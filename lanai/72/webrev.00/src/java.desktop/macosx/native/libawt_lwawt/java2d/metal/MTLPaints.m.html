<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;
 37 #import &quot;MTLBufImgOps.h&quot;
 38 #include &quot;MTLRenderQueue.h&quot;
 39 
 40 #define RGBA_TO_V4(c)              \
 41 {                                  \
 42     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 43     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 44     ((c) &amp; 0xFF)/255.0f,           \
 45     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 46 }
 47 
 48 #define FLOAT_ARR_TO_V4(p) \
 49 {                      \
 50     p[0], \
 51     p[1], \
 52     p[2], \
 53     p[3]  \
 54 }
 55 
 56 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 57 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 58 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 59 
 60 static void initTemplatePipelineDescriptors() {
 61     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 62         return;
 63 
 64     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 65     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 66     vertDesc.attributes[VertexAttributePosition].offset = 0;
 67     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 68     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 69     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 70     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 71 
 72     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 73     templateRenderPipelineDesc.sampleCount = 1;
 74     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 75     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 76     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 77 
 78     templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
 79     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 80     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 81     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 82     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 83     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 84     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 85     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 86 
 87     templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
 88     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 89     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 90     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 91     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 92     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 93 
 94 }
 95 
 96 @implementation MTLPaint {
 97     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 98     jint          _paintState;
 99 
100     // color-mode
101     jint          _color;
102 
103     // lin-grad-mode
104     jdouble       _p0;
105     jdouble       _p1;
106     jdouble       _p3;
107     jboolean      _cyclic;
108     jint          _pixel1;
109     jint          _pixel2;
110     jboolean      _useMask;
111 
112     // texture paint
113     id&lt;MTLTexture&gt; _paintTexture;
114     struct AnchorData _anchor;
115 }
116 
117 - (id)init {
118     self = [super init];
119     if (self) {
120         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
121     }
122     return self;
123 }
124 
125 - (BOOL)isEqual:(MTLPaint *)other {
126     if (self == other)
127         return YES;
128     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
129         return _paintState == other-&gt;_paintState;
130     if (_paintState != other-&gt;_paintState)
131         return NO;
132     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
133         return _p0 == other-&gt;_p0
134                &amp;&amp; _p1 == other-&gt;_p1
135                &amp;&amp; _p3 == other-&gt;_p3
136                &amp;&amp; _pixel1 == other-&gt;_pixel1
137                &amp;&amp; _pixel2 == other-&gt;_pixel2;
138     }
139     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
140         return _color == other-&gt;_color;
141     }
142     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
143         return _paintTexture == other-&gt;_paintTexture
144                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
145                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
146                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
147                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
148                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
149                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
150     }
151 
152     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
153     return NO;
154 }
155 
156 - (void)copyFrom:(MTLPaint *)other {
157     _paintState = other-&gt;_paintState;
158     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
159         return;
160 
161     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
162         _p0 = other-&gt;_p0;
163         _p1 = other-&gt;_p1;
164         _p3 = other-&gt;_p3;
165         _pixel1 = other-&gt;_pixel1;
166         _pixel2 = other-&gt;_pixel2;
167         return;
168     }
169     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
170         _color = other-&gt;_color;
171         return;
172     }
173 
174     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
175         _color = other-&gt;_color;
176         _paintTexture = other-&gt;_paintTexture;
177         _anchor = other-&gt;_anchor;
178         return;
179     }
180 
181     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
182 }
183 
184 - (NSString *)getDescription {
185     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
186         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
187     }
188     
189     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
190         return [NSString stringWithFormat:@&quot;gradient&quot;];
191     }
192 
193     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
194         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
195     }
196 
197     return @&quot;unknown-paint&quot;;
198 }
199 
200 - (jint)getColor {
201     return _color;
202 }
203 
204 - (void)reset {
205     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
206     _paintTexture = nil;
207     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
208     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
209 }
210 
211 - (void)setColor:(jint)pixelColor {
212     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
213     _color = pixelColor;
214 }
215 
216 - (void)setGradientUseMask:(jboolean)useMask
217                     cyclic:(jboolean)cyclic
218                         p0:(jdouble)p0
219                         p1:(jdouble)p1
220                         p3:(jdouble)p3
221                     pixel1:(jint)pixel1
222                     pixel2:(jint)pixel2
223 {
224     //TODO Resolve gradient distribution problem
225     //TODO Implement useMask
226     //TODO Implement cyclic
227     //fprintf(stderr,
228     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
229     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
230     //        p0, p1, p3, pixel1, pixel2);
231 
232     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
233     _useMask = useMask;
234     _pixel1 = pixel1;
235     _pixel2 = pixel2;
236     _p0 = p0;
237     _p1 = p1;
238     _p3 = p3;
239     _cyclic = cyclic;
240 }
241 
242 - (void)setLinearGradient:(jboolean)useMask
243                    linear:(jboolean)linear
244               cycleMethod:(jboolean)cycleMethod
245                  numStops:(jint)numStops
246                        p0:(jfloat)p0
247                        p1:(jfloat)p1
248                        p3:(jfloat)p3
249                 fractions:(void *)fractions
250                    pixels:(void *)pixels
251 {
252     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
253     [self setColor:0];
254 }
255 
256 - (void)setRadialGradient:(jboolean)useMask
257                    linear:(jboolean)linear
258               cycleMethod:(jboolean)cycleMethod
259                  numStops:(jint)numStops
260                       m00:(jfloat)m00
261                       m01:(jfloat)m01
262                       m02:(jfloat)m02
263                       m10:(jfloat)m10
264                       m11:(jfloat)m11
265                       m12:(jfloat)m12
266                    focusX:(jfloat)focusX
267                 fractions:(void *)fractions
268                    pixels:(void *)pixels
269 {
270     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
271     [self setColor:0];
272 }
273 
274 - (void)setTexture:(jboolean)useMask
275            textureID:(id&lt;MTLTexture&gt;)textureID
276             filter:(jboolean)filter
277                xp0:(jdouble)xp0
278                xp1:(jdouble)xp1
279                xp3:(jdouble)xp3
280                yp0:(jdouble)yp0
281                yp1:(jdouble)yp1
282                yp3:(jdouble)yp3
283 {
284     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
285     _paintTexture = textureID;
286     
287     _anchor.xParams[0] = xp0;
288     _anchor.xParams[1] = xp1;
289     _anchor.xParams[2] = xp3;
290 
291     _anchor.yParams[0] = yp0;
292     _anchor.yParams[1] = yp1;
293     _anchor.yParams[2] = yp3;
294 }
295 
296 static id&lt;MTLSamplerState&gt; samplerNearestClamp = nil;
297 static id&lt;MTLSamplerState&gt; samplerLinearClamp = nil;
298 static id&lt;MTLSamplerState&gt; samplerNearestRepeat = nil;
299 static id&lt;MTLSamplerState&gt; samplerLinearRepeat = nil;
300 
301 void initSamplers(id&lt;MTLDevice&gt; device) {
302     // TODO: move this code into SamplerManager (need implement)
303 
304     if (samplerNearestClamp != nil)
305         return;
306 
307     MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];
308 
309     samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;
310     samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;
311     samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;
312 
313     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
314     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
315     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
316 
317     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
318     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
319     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
320 
321     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
322     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
323     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
324 
325     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
326     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
327     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
328 
329     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
330     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
331     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
332 }
333 
334 static void setSampler(id&lt;MTLRenderCommandEncoder&gt; encoder, int interpolation, bool repeat) {
335     id&lt;MTLSamplerState&gt; sampler;
336     if (repeat) {
337         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
338     } else {
339         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
340     }
341     [encoder setFragmentSamplerState:sampler atIndex:0];
342 }
343 
344 static void setTxtUniforms(
345         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
346         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
347 ) {
348     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, extraAlpha};
349     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
350 
351     setSampler(encoder, interpolation, repeat);
352 }
353 
354 // For the current paint mode:
355 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
356 // 2. Set vertex and fragment buffers
357 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
358                  context:(MTLContext *)mtlc
359            renderOptions:(const RenderOptions *)renderOptions
360     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
361 {
362     initTemplatePipelineDescriptors();
363 
364     NSString * vertShader = @&quot;vert_txt&quot;;
365     NSString * fragShader = @&quot;frag_txt&quot;;
366     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
367 
368     if (renderOptions-&gt;isTexture) {
369         NSObject *bufImgOp = [mtlc getBufImgOp];
370         if (bufImgOp != nil) {
371             if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
372                 MTLRescaleOp *rescaleOp = bufImgOp;
373                 vertShader = @&quot;vert_txt&quot;;
374                 fragShader = @&quot;frag_txt_op_rescale&quot;;
375 
376                 struct TxtFrameOpRescaleUniforms uf = {
377                         RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions-&gt;srcFlags.isOpaque,
378                         rescaleOp.isNonPremult,
379                         FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])
380                 };
381                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
382                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
383             } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {
384                 MTLConvolveOp * convolveOp = bufImgOp;
385                 vertShader = @&quot;vert_txt&quot;;
386                 fragShader = @&quot;frag_txt_op_convolve&quot;;
387 
388                 struct TxtFrameOpConvolveUniforms uf = {
389                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),
390                         convolveOp.kernelSize, convolveOp.isEdgeZeroFill,
391                 };
392                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
393                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
394 
395                 [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];
396             } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {
397                 MTLLookupOp * lookupOp = bufImgOp;
398                 vertShader = @&quot;vert_txt&quot;;
399                 fragShader = @&quot;frag_txt_op_lookup&quot;;
400 
401                 struct TxtFrameOpLookupUniforms uf = {
402                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),
403                         lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,
404                 };
405                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
406                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
407                 [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];
408             }
409         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
410             vertShader = @&quot;vert_txt_tp&quot;;
411             fragShader = @&quot;frag_txt_tp&quot;;
412             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
413             [encoder setFragmentTexture:_paintTexture atIndex:1];
414 
415             setTxtUniforms(encoder, 0, 0, renderOptions-&gt;interpolation, YES, [mtlc.composite getExtraAlpha],
416                            &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
417         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
418             vertShader = @&quot;vert_txt_grad&quot;;
419             fragShader = @&quot;frag_txt_grad&quot;;
420             struct GradFrameUniforms uf = {
421                     {_p0, _p1, _p3},
422                     RGBA_TO_V4(_pixel1),
423                     RGBA_TO_V4(_pixel2)};
424             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
425 
426         } else {
427             vertShader = @&quot;vert_txt&quot;;
428             fragShader = @&quot;frag_txt&quot;;
429             if (renderOptions-&gt;isAA) {
430                 fragShader = @&quot;aa_frag_txt&quot;;
431                 rpDesc = templateAATexturePipelineDesc;
432             }
433 
434             setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
435                            renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags,
436                            &amp;renderOptions-&gt;dstFlags);
437         }
438     } else {
439         rpDesc = templateRenderPipelineDesc;
440 
441         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
442             vertShader = @&quot;vert_col&quot;;
443             fragShader = @&quot;frag_col&quot;;
444 
445             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
446             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
447         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
448             vertShader = @&quot;vert_grad&quot;;
449             fragShader = @&quot;frag_grad&quot;;
450 
451             struct GradFrameUniforms uf = {
452                     {_p0, _p1, _p3},
453                     RGBA_TO_V4(_pixel1),
454                     RGBA_TO_V4(_pixel2)};
455             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
456         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
457             vertShader = @&quot;vert_tp&quot;;
458             fragShader = @&quot;frag_tp&quot;;
459 
460             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
461             [encoder setFragmentTexture:_paintTexture atIndex:0];
462 
463         }
464     }
465 
466     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
467                                                                         vertexShaderId:vertShader
468                                                                       fragmentShaderId:fragShader
469                                                                              composite:mtlc.composite
470                                                                          renderOptions:renderOptions
471                                                                          stencilNeeded:[mtlc.clip isShape]];
472     [encoder setRenderPipelineState:pipelineState];
473 }
474 
475 
476 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
477 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
478 // 2. Set vertex and fragment buffers
479 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
480                         context:(MTLContext *)mtlc
481                   renderOptions:(const RenderOptions *)renderOptions
482            pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
483 {
484     initTemplatePipelineDescriptors();
485 
486     jint xorColor = (jint) [mtlc.composite getXorColor];
487 
488     NSString * vertShader = @&quot;vert_txt_xorMode&quot;;
489     NSString * fragShader = @&quot;frag_txt_xorMode&quot;;
490     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
491 
492     if (renderOptions-&gt;isTexture) {
493         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
494         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
495                        renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha],
496                        &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
497         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
498 
499         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
500         [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
501 
502         J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- TEXTURE DRAW&quot;);
503     } else {
504         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
505             vertShader = @&quot;vert_col_xorMode&quot;;
506             fragShader = @&quot;frag_col_xorMode&quot;;
507             rpDesc = templateRenderPipelineDesc;
508 
509             // Calculate _color ^ xorColor for RGB components
510             // This color gets XORed with destination framebuffer pixel color
511             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
512             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
513 
514             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
515             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:0];
516 
517             J2dTraceLn(J2D_TRACE_INFO ,&quot;MTLPaints - setXorModePipelineState -- PAINT_ALPHACOLOR&quot;);
518         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
519             // This block is not reached in current implementation.
520             // Gradient paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)
521             vertShader = @&quot;vert_grad_xorMode&quot;;
522             fragShader = @&quot;frag_grad_xorMode&quot;;
523             rpDesc = templateRenderPipelineDesc;
524 
525             struct GradFrameUniforms uf = {
526                         {_p0, _p1, _p3},
527                         RGBA_TO_V4(_pixel1 ^ xorColor),
528                         RGBA_TO_V4(_pixel2 ^ xorColor)};
529 
530             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
531             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
532             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:0];
533 
534             J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- PAINT_GRADIENT&quot;);
535         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
536             // This block is not reached in current implementation.
537             // Texture paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)
538             vertShader = @&quot;vert_tp_xorMode&quot;;
539             fragShader = @&quot;frag_tp_xorMode&quot;;
540             rpDesc = templateRenderPipelineDesc;
541 
542             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
543             [encoder setFragmentTexture:_paintTexture atIndex: 0];
544             BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
545             [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
546             [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
547 
548             J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints - setXorModePipelineState -- PAINT_TEXTURE&quot;);
549         }
550     }
551 
552     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
553                                                                         vertexShaderId:vertShader
554                                                                       fragmentShaderId:fragShader
555                                                                              composite:mtlc.composite
556                                                                          renderOptions:renderOptions
557                                                                          stencilNeeded:[mtlc.clip isShape]];
558     [encoder setRenderPipelineState:pipelineState];
559 }
560 
561 @end
562 
563 /************************* GradientPaint support ****************************/
564 
565 static void
566 MTLPaints_InitGradientTexture()
567 {
568     //TODO
569     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
570 }
571 
572 /****************** Shared MultipleGradientPaint support ********************/
573 
574 /**
575  * These constants are identical to those defined in the
576  * MultipleGradientPaint.CycleMethod enum; they are copied here for
577  * convenience (ideally we would pull them directly from the Java level,
578  * but that entails more hassle than it is worth).
579  */
580 #define CYCLE_NONE    0
581 #define CYCLE_REFLECT 1
582 #define CYCLE_REPEAT  2
583 
584 /**
585  * The following constants are flags that can be bitwise-or&#39;ed together
586  * to control how the MultipleGradientPaint shader source code is generated:
587  *
588  *   MULTI_CYCLE_METHOD
589  *     Placeholder for the CycleMethod enum constant.
590  *
591  *   MULTI_LARGE
592  *     If set, use the (slower) shader that supports a larger number of
593  *     gradient colors; otherwise, use the optimized codepath.  See
594  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
595  *
596  *   MULTI_USE_MASK
597  *     If set, apply the alpha mask value from texture unit 0 to the
598  *     final color result (only used in the MaskFill case).
599  *
600  *   MULTI_LINEAR_RGB
601  *     If set, convert the linear RGB result back into the sRGB color space.
602  */
603 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
604 #define MULTI_LARGE        (1 &lt;&lt; 2)
605 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
606 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
607 
608 /**
609  * This value determines the size of the array of programs for each
610  * MultipleGradientPaint type.  This value reflects the maximum value that
611  * can be represented by performing a bitwise-or of all the MULTI_*
612  * constants defined above.
613  */
614 #define MAX_PROGRAMS 32
615 
616 /** Evaluates to true if the given bit is set on the local flags variable. */
617 #define IS_SET(flagbit) \
618     (((flags) &amp; (flagbit)) != 0)
619 
620 /** Composes the given parameters as flags into the given flags variable.*/
621 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
622     do {                                                   \
623         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
624         if (large)   flags |= MULTI_LARGE;                 \
625         if (useMask) flags |= MULTI_USE_MASK;              \
626         if (linear)  flags |= MULTI_LINEAR_RGB;            \
627     } while (0)
628 
629 /** Extracts the CycleMethod enum value from the given flags variable. */
630 #define EXTRACT_CYCLE_METHOD(flags) \
631     ((flags) &amp; MULTI_CYCLE_METHOD)
632 
633 /**
634  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
635  * and related code.  When the MULTI_LARGE flag is set, we will use
636  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
637  * two separate values, we can have one highly optimized shader (SMALL) that
638  * supports only a few fractions/colors, and then another, less optimal
639  * shader that supports more stops.
640  */
641 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
642 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
643 #define MAX_FRACTIONS_SMALL 4
644 
645 /**
646  * The maximum number of gradient colors supported by all of the gradient
647  * fragment shaders.  Note that this value must be a power of two, as it
648  * determines the size of the 1D texture created below.  It also must be
649  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
650  * that the two values be equal).
651  */
652 #define MAX_COLORS 16
653 
654 /**
655  * The handle to the gradient color table texture object used by the shaders.
656  */
657 static jint multiGradientTexID = 0;
658 
659 /**
660  * This is essentially a template of the shader source code that can be used
661  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
662  * structure and some variables that are common to each; the remaining
663  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
664  * are filled in prior to compiling the shader at runtime depending on the
665  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
666  */
667 static const char *multiGradientShaderSource =
668     // gradient texture size (in texels)
669     &quot;const int TEXTURE_SIZE = %d;&quot;
670     // maximum number of fractions/colors supported by this shader
671     &quot;const int MAX_FRACTIONS = %d;&quot;
672     // size of a single texel
673     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
674     // size of half of a single texel
675     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
676     // texture containing the gradient colors
677     &quot;uniform sampler1D colors;&quot;
678     // array of gradient stops/fractions
679     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
680     // array of scale factors (one for each interval)
681     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
682     // (placeholder for mask variable)
683     &quot;%s&quot;
684     // (placeholder for Linear/RadialGP-specific variables)
685     &quot;%s&quot;
686     &quot;&quot;
687     &quot;void main(void)&quot;
688     &quot;{&quot;
689     &quot;    float dist;&quot;
690          // (placeholder for Linear/RadialGradientPaint-specific code)
691     &quot;    %s&quot;
692     &quot;&quot;
693     &quot;    float tc;&quot;
694          // (placeholder for CycleMethod-specific code)
695     &quot;    %s&quot;
696     &quot;&quot;
697          // calculate interpolated color
698     &quot;    vec4 result = texture1D(colors, tc);&quot;
699     &quot;&quot;
700          // (placeholder for ColorSpace conversion code)
701     &quot;    %s&quot;
702     &quot;&quot;
703          // (placeholder for mask modulation code)
704     &quot;    %s&quot;
705     &quot;&quot;
706          // modulate with gl_Color in order to apply extra alpha
707     &quot;    gl_FragColor = result * gl_Color;&quot;
708     &quot;}&quot;;
709 
710 /**
711  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
712  * LGP/RGP-specific code) in the range [0,1] and produces a texture
713  * coordinate value &quot;tc&quot; that represents the position of the chosen color
714  * in the one-dimensional gradient texture (also in the range [0,1]).
715  *
716  * One naive way to implement this would be to iterate through the fractions
717  * to figure out in which interval &quot;dist&quot; falls, and then compute the
718  * relative distance between the two nearest stops.  This approach would
719  * require an &quot;if&quot; check on every iteration, and it is best to avoid
720  * conditionals in fragment shaders for performance reasons.  Also, one might
721  * be tempted to use a break statement to jump out of the loop once the
722  * interval was found, but break statements (and non-constant loop bounds)
723  * are not natively available on most graphics hardware today, so that is
724  * a non-starter.
725  *
726  * The more optimal approach used here avoids these issues entirely by using
727  * an accumulation function that is equivalent to the process described above.
728  * The scaleFactors array is pre-initialized at enable time as follows:
729  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
730  *
731  * For each iteration, we subtract fractions[i] from dist and then multiply
732  * that value by scaleFactors[i].  If we are within the target interval,
733  * this value will be a fraction in the range [0,1] indicating the relative
734  * distance between fraction[i] and fraction[i+1].  If we are below the
735  * target interval, this value will be negative, so we clamp it to zero
736  * to avoid accumulating any value.  If we are above the target interval,
737  * the value will be greater than one, so we clamp it to one.  Upon exiting
738  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
739  * fractional value.  This accumulated value tells us the position of the
740  * fragment color in the one-dimensional gradient texture, i.e., the
741  * texcoord called &quot;tc&quot;.
742  */
743 static const char *texCoordCalcCode =
744     &quot;int i;&quot;
745     &quot;float relFraction = 0.0;&quot;
746     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
747     &quot;    relFraction +=&quot;
748     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
749     &quot;}&quot;
750     // we offset by half a texel so that we find the linearly interpolated
751     // color between the two texel centers of interest
752     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
753 
754 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
755 static const char *noCycleCode =
756     &quot;if (dist &lt;= 0.0) {&quot;
757     &quot;    tc = 0.0;&quot;
758     &quot;} else if (dist &gt;= 1.0) {&quot;
759     &quot;    tc = 1.0;&quot;
760     &quot;} else {&quot;
761          // (placeholder for texcoord calculation)
762     &quot;    %s&quot;
763     &quot;}&quot;;
764 
765 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
766 static const char *reflectCode =
767     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
768     // (placeholder for texcoord calculation)
769     &quot;%s&quot;;
770 
771 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
772 static const char *repeatCode =
773     &quot;dist = fract(dist);&quot;
774     // (placeholder for texcoord calculation)
775     &quot;%s&quot;;
776 
777 static void
778 MTLPaints_InitMultiGradientTexture()
779 {
780     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
781 }
782 
783 /**
784  * Compiles and links the MultipleGradientPaint shader program.  If
785  * successful, this function returns a handle to the newly created
786  * shader program; otherwise returns 0.
787  */
788 static void*
789 MTLPaints_CreateMultiGradProgram(jint flags,
790                                  char *paintVars, char *distCode)
791 {
792 
793     //TODO
794     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
795 
796     return NULL;
797 }
798 
799 /**
800  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
801  * in order to setup the fraction/color values that are common to both.
802  */
803 static void
804 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
805                                 jint numStops,
806                                 void *pFractions, void *pPixels)
807 {
808     //TODO
809     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
810 
811 }
812 
813 /********************** LinearGradientPaint support *************************/
814 
815 /**
816  * The handles to the LinearGradientPaint fragment program objects.  The
817  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
818  * above.  Note that most applications will likely need to initialize one
819  * or two of these elements, so the array is usually sparsely populated.
820  */
821 static void* linearGradPrograms[MAX_PROGRAMS];
822 
823 /**
824  * Compiles and links the LinearGradientPaint shader program.  If successful,
825  * this function returns a handle to the newly created shader program;
826  * otherwise returns 0.
827  */
828 static void*
829 MTLPaints_CreateLinearGradProgram(jint flags)
830 {
831     char *paintVars;
832     char *distCode;
833 
834     J2dTraceLn1(J2D_TRACE_INFO,
835                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
836                 flags);
837 
838     /*
839      * To simplify the code and to make it easier to upload a number of
840      * uniform values at once, we pack a bunch of scalar (float) values
841      * into vec3 values below.  Here&#39;s how the values are related:
842      *
843      *   params.x = p0
844      *   params.y = p1
845      *   params.z = p3
846      *
847      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
848      */
849     paintVars =
850         &quot;uniform vec3 params;&quot;
851         &quot;uniform float yoff;&quot;;
852     distCode =
853         // note that gl_FragCoord is in window space relative to the
854         // lower-left corner, so we have to flip the y-coordinate here
855         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
856         &quot;dist = dot(params, fragCoord);&quot;;
857 
858     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
859 }
860 
861 /********************** RadialGradientPaint support *************************/
862 
863 /**
864  * The handles to the RadialGradientPaint fragment program objects.  The
865  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
866  * above.  Note that most applications will likely need to initialize one
867  * or two of these elements, so the array is usually sparsely populated.
868  */
869 static void* radialGradPrograms[MAX_PROGRAMS];
870 
871 /**
872  * Compiles and links the RadialGradientPaint shader program.  If successful,
873  * this function returns a handle to the newly created shader program;
874  * otherwise returns 0.
875  */
876 static void*
877 MTLPaints_CreateRadialGradProgram(jint flags)
878 {
879     char *paintVars;
880     char *distCode;
881 
882     J2dTraceLn1(J2D_TRACE_INFO,
883                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
884                 flags);
885 
886     /*
887      * To simplify the code and to make it easier to upload a number of
888      * uniform values at once, we pack a bunch of scalar (float) values
889      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
890      *
891      *   m0.x = m00
892      *   m0.y = m01
893      *   m0.z = m02
894      *
895      *   m1.x = m10
896      *   m1.y = m11
897      *   m1.z = m12
898      *
899      *   precalc.x = focusX
900      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
901      *   precalc.z = 1.0 - (focusX * focusX)
902      *   precalc.w = 1.0 / precalc.z
903      */
904     paintVars =
905         &quot;uniform vec3 m0;&quot;
906         &quot;uniform vec3 m1;&quot;
907         &quot;uniform vec4 precalc;&quot;;
908 
909     /*
910      * The following code is derived from Daniel Rice&#39;s whitepaper on
911      * radial gradient performance (attached to the bug report for 6521533).
912      * Refer to that document as well as the setup code in the Java-level
913      * BufferedPaints.setRadialGradientPaint() method for more details.
914      */
915     distCode =
916         // note that gl_FragCoord is in window space relative to the
917         // lower-left corner, so we have to flip the y-coordinate here
918         &quot;vec3 fragCoord =&quot;
919         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
920         &quot;float x = dot(fragCoord, m0);&quot;
921         &quot;float y = dot(fragCoord, m1);&quot;
922         &quot;float xfx = x - precalc.x;&quot;
923         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
924 
925     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
926 }
927 
928 #endif /* !HEADLESS */
    </pre>
  </body>
</html>