<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/vm_version_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;logging/logStream.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  35 #include &quot;runtime/vm_version.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  36 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  37 #include &quot;utilities/virtualizationSupport.hpp&quot;
  38 
  39 #include OS_HEADER_INLINE(os)
  40 
  41 int VM_Version::_cpu;
  42 int VM_Version::_model;
  43 int VM_Version::_stepping;
<a name="2" id="anc2"></a><span class="line-added">  44 bool VM_Version::_has_intel_jcc_erratum;</span>
  45 VM_Version::CpuidInfo VM_Version::_cpuid_info = { 0, };
  46 
  47 // Address of instruction which causes SEGV
  48 address VM_Version::_cpuinfo_segv_addr = 0;
  49 // Address of instruction after the one which causes SEGV
  50 address VM_Version::_cpuinfo_cont_addr = 0;
  51 
  52 static BufferBlob* stub_blob;
  53 static const int stub_size = 1100;
  54 
  55 extern &quot;C&quot; {
  56   typedef void (*get_cpu_info_stub_t)(void*);
  57 }
  58 static get_cpu_info_stub_t get_cpu_info_stub = NULL;
  59 
  60 
  61 class VM_Version_StubGenerator: public StubCodeGenerator {
  62  public:
  63 
  64   VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
  65 
  66   address generate_get_cpu_info() {
  67     // Flags to test CPU type.
  68     const uint32_t HS_EFL_AC = 0x40000;
  69     const uint32_t HS_EFL_ID = 0x200000;
  70     // Values for when we don&#39;t have a CPUID instruction.
  71     const int      CPU_FAMILY_SHIFT = 8;
  72     const uint32_t CPU_FAMILY_386 = (3 &lt;&lt; CPU_FAMILY_SHIFT);
  73     const uint32_t CPU_FAMILY_486 = (4 &lt;&lt; CPU_FAMILY_SHIFT);
  74     bool use_evex = FLAG_IS_DEFAULT(UseAVX) || (UseAVX &gt; 2);
  75 
  76     Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;
  77     Label sef_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7, ext_cpuid8, done, wrapup;
  78     Label legacy_setup, save_restore_except, legacy_save_restore, start_simd_check;
  79 
  80     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;get_cpu_info_stub&quot;);
  81 #   define __ _masm-&gt;
  82 
  83     address start = __ pc();
  84 
  85     //
  86     // void get_cpu_info(VM_Version::CpuidInfo* cpuid_info);
  87     //
  88     // LP64: rcx and rdx are first and second argument registers on windows
  89 
  90     __ push(rbp);
  91 #ifdef _LP64
  92     __ mov(rbp, c_rarg0); // cpuid_info address
  93 #else
  94     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
  95 #endif
  96     __ push(rbx);
  97     __ push(rsi);
  98     __ pushf();          // preserve rbx, and flags
  99     __ pop(rax);
 100     __ push(rax);
 101     __ mov(rcx, rax);
 102     //
 103     // if we are unable to change the AC flag, we have a 386
 104     //
 105     __ xorl(rax, HS_EFL_AC);
 106     __ push(rax);
 107     __ popf();
 108     __ pushf();
 109     __ pop(rax);
 110     __ cmpptr(rax, rcx);
 111     __ jccb(Assembler::notEqual, detect_486);
 112 
 113     __ movl(rax, CPU_FAMILY_386);
 114     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 115     __ jmp(done);
 116 
 117     //
 118     // If we are unable to change the ID flag, we have a 486 which does
 119     // not support the &quot;cpuid&quot; instruction.
 120     //
 121     __ bind(detect_486);
 122     __ mov(rax, rcx);
 123     __ xorl(rax, HS_EFL_ID);
 124     __ push(rax);
 125     __ popf();
 126     __ pushf();
 127     __ pop(rax);
 128     __ cmpptr(rcx, rax);
 129     __ jccb(Assembler::notEqual, detect_586);
 130 
 131     __ bind(cpu486);
 132     __ movl(rax, CPU_FAMILY_486);
 133     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 134     __ jmp(done);
 135 
 136     //
 137     // At this point, we have a chip which supports the &quot;cpuid&quot; instruction
 138     //
 139     __ bind(detect_586);
 140     __ xorl(rax, rax);
 141     __ cpuid();
 142     __ orl(rax, rax);
 143     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn&#39;t support an input
 144                                         // value of at least 1, we give up and
 145                                         // assume a 486
 146     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 147     __ movl(Address(rsi, 0), rax);
 148     __ movl(Address(rsi, 4), rbx);
 149     __ movl(Address(rsi, 8), rcx);
 150     __ movl(Address(rsi,12), rdx);
 151 
 152     __ cmpl(rax, 0xa);                  // Is cpuid(0xB) supported?
 153     __ jccb(Assembler::belowEqual, std_cpuid4);
 154 
 155     //
 156     // cpuid(0xB) Processor Topology
 157     //
 158     __ movl(rax, 0xb);
 159     __ xorl(rcx, rcx);   // Threads level
 160     __ cpuid();
 161 
 162     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB0_offset())));
 163     __ movl(Address(rsi, 0), rax);
 164     __ movl(Address(rsi, 4), rbx);
 165     __ movl(Address(rsi, 8), rcx);
 166     __ movl(Address(rsi,12), rdx);
 167 
 168     __ movl(rax, 0xb);
 169     __ movl(rcx, 1);     // Cores level
 170     __ cpuid();
 171     __ push(rax);
 172     __ andl(rax, 0x1f);  // Determine if valid topology level
 173     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 174     __ andl(rax, 0xffff);
 175     __ pop(rax);
 176     __ jccb(Assembler::equal, std_cpuid4);
 177 
 178     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB1_offset())));
 179     __ movl(Address(rsi, 0), rax);
 180     __ movl(Address(rsi, 4), rbx);
 181     __ movl(Address(rsi, 8), rcx);
 182     __ movl(Address(rsi,12), rdx);
 183 
 184     __ movl(rax, 0xb);
 185     __ movl(rcx, 2);     // Packages level
 186     __ cpuid();
 187     __ push(rax);
 188     __ andl(rax, 0x1f);  // Determine if valid topology level
 189     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 190     __ andl(rax, 0xffff);
 191     __ pop(rax);
 192     __ jccb(Assembler::equal, std_cpuid4);
 193 
 194     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB2_offset())));
 195     __ movl(Address(rsi, 0), rax);
 196     __ movl(Address(rsi, 4), rbx);
 197     __ movl(Address(rsi, 8), rcx);
 198     __ movl(Address(rsi,12), rdx);
 199 
 200     //
 201     // cpuid(0x4) Deterministic cache params
 202     //
 203     __ bind(std_cpuid4);
 204     __ movl(rax, 4);
 205     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x4) supported?
 206     __ jccb(Assembler::greater, std_cpuid1);
 207 
 208     __ xorl(rcx, rcx);   // L1 cache
 209     __ cpuid();
 210     __ push(rax);
 211     __ andl(rax, 0x1f);  // Determine if valid cache parameters used
 212     __ orl(rax, rax);    // eax[4:0] == 0 indicates invalid cache
 213     __ pop(rax);
 214     __ jccb(Assembler::equal, std_cpuid1);
 215 
 216     __ lea(rsi, Address(rbp, in_bytes(VM_Version::dcp_cpuid4_offset())));
 217     __ movl(Address(rsi, 0), rax);
 218     __ movl(Address(rsi, 4), rbx);
 219     __ movl(Address(rsi, 8), rcx);
 220     __ movl(Address(rsi,12), rdx);
 221 
 222     //
 223     // Standard cpuid(0x1)
 224     //
 225     __ bind(std_cpuid1);
 226     __ movl(rax, 1);
 227     __ cpuid();
 228     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 229     __ movl(Address(rsi, 0), rax);
 230     __ movl(Address(rsi, 4), rbx);
 231     __ movl(Address(rsi, 8), rcx);
 232     __ movl(Address(rsi,12), rdx);
 233 
 234     //
 235     // Check if OS has enabled XGETBV instruction to access XCR0
 236     // (OSXSAVE feature flag) and CPU supports AVX
 237     //
 238     __ andl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 239     __ cmpl(rcx, 0x18000000);
 240     __ jccb(Assembler::notEqual, sef_cpuid); // jump if AVX is not supported
 241 
 242     //
 243     // XCR0, XFEATURE_ENABLED_MASK register
 244     //
 245     __ xorl(rcx, rcx);   // zero for XCR0 register
 246     __ xgetbv();
 247     __ lea(rsi, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset())));
 248     __ movl(Address(rsi, 0), rax);
 249     __ movl(Address(rsi, 4), rdx);
 250 
 251     //
 252     // cpuid(0x7) Structured Extended Features
 253     //
 254     __ bind(sef_cpuid);
 255     __ movl(rax, 7);
 256     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x7) supported?
 257     __ jccb(Assembler::greater, ext_cpuid);
 258 
 259     __ xorl(rcx, rcx);
 260     __ cpuid();
 261     __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 262     __ movl(Address(rsi, 0), rax);
 263     __ movl(Address(rsi, 4), rbx);
 264     __ movl(Address(rsi, 8), rcx);
 265     __ movl(Address(rsi, 12), rdx);
 266 
 267     //
 268     // Extended cpuid(0x80000000)
 269     //
 270     __ bind(ext_cpuid);
 271     __ movl(rax, 0x80000000);
 272     __ cpuid();
 273     __ cmpl(rax, 0x80000000);     // Is cpuid(0x80000001) supported?
 274     __ jcc(Assembler::belowEqual, done);
 275     __ cmpl(rax, 0x80000004);     // Is cpuid(0x80000005) supported?
 276     __ jcc(Assembler::belowEqual, ext_cpuid1);
 277     __ cmpl(rax, 0x80000006);     // Is cpuid(0x80000007) supported?
 278     __ jccb(Assembler::belowEqual, ext_cpuid5);
 279     __ cmpl(rax, 0x80000007);     // Is cpuid(0x80000008) supported?
 280     __ jccb(Assembler::belowEqual, ext_cpuid7);
 281     __ cmpl(rax, 0x80000008);     // Is cpuid(0x80000009 and above) supported?
 282     __ jccb(Assembler::belowEqual, ext_cpuid8);
 283     __ cmpl(rax, 0x8000001E);     // Is cpuid(0x8000001E) supported?
 284     __ jccb(Assembler::below, ext_cpuid8);
 285     //
 286     // Extended cpuid(0x8000001E)
 287     //
 288     __ movl(rax, 0x8000001E);
 289     __ cpuid();
 290     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1E_offset())));
 291     __ movl(Address(rsi, 0), rax);
 292     __ movl(Address(rsi, 4), rbx);
 293     __ movl(Address(rsi, 8), rcx);
 294     __ movl(Address(rsi,12), rdx);
 295 
 296     //
 297     // Extended cpuid(0x80000008)
 298     //
 299     __ bind(ext_cpuid8);
 300     __ movl(rax, 0x80000008);
 301     __ cpuid();
 302     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid8_offset())));
 303     __ movl(Address(rsi, 0), rax);
 304     __ movl(Address(rsi, 4), rbx);
 305     __ movl(Address(rsi, 8), rcx);
 306     __ movl(Address(rsi,12), rdx);
 307 
 308     //
 309     // Extended cpuid(0x80000007)
 310     //
 311     __ bind(ext_cpuid7);
 312     __ movl(rax, 0x80000007);
 313     __ cpuid();
 314     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid7_offset())));
 315     __ movl(Address(rsi, 0), rax);
 316     __ movl(Address(rsi, 4), rbx);
 317     __ movl(Address(rsi, 8), rcx);
 318     __ movl(Address(rsi,12), rdx);
 319 
 320     //
 321     // Extended cpuid(0x80000005)
 322     //
 323     __ bind(ext_cpuid5);
 324     __ movl(rax, 0x80000005);
 325     __ cpuid();
 326     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid5_offset())));
 327     __ movl(Address(rsi, 0), rax);
 328     __ movl(Address(rsi, 4), rbx);
 329     __ movl(Address(rsi, 8), rcx);
 330     __ movl(Address(rsi,12), rdx);
 331 
 332     //
 333     // Extended cpuid(0x80000001)
 334     //
 335     __ bind(ext_cpuid1);
 336     __ movl(rax, 0x80000001);
 337     __ cpuid();
 338     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1_offset())));
 339     __ movl(Address(rsi, 0), rax);
 340     __ movl(Address(rsi, 4), rbx);
 341     __ movl(Address(rsi, 8), rcx);
 342     __ movl(Address(rsi,12), rdx);
 343 
 344     //
 345     // Check if OS has enabled XGETBV instruction to access XCR0
 346     // (OSXSAVE feature flag) and CPU supports AVX
 347     //
 348     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 349     __ movl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 350     __ andl(rcx, Address(rsi, 8)); // cpuid1 bits osxsave | avx
 351     __ cmpl(rcx, 0x18000000);
 352     __ jccb(Assembler::notEqual, done); // jump if AVX is not supported
 353 
 354     __ movl(rax, 0x6);
 355     __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 356     __ cmpl(rax, 0x6);
 357     __ jccb(Assembler::equal, start_simd_check); // return if AVX is not supported
 358 
 359     // we need to bridge farther than imm8, so we use this island as a thunk
 360     __ bind(done);
 361     __ jmp(wrapup);
 362 
 363     __ bind(start_simd_check);
 364     //
 365     // Some OSs have a bug when upper 128/256bits of YMM/ZMM
 366     // registers are not restored after a signal processing.
 367     // Generate SEGV here (reference through NULL)
 368     // and check upper YMM/ZMM bits after it.
 369     //
 370     intx saved_useavx = UseAVX;
 371     intx saved_usesse = UseSSE;
 372 
 373     // If UseAVX is unitialized or is set by the user to include EVEX
 374     if (use_evex) {
 375       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 376       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 377       __ movl(rax, 0x10000);
 378       __ andl(rax, Address(rsi, 4)); // xcr0 bits sse | ymm
 379       __ cmpl(rax, 0x10000);
 380       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 381       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 382       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 383       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 384       __ movl(rax, 0xE0);
 385       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 386       __ cmpl(rax, 0xE0);
 387       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 388 
 389       if (FLAG_IS_DEFAULT(UseAVX)) {
 390         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 391         __ movl(rax, Address(rsi, 0));
 392         __ cmpl(rax, 0x50654);              // If it is Skylake
 393         __ jcc(Assembler::equal, legacy_setup);
 394       }
 395       // EVEX setup: run in lowest evex mode
 396       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 397       UseAVX = 3;
 398       UseSSE = 2;
 399 #ifdef _WINDOWS
 400       // xmm5-xmm15 are not preserved by caller on windows
 401       // https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx
 402       __ subptr(rsp, 64);
 403       __ evmovdqul(Address(rsp, 0), xmm7, Assembler::AVX_512bit);
 404 #ifdef _LP64
 405       __ subptr(rsp, 64);
 406       __ evmovdqul(Address(rsp, 0), xmm8, Assembler::AVX_512bit);
 407       __ subptr(rsp, 64);
 408       __ evmovdqul(Address(rsp, 0), xmm31, Assembler::AVX_512bit);
 409 #endif // _LP64
 410 #endif // _WINDOWS
 411 
 412       // load value into all 64 bytes of zmm7 register
 413       __ movl(rcx, VM_Version::ymm_test_value());
 414       __ movdl(xmm0, rcx);
 415       __ vpbroadcastd(xmm0, xmm0, Assembler::AVX_512bit);
 416       __ evmovdqul(xmm7, xmm0, Assembler::AVX_512bit);
 417 #ifdef _LP64
 418       __ evmovdqul(xmm8, xmm0, Assembler::AVX_512bit);
 419       __ evmovdqul(xmm31, xmm0, Assembler::AVX_512bit);
 420 #endif
 421       VM_Version::clean_cpuFeatures();
 422       __ jmp(save_restore_except);
 423     }
 424 
 425     __ bind(legacy_setup);
 426     // AVX setup
 427     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 428     UseAVX = 1;
 429     UseSSE = 2;
 430 #ifdef _WINDOWS
 431     __ subptr(rsp, 32);
 432     __ vmovdqu(Address(rsp, 0), xmm7);
 433 #ifdef _LP64
 434     __ subptr(rsp, 32);
 435     __ vmovdqu(Address(rsp, 0), xmm8);
 436     __ subptr(rsp, 32);
 437     __ vmovdqu(Address(rsp, 0), xmm15);
 438 #endif // _LP64
 439 #endif // _WINDOWS
 440 
 441     // load value into all 32 bytes of ymm7 register
 442     __ movl(rcx, VM_Version::ymm_test_value());
 443 
 444     __ movdl(xmm0, rcx);
 445     __ pshufd(xmm0, xmm0, 0x00);
 446     __ vinsertf128_high(xmm0, xmm0);
 447     __ vmovdqu(xmm7, xmm0);
 448 #ifdef _LP64
 449     __ vmovdqu(xmm8, xmm0);
 450     __ vmovdqu(xmm15, xmm0);
 451 #endif
 452     VM_Version::clean_cpuFeatures();
 453 
 454     __ bind(save_restore_except);
 455     __ xorl(rsi, rsi);
 456     VM_Version::set_cpuinfo_segv_addr(__ pc());
 457     // Generate SEGV
 458     __ movl(rax, Address(rsi, 0));
 459 
 460     VM_Version::set_cpuinfo_cont_addr(__ pc());
 461     // Returns here after signal. Save xmm0 to check it later.
 462 
 463     // If UseAVX is unitialized or is set by the user to include EVEX
 464     if (use_evex) {
 465       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 466       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 467       __ movl(rax, 0x10000);
 468       __ andl(rax, Address(rsi, 4));
 469       __ cmpl(rax, 0x10000);
 470       __ jcc(Assembler::notEqual, legacy_save_restore);
 471       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 472       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 473       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 474       __ movl(rax, 0xE0);
 475       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 476       __ cmpl(rax, 0xE0);
 477       __ jcc(Assembler::notEqual, legacy_save_restore);
 478 
 479       if (FLAG_IS_DEFAULT(UseAVX)) {
 480         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 481         __ movl(rax, Address(rsi, 0));
 482         __ cmpl(rax, 0x50654);              // If it is Skylake
 483         __ jcc(Assembler::equal, legacy_save_restore);
 484       }
 485       // EVEX check: run in lowest evex mode
 486       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 487       UseAVX = 3;
 488       UseSSE = 2;
 489       __ lea(rsi, Address(rbp, in_bytes(VM_Version::zmm_save_offset())));
 490       __ evmovdqul(Address(rsi, 0), xmm0, Assembler::AVX_512bit);
 491       __ evmovdqul(Address(rsi, 64), xmm7, Assembler::AVX_512bit);
 492 #ifdef _LP64
 493       __ evmovdqul(Address(rsi, 128), xmm8, Assembler::AVX_512bit);
 494       __ evmovdqul(Address(rsi, 192), xmm31, Assembler::AVX_512bit);
 495 #endif
 496 
 497 #ifdef _WINDOWS
 498 #ifdef _LP64
 499       __ evmovdqul(xmm31, Address(rsp, 0), Assembler::AVX_512bit);
 500       __ addptr(rsp, 64);
 501       __ evmovdqul(xmm8, Address(rsp, 0), Assembler::AVX_512bit);
 502       __ addptr(rsp, 64);
 503 #endif // _LP64
 504       __ evmovdqul(xmm7, Address(rsp, 0), Assembler::AVX_512bit);
 505       __ addptr(rsp, 64);
 506 #endif // _WINDOWS
 507       generate_vzeroupper(wrapup);
 508       VM_Version::clean_cpuFeatures();
 509       UseAVX = saved_useavx;
 510       UseSSE = saved_usesse;
 511       __ jmp(wrapup);
 512    }
 513 
 514     __ bind(legacy_save_restore);
 515     // AVX check
 516     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 517     UseAVX = 1;
 518     UseSSE = 2;
 519     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ymm_save_offset())));
 520     __ vmovdqu(Address(rsi, 0), xmm0);
 521     __ vmovdqu(Address(rsi, 32), xmm7);
 522 #ifdef _LP64
 523     __ vmovdqu(Address(rsi, 64), xmm8);
 524     __ vmovdqu(Address(rsi, 96), xmm15);
 525 #endif
 526 
 527 #ifdef _WINDOWS
 528 #ifdef _LP64
 529     __ vmovdqu(xmm15, Address(rsp, 0));
 530     __ addptr(rsp, 32);
 531     __ vmovdqu(xmm8, Address(rsp, 0));
 532     __ addptr(rsp, 32);
 533 #endif // _LP64
 534     __ vmovdqu(xmm7, Address(rsp, 0));
 535     __ addptr(rsp, 32);
 536 #endif // _WINDOWS
 537     generate_vzeroupper(wrapup);
 538     VM_Version::clean_cpuFeatures();
 539     UseAVX = saved_useavx;
 540     UseSSE = saved_usesse;
 541 
 542     __ bind(wrapup);
 543     __ popf();
 544     __ pop(rsi);
 545     __ pop(rbx);
 546     __ pop(rbp);
 547     __ ret(0);
 548 
 549 #   undef __
 550 
 551     return start;
 552   };
 553   void generate_vzeroupper(Label&amp; L_wrapup) {
 554 #   define __ _masm-&gt;
 555     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 556     __ cmpl(Address(rsi, 4), 0x756e6547);  // &#39;uneG&#39;
 557     __ jcc(Assembler::notEqual, L_wrapup);
 558     __ movl(rcx, 0x0FFF0FF0);
 559     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 560     __ andl(rcx, Address(rsi, 0));
 561     __ cmpl(rcx, 0x00050670);              // If it is Xeon Phi 3200/5200/7200
 562     __ jcc(Assembler::equal, L_wrapup);
 563     __ cmpl(rcx, 0x00080650);              // If it is Future Xeon Phi
 564     __ jcc(Assembler::equal, L_wrapup);
<a name="3" id="anc3"></a><span class="line-modified"> 565     // vzeroupper() will use a pre-computed instruction sequence that we</span>
<span class="line-added"> 566     // can&#39;t compute until after we&#39;ve determined CPU capabilities. Use</span>
<span class="line-added"> 567     // uncached variant here directly to be able to bootstrap correctly</span>
<span class="line-added"> 568     __ vzeroupper_uncached();</span>
 569 #   undef __
 570   }
 571 };
 572 
 573 void VM_Version::get_processor_features() {
 574 
 575   _cpu = 4; // 486 by default
 576   _model = 0;
 577   _stepping = 0;
 578   _features = 0;
 579   _logical_processors_per_package = 1;
 580   // i486 internal cache is both I&amp;D and has a 16-byte line size
 581   _L1_data_cache_line_size = 16;
 582 
 583   // Get raw processor info
 584 
 585   get_cpu_info_stub(&amp;_cpuid_info);
 586 
 587   assert_is_initialized();
 588   _cpu = extended_cpu_family();
 589   _model = extended_cpu_model();
 590   _stepping = cpu_stepping();
 591 
 592   if (cpu_family() &gt; 4) { // it supports CPUID
 593     _features = feature_flags();
 594     // Logical processors are only available on P4s and above,
 595     // and only if hyperthreading is available.
 596     _logical_processors_per_package = logical_processor_count();
 597     _L1_data_cache_line_size = L1_line_size();
 598   }
 599 
 600   _supports_cx8 = supports_cmpxchg8();
 601   // xchg and xadd instructions
 602   _supports_atomic_getset4 = true;
 603   _supports_atomic_getadd4 = true;
 604   LP64_ONLY(_supports_atomic_getset8 = true);
 605   LP64_ONLY(_supports_atomic_getadd8 = true);
 606 
 607 #ifdef _LP64
 608   // OS should support SSE for x64 and hardware should support at least SSE2.
 609   if (!VM_Version::supports_sse2()) {
 610     vm_exit_during_initialization(&quot;Unknown x64 processor: SSE2 not supported&quot;);
 611   }
 612   // in 64 bit the use of SSE2 is the minimum
 613   if (UseSSE &lt; 2) UseSSE = 2;
 614 #endif
 615 
 616 #ifdef AMD64
 617   // flush_icache_stub have to be generated first.
 618   // That is why Icache line size is hard coded in ICache class,
 619   // see icache_x86.hpp. It is also the reason why we can&#39;t use
 620   // clflush instruction in 32-bit VM since it could be running
 621   // on CPU which does not support it.
 622   //
 623   // The only thing we can do is to verify that flushed
 624   // ICache::line_size has correct value.
 625   guarantee(_cpuid_info.std_cpuid1_edx.bits.clflush != 0, &quot;clflush is not supported&quot;);
 626   // clflush_size is size in quadwords (8 bytes).
 627   guarantee(_cpuid_info.std_cpuid1_ebx.bits.clflush_size == 8, &quot;such clflush size is not supported&quot;);
 628 #endif
 629 
 630 #ifdef _LP64
 631   // assigning this field effectively enables Unsafe.writebackMemory()
 632   // by initing UnsafeConstant.DATA_CACHE_LINE_FLUSH_SIZE to non-zero
 633   // that is only implemented on x86_64 and only if the OS plays ball
 634   if (os::supports_map_sync()) {
 635     // publish data cache line flush size to generic field, otherwise
 636     // let if default to zero thereby disabling writeback
 637     _data_cache_line_flush_size = _cpuid_info.std_cpuid1_ebx.bits.clflush_size * 8;
 638   }
 639 #endif
 640   // If the OS doesn&#39;t support SSE, we can&#39;t use this feature even if the HW does
 641   if (!os::supports_sse())
 642     _features &amp;= ~(CPU_SSE|CPU_SSE2|CPU_SSE3|CPU_SSSE3|CPU_SSE4A|CPU_SSE4_1|CPU_SSE4_2);
 643 
 644   if (UseSSE &lt; 4) {
 645     _features &amp;= ~CPU_SSE4_1;
 646     _features &amp;= ~CPU_SSE4_2;
 647   }
 648 
 649   if (UseSSE &lt; 3) {
 650     _features &amp;= ~CPU_SSE3;
 651     _features &amp;= ~CPU_SSSE3;
 652     _features &amp;= ~CPU_SSE4A;
 653   }
 654 
 655   if (UseSSE &lt; 2)
 656     _features &amp;= ~CPU_SSE2;
 657 
 658   if (UseSSE &lt; 1)
 659     _features &amp;= ~CPU_SSE;
 660 
 661   //since AVX instructions is slower than SSE in some ZX cpus, force USEAVX=0.
 662   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7))) {
 663     UseAVX = 0;
 664   }
 665 
 666   // first try initial setting and detect what we can support
 667   int use_avx_limit = 0;
 668   if (UseAVX &gt; 0) {
 669     if (UseAVX &gt; 2 &amp;&amp; supports_evex()) {
 670       use_avx_limit = 3;
 671     } else if (UseAVX &gt; 1 &amp;&amp; supports_avx2()) {
 672       use_avx_limit = 2;
 673     } else if (UseAVX &gt; 0 &amp;&amp; supports_avx()) {
 674       use_avx_limit = 1;
 675     } else {
 676       use_avx_limit = 0;
 677     }
 678   }
 679   if (FLAG_IS_DEFAULT(UseAVX)) {
 680     // Don&#39;t use AVX-512 on older Skylakes unless explicitly requested.
 681     if (use_avx_limit &gt; 2 &amp;&amp; is_intel_skylake() &amp;&amp; _stepping &lt; 5) {
 682       FLAG_SET_DEFAULT(UseAVX, 2);
 683     } else {
 684       FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 685     }
 686   }
 687   if (UseAVX &gt; use_avx_limit) {
 688     warning(&quot;UseAVX=%d is not supported on this CPU, setting it to UseAVX=%d&quot;, (int) UseAVX, use_avx_limit);
 689     FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 690   } else if (UseAVX &lt; 0) {
 691     warning(&quot;UseAVX=%d is not valid, setting it to UseAVX=0&quot;, (int) UseAVX);
 692     FLAG_SET_DEFAULT(UseAVX, 0);
 693   }
 694 
 695   if (UseAVX &lt; 3) {
 696     _features &amp;= ~CPU_AVX512F;
 697     _features &amp;= ~CPU_AVX512DQ;
 698     _features &amp;= ~CPU_AVX512CD;
 699     _features &amp;= ~CPU_AVX512BW;
 700     _features &amp;= ~CPU_AVX512VL;
 701     _features &amp;= ~CPU_AVX512_VPOPCNTDQ;
 702     _features &amp;= ~CPU_AVX512_VPCLMULQDQ;
<a name="4" id="anc4"></a><span class="line-modified"> 703     _features &amp;= ~CPU_AVX512_VAES;</span>
<span class="line-modified"> 704     _features &amp;= ~CPU_AVX512_VNNI;</span>
<span class="line-modified"> 705     _features &amp;= ~CPU_AVX512_VBMI2;</span>
 706   }
 707 
 708   if (UseAVX &lt; 2)
 709     _features &amp;= ~CPU_AVX2;
 710 
 711   if (UseAVX &lt; 1) {
 712     _features &amp;= ~CPU_AVX;
 713     _features &amp;= ~CPU_VZEROUPPER;
 714   }
 715 
 716   if (logical_processors_per_package() == 1) {
 717     // HT processor could be installed on a system which doesn&#39;t support HT.
 718     _features &amp;= ~CPU_HT;
 719   }
 720 
 721   if (is_intel()) { // Intel cpus specific settings
 722     if (is_knights_family()) {
 723       _features &amp;= ~CPU_VZEROUPPER;
 724     }
 725   }
 726 
<a name="5" id="anc5"></a><span class="line-modified"> 727   if (FLAG_IS_DEFAULT(IntelJccErratumMitigation)) {</span>
<span class="line-modified"> 728     _has_intel_jcc_erratum = compute_has_intel_jcc_erratum();</span>
<span class="line-added"> 729   } else {</span>
<span class="line-added"> 730     _has_intel_jcc_erratum = IntelJccErratumMitigation;</span>
<span class="line-added"> 731   }</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733   char buf[512];</span>
<span class="line-added"> 734   int res = jio_snprintf(buf, sizeof(buf),</span>
<span class="line-added"> 735               &quot;(%u cores per cpu, %u threads per core) family %d model %d stepping %d&quot;</span>
<span class="line-added"> 736               &quot;%s%s%s%s%s%s%s%s%s%s&quot; &quot;%s%s%s%s%s%s%s%s%s%s&quot; &quot;%s%s%s%s%s%s%s%s%s%s&quot; &quot;%s%s%s%s%s%s%s%s%s%s&quot; &quot;%s%s%s%s%s%s&quot;,</span>
<span class="line-added"> 737 </span>
 738                cores_per_cpu(), threads_per_core(),
 739                cpu_family(), _model, _stepping,
<a name="6" id="anc6"></a><span class="line-added"> 740 </span>
 741                (supports_cmov() ? &quot;, cmov&quot; : &quot;&quot;),
 742                (supports_cmpxchg8() ? &quot;, cx8&quot; : &quot;&quot;),
 743                (supports_fxsr() ? &quot;, fxsr&quot; : &quot;&quot;),
 744                (supports_mmx()  ? &quot;, mmx&quot;  : &quot;&quot;),
 745                (supports_sse()  ? &quot;, sse&quot;  : &quot;&quot;),
 746                (supports_sse2() ? &quot;, sse2&quot; : &quot;&quot;),
 747                (supports_sse3() ? &quot;, sse3&quot; : &quot;&quot;),
 748                (supports_ssse3()? &quot;, ssse3&quot;: &quot;&quot;),
 749                (supports_sse4_1() ? &quot;, sse4.1&quot; : &quot;&quot;),
 750                (supports_sse4_2() ? &quot;, sse4.2&quot; : &quot;&quot;),
<a name="7" id="anc7"></a><span class="line-added"> 751 </span>
 752                (supports_popcnt() ? &quot;, popcnt&quot; : &quot;&quot;),
<a name="8" id="anc8"></a><span class="line-added"> 753                (supports_vzeroupper() ? &quot;, vzeroupper&quot; : &quot;&quot;),</span>
 754                (supports_avx()    ? &quot;, avx&quot; : &quot;&quot;),
 755                (supports_avx2()   ? &quot;, avx2&quot; : &quot;&quot;),
 756                (supports_aes()    ? &quot;, aes&quot; : &quot;&quot;),
 757                (supports_clmul()  ? &quot;, clmul&quot; : &quot;&quot;),
 758                (supports_erms()   ? &quot;, erms&quot; : &quot;&quot;),
 759                (supports_rtm()    ? &quot;, rtm&quot; : &quot;&quot;),
 760                (supports_mmx_ext() ? &quot;, mmxext&quot; : &quot;&quot;),
 761                (supports_3dnow_prefetch() ? &quot;, 3dnowpref&quot; : &quot;&quot;),
<a name="9" id="anc9"></a><span class="line-added"> 762 </span>
 763                (supports_lzcnt()   ? &quot;, lzcnt&quot;: &quot;&quot;),
 764                (supports_sse4a()   ? &quot;, sse4a&quot;: &quot;&quot;),
 765                (supports_ht() ? &quot;, ht&quot;: &quot;&quot;),
 766                (supports_tsc() ? &quot;, tsc&quot;: &quot;&quot;),
 767                (supports_tscinv_bit() ? &quot;, tscinvbit&quot;: &quot;&quot;),
 768                (supports_tscinv() ? &quot;, tscinv&quot;: &quot;&quot;),
 769                (supports_bmi1() ? &quot;, bmi1&quot; : &quot;&quot;),
 770                (supports_bmi2() ? &quot;, bmi2&quot; : &quot;&quot;),
 771                (supports_adx() ? &quot;, adx&quot; : &quot;&quot;),
<a name="10" id="anc10"></a><span class="line-modified"> 772                (supports_evex() ? &quot;, avx512f&quot; : &quot;&quot;),</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774                (supports_avx512dq() ? &quot;, avx512dq&quot; : &quot;&quot;),</span>
<span class="line-added"> 775                (supports_avx512pf() ? &quot;, avx512pf&quot; : &quot;&quot;),</span>
<span class="line-added"> 776                (supports_avx512er() ? &quot;, avx512er&quot; : &quot;&quot;),</span>
<span class="line-added"> 777                (supports_avx512cd() ? &quot;, avx512cd&quot; : &quot;&quot;),</span>
<span class="line-added"> 778                (supports_avx512bw() ? &quot;, avx512bw&quot; : &quot;&quot;),</span>
<span class="line-added"> 779                (supports_avx512vl() ? &quot;, avx512vl&quot; : &quot;&quot;),</span>
<span class="line-added"> 780                (supports_avx512_vpopcntdq() ? &quot;, avx512_vpopcntdq&quot; : &quot;&quot;),</span>
<span class="line-added"> 781                (supports_avx512_vpclmulqdq() ? &quot;, avx512_vpclmulqdq&quot; : &quot;&quot;),</span>
<span class="line-added"> 782                (supports_avx512_vbmi2() ? &quot;, avx512_vbmi2&quot; : &quot;&quot;),</span>
<span class="line-added"> 783                (supports_avx512_vaes() ? &quot;, avx512_vaes&quot; : &quot;&quot;),</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785                (supports_avx512_vnni() ? &quot;, avx512_vnni&quot; : &quot;&quot;),</span>
 786                (supports_sha() ? &quot;, sha&quot; : &quot;&quot;),
 787                (supports_fma() ? &quot;, fma&quot; : &quot;&quot;),
<a name="11" id="anc11"></a><span class="line-modified"> 788                (supports_clflush() ? &quot;, clflush&quot; : &quot;&quot;),</span>
<span class="line-modified"> 789                (supports_clflushopt() ? &quot;, clflushopt&quot; : &quot;&quot;),</span>
<span class="line-modified"> 790                (supports_clwb() ? &quot;, clwb&quot; : &quot;&quot;));</span>
<span class="line-added"> 791 </span>
<span class="line-added"> 792   assert(res &gt; 0, &quot;not enough temporary space allocated&quot;); // increase &#39;buf&#39; size</span>
<span class="line-added"> 793 </span>
 794   _features_string = os::strdup(buf);
 795 
 796   // UseSSE is set to the smaller of what hardware supports and what
 797   // the command line requires.  I.e., you cannot set UseSSE to 2 on
 798   // older Pentiums which do not support it.
 799   int use_sse_limit = 0;
 800   if (UseSSE &gt; 0) {
 801     if (UseSSE &gt; 3 &amp;&amp; supports_sse4_1()) {
 802       use_sse_limit = 4;
 803     } else if (UseSSE &gt; 2 &amp;&amp; supports_sse3()) {
 804       use_sse_limit = 3;
 805     } else if (UseSSE &gt; 1 &amp;&amp; supports_sse2()) {
 806       use_sse_limit = 2;
 807     } else if (UseSSE &gt; 0 &amp;&amp; supports_sse()) {
 808       use_sse_limit = 1;
 809     } else {
 810       use_sse_limit = 0;
 811     }
 812   }
 813   if (FLAG_IS_DEFAULT(UseSSE)) {
 814     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 815   } else if (UseSSE &gt; use_sse_limit) {
 816     warning(&quot;UseSSE=%d is not supported on this CPU, setting it to UseSSE=%d&quot;, (int) UseSSE, use_sse_limit);
 817     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 818   } else if (UseSSE &lt; 0) {
 819     warning(&quot;UseSSE=%d is not valid, setting it to UseSSE=0&quot;, (int) UseSSE);
 820     FLAG_SET_DEFAULT(UseSSE, 0);
 821   }
 822 
 823   // Use AES instructions if available.
 824   if (supports_aes()) {
 825     if (FLAG_IS_DEFAULT(UseAES)) {
 826       FLAG_SET_DEFAULT(UseAES, true);
 827     }
 828     if (!UseAES) {
 829       if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 830         warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 831       }
 832       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 833     } else {
 834       if (UseSSE &gt; 2) {
 835         if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 836           FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 837         }
 838       } else {
 839         // The AES intrinsic stubs require AES instruction support (of course)
 840         // but also require sse3 mode or higher for instructions it use.
 841         if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 842           warning(&quot;X86 AES intrinsics require SSE3 instructions or higher. Intrinsics will be disabled.&quot;);
 843         }
 844         FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 845       }
 846 
 847       // --AES-CTR begins--
 848       if (!UseAESIntrinsics) {
 849         if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 850           warning(&quot;AES-CTR intrinsics require UseAESIntrinsics flag to be enabled. Intrinsics will be disabled.&quot;);
 851           FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 852         }
 853       } else {
 854         if (supports_sse4_1()) {
 855           if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 856             FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);
 857           }
 858         } else {
 859            // The AES-CTR intrinsic stubs require AES instruction support (of course)
 860            // but also require sse4.1 mode or higher for instructions it use.
 861           if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 862              warning(&quot;X86 AES-CTR intrinsics require SSE4.1 instructions or higher. Intrinsics will be disabled.&quot;);
 863            }
 864            FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 865         }
 866       }
 867       // --AES-CTR ends--
 868     }
 869   } else if (UseAES || UseAESIntrinsics || UseAESCTRIntrinsics) {
 870     if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
 871       warning(&quot;AES instructions are not available on this CPU&quot;);
 872       FLAG_SET_DEFAULT(UseAES, false);
 873     }
 874     if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 875       warning(&quot;AES intrinsics are not available on this CPU&quot;);
 876       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 877     }
 878     if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 879       warning(&quot;AES-CTR intrinsics are not available on this CPU&quot;);
 880       FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 881     }
 882   }
 883 
 884   // Use CLMUL instructions if available.
 885   if (supports_clmul()) {
 886     if (FLAG_IS_DEFAULT(UseCLMUL)) {
 887       UseCLMUL = true;
 888     }
 889   } else if (UseCLMUL) {
 890     if (!FLAG_IS_DEFAULT(UseCLMUL))
 891       warning(&quot;CLMUL instructions not available on this CPU (AVX may also be required)&quot;);
 892     FLAG_SET_DEFAULT(UseCLMUL, false);
 893   }
 894 
 895   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 896     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 897       UseCRC32Intrinsics = true;
 898     }
 899   } else if (UseCRC32Intrinsics) {
 900     if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics))
 901       warning(&quot;CRC32 Intrinsics requires CLMUL instructions (not available on this CPU)&quot;);
 902     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
 903   }
 904 
 905   if (supports_sse4_2() &amp;&amp; supports_clmul()) {
 906     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 907       UseCRC32CIntrinsics = true;
 908     }
 909   } else if (UseCRC32CIntrinsics) {
 910     if (!FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 911       warning(&quot;CRC32C intrinsics are not available on this CPU&quot;);
 912     }
 913     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 914   }
 915 
 916   // GHASH/GCM intrinsics
 917   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 918     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
 919       UseGHASHIntrinsics = true;
 920     }
 921   } else if (UseGHASHIntrinsics) {
 922     if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics))
 923       warning(&quot;GHASH intrinsic requires CLMUL and SSE2 instructions on this CPU&quot;);
 924     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 925   }
 926 
 927   // Base64 Intrinsics (Check the condition for which the intrinsic will be active)
 928   if ((UseAVX &gt; 2) &amp;&amp; supports_avx512vl() &amp;&amp; supports_avx512bw()) {
 929     if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {
 930       UseBASE64Intrinsics = true;
 931     }
 932   } else if (UseBASE64Intrinsics) {
 933      if (!FLAG_IS_DEFAULT(UseBASE64Intrinsics))
 934       warning(&quot;Base64 intrinsic requires EVEX instructions on this CPU&quot;);
 935     FLAG_SET_DEFAULT(UseBASE64Intrinsics, false);
 936   }
 937 
 938   if (supports_fma() &amp;&amp; UseSSE &gt;= 2) { // Check UseSSE since FMA code uses SSE instructions
 939     if (FLAG_IS_DEFAULT(UseFMA)) {
 940       UseFMA = true;
 941     }
 942   } else if (UseFMA) {
 943     warning(&quot;FMA instructions are not available on this CPU&quot;);
 944     FLAG_SET_DEFAULT(UseFMA, false);
 945   }
 946 
 947   if (supports_sha() LP64_ONLY(|| supports_avx2() &amp;&amp; supports_bmi2())) {
 948     if (FLAG_IS_DEFAULT(UseSHA)) {
 949       UseSHA = true;
 950     }
 951   } else if (UseSHA) {
 952     warning(&quot;SHA instructions are not available on this CPU&quot;);
 953     FLAG_SET_DEFAULT(UseSHA, false);
 954   }
 955 
 956   if (supports_sha() &amp;&amp; supports_sse4_1() &amp;&amp; UseSHA) {
 957     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 958       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 959     }
 960   } else if (UseSHA1Intrinsics) {
 961     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 962     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 963   }
 964 
 965   if (supports_sse4_1() &amp;&amp; UseSHA) {
 966     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 967       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 968     }
 969   } else if (UseSHA256Intrinsics) {
 970     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 971     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 972   }
 973 
 974 #ifdef _LP64
 975   // These are only supported on 64-bit
 976   if (UseSHA &amp;&amp; supports_avx2() &amp;&amp; supports_bmi2()) {
 977     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 978       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 979     }
 980   } else
 981 #endif
 982   if (UseSHA512Intrinsics) {
 983     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 984     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 985   }
 986 
 987   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 988     FLAG_SET_DEFAULT(UseSHA, false);
 989   }
 990 
 991   if (UseAdler32Intrinsics) {
 992     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 993     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 994   }
 995 
 996   if (!supports_rtm() &amp;&amp; UseRTMLocking) {
 997     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 998     // setting during arguments processing. See use_biased_locking().
 999     // VM_Version_init() is executed after UseBiasedLocking is used
1000     // in Thread::allocate().
1001     vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU&quot;);
1002   }
1003 
1004 #if INCLUDE_RTM_OPT
1005   if (UseRTMLocking) {
1006     if (is_client_compilation_mode_vm()) {
1007       // Only C2 does RTM locking optimization.
1008       // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
1009       // setting during arguments processing. See use_biased_locking().
1010       vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
1011     }
1012     if (is_intel_family_core()) {
1013       if ((_model == CPU_MODEL_HASWELL_E3) ||
1014           (_model == CPU_MODEL_HASWELL_E7 &amp;&amp; _stepping &lt; 3) ||
1015           (_model == CPU_MODEL_BROADWELL  &amp;&amp; _stepping &lt; 4)) {
1016         // currently a collision between SKL and HSW_E3
1017         if (!UnlockExperimentalVMOptions &amp;&amp; UseAVX &lt; 3) {
1018           vm_exit_during_initialization(&quot;UseRTMLocking is only available as experimental option on this &quot;
1019                                         &quot;platform. It must be enabled via -XX:+UnlockExperimentalVMOptions flag.&quot;);
1020         } else {
1021           warning(&quot;UseRTMLocking is only available as experimental option on this platform.&quot;);
1022         }
1023       }
1024     }
1025     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
1026       // RTM locking should be used only for applications with
1027       // high lock contention. For now we do not use it by default.
1028       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
1029     }
1030   } else { // !UseRTMLocking
1031     if (UseRTMForStackLocks) {
1032       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
1033         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
1034       }
1035       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
1036     }
1037     if (UseRTMDeopt) {
1038       FLAG_SET_DEFAULT(UseRTMDeopt, false);
1039     }
1040     if (PrintPreciseRTMLockingStatistics) {
1041       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
1042     }
1043   }
1044 #else
1045   if (UseRTMLocking) {
1046     // Only C2 does RTM locking optimization.
1047     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
1048     // setting during arguments processing. See use_biased_locking().
1049     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
1050   }
1051 #endif
1052 
1053 #ifdef COMPILER2
1054   if (UseFPUForSpilling) {
1055     if (UseSSE &lt; 2) {
1056       // Only supported with SSE2+
1057       FLAG_SET_DEFAULT(UseFPUForSpilling, false);
1058     }
1059   }
1060 #endif
1061 
1062 #if COMPILER2_OR_JVMCI
1063   int max_vector_size = 0;
1064   if (UseSSE &lt; 2) {
1065     // Vectors (in XMM) are only supported with SSE2+
1066     // SSE is always 2 on x64.
1067     max_vector_size = 0;
1068   } else if (UseAVX == 0 || !os_supports_avx_vectors()) {
1069     // 16 byte vectors (in XMM) are supported with SSE2+
1070     max_vector_size = 16;
1071   } else if (UseAVX == 1 || UseAVX == 2) {
1072     // 32 bytes vectors (in YMM) are only supported with AVX+
1073     max_vector_size = 32;
1074   } else if (UseAVX &gt; 2) {
1075     // 64 bytes vectors (in ZMM) are only supported with AVX 3
1076     max_vector_size = 64;
1077   }
1078 
1079 #ifdef _LP64
1080   int min_vector_size = 4; // We require MaxVectorSize to be at least 4 on 64bit
1081 #else
1082   int min_vector_size = 0;
1083 #endif
1084 
1085   if (!FLAG_IS_DEFAULT(MaxVectorSize)) {
1086     if (MaxVectorSize &lt; min_vector_size) {
1087       warning(&quot;MaxVectorSize must be at least %i on this platform&quot;, min_vector_size);
1088       FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);
1089     }
1090     if (MaxVectorSize &gt; max_vector_size) {
1091       warning(&quot;MaxVectorSize must be at most %i on this platform&quot;, max_vector_size);
1092       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1093     }
1094     if (!is_power_of_2(MaxVectorSize)) {
1095       warning(&quot;MaxVectorSize must be a power of 2, setting to default: %i&quot;, max_vector_size);
1096       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1097     }
1098   } else {
1099     // If default, use highest supported configuration
1100     FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1101   }
1102 
1103 #if defined(COMPILER2) &amp;&amp; defined(ASSERT)
1104   if (MaxVectorSize &gt; 0) {
1105     if (supports_avx() &amp;&amp; PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; TraceNewVectors) {
1106       tty-&gt;print_cr(&quot;State of YMM registers after signal handle:&quot;);
1107       int nreg = 2 LP64_ONLY(+2);
1108       const char* ymm_name[4] = {&quot;0&quot;, &quot;7&quot;, &quot;8&quot;, &quot;15&quot;};
1109       for (int i = 0; i &lt; nreg; i++) {
1110         tty-&gt;print(&quot;YMM%s:&quot;, ymm_name[i]);
1111         for (int j = 7; j &gt;=0; j--) {
1112           tty-&gt;print(&quot; %x&quot;, _cpuid_info.ymm_save[i*8 + j]);
1113         }
1114         tty-&gt;cr();
1115       }
1116     }
1117   }
1118 #endif // COMPILER2 &amp;&amp; ASSERT
1119 
1120   if (!FLAG_IS_DEFAULT(AVX3Threshold)) {
1121     if (!is_power_of_2(AVX3Threshold)) {
1122       warning(&quot;AVX3Threshold must be a power of 2&quot;);
1123       FLAG_SET_DEFAULT(AVX3Threshold, 4096);
1124     }
1125   }
1126 
1127 #ifdef _LP64
1128   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1129     UseMultiplyToLenIntrinsic = true;
1130   }
1131   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1132     UseSquareToLenIntrinsic = true;
1133   }
1134   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1135     UseMulAddIntrinsic = true;
1136   }
1137   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1138     UseMontgomeryMultiplyIntrinsic = true;
1139   }
1140   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1141     UseMontgomerySquareIntrinsic = true;
1142   }
1143 #else
1144   if (UseMultiplyToLenIntrinsic) {
1145     if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1146       warning(&quot;multiplyToLen intrinsic is not available in 32-bit VM&quot;);
1147     }
1148     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);
1149   }
1150   if (UseMontgomeryMultiplyIntrinsic) {
1151     if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1152       warning(&quot;montgomeryMultiply intrinsic is not available in 32-bit VM&quot;);
1153     }
1154     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);
1155   }
1156   if (UseMontgomerySquareIntrinsic) {
1157     if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1158       warning(&quot;montgomerySquare intrinsic is not available in 32-bit VM&quot;);
1159     }
1160     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);
1161   }
1162   if (UseSquareToLenIntrinsic) {
1163     if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1164       warning(&quot;squareToLen intrinsic is not available in 32-bit VM&quot;);
1165     }
1166     FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);
1167   }
1168   if (UseMulAddIntrinsic) {
1169     if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1170       warning(&quot;mulAdd intrinsic is not available in 32-bit VM&quot;);
1171     }
1172     FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);
1173   }
1174 #endif // _LP64
1175 #endif // COMPILER2_OR_JVMCI
1176 
1177   // On new cpus instructions which update whole XMM register should be used
1178   // to prevent partial register stall due to dependencies on high half.
1179   //
1180   // UseXmmLoadAndClearUpper == true  --&gt; movsd(xmm, mem)
1181   // UseXmmLoadAndClearUpper == false --&gt; movlpd(xmm, mem)
1182   // UseXmmRegToRegMoveAll == true  --&gt; movaps(xmm, xmm), movapd(xmm, xmm).
1183   // UseXmmRegToRegMoveAll == false --&gt; movss(xmm, xmm),  movsd(xmm, xmm).
1184 
1185 
1186   if (is_zx()) { // ZX cpus specific settings
1187     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1188       UseStoreImmI16 = false; // don&#39;t use it on ZX cpus
1189     }
1190     if ((cpu_family() == 6) || (cpu_family() == 7)) {
1191       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1192         // Use it on all ZX cpus
1193         UseAddressNop = true;
1194       }
1195     }
1196     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1197       UseXmmLoadAndClearUpper = true; // use movsd on all ZX cpus
1198     }
1199     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1200       if (supports_sse3()) {
1201         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new ZX cpus
1202       } else {
1203         UseXmmRegToRegMoveAll = false;
1204       }
1205     }
1206     if (((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse3()) { // new ZX cpus
1207 #ifdef COMPILER2
1208       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1209         // For new ZX cpus do the next optimization:
1210         // don&#39;t align the beginning of a loop if there are enough instructions
1211         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1212         // in current fetch line (OptoLoopAlignment) or the padding
1213         // is big (&gt; MaxLoopPad).
1214         // Set MaxLoopPad to 11 for new ZX cpus to reduce number of
1215         // generated NOP instructions. 11 is the largest size of one
1216         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1217         MaxLoopPad = 11;
1218       }
1219 #endif // COMPILER2
1220       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1221         UseXMMForArrayCopy = true; // use SSE2 movq on new ZX cpus
1222       }
1223       if (supports_sse4_2()) { // new ZX cpus
1224         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1225           UseUnalignedLoadStores = true; // use movdqu on newest ZX cpus
1226         }
1227       }
1228       if (supports_sse4_2()) {
1229         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1230           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1231         }
1232       } else {
1233         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1234           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1235         }
1236         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1237       }
1238     }
1239 
1240     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1241       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1242     }
1243   }
1244 
1245   if (is_amd_family()) { // AMD cpus specific settings
1246     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseAddressNop)) {
1247       // Use it on new AMD cpus starting from Opteron.
1248       UseAddressNop = true;
1249     }
1250     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseNewLongLShift)) {
1251       // Use it on new AMD cpus starting from Opteron.
1252       UseNewLongLShift = true;
1253     }
1254     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1255       if (supports_sse4a()) {
1256         UseXmmLoadAndClearUpper = true; // use movsd only on &#39;10h&#39; Opteron
1257       } else {
1258         UseXmmLoadAndClearUpper = false;
1259       }
1260     }
1261     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1262       if (supports_sse4a()) {
1263         UseXmmRegToRegMoveAll = true; // use movaps, movapd only on &#39;10h&#39;
1264       } else {
1265         UseXmmRegToRegMoveAll = false;
1266       }
1267     }
1268     if (FLAG_IS_DEFAULT(UseXmmI2F)) {
1269       if (supports_sse4a()) {
1270         UseXmmI2F = true;
1271       } else {
1272         UseXmmI2F = false;
1273       }
1274     }
1275     if (FLAG_IS_DEFAULT(UseXmmI2D)) {
1276       if (supports_sse4a()) {
1277         UseXmmI2D = true;
1278       } else {
1279         UseXmmI2D = false;
1280       }
1281     }
1282     if (supports_sse4_2()) {
1283       if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1284         FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1285       }
1286     } else {
1287       if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1288         warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1289       }
1290       FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1291     }
1292 
1293     // some defaults for AMD family 15h
1294     if (cpu_family() == 0x15) {
1295       // On family 15h processors default is no sw prefetch
1296       if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1297         FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1298       }
1299       // Also, if some other prefetch style is specified, default instruction type is PREFETCHW
1300       if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1301         FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1302       }
1303       // On family 15h processors use XMM and UnalignedLoadStores for Array Copy
1304       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1305         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1306       }
1307       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1308         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1309       }
1310     }
1311 
1312 #ifdef COMPILER2
1313     if (cpu_family() &lt; 0x17 &amp;&amp; MaxVectorSize &gt; 16) {
1314       // Limit vectors size to 16 bytes on AMD cpus &lt; 17h.
1315       FLAG_SET_DEFAULT(MaxVectorSize, 16);
1316     }
1317 #endif // COMPILER2
1318 
1319     // Some defaults for AMD family 17h || Hygon family 18h
1320     if (cpu_family() == 0x17 || cpu_family() == 0x18) {
1321       // On family 17h processors use XMM and UnalignedLoadStores for Array Copy
1322       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1323         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1324       }
1325       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1326         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1327       }
1328 #ifdef COMPILER2
1329       if (supports_sse4_2() &amp;&amp; FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1330         FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1331       }
1332 #endif
1333     }
1334   }
1335 
1336   if (is_intel()) { // Intel cpus specific settings
1337     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1338       UseStoreImmI16 = false; // don&#39;t use it on Intel cpus
1339     }
1340     if (cpu_family() == 6 || cpu_family() == 15) {
1341       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1342         // Use it on all Intel cpus starting from PentiumPro
1343         UseAddressNop = true;
1344       }
1345     }
1346     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1347       UseXmmLoadAndClearUpper = true; // use movsd on all Intel cpus
1348     }
1349     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1350       if (supports_sse3()) {
1351         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new Intel cpus
1352       } else {
1353         UseXmmRegToRegMoveAll = false;
1354       }
1355     }
1356     if (cpu_family() == 6 &amp;&amp; supports_sse3()) { // New Intel cpus
1357 #ifdef COMPILER2
1358       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1359         // For new Intel cpus do the next optimization:
1360         // don&#39;t align the beginning of a loop if there are enough instructions
1361         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1362         // in current fetch line (OptoLoopAlignment) or the padding
1363         // is big (&gt; MaxLoopPad).
1364         // Set MaxLoopPad to 11 for new Intel cpus to reduce number of
1365         // generated NOP instructions. 11 is the largest size of one
1366         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1367         MaxLoopPad = 11;
1368       }
1369 #endif // COMPILER2
1370       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1371         UseXMMForArrayCopy = true; // use SSE2 movq on new Intel cpus
1372       }
1373       if ((supports_sse4_2() &amp;&amp; supports_ht()) || supports_avx()) { // Newest Intel cpus
1374         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1375           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1376         }
1377       }
1378       if (supports_sse4_2()) {
1379         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1380           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1381         }
1382       } else {
1383         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1384           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1385         }
1386         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1387       }
1388     }
1389     if (is_atom_family() || is_knights_family()) {
1390 #ifdef COMPILER2
1391       if (FLAG_IS_DEFAULT(OptoScheduling)) {
1392         OptoScheduling = true;
1393       }
1394 #endif
1395       if (supports_sse4_2()) { // Silvermont
1396         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1397           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1398         }
1399       }
1400       if (FLAG_IS_DEFAULT(UseIncDec)) {
1401         FLAG_SET_DEFAULT(UseIncDec, false);
1402       }
1403     }
1404     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1405       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1406     }
1407   }
1408 
1409 #ifdef _LP64
1410   if (UseSSE42Intrinsics) {
1411     if (FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1412       UseVectorizedMismatchIntrinsic = true;
1413     }
1414   } else if (UseVectorizedMismatchIntrinsic) {
1415     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic))
1416       warning(&quot;vectorizedMismatch intrinsics are not available on this CPU&quot;);
1417     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1418   }
1419 #else
1420   if (UseVectorizedMismatchIntrinsic) {
1421     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1422       warning(&quot;vectorizedMismatch intrinsic is not available in 32-bit VM&quot;);
1423     }
1424     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1425   }
1426 #endif // _LP64
1427 
1428   // Use count leading zeros count instruction if available.
1429   if (supports_lzcnt()) {
1430     if (FLAG_IS_DEFAULT(UseCountLeadingZerosInstruction)) {
1431       UseCountLeadingZerosInstruction = true;
1432     }
1433    } else if (UseCountLeadingZerosInstruction) {
1434     warning(&quot;lzcnt instruction is not available on this CPU&quot;);
1435     FLAG_SET_DEFAULT(UseCountLeadingZerosInstruction, false);
1436   }
1437 
1438   // Use count trailing zeros instruction if available
1439   if (supports_bmi1()) {
1440     // tzcnt does not require VEX prefix
1441     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstruction)) {
1442       if (!UseBMI1Instructions &amp;&amp; !FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1443         // Don&#39;t use tzcnt if BMI1 is switched off on command line.
1444         UseCountTrailingZerosInstruction = false;
1445       } else {
1446         UseCountTrailingZerosInstruction = true;
1447       }
1448     }
1449   } else if (UseCountTrailingZerosInstruction) {
1450     warning(&quot;tzcnt instruction is not available on this CPU&quot;);
1451     FLAG_SET_DEFAULT(UseCountTrailingZerosInstruction, false);
1452   }
1453 
1454   // BMI instructions (except tzcnt) use an encoding with VEX prefix.
1455   // VEX prefix is generated only when AVX &gt; 0.
1456   if (supports_bmi1() &amp;&amp; supports_avx()) {
1457     if (FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1458       UseBMI1Instructions = true;
1459     }
1460   } else if (UseBMI1Instructions) {
1461     warning(&quot;BMI1 instructions are not available on this CPU (AVX is also required)&quot;);
1462     FLAG_SET_DEFAULT(UseBMI1Instructions, false);
1463   }
1464 
1465   if (supports_bmi2() &amp;&amp; supports_avx()) {
1466     if (FLAG_IS_DEFAULT(UseBMI2Instructions)) {
1467       UseBMI2Instructions = true;
1468     }
1469   } else if (UseBMI2Instructions) {
1470     warning(&quot;BMI2 instructions are not available on this CPU (AVX is also required)&quot;);
1471     FLAG_SET_DEFAULT(UseBMI2Instructions, false);
1472   }
1473 
1474   // Use population count instruction if available.
1475   if (supports_popcnt()) {
1476     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
1477       UsePopCountInstruction = true;
1478     }
1479   } else if (UsePopCountInstruction) {
1480     warning(&quot;POPCNT instruction is not available on this CPU&quot;);
1481     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
1482   }
1483 
1484   // Use fast-string operations if available.
1485   if (supports_erms()) {
1486     if (FLAG_IS_DEFAULT(UseFastStosb)) {
1487       UseFastStosb = true;
1488     }
1489   } else if (UseFastStosb) {
1490     warning(&quot;fast-string operations are not available on this CPU&quot;);
1491     FLAG_SET_DEFAULT(UseFastStosb, false);
1492   }
1493 
1494   // Use XMM/YMM MOVDQU instruction for Object Initialization
1495   if (!UseFastStosb &amp;&amp; UseSSE &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
1496     if (FLAG_IS_DEFAULT(UseXMMForObjInit)) {
1497       UseXMMForObjInit = true;
1498     }
1499   } else if (UseXMMForObjInit) {
1500     warning(&quot;UseXMMForObjInit requires SSE2 and unaligned load/stores. Feature is switched off.&quot;);
1501     FLAG_SET_DEFAULT(UseXMMForObjInit, false);
1502   }
1503 
1504 #ifdef COMPILER2
1505   if (FLAG_IS_DEFAULT(AlignVector)) {
1506     // Modern processors allow misaligned memory operations for vectors.
1507     AlignVector = !UseUnalignedLoadStores;
1508   }
1509 #endif // COMPILER2
1510 
1511   if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1512     if (AllocatePrefetchInstr == 3 &amp;&amp; !supports_3dnow_prefetch()) {
1513       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
1514     } else if (!supports_sse() &amp;&amp; supports_3dnow_prefetch()) {
1515       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1516     }
1517   }
1518 
1519   // Allocation prefetch settings
1520   intx cache_line_size = prefetch_data_size();
1521   if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) &amp;&amp;
1522       (cache_line_size &gt; AllocatePrefetchStepSize)) {
1523     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
1524   }
1525 
1526   if ((AllocatePrefetchDistance == 0) &amp;&amp; (AllocatePrefetchStyle != 0)) {
1527     assert(!FLAG_IS_DEFAULT(AllocatePrefetchDistance), &quot;default value should not be 0&quot;);
1528     if (!FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1529       warning(&quot;AllocatePrefetchDistance is set to 0 which disable prefetching. Ignoring AllocatePrefetchStyle flag.&quot;);
1530     }
1531     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1532   }
1533 
1534   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
1535     bool use_watermark_prefetch = (AllocatePrefetchStyle == 2);
1536     FLAG_SET_DEFAULT(AllocatePrefetchDistance, allocate_prefetch_distance(use_watermark_prefetch));
1537   }
1538 
1539   if (is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp; supports_sse3()) {
1540     if (FLAG_IS_DEFAULT(AllocatePrefetchLines) &amp;&amp;
1541         supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
1542       FLAG_SET_DEFAULT(AllocatePrefetchLines, 4);
1543     }
1544 #ifdef COMPILER2
1545     if (FLAG_IS_DEFAULT(UseFPUForSpilling) &amp;&amp; supports_sse4_2()) {
1546       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1547     }
1548 #endif
1549   }
1550 
1551   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse4_2()) {
1552 #ifdef COMPILER2
1553     if (FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1554       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1555     }
1556 #endif
1557   }
1558 
1559 #ifdef _LP64
1560   // Prefetch settings
1561 
1562   // Prefetch interval for gc copy/scan == 9 dcache lines.  Derived from
1563   // 50-warehouse specjbb runs on a 2-way 1.8ghz opteron using a 4gb heap.
1564   // Tested intervals from 128 to 2048 in increments of 64 == one cache line.
1565   // 256 bytes (4 dcache lines) was the nearest runner-up to 576.
1566 
1567   // gc copy/scan is disabled if prefetchw isn&#39;t supported, because
1568   // Prefetch::write emits an inlined prefetchw on Linux.
1569   // Do not use the 3dnow prefetchw instruction.  It isn&#39;t supported on em64t.
1570   // The used prefetcht0 instruction works for both amd64 and em64t.
1571 
1572   if (FLAG_IS_DEFAULT(PrefetchCopyIntervalInBytes)) {
1573     FLAG_SET_DEFAULT(PrefetchCopyIntervalInBytes, 576);
1574   }
1575   if (FLAG_IS_DEFAULT(PrefetchScanIntervalInBytes)) {
1576     FLAG_SET_DEFAULT(PrefetchScanIntervalInBytes, 576);
1577   }
1578   if (FLAG_IS_DEFAULT(PrefetchFieldsAhead)) {
1579     FLAG_SET_DEFAULT(PrefetchFieldsAhead, 1);
1580   }
1581 #endif
1582 
1583   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
1584      (cache_line_size &gt; ContendedPaddingWidth))
1585      ContendedPaddingWidth = cache_line_size;
1586 
1587   // This machine allows unaligned memory accesses
1588   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
1589     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
1590   }
1591 
1592 #ifndef PRODUCT
1593   if (log_is_enabled(Info, os, cpu)) {
1594     LogStream ls(Log(os, cpu)::info());
1595     outputStream* log = &amp;ls;
1596     log-&gt;print_cr(&quot;Logical CPUs per core: %u&quot;,
1597                   logical_processors_per_package());
1598     log-&gt;print_cr(&quot;L1 data cache line size: %u&quot;, L1_data_cache_line_size());
1599     log-&gt;print(&quot;UseSSE=%d&quot;, (int) UseSSE);
1600     if (UseAVX &gt; 0) {
1601       log-&gt;print(&quot;  UseAVX=%d&quot;, (int) UseAVX);
1602     }
1603     if (UseAES) {
1604       log-&gt;print(&quot;  UseAES=1&quot;);
1605     }
1606 #ifdef COMPILER2
1607     if (MaxVectorSize &gt; 0) {
1608       log-&gt;print(&quot;  MaxVectorSize=%d&quot;, (int) MaxVectorSize);
1609     }
1610 #endif
1611     log-&gt;cr();
1612     log-&gt;print(&quot;Allocation&quot;);
1613     if (AllocatePrefetchStyle &lt;= 0 || (UseSSE == 0 &amp;&amp; !supports_3dnow_prefetch())) {
1614       log-&gt;print_cr(&quot;: no prefetching&quot;);
1615     } else {
1616       log-&gt;print(&quot; prefetching: &quot;);
1617       if (UseSSE == 0 &amp;&amp; supports_3dnow_prefetch()) {
1618         log-&gt;print(&quot;PREFETCHW&quot;);
1619       } else if (UseSSE &gt;= 1) {
1620         if (AllocatePrefetchInstr == 0) {
1621           log-&gt;print(&quot;PREFETCHNTA&quot;);
1622         } else if (AllocatePrefetchInstr == 1) {
1623           log-&gt;print(&quot;PREFETCHT0&quot;);
1624         } else if (AllocatePrefetchInstr == 2) {
1625           log-&gt;print(&quot;PREFETCHT2&quot;);
1626         } else if (AllocatePrefetchInstr == 3) {
1627           log-&gt;print(&quot;PREFETCHW&quot;);
1628         }
1629       }
1630       if (AllocatePrefetchLines &gt; 1) {
1631         log-&gt;print_cr(&quot; at distance %d, %d lines of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);
1632       } else {
1633         log-&gt;print_cr(&quot; at distance %d, one line of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);
1634       }
1635     }
1636 
1637     if (PrefetchCopyIntervalInBytes &gt; 0) {
1638       log-&gt;print_cr(&quot;PrefetchCopyIntervalInBytes %d&quot;, (int) PrefetchCopyIntervalInBytes);
1639     }
1640     if (PrefetchScanIntervalInBytes &gt; 0) {
1641       log-&gt;print_cr(&quot;PrefetchScanIntervalInBytes %d&quot;, (int) PrefetchScanIntervalInBytes);
1642     }
1643     if (PrefetchFieldsAhead &gt; 0) {
1644       log-&gt;print_cr(&quot;PrefetchFieldsAhead %d&quot;, (int) PrefetchFieldsAhead);
1645     }
1646     if (ContendedPaddingWidth &gt; 0) {
1647       log-&gt;print_cr(&quot;ContendedPaddingWidth %d&quot;, (int) ContendedPaddingWidth);
1648     }
1649   }
1650 #endif // !PRODUCT
1651 }
1652 
1653 void VM_Version::print_platform_virtualization_info(outputStream* st) {
1654   VirtualizationType vrt = VM_Version::get_detected_virtualization();
1655   if (vrt == XenHVM) {
1656     st-&gt;print_cr(&quot;Xen hardware-assisted virtualization detected&quot;);
1657   } else if (vrt == KVM) {
1658     st-&gt;print_cr(&quot;KVM virtualization detected&quot;);
1659   } else if (vrt == VMWare) {
1660     st-&gt;print_cr(&quot;VMWare virtualization detected&quot;);
1661     VirtualizationSupport::print_virtualization_info(st);
1662   } else if (vrt == HyperV) {
1663     st-&gt;print_cr(&quot;HyperV virtualization detected&quot;);
1664   }
1665 }
1666 
1667 void VM_Version::check_virt_cpuid(uint32_t idx, uint32_t *regs) {
1668 // TODO support 32 bit
1669 #if defined(_LP64)
1670 #if defined(_MSC_VER)
1671   // Allocate space for the code
1672   const int code_size = 100;
1673   ResourceMark rm;
1674   CodeBuffer cb(&quot;detect_virt&quot;, code_size, 0);
1675   MacroAssembler* a = new MacroAssembler(&amp;cb);
1676   address code = a-&gt;pc();
1677   void (*test)(uint32_t idx, uint32_t *regs) = (void(*)(uint32_t idx, uint32_t *regs))code;
1678 
1679   a-&gt;movq(r9, rbx); // save nonvolatile register
1680 
1681   // next line would not work on 32-bit
1682   a-&gt;movq(rax, c_rarg0 /* rcx */);
1683   a-&gt;movq(r8, c_rarg1 /* rdx */);
1684   a-&gt;cpuid();
1685   a-&gt;movl(Address(r8,  0), rax);
1686   a-&gt;movl(Address(r8,  4), rbx);
1687   a-&gt;movl(Address(r8,  8), rcx);
1688   a-&gt;movl(Address(r8, 12), rdx);
1689 
1690   a-&gt;movq(rbx, r9); // restore nonvolatile register
1691   a-&gt;ret(0);
1692 
1693   uint32_t *code_end = (uint32_t *)a-&gt;pc();
1694   a-&gt;flush();
1695 
1696   // execute code
1697   (*test)(idx, regs);
1698 #elif defined(__GNUC__)
1699   __asm__ volatile (
1700      &quot;        cpuid;&quot;
1701      &quot;        mov %%eax,(%1);&quot;
1702      &quot;        mov %%ebx,4(%1);&quot;
1703      &quot;        mov %%ecx,8(%1);&quot;
1704      &quot;        mov %%edx,12(%1);&quot;
1705      : &quot;+a&quot; (idx)
1706      : &quot;S&quot; (regs)
1707      : &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;memory&quot; );
1708 #endif
1709 #endif
1710 }
1711 
1712 
1713 bool VM_Version::use_biased_locking() {
1714 #if INCLUDE_RTM_OPT
1715   // RTM locking is most useful when there is high lock contention and
1716   // low data contention.  With high lock contention the lock is usually
1717   // inflated and biased locking is not suitable for that case.
1718   // RTM locking code requires that biased locking is off.
1719   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
1720   // because it is used by Thread::allocate() which is called before
1721   // VM_Version::initialize().
1722   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
1723     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
1724       FLAG_SET_DEFAULT(UseBiasedLocking, false);
1725     } else {
1726       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
1727       UseBiasedLocking = false;
1728     }
1729   }
1730 #endif
1731   return UseBiasedLocking;
1732 }
1733 
<a name="12" id="anc12"></a><span class="line-added">1734 bool VM_Version::compute_has_intel_jcc_erratum() {</span>
<span class="line-added">1735   if (!is_intel_family_core()) {</span>
<span class="line-added">1736     // Only Intel CPUs are affected.</span>
<span class="line-added">1737     return false;</span>
<span class="line-added">1738   }</span>
<span class="line-added">1739   // The following table of affected CPUs is based on the following document released by Intel:</span>
<span class="line-added">1740   // https://www.intel.com/content/dam/support/us/en/documents/processors/mitigations-jump-conditional-code-erratum.pdf</span>
<span class="line-added">1741   switch (_model) {</span>
<span class="line-added">1742   case 0x8E:</span>
<span class="line-added">1743     // 06_8EH | 9 | 8th Generation Intel Core Processor Family based on microarchitecture code name Amber Lake Y</span>
<span class="line-added">1744     // 06_8EH | 9 | 7th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake U</span>
<span class="line-added">1745     // 06_8EH | 9 | 7th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake U 23e</span>
<span class="line-added">1746     // 06_8EH | 9 | 7th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake Y</span>
<span class="line-added">1747     // 06_8EH | A | 8th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake U43e</span>
<span class="line-added">1748     // 06_8EH | B | 8th Generation Intel Core Processors based on microarchitecture code name Whiskey Lake U</span>
<span class="line-added">1749     // 06_8EH | C | 8th Generation Intel Core Processor Family based on microarchitecture code name Amber Lake Y</span>
<span class="line-added">1750     // 06_8EH | C | 10th Generation Intel Core Processor Family based on microarchitecture code name Comet Lake U42</span>
<span class="line-added">1751     // 06_8EH | C | 8th Generation Intel Core Processors based on microarchitecture code name Whiskey Lake U</span>
<span class="line-added">1752     return _stepping == 0x9 || _stepping == 0xA || _stepping == 0xB || _stepping == 0xC;</span>
<span class="line-added">1753   case 0x4E:</span>
<span class="line-added">1754     // 06_4E  | 3 | 6th Generation Intel Core Processors based on microarchitecture code name Skylake U</span>
<span class="line-added">1755     // 06_4E  | 3 | 6th Generation Intel Core Processor Family based on microarchitecture code name Skylake U23e</span>
<span class="line-added">1756     // 06_4E  | 3 | 6th Generation Intel Core Processors based on microarchitecture code name Skylake Y</span>
<span class="line-added">1757     return _stepping == 0x3;</span>
<span class="line-added">1758   case 0x55:</span>
<span class="line-added">1759     // 06_55H | 4 | Intel Xeon Processor D Family based on microarchitecture code name Skylake D, Bakerville</span>
<span class="line-added">1760     // 06_55H | 4 | Intel Xeon Scalable Processors based on microarchitecture code name Skylake Server</span>
<span class="line-added">1761     // 06_55H | 4 | Intel Xeon Processor W Family based on microarchitecture code name Skylake W</span>
<span class="line-added">1762     // 06_55H | 4 | Intel Core X-series Processors based on microarchitecture code name Skylake X</span>
<span class="line-added">1763     // 06_55H | 4 | Intel Xeon Processor E3 v5 Family based on microarchitecture code name Skylake Xeon E3</span>
<span class="line-added">1764     // 06_55  | 7 | 2nd Generation Intel Xeon Scalable Processors based on microarchitecture code name Cascade Lake (server)</span>
<span class="line-added">1765     return _stepping == 0x4 || _stepping == 0x7;</span>
<span class="line-added">1766   case 0x5E:</span>
<span class="line-added">1767     // 06_5E  | 3 | 6th Generation Intel Core Processor Family based on microarchitecture code name Skylake H</span>
<span class="line-added">1768     // 06_5E  | 3 | 6th Generation Intel Core Processor Family based on microarchitecture code name Skylake S</span>
<span class="line-added">1769     return _stepping == 0x3;</span>
<span class="line-added">1770   case 0x9E:</span>
<span class="line-added">1771     // 06_9EH | 9 | 8th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake G</span>
<span class="line-added">1772     // 06_9EH | 9 | 7th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake H</span>
<span class="line-added">1773     // 06_9EH | 9 | 7th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake S</span>
<span class="line-added">1774     // 06_9EH | 9 | Intel Core X-series Processors based on microarchitecture code name Kaby Lake X</span>
<span class="line-added">1775     // 06_9EH | 9 | Intel Xeon Processor E3 v6 Family Kaby Lake Xeon E3</span>
<span class="line-added">1776     // 06_9EH | A | 8th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake H</span>
<span class="line-added">1777     // 06_9EH | A | 8th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake S</span>
<span class="line-added">1778     // 06_9EH | A | 8th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake S (6+2) x/KBP</span>
<span class="line-added">1779     // 06_9EH | A | Intel Xeon Processor E Family based on microarchitecture code name Coffee Lake S (6+2)</span>
<span class="line-added">1780     // 06_9EH | A | Intel Xeon Processor E Family based on microarchitecture code name Coffee Lake S (4+2)</span>
<span class="line-added">1781     // 06_9EH | B | 8th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake S (4+2)</span>
<span class="line-added">1782     // 06_9EH | B | Intel Celeron Processor G Series based on microarchitecture code name Coffee Lake S (4+2)</span>
<span class="line-added">1783     // 06_9EH | D | 9th Generation Intel Core Processor Family based on microarchitecturecode name Coffee Lake H (8+2)</span>
<span class="line-added">1784     // 06_9EH | D | 9th Generation Intel Core Processor Family based on microarchitecture code name Coffee Lake S (8+2)</span>
<span class="line-added">1785     return _stepping == 0x9 || _stepping == 0xA || _stepping == 0xB || _stepping == 0xD;</span>
<span class="line-added">1786   case 0xA6:</span>
<span class="line-added">1787     // 06_A6H | 0  | 10th Generation Intel Core Processor Family based on microarchitecture code name Comet Lake U62</span>
<span class="line-added">1788     return _stepping == 0x0;</span>
<span class="line-added">1789   case 0xAE:</span>
<span class="line-added">1790     // 06_AEH | A | 8th Generation Intel Core Processor Family based on microarchitecture code name Kaby Lake Refresh U (4+2)</span>
<span class="line-added">1791     return _stepping == 0xA;</span>
<span class="line-added">1792   default:</span>
<span class="line-added">1793     // If we are running on another intel machine not recognized in the table, we are okay.</span>
<span class="line-added">1794     return false;</span>
<span class="line-added">1795   }</span>
<span class="line-added">1796 }</span>
<span class="line-added">1797 </span>
1798 // On Xen, the cpuid instruction returns
1799 //  eax / registers[0]: Version of Xen
1800 //  ebx / registers[1]: chars &#39;XenV&#39;
1801 //  ecx / registers[2]: chars &#39;MMXe&#39;
1802 //  edx / registers[3]: chars &#39;nVMM&#39;
1803 //
1804 // On KVM / VMWare / MS Hyper-V, the cpuid instruction returns
1805 //  ebx / registers[1]: chars &#39;KVMK&#39; / &#39;VMwa&#39; / &#39;Micr&#39;
1806 //  ecx / registers[2]: chars &#39;VMKV&#39; / &#39;reVM&#39; / &#39;osof&#39;
1807 //  edx / registers[3]: chars &#39;M&#39;    / &#39;ware&#39; / &#39;t Hv&#39;
1808 //
1809 // more information :
1810 // https://kb.vmware.com/s/article/1009458
1811 //
1812 void VM_Version::check_virtualizations() {
1813 #if defined(_LP64)
1814   uint32_t registers[4];
1815   char signature[13];
1816   uint32_t base;
1817   signature[12] = &#39;\0&#39;;
1818   memset((void*)registers, 0, 4*sizeof(uint32_t));
1819 
1820   for (base = 0x40000000; base &lt; 0x40010000; base += 0x100) {
1821     check_virt_cpuid(base, registers);
1822 
1823     *(uint32_t *)(signature + 0) = registers[1];
1824     *(uint32_t *)(signature + 4) = registers[2];
1825     *(uint32_t *)(signature + 8) = registers[3];
1826 
1827     if (strncmp(&quot;VMwareVMware&quot;, signature, 12) == 0) {
1828       Abstract_VM_Version::_detected_virtualization = VMWare;
1829       // check for extended metrics from guestlib
1830       VirtualizationSupport::initialize();
1831     }
1832 
1833     if (strncmp(&quot;Microsoft Hv&quot;, signature, 12) == 0) {
1834       Abstract_VM_Version::_detected_virtualization = HyperV;
1835     }
1836 
1837     if (strncmp(&quot;KVMKVMKVM&quot;, signature, 9) == 0) {
1838       Abstract_VM_Version::_detected_virtualization = KVM;
1839     }
1840 
1841     if (strncmp(&quot;XenVMMXenVMM&quot;, signature, 12) == 0) {
1842       Abstract_VM_Version::_detected_virtualization = XenHVM;
1843     }
1844   }
1845 #endif
1846 }
1847 
1848 void VM_Version::initialize() {
1849   ResourceMark rm;
1850   // Making this stub must be FIRST use of assembler
1851 
1852   stub_blob = BufferBlob::create(&quot;get_cpu_info_stub&quot;, stub_size);
1853   if (stub_blob == NULL) {
1854     vm_exit_during_initialization(&quot;Unable to allocate get_cpu_info_stub&quot;);
1855   }
1856   CodeBuffer c(stub_blob);
1857   VM_Version_StubGenerator g(&amp;c);
1858   get_cpu_info_stub = CAST_TO_FN_PTR(get_cpu_info_stub_t,
1859                                      g.generate_get_cpu_info());
1860 
1861   get_processor_features();
<a name="13" id="anc13"></a><span class="line-added">1862 </span>
<span class="line-added">1863   LP64_ONLY(Assembler::precompute_instructions();)</span>
<span class="line-added">1864 </span>
1865   if (cpu_family() &gt; 4) { // it supports CPUID
1866     check_virtualizations();
1867   }
1868 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>