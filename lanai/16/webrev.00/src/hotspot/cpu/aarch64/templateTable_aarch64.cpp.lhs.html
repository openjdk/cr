<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/methodData.hpp&quot;
  35 #include &quot;oops/method.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
<a name="1" id="anc1"></a>
  43 
  44 #define __ _masm-&gt;
  45 
  46 // Platform-dependent initialization
  47 
  48 void TemplateTable::pd_initialize() {
  49   // No aarch64 specific initialization
  50 }
  51 
  52 // Address computation: local variables
  53 
  54 static inline Address iaddress(int n) {
  55   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  56 }
  57 
  58 static inline Address laddress(int n) {
  59   return iaddress(n + 1);
  60 }
  61 
  62 static inline Address faddress(int n) {
  63   return iaddress(n);
  64 }
  65 
  66 static inline Address daddress(int n) {
  67   return laddress(n);
  68 }
  69 
  70 static inline Address aaddress(int n) {
  71   return iaddress(n);
  72 }
  73 
  74 static inline Address iaddress(Register r) {
  75   return Address(rlocals, r, Address::lsl(3));
  76 }
  77 
  78 static inline Address laddress(Register r, Register scratch,
  79                                InterpreterMacroAssembler* _masm) {
  80   __ lea(scratch, Address(rlocals, r, Address::lsl(3)));
  81   return Address(scratch, Interpreter::local_offset_in_bytes(1));
  82 }
  83 
  84 static inline Address faddress(Register r) {
  85   return iaddress(r);
  86 }
  87 
  88 static inline Address daddress(Register r, Register scratch,
  89                                InterpreterMacroAssembler* _masm) {
  90   return laddress(r, scratch, _masm);
  91 }
  92 
  93 static inline Address aaddress(Register r) {
  94   return iaddress(r);
  95 }
  96 
  97 static inline Address at_rsp() {
  98   return Address(esp, 0);
  99 }
 100 
 101 // At top of Java expression stack which may be different than esp().  It
 102 // isn&#39;t for category 1 objects.
 103 static inline Address at_tos   () {
 104   return Address(esp,  Interpreter::expr_offset_in_bytes(0));
 105 }
 106 
 107 static inline Address at_tos_p1() {
 108   return Address(esp,  Interpreter::expr_offset_in_bytes(1));
 109 }
 110 
 111 static inline Address at_tos_p2() {
 112   return Address(esp,  Interpreter::expr_offset_in_bytes(2));
 113 }
 114 
 115 static inline Address at_tos_p3() {
 116   return Address(esp,  Interpreter::expr_offset_in_bytes(3));
 117 }
 118 
 119 static inline Address at_tos_p4() {
 120   return Address(esp,  Interpreter::expr_offset_in_bytes(4));
 121 }
 122 
 123 static inline Address at_tos_p5() {
 124   return Address(esp,  Interpreter::expr_offset_in_bytes(5));
 125 }
 126 
 127 // Condition conversion
 128 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 129   switch (cc) {
 130   case TemplateTable::equal        : return Assembler::NE;
 131   case TemplateTable::not_equal    : return Assembler::EQ;
 132   case TemplateTable::less         : return Assembler::GE;
 133   case TemplateTable::less_equal   : return Assembler::GT;
 134   case TemplateTable::greater      : return Assembler::LE;
 135   case TemplateTable::greater_equal: return Assembler::LT;
 136   }
 137   ShouldNotReachHere();
 138   return Assembler::EQ;
 139 }
 140 
 141 
 142 // Miscelaneous helper routines
 143 // Store an oop (or NULL) at the Address described by obj.
 144 // If val == noreg this means store a NULL
 145 static void do_oop_store(InterpreterMacroAssembler* _masm,
 146                          Address dst,
 147                          Register val,
 148                          DecoratorSet decorators) {
 149   assert(val == noreg || val == r0, &quot;parameter is just for looks&quot;);
 150   __ store_heap_oop(dst, val, r10, r1, decorators);
 151 }
 152 
 153 static void do_oop_load(InterpreterMacroAssembler* _masm,
 154                         Address src,
 155                         Register dst,
 156                         DecoratorSet decorators) {
 157   __ load_heap_oop(dst, src, r10, r1, decorators);
 158 }
 159 
 160 Address TemplateTable::at_bcp(int offset) {
 161   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 162   return Address(rbcp, offset);
 163 }
 164 
 165 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 166                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 167                                    int byte_no)
 168 {
 169   if (!RewriteBytecodes)  return;
 170   Label L_patch_done;
 171 
 172   switch (bc) {
 173   case Bytecodes::_fast_aputfield:
 174   case Bytecodes::_fast_bputfield:
 175   case Bytecodes::_fast_zputfield:
 176   case Bytecodes::_fast_cputfield:
 177   case Bytecodes::_fast_dputfield:
 178   case Bytecodes::_fast_fputfield:
 179   case Bytecodes::_fast_iputfield:
 180   case Bytecodes::_fast_lputfield:
 181   case Bytecodes::_fast_sputfield:
 182     {
 183       // We skip bytecode quickening for putfield instructions when
 184       // the put_code written to the constant pool cache is zero.
 185       // This is required so that every execution of this instruction
 186       // calls out to InterpreterRuntime::resolve_get_put to do
 187       // additional, required work.
 188       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 189       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 190       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 191       __ movw(bc_reg, bc);
 192       __ cbzw(temp_reg, L_patch_done);  // don&#39;t patch
 193     }
 194     break;
 195   default:
 196     assert(byte_no == -1, &quot;sanity&quot;);
 197     // the pair bytecodes have already done the load.
 198     if (load_bc_into_bc_reg) {
 199       __ movw(bc_reg, bc);
 200     }
 201   }
 202 
 203   if (JvmtiExport::can_post_breakpoint()) {
 204     Label L_fast_patch;
 205     // if a breakpoint is present we can&#39;t rewrite the stream directly
 206     __ load_unsigned_byte(temp_reg, at_bcp(0));
 207     __ cmpw(temp_reg, Bytecodes::_breakpoint);
 208     __ br(Assembler::NE, L_fast_patch);
 209     // Let breakpoint table handling rewrite to quicker bytecode
 210     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), rmethod, rbcp, bc_reg);
 211     __ b(L_patch_done);
 212     __ bind(L_fast_patch);
 213   }
 214 
 215 #ifdef ASSERT
 216   Label L_okay;
 217   __ load_unsigned_byte(temp_reg, at_bcp(0));
 218   __ cmpw(temp_reg, (int) Bytecodes::java_code(bc));
 219   __ br(Assembler::EQ, L_okay);
 220   __ cmpw(temp_reg, bc_reg);
 221   __ br(Assembler::EQ, L_okay);
 222   __ stop(&quot;patching the wrong bytecode&quot;);
 223   __ bind(L_okay);
 224 #endif
 225 
 226   // patch bytecode
 227   __ strb(bc_reg, at_bcp(0));
 228   __ bind(L_patch_done);
 229 }
 230 
 231 
 232 // Individual instructions
 233 
 234 void TemplateTable::nop() {
 235   transition(vtos, vtos);
 236   // nothing to do
 237 }
 238 
 239 void TemplateTable::shouldnotreachhere() {
 240   transition(vtos, vtos);
 241   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 242 }
 243 
 244 void TemplateTable::aconst_null()
 245 {
 246   transition(vtos, atos);
 247   __ mov(r0, 0);
 248 }
 249 
 250 void TemplateTable::iconst(int value)
 251 {
 252   transition(vtos, itos);
 253   __ mov(r0, value);
 254 }
 255 
 256 void TemplateTable::lconst(int value)
 257 {
 258   __ mov(r0, value);
 259 }
 260 
 261 void TemplateTable::fconst(int value)
 262 {
 263   transition(vtos, ftos);
 264   switch (value) {
 265   case 0:
 266     __ fmovs(v0, zr);
 267     break;
 268   case 1:
 269     __ fmovs(v0, 1.0);
 270     break;
 271   case 2:
 272     __ fmovs(v0, 2.0);
 273     break;
 274   default:
 275     ShouldNotReachHere();
 276     break;
 277   }
 278 }
 279 
 280 void TemplateTable::dconst(int value)
 281 {
 282   transition(vtos, dtos);
 283   switch (value) {
 284   case 0:
 285     __ fmovd(v0, zr);
 286     break;
 287   case 1:
 288     __ fmovd(v0, 1.0);
 289     break;
 290   case 2:
 291     __ fmovd(v0, 2.0);
 292     break;
 293   default:
 294     ShouldNotReachHere();
 295     break;
 296   }
 297 }
 298 
 299 void TemplateTable::bipush()
 300 {
 301   transition(vtos, itos);
 302   __ load_signed_byte32(r0, at_bcp(1));
 303 }
 304 
 305 void TemplateTable::sipush()
 306 {
 307   transition(vtos, itos);
 308   __ load_unsigned_short(r0, at_bcp(1));
 309   __ revw(r0, r0);
 310   __ asrw(r0, r0, 16);
 311 }
 312 
 313 void TemplateTable::ldc(bool wide)
 314 {
 315   transition(vtos, vtos);
 316   Label call_ldc, notFloat, notClass, notInt, Done;
 317 
 318   if (wide) {
 319     __ get_unsigned_2_byte_index_at_bcp(r1, 1);
 320   } else {
 321     __ load_unsigned_byte(r1, at_bcp(1));
 322   }
 323   __ get_cpool_and_tags(r2, r0);
 324 
 325   const int base_offset = ConstantPool::header_size() * wordSize;
 326   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 327 
 328   // get type
 329   __ add(r3, r1, tags_offset);
 330   __ lea(r3, Address(r0, r3));
 331   __ ldarb(r3, r3);
 332 
 333   // unresolved class - get the resolved class
 334   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClass);
 335   __ br(Assembler::EQ, call_ldc);
 336 
 337   // unresolved class in error state - call into runtime to throw the error
 338   // from the first resolution attempt
 339   __ cmp(r3, (u1)JVM_CONSTANT_UnresolvedClassInError);
 340   __ br(Assembler::EQ, call_ldc);
 341 
 342   // resolved class - need to call vm to get java mirror of the class
 343   __ cmp(r3, (u1)JVM_CONSTANT_Class);
 344   __ br(Assembler::NE, notClass);
 345 
 346   __ bind(call_ldc);
 347   __ mov(c_rarg1, wide);
 348   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), c_rarg1);
 349   __ push_ptr(r0);
 350   __ verify_oop(r0);
 351   __ b(Done);
 352 
 353   __ bind(notClass);
 354   __ cmp(r3, (u1)JVM_CONSTANT_Float);
 355   __ br(Assembler::NE, notFloat);
 356   // ftos
 357   __ adds(r1, r2, r1, Assembler::LSL, 3);
 358   __ ldrs(v0, Address(r1, base_offset));
 359   __ push_f();
 360   __ b(Done);
 361 
 362   __ bind(notFloat);
 363 
 364   __ cmp(r3, (u1)JVM_CONSTANT_Integer);
 365   __ br(Assembler::NE, notInt);
 366 
 367   // itos
 368   __ adds(r1, r2, r1, Assembler::LSL, 3);
 369   __ ldrw(r0, Address(r1, base_offset));
 370   __ push_i(r0);
 371   __ b(Done);
 372 
 373   __ bind(notInt);
 374   condy_helper(Done);
 375 
 376   __ bind(Done);
 377 }
 378 
 379 // Fast path for caching oop constants.
 380 void TemplateTable::fast_aldc(bool wide)
 381 {
 382   transition(vtos, atos);
 383 
 384   Register result = r0;
 385   Register tmp = r1;
 386   Register rarg = r2;
 387 
 388   int index_size = wide ? sizeof(u2) : sizeof(u1);
 389 
 390   Label resolved;
 391 
 392   // We are resolved if the resolved reference cache entry contains a
 393   // non-null object (String, MethodType, etc.)
 394   assert_different_registers(result, tmp);
 395   __ get_cache_index_at_bcp(tmp, 1, index_size);
 396   __ load_resolved_reference_at_index(result, tmp);
 397   __ cbnz(result, resolved);
 398 
 399   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 400 
 401   // first time invocation - must resolve first
 402   __ mov(rarg, (int)bytecode());
 403   __ call_VM(result, entry, rarg);
 404 
 405   __ bind(resolved);
 406 
 407   { // Check for the null sentinel.
 408     // If we just called the VM, it already did the mapping for us,
 409     // but it&#39;s harmless to retry.
 410     Label notNull;
 411 
 412     // Stash null_sentinel address to get its value later
 413     __ movptr(rarg, (uintptr_t)Universe::the_null_sentinel_addr());
 414     __ ldr(tmp, Address(rarg));
 415     __ cmpoop(result, tmp);
 416     __ br(Assembler::NE, notNull);
 417     __ mov(result, 0);  // NULL object reference
 418     __ bind(notNull);
 419   }
 420 
 421   if (VerifyOops) {
 422     // Safe to call with 0 result
 423     __ verify_oop(result);
 424   }
 425 }
 426 
 427 void TemplateTable::ldc2_w()
 428 {
 429   transition(vtos, vtos);
 430   Label notDouble, notLong, Done;
 431   __ get_unsigned_2_byte_index_at_bcp(r0, 1);
 432 
 433   __ get_cpool_and_tags(r1, r2);
 434   const int base_offset = ConstantPool::header_size() * wordSize;
 435   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 436 
 437   // get type
 438   __ lea(r2, Address(r2, r0, Address::lsl(0)));
 439   __ load_unsigned_byte(r2, Address(r2, tags_offset));
 440   __ cmpw(r2, (int)JVM_CONSTANT_Double);
 441   __ br(Assembler::NE, notDouble);
 442 
 443   // dtos
 444   __ lea (r2, Address(r1, r0, Address::lsl(3)));
 445   __ ldrd(v0, Address(r2, base_offset));
 446   __ push_d();
 447   __ b(Done);
 448 
 449   __ bind(notDouble);
 450   __ cmpw(r2, (int)JVM_CONSTANT_Long);
 451   __ br(Assembler::NE, notLong);
 452 
 453   // ltos
 454   __ lea(r0, Address(r1, r0, Address::lsl(3)));
 455   __ ldr(r0, Address(r0, base_offset));
 456   __ push_l();
 457   __ b(Done);
 458 
 459   __ bind(notLong);
 460   condy_helper(Done);
 461 
 462   __ bind(Done);
 463 }
 464 
 465 void TemplateTable::condy_helper(Label&amp; Done)
 466 {
 467   Register obj = r0;
 468   Register rarg = r1;
 469   Register flags = r2;
 470   Register off = r3;
 471 
 472   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 473 
 474   __ mov(rarg, (int) bytecode());
 475   __ call_VM(obj, entry, rarg);
 476 
 477   __ get_vm_result_2(flags, rthread);
 478 
 479   // VMr = obj = base address to find primitive value to push
 480   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 481   __ mov(off, flags);
 482   __ andw(off, off, ConstantPoolCacheEntry::field_index_mask);
 483 
 484   const Address field(obj, off);
 485 
 486   // What sort of thing are we loading?
 487   // x86 uses a shift and mask or wings it with a shift plus assert
 488   // the mask is not needed. aarch64 just uses bitfield extract
 489   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,
 490            ConstantPoolCacheEntry::tos_state_bits);
 491 
 492   switch (bytecode()) {
 493     case Bytecodes::_ldc:
 494     case Bytecodes::_ldc_w:
 495       {
 496         // tos in (itos, ftos, stos, btos, ctos, ztos)
 497         Label notInt, notFloat, notShort, notByte, notChar, notBool;
 498         __ cmpw(flags, itos);
 499         __ br(Assembler::NE, notInt);
 500         // itos
 501         __ ldrw(r0, field);
 502         __ push(itos);
 503         __ b(Done);
 504 
 505         __ bind(notInt);
 506         __ cmpw(flags, ftos);
 507         __ br(Assembler::NE, notFloat);
 508         // ftos
 509         __ load_float(field);
 510         __ push(ftos);
 511         __ b(Done);
 512 
 513         __ bind(notFloat);
 514         __ cmpw(flags, stos);
 515         __ br(Assembler::NE, notShort);
 516         // stos
 517         __ load_signed_short(r0, field);
 518         __ push(stos);
 519         __ b(Done);
 520 
 521         __ bind(notShort);
 522         __ cmpw(flags, btos);
 523         __ br(Assembler::NE, notByte);
 524         // btos
 525         __ load_signed_byte(r0, field);
 526         __ push(btos);
 527         __ b(Done);
 528 
 529         __ bind(notByte);
 530         __ cmpw(flags, ctos);
 531         __ br(Assembler::NE, notChar);
 532         // ctos
 533         __ load_unsigned_short(r0, field);
 534         __ push(ctos);
 535         __ b(Done);
 536 
 537         __ bind(notChar);
 538         __ cmpw(flags, ztos);
 539         __ br(Assembler::NE, notBool);
 540         // ztos
 541         __ load_signed_byte(r0, field);
 542         __ push(ztos);
 543         __ b(Done);
 544 
 545         __ bind(notBool);
 546         break;
 547       }
 548 
 549     case Bytecodes::_ldc2_w:
 550       {
 551         Label notLong, notDouble;
 552         __ cmpw(flags, ltos);
 553         __ br(Assembler::NE, notLong);
 554         // ltos
 555         __ ldr(r0, field);
 556         __ push(ltos);
 557         __ b(Done);
 558 
 559         __ bind(notLong);
 560         __ cmpw(flags, dtos);
 561         __ br(Assembler::NE, notDouble);
 562         // dtos
 563         __ load_double(field);
 564         __ push(dtos);
 565         __ b(Done);
 566 
 567        __ bind(notDouble);
 568         break;
 569       }
 570 
 571     default:
 572       ShouldNotReachHere();
 573     }
 574 
 575     __ stop(&quot;bad ldc/condy&quot;);
 576 }
 577 
 578 void TemplateTable::locals_index(Register reg, int offset)
 579 {
 580   __ ldrb(reg, at_bcp(offset));
 581   __ neg(reg, reg);
 582 }
 583 
 584 void TemplateTable::iload() {
 585   iload_internal();
 586 }
 587 
 588 void TemplateTable::nofast_iload() {
 589   iload_internal(may_not_rewrite);
 590 }
 591 
 592 void TemplateTable::iload_internal(RewriteControl rc) {
 593   transition(vtos, itos);
 594   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 595     Label rewrite, done;
 596     Register bc = r4;
 597 
 598     // get next bytecode
 599     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 600 
 601     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 602     // last two iloads in a pair.  Comparing against fast_iload means that
 603     // the next bytecode is neither an iload or a caload, and therefore
 604     // an iload pair.
 605     __ cmpw(r1, Bytecodes::_iload);
 606     __ br(Assembler::EQ, done);
 607 
 608     // if _fast_iload rewrite to _fast_iload2
 609     __ cmpw(r1, Bytecodes::_fast_iload);
 610     __ movw(bc, Bytecodes::_fast_iload2);
 611     __ br(Assembler::EQ, rewrite);
 612 
 613     // if _caload rewrite to _fast_icaload
 614     __ cmpw(r1, Bytecodes::_caload);
 615     __ movw(bc, Bytecodes::_fast_icaload);
 616     __ br(Assembler::EQ, rewrite);
 617 
 618     // else rewrite to _fast_iload
 619     __ movw(bc, Bytecodes::_fast_iload);
 620 
 621     // rewrite
 622     // bc: new bytecode
 623     __ bind(rewrite);
 624     patch_bytecode(Bytecodes::_iload, bc, r1, false);
 625     __ bind(done);
 626 
 627   }
 628 
 629   // do iload, get the local value into tos
 630   locals_index(r1);
 631   __ ldr(r0, iaddress(r1));
 632 
 633 }
 634 
 635 void TemplateTable::fast_iload2()
 636 {
 637   transition(vtos, itos);
 638   locals_index(r1);
 639   __ ldr(r0, iaddress(r1));
 640   __ push(itos);
 641   locals_index(r1, 3);
 642   __ ldr(r0, iaddress(r1));
 643 }
 644 
 645 void TemplateTable::fast_iload()
 646 {
 647   transition(vtos, itos);
 648   locals_index(r1);
 649   __ ldr(r0, iaddress(r1));
 650 }
 651 
 652 void TemplateTable::lload()
 653 {
 654   transition(vtos, ltos);
 655   __ ldrb(r1, at_bcp(1));
 656   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 657   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 658 }
 659 
 660 void TemplateTable::fload()
 661 {
 662   transition(vtos, ftos);
 663   locals_index(r1);
 664   // n.b. we use ldrd here because this is a 64 bit slot
 665   // this is comparable to the iload case
 666   __ ldrd(v0, faddress(r1));
 667 }
 668 
 669 void TemplateTable::dload()
 670 {
 671   transition(vtos, dtos);
 672   __ ldrb(r1, at_bcp(1));
 673   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 674   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 675 }
 676 
 677 void TemplateTable::aload()
 678 {
 679   transition(vtos, atos);
 680   locals_index(r1);
 681   __ ldr(r0, iaddress(r1));
 682 }
 683 
 684 void TemplateTable::locals_index_wide(Register reg) {
 685   __ ldrh(reg, at_bcp(2));
 686   __ rev16w(reg, reg);
 687   __ neg(reg, reg);
 688 }
 689 
 690 void TemplateTable::wide_iload() {
 691   transition(vtos, itos);
 692   locals_index_wide(r1);
 693   __ ldr(r0, iaddress(r1));
 694 }
 695 
 696 void TemplateTable::wide_lload()
 697 {
 698   transition(vtos, ltos);
 699   __ ldrh(r1, at_bcp(2));
 700   __ rev16w(r1, r1);
 701   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 702   __ ldr(r0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 703 }
 704 
 705 void TemplateTable::wide_fload()
 706 {
 707   transition(vtos, ftos);
 708   locals_index_wide(r1);
 709   // n.b. we use ldrd here because this is a 64 bit slot
 710   // this is comparable to the iload case
 711   __ ldrd(v0, faddress(r1));
 712 }
 713 
 714 void TemplateTable::wide_dload()
 715 {
 716   transition(vtos, dtos);
 717   __ ldrh(r1, at_bcp(2));
 718   __ rev16w(r1, r1);
 719   __ sub(r1, rlocals, r1, ext::uxtw, LogBytesPerWord);
 720   __ ldrd(v0, Address(r1, Interpreter::local_offset_in_bytes(1)));
 721 }
 722 
 723 void TemplateTable::wide_aload()
 724 {
 725   transition(vtos, atos);
 726   locals_index_wide(r1);
 727   __ ldr(r0, aaddress(r1));
 728 }
 729 
 730 void TemplateTable::index_check(Register array, Register index)
 731 {
 732   // destroys r1, rscratch1
 733   // check array
 734   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 735   // sign extend index for use by indexed load
 736   // __ movl2ptr(index, index);
 737   // check index
 738   Register length = rscratch1;
 739   __ ldrw(length, Address(array, arrayOopDesc::length_offset_in_bytes()));
 740   __ cmpw(index, length);
 741   if (index != r1) {
 742     // ??? convention: move aberrant index into r1 for exception message
 743     assert(r1 != array, &quot;different registers&quot;);
 744     __ mov(r1, index);
 745   }
 746   Label ok;
 747   __ br(Assembler::LO, ok);
 748     // ??? convention: move array into r3 for exception message
 749   __ mov(r3, array);
 750   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 751   __ br(rscratch1);
 752   __ bind(ok);
 753 }
 754 
 755 void TemplateTable::iaload()
 756 {
 757   transition(itos, itos);
 758   __ mov(r1, r0);
 759   __ pop_ptr(r0);
 760   // r0: array
 761   // r1: index
 762   index_check(r0, r1); // leaves index in r1, kills rscratch1
 763   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
 764   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 765 }
 766 
 767 void TemplateTable::laload()
 768 {
 769   transition(itos, ltos);
 770   __ mov(r1, r0);
 771   __ pop_ptr(r0);
 772   // r0: array
 773   // r1: index
 774   index_check(r0, r1); // leaves index in r1, kills rscratch1
 775   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
 776   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 777 }
 778 
 779 void TemplateTable::faload()
 780 {
 781   transition(itos, ftos);
 782   __ mov(r1, r0);
 783   __ pop_ptr(r0);
 784   // r0: array
 785   // r1: index
 786   index_check(r0, r1); // leaves index in r1, kills rscratch1
 787   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
 788   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);
 789 }
 790 
 791 void TemplateTable::daload()
 792 {
 793   transition(itos, dtos);
 794   __ mov(r1, r0);
 795   __ pop_ptr(r0);
 796   // r0: array
 797   // r1: index
 798   index_check(r0, r1); // leaves index in r1, kills rscratch1
 799   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
 800   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);
 801 }
 802 
 803 void TemplateTable::aaload()
 804 {
 805   transition(itos, atos);
 806   __ mov(r1, r0);
 807   __ pop_ptr(r0);
 808   // r0: array
 809   // r1: index
 810   index_check(r0, r1); // leaves index in r1, kills rscratch1
 811   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
 812   do_oop_load(_masm,
 813               Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),
 814               r0,
 815               IS_ARRAY);
 816 }
 817 
 818 void TemplateTable::baload()
 819 {
 820   transition(itos, itos);
 821   __ mov(r1, r0);
 822   __ pop_ptr(r0);
 823   // r0: array
 824   // r1: index
 825   index_check(r0, r1); // leaves index in r1, kills rscratch1
 826   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
 827   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);
 828 }
 829 
 830 void TemplateTable::caload()
 831 {
 832   transition(itos, itos);
 833   __ mov(r1, r0);
 834   __ pop_ptr(r0);
 835   // r0: array
 836   // r1: index
 837   index_check(r0, r1); // leaves index in r1, kills rscratch1
 838   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 839   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 840 }
 841 
 842 // iload followed by caload frequent pair
 843 void TemplateTable::fast_icaload()
 844 {
 845   transition(vtos, itos);
 846   // load index out of locals
 847   locals_index(r2);
 848   __ ldr(r1, iaddress(r2));
 849 
 850   __ pop_ptr(r0);
 851 
 852   // r0: array
 853   // r1: index
 854   index_check(r0, r1); // leaves index in r1, kills rscratch1
 855   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
 856   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 857 }
 858 
 859 void TemplateTable::saload()
 860 {
 861   transition(itos, itos);
 862   __ mov(r1, r0);
 863   __ pop_ptr(r0);
 864   // r0: array
 865   // r1: index
 866   index_check(r0, r1); // leaves index in r1, kills rscratch1
 867   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_SHORT) &gt;&gt; 1);
 868   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);
 869 }
 870 
 871 void TemplateTable::iload(int n)
 872 {
 873   transition(vtos, itos);
 874   __ ldr(r0, iaddress(n));
 875 }
 876 
 877 void TemplateTable::lload(int n)
 878 {
 879   transition(vtos, ltos);
 880   __ ldr(r0, laddress(n));
 881 }
 882 
 883 void TemplateTable::fload(int n)
 884 {
 885   transition(vtos, ftos);
 886   __ ldrs(v0, faddress(n));
 887 }
 888 
 889 void TemplateTable::dload(int n)
 890 {
 891   transition(vtos, dtos);
 892   __ ldrd(v0, daddress(n));
 893 }
 894 
 895 void TemplateTable::aload(int n)
 896 {
 897   transition(vtos, atos);
 898   __ ldr(r0, iaddress(n));
 899 }
 900 
 901 void TemplateTable::aload_0() {
 902   aload_0_internal();
 903 }
 904 
 905 void TemplateTable::nofast_aload_0() {
 906   aload_0_internal(may_not_rewrite);
 907 }
 908 
 909 void TemplateTable::aload_0_internal(RewriteControl rc) {
 910   // According to bytecode histograms, the pairs:
 911   //
 912   // _aload_0, _fast_igetfield
 913   // _aload_0, _fast_agetfield
 914   // _aload_0, _fast_fgetfield
 915   //
 916   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 917   // _aload_0 bytecode checks if the next bytecode is either
 918   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 919   // rewrites the current bytecode into a pair bytecode; otherwise it
 920   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 921   // the pair check anymore.
 922   //
 923   // Note: If the next bytecode is _getfield, the rewrite must be
 924   //       delayed, otherwise we may miss an opportunity for a pair.
 925   //
 926   // Also rewrite frequent pairs
 927   //   aload_0, aload_1
 928   //   aload_0, iload_1
 929   // These bytecodes with a small amount of code are most profitable
 930   // to rewrite
 931   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 932     Label rewrite, done;
 933     const Register bc = r4;
 934 
 935     // get next bytecode
 936     __ load_unsigned_byte(r1, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
 937 
 938     // if _getfield then wait with rewrite
 939     __ cmpw(r1, Bytecodes::Bytecodes::_getfield);
 940     __ br(Assembler::EQ, done);
 941 
 942     // if _igetfield then rewrite to _fast_iaccess_0
 943     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 944     __ cmpw(r1, Bytecodes::_fast_igetfield);
 945     __ movw(bc, Bytecodes::_fast_iaccess_0);
 946     __ br(Assembler::EQ, rewrite);
 947 
 948     // if _agetfield then rewrite to _fast_aaccess_0
 949     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 950     __ cmpw(r1, Bytecodes::_fast_agetfield);
 951     __ movw(bc, Bytecodes::_fast_aaccess_0);
 952     __ br(Assembler::EQ, rewrite);
 953 
 954     // if _fgetfield then rewrite to _fast_faccess_0
 955     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 956     __ cmpw(r1, Bytecodes::_fast_fgetfield);
 957     __ movw(bc, Bytecodes::_fast_faccess_0);
 958     __ br(Assembler::EQ, rewrite);
 959 
 960     // else rewrite to _fast_aload0
 961     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 962     __ movw(bc, Bytecodes::Bytecodes::_fast_aload_0);
 963 
 964     // rewrite
 965     // bc: new bytecode
 966     __ bind(rewrite);
 967     patch_bytecode(Bytecodes::_aload_0, bc, r1, false);
 968 
 969     __ bind(done);
 970   }
 971 
 972   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
 973   aload(0);
 974 }
 975 
 976 void TemplateTable::istore()
 977 {
 978   transition(itos, vtos);
 979   locals_index(r1);
 980   // FIXME: We&#39;re being very pernickerty here storing a jint in a
 981   // local with strw, which costs an extra instruction over what we&#39;d
 982   // be able to do with a simple str.  We should just store the whole
 983   // word.
 984   __ lea(rscratch1, iaddress(r1));
 985   __ strw(r0, Address(rscratch1));
 986 }
 987 
 988 void TemplateTable::lstore()
 989 {
 990   transition(ltos, vtos);
 991   locals_index(r1);
 992   __ str(r0, laddress(r1, rscratch1, _masm));
 993 }
 994 
 995 void TemplateTable::fstore() {
 996   transition(ftos, vtos);
 997   locals_index(r1);
 998   __ lea(rscratch1, iaddress(r1));
 999   __ strs(v0, Address(rscratch1));
1000 }
1001 
1002 void TemplateTable::dstore() {
1003   transition(dtos, vtos);
1004   locals_index(r1);
1005   __ strd(v0, daddress(r1, rscratch1, _masm));
1006 }
1007 
1008 void TemplateTable::astore()
1009 {
1010   transition(vtos, vtos);
1011   __ pop_ptr(r0);
1012   locals_index(r1);
1013   __ str(r0, aaddress(r1));
1014 }
1015 
1016 void TemplateTable::wide_istore() {
1017   transition(vtos, vtos);
1018   __ pop_i();
1019   locals_index_wide(r1);
1020   __ lea(rscratch1, iaddress(r1));
1021   __ strw(r0, Address(rscratch1));
1022 }
1023 
1024 void TemplateTable::wide_lstore() {
1025   transition(vtos, vtos);
1026   __ pop_l();
1027   locals_index_wide(r1);
1028   __ str(r0, laddress(r1, rscratch1, _masm));
1029 }
1030 
1031 void TemplateTable::wide_fstore() {
1032   transition(vtos, vtos);
1033   __ pop_f();
1034   locals_index_wide(r1);
1035   __ lea(rscratch1, faddress(r1));
1036   __ strs(v0, rscratch1);
1037 }
1038 
1039 void TemplateTable::wide_dstore() {
1040   transition(vtos, vtos);
1041   __ pop_d();
1042   locals_index_wide(r1);
1043   __ strd(v0, daddress(r1, rscratch1, _masm));
1044 }
1045 
1046 void TemplateTable::wide_astore() {
1047   transition(vtos, vtos);
1048   __ pop_ptr(r0);
1049   locals_index_wide(r1);
1050   __ str(r0, aaddress(r1));
1051 }
1052 
1053 void TemplateTable::iastore() {
1054   transition(itos, vtos);
1055   __ pop_i(r1);
1056   __ pop_ptr(r3);
1057   // r0: value
1058   // r1: index
1059   // r3: array
1060   index_check(r3, r1); // prefer index in r1
1061   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_INT) &gt;&gt; 2);
1062   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);
1063 }
1064 
1065 void TemplateTable::lastore() {
1066   transition(ltos, vtos);
1067   __ pop_i(r1);
1068   __ pop_ptr(r3);
1069   // r0: value
1070   // r1: index
1071   // r3: array
1072   index_check(r3, r1); // prefer index in r1
1073   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_LONG) &gt;&gt; 3);
1074   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);
1075 }
1076 
1077 void TemplateTable::fastore() {
1078   transition(ftos, vtos);
1079   __ pop_i(r1);
1080   __ pop_ptr(r3);
1081   // v0: value
1082   // r1:  index
1083   // r3:  array
1084   index_check(r3, r1); // prefer index in r1
1085   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_FLOAT) &gt;&gt; 2);
1086   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg /* ftos */, noreg, noreg);
1087 }
1088 
1089 void TemplateTable::dastore() {
1090   transition(dtos, vtos);
1091   __ pop_i(r1);
1092   __ pop_ptr(r3);
1093   // v0: value
1094   // r1:  index
1095   // r3:  array
1096   index_check(r3, r1); // prefer index in r1
1097   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_DOUBLE) &gt;&gt; 3);
1098   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg /* dtos */, noreg, noreg);
1099 }
1100 
1101 void TemplateTable::aastore() {
1102   Label is_null, ok_is_subtype, done;
1103   transition(vtos, vtos);
1104   // stack: ..., array, index, value
1105   __ ldr(r0, at_tos());    // value
1106   __ ldr(r2, at_tos_p1()); // index
1107   __ ldr(r3, at_tos_p2()); // array
1108 
1109   Address element_address(r3, r4, Address::uxtw(LogBytesPerHeapOop));
1110 
1111   index_check(r3, r2);     // kills r1
1112   __ add(r4, r2, arrayOopDesc::base_offset_in_bytes(T_OBJECT) &gt;&gt; LogBytesPerHeapOop);
1113 
1114   // do array store check - check for NULL value first
1115   __ cbz(r0, is_null);
1116 
1117   // Move subklass into r1
1118   __ load_klass(r1, r0);
1119   // Move superklass into r0
1120   __ load_klass(r0, r3);
1121   __ ldr(r0, Address(r0,
1122                      ObjArrayKlass::element_klass_offset()));
1123   // Compress array + index*oopSize + 12 into a single register.  Frees r2.
1124 
1125   // Generate subtype check.  Blows r2, r5
1126   // Superklass in r0.  Subklass in r1.
1127   __ gen_subtype_check(r1, ok_is_subtype);
1128 
1129   // Come here on failure
1130   // object is at TOS
1131   __ b(Interpreter::_throw_ArrayStoreException_entry);
1132 
1133   // Come here on success
1134   __ bind(ok_is_subtype);
1135 
1136   // Get the value we will store
1137   __ ldr(r0, at_tos());
1138   // Now store using the appropriate barrier
1139   do_oop_store(_masm, element_address, r0, IS_ARRAY);
1140   __ b(done);
1141 
1142   // Have a NULL in r0, r3=array, r2=index.  Store NULL at ary[idx]
1143   __ bind(is_null);
1144   __ profile_null_seen(r2);
1145 
1146   // Store a NULL
1147   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1148 
1149   // Pop stack arguments
1150   __ bind(done);
1151   __ add(esp, esp, 3 * Interpreter::stackElementSize);
1152 }
1153 
1154 void TemplateTable::bastore()
1155 {
1156   transition(itos, vtos);
1157   __ pop_i(r1);
1158   __ pop_ptr(r3);
1159   // r0: value
1160   // r1: index
1161   // r3: array
1162   index_check(r3, r1); // prefer index in r1
1163 
1164   // Need to check whether array is boolean or byte
1165   // since both types share the bastore bytecode.
1166   __ load_klass(r2, r3);
1167   __ ldrw(r2, Address(r2, Klass::layout_helper_offset()));
1168   int diffbit_index = exact_log2(Klass::layout_helper_boolean_diffbit());
1169   Label L_skip;
1170   __ tbz(r2, diffbit_index, L_skip);
1171   __ andw(r0, r0, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1172   __ bind(L_skip);
1173 
1174   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_BYTE) &gt;&gt; 0);
1175   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);
1176 }
1177 
1178 void TemplateTable::castore()
1179 {
1180   transition(itos, vtos);
1181   __ pop_i(r1);
1182   __ pop_ptr(r3);
1183   // r0: value
1184   // r1: index
1185   // r3: array
1186   index_check(r3, r1); // prefer index in r1
1187   __ add(r1, r1, arrayOopDesc::base_offset_in_bytes(T_CHAR) &gt;&gt; 1);
1188   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);
1189 }
1190 
1191 void TemplateTable::sastore()
1192 {
1193   castore();
1194 }
1195 
1196 void TemplateTable::istore(int n)
1197 {
1198   transition(itos, vtos);
1199   __ str(r0, iaddress(n));
1200 }
1201 
1202 void TemplateTable::lstore(int n)
1203 {
1204   transition(ltos, vtos);
1205   __ str(r0, laddress(n));
1206 }
1207 
1208 void TemplateTable::fstore(int n)
1209 {
1210   transition(ftos, vtos);
1211   __ strs(v0, faddress(n));
1212 }
1213 
1214 void TemplateTable::dstore(int n)
1215 {
1216   transition(dtos, vtos);
1217   __ strd(v0, daddress(n));
1218 }
1219 
1220 void TemplateTable::astore(int n)
1221 {
1222   transition(vtos, vtos);
1223   __ pop_ptr(r0);
1224   __ str(r0, iaddress(n));
1225 }
1226 
1227 void TemplateTable::pop()
1228 {
1229   transition(vtos, vtos);
1230   __ add(esp, esp, Interpreter::stackElementSize);
1231 }
1232 
1233 void TemplateTable::pop2()
1234 {
1235   transition(vtos, vtos);
1236   __ add(esp, esp, 2 * Interpreter::stackElementSize);
1237 }
1238 
1239 void TemplateTable::dup()
1240 {
1241   transition(vtos, vtos);
1242   __ ldr(r0, Address(esp, 0));
1243   __ push(r0);
1244   // stack: ..., a, a
1245 }
1246 
1247 void TemplateTable::dup_x1()
1248 {
1249   transition(vtos, vtos);
1250   // stack: ..., a, b
1251   __ ldr(r0, at_tos());  // load b
1252   __ ldr(r2, at_tos_p1());  // load a
1253   __ str(r0, at_tos_p1());  // store b
1254   __ str(r2, at_tos());  // store a
1255   __ push(r0);                  // push b
1256   // stack: ..., b, a, b
1257 }
1258 
1259 void TemplateTable::dup_x2()
1260 {
1261   transition(vtos, vtos);
1262   // stack: ..., a, b, c
1263   __ ldr(r0, at_tos());  // load c
1264   __ ldr(r2, at_tos_p2());  // load a
1265   __ str(r0, at_tos_p2());  // store c in a
1266   __ push(r0);      // push c
1267   // stack: ..., c, b, c, c
1268   __ ldr(r0, at_tos_p2());  // load b
1269   __ str(r2, at_tos_p2());  // store a in b
1270   // stack: ..., c, a, c, c
1271   __ str(r0, at_tos_p1());  // store b in c
1272   // stack: ..., c, a, b, c
1273 }
1274 
1275 void TemplateTable::dup2()
1276 {
1277   transition(vtos, vtos);
1278   // stack: ..., a, b
1279   __ ldr(r0, at_tos_p1());  // load a
1280   __ push(r0);                  // push a
1281   __ ldr(r0, at_tos_p1());  // load b
1282   __ push(r0);                  // push b
1283   // stack: ..., a, b, a, b
1284 }
1285 
1286 void TemplateTable::dup2_x1()
1287 {
1288   transition(vtos, vtos);
1289   // stack: ..., a, b, c
1290   __ ldr(r2, at_tos());  // load c
1291   __ ldr(r0, at_tos_p1());  // load b
1292   __ push(r0);                  // push b
1293   __ push(r2);                  // push c
1294   // stack: ..., a, b, c, b, c
1295   __ str(r2, at_tos_p3());  // store c in b
1296   // stack: ..., a, c, c, b, c
1297   __ ldr(r2, at_tos_p4());  // load a
1298   __ str(r2, at_tos_p2());  // store a in 2nd c
1299   // stack: ..., a, c, a, b, c
1300   __ str(r0, at_tos_p4());  // store b in a
1301   // stack: ..., b, c, a, b, c
1302 }
1303 
1304 void TemplateTable::dup2_x2()
1305 {
1306   transition(vtos, vtos);
1307   // stack: ..., a, b, c, d
1308   __ ldr(r2, at_tos());  // load d
1309   __ ldr(r0, at_tos_p1());  // load c
1310   __ push(r0)            ;      // push c
1311   __ push(r2);                  // push d
1312   // stack: ..., a, b, c, d, c, d
1313   __ ldr(r0, at_tos_p4());  // load b
1314   __ str(r0, at_tos_p2());  // store b in d
1315   __ str(r2, at_tos_p4());  // store d in b
1316   // stack: ..., a, d, c, b, c, d
1317   __ ldr(r2, at_tos_p5());  // load a
1318   __ ldr(r0, at_tos_p3());  // load c
1319   __ str(r2, at_tos_p3());  // store a in c
1320   __ str(r0, at_tos_p5());  // store c in a
1321   // stack: ..., c, d, a, b, c, d
1322 }
1323 
1324 void TemplateTable::swap()
1325 {
1326   transition(vtos, vtos);
1327   // stack: ..., a, b
1328   __ ldr(r2, at_tos_p1());  // load a
1329   __ ldr(r0, at_tos());  // load b
1330   __ str(r2, at_tos());  // store a in b
1331   __ str(r0, at_tos_p1());  // store b in a
1332   // stack: ..., b, a
1333 }
1334 
1335 void TemplateTable::iop2(Operation op)
1336 {
1337   transition(itos, itos);
1338   // r0 &lt;== r1 op r0
1339   __ pop_i(r1);
1340   switch (op) {
1341   case add  : __ addw(r0, r1, r0); break;
1342   case sub  : __ subw(r0, r1, r0); break;
1343   case mul  : __ mulw(r0, r1, r0); break;
1344   case _and : __ andw(r0, r1, r0); break;
1345   case _or  : __ orrw(r0, r1, r0); break;
1346   case _xor : __ eorw(r0, r1, r0); break;
1347   case shl  : __ lslvw(r0, r1, r0); break;
1348   case shr  : __ asrvw(r0, r1, r0); break;
1349   case ushr : __ lsrvw(r0, r1, r0);break;
1350   default   : ShouldNotReachHere();
1351   }
1352 }
1353 
1354 void TemplateTable::lop2(Operation op)
1355 {
1356   transition(ltos, ltos);
1357   // r0 &lt;== r1 op r0
1358   __ pop_l(r1);
1359   switch (op) {
1360   case add  : __ add(r0, r1, r0); break;
1361   case sub  : __ sub(r0, r1, r0); break;
1362   case mul  : __ mul(r0, r1, r0); break;
1363   case _and : __ andr(r0, r1, r0); break;
1364   case _or  : __ orr(r0, r1, r0); break;
1365   case _xor : __ eor(r0, r1, r0); break;
1366   default   : ShouldNotReachHere();
1367   }
1368 }
1369 
1370 void TemplateTable::idiv()
1371 {
1372   transition(itos, itos);
1373   // explicitly check for div0
1374   Label no_div0;
1375   __ cbnzw(r0, no_div0);
1376   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1377   __ br(rscratch1);
1378   __ bind(no_div0);
1379   __ pop_i(r1);
1380   // r0 &lt;== r1 idiv r0
1381   __ corrected_idivl(r0, r1, r0, /* want_remainder */ false);
1382 }
1383 
1384 void TemplateTable::irem()
1385 {
1386   transition(itos, itos);
1387   // explicitly check for div0
1388   Label no_div0;
1389   __ cbnzw(r0, no_div0);
1390   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1391   __ br(rscratch1);
1392   __ bind(no_div0);
1393   __ pop_i(r1);
1394   // r0 &lt;== r1 irem r0
1395   __ corrected_idivl(r0, r1, r0, /* want_remainder */ true);
1396 }
1397 
1398 void TemplateTable::lmul()
1399 {
1400   transition(ltos, ltos);
1401   __ pop_l(r1);
1402   __ mul(r0, r0, r1);
1403 }
1404 
1405 void TemplateTable::ldiv()
1406 {
1407   transition(ltos, ltos);
1408   // explicitly check for div0
1409   Label no_div0;
1410   __ cbnz(r0, no_div0);
1411   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1412   __ br(rscratch1);
1413   __ bind(no_div0);
1414   __ pop_l(r1);
1415   // r0 &lt;== r1 ldiv r0
1416   __ corrected_idivq(r0, r1, r0, /* want_remainder */ false);
1417 }
1418 
1419 void TemplateTable::lrem()
1420 {
1421   transition(ltos, ltos);
1422   // explicitly check for div0
1423   Label no_div0;
1424   __ cbnz(r0, no_div0);
1425   __ mov(rscratch1, Interpreter::_throw_ArithmeticException_entry);
1426   __ br(rscratch1);
1427   __ bind(no_div0);
1428   __ pop_l(r1);
1429   // r0 &lt;== r1 lrem r0
1430   __ corrected_idivq(r0, r1, r0, /* want_remainder */ true);
1431 }
1432 
1433 void TemplateTable::lshl()
1434 {
1435   transition(itos, ltos);
1436   // shift count is in r0
1437   __ pop_l(r1);
1438   __ lslv(r0, r1, r0);
1439 }
1440 
1441 void TemplateTable::lshr()
1442 {
1443   transition(itos, ltos);
1444   // shift count is in r0
1445   __ pop_l(r1);
1446   __ asrv(r0, r1, r0);
1447 }
1448 
1449 void TemplateTable::lushr()
1450 {
1451   transition(itos, ltos);
1452   // shift count is in r0
1453   __ pop_l(r1);
1454   __ lsrv(r0, r1, r0);
1455 }
1456 
1457 void TemplateTable::fop2(Operation op)
1458 {
1459   transition(ftos, ftos);
1460   switch (op) {
1461   case add:
1462     // n.b. use ldrd because this is a 64 bit slot
1463     __ pop_f(v1);
1464     __ fadds(v0, v1, v0);
1465     break;
1466   case sub:
1467     __ pop_f(v1);
1468     __ fsubs(v0, v1, v0);
1469     break;
1470   case mul:
1471     __ pop_f(v1);
1472     __ fmuls(v0, v1, v0);
1473     break;
1474   case div:
1475     __ pop_f(v1);
1476     __ fdivs(v0, v1, v0);
1477     break;
1478   case rem:
1479     __ fmovs(v1, v0);
1480     __ pop_f(v0);
1481     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1482     break;
1483   default:
1484     ShouldNotReachHere();
1485     break;
1486   }
1487 }
1488 
1489 void TemplateTable::dop2(Operation op)
1490 {
1491   transition(dtos, dtos);
1492   switch (op) {
1493   case add:
1494     // n.b. use ldrd because this is a 64 bit slot
1495     __ pop_d(v1);
1496     __ faddd(v0, v1, v0);
1497     break;
1498   case sub:
1499     __ pop_d(v1);
1500     __ fsubd(v0, v1, v0);
1501     break;
1502   case mul:
1503     __ pop_d(v1);
1504     __ fmuld(v0, v1, v0);
1505     break;
1506   case div:
1507     __ pop_d(v1);
1508     __ fdivd(v0, v1, v0);
1509     break;
1510   case rem:
1511     __ fmovd(v1, v0);
1512     __ pop_d(v0);
1513     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1514     break;
1515   default:
1516     ShouldNotReachHere();
1517     break;
1518   }
1519 }
1520 
1521 void TemplateTable::ineg()
1522 {
1523   transition(itos, itos);
1524   __ negw(r0, r0);
1525 
1526 }
1527 
1528 void TemplateTable::lneg()
1529 {
1530   transition(ltos, ltos);
1531   __ neg(r0, r0);
1532 }
1533 
1534 void TemplateTable::fneg()
1535 {
1536   transition(ftos, ftos);
1537   __ fnegs(v0, v0);
1538 }
1539 
1540 void TemplateTable::dneg()
1541 {
1542   transition(dtos, dtos);
1543   __ fnegd(v0, v0);
1544 }
1545 
1546 void TemplateTable::iinc()
1547 {
1548   transition(vtos, vtos);
1549   __ load_signed_byte(r1, at_bcp(2)); // get constant
1550   locals_index(r2);
1551   __ ldr(r0, iaddress(r2));
1552   __ addw(r0, r0, r1);
1553   __ str(r0, iaddress(r2));
1554 }
1555 
1556 void TemplateTable::wide_iinc()
1557 {
1558   transition(vtos, vtos);
1559   // __ mov(r1, zr);
1560   __ ldrw(r1, at_bcp(2)); // get constant and index
1561   __ rev16(r1, r1);
1562   __ ubfx(r2, r1, 0, 16);
1563   __ neg(r2, r2);
1564   __ sbfx(r1, r1, 16, 16);
1565   __ ldr(r0, iaddress(r2));
1566   __ addw(r0, r0, r1);
1567   __ str(r0, iaddress(r2));
1568 }
1569 
1570 void TemplateTable::convert()
1571 {
1572   // Checking
1573 #ifdef ASSERT
1574   {
1575     TosState tos_in  = ilgl;
1576     TosState tos_out = ilgl;
1577     switch (bytecode()) {
1578     case Bytecodes::_i2l: // fall through
1579     case Bytecodes::_i2f: // fall through
1580     case Bytecodes::_i2d: // fall through
1581     case Bytecodes::_i2b: // fall through
1582     case Bytecodes::_i2c: // fall through
1583     case Bytecodes::_i2s: tos_in = itos; break;
1584     case Bytecodes::_l2i: // fall through
1585     case Bytecodes::_l2f: // fall through
1586     case Bytecodes::_l2d: tos_in = ltos; break;
1587     case Bytecodes::_f2i: // fall through
1588     case Bytecodes::_f2l: // fall through
1589     case Bytecodes::_f2d: tos_in = ftos; break;
1590     case Bytecodes::_d2i: // fall through
1591     case Bytecodes::_d2l: // fall through
1592     case Bytecodes::_d2f: tos_in = dtos; break;
1593     default             : ShouldNotReachHere();
1594     }
1595     switch (bytecode()) {
1596     case Bytecodes::_l2i: // fall through
1597     case Bytecodes::_f2i: // fall through
1598     case Bytecodes::_d2i: // fall through
1599     case Bytecodes::_i2b: // fall through
1600     case Bytecodes::_i2c: // fall through
1601     case Bytecodes::_i2s: tos_out = itos; break;
1602     case Bytecodes::_i2l: // fall through
1603     case Bytecodes::_f2l: // fall through
1604     case Bytecodes::_d2l: tos_out = ltos; break;
1605     case Bytecodes::_i2f: // fall through
1606     case Bytecodes::_l2f: // fall through
1607     case Bytecodes::_d2f: tos_out = ftos; break;
1608     case Bytecodes::_i2d: // fall through
1609     case Bytecodes::_l2d: // fall through
1610     case Bytecodes::_f2d: tos_out = dtos; break;
1611     default             : ShouldNotReachHere();
1612     }
1613     transition(tos_in, tos_out);
1614   }
1615 #endif // ASSERT
1616   // static const int64_t is_nan = 0x8000000000000000L;
1617 
1618   // Conversion
1619   switch (bytecode()) {
1620   case Bytecodes::_i2l:
1621     __ sxtw(r0, r0);
1622     break;
1623   case Bytecodes::_i2f:
1624     __ scvtfws(v0, r0);
1625     break;
1626   case Bytecodes::_i2d:
1627     __ scvtfwd(v0, r0);
1628     break;
1629   case Bytecodes::_i2b:
1630     __ sxtbw(r0, r0);
1631     break;
1632   case Bytecodes::_i2c:
1633     __ uxthw(r0, r0);
1634     break;
1635   case Bytecodes::_i2s:
1636     __ sxthw(r0, r0);
1637     break;
1638   case Bytecodes::_l2i:
1639     __ uxtw(r0, r0);
1640     break;
1641   case Bytecodes::_l2f:
1642     __ scvtfs(v0, r0);
1643     break;
1644   case Bytecodes::_l2d:
1645     __ scvtfd(v0, r0);
1646     break;
1647   case Bytecodes::_f2i:
1648   {
1649     Label L_Okay;
1650     __ clear_fpsr();
1651     __ fcvtzsw(r0, v0);
1652     __ get_fpsr(r1);
1653     __ cbzw(r1, L_Okay);
1654     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i));
1655     __ bind(L_Okay);
1656   }
1657     break;
1658   case Bytecodes::_f2l:
1659   {
1660     Label L_Okay;
1661     __ clear_fpsr();
1662     __ fcvtzs(r0, v0);
1663     __ get_fpsr(r1);
1664     __ cbzw(r1, L_Okay);
1665     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l));
1666     __ bind(L_Okay);
1667   }
1668     break;
1669   case Bytecodes::_f2d:
1670     __ fcvts(v0, v0);
1671     break;
1672   case Bytecodes::_d2i:
1673   {
1674     Label L_Okay;
1675     __ clear_fpsr();
1676     __ fcvtzdw(r0, v0);
1677     __ get_fpsr(r1);
1678     __ cbzw(r1, L_Okay);
1679     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i));
1680     __ bind(L_Okay);
1681   }
1682     break;
1683   case Bytecodes::_d2l:
1684   {
1685     Label L_Okay;
1686     __ clear_fpsr();
1687     __ fcvtzd(r0, v0);
1688     __ get_fpsr(r1);
1689     __ cbzw(r1, L_Okay);
1690     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l));
1691     __ bind(L_Okay);
1692   }
1693     break;
1694   case Bytecodes::_d2f:
1695     __ fcvtd(v0, v0);
1696     break;
1697   default:
1698     ShouldNotReachHere();
1699   }
1700 }
1701 
1702 void TemplateTable::lcmp()
1703 {
1704   transition(ltos, itos);
1705   Label done;
1706   __ pop_l(r1);
1707   __ cmp(r1, r0);
1708   __ mov(r0, (u_int64_t)-1L);
1709   __ br(Assembler::LT, done);
1710   // __ mov(r0, 1UL);
1711   // __ csel(r0, r0, zr, Assembler::NE);
1712   // and here is a faster way
1713   __ csinc(r0, zr, zr, Assembler::EQ);
1714   __ bind(done);
1715 }
1716 
1717 void TemplateTable::float_cmp(bool is_float, int unordered_result)
1718 {
1719   Label done;
1720   if (is_float) {
1721     // XXX get rid of pop here, use ... reg, mem32
1722     __ pop_f(v1);
1723     __ fcmps(v1, v0);
1724   } else {
1725     // XXX get rid of pop here, use ... reg, mem64
1726     __ pop_d(v1);
1727     __ fcmpd(v1, v0);
1728   }
1729   if (unordered_result &lt; 0) {
1730     // we want -1 for unordered or less than, 0 for equal and 1 for
1731     // greater than.
1732     __ mov(r0, (u_int64_t)-1L);
1733     // for FP LT tests less than or unordered
1734     __ br(Assembler::LT, done);
1735     // install 0 for EQ otherwise 1
1736     __ csinc(r0, zr, zr, Assembler::EQ);
1737   } else {
1738     // we want -1 for less than, 0 for equal and 1 for unordered or
1739     // greater than.
1740     __ mov(r0, 1L);
1741     // for FP HI tests greater than or unordered
1742     __ br(Assembler::HI, done);
1743     // install 0 for EQ otherwise ~0
1744     __ csinv(r0, zr, zr, Assembler::EQ);
1745 
1746   }
1747   __ bind(done);
1748 }
1749 
1750 void TemplateTable::branch(bool is_jsr, bool is_wide)
1751 {
1752   // We might be moving to a safepoint.  The thread which calls
1753   // Interpreter::notice_safepoints() will effectively flush its cache
1754   // when it makes a system call, but we need to do something to
1755   // ensure that we see the changed dispatch table.
1756   __ membar(MacroAssembler::LoadLoad);
1757 
1758   __ profile_taken_branch(r0, r1);
1759   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
1760                              InvocationCounter::counter_offset();
1761   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
1762                               InvocationCounter::counter_offset();
1763 
1764   // load branch displacement
1765   if (!is_wide) {
1766     __ ldrh(r2, at_bcp(1));
1767     __ rev16(r2, r2);
1768     // sign extend the 16 bit value in r2
1769     __ sbfm(r2, r2, 0, 15);
1770   } else {
1771     __ ldrw(r2, at_bcp(1));
1772     __ revw(r2, r2);
1773     // sign extend the 32 bit value in r2
1774     __ sbfm(r2, r2, 0, 31);
1775   }
1776 
1777   // Handle all the JSR stuff here, then exit.
1778   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
1779   // normal-branch stuff occurring below.
1780 
1781   if (is_jsr) {
1782     // Pre-load the next target bytecode into rscratch1
1783     __ load_unsigned_byte(rscratch1, Address(rbcp, r2));
1784     // compute return address as bci
1785     __ ldr(rscratch2, Address(rmethod, Method::const_offset()));
1786     __ add(rscratch2, rscratch2,
1787            in_bytes(ConstMethod::codes_offset()) - (is_wide ? 5 : 3));
1788     __ sub(r1, rbcp, rscratch2);
1789     __ push_i(r1);
1790     // Adjust the bcp by the 16-bit displacement in r2
1791     __ add(rbcp, rbcp, r2);
1792     __ dispatch_only(vtos, /*generate_poll*/true);
1793     return;
1794   }
1795 
1796   // Normal (non-jsr) branch handling
1797 
1798   // Adjust the bcp by the displacement in r2
1799   __ add(rbcp, rbcp, r2);
1800 
1801   assert(UseLoopCounter || !UseOnStackReplacement,
1802          &quot;on-stack-replacement requires loop counters&quot;);
1803   Label backedge_counter_overflow;
1804   Label profile_method;
1805   Label dispatch;
1806   if (UseLoopCounter) {
1807     // increment backedge counter for backward branches
1808     // r0: MDO
1809     // w1: MDO bumped taken-count
1810     // r2: target offset
1811     __ cmp(r2, zr);
1812     __ br(Assembler::GT, dispatch); // count only if backward branch
1813 
1814     // ECN: FIXME: This code smells
1815     // check if MethodCounters exists
1816     Label has_counters;
1817     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1818     __ cbnz(rscratch1, has_counters);
1819     __ push(r0);
1820     __ push(r1);
1821     __ push(r2);
1822     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
1823             InterpreterRuntime::build_method_counters), rmethod);
1824     __ pop(r2);
1825     __ pop(r1);
1826     __ pop(r0);
1827     __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1828     __ cbz(rscratch1, dispatch); // No MethodCounters allocated, OutOfMemory
1829     __ bind(has_counters);
1830 
1831     if (TieredCompilation) {
1832       Label no_mdo;
1833       int increment = InvocationCounter::count_increment;
1834       if (ProfileInterpreter) {
1835         // Are we profiling?
1836         __ ldr(r1, Address(rmethod, in_bytes(Method::method_data_offset())));
1837         __ cbz(r1, no_mdo);
1838         // Increment the MDO backedge counter
1839         const Address mdo_backedge_counter(r1, in_bytes(MethodData::backedge_counter_offset()) +
1840                                            in_bytes(InvocationCounter::counter_offset()));
1841         const Address mask(r1, in_bytes(MethodData::backedge_mask_offset()));
1842         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1843                                    r0, rscratch1, false, Assembler::EQ,
1844                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1845         __ b(dispatch);
1846       }
1847       __ bind(no_mdo);
1848       // Increment backedge counter in MethodCounters*
1849       __ ldr(rscratch1, Address(rmethod, Method::method_counters_offset()));
1850       const Address mask(rscratch1, in_bytes(MethodCounters::backedge_mask_offset()));
1851       __ increment_mask_and_jump(Address(rscratch1, be_offset), increment, mask,
1852                                  r0, rscratch2, false, Assembler::EQ,
1853                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : &amp;dispatch);
1854     } else { // not TieredCompilation
1855       // increment counter
1856       __ ldr(rscratch2, Address(rmethod, Method::method_counters_offset()));
1857       __ ldrw(r0, Address(rscratch2, be_offset));        // load backedge counter
1858       __ addw(rscratch1, r0, InvocationCounter::count_increment); // increment counter
1859       __ strw(rscratch1, Address(rscratch2, be_offset));        // store counter
1860 
1861       __ ldrw(r0, Address(rscratch2, inv_offset));    // load invocation counter
1862       __ andw(r0, r0, (unsigned)InvocationCounter::count_mask_value); // and the status bits
1863       __ addw(r0, r0, rscratch1);        // add both counters
1864 
1865       if (ProfileInterpreter) {
1866         // Test to see if we should create a method data oop
1867         __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
1868         __ cmpw(r0, rscratch1);
1869         __ br(Assembler::LT, dispatch);
1870 
1871         // if no method data exists, go to profile method
1872         __ test_method_data_pointer(r0, profile_method);
1873 
1874         if (UseOnStackReplacement) {
1875           // check for overflow against w1 which is the MDO taken count
1876           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1877           __ cmpw(r1, rscratch1);
1878           __ br(Assembler::LO, dispatch); // Intel == Assembler::below
1879 
1880           // When ProfileInterpreter is on, the backedge_count comes
1881           // from the MethodData*, which value does not get reset on
1882           // the call to frequency_counter_overflow().  To avoid
1883           // excessive calls to the overflow routine while the method is
1884           // being compiled, add a second test to make sure the overflow
1885           // function is called only once every overflow_frequency.
1886           const int overflow_frequency = 1024;
1887           __ andsw(r1, r1, overflow_frequency - 1);
1888           __ br(Assembler::EQ, backedge_counter_overflow);
1889 
1890         }
1891       } else {
1892         if (UseOnStackReplacement) {
1893           // check for overflow against w0, which is the sum of the
1894           // counters
1895           __ ldrw(rscratch1, Address(rscratch2, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
1896           __ cmpw(r0, rscratch1);
1897           __ br(Assembler::HS, backedge_counter_overflow); // Intel == Assembler::aboveEqual
1898         }
1899       }
1900     }
1901     __ bind(dispatch);
1902   }
1903 
1904   // Pre-load the next target bytecode into rscratch1
1905   __ load_unsigned_byte(rscratch1, Address(rbcp, 0));
1906 
1907   // continue with the bytecode @ target
1908   // rscratch1: target bytecode
1909   // rbcp: target bcp
1910   __ dispatch_only(vtos, /*generate_poll*/true);
1911 
1912   if (UseLoopCounter) {
1913     if (ProfileInterpreter) {
1914       // Out-of-line code to allocate method data oop.
1915       __ bind(profile_method);
1916       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
1917       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1918       __ set_method_data_pointer_for_bcp();
1919       __ b(dispatch);
1920     }
1921 
1922     if (UseOnStackReplacement) {
1923       // invocation counter overflow
1924       __ bind(backedge_counter_overflow);
1925       __ neg(r2, r2);
1926       __ add(r2, r2, rbcp);     // branch bcp
1927       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
1928       __ call_VM(noreg,
1929                  CAST_FROM_FN_PTR(address,
1930                                   InterpreterRuntime::frequency_counter_overflow),
1931                  r2);
1932       __ load_unsigned_byte(r1, Address(rbcp, 0));  // restore target bytecode
1933 
1934       // r0: osr nmethod (osr ok) or NULL (osr not possible)
1935       // w1: target bytecode
1936       // r2: scratch
1937       __ cbz(r0, dispatch);     // test result -- no osr if null
1938       // nmethod may have been invalidated (VM may block upon call_VM return)
1939       __ ldrb(r2, Address(r0, nmethod::state_offset()));
1940       if (nmethod::in_use != 0)
1941         __ sub(r2, r2, nmethod::in_use);
1942       __ cbnz(r2, dispatch);
1943 
1944       // We have the address of an on stack replacement routine in r0
1945       // We need to prepare to execute the OSR method. First we must
1946       // migrate the locals and monitors off of the stack.
1947 
1948       __ mov(r19, r0);                             // save the nmethod
1949 
1950       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
1951 
1952       // r0 is OSR buffer, move it to expected parameter location
1953       __ mov(j_rarg0, r0);
1954 
1955       // remove activation
1956       // get sender esp
1957       __ ldr(esp,
1958           Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));
1959       // remove frame anchor
1960       __ leave();
1961       // Ensure compiled code always sees stack at proper alignment
1962       __ andr(sp, esp, -16);
1963 
1964       // and begin the OSR nmethod
1965       __ ldr(rscratch1, Address(r19, nmethod::osr_entry_point_offset()));
1966       __ br(rscratch1);
1967     }
1968   }
1969 }
1970 
1971 
1972 void TemplateTable::if_0cmp(Condition cc)
1973 {
1974   transition(itos, vtos);
1975   // assume branch is more often taken than not (loops use backward branches)
1976   Label not_taken;
1977   if (cc == equal)
1978     __ cbnzw(r0, not_taken);
1979   else if (cc == not_equal)
1980     __ cbzw(r0, not_taken);
1981   else {
1982     __ andsw(zr, r0, r0);
1983     __ br(j_not(cc), not_taken);
1984   }
1985 
1986   branch(false, false);
1987   __ bind(not_taken);
1988   __ profile_not_taken_branch(r0);
1989 }
1990 
1991 void TemplateTable::if_icmp(Condition cc)
1992 {
1993   transition(itos, vtos);
1994   // assume branch is more often taken than not (loops use backward branches)
1995   Label not_taken;
1996   __ pop_i(r1);
1997   __ cmpw(r1, r0, Assembler::LSL);
1998   __ br(j_not(cc), not_taken);
1999   branch(false, false);
2000   __ bind(not_taken);
2001   __ profile_not_taken_branch(r0);
2002 }
2003 
2004 void TemplateTable::if_nullcmp(Condition cc)
2005 {
2006   transition(atos, vtos);
2007   // assume branch is more often taken than not (loops use backward branches)
2008   Label not_taken;
2009   if (cc == equal)
2010     __ cbnz(r0, not_taken);
2011   else
2012     __ cbz(r0, not_taken);
2013   branch(false, false);
2014   __ bind(not_taken);
2015   __ profile_not_taken_branch(r0);
2016 }
2017 
2018 void TemplateTable::if_acmp(Condition cc)
2019 {
2020   transition(atos, vtos);
2021   // assume branch is more often taken than not (loops use backward branches)
2022   Label not_taken;
2023   __ pop_ptr(r1);
2024   __ cmpoop(r1, r0);
2025   __ br(j_not(cc), not_taken);
2026   branch(false, false);
2027   __ bind(not_taken);
2028   __ profile_not_taken_branch(r0);
2029 }
2030 
2031 void TemplateTable::ret() {
2032   transition(vtos, vtos);
2033   // We might be moving to a safepoint.  The thread which calls
2034   // Interpreter::notice_safepoints() will effectively flush its cache
2035   // when it makes a system call, but we need to do something to
2036   // ensure that we see the changed dispatch table.
2037   __ membar(MacroAssembler::LoadLoad);
2038 
2039   locals_index(r1);
2040   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2041   __ profile_ret(r1, r2);
2042   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2043   __ lea(rbcp, Address(rbcp, r1));
2044   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2045   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2046 }
2047 
2048 void TemplateTable::wide_ret() {
2049   transition(vtos, vtos);
2050   locals_index_wide(r1);
2051   __ ldr(r1, aaddress(r1)); // get return bci, compute return bcp
2052   __ profile_ret(r1, r2);
2053   __ ldr(rbcp, Address(rmethod, Method::const_offset()));
2054   __ lea(rbcp, Address(rbcp, r1));
2055   __ add(rbcp, rbcp, in_bytes(ConstMethod::codes_offset()));
2056   __ dispatch_next(vtos, 0, /*generate_poll*/true);
2057 }
2058 
2059 
2060 void TemplateTable::tableswitch() {
2061   Label default_case, continue_execution;
2062   transition(itos, vtos);
2063   // align rbcp
2064   __ lea(r1, at_bcp(BytesPerInt));
2065   __ andr(r1, r1, -BytesPerInt);
2066   // load lo &amp; hi
2067   __ ldrw(r2, Address(r1, BytesPerInt));
2068   __ ldrw(r3, Address(r1, 2 * BytesPerInt));
2069   __ rev32(r2, r2);
2070   __ rev32(r3, r3);
2071   // check against lo &amp; hi
2072   __ cmpw(r0, r2);
2073   __ br(Assembler::LT, default_case);
2074   __ cmpw(r0, r3);
2075   __ br(Assembler::GT, default_case);
2076   // lookup dispatch offset
2077   __ subw(r0, r0, r2);
2078   __ lea(r3, Address(r1, r0, Address::uxtw(2)));
2079   __ ldrw(r3, Address(r3, 3 * BytesPerInt));
2080   __ profile_switch_case(r0, r1, r2);
2081   // continue execution
2082   __ bind(continue_execution);
2083   __ rev32(r3, r3);
2084   __ load_unsigned_byte(rscratch1, Address(rbcp, r3, Address::sxtw(0)));
2085   __ add(rbcp, rbcp, r3, ext::sxtw);
2086   __ dispatch_only(vtos, /*generate_poll*/true);
2087   // handle default
2088   __ bind(default_case);
2089   __ profile_switch_default(r0);
2090   __ ldrw(r3, Address(r1, 0));
2091   __ b(continue_execution);
2092 }
2093 
2094 void TemplateTable::lookupswitch() {
2095   transition(itos, itos);
2096   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2097 }
2098 
2099 void TemplateTable::fast_linearswitch() {
2100   transition(itos, vtos);
2101   Label loop_entry, loop, found, continue_execution;
2102   // bswap r0 so we can avoid bswapping the table entries
2103   __ rev32(r0, r0);
2104   // align rbcp
2105   __ lea(r19, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2106                                     // this instruction (change offsets
2107                                     // below)
2108   __ andr(r19, r19, -BytesPerInt);
2109   // set counter
2110   __ ldrw(r1, Address(r19, BytesPerInt));
2111   __ rev32(r1, r1);
2112   __ b(loop_entry);
2113   // table search
2114   __ bind(loop);
2115   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2116   __ ldrw(rscratch1, Address(rscratch1, 2 * BytesPerInt));
2117   __ cmpw(r0, rscratch1);
2118   __ br(Assembler::EQ, found);
2119   __ bind(loop_entry);
2120   __ subs(r1, r1, 1);
2121   __ br(Assembler::PL, loop);
2122   // default case
2123   __ profile_switch_default(r0);
2124   __ ldrw(r3, Address(r19, 0));
2125   __ b(continue_execution);
2126   // entry found -&gt; get offset
2127   __ bind(found);
2128   __ lea(rscratch1, Address(r19, r1, Address::lsl(3)));
2129   __ ldrw(r3, Address(rscratch1, 3 * BytesPerInt));
2130   __ profile_switch_case(r1, r0, r19);
2131   // continue execution
2132   __ bind(continue_execution);
2133   __ rev32(r3, r3);
2134   __ add(rbcp, rbcp, r3, ext::sxtw);
2135   __ ldrb(rscratch1, Address(rbcp, 0));
2136   __ dispatch_only(vtos, /*generate_poll*/true);
2137 }
2138 
2139 void TemplateTable::fast_binaryswitch() {
2140   transition(itos, vtos);
2141   // Implementation using the following core algorithm:
2142   //
2143   // int binary_search(int key, LookupswitchPair* array, int n) {
2144   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2145   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2146   //   int i = 0;
2147   //   int j = n;
2148   //   while (i+1 &lt; j) {
2149   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2150   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2151   //     // where a stands for the array and assuming that the (inexisting)
2152   //     // element a[n] is infinitely big.
2153   //     int h = (i + j) &gt;&gt; 1;
2154   //     // i &lt; h &lt; j
2155   //     if (key &lt; array[h].fast_match()) {
2156   //       j = h;
2157   //     } else {
2158   //       i = h;
2159   //     }
2160   //   }
2161   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2162   //   // (i.e., if key is within array, i is the correct index)
2163   //   return i;
2164   // }
2165 
2166   // Register allocation
2167   const Register key   = r0; // already set (tosca)
2168   const Register array = r1;
2169   const Register i     = r2;
2170   const Register j     = r3;
2171   const Register h     = rscratch1;
2172   const Register temp  = rscratch2;
2173 
2174   // Find array start
2175   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2176                                           // get rid of this
2177                                           // instruction (change
2178                                           // offsets below)
2179   __ andr(array, array, -BytesPerInt);
2180 
2181   // Initialize i &amp; j
2182   __ mov(i, 0);                            // i = 0;
2183   __ ldrw(j, Address(array, -BytesPerInt)); // j = length(array);
2184 
2185   // Convert j into native byteordering
2186   __ rev32(j, j);
2187 
2188   // And start
2189   Label entry;
2190   __ b(entry);
2191 
2192   // binary search loop
2193   {
2194     Label loop;
2195     __ bind(loop);
2196     // int h = (i + j) &gt;&gt; 1;
2197     __ addw(h, i, j);                           // h = i + j;
2198     __ lsrw(h, h, 1);                                   // h = (i + j) &gt;&gt; 1;
2199     // if (key &lt; array[h].fast_match()) {
2200     //   j = h;
2201     // } else {
2202     //   i = h;
2203     // }
2204     // Convert array[h].match to native byte-ordering before compare
2205     __ ldr(temp, Address(array, h, Address::lsl(3)));
2206     __ rev32(temp, temp);
2207     __ cmpw(key, temp);
2208     // j = h if (key &lt;  array[h].fast_match())
2209     __ csel(j, h, j, Assembler::LT);
2210     // i = h if (key &gt;= array[h].fast_match())
2211     __ csel(i, h, i, Assembler::GE);
2212     // while (i+1 &lt; j)
2213     __ bind(entry);
2214     __ addw(h, i, 1);          // i+1
2215     __ cmpw(h, j);             // i+1 &lt; j
2216     __ br(Assembler::LT, loop);
2217   }
2218 
2219   // end of binary search, result index is i (must check again!)
2220   Label default_case;
2221   // Convert array[i].match to native byte-ordering before compare
2222   __ ldr(temp, Address(array, i, Address::lsl(3)));
2223   __ rev32(temp, temp);
2224   __ cmpw(key, temp);
2225   __ br(Assembler::NE, default_case);
2226 
2227   // entry found -&gt; j = offset
2228   __ add(j, array, i, ext::uxtx, 3);
2229   __ ldrw(j, Address(j, BytesPerInt));
2230   __ profile_switch_case(i, key, array);
2231   __ rev32(j, j);
2232   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2233   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2234   __ dispatch_only(vtos, /*generate_poll*/true);
2235 
2236   // default case -&gt; j = default offset
2237   __ bind(default_case);
2238   __ profile_switch_default(i);
2239   __ ldrw(j, Address(array, -2 * BytesPerInt));
2240   __ rev32(j, j);
2241   __ load_unsigned_byte(rscratch1, Address(rbcp, j, Address::sxtw(0)));
2242   __ lea(rbcp, Address(rbcp, j, Address::sxtw(0)));
2243   __ dispatch_only(vtos, /*generate_poll*/true);
2244 }
2245 
2246 
2247 void TemplateTable::_return(TosState state)
2248 {
2249   transition(state, state);
2250   assert(_desc-&gt;calls_vm(),
2251          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2252 
2253   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2254     assert(state == vtos, &quot;only valid state&quot;);
2255 
2256     __ ldr(c_rarg1, aaddress(0));
2257     __ load_klass(r3, c_rarg1);
2258     __ ldrw(r3, Address(r3, Klass::access_flags_offset()));
2259     Label skip_register_finalizer;
2260     __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);
2261 
2262     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), c_rarg1);
2263 
2264     __ bind(skip_register_finalizer);
2265   }
2266 
2267   // Issue a StoreStore barrier after all stores but before return
2268   // from any constructor for any class with a final field.  We don&#39;t
2269   // know if this is a finalizer, so we always do so.
2270   if (_desc-&gt;bytecode() == Bytecodes::_return)
2271     __ membar(MacroAssembler::StoreStore);
2272 
2273   // Narrow result if state is itos but result type is smaller.
2274   // Need to narrow in the return bytecode rather than in generate_return_entry
2275   // since compiled code callers expect the result to already be narrowed.
2276   if (state == itos) {
2277     __ narrow(r0);
2278   }
2279 
2280   __ remove_activation(state);
2281   __ ret(lr);
2282 }
2283 
2284 // ----------------------------------------------------------------------------
2285 // Volatile variables demand their effects be made known to all CPU&#39;s
2286 // in order.  Store buffers on most chips allow reads &amp; writes to
2287 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2288 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2289 // the interpreter does not reorder volatile references, the hardware
2290 // also must not reorder them).
2291 //
2292 // According to the new Java Memory Model (JMM):
2293 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2294 //     writes act as aquire &amp; release, so:
2295 // (2) A read cannot let unrelated NON-volatile memory refs that
2296 //     happen after the read float up to before the read.  It&#39;s OK for
2297 //     non-volatile memory refs that happen before the volatile read to
2298 //     float down below it.
2299 // (3) Similar a volatile write cannot let unrelated NON-volatile
2300 //     memory refs that happen BEFORE the write float down to after the
2301 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2302 //     volatile write to float up before it.
2303 //
2304 // We only put in barriers around volatile refs (they are expensive),
2305 // not _between_ memory refs (that would require us to track the
2306 // flavor of the previous memory refs).  Requirements (2) and (3)
2307 // require some barriers before volatile stores and after volatile
2308 // loads.  These nearly cover requirement (1) but miss the
2309 // volatile-store-volatile-load case.  This final case is placed after
2310 // volatile-stores although it could just as well go before
2311 // volatile-loads.
2312 
2313 void TemplateTable::resolve_cache_and_index(int byte_no,
2314                                             Register Rcache,
2315                                             Register index,
2316                                             size_t index_size) {
2317   const Register temp = r19;
2318   assert_different_registers(Rcache, index, temp);
2319 
2320   Label resolved, clinit_barrier_slow;
2321 
2322   Bytecodes::Code code = bytecode();
2323   switch (code) {
2324   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2325   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2326   default: break;
2327   }
2328 
2329   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2330   __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, 1, index_size);
2331   __ subs(zr, temp, (int) code);  // have we resolved this bytecode?
2332   __ br(Assembler::EQ, resolved);
2333 
2334   // resolve first time through
2335   // Class initialization barrier slow path lands here as well.
2336   __ bind(clinit_barrier_slow);
2337   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2338   __ mov(temp, (int) code);
2339   __ call_VM(noreg, entry, temp);
2340 
2341   // Update registers with resolved info
2342   __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size);
2343   // n.b. unlike x86 Rcache is now rcpool plus the indexed offset
2344   // so all clients ofthis method must be modified accordingly
2345   __ bind(resolved);
2346 
2347   // Class initialization barrier for static methods
2348   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2349     __ load_resolved_method_at_index(byte_no, temp, Rcache);
2350     __ load_method_holder(temp, temp);
2351     __ clinit_barrier(temp, rscratch1, NULL, &amp;clinit_barrier_slow);
2352   }
2353 }
2354 
2355 // The Rcache and index registers must be set before call
2356 // n.b unlike x86 cache already includes the index offset
2357 void TemplateTable::load_field_cp_cache_entry(Register obj,
2358                                               Register cache,
2359                                               Register index,
2360                                               Register off,
2361                                               Register flags,
2362                                               bool is_static = false) {
2363   assert_different_registers(cache, index, flags, off);
2364 
2365   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2366   // Field offset
2367   __ ldr(off, Address(cache, in_bytes(cp_base_offset +
2368                                           ConstantPoolCacheEntry::f2_offset())));
2369   // Flags
2370   __ ldrw(flags, Address(cache, in_bytes(cp_base_offset +
2371                                            ConstantPoolCacheEntry::flags_offset())));
2372 
2373   // klass overwrite register
2374   if (is_static) {
2375     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
2376                                         ConstantPoolCacheEntry::f1_offset())));
2377     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2378     __ ldr(obj, Address(obj, mirror_offset));
2379     __ resolve_oop_handle(obj);
2380   }
2381 }
2382 
2383 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2384                                                Register method,
2385                                                Register itable_index,
2386                                                Register flags,
2387                                                bool is_invokevirtual,
2388                                                bool is_invokevfinal, /*unused*/
2389                                                bool is_invokedynamic) {
2390   // setup registers
2391   const Register cache = rscratch2;
2392   const Register index = r4;
2393   assert_different_registers(method, flags);
2394   assert_different_registers(method, cache, index);
2395   assert_different_registers(itable_index, flags);
2396   assert_different_registers(itable_index, cache, index);
2397   // determine constant pool cache field offsets
2398   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2399   const int method_offset = in_bytes(
2400     ConstantPoolCache::base_offset() +
2401       (is_invokevirtual
2402        ? ConstantPoolCacheEntry::f2_offset()
2403        : ConstantPoolCacheEntry::f1_offset()));
2404   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2405                                     ConstantPoolCacheEntry::flags_offset());
2406   // access constant pool cache fields
2407   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2408                                     ConstantPoolCacheEntry::f2_offset());
2409 
2410   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2411   resolve_cache_and_index(byte_no, cache, index, index_size);
2412   __ ldr(method, Address(cache, method_offset));
2413 
2414   if (itable_index != noreg) {
2415     __ ldr(itable_index, Address(cache, index_offset));
2416   }
2417   __ ldrw(flags, Address(cache, flags_offset));
2418 }
2419 
2420 
2421 // The registers cache and index expected to be set before call.
2422 // Correct values of the cache and index registers are preserved.
2423 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2424                                             bool is_static, bool has_tos) {
2425   // do the JVMTI work here to avoid disturbing the register state below
2426   // We use c_rarg registers here because we want to use the register used in
2427   // the call to the VM
2428   if (JvmtiExport::can_post_field_access()) {
2429     // Check to see if a field access watch has been set before we
2430     // take the time to call into the VM.
2431     Label L1;
2432     assert_different_registers(cache, index, r0);
2433     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2434     __ ldrw(r0, Address(rscratch1));
2435     __ cbzw(r0, L1);
2436 
2437     __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);
2438     __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));
2439 
2440     if (is_static) {
2441       __ mov(c_rarg1, zr); // NULL object reference
2442     } else {
2443       __ ldr(c_rarg1, at_tos()); // get object pointer without popping it
2444       __ verify_oop(c_rarg1);
2445     }
2446     // c_rarg1: object pointer or NULL
2447     // c_rarg2: cache entry pointer
2448     // c_rarg3: jvalue object on the stack
2449     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2450                                        InterpreterRuntime::post_field_access),
2451                c_rarg1, c_rarg2, c_rarg3);
2452     __ get_cache_and_index_at_bcp(cache, index, 1);
2453     __ bind(L1);
2454   }
2455 }
2456 
2457 void TemplateTable::pop_and_check_object(Register r)
2458 {
2459   __ pop_ptr(r);
2460   __ null_check(r);  // for field access must check obj.
2461   __ verify_oop(r);
2462 }
2463 
2464 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc)
2465 {
2466   const Register cache = r2;
2467   const Register index = r3;
2468   const Register obj   = r4;
2469   const Register off   = r19;
2470   const Register flags = r0;
2471   const Register raw_flags = r6;
2472   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2473 
2474   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2475   jvmti_post_field_access(cache, index, is_static, false);
2476   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2477 
2478   if (!is_static) {
2479     // obj is on the stack
2480     pop_and_check_object(obj);
2481   }
2482 
2483   // 8179954: We need to make sure that the code generated for
2484   // volatile accesses forms a sequentially-consistent set of
2485   // operations when combined with STLR and LDAR.  Without a leading
2486   // membar it&#39;s possible for a simple Dekker test to fail if loads
2487   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2488   // the stores in one method and we interpret the loads in another.
2489   if (! UseBarriersForVolatile) {
2490     Label notVolatile;
2491     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2492     __ membar(MacroAssembler::AnyAny);
2493     __ bind(notVolatile);
2494   }
2495 
2496   const Address field(obj, off);
2497 
2498   Label Done, notByte, notBool, notInt, notShort, notChar,
2499               notLong, notFloat, notObj, notDouble;
2500 
2501   // x86 uses a shift and mask or wings it with a shift plus assert
2502   // the mask is not needed. aarch64 just uses bitfield extract
2503   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2504            ConstantPoolCacheEntry::tos_state_bits);
2505 
2506   assert(btos == 0, &quot;change code, btos != 0&quot;);
2507   __ cbnz(flags, notByte);
2508 
2509   // Don&#39;t rewrite getstatic, only getfield
2510   if (is_static) rc = may_not_rewrite;
2511 
2512   // btos
2513   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
2514   __ push(btos);
2515   // Rewrite bytecode to be faster
2516   if (rc == may_rewrite) {
2517     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2518   }
2519   __ b(Done);
2520 
2521   __ bind(notByte);
2522   __ cmp(flags, (u1)ztos);
2523   __ br(Assembler::NE, notBool);
2524 
2525   // ztos (same code as btos)
2526   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
2527   __ push(ztos);
2528   // Rewrite bytecode to be faster
2529   if (rc == may_rewrite) {
2530     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2531     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
2532   }
2533   __ b(Done);
2534 
2535   __ bind(notBool);
2536   __ cmp(flags, (u1)atos);
2537   __ br(Assembler::NE, notObj);
2538   // atos
2539   do_oop_load(_masm, field, r0, IN_HEAP);
2540   __ push(atos);
2541   if (rc == may_rewrite) {
2542     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
2543   }
2544   __ b(Done);
2545 
2546   __ bind(notObj);
2547   __ cmp(flags, (u1)itos);
2548   __ br(Assembler::NE, notInt);
2549   // itos
2550   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
2551   __ push(itos);
2552   // Rewrite bytecode to be faster
2553   if (rc == may_rewrite) {
2554     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
2555   }
2556   __ b(Done);
2557 
2558   __ bind(notInt);
2559   __ cmp(flags, (u1)ctos);
2560   __ br(Assembler::NE, notChar);
2561   // ctos
2562   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
2563   __ push(ctos);
2564   // Rewrite bytecode to be faster
2565   if (rc == may_rewrite) {
2566     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
2567   }
2568   __ b(Done);
2569 
2570   __ bind(notChar);
2571   __ cmp(flags, (u1)stos);
2572   __ br(Assembler::NE, notShort);
2573   // stos
2574   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
2575   __ push(stos);
2576   // Rewrite bytecode to be faster
2577   if (rc == may_rewrite) {
2578     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
2579   }
2580   __ b(Done);
2581 
2582   __ bind(notShort);
2583   __ cmp(flags, (u1)ltos);
2584   __ br(Assembler::NE, notLong);
2585   // ltos
2586   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
2587   __ push(ltos);
2588   // Rewrite bytecode to be faster
2589   if (rc == may_rewrite) {
2590     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
2591   }
2592   __ b(Done);
2593 
2594   __ bind(notLong);
2595   __ cmp(flags, (u1)ftos);
2596   __ br(Assembler::NE, notFloat);
2597   // ftos
2598   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2599   __ push(ftos);
2600   // Rewrite bytecode to be faster
2601   if (rc == may_rewrite) {
2602     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
2603   }
2604   __ b(Done);
2605 
2606   __ bind(notFloat);
2607 #ifdef ASSERT
2608   __ cmp(flags, (u1)dtos);
2609   __ br(Assembler::NE, notDouble);
2610 #endif
2611   // dtos
2612   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
2613   __ push(dtos);
2614   // Rewrite bytecode to be faster
2615   if (rc == may_rewrite) {
2616     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
2617   }
2618 #ifdef ASSERT
2619   __ b(Done);
2620 
2621   __ bind(notDouble);
2622   __ stop(&quot;Bad state&quot;);
2623 #endif
2624 
2625   __ bind(Done);
2626 
2627   Label notVolatile;
2628   __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2629   __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
2630   __ bind(notVolatile);
2631 }
2632 
2633 
2634 void TemplateTable::getfield(int byte_no)
2635 {
2636   getfield_or_static(byte_no, false);
2637 }
2638 
2639 void TemplateTable::nofast_getfield(int byte_no) {
2640   getfield_or_static(byte_no, false, may_not_rewrite);
2641 }
2642 
2643 void TemplateTable::getstatic(int byte_no)
2644 {
2645   getfield_or_static(byte_no, true);
2646 }
2647 
2648 // The registers cache and index expected to be set before call.
2649 // The function may destroy various registers, just not the cache and index registers.
2650 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
2651   transition(vtos, vtos);
2652 
2653   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2654 
2655   if (JvmtiExport::can_post_field_modification()) {
2656     // Check to see if a field modification watch has been set before
2657     // we take the time to call into the VM.
2658     Label L1;
2659     assert_different_registers(cache, index, r0);
2660     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2661     __ ldrw(r0, Address(rscratch1));
2662     __ cbz(r0, L1);
2663 
2664     __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);
2665 
2666     if (is_static) {
2667       // Life is simple.  Null out the object pointer.
2668       __ mov(c_rarg1, zr);
2669     } else {
2670       // Life is harder. The stack holds the value on top, followed by
2671       // the object.  We don&#39;t know the size of the value, though; it
2672       // could be one or two words depending on its type. As a result,
2673       // we must find the type to determine where the object is.
2674       __ ldrw(c_rarg3, Address(c_rarg2,
2675                                in_bytes(cp_base_offset +
2676                                         ConstantPoolCacheEntry::flags_offset())));
2677       __ lsr(c_rarg3, c_rarg3,
2678              ConstantPoolCacheEntry::tos_state_shift);
2679       ConstantPoolCacheEntry::verify_tos_state_shift();
2680       Label nope2, done, ok;
2681       __ ldr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
2682       __ cmpw(c_rarg3, ltos);
2683       __ br(Assembler::EQ, ok);
2684       __ cmpw(c_rarg3, dtos);
2685       __ br(Assembler::NE, nope2);
2686       __ bind(ok);
2687       __ ldr(c_rarg1, at_tos_p2()); // ltos (two word jvalue)
2688       __ bind(nope2);
2689     }
2690     // cache entry pointer
2691     __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));
2692     // object (tos)
2693     __ mov(c_rarg3, esp);
2694     // c_rarg1: object pointer set up above (NULL if static)
2695     // c_rarg2: cache entry pointer
2696     // c_rarg3: jvalue object on the stack
2697     __ call_VM(noreg,
2698                CAST_FROM_FN_PTR(address,
2699                                 InterpreterRuntime::post_field_modification),
2700                c_rarg1, c_rarg2, c_rarg3);
2701     __ get_cache_and_index_at_bcp(cache, index, 1);
2702     __ bind(L1);
2703   }
2704 }
2705 
2706 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2707   transition(vtos, vtos);
2708 
2709   const Register cache = r2;
2710   const Register index = r3;
2711   const Register obj   = r2;
2712   const Register off   = r19;
2713   const Register flags = r0;
2714   const Register bc    = r4;
2715 
2716   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2717   jvmti_post_field_mod(cache, index, is_static);
2718   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2719 
2720   Label Done;
2721   __ mov(r5, flags);
2722 
2723   {
2724     Label notVolatile;
2725     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2726     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2727     __ bind(notVolatile);
2728   }
2729 
2730   // field address
2731   const Address field(obj, off);
2732 
2733   Label notByte, notBool, notInt, notShort, notChar,
2734         notLong, notFloat, notObj, notDouble;
2735 
2736   // x86 uses a shift and mask or wings it with a shift plus assert
2737   // the mask is not needed. aarch64 just uses bitfield extract
2738   __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
2739 
2740   assert(btos == 0, &quot;change code, btos != 0&quot;);
2741   __ cbnz(flags, notByte);
2742 
2743   // Don&#39;t rewrite putstatic, only putfield
2744   if (is_static) rc = may_not_rewrite;
2745 
2746   // btos
2747   {
2748     __ pop(btos);
2749     if (!is_static) pop_and_check_object(obj);
2750     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
2751     if (rc == may_rewrite) {
2752       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
2753     }
2754     __ b(Done);
2755   }
2756 
2757   __ bind(notByte);
2758   __ cmp(flags, (u1)ztos);
2759   __ br(Assembler::NE, notBool);
2760 
2761   // ztos
2762   {
2763     __ pop(ztos);
2764     if (!is_static) pop_and_check_object(obj);
2765     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
2766     if (rc == may_rewrite) {
2767       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
2768     }
2769     __ b(Done);
2770   }
2771 
2772   __ bind(notBool);
2773   __ cmp(flags, (u1)atos);
2774   __ br(Assembler::NE, notObj);
2775 
2776   // atos
2777   {
2778     __ pop(atos);
2779     if (!is_static) pop_and_check_object(obj);
2780     // Store into the field
2781     do_oop_store(_masm, field, r0, IN_HEAP);
2782     if (rc == may_rewrite) {
2783       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
2784     }
2785     __ b(Done);
2786   }
2787 
2788   __ bind(notObj);
2789   __ cmp(flags, (u1)itos);
2790   __ br(Assembler::NE, notInt);
2791 
2792   // itos
2793   {
2794     __ pop(itos);
2795     if (!is_static) pop_and_check_object(obj);
2796     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
2797     if (rc == may_rewrite) {
2798       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
2799     }
2800     __ b(Done);
2801   }
2802 
2803   __ bind(notInt);
2804   __ cmp(flags, (u1)ctos);
2805   __ br(Assembler::NE, notChar);
2806 
2807   // ctos
2808   {
2809     __ pop(ctos);
2810     if (!is_static) pop_and_check_object(obj);
2811     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
2812     if (rc == may_rewrite) {
2813       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
2814     }
2815     __ b(Done);
2816   }
2817 
2818   __ bind(notChar);
2819   __ cmp(flags, (u1)stos);
2820   __ br(Assembler::NE, notShort);
2821 
2822   // stos
2823   {
2824     __ pop(stos);
2825     if (!is_static) pop_and_check_object(obj);
2826     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
2827     if (rc == may_rewrite) {
2828       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
2829     }
2830     __ b(Done);
2831   }
2832 
2833   __ bind(notShort);
2834   __ cmp(flags, (u1)ltos);
2835   __ br(Assembler::NE, notLong);
2836 
2837   // ltos
2838   {
2839     __ pop(ltos);
2840     if (!is_static) pop_and_check_object(obj);
2841     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
2842     if (rc == may_rewrite) {
2843       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
2844     }
2845     __ b(Done);
2846   }
2847 
2848   __ bind(notLong);
2849   __ cmp(flags, (u1)ftos);
2850   __ br(Assembler::NE, notFloat);
2851 
2852   // ftos
2853   {
2854     __ pop(ftos);
2855     if (!is_static) pop_and_check_object(obj);
2856     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
2857     if (rc == may_rewrite) {
2858       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
2859     }
2860     __ b(Done);
2861   }
2862 
2863   __ bind(notFloat);
2864 #ifdef ASSERT
2865   __ cmp(flags, (u1)dtos);
2866   __ br(Assembler::NE, notDouble);
2867 #endif
2868 
2869   // dtos
2870   {
2871     __ pop(dtos);
2872     if (!is_static) pop_and_check_object(obj);
2873     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
2874     if (rc == may_rewrite) {
2875       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
2876     }
2877   }
2878 
2879 #ifdef ASSERT
2880   __ b(Done);
2881 
2882   __ bind(notDouble);
2883   __ stop(&quot;Bad state&quot;);
2884 #endif
2885 
2886   __ bind(Done);
2887 
2888   {
2889     Label notVolatile;
2890     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2891     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
2892     __ bind(notVolatile);
2893   }
2894 }
2895 
2896 void TemplateTable::putfield(int byte_no)
2897 {
2898   putfield_or_static(byte_no, false);
2899 }
2900 
2901 void TemplateTable::nofast_putfield(int byte_no) {
2902   putfield_or_static(byte_no, false, may_not_rewrite);
2903 }
2904 
2905 void TemplateTable::putstatic(int byte_no) {
2906   putfield_or_static(byte_no, true);
2907 }
2908 
2909 void TemplateTable::jvmti_post_fast_field_mod()
2910 {
2911   if (JvmtiExport::can_post_field_modification()) {
2912     // Check to see if a field modification watch has been set before
2913     // we take the time to call into the VM.
2914     Label L2;
2915     __ lea(rscratch1, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
2916     __ ldrw(c_rarg3, Address(rscratch1));
2917     __ cbzw(c_rarg3, L2);
2918     __ pop_ptr(r19);                  // copy the object pointer from tos
2919     __ verify_oop(r19);
2920     __ push_ptr(r19);                 // put the object pointer back on tos
2921     // Save tos values before call_VM() clobbers them. Since we have
2922     // to do it for every data type, we use the saved values as the
2923     // jvalue object.
2924     switch (bytecode()) {          // load values into the jvalue object
2925     case Bytecodes::_fast_aputfield: __ push_ptr(r0); break;
2926     case Bytecodes::_fast_bputfield: // fall through
2927     case Bytecodes::_fast_zputfield: // fall through
2928     case Bytecodes::_fast_sputfield: // fall through
2929     case Bytecodes::_fast_cputfield: // fall through
2930     case Bytecodes::_fast_iputfield: __ push_i(r0); break;
2931     case Bytecodes::_fast_dputfield: __ push_d(); break;
2932     case Bytecodes::_fast_fputfield: __ push_f(); break;
2933     case Bytecodes::_fast_lputfield: __ push_l(r0); break;
2934 
2935     default:
2936       ShouldNotReachHere();
2937     }
2938     __ mov(c_rarg3, esp);             // points to jvalue on the stack
2939     // access constant pool cache entry
2940     __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);
2941     __ verify_oop(r19);
2942     // r19: object pointer copied above
2943     // c_rarg2: cache entry pointer
2944     // c_rarg3: jvalue object on the stack
2945     __ call_VM(noreg,
2946                CAST_FROM_FN_PTR(address,
2947                                 InterpreterRuntime::post_field_modification),
2948                r19, c_rarg2, c_rarg3);
2949 
2950     switch (bytecode()) {             // restore tos values
2951     case Bytecodes::_fast_aputfield: __ pop_ptr(r0); break;
2952     case Bytecodes::_fast_bputfield: // fall through
2953     case Bytecodes::_fast_zputfield: // fall through
2954     case Bytecodes::_fast_sputfield: // fall through
2955     case Bytecodes::_fast_cputfield: // fall through
2956     case Bytecodes::_fast_iputfield: __ pop_i(r0); break;
2957     case Bytecodes::_fast_dputfield: __ pop_d(); break;
2958     case Bytecodes::_fast_fputfield: __ pop_f(); break;
2959     case Bytecodes::_fast_lputfield: __ pop_l(r0); break;
2960     default: break;
2961     }
2962     __ bind(L2);
2963   }
2964 }
2965 
2966 void TemplateTable::fast_storefield(TosState state)
2967 {
2968   transition(state, vtos);
2969 
2970   ByteSize base = ConstantPoolCache::base_offset();
2971 
2972   jvmti_post_fast_field_mod();
2973 
2974   // access constant pool cache
2975   __ get_cache_and_index_at_bcp(r2, r1, 1);
2976 
2977   // test for volatile with r3
2978   __ ldrw(r3, Address(r2, in_bytes(base +
2979                                    ConstantPoolCacheEntry::flags_offset())));
2980 
2981   // replace index with field offset from cache entry
2982   __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
2983 
2984   {
2985     Label notVolatile;
2986     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2987     __ membar(MacroAssembler::StoreStore | MacroAssembler::LoadStore);
2988     __ bind(notVolatile);
2989   }
2990 
2991   Label notVolatile;
2992 
2993   // Get object from stack
2994   pop_and_check_object(r2);
2995 
2996   // field address
2997   const Address field(r2, r1);
2998 
2999   // access field
3000   switch (bytecode()) {
3001   case Bytecodes::_fast_aputfield:
3002     do_oop_store(_masm, field, r0, IN_HEAP);
3003     break;
3004   case Bytecodes::_fast_lputfield:
3005     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
3006     break;
3007   case Bytecodes::_fast_iputfield:
3008     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
3009     break;
3010   case Bytecodes::_fast_zputfield:
3011     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
3012     break;
3013   case Bytecodes::_fast_bputfield:
3014     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
3015     break;
3016   case Bytecodes::_fast_sputfield:
3017     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
3018     break;
3019   case Bytecodes::_fast_cputfield:
3020     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
3021     break;
3022   case Bytecodes::_fast_fputfield:
3023     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3024     break;
3025   case Bytecodes::_fast_dputfield:
3026     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
3027     break;
3028   default:
3029     ShouldNotReachHere();
3030   }
3031 
3032   {
3033     Label notVolatile;
3034     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3035     __ membar(MacroAssembler::StoreLoad | MacroAssembler::StoreStore);
3036     __ bind(notVolatile);
3037   }
3038 }
3039 
3040 
3041 void TemplateTable::fast_accessfield(TosState state)
3042 {
3043   transition(atos, state);
3044   // Do the JVMTI work here to avoid disturbing the register state below
3045   if (JvmtiExport::can_post_field_access()) {
3046     // Check to see if a field access watch has been set before we
3047     // take the time to call into the VM.
3048     Label L1;
3049     __ lea(rscratch1, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3050     __ ldrw(r2, Address(rscratch1));
3051     __ cbzw(r2, L1);
3052     // access constant pool cache entry
3053     __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);
3054     __ verify_oop(r0);
3055     __ push_ptr(r0);  // save object pointer before call_VM() clobbers it
3056     __ mov(c_rarg1, r0);
3057     // c_rarg1: object pointer copied above
3058     // c_rarg2: cache entry pointer
3059     __ call_VM(noreg,
3060                CAST_FROM_FN_PTR(address,
3061                                 InterpreterRuntime::post_field_access),
3062                c_rarg1, c_rarg2);
3063     __ pop_ptr(r0); // restore object pointer
3064     __ bind(L1);
3065   }
3066 
3067   // access constant pool cache
3068   __ get_cache_and_index_at_bcp(r2, r1, 1);
3069   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3070                                   ConstantPoolCacheEntry::f2_offset())));
3071   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3072                                    ConstantPoolCacheEntry::flags_offset())));
3073 
3074   // r0: object
3075   __ verify_oop(r0);
3076   __ null_check(r0);
3077   const Address field(r0, r1);
3078 
3079   // 8179954: We need to make sure that the code generated for
3080   // volatile accesses forms a sequentially-consistent set of
3081   // operations when combined with STLR and LDAR.  Without a leading
3082   // membar it&#39;s possible for a simple Dekker test to fail if loads
3083   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3084   // the stores in one method and we interpret the loads in another.
3085   if (! UseBarriersForVolatile) {
3086     Label notVolatile;
3087     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3088     __ membar(MacroAssembler::AnyAny);
3089     __ bind(notVolatile);
3090   }
3091 
3092   // access field
3093   switch (bytecode()) {
3094   case Bytecodes::_fast_agetfield:
3095     do_oop_load(_masm, field, r0, IN_HEAP);
3096     __ verify_oop(r0);
3097     break;
3098   case Bytecodes::_fast_lgetfield:
3099     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3100     break;
3101   case Bytecodes::_fast_igetfield:
3102     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3103     break;
3104   case Bytecodes::_fast_bgetfield:
3105     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
3106     break;
3107   case Bytecodes::_fast_sgetfield:
3108     __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
3109     break;
3110   case Bytecodes::_fast_cgetfield:
3111     __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
3112     break;
3113   case Bytecodes::_fast_fgetfield:
3114     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3115     break;
3116   case Bytecodes::_fast_dgetfield:
3117     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3118     break;
3119   default:
3120     ShouldNotReachHere();
3121   }
3122   {
3123     Label notVolatile;
3124     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3125     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3126     __ bind(notVolatile);
3127   }
3128 }
3129 
3130 void TemplateTable::fast_xaccess(TosState state)
3131 {
3132   transition(vtos, state);
3133 
3134   // get receiver
3135   __ ldr(r0, aaddress(0));
3136   // access constant pool cache
3137   __ get_cache_and_index_at_bcp(r2, r3, 2);
3138   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3139                                   ConstantPoolCacheEntry::f2_offset())));
3140 
3141   // 8179954: We need to make sure that the code generated for
3142   // volatile accesses forms a sequentially-consistent set of
3143   // operations when combined with STLR and LDAR.  Without a leading
3144   // membar it&#39;s possible for a simple Dekker test to fail if loads
3145   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3146   // the stores in one method and we interpret the loads in another.
3147   if (! UseBarriersForVolatile) {
3148     Label notVolatile;
3149     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3150                                      ConstantPoolCacheEntry::flags_offset())));
3151     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3152     __ membar(MacroAssembler::AnyAny);
3153     __ bind(notVolatile);
3154   }
3155 
3156   // make sure exception is reported in correct bcp range (getfield is
3157   // next instruction)
3158   __ increment(rbcp);
3159   __ null_check(r0);
3160   switch (state) {
3161   case itos:
3162     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3163     break;
3164   case atos:
3165     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3166     __ verify_oop(r0);
3167     break;
3168   case ftos:
3169     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3170     break;
3171   default:
3172     ShouldNotReachHere();
3173   }
3174 
3175   {
3176     Label notVolatile;
3177     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3178                                      ConstantPoolCacheEntry::flags_offset())));
3179     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3180     __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);
3181     __ bind(notVolatile);
3182   }
3183 
3184   __ decrement(rbcp);
3185 }
3186 
3187 
3188 
3189 //-----------------------------------------------------------------------------
3190 // Calls
3191 
3192 void TemplateTable::count_calls(Register method, Register temp)
3193 {
3194   __ call_Unimplemented();
3195 }
3196 
3197 void TemplateTable::prepare_invoke(int byte_no,
3198                                    Register method, // linked method (or i-klass)
3199                                    Register index,  // itable index, MethodType, etc.
3200                                    Register recv,   // if caller wants to see it
3201                                    Register flags   // if caller wants to test it
3202                                    ) {
3203   // determine flags
3204   Bytecodes::Code code = bytecode();
3205   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3206   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3207   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3208   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3209   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3210   const bool load_receiver       = (recv  != noreg);
3211   const bool save_flags          = (flags != noreg);
3212   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3213   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3214   assert(flags == noreg || flags == r3, &quot;&quot;);
3215   assert(recv  == noreg || recv  == r2, &quot;&quot;);
3216 
3217   // setup registers &amp; access constant pool cache
3218   if (recv  == noreg)  recv  = r2;
3219   if (flags == noreg)  flags = r3;
3220   assert_different_registers(method, index, recv, flags);
3221 
3222   // save &#39;interpreter return address&#39;
3223   __ save_bcp();
3224 
3225   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3226 
3227   // maybe push appendix to arguments (just before return address)
3228   if (is_invokedynamic || is_invokehandle) {
3229     Label L_no_push;
3230     __ tbz(flags, ConstantPoolCacheEntry::has_appendix_shift, L_no_push);
3231     // Push the appendix as a trailing parameter.
3232     // This must be done before we get the receiver,
3233     // since the parameter_size includes it.
3234     __ push(r19);
3235     __ mov(r19, index);
3236     __ load_resolved_reference_at_index(index, r19);
3237     __ pop(r19);
3238     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3239     __ bind(L_no_push);
3240   }
3241 
3242   // load receiver if needed (note: no return address pushed yet)
3243   if (load_receiver) {
3244     __ andw(recv, flags, ConstantPoolCacheEntry::parameter_size_mask);
3245     // FIXME -- is this actually correct? looks like it should be 2
3246     // const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3247     // const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3248     // Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3249     // __ movptr(recv, recv_addr);
3250     __ add(rscratch1, esp, recv, ext::uxtx, 3); // FIXME: uxtb here?
3251     __ ldr(recv, Address(rscratch1, -Interpreter::expr_offset_in_bytes(1)));
3252     __ verify_oop(recv);
3253   }
3254 
3255   // compute return type
3256   // x86 uses a shift and mask or wings it with a shift plus assert
3257   // the mask is not needed. aarch64 just uses bitfield extract
3258   __ ubfxw(rscratch2, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);
3259   // load return address
3260   {
3261     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3262     __ mov(rscratch1, table_addr);
3263     __ ldr(lr, Address(rscratch1, rscratch2, Address::lsl(3)));
3264   }
3265 }
3266 
3267 
3268 void TemplateTable::invokevirtual_helper(Register index,
3269                                          Register recv,
3270                                          Register flags)
3271 {
3272   // Uses temporary registers r0, r3
3273   assert_different_registers(index, recv, r0, r3);
3274   // Test for an invoke of a final method
3275   Label notFinal;
3276   __ tbz(flags, ConstantPoolCacheEntry::is_vfinal_shift, notFinal);
3277 
3278   const Register method = index;  // method must be rmethod
3279   assert(method == rmethod,
3280          &quot;methodOop must be rmethod for interpreter calling convention&quot;);
3281 
3282   // do the call - the index is actually the method to call
3283   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3284 
3285   // It&#39;s final, need a null check here!
3286   __ null_check(recv);
3287 
3288   // profile this call
3289   __ profile_final_call(r0);
3290   __ profile_arguments_type(r0, method, r4, true);
3291 
3292   __ jump_from_interpreted(method, r0);
3293 
3294   __ bind(notFinal);
3295 
3296   // get receiver klass
3297   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3298   __ load_klass(r0, recv);
3299 
3300   // profile this call
3301   __ profile_virtual_call(r0, rlocals, r3);
3302 
3303   // get target methodOop &amp; entry point
3304   __ lookup_virtual_method(r0, index, method);
3305   __ profile_arguments_type(r3, method, r4, true);
3306   // FIXME -- this looks completely redundant. is it?
3307   // __ ldr(r3, Address(method, Method::interpreter_entry_offset()));
3308   __ jump_from_interpreted(method, r3);
3309 }
3310 
3311 void TemplateTable::invokevirtual(int byte_no)
3312 {
3313   transition(vtos, vtos);
3314   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3315 
3316   prepare_invoke(byte_no, rmethod, noreg, r2, r3);
3317 
3318   // rmethod: index (actually a Method*)
3319   // r2: receiver
3320   // r3: flags
3321 
3322   invokevirtual_helper(rmethod, r2, r3);
3323 }
3324 
3325 void TemplateTable::invokespecial(int byte_no)
3326 {
3327   transition(vtos, vtos);
3328   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3329 
3330   prepare_invoke(byte_no, rmethod, noreg,  // get f1 Method*
3331                  r2);  // get receiver also for null check
3332   __ verify_oop(r2);
3333   __ null_check(r2);
3334   // do the call
3335   __ profile_call(r0);
3336   __ profile_arguments_type(r0, rmethod, rbcp, false);
3337   __ jump_from_interpreted(rmethod, r0);
3338 }
3339 
3340 void TemplateTable::invokestatic(int byte_no)
3341 {
3342   transition(vtos, vtos);
3343   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3344 
3345   prepare_invoke(byte_no, rmethod);  // get f1 Method*
3346   // do the call
3347   __ profile_call(r0);
3348   __ profile_arguments_type(r0, rmethod, r4, false);
3349   __ jump_from_interpreted(rmethod, r0);
3350 }
3351 
3352 void TemplateTable::fast_invokevfinal(int byte_no)
3353 {
3354   __ call_Unimplemented();
3355 }
3356 
3357 void TemplateTable::invokeinterface(int byte_no) {
3358   transition(vtos, vtos);
3359   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3360 
3361   prepare_invoke(byte_no, r0, rmethod,  // get f1 Klass*, f2 Method*
3362                  r2, r3); // recv, flags
3363 
3364   // r0: interface klass (from f1)
3365   // rmethod: method (from f2)
3366   // r2: receiver
3367   // r3: flags
3368 
3369   // First check for Object case, then private interface method,
3370   // then regular interface method.
3371 
3372   // Special case of invokeinterface called for virtual method of
3373   // java.lang.Object.  See cpCache.cpp for details.
3374   Label notObjectMethod;
3375   __ tbz(r3, ConstantPoolCacheEntry::is_forced_virtual_shift, notObjectMethod);
3376 
3377   invokevirtual_helper(rmethod, r2, r3);
3378   __ bind(notObjectMethod);
3379 
3380   Label no_such_interface;
3381 
3382   // Check for private method invocation - indicated by vfinal
3383   Label notVFinal;
3384   __ tbz(r3, ConstantPoolCacheEntry::is_vfinal_shift, notVFinal);
3385 
3386   // Get receiver klass into r3 - also a null check
3387   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3388   __ load_klass(r3, r2);
3389 
3390   Label subtype;
3391   __ check_klass_subtype(r3, r0, r4, subtype);
3392   // If we get here the typecheck failed
3393   __ b(no_such_interface);
3394   __ bind(subtype);
3395 
3396   __ profile_final_call(r0);
3397   __ profile_arguments_type(r0, rmethod, r4, true);
3398   __ jump_from_interpreted(rmethod, r0);
3399 
3400   __ bind(notVFinal);
3401 
3402   // Get receiver klass into r3 - also a null check
3403   __ restore_locals();
3404   __ null_check(r2, oopDesc::klass_offset_in_bytes());
3405   __ load_klass(r3, r2);
3406 
3407   Label no_such_method;
3408 
3409   // Preserve method for throw_AbstractMethodErrorVerbose.
3410   __ mov(r16, rmethod);
3411   // Receiver subtype check against REFC.
3412   // Superklass in r0. Subklass in r3. Blows rscratch2, r13
3413   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3414                              r3, r0, noreg,
3415                              // outputs: scan temp. reg, scan temp. reg
3416                              rscratch2, r13,
3417                              no_such_interface,
3418                              /*return_method=*/false);
3419 
3420   // profile this call
3421   __ profile_virtual_call(r3, r13, r19);
3422 
3423   // Get declaring interface class from method, and itable index
3424 
3425   __ load_method_holder(r0, rmethod);
3426   __ ldrw(rmethod, Address(rmethod, Method::itable_index_offset()));
3427   __ subw(rmethod, rmethod, Method::itable_index_max);
3428   __ negw(rmethod, rmethod);
3429 
3430   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3431   __ mov(rlocals, r3);
3432   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3433                              rlocals, r0, rmethod,
3434                              // outputs: method, scan temp. reg
3435                              rmethod, r13,
3436                              no_such_interface);
3437 
3438   // rmethod,: methodOop to call
3439   // r2: receiver
3440   // Check for abstract method error
3441   // Note: This should be done more efficiently via a throw_abstract_method_error
3442   //       interpreter entry point and a conditional jump to it in case of a null
3443   //       method.
3444   __ cbz(rmethod, no_such_method);
3445 
3446   __ profile_arguments_type(r3, rmethod, r13, true);
3447 
3448   // do the call
3449   // r2: receiver
3450   // rmethod,: methodOop
3451   __ jump_from_interpreted(rmethod, r3);
3452   __ should_not_reach_here();
3453 
3454   // exception handling code follows...
3455   // note: must restore interpreter registers to canonical
3456   //       state for exception handling to work correctly!
3457 
3458   __ bind(no_such_method);
3459   // throw exception
3460   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3461   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3462   // Pass arguments for generating a verbose error message.
3463   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose), r3, r16);
3464   // the call_VM checks for exception, so we should never return here.
3465   __ should_not_reach_here();
3466 
3467   __ bind(no_such_interface);
3468   // throw exception
3469   __ restore_bcp();      // bcp must be correct for exception handler   (was destroyed)
3470   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3471   // Pass arguments for generating a verbose error message.
3472   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3473                    InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose), r3, r0);
3474   // the call_VM checks for exception, so we should never return here.
3475   __ should_not_reach_here();
3476   return;
3477 }
3478 
3479 void TemplateTable::invokehandle(int byte_no) {
3480   transition(vtos, vtos);
3481   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3482 
3483   prepare_invoke(byte_no, rmethod, r0, r2);
3484   __ verify_method_ptr(r2);
3485   __ verify_oop(r2);
3486   __ null_check(r2);
3487 
3488   // FIXME: profile the LambdaForm also
3489 
3490   // r13 is safe to use here as a scratch reg because it is about to
3491   // be clobbered by jump_from_interpreted().
3492   __ profile_final_call(r13);
3493   __ profile_arguments_type(r13, rmethod, r4, true);
3494 
3495   __ jump_from_interpreted(rmethod, r0);
3496 }
3497 
3498 void TemplateTable::invokedynamic(int byte_no) {
3499   transition(vtos, vtos);
3500   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3501 
3502   prepare_invoke(byte_no, rmethod, r0);
3503 
3504   // r0: CallSite object (from cpool-&gt;resolved_references[])
3505   // rmethod: MH.linkToCallSite method (from f2)
3506 
3507   // Note:  r0_callsite is already pushed by prepare_invoke
3508 
3509   // %%% should make a type profile for any invokedynamic that takes a ref argument
3510   // profile this call
3511   __ profile_call(rbcp);
3512   __ profile_arguments_type(r3, rmethod, r13, false);
3513 
3514   __ verify_oop(r0);
3515 
3516   __ jump_from_interpreted(rmethod, r0);
3517 }
3518 
3519 
3520 //-----------------------------------------------------------------------------
3521 // Allocation
3522 
3523 void TemplateTable::_new() {
3524   transition(vtos, atos);
3525 
3526   __ get_unsigned_2_byte_index_at_bcp(r3, 1);
3527   Label slow_case;
3528   Label done;
3529   Label initialize_header;
3530   Label initialize_object; // including clearing the fields
3531 
3532   __ get_cpool_and_tags(r4, r0);
3533   // Make sure the class we&#39;re about to instantiate has been resolved.
3534   // This is done before loading InstanceKlass to be consistent with the order
3535   // how Constant Pool is updated (see ConstantPool::klass_at_put)
3536   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3537   __ lea(rscratch1, Address(r0, r3, Address::lsl(0)));
3538   __ lea(rscratch1, Address(rscratch1, tags_offset));
3539   __ ldarb(rscratch1, rscratch1);
3540   __ cmp(rscratch1, (u1)JVM_CONSTANT_Class);
3541   __ br(Assembler::NE, slow_case);
3542 
3543   // get InstanceKlass
3544   __ load_resolved_klass_at_offset(r4, r3, r4, rscratch1);
3545 
3546   // make sure klass is initialized &amp; doesn&#39;t have finalizer
3547   // make sure klass is fully initialized
3548   __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));
3549   __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);
3550   __ br(Assembler::NE, slow_case);
3551 
3552   // get instance_size in InstanceKlass (scaled to a count of bytes)
3553   __ ldrw(r3,
3554           Address(r4,
3555                   Klass::layout_helper_offset()));
3556   // test to see if it has a finalizer or is malformed in some way
3557   __ tbnz(r3, exact_log2(Klass::_lh_instance_slow_path_bit), slow_case);
3558 
3559   // Allocate the instance:
3560   //  If TLAB is enabled:
3561   //    Try to allocate in the TLAB.
3562   //    If fails, go to the slow path.
3563   //  Else If inline contiguous allocations are enabled:
3564   //    Try to allocate in eden.
3565   //    If fails due to heap end, go to slow path.
3566   //
3567   //  If TLAB is enabled OR inline contiguous is enabled:
3568   //    Initialize the allocation.
3569   //    Exit.
3570   //
3571   //  Go to slow path.
3572   const bool allow_shared_alloc =
3573     Universe::heap()-&gt;supports_inline_contig_alloc();
3574 
3575   if (UseTLAB) {
3576     __ tlab_allocate(r0, r3, 0, noreg, r1, slow_case);
3577 
3578     if (ZeroTLAB) {
3579       // the fields have been already cleared
3580       __ b(initialize_header);
3581     } else {
3582       // initialize both the header and fields
3583       __ b(initialize_object);
3584     }
3585   } else {
3586     // Allocation in the shared Eden, if allowed.
3587     //
3588     // r3: instance size in bytes
3589     if (allow_shared_alloc) {
3590       __ eden_allocate(r0, r3, 0, r10, slow_case);
3591     }
3592   }
3593 
3594   // If UseTLAB or allow_shared_alloc are true, the object is created above and
3595   // there is an initialize need. Otherwise, skip and go to the slow path.
3596   if (UseTLAB || allow_shared_alloc) {
3597     // The object is initialized before the header.  If the object size is
3598     // zero, go directly to the header initialization.
3599     __ bind(initialize_object);
3600     __ sub(r3, r3, sizeof(oopDesc));
3601     __ cbz(r3, initialize_header);
3602 
3603     // Initialize object fields
3604     {
3605       __ add(r2, r0, sizeof(oopDesc));
3606       Label loop;
3607       __ bind(loop);
3608       __ str(zr, Address(__ post(r2, BytesPerLong)));
3609       __ sub(r3, r3, BytesPerLong);
3610       __ cbnz(r3, loop);
3611     }
3612 
3613     // initialize object header only.
3614     __ bind(initialize_header);
3615     if (UseBiasedLocking) {
3616       __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));
3617     } else {
3618       __ mov(rscratch1, (intptr_t)markWord::prototype().value());
3619     }
3620     __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));
3621     __ store_klass_gap(r0, zr);  // zero klass gap for compressed oops
3622     __ store_klass(r0, r4);      // store klass last
3623 
3624     {
3625       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);
3626       // Trigger dtrace event for fastpath
3627       __ push(atos); // save the return value
3628       __ call_VM_leaf(
3629            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), r0);
3630       __ pop(atos); // restore the return value
3631 
3632     }
3633     __ b(done);
3634   }
3635 
3636   // slow case
3637   __ bind(slow_case);
3638   __ get_constant_pool(c_rarg1);
3639   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3640   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);
3641   __ verify_oop(r0);
3642 
3643   // continue
3644   __ bind(done);
3645   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3646   __ membar(Assembler::StoreStore);
3647 }
3648 
3649 void TemplateTable::newarray() {
3650   transition(itos, atos);
3651   __ load_unsigned_byte(c_rarg1, at_bcp(1));
3652   __ mov(c_rarg2, r0);
3653   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3654           c_rarg1, c_rarg2);
3655   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3656   __ membar(Assembler::StoreStore);
3657 }
3658 
3659 void TemplateTable::anewarray() {
3660   transition(itos, atos);
3661   __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);
3662   __ get_constant_pool(c_rarg1);
3663   __ mov(c_rarg3, r0);
3664   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3665           c_rarg1, c_rarg2, c_rarg3);
3666   // Must prevent reordering of stores for object initialization with stores that publish the new object.
3667   __ membar(Assembler::StoreStore);
3668 }
3669 
3670 void TemplateTable::arraylength() {
3671   transition(atos, itos);
3672   __ null_check(r0, arrayOopDesc::length_offset_in_bytes());
3673   __ ldrw(r0, Address(r0, arrayOopDesc::length_offset_in_bytes()));
3674 }
3675 
3676 void TemplateTable::checkcast()
3677 {
3678   transition(atos, atos);
3679   Label done, is_null, ok_is_subtype, quicked, resolved;
3680   __ cbz(r0, is_null);
3681 
3682   // Get cpool &amp; tags index
3683   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3684   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3685   // See if bytecode has already been quicked
3686   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3687   __ lea(r1, Address(rscratch1, r19));
3688   __ ldarb(r1, r1);
3689   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3690   __ br(Assembler::EQ, quicked);
3691 
3692   __ push(atos); // save receiver for result, and for GC
3693   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3694   // vm_result_2 has metadata result
3695   __ get_vm_result_2(r0, rthread);
3696   __ pop(r3); // restore receiver
3697   __ b(resolved);
3698 
3699   // Get superklass in r0 and subklass in r3
3700   __ bind(quicked);
3701   __ mov(r3, r0); // Save object in r3; r0 needed for subtype check
3702   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1); // r0 = klass
3703 
3704   __ bind(resolved);
3705   __ load_klass(r19, r3);
3706 
3707   // Generate subtype check.  Blows r2, r5.  Object in r3.
3708   // Superklass in r0.  Subklass in r19.
3709   __ gen_subtype_check(r19, ok_is_subtype);
3710 
3711   // Come here on failure
3712   __ push(r3);
3713   // object is at TOS
3714   __ b(Interpreter::_throw_ClassCastException_entry);
3715 
3716   // Come here on success
3717   __ bind(ok_is_subtype);
3718   __ mov(r0, r3); // Restore object in r3
3719 
3720   // Collect counts on whether this test sees NULLs a lot or not.
3721   if (ProfileInterpreter) {
3722     __ b(done);
3723     __ bind(is_null);
3724     __ profile_null_seen(r2);
3725   } else {
3726     __ bind(is_null);   // same as &#39;done&#39;
3727   }
3728   __ bind(done);
3729 }
3730 
3731 void TemplateTable::instanceof() {
3732   transition(atos, itos);
3733   Label done, is_null, ok_is_subtype, quicked, resolved;
3734   __ cbz(r0, is_null);
3735 
3736   // Get cpool &amp; tags index
3737   __ get_cpool_and_tags(r2, r3); // r2=cpool, r3=tags array
3738   __ get_unsigned_2_byte_index_at_bcp(r19, 1); // r19=index
3739   // See if bytecode has already been quicked
3740   __ add(rscratch1, r3, Array&lt;u1&gt;::base_offset_in_bytes());
3741   __ lea(r1, Address(rscratch1, r19));
3742   __ ldarb(r1, r1);
3743   __ cmp(r1, (u1)JVM_CONSTANT_Class);
3744   __ br(Assembler::EQ, quicked);
3745 
3746   __ push(atos); // save receiver for result, and for GC
3747   call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3748   // vm_result_2 has metadata result
3749   __ get_vm_result_2(r0, rthread);
3750   __ pop(r3); // restore receiver
3751   __ verify_oop(r3);
3752   __ load_klass(r3, r3);
3753   __ b(resolved);
3754 
3755   // Get superklass in r0 and subklass in r3
3756   __ bind(quicked);
3757   __ load_klass(r3, r0);
3758   __ load_resolved_klass_at_offset(r2, r19, r0, rscratch1);
3759 
3760   __ bind(resolved);
3761 
3762   // Generate subtype check.  Blows r2, r5
3763   // Superklass in r0.  Subklass in r3.
3764   __ gen_subtype_check(r3, ok_is_subtype);
3765 
3766   // Come here on failure
3767   __ mov(r0, 0);
3768   __ b(done);
3769   // Come here on success
3770   __ bind(ok_is_subtype);
3771   __ mov(r0, 1);
3772 
3773   // Collect counts on whether this test sees NULLs a lot or not.
3774   if (ProfileInterpreter) {
3775     __ b(done);
3776     __ bind(is_null);
3777     __ profile_null_seen(r2);
3778   } else {
3779     __ bind(is_null);   // same as &#39;done&#39;
3780   }
3781   __ bind(done);
3782   // r0 = 0: obj == NULL or  obj is not an instanceof the specified klass
3783   // r0 = 1: obj != NULL and obj is     an instanceof the specified klass
3784 }
3785 
3786 //-----------------------------------------------------------------------------
3787 // Breakpoints
3788 void TemplateTable::_breakpoint() {
3789   // Note: We get here even if we are single stepping..
3790   // jbug inists on setting breakpoints at every bytecode
3791   // even if we are in single step mode.
3792 
3793   transition(vtos, vtos);
3794 
3795   // get the unpatched byte code
3796   __ get_method(c_rarg1);
3797   __ call_VM(noreg,
3798              CAST_FROM_FN_PTR(address,
3799                               InterpreterRuntime::get_original_bytecode_at),
3800              c_rarg1, rbcp);
3801   __ mov(r19, r0);
3802 
3803   // post the breakpoint event
3804   __ call_VM(noreg,
3805              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
3806              rmethod, rbcp);
3807 
3808   // complete the execution of original bytecode
3809   __ mov(rscratch1, r19);
3810   __ dispatch_only_normal(vtos);
3811 }
3812 
3813 //-----------------------------------------------------------------------------
3814 // Exceptions
3815 
3816 void TemplateTable::athrow() {
3817   transition(atos, vtos);
3818   __ null_check(r0);
3819   __ b(Interpreter::throw_exception_entry());
3820 }
3821 
3822 //-----------------------------------------------------------------------------
3823 // Synchronization
3824 //
3825 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
3826 //       in the assembly code structure as well
3827 //
3828 // Stack layout:
3829 //
3830 // [expressions  ] &lt;--- esp               = expression stack top
3831 // ..
3832 // [expressions  ]
3833 // [monitor entry] &lt;--- monitor block top = expression stack bot
3834 // ..
3835 // [monitor entry]
3836 // [frame data   ] &lt;--- monitor block bot
3837 // ...
3838 // [saved rbp    ] &lt;--- rbp
3839 void TemplateTable::monitorenter()
3840 {
3841   transition(atos, vtos);
3842 
3843   // check for NULL object
3844   __ null_check(r0);
3845 
3846   __ resolve(IS_NOT_NULL, r0);
3847 
3848   const Address monitor_block_top(
3849         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3850   const Address monitor_block_bot(
3851         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3852   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3853 
3854   Label allocated;
3855 
3856   // initialize entry pointer
3857   __ mov(c_rarg1, zr); // points to free slot or NULL
3858 
3859   // find a free slot in the monitor block (result in c_rarg1)
3860   {
3861     Label entry, loop, exit;
3862     __ ldr(c_rarg3, monitor_block_top); // points to current entry,
3863                                         // starting with top-most entry
3864     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3865 
3866     __ b(entry);
3867 
3868     __ bind(loop);
3869     // check if current entry is used
3870     // if not used then remember entry in c_rarg1
3871     __ ldr(rscratch1, Address(c_rarg3, BasicObjectLock::obj_offset_in_bytes()));
3872     __ cmp(zr, rscratch1);
3873     __ csel(c_rarg1, c_rarg3, c_rarg1, Assembler::EQ);
3874     // check if current entry is for same object
3875     __ cmp(r0, rscratch1);
3876     // if same object then stop searching
3877     __ br(Assembler::EQ, exit);
3878     // otherwise advance to next entry
3879     __ add(c_rarg3, c_rarg3, entry_size);
3880     __ bind(entry);
3881     // check if bottom reached
3882     __ cmp(c_rarg3, c_rarg2);
3883     // if not at bottom then check this entry
3884     __ br(Assembler::NE, loop);
3885     __ bind(exit);
3886   }
3887 
3888   __ cbnz(c_rarg1, allocated); // check if a slot has been found and
3889                             // if found, continue with that on
3890 
3891   // allocate one if there&#39;s no free slot
3892   {
3893     Label entry, loop;
3894     // 1. compute new pointers            // rsp: old expression stack top
3895     __ ldr(c_rarg1, monitor_block_bot);   // c_rarg1: old expression stack bottom
3896     __ sub(esp, esp, entry_size);         // move expression stack top
3897     __ sub(c_rarg1, c_rarg1, entry_size); // move expression stack bottom
3898     __ mov(c_rarg3, esp);                 // set start value for copy loop
3899     __ str(c_rarg1, monitor_block_bot);   // set new monitor block bottom
3900 
3901     __ sub(sp, sp, entry_size);           // make room for the monitor
3902 
3903     __ b(entry);
3904     // 2. move expression stack contents
3905     __ bind(loop);
3906     __ ldr(c_rarg2, Address(c_rarg3, entry_size)); // load expression stack
3907                                                    // word from old location
3908     __ str(c_rarg2, Address(c_rarg3, 0));          // and store it at new location
3909     __ add(c_rarg3, c_rarg3, wordSize);            // advance to next word
3910     __ bind(entry);
3911     __ cmp(c_rarg3, c_rarg1);        // check if bottom reached
3912     __ br(Assembler::NE, loop);      // if not at bottom then
3913                                      // copy next word
3914   }
3915 
3916   // call run-time routine
3917   // c_rarg1: points to monitor entry
3918   __ bind(allocated);
3919 
3920   // Increment bcp to point to the next bytecode, so exception
3921   // handling for async. exceptions work correctly.
3922   // The object has already been poped from the stack, so the
3923   // expression stack looks correct.
3924   __ increment(rbcp);
3925 
3926   // store object
3927   __ str(r0, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3928   __ lock_object(c_rarg1);
3929 
3930   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
3931   __ save_bcp();  // in case of exception
3932   __ generate_stack_overflow_check(0);
3933 
3934   // The bcp has already been incremented. Just need to dispatch to
3935   // next instruction.
3936   __ dispatch_next(vtos);
3937 }
3938 
3939 
3940 void TemplateTable::monitorexit()
3941 {
3942   transition(atos, vtos);
3943 
3944   // check for NULL object
3945   __ null_check(r0);
3946 
3947   __ resolve(IS_NOT_NULL, r0);
3948 
3949   const Address monitor_block_top(
3950         rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
3951   const Address monitor_block_bot(
3952         rfp, frame::interpreter_frame_initial_sp_offset * wordSize);
3953   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
3954 
3955   Label found;
3956 
3957   // find matching slot
3958   {
3959     Label entry, loop;
3960     __ ldr(c_rarg1, monitor_block_top); // points to current entry,
3961                                         // starting with top-most entry
3962     __ lea(c_rarg2, monitor_block_bot); // points to word before bottom
3963                                         // of monitor block
3964     __ b(entry);
3965 
3966     __ bind(loop);
3967     // check if current entry is for same object
3968     __ ldr(rscratch1, Address(c_rarg1, BasicObjectLock::obj_offset_in_bytes()));
3969     __ cmp(r0, rscratch1);
3970     // if same object then stop searching
3971     __ br(Assembler::EQ, found);
3972     // otherwise advance to next entry
3973     __ add(c_rarg1, c_rarg1, entry_size);
3974     __ bind(entry);
3975     // check if bottom reached
3976     __ cmp(c_rarg1, c_rarg2);
3977     // if not at bottom then check this entry
3978     __ br(Assembler::NE, loop);
3979   }
3980 
3981   // error handling. Unlocking was not block-structured
3982   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
3983                    InterpreterRuntime::throw_illegal_monitor_state_exception));
3984   __ should_not_reach_here();
3985 
3986   // call run-time routine
3987   __ bind(found);
3988   __ push_ptr(r0); // make sure object is on stack (contract with oopMaps)
3989   __ unlock_object(c_rarg1);
3990   __ pop_ptr(r0); // discard object
3991 }
3992 
3993 
3994 // Wide instructions
3995 void TemplateTable::wide()
3996 {
3997   __ load_unsigned_byte(r19, at_bcp(1));
3998   __ mov(rscratch1, (address)Interpreter::_wentry_point);
3999   __ ldr(rscratch1, Address(rscratch1, r19, Address::uxtw(3)));
4000   __ br(rscratch1);
4001 }
4002 
4003 
4004 // Multi arrays
4005 void TemplateTable::multianewarray() {
4006   transition(vtos, atos);
4007   __ load_unsigned_byte(r0, at_bcp(3)); // get number of dimensions
4008   // last dim is on top of stack; we want address of first one:
4009   // first_addr = last_addr + (ndims - 1) * wordSize
4010   __ lea(c_rarg1, Address(esp, r0, Address::uxtw(3)));
4011   __ sub(c_rarg1, c_rarg1, wordSize);
4012   call_VM(r0,
4013           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4014           c_rarg1);
4015   __ load_unsigned_byte(r1, at_bcp(3));
4016   __ lea(esp, Address(esp, r1, Address::uxtw(3)));
4017 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>