<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/stringopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callGenerator.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/divnode.hpp&quot;
  31 #include &quot;opto/graphKit.hpp&quot;
  32 #include &quot;opto/idealKit.hpp&quot;
  33 #include &quot;opto/rootnode.hpp&quot;
  34 #include &quot;opto/runtime.hpp&quot;
  35 #include &quot;opto/stringopts.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 
  39 #define __ kit.
  40 
  41 class StringConcat : public ResourceObj {
  42  private:
  43   PhaseStringOpts*    _stringopts;
  44   Node*               _string_alloc;
  45   AllocateNode*       _begin;          // The allocation the begins the pattern
  46   CallStaticJavaNode* _end;            // The final call of the pattern.  Will either be
  47                                        // SB.toString or or String.&lt;init&gt;(SB.toString)
  48   bool                _multiple;       // indicates this is a fusion of two or more
  49                                        // separate StringBuilders
  50 
  51   Node*               _arguments;      // The list of arguments to be concatenated
  52   GrowableArray&lt;int&gt;  _mode;           // into a String along with a mode flag
  53                                        // indicating how to treat the value.
  54   Node_List           _constructors;   // List of constructors (many in case of stacked concat)
  55   Node_List           _control;        // List of control nodes that will be deleted
  56   Node_List           _uncommon_traps; // Uncommon traps that needs to be rewritten
  57                                        // to restart at the initial JVMState.
  58 
  59  public:
  60   // Mode for converting arguments to Strings
  61   enum {
  62     StringMode,
  63     IntMode,
  64     CharMode,
  65     StringNullCheckMode
  66   };
  67 
  68   StringConcat(PhaseStringOpts* stringopts, CallStaticJavaNode* end):
  69     _stringopts(stringopts),
  70     _string_alloc(NULL),
  71     _begin(NULL),
  72     _end(end),
  73     _multiple(false) {
  74     _arguments = new Node(1);
  75     _arguments-&gt;del_req(0);
  76   }
  77 
  78   bool validate_mem_flow();
  79   bool validate_control_flow();
  80 
  81   void merge_add() {
  82 #if 0
  83     // XXX This is place holder code for reusing an existing String
  84     // allocation but the logic for checking the state safety is
  85     // probably inadequate at the moment.
  86     CallProjections endprojs;
  87     sc-&gt;end()-&gt;extract_projections(&amp;endprojs, false);
  88     if (endprojs.resproj != NULL) {
  89       for (SimpleDUIterator i(endprojs.resproj); i.has_next(); i.next()) {
  90         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
  91         if (use != NULL &amp;&amp; use-&gt;method() != NULL &amp;&amp;
  92             use-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_String_String &amp;&amp;
  93             use-&gt;in(TypeFunc::Parms + 1) == endprojs.resproj) {
  94           // Found useless new String(sb.toString()) so reuse the newly allocated String
  95           // when creating the result instead of allocating a new one.
  96           sc-&gt;set_string_alloc(use-&gt;in(TypeFunc::Parms));
  97           sc-&gt;set_end(use);
  98         }
  99       }
 100     }
 101 #endif
 102   }
 103 
 104   StringConcat* merge(StringConcat* other, Node* arg);
 105 
 106   void set_allocation(AllocateNode* alloc) {
 107     _begin = alloc;
 108   }
 109 
 110   void append(Node* value, int mode) {
 111     _arguments-&gt;add_req(value);
 112     _mode.append(mode);
 113   }
 114   void push(Node* value, int mode) {
 115     _arguments-&gt;ins_req(0, value);
 116     _mode.insert_before(0, mode);
 117   }
 118 
 119   void push_string(Node* value) {
 120     push(value, StringMode);
 121   }
 122   void push_string_null_check(Node* value) {
 123     push(value, StringNullCheckMode);
 124   }
 125   void push_int(Node* value) {
 126     push(value, IntMode);
 127   }
 128   void push_char(Node* value) {
 129     push(value, CharMode);
 130   }
 131 
 132   static bool is_SB_toString(Node* call) {
 133     if (call-&gt;is_CallStaticJava()) {
 134       CallStaticJavaNode* csj = call-&gt;as_CallStaticJava();
 135       ciMethod* m = csj-&gt;method();
 136       if (m != NULL &amp;&amp;
 137           (m-&gt;intrinsic_id() == vmIntrinsics::_StringBuilder_toString ||
 138            m-&gt;intrinsic_id() == vmIntrinsics::_StringBuffer_toString)) {
 139         return true;
 140       }
 141     }
 142     return false;
 143   }
 144 
 145   static Node* skip_string_null_check(Node* value) {
 146     // Look for a diamond shaped Null check of toString() result
 147     // (could be code from String.valueOf()):
 148     // (Proj == NULL) ? &quot;null&quot;:&quot;CastPP(Proj)#NotNULL
 149     if (value-&gt;is_Phi()) {
 150       int true_path = value-&gt;as_Phi()-&gt;is_diamond_phi();
 151       if (true_path != 0) {
 152         // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool
 153         BoolNode* b = value-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
 154         Node* cmp = b-&gt;in(1);
 155         Node* v1 = cmp-&gt;in(1);
 156         Node* v2 = cmp-&gt;in(2);
 157         // Null check of the return of toString which can simply be skipped.
 158         if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 159             v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 160             value-&gt;in(true_path)-&gt;Opcode() == Op_CastPP &amp;&amp;
 161             value-&gt;in(true_path)-&gt;in(1) == v1 &amp;&amp;
 162             v1-&gt;is_Proj() &amp;&amp; is_SB_toString(v1-&gt;in(0))) {
 163           return v1;
 164         }
 165       }
 166     }
 167     return value;
 168   }
 169 
 170   Node* argument(int i) {
 171     return _arguments-&gt;in(i);
 172   }
 173   Node* argument_uncast(int i) {
 174     Node* arg = argument(i);
 175     int amode = mode(i);
 176     if (amode == StringConcat::StringMode ||
 177         amode == StringConcat::StringNullCheckMode) {
 178       arg = skip_string_null_check(arg);
 179     }
 180     return arg;
 181   }
 182   void set_argument(int i, Node* value) {
 183     _arguments-&gt;set_req(i, value);
 184   }
 185   int num_arguments() {
 186     return _mode.length();
 187   }
 188   int mode(int i) {
 189     return _mode.at(i);
 190   }
 191   void add_control(Node* ctrl) {
 192     assert(!_control.contains(ctrl), &quot;only push once&quot;);
 193     _control.push(ctrl);
 194   }
 195   void add_constructor(Node* init) {
 196     assert(!_constructors.contains(init), &quot;only push once&quot;);
 197     _constructors.push(init);
 198   }
 199   CallStaticJavaNode* end() { return _end; }
 200   AllocateNode* begin() { return _begin; }
 201   Node* string_alloc() { return _string_alloc; }
 202 
 203   void eliminate_unneeded_control();
 204   void eliminate_initialize(InitializeNode* init);
 205   void eliminate_call(CallNode* call);
 206 
 207   void maybe_log_transform() {
 208     CompileLog* log = _stringopts-&gt;C-&gt;log();
 209     if (log != NULL) {
 210       log-&gt;head(&quot;replace_string_concat arguments=&#39;%d&#39; string_alloc=&#39;%d&#39; multiple=&#39;%d&#39;&quot;,
 211                 num_arguments(),
 212                 _string_alloc != NULL,
 213                 _multiple);
 214       JVMState* p = _begin-&gt;jvms();
 215       while (p != NULL) {
 216         log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
 217         p = p-&gt;caller();
 218       }
 219       log-&gt;tail(&quot;replace_string_concat&quot;);
 220     }
 221   }
 222 
 223   void convert_uncommon_traps(GraphKit&amp; kit, const JVMState* jvms) {
 224     for (uint u = 0; u &lt; _uncommon_traps.size(); u++) {
 225       Node* uct = _uncommon_traps.at(u);
 226 
 227       // Build a new call using the jvms state of the allocate
 228       address call_addr = SharedRuntime::uncommon_trap_blob()-&gt;entry_point();
 229       const TypeFunc* call_type = OptoRuntime::uncommon_trap_Type();
 230       const TypePtr* no_memory_effects = NULL;
 231       Compile* C = _stringopts-&gt;C;
 232       CallStaticJavaNode* call = new CallStaticJavaNode(call_type, call_addr, &quot;uncommon_trap&quot;,
 233                                                         jvms-&gt;bci(), no_memory_effects);
 234       for (int e = 0; e &lt; TypeFunc::Parms; e++) {
 235         call-&gt;init_req(e, uct-&gt;in(e));
 236       }
 237       // Set the trap request to record intrinsic failure if this trap
 238       // is taken too many times.  Ideally we would handle then traps by
 239       // doing the original bookkeeping in the MDO so that if it caused
 240       // the code to be thrown out we could still recompile and use the
 241       // optimization.  Failing the uncommon traps doesn&#39;t really mean
 242       // that the optimization is a bad idea but there&#39;s no other way to
 243       // do the MDO updates currently.
 244       int trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_intrinsic,
 245                                                            Deoptimization::Action_make_not_entrant);
 246       call-&gt;init_req(TypeFunc::Parms, __ intcon(trap_request));
 247       kit.add_safepoint_edges(call);
 248 
 249       _stringopts-&gt;gvn()-&gt;transform(call);
 250       C-&gt;gvn_replace_by(uct, call);
 251       uct-&gt;disconnect_inputs(NULL, C);
 252     }
 253   }
 254 
 255   void cleanup() {
 256     // disconnect the hook node
 257     _arguments-&gt;disconnect_inputs(NULL, _stringopts-&gt;C);
 258   }
 259 };
 260 
 261 
 262 void StringConcat::eliminate_unneeded_control() {
 263   for (uint i = 0; i &lt; _control.size(); i++) {
 264     Node* n = _control.at(i);
 265     if (n-&gt;is_Allocate()) {
 266       eliminate_initialize(n-&gt;as_Allocate()-&gt;initialization());
 267     }
 268     if (n-&gt;is_Call()) {
 269       if (n != _end) {
 270         eliminate_call(n-&gt;as_Call());
 271       }
 272     } else if (n-&gt;is_IfTrue()) {
 273       Compile* C = _stringopts-&gt;C;
 274       C-&gt;gvn_replace_by(n, n-&gt;in(0)-&gt;in(0));
 275       // get rid of the other projection
 276       C-&gt;gvn_replace_by(n-&gt;in(0)-&gt;as_If()-&gt;proj_out(false), C-&gt;top());
 277     }
 278   }
 279 }
 280 
 281 
 282 StringConcat* StringConcat::merge(StringConcat* other, Node* arg) {
 283   StringConcat* result = new StringConcat(_stringopts, _end);
 284   for (uint x = 0; x &lt; _control.size(); x++) {
 285     Node* n = _control.at(x);
 286     if (n-&gt;is_Call()) {
 287       result-&gt;_control.push(n);
 288     }
 289   }
 290   for (uint x = 0; x &lt; other-&gt;_control.size(); x++) {
 291     Node* n = other-&gt;_control.at(x);
 292     if (n-&gt;is_Call()) {
 293       result-&gt;_control.push(n);
 294     }
 295   }
 296   assert(result-&gt;_control.contains(other-&gt;_end), &quot;what?&quot;);
 297   assert(result-&gt;_control.contains(_begin), &quot;what?&quot;);
 298   for (int x = 0; x &lt; num_arguments(); x++) {
 299     Node* argx = argument_uncast(x);
 300     if (argx == arg) {
 301       // replace the toString result with the all the arguments that
 302       // made up the other StringConcat
 303       for (int y = 0; y &lt; other-&gt;num_arguments(); y++) {
 304         result-&gt;append(other-&gt;argument(y), other-&gt;mode(y));
 305       }
 306     } else {
 307       result-&gt;append(argx, mode(x));
 308     }
 309   }
 310   result-&gt;set_allocation(other-&gt;_begin);
 311   for (uint i = 0; i &lt; _constructors.size(); i++) {
 312     result-&gt;add_constructor(_constructors.at(i));
 313   }
 314   for (uint i = 0; i &lt; other-&gt;_constructors.size(); i++) {
 315     result-&gt;add_constructor(other-&gt;_constructors.at(i));
 316   }
 317   result-&gt;_multiple = true;
 318   return result;
 319 }
 320 
 321 
 322 void StringConcat::eliminate_call(CallNode* call) {
 323   Compile* C = _stringopts-&gt;C;
 324   CallProjections projs;
 325   call-&gt;extract_projections(&amp;projs, false);
 326   if (projs.fallthrough_catchproj != NULL) {
 327     C-&gt;gvn_replace_by(projs.fallthrough_catchproj, call-&gt;in(TypeFunc::Control));
 328   }
 329   if (projs.fallthrough_memproj != NULL) {
 330     C-&gt;gvn_replace_by(projs.fallthrough_memproj, call-&gt;in(TypeFunc::Memory));
 331   }
 332   if (projs.catchall_memproj != NULL) {
 333     C-&gt;gvn_replace_by(projs.catchall_memproj, C-&gt;top());
 334   }
 335   if (projs.fallthrough_ioproj != NULL) {
 336     C-&gt;gvn_replace_by(projs.fallthrough_ioproj, call-&gt;in(TypeFunc::I_O));
 337   }
 338   if (projs.catchall_ioproj != NULL) {
 339     C-&gt;gvn_replace_by(projs.catchall_ioproj, C-&gt;top());
 340   }
 341   if (projs.catchall_catchproj != NULL) {
 342     // EA can&#39;t cope with the partially collapsed graph this
 343     // creates so put it on the worklist to be collapsed later.
 344     for (SimpleDUIterator i(projs.catchall_catchproj); i.has_next(); i.next()) {
 345       Node *use = i.get();
 346       int opc = use-&gt;Opcode();
 347       if (opc == Op_CreateEx || opc == Op_Region) {
 348         _stringopts-&gt;record_dead_node(use);
 349       }
 350     }
 351     C-&gt;gvn_replace_by(projs.catchall_catchproj, C-&gt;top());
 352   }
 353   if (projs.resproj != NULL) {
 354     C-&gt;gvn_replace_by(projs.resproj, C-&gt;top());
 355   }
 356   C-&gt;gvn_replace_by(call, C-&gt;top());
 357 }
 358 
 359 void StringConcat::eliminate_initialize(InitializeNode* init) {
 360   Compile* C = _stringopts-&gt;C;
 361 
 362   // Eliminate Initialize node.
 363   assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
 364   assert(init-&gt;req() &lt;= InitializeNode::RawStores, &quot;no pending inits&quot;);
 365   Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
 366   if (ctrl_proj != NULL) {
 367     C-&gt;gvn_replace_by(ctrl_proj, init-&gt;in(TypeFunc::Control));
 368   }
 369   Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
 370   if (mem_proj != NULL) {
 371     Node *mem = init-&gt;in(TypeFunc::Memory);
 372     C-&gt;gvn_replace_by(mem_proj, mem);
 373   }
 374   C-&gt;gvn_replace_by(init, C-&gt;top());
 375   init-&gt;disconnect_inputs(NULL, C);
 376 }
 377 
 378 Node_List PhaseStringOpts::collect_toString_calls() {
 379   Node_List string_calls;
 380   Node_List worklist;
 381 
 382   _visited.clear();
 383 
 384   // Prime the worklist
 385   for (uint i = 1; i &lt; C-&gt;root()-&gt;len(); i++) {
 386     Node* n = C-&gt;root()-&gt;in(i);
 387     if (n != NULL &amp;&amp; !_visited.test_set(n-&gt;_idx)) {
 388       worklist.push(n);
 389     }
 390   }
 391 
 392   while (worklist.size() &gt; 0) {
 393     Node* ctrl = worklist.pop();
 394     if (StringConcat::is_SB_toString(ctrl)) {
 395       CallStaticJavaNode* csj = ctrl-&gt;as_CallStaticJava();
 396       string_calls.push(csj);
 397     }
 398     if (ctrl-&gt;in(0) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(0)-&gt;_idx)) {
 399       worklist.push(ctrl-&gt;in(0));
 400     }
 401     if (ctrl-&gt;is_Region()) {
 402       for (uint i = 1; i &lt; ctrl-&gt;len(); i++) {
 403         if (ctrl-&gt;in(i) != NULL &amp;&amp; !_visited.test_set(ctrl-&gt;in(i)-&gt;_idx)) {
 404           worklist.push(ctrl-&gt;in(i));
 405         }
 406       }
 407     }
 408   }
 409   return string_calls;
 410 }
 411 
 412 
 413 StringConcat* PhaseStringOpts::build_candidate(CallStaticJavaNode* call) {
 414   ciMethod* m = call-&gt;method();
 415   ciSymbol* string_sig;
 416   ciSymbol* int_sig;
 417   ciSymbol* char_sig;
 418   if (m-&gt;holder() == C-&gt;env()-&gt;StringBuilder_klass()) {
 419     string_sig = ciSymbol::String_StringBuilder_signature();
 420     int_sig = ciSymbol::int_StringBuilder_signature();
 421     char_sig = ciSymbol::char_StringBuilder_signature();
 422   } else if (m-&gt;holder() == C-&gt;env()-&gt;StringBuffer_klass()) {
 423     string_sig = ciSymbol::String_StringBuffer_signature();
 424     int_sig = ciSymbol::int_StringBuffer_signature();
 425     char_sig = ciSymbol::char_StringBuffer_signature();
 426   } else {
 427     return NULL;
 428   }
 429 #ifndef PRODUCT
 430   if (PrintOptimizeStringConcat) {
 431     tty-&gt;print(&quot;considering toString call in &quot;);
 432     call-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 433   }
 434 #endif
 435 
 436   StringConcat* sc = new StringConcat(this, call);
 437 
 438   AllocateNode* alloc = NULL;
 439   InitializeNode* init = NULL;
 440 
 441   // possible opportunity for StringBuilder fusion
 442   CallStaticJavaNode* cnode = call;
 443   while (cnode) {
 444     Node* recv = cnode-&gt;in(TypeFunc::Parms)-&gt;uncast();
 445     if (recv-&gt;is_Proj()) {
 446       recv = recv-&gt;in(0);
 447     }
 448     cnode = recv-&gt;isa_CallStaticJava();
 449     if (cnode == NULL) {
 450       alloc = recv-&gt;isa_Allocate();
 451       if (alloc == NULL) {
 452         break;
 453       }
 454       // Find the constructor call
 455       Node* result = alloc-&gt;result_cast();
 456       if (result == NULL || !result-&gt;is_CheckCastPP() || alloc-&gt;in(TypeFunc::Memory)-&gt;is_top()) {
 457         // strange looking allocation
 458 #ifndef PRODUCT
 459         if (PrintOptimizeStringConcat) {
 460           tty-&gt;print(&quot;giving up because allocation looks strange &quot;);
 461           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 462         }
 463 #endif
 464         break;
 465       }
 466       Node* constructor = NULL;
 467       for (SimpleDUIterator i(result); i.has_next(); i.next()) {
 468         CallStaticJavaNode *use = i.get()-&gt;isa_CallStaticJava();
 469         if (use != NULL &amp;&amp;
 470             use-&gt;method() != NULL &amp;&amp;
 471             !use-&gt;method()-&gt;is_static() &amp;&amp;
 472             use-&gt;method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
 473             use-&gt;method()-&gt;holder() == m-&gt;holder()) {
 474           // Matched the constructor.
 475           ciSymbol* sig = use-&gt;method()-&gt;signature()-&gt;as_symbol();
 476           if (sig == ciSymbol::void_method_signature() ||
 477               sig == ciSymbol::int_void_signature() ||
 478               sig == ciSymbol::string_void_signature()) {
 479             if (sig == ciSymbol::string_void_signature()) {
 480               // StringBuilder(String) so pick this up as the first argument
 481               assert(use-&gt;in(TypeFunc::Parms + 1) != NULL, &quot;what?&quot;);
 482               const Type* type = _gvn-&gt;type(use-&gt;in(TypeFunc::Parms + 1));
 483               if (type == TypePtr::NULL_PTR) {
 484                 // StringBuilder(null) throws exception.
 485 #ifndef PRODUCT
 486                 if (PrintOptimizeStringConcat) {
 487                   tty-&gt;print(&quot;giving up because StringBuilder(null) throws exception&quot;);
 488                   alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 489                 }
 490 #endif
 491                 return NULL;
 492               }
 493               // StringBuilder(str) argument needs null check.
 494               sc-&gt;push_string_null_check(use-&gt;in(TypeFunc::Parms + 1));
 495             }
 496             // The int variant takes an initial size for the backing
 497             // array so just treat it like the void version.
 498             constructor = use;
 499           } else {
 500 #ifndef PRODUCT
 501             if (PrintOptimizeStringConcat) {
 502               tty-&gt;print(&quot;unexpected constructor signature: %s&quot;, sig-&gt;as_utf8());
 503             }
 504 #endif
 505           }
 506           break;
 507         }
 508       }
 509       if (constructor == NULL) {
 510         // couldn&#39;t find constructor
 511 #ifndef PRODUCT
 512         if (PrintOptimizeStringConcat) {
 513           tty-&gt;print(&quot;giving up because couldn&#39;t find constructor &quot;);
 514           alloc-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 515         }
 516 #endif
 517         break;
 518       }
 519 
 520       // Walked all the way back and found the constructor call so see
 521       // if this call converted into a direct string concatenation.
 522       sc-&gt;add_control(call);
 523       sc-&gt;add_control(constructor);
 524       sc-&gt;add_control(alloc);
 525       sc-&gt;set_allocation(alloc);
 526       sc-&gt;add_constructor(constructor);
 527       if (sc-&gt;validate_control_flow() &amp;&amp; sc-&gt;validate_mem_flow()) {
 528         return sc;
 529       } else {
 530         return NULL;
 531       }
 532     } else if (cnode-&gt;method() == NULL) {
 533       break;
 534     } else if (!cnode-&gt;method()-&gt;is_static() &amp;&amp;
 535                cnode-&gt;method()-&gt;holder() == m-&gt;holder() &amp;&amp;
 536                cnode-&gt;method()-&gt;name() == ciSymbol::append_name() &amp;&amp;
 537                (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == string_sig ||
 538                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig ||
 539                 cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig)) {
 540       sc-&gt;add_control(cnode);
 541       Node* arg = cnode-&gt;in(TypeFunc::Parms + 1);
 542       if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == int_sig) {
 543         sc-&gt;push_int(arg);
 544       } else if (cnode-&gt;method()-&gt;signature()-&gt;as_symbol() == char_sig) {
 545         sc-&gt;push_char(arg);
 546       } else {
 547         if (arg-&gt;is_Proj() &amp;&amp; arg-&gt;in(0)-&gt;is_CallStaticJava()) {
 548           CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 549           if (csj-&gt;method() != NULL &amp;&amp;
 550               csj-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_Integer_toString &amp;&amp;
 551               arg-&gt;outcnt() == 1) {
 552             // _control is the list of StringBuilder calls nodes which
 553             // will be replaced by new String code after this optimization.
 554             // Integer::toString() call is not part of StringBuilder calls
 555             // chain. It could be eliminated only if its result is used
 556             // only by this SB calls chain.
 557             // Another limitation: it should be used only once because
 558             // it is unknown that it is used only by this SB calls chain
 559             // until all related SB calls nodes are collected.
 560             assert(arg-&gt;unique_out() == cnode, &quot;sanity&quot;);
 561             sc-&gt;add_control(csj);
 562             sc-&gt;push_int(csj-&gt;in(TypeFunc::Parms));
 563             continue;
 564           }
 565         }
 566         sc-&gt;push_string(arg);
 567       }
 568       continue;
 569     } else {
 570       // some unhandled signature
 571 #ifndef PRODUCT
 572       if (PrintOptimizeStringConcat) {
 573         tty-&gt;print(&quot;giving up because encountered unexpected signature &quot;);
 574         cnode-&gt;tf()-&gt;dump(); tty-&gt;cr();
 575         cnode-&gt;in(TypeFunc::Parms + 1)-&gt;dump();
 576       }
 577 #endif
 578       break;
 579     }
 580   }
 581   return NULL;
 582 }
 583 
 584 
 585 PhaseStringOpts::PhaseStringOpts(PhaseGVN* gvn, Unique_Node_List*):
 586   Phase(StringOpts),
 587   _gvn(gvn),
 588   _visited(Thread::current()-&gt;resource_area()) {
 589 
 590   assert(OptimizeStringConcat, &quot;shouldn&#39;t be here&quot;);
 591 
 592   size_table_field = C-&gt;env()-&gt;Integer_klass()-&gt;get_field_by_name(ciSymbol::make(&quot;sizeTable&quot;),
 593                                                                   ciSymbol::make(&quot;[I&quot;), true);
 594   if (size_table_field == NULL) {
 595     // Something wrong so give up.
 596     assert(false, &quot;why can&#39;t we find Integer.sizeTable?&quot;);
 597     return;
 598   }
 599 
 600   // Collect the types needed to talk about the various slices of memory
 601   byte_adr_idx = C-&gt;get_alias_index(TypeAryPtr::BYTES);
 602 
 603   // For each locally allocated StringBuffer see if the usages can be
 604   // collapsed into a single String construction.
 605 
 606   // Run through the list of allocation looking for SB.toString to see
 607   // if it&#39;s possible to fuse the usage of the SB into a single String
 608   // construction.
 609   GrowableArray&lt;StringConcat*&gt; concats;
 610   Node_List toStrings = collect_toString_calls();
 611   while (toStrings.size() &gt; 0) {
 612     StringConcat* sc = build_candidate(toStrings.pop()-&gt;as_CallStaticJava());
 613     if (sc != NULL) {
 614       concats.push(sc);
 615     }
 616   }
 617 
 618   // try to coalesce separate concats
 619  restart:
 620   for (int c = 0; c &lt; concats.length(); c++) {
 621     StringConcat* sc = concats.at(c);
 622     for (int i = 0; i &lt; sc-&gt;num_arguments(); i++) {
 623       Node* arg = sc-&gt;argument_uncast(i);
 624       if (arg-&gt;is_Proj() &amp;&amp; StringConcat::is_SB_toString(arg-&gt;in(0))) {
 625         CallStaticJavaNode* csj = arg-&gt;in(0)-&gt;as_CallStaticJava();
 626         for (int o = 0; o &lt; concats.length(); o++) {
 627           if (c == o) continue;
 628           StringConcat* other = concats.at(o);
 629           if (other-&gt;end() == csj) {
 630 #ifndef PRODUCT
 631             if (PrintOptimizeStringConcat) {
 632               tty-&gt;print_cr(&quot;considering stacked concats&quot;);
 633             }
 634 #endif
 635 
 636             StringConcat* merged = sc-&gt;merge(other, arg);
 637             if (merged-&gt;validate_control_flow() &amp;&amp; merged-&gt;validate_mem_flow()) {
 638 #ifndef PRODUCT
 639               if (PrintOptimizeStringConcat) {
 640                 tty-&gt;print_cr(&quot;stacking would succeed&quot;);
 641               }
 642 #endif
 643               if (c &lt; o) {
 644                 concats.remove_at(o);
 645                 concats.at_put(c, merged);
 646               } else {
 647                 concats.remove_at(c);
 648                 concats.at_put(o, merged);
 649               }
 650               goto restart;
 651             } else {
 652 #ifndef PRODUCT
 653               if (PrintOptimizeStringConcat) {
 654                 tty-&gt;print_cr(&quot;stacking would fail&quot;);
 655               }
 656 #endif
 657             }
 658           }
 659         }
 660       }
 661     }
 662   }
 663 
 664 
 665   for (int c = 0; c &lt; concats.length(); c++) {
 666     StringConcat* sc = concats.at(c);
 667     replace_string_concat(sc);
 668   }
 669 
 670   remove_dead_nodes();
 671 }
 672 
 673 void PhaseStringOpts::record_dead_node(Node* dead) {
 674   dead_worklist.push(dead);
 675 }
 676 
 677 void PhaseStringOpts::remove_dead_nodes() {
 678   // Delete any dead nodes to make things clean enough that escape
 679   // analysis doesn&#39;t get unhappy.
 680   while (dead_worklist.size() &gt; 0) {
 681     Node* use = dead_worklist.pop();
 682     int opc = use-&gt;Opcode();
 683     switch (opc) {
 684       case Op_Region: {
 685         uint i = 1;
 686         for (i = 1; i &lt; use-&gt;req(); i++) {
 687           if (use-&gt;in(i) != C-&gt;top()) {
 688             break;
 689           }
 690         }
 691         if (i &gt;= use-&gt;req()) {
 692           for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 693             Node* m = i.get();
 694             if (m-&gt;is_Phi()) {
 695               dead_worklist.push(m);
 696             }
 697           }
 698           C-&gt;gvn_replace_by(use, C-&gt;top());
 699         }
 700         break;
 701       }
 702       case Op_AddP:
 703       case Op_CreateEx: {
 704         // Recurisvely clean up references to CreateEx so EA doesn&#39;t
 705         // get unhappy about the partially collapsed graph.
 706         for (SimpleDUIterator i(use); i.has_next(); i.next()) {
 707           Node* m = i.get();
 708           if (m-&gt;is_AddP()) {
 709             dead_worklist.push(m);
 710           }
 711         }
 712         C-&gt;gvn_replace_by(use, C-&gt;top());
 713         break;
 714       }
 715       case Op_Phi:
 716         if (use-&gt;in(0) == C-&gt;top()) {
 717           C-&gt;gvn_replace_by(use, C-&gt;top());
 718         }
 719         break;
 720     }
 721   }
 722 }
 723 
 724 
 725 bool StringConcat::validate_mem_flow() {
 726   Compile* C = _stringopts-&gt;C;
 727 
 728   for (uint i = 0; i &lt; _control.size(); i++) {
 729 #ifndef PRODUCT
 730     Node_List path;
 731 #endif
 732     Node* curr = _control.at(i);
 733     if (curr-&gt;is_Call() &amp;&amp; curr != _begin) { // For all calls except the first allocation
 734       // Now here&#39;s the main invariant in our case:
 735       // For memory between the constructor, and appends, and toString we should only see bottom memory,
 736       // produced by the previous call we know about.
 737       if (!_constructors.contains(curr)) {
 738         NOT_PRODUCT(path.push(curr);)
 739         Node* mem = curr-&gt;in(TypeFunc::Memory);
 740         assert(mem != NULL, &quot;calls should have memory edge&quot;);
 741         assert(!mem-&gt;is_Phi(), &quot;should be handled by control flow validation&quot;);
 742         NOT_PRODUCT(path.push(mem);)
 743         while (mem-&gt;is_MergeMem()) {
 744           for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 745             if (i != Compile::AliasIdxBot &amp;&amp; mem-&gt;in(i) != C-&gt;top()) {
 746 #ifndef PRODUCT
 747               if (PrintOptimizeStringConcat) {
 748                 tty-&gt;print(&quot;fusion has incorrect memory flow (side effects) for &quot;);
 749                 _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 750                 path.dump();
 751               }
 752 #endif
 753               return false;
 754             }
 755           }
 756           // skip through a potential MergeMem chain, linked through Bot
 757           mem = mem-&gt;in(Compile::AliasIdxBot);
 758           NOT_PRODUCT(path.push(mem);)
 759         }
 760         // now let it fall through, and see if we have a projection
 761         if (mem-&gt;is_Proj()) {
 762           // Should point to a previous known call
 763           Node *prev = mem-&gt;in(0);
 764           NOT_PRODUCT(path.push(prev);)
 765           if (!prev-&gt;is_Call() || !_control.contains(prev)) {
 766 #ifndef PRODUCT
 767             if (PrintOptimizeStringConcat) {
 768               tty-&gt;print(&quot;fusion has incorrect memory flow (unknown call) for &quot;);
 769               _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 770               path.dump();
 771             }
 772 #endif
 773             return false;
 774           }
 775         } else {
 776           assert(mem-&gt;is_Store() || mem-&gt;is_LoadStore(), &quot;unexpected node type: %s&quot;, mem-&gt;Name());
 777 #ifndef PRODUCT
 778           if (PrintOptimizeStringConcat) {
 779             tty-&gt;print(&quot;fusion has incorrect memory flow (unexpected source) for &quot;);
 780             _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 781             path.dump();
 782           }
 783 #endif
 784           return false;
 785         }
 786       } else {
 787         // For memory that feeds into constructors it&#39;s more complicated.
 788         // However the advantage is that any side effect that happens between the Allocate/Initialize and
 789         // the constructor will have to be control-dependent on Initialize.
 790         // So we actually don&#39;t have to do anything, since it&#39;s going to be caught by the control flow
 791         // analysis.
 792 #ifdef ASSERT
 793         // Do a quick verification of the control pattern between the constructor and the initialize node
 794         assert(curr-&gt;is_Call(), &quot;constructor should be a call&quot;);
 795         // Go up the control starting from the constructor call
 796         Node* ctrl = curr-&gt;in(0);
 797         IfNode* iff = NULL;
 798         RegionNode* copy = NULL;
 799 
 800         while (true) {
 801           // skip known check patterns
 802           if (ctrl-&gt;is_Region()) {
 803             if (ctrl-&gt;as_Region()-&gt;is_copy()) {
 804               copy = ctrl-&gt;as_Region();
 805               ctrl = copy-&gt;is_copy();
 806             } else { // a cast
 807               assert(ctrl-&gt;req() == 3 &amp;&amp;
 808                      ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 809                      ctrl-&gt;in(2) != NULL &amp;&amp; ctrl-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 810                      ctrl-&gt;in(1)-&gt;in(0) == ctrl-&gt;in(2)-&gt;in(0) &amp;&amp;
 811                      ctrl-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ctrl-&gt;in(1)-&gt;in(0)-&gt;is_If(),
 812                      &quot;must be a simple diamond&quot;);
 813               Node* true_proj = ctrl-&gt;in(1)-&gt;is_IfTrue() ? ctrl-&gt;in(1) : ctrl-&gt;in(2);
 814               for (SimpleDUIterator i(true_proj); i.has_next(); i.next()) {
 815                 Node* use = i.get();
 816                 assert(use == ctrl || use-&gt;is_ConstraintCast(),
 817                        &quot;unexpected user: %s&quot;, use-&gt;Name());
 818               }
 819 
 820               iff = ctrl-&gt;in(1)-&gt;in(0)-&gt;as_If();
 821               ctrl = iff-&gt;in(0);
 822             }
 823           } else if (ctrl-&gt;is_IfTrue()) { // null checks, class checks
 824             iff = ctrl-&gt;in(0)-&gt;as_If();
 825             // Verify that the other arm is an uncommon trap
 826             Node* otherproj = iff-&gt;proj_out(1 - ctrl-&gt;as_Proj()-&gt;_con);
 827             CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 828             assert(strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0, &quot;must be uncommon trap&quot;);
 829             ctrl = iff-&gt;in(0);
 830           } else {
 831             break;
 832           }
 833         }
 834 
 835         assert(ctrl-&gt;is_Proj(), &quot;must be a projection&quot;);
 836         assert(ctrl-&gt;in(0)-&gt;is_Initialize(), &quot;should be initialize&quot;);
 837         for (SimpleDUIterator i(ctrl); i.has_next(); i.next()) {
 838           Node* use = i.get();
 839           assert(use == copy || use == iff || use == curr || use-&gt;is_CheckCastPP() || use-&gt;is_Load(),
 840                  &quot;unexpected user: %s&quot;, use-&gt;Name());
 841         }
 842 #endif // ASSERT
 843       }
 844     }
 845   }
 846 
 847 #ifndef PRODUCT
 848   if (PrintOptimizeStringConcat) {
 849     tty-&gt;print(&quot;fusion has correct memory flow for &quot;);
 850     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
 851     tty-&gt;cr();
 852   }
 853 #endif
 854   return true;
 855 }
 856 
 857 bool StringConcat::validate_control_flow() {
 858   // We found all the calls and arguments now lets see if it&#39;s
 859   // safe to transform the graph as we would expect.
 860 
 861   // Check to see if this resulted in too many uncommon traps previously
 862   if (Compile::current()-&gt;too_many_traps(_begin-&gt;jvms()-&gt;method(), _begin-&gt;jvms()-&gt;bci(),
 863                         Deoptimization::Reason_intrinsic)) {
 864     return false;
 865   }
 866 
 867   // Walk backwards over the control flow from toString to the
 868   // allocation and make sure all the control flow is ok.  This
 869   // means it&#39;s either going to be eliminated once the calls are
 870   // removed or it can safely be transformed into an uncommon
 871   // trap.
 872 
 873   int null_check_count = 0;
 874   Unique_Node_List ctrl_path;
 875 
 876   assert(_control.contains(_begin), &quot;missing&quot;);
 877   assert(_control.contains(_end), &quot;missing&quot;);
 878 
 879   // Collect the nodes that we know about and will eliminate into ctrl_path
 880   for (uint i = 0; i &lt; _control.size(); i++) {
 881     // Push the call and it&#39;s control projection
 882     Node* n = _control.at(i);
 883     if (n-&gt;is_Allocate()) {
 884       AllocateNode* an = n-&gt;as_Allocate();
 885       InitializeNode* init = an-&gt;initialization();
 886       ctrl_path.push(init);
 887       ctrl_path.push(init-&gt;as_Multi()-&gt;proj_out(0));
 888     }
 889     if (n-&gt;is_Call()) {
 890       CallNode* cn = n-&gt;as_Call();
 891       ctrl_path.push(cn);
 892       ctrl_path.push(cn-&gt;proj_out(0));
 893       ctrl_path.push(cn-&gt;proj_out(0)-&gt;unique_out());
 894       Node* catchproj = cn-&gt;proj_out(0)-&gt;unique_out()-&gt;as_Catch()-&gt;proj_out_or_null(0);
 895       if (catchproj != NULL) {
 896         ctrl_path.push(catchproj);
 897       }
 898     } else {
 899       ShouldNotReachHere();
 900     }
 901   }
 902 
 903   // Skip backwards through the control checking for unexpected control flow
 904   Node* ptr = _end;
 905   bool fail = false;
 906   while (ptr != _begin) {
 907     if (ptr-&gt;is_Call() &amp;&amp; ctrl_path.member(ptr)) {
 908       ptr = ptr-&gt;in(0);
 909     } else if (ptr-&gt;is_CatchProj() &amp;&amp; ctrl_path.member(ptr)) {
 910       ptr = ptr-&gt;in(0)-&gt;in(0)-&gt;in(0);
 911       assert(ctrl_path.member(ptr), &quot;should be a known piece of control&quot;);
 912     } else if (ptr-&gt;is_IfTrue()) {
 913       IfNode* iff = ptr-&gt;in(0)-&gt;as_If();
 914       BoolNode* b = iff-&gt;in(1)-&gt;isa_Bool();
 915 
 916       if (b == NULL) {
 917 #ifndef PRODUCT
 918         if (PrintOptimizeStringConcat) {
 919           tty-&gt;print_cr(&quot;unexpected input to IfNode&quot;);
 920           iff-&gt;in(1)-&gt;dump();
 921           tty-&gt;cr();
 922         }
 923 #endif
 924         fail = true;
 925         break;
 926       }
 927 
 928       Node* cmp = b-&gt;in(1);
 929       Node* v1 = cmp-&gt;in(1);
 930       Node* v2 = cmp-&gt;in(2);
 931       Node* otherproj = iff-&gt;proj_out(1 - ptr-&gt;as_Proj()-&gt;_con);
 932 
 933       // Null check of the return of append which can simply be eliminated
 934       if (b-&gt;_test._test == BoolTest::ne &amp;&amp;
 935           v2-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;
 936           v1-&gt;is_Proj() &amp;&amp; ctrl_path.member(v1-&gt;in(0))) {
 937         // NULL check of the return value of the append
 938         null_check_count++;
 939         if (otherproj-&gt;outcnt() == 1) {
 940           CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 941           if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 942             ctrl_path.push(call);
 943           }
 944         }
 945         _control.push(ptr);
 946         ptr = ptr-&gt;in(0)-&gt;in(0);
 947         continue;
 948       }
 949 
 950       // A test which leads to an uncommon trap which should be safe.
 951       // Later this trap will be converted into a trap that restarts
 952       // at the beginning.
 953       if (otherproj-&gt;outcnt() == 1) {
 954         CallStaticJavaNode* call = otherproj-&gt;unique_out()-&gt;isa_CallStaticJava();
 955         if (call != NULL &amp;&amp; call-&gt;_name != NULL &amp;&amp; strcmp(call-&gt;_name, &quot;uncommon_trap&quot;) == 0) {
 956           // control flow leads to uct so should be ok
 957           _uncommon_traps.push(call);
 958           ctrl_path.push(call);
 959           ptr = ptr-&gt;in(0)-&gt;in(0);
 960           continue;
 961         }
 962       }
 963 
 964 #ifndef PRODUCT
 965       // Some unexpected control flow we don&#39;t know how to handle.
 966       if (PrintOptimizeStringConcat) {
 967         tty-&gt;print_cr(&quot;failing with unknown test&quot;);
 968         b-&gt;dump();
 969         cmp-&gt;dump();
 970         v1-&gt;dump();
 971         v2-&gt;dump();
 972         tty-&gt;cr();
 973       }
 974 #endif
 975       fail = true;
 976       break;
 977     } else if (ptr-&gt;is_Proj() &amp;&amp; ptr-&gt;in(0)-&gt;is_Initialize()) {
 978       ptr = ptr-&gt;in(0)-&gt;in(0);
 979     } else if (ptr-&gt;is_Region()) {
 980       Node* copy = ptr-&gt;as_Region()-&gt;is_copy();
 981       if (copy != NULL) {
 982         ptr = copy;
 983         continue;
 984       }
 985       if (ptr-&gt;req() == 3 &amp;&amp;
 986           ptr-&gt;in(1) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;is_Proj() &amp;&amp;
 987           ptr-&gt;in(2) != NULL &amp;&amp; ptr-&gt;in(2)-&gt;is_Proj() &amp;&amp;
 988           ptr-&gt;in(1)-&gt;in(0) == ptr-&gt;in(2)-&gt;in(0) &amp;&amp;
 989           ptr-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ptr-&gt;in(1)-&gt;in(0)-&gt;is_If()) {
 990         // Simple diamond.
 991         // XXX should check for possibly merging stores.  simple data merges are ok.
 992         // The IGVN will make this simple diamond go away when it
 993         // transforms the Region. Make sure it sees it.
 994         Compile::current()-&gt;record_for_igvn(ptr);
 995         ptr = ptr-&gt;in(1)-&gt;in(0)-&gt;in(0);
 996         continue;
 997       }
 998 #ifndef PRODUCT
 999       if (PrintOptimizeStringConcat) {
1000         tty-&gt;print_cr(&quot;fusion would fail for region&quot;);
1001         _begin-&gt;dump();
1002         ptr-&gt;dump(2);
1003       }
1004 #endif
1005       fail = true;
1006       break;
1007     } else {
1008       // other unknown control
1009       if (!fail) {
1010 #ifndef PRODUCT
1011         if (PrintOptimizeStringConcat) {
1012           tty-&gt;print_cr(&quot;fusion would fail for&quot;);
1013           _begin-&gt;dump();
1014         }
1015 #endif
1016         fail = true;
1017       }
1018 #ifndef PRODUCT
1019       if (PrintOptimizeStringConcat) {
1020         ptr-&gt;dump();
1021       }
1022 #endif
1023       ptr = ptr-&gt;in(0);
1024     }
1025   }
1026 #ifndef PRODUCT
1027   if (PrintOptimizeStringConcat &amp;&amp; fail) {
1028     tty-&gt;cr();
1029   }
1030 #endif
1031   if (fail) return !fail;
1032 
1033   // Validate that all these results produced are contained within
1034   // this cluster of objects.  First collect all the results produced
1035   // by calls in the region.
1036   _stringopts-&gt;_visited.clear();
1037   Node_List worklist;
1038   Node* final_result = _end-&gt;proj_out_or_null(TypeFunc::Parms);
1039   for (uint i = 0; i &lt; _control.size(); i++) {
1040     CallNode* cnode = _control.at(i)-&gt;isa_Call();
1041     if (cnode != NULL) {
1042       _stringopts-&gt;_visited.test_set(cnode-&gt;_idx);
1043     }
1044     Node* result = cnode != NULL ? cnode-&gt;proj_out_or_null(TypeFunc::Parms) : NULL;
1045     if (result != NULL &amp;&amp; result != final_result) {
1046       worklist.push(result);
1047     }
1048   }
1049 
1050   Node* last_result = NULL;
1051   while (worklist.size() &gt; 0) {
1052     Node* result = worklist.pop();
1053     if (_stringopts-&gt;_visited.test_set(result-&gt;_idx))
1054       continue;
1055     for (SimpleDUIterator i(result); i.has_next(); i.next()) {
1056       Node *use = i.get();
1057       if (ctrl_path.member(use)) {
1058         // already checked this
1059         continue;
1060       }
1061       int opc = use-&gt;Opcode();
1062       if (opc == Op_CmpP || opc == Op_Node) {
1063         ctrl_path.push(use);
1064         continue;
1065       }
1066       if (opc == Op_CastPP || opc == Op_CheckCastPP) {
1067         for (SimpleDUIterator j(use); j.has_next(); j.next()) {
1068           worklist.push(j.get());
1069         }
1070         worklist.push(use-&gt;in(1));
1071         ctrl_path.push(use);
1072         continue;
1073       }
1074 #ifndef PRODUCT
1075       if (PrintOptimizeStringConcat) {
1076         if (result != last_result) {
1077           last_result = result;
1078           tty-&gt;print_cr(&quot;extra uses for result:&quot;);
1079           last_result-&gt;dump();
1080         }
1081         use-&gt;dump();
1082       }
1083 #endif
1084       fail = true;
1085       break;
1086     }
1087   }
1088 
1089 #ifndef PRODUCT
1090   if (PrintOptimizeStringConcat &amp;&amp; !fail) {
1091     ttyLocker ttyl;
1092     tty-&gt;cr();
1093     tty-&gt;print(&quot;fusion has correct control flow (%d %d) for &quot;, null_check_count, _uncommon_traps.size());
1094     _begin-&gt;jvms()-&gt;dump_spec(tty); tty-&gt;cr();
1095     for (int i = 0; i &lt; num_arguments(); i++) {
1096       argument(i)-&gt;dump();
1097     }
1098     _control.dump();
1099     tty-&gt;cr();
1100   }
1101 #endif
1102 
1103   return !fail;
1104 }
1105 
1106 Node* PhaseStringOpts::fetch_static_field(GraphKit&amp; kit, ciField* field) {
1107   const TypeInstPtr* mirror_type = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1108   Node* klass_node = __ makecon(mirror_type);
1109   BasicType bt = field-&gt;layout_type();
1110   ciType* field_klass = field-&gt;type();
1111 
1112   const Type *type;
1113   if( bt == T_OBJECT ) {
1114     if (!field-&gt;type()-&gt;is_loaded()) {
1115       type = TypeInstPtr::BOTTOM;
1116     } else if (field-&gt;is_static_constant()) {
1117       // This can happen if the constant oop is non-perm.
1118       ciObject* con = field-&gt;constant_value().as_object();
1119       // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
1120       // and may yield a vacuous result if the field is of interface type.
1121       type = TypeOopPtr::make_from_constant(con, true)-&gt;isa_oopptr();
1122       assert(type != NULL, &quot;field singleton type must be consistent&quot;);
1123       return __ makecon(type);
1124     } else {
1125       type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
1126     }
1127   } else {
1128     type = Type::get_const_basic_type(bt);
1129   }
1130 
1131   return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field-&gt;offset_in_bytes()),
1132                        type, T_OBJECT,
1133                        C-&gt;get_alias_index(mirror_type-&gt;add_offset(field-&gt;offset_in_bytes())),
1134                        MemNode::unordered);
1135 }
1136 
1137 Node* PhaseStringOpts::int_stringSize(GraphKit&amp; kit, Node* arg) {
1138   if (arg-&gt;is_Con()) {
1139     // Constant integer. Compute constant length using Integer.sizeTable
1140     int arg_val = arg-&gt;get_int();
1141     int count = 1;
1142     if (arg_val &lt; 0) {
1143       arg_val = -arg_val;
1144       count++;
1145     }
1146 
1147     ciArray* size_table = (ciArray*)size_table_field-&gt;constant_value().as_object();
1148     for (int i = 0; i &lt; size_table-&gt;length(); i++) {
1149       if (arg_val &lt;= size_table-&gt;element_value(i).as_int()) {
1150         count += i;
1151         break;
1152       }
1153     }
1154     return __ intcon(count);
1155   }
1156 
1157   RegionNode *final_merge = new RegionNode(3);
1158   kit.gvn().set_type(final_merge, Type::CONTROL);
1159   Node* final_size = new PhiNode(final_merge, TypeInt::INT);
1160   kit.gvn().set_type(final_size, TypeInt::INT);
1161 
1162   IfNode* iff = kit.create_and_map_if(kit.control(),
1163                                       __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1164                                       PROB_FAIR, COUNT_UNKNOWN);
1165   Node* is_min = __ IfFalse(iff);
1166   final_merge-&gt;init_req(1, is_min);
1167   final_size-&gt;init_req(1, __ intcon(11));
1168 
1169   kit.set_control(__ IfTrue(iff));
1170   if (kit.stopped()) {
1171     final_merge-&gt;init_req(2, C-&gt;top());
1172     final_size-&gt;init_req(2, C-&gt;top());
1173   } else {
1174 
1175     // int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);
1176     RegionNode *r = new RegionNode(3);
1177     kit.gvn().set_type(r, Type::CONTROL);
1178     Node *phi = new PhiNode(r, TypeInt::INT);
1179     kit.gvn().set_type(phi, TypeInt::INT);
1180     Node *size = new PhiNode(r, TypeInt::INT);
1181     kit.gvn().set_type(size, TypeInt::INT);
1182     Node* chk = __ CmpI(arg, __ intcon(0));
1183     Node* p = __ Bool(chk, BoolTest::lt);
1184     IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);
1185     Node* lessthan = __ IfTrue(iff);
1186     Node* greaterequal = __ IfFalse(iff);
1187     r-&gt;init_req(1, lessthan);
1188     phi-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1189     size-&gt;init_req(1, __ intcon(1));
1190     r-&gt;init_req(2, greaterequal);
1191     phi-&gt;init_req(2, arg);
1192     size-&gt;init_req(2, __ intcon(0));
1193     kit.set_control(r);
1194     C-&gt;record_for_igvn(r);
1195     C-&gt;record_for_igvn(phi);
1196     C-&gt;record_for_igvn(size);
1197 
1198     // for (int i=0; ; i++)
1199     //   if (x &lt;= sizeTable[i])
1200     //     return i+1;
1201 
1202     // Add loop predicate first.
1203     kit.add_predicate();
1204 
1205     RegionNode *loop = new RegionNode(3);
1206     loop-&gt;init_req(1, kit.control());
1207     kit.gvn().set_type(loop, Type::CONTROL);
1208 
1209     Node *index = new PhiNode(loop, TypeInt::INT);
1210     index-&gt;init_req(1, __ intcon(0));
1211     kit.gvn().set_type(index, TypeInt::INT);
1212     kit.set_control(loop);
1213     Node* sizeTable = fetch_static_field(kit, size_table_field);
1214 
1215     Node* value = kit.load_array_element(NULL, sizeTable, index, TypeAryPtr::INTS);
1216     C-&gt;record_for_igvn(value);
1217     Node* limit = __ CmpI(phi, value);
1218     Node* limitb = __ Bool(limit, BoolTest::le);
1219     IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);
1220     Node* lessEqual = __ IfTrue(iff2);
1221     Node* greater = __ IfFalse(iff2);
1222 
1223     loop-&gt;init_req(2, greater);
1224     index-&gt;init_req(2, __ AddI(index, __ intcon(1)));
1225 
1226     kit.set_control(lessEqual);
1227     C-&gt;record_for_igvn(loop);
1228     C-&gt;record_for_igvn(index);
1229 
1230     final_merge-&gt;init_req(2, kit.control());
1231     final_size-&gt;init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));
1232   }
1233 
1234   kit.set_control(final_merge);
1235   C-&gt;record_for_igvn(final_merge);
1236   C-&gt;record_for_igvn(final_size);
1237 
1238   return final_size;
1239 }
1240 
1241 // Simplified version of Integer.getChars
1242 void PhaseStringOpts::getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, BasicType bt, Node* end, Node* final_merge, Node* final_mem, int merge_index) {
1243   // if (i &lt; 0) {
1244   //     sign = &#39;-&#39;;
1245   //     i = -i;
1246   // }
1247   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::lt),
1248                                       PROB_FAIR, COUNT_UNKNOWN);
1249 
1250   RegionNode* merge = new RegionNode(3);
1251   kit.gvn().set_type(merge, Type::CONTROL);
1252   Node* i = new PhiNode(merge, TypeInt::INT);
1253   kit.gvn().set_type(i, TypeInt::INT);
1254   Node* sign = new PhiNode(merge, TypeInt::INT);
1255   kit.gvn().set_type(sign, TypeInt::INT);
1256 
1257   merge-&gt;init_req(1, __ IfTrue(iff));
1258   i-&gt;init_req(1, __ SubI(__ intcon(0), arg));
1259   sign-&gt;init_req(1, __ intcon(&#39;-&#39;));
1260   merge-&gt;init_req(2, __ IfFalse(iff));
1261   i-&gt;init_req(2, arg);
1262   sign-&gt;init_req(2, __ intcon(0));
1263 
1264   kit.set_control(merge);
1265 
1266   C-&gt;record_for_igvn(merge);
1267   C-&gt;record_for_igvn(i);
1268   C-&gt;record_for_igvn(sign);
1269 
1270   // for (;;) {
1271   //     q = i / 10;
1272   //     r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1));  // r = i-(q*10) ...
1273   //     buf [--charPos] = digits [r];
1274   //     i = q;
1275   //     if (i == 0) break;
1276   // }
1277 
1278   // Add loop predicate first.
1279   kit.add_predicate();
1280 
1281   RegionNode* head = new RegionNode(3);
1282   head-&gt;init_req(1, kit.control());
1283 
1284   kit.gvn().set_type(head, Type::CONTROL);
1285   Node* i_phi = new PhiNode(head, TypeInt::INT);
1286   i_phi-&gt;init_req(1, i);
1287   kit.gvn().set_type(i_phi, TypeInt::INT);
1288   Node* charPos = new PhiNode(head, TypeInt::INT);
1289   charPos-&gt;init_req(1, end);
1290   kit.gvn().set_type(charPos, TypeInt::INT);
1291   Node* mem = PhiNode::make(head, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1292   kit.gvn().set_type(mem, Type::MEMORY);
1293 
1294   kit.set_control(head);
1295   kit.set_memory(mem, byte_adr_idx);
1296 
1297   Node* q = __ DivI(kit.null(), i_phi, __ intcon(10));
1298   Node* r = __ SubI(i_phi, __ AddI(__ LShiftI(q, __ intcon(3)),
1299                                    __ LShiftI(q, __ intcon(1))));
1300   Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1301   Node* ch = __ AddI(r, __ intcon(&#39;0&#39;));
1302   Node* st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1303                                 ch, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1304 
1305   iff = kit.create_and_map_if(head, __ Bool(__ CmpI(q, __ intcon(0)), BoolTest::ne),
1306                               PROB_FAIR, COUNT_UNKNOWN);
1307   Node* ne = __ IfTrue(iff);
1308   Node* eq = __ IfFalse(iff);
1309 
1310   head-&gt;init_req(2, ne);
1311   mem-&gt;init_req(2, st);
1312 
1313   i_phi-&gt;init_req(2, q);
1314   charPos-&gt;init_req(2, index);
1315   charPos = index;
1316 
1317   kit.set_control(eq);
1318   kit.set_memory(st, byte_adr_idx);
1319 
1320   C-&gt;record_for_igvn(head);
1321   C-&gt;record_for_igvn(mem);
1322   C-&gt;record_for_igvn(i_phi);
1323   C-&gt;record_for_igvn(charPos);
1324 
1325   // if (sign != 0) {
1326   //     buf [--charPos] = sign;
1327   // }
1328   iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(sign, __ intcon(0)), BoolTest::ne),
1329                               PROB_FAIR, COUNT_UNKNOWN);
1330 
1331   final_merge-&gt;init_req(merge_index + 2, __ IfFalse(iff));
1332   final_mem-&gt;init_req(merge_index + 2, kit.memory(byte_adr_idx));
1333 
1334   kit.set_control(__ IfTrue(iff));
1335   if (kit.stopped()) {
1336     final_merge-&gt;init_req(merge_index + 1, C-&gt;top());
1337     final_mem-&gt;init_req(merge_index + 1, C-&gt;top());
1338   } else {
1339     Node* index = __ SubI(charPos, __ intcon((bt == T_BYTE) ? 1 : 2));
1340     st = __ store_to_memory(kit.control(), kit.array_element_address(dst_array, index, T_BYTE),
1341                             sign, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) /* mismatched */);
1342 
1343     final_merge-&gt;init_req(merge_index + 1, kit.control());
1344     final_mem-&gt;init_req(merge_index + 1, st);
1345   }
1346 }
1347 
1348 // Copy the characters representing arg into dst_array starting at start
1349 Node* PhaseStringOpts::int_getChars(GraphKit&amp; kit, Node* arg, Node* dst_array, Node* dst_coder, Node* start, Node* size) {
1350   bool dcon = dst_coder-&gt;is_Con();
1351   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1352   Node* end = __ AddI(start, __ LShiftI(size, dst_coder));
1353 
1354   // The final_merge node has 4 entries in case the encoding is known:
1355   // (0) Control, (1) result w/ sign, (2) result w/o sign, (3) result for Integer.min_value
1356   // or 6 entries in case the encoding is not known:
1357   // (0) Control, (1) Latin1 w/ sign, (2) Latin1 w/o sign, (3) min_value, (4) UTF16 w/ sign, (5) UTF16 w/o sign
1358   RegionNode* final_merge = new RegionNode(dcon ? 4 : 6);
1359   kit.gvn().set_type(final_merge, Type::CONTROL);
1360 
1361   Node* final_mem = PhiNode::make(final_merge, kit.memory(byte_adr_idx), Type::MEMORY, TypeAryPtr::BYTES);
1362   kit.gvn().set_type(final_mem, Type::MEMORY);
1363 
1364   // need to handle arg == Integer.MIN_VALUE specially because negating doesn&#39;t make it positive
1365   IfNode* iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),
1366                                       PROB_FAIR, COUNT_UNKNOWN);
1367 
1368   Node* old_mem = kit.memory(byte_adr_idx);
1369 
1370   kit.set_control(__ IfFalse(iff));
1371   if (kit.stopped()) {
1372     // Statically not equal to MIN_VALUE so this path is dead
1373     final_merge-&gt;init_req(3, kit.control());
1374   } else {
1375     copy_string(kit, __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_min_jint_string())),
1376                 dst_array, dst_coder, start);
1377     final_merge-&gt;init_req(3, kit.control());
1378     final_mem-&gt;init_req(3, kit.memory(byte_adr_idx));
1379   }
1380 
1381   kit.set_control(__ IfTrue(iff));
1382   kit.set_memory(old_mem, byte_adr_idx);
1383 
1384   if (!dcon) {
1385     // Check encoding of destination
1386     iff = kit.create_and_map_if(kit.control(), __ Bool(__ CmpI(dst_coder, __ intcon(0)), BoolTest::eq),
1387                                 PROB_FAIR, COUNT_UNKNOWN);
1388     old_mem = kit.memory(byte_adr_idx);
1389   }
1390   if (!dcon || dbyte) {
1391     // Destination is Latin1,
1392     if (!dcon) {
1393       kit.set_control(__ IfTrue(iff));
1394     }
1395     getChars(kit, arg, dst_array, T_BYTE, end, final_merge, final_mem);
1396   }
1397   if (!dcon || !dbyte) {
1398     // Destination is UTF16
1399     int merge_index = 0;
1400     if (!dcon) {
1401       kit.set_control(__ IfFalse(iff));
1402       kit.set_memory(old_mem, byte_adr_idx);
1403       merge_index = 3; // Account for Latin1 case
1404     }
1405     getChars(kit, arg, dst_array, T_CHAR, end, final_merge, final_mem, merge_index);
1406   }
1407 
1408   // Final merge point for Latin1 and UTF16 case
1409   kit.set_control(final_merge);
1410   kit.set_memory(final_mem, byte_adr_idx);
1411 
1412   C-&gt;record_for_igvn(final_merge);
1413   C-&gt;record_for_igvn(final_mem);
1414   return end;
1415 }
1416 
1417 // Copy &#39;count&#39; bytes/chars from src_array to dst_array starting at index start
1418 void PhaseStringOpts::arraycopy(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, Node* dst_array, BasicType elembt, Node* start, Node* count) {
1419   assert(elembt == T_BYTE || elembt == T_CHAR, &quot;Invalid type for arraycopy&quot;);
1420 
1421   if (elembt == T_CHAR) {
1422     // Get number of chars
1423     count = __ RShiftI(count, __ intcon(1));
1424   }
1425 
1426   Node* extra = NULL;
1427 #ifdef _LP64
1428   count = __ ConvI2L(count);
1429   extra = C-&gt;top();
1430 #endif
1431 
1432   Node* src_ptr = __ array_element_address(src_array, __ intcon(0), T_BYTE);
1433   Node* dst_ptr = __ array_element_address(dst_array, start, T_BYTE);
1434   // Check if destination address is aligned to HeapWordSize
1435   const TypeInt* tdst = __ gvn().type(start)-&gt;is_int();
1436   bool aligned = tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);
1437   // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1438   const char* copyfunc_name = &quot;arraycopy&quot;;
1439   address     copyfunc_addr = StubRoutines::select_arraycopy_function(elembt, aligned, true, copyfunc_name, true);
1440   ideal.make_leaf_call_no_fp(OptoRuntime::fast_arraycopy_Type(), copyfunc_addr, copyfunc_name,
1441                              TypeAryPtr::BYTES, src_ptr, dst_ptr, count, extra);
1442 }
1443 
1444 #undef __
1445 #define __ ideal.
1446 
1447 // Copy contents of a Latin1 encoded string from src_array to dst_array
1448 void PhaseStringOpts::copy_latin1_string(GraphKit&amp; kit, IdealKit&amp; ideal, Node* src_array, IdealVariable&amp; count,
1449                                          Node* dst_array, Node* dst_coder, Node* start) {
1450   bool dcon = dst_coder-&gt;is_Con();
1451   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1452 
1453   if (!dcon) {
1454     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1455   }
1456   if (!dcon || dbyte) {
1457     // Destination is Latin1. Simply emit a byte arraycopy.
1458     arraycopy(kit, ideal, src_array, dst_array, T_BYTE, start, __ value(count));
1459   }
1460   if (!dcon) {
1461     __ else_();
1462   }
1463   if (!dcon || !dbyte) {
1464     // Destination is UTF16. Inflate src_array into dst_array.
1465     kit.sync_kit(ideal);
1466     if (Matcher::match_rule_supported(Op_StrInflatedCopy)) {
1467       // Use fast intrinsic
1468       Node* src = kit.array_element_address(src_array, kit.intcon(0), T_BYTE);
1469       Node* dst = kit.array_element_address(dst_array, start, T_BYTE);
1470       kit.inflate_string(src, dst, TypeAryPtr::BYTES, __ value(count));
1471     } else {
1472       // No intrinsic available, use slow method
1473       kit.inflate_string_slow(src_array, dst_array, start, __ value(count));
1474     }
1475     ideal.sync_kit(&amp;kit);
1476     // Multiply count by two since we now need two bytes per char
1477     __ set(count, __ LShiftI(__ value(count), __ ConI(1)));
1478   }
1479   if (!dcon) {
1480     __ end_if();
1481   }
1482 }
1483 
1484 // Read two bytes from index and index+1 and convert them to a char
1485 static jchar readChar(ciTypeArray* array, int index) {
1486   int shift_high, shift_low;
1487 #ifdef VM_LITTLE_ENDIAN
1488     shift_high = 0;
1489     shift_low = 8;
1490 #else
1491     shift_high = 8;
1492     shift_low = 0;
1493 #endif
1494 
1495   jchar b1 = ((jchar) array-&gt;byte_at(index)) &amp; 0xff;
1496   jchar b2 = ((jchar) array-&gt;byte_at(index+1)) &amp; 0xff;
1497   return (b1 &lt;&lt; shift_high) | (b2 &lt;&lt; shift_low);
1498 }
1499 
1500 // Copy contents of constant src_array to dst_array by emitting individual stores
1501 void PhaseStringOpts::copy_constant_string(GraphKit&amp; kit, IdealKit&amp; ideal, ciTypeArray* src_array, IdealVariable&amp; count,
1502                                            bool src_is_byte, Node* dst_array, Node* dst_coder, Node* start) {
1503   bool dcon = dst_coder-&gt;is_Con();
1504   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1505   int length = src_array-&gt;length();
1506 
1507   if (!dcon) {
1508     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1509   }
1510   if (!dcon || dbyte) {
1511     // Destination is Latin1. Copy each byte of src_array into dst_array.
1512     Node* index = start;
1513     for (int i = 0; i &lt; length; i++) {
1514       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1515       Node* val = __ ConI(src_array-&gt;byte_at(i));
1516       __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1517       index = __ AddI(index, __ ConI(1));
1518     }
1519   }
1520   if (!dcon) {
1521     __ else_();
1522   }
1523   if (!dcon || !dbyte) {
1524     // Destination is UTF16. Copy each char of src_array into dst_array.
1525     Node* index = start;
1526     for (int i = 0; i &lt; length; i++) {
1527       Node* adr = kit.array_element_address(dst_array, index, T_BYTE);
1528       jchar val;
1529       if (src_is_byte) {
1530         val = src_array-&gt;byte_at(i) &amp; 0xff;
1531       } else {
1532         val = readChar(src_array, i++);
1533       }
1534       __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1535       index = __ AddI(index, __ ConI(2));
1536     }
1537     if (src_is_byte) {
1538       // Multiply count by two since we now need two bytes per char
1539       __ set(count, __ ConI(2 * length));
1540     }
1541   }
1542   if (!dcon) {
1543     __ end_if();
1544   }
1545 }
1546 
1547 // Compress copy contents of the byte/char String str into dst_array starting at index start.
1548 Node* PhaseStringOpts::copy_string(GraphKit&amp; kit, Node* str, Node* dst_array, Node* dst_coder, Node* start) {
1549   Node* src_array = kit.load_String_value(str, true);
1550 
1551   IdealKit ideal(&amp;kit, true, true);
1552   IdealVariable count(ideal); __ declarations_done();
1553 
1554   if (str-&gt;is_Con()) {
1555     // Constant source string
1556     ciTypeArray* src_array_type = get_constant_value(kit, str);
1557 
1558     // Check encoding of constant string
1559     bool src_is_byte = (get_constant_coder(kit, str) == java_lang_String::CODER_LATIN1);
1560 
1561     // For small constant strings just emit individual stores.
1562     // A length of 6 seems like a good space/speed tradeof.
1563     __ set(count, __ ConI(src_array_type-&gt;length()));
1564     int src_len = src_array_type-&gt;length() / (src_is_byte ? 1 : 2);
1565     if (src_len &lt; unroll_string_copy_length) {
1566       // Small constant string
1567       copy_constant_string(kit, ideal, src_array_type, count, src_is_byte, dst_array, dst_coder, start);
1568     } else if (src_is_byte) {
1569       // Source is Latin1
1570       copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1571     } else {
1572       // Source is UTF16 (destination too). Simply emit a char arraycopy.
1573       arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1574     }
1575   } else {
1576     Node* size = kit.load_array_length(src_array);
1577     __ set(count, size);
1578     // Non-constant source string
1579     if (CompactStrings) {
1580       // Emit runtime check for coder
1581       Node* coder = kit.load_String_coder(str, true);
1582       __ if_then(coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1)); {
1583         // Source is Latin1
1584         copy_latin1_string(kit, ideal, src_array, count, dst_array, dst_coder, start);
1585       } __ else_();
1586     }
1587     // Source is UTF16 (destination too). Simply emit a char arraycopy.
1588     arraycopy(kit, ideal, src_array, dst_array, T_CHAR, start, __ value(count));
1589 
1590     if (CompactStrings) {
1591       __ end_if();
1592     }
1593   }
1594 
1595   // Finally sync IdealKit and GraphKit.
1596   kit.sync_kit(ideal);
1597   return __ AddI(start, __ value(count));
1598 }
1599 
1600 // Compress copy the char into dst_array at index start.
1601 Node* PhaseStringOpts::copy_char(GraphKit&amp; kit, Node* val, Node* dst_array, Node* dst_coder, Node* start) {
1602   bool dcon = (dst_coder != NULL) &amp;&amp; dst_coder-&gt;is_Con();
1603   bool dbyte = dcon ? (dst_coder-&gt;get_int() == java_lang_String::CODER_LATIN1) : false;
1604 
1605   IdealKit ideal(&amp;kit, true, true);
1606   IdealVariable end(ideal); __ declarations_done();
1607   Node* adr = kit.array_element_address(dst_array, start, T_BYTE);
1608   if (!dcon){
1609     __ if_then(dst_coder, BoolTest::eq, __ ConI(java_lang_String::CODER_LATIN1));
1610   }
1611   if (!dcon || dbyte) {
1612     // Destination is Latin1. Store a byte.
1613     __ store(__ ctrl(), adr, val, T_BYTE, byte_adr_idx, MemNode::unordered);
1614     __ set(end, __ AddI(start, __ ConI(1)));
1615   }
1616   if (!dcon) {
1617     __ else_();
1618   }
1619   if (!dcon || !dbyte) {
1620     // Destination is UTF16. Store a char.
1621     __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, true /* mismatched */);
1622     __ set(end, __ AddI(start, __ ConI(2)));
1623   }
1624   if (!dcon) {
1625     __ end_if();
1626   }
1627   // Finally sync IdealKit and GraphKit.
1628   kit.sync_kit(ideal);
1629   return __ value(end);
1630 }
1631 
1632 #undef __
1633 #define __ kit.
1634 
1635 // Allocate a byte array of specified length.
1636 Node* PhaseStringOpts::allocate_byte_array(GraphKit&amp; kit, IdealKit* ideal, Node* length) {
1637   if (ideal != NULL) {
1638     // Sync IdealKit and graphKit.
1639     kit.sync_kit(*ideal);
1640   }
1641   Node* byte_array = NULL;
1642   {
1643     PreserveReexecuteState preexecs(&amp;kit);
1644     // The original jvms is for an allocation of either a String or
1645     // StringBuffer so no stack adjustment is necessary for proper
1646     // reexecution.  If we deoptimize in the slow path the bytecode
1647     // will be reexecuted and the char[] allocation will be thrown away.
1648     kit.jvms()-&gt;set_should_reexecute(true);
1649     byte_array = kit.new_array(__ makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE))),
1650                                length, 1);
1651   }
1652 
1653   // Mark the allocation so that zeroing is skipped since the code
1654   // below will overwrite the entire array
1655   AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);
1656   byte_alloc-&gt;maybe_set_complete(_gvn);
1657 
1658   if (ideal != NULL) {
1659     // Sync IdealKit and graphKit.
1660     ideal-&gt;sync_kit(&amp;kit);
1661   }
1662   return byte_array;
1663 }
1664 
1665 jbyte PhaseStringOpts::get_constant_coder(GraphKit&amp; kit, Node* str) {
1666   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1667   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1668   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1669   jbyte coder = str_instance-&gt;field_value_by_offset(java_lang_String::coder_offset_in_bytes()).as_byte();
1670   assert(CompactStrings || (coder == java_lang_String::CODER_UTF16), &quot;Strings must be UTF16 encoded&quot;);
1671   return coder;
1672 }
1673 
1674 int PhaseStringOpts::get_constant_length(GraphKit&amp; kit, Node* str) {
1675   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1676   return get_constant_value(kit, str)-&gt;length();
1677 }
1678 
1679 ciTypeArray* PhaseStringOpts::get_constant_value(GraphKit&amp; kit, Node* str) {
1680   assert(str-&gt;is_Con(), &quot;String must be constant&quot;);
1681   const TypeOopPtr* str_type = kit.gvn().type(str)-&gt;isa_oopptr();
1682   ciInstance* str_instance = str_type-&gt;const_oop()-&gt;as_instance();
1683   ciObject* src_array = str_instance-&gt;field_value_by_offset(java_lang_String::value_offset_in_bytes()).as_object();
1684   return src_array-&gt;as_type_array();
1685 }
1686 
1687 void PhaseStringOpts::replace_string_concat(StringConcat* sc) {
1688   // Log a little info about the transformation
1689   sc-&gt;maybe_log_transform();
1690 
1691   // pull the JVMState of the allocation into a SafePointNode to serve as
1692   // as a shim for the insertion of the new code.
1693   JVMState* jvms     = sc-&gt;begin()-&gt;jvms()-&gt;clone_shallow(C);
1694   uint size = sc-&gt;begin()-&gt;req();
1695   SafePointNode* map = new SafePointNode(size, jvms);
1696 
1697   // copy the control and memory state from the final call into our
1698   // new starting state.  This allows any preceeding tests to feed
1699   // into the new section of code.
1700   for (uint i1 = 0; i1 &lt; TypeFunc::Parms; i1++) {
1701     map-&gt;init_req(i1, sc-&gt;end()-&gt;in(i1));
1702   }
1703   // blow away old allocation arguments
1704   for (uint i1 = TypeFunc::Parms; i1 &lt; jvms-&gt;debug_start(); i1++) {
1705     map-&gt;init_req(i1, C-&gt;top());
1706   }
1707   // Copy the rest of the inputs for the JVMState
1708   for (uint i1 = jvms-&gt;debug_start(); i1 &lt; sc-&gt;begin()-&gt;req(); i1++) {
1709     map-&gt;init_req(i1, sc-&gt;begin()-&gt;in(i1));
1710   }
1711   // Make sure the memory state is a MergeMem for parsing.
1712   if (!map-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem()) {
1713     map-&gt;set_req(TypeFunc::Memory, MergeMemNode::make(map-&gt;in(TypeFunc::Memory)));
1714   }
1715 
1716   jvms-&gt;set_map(map);
1717   map-&gt;ensure_stack(jvms, jvms-&gt;method()-&gt;max_stack());
1718 
1719   // disconnect all the old StringBuilder calls from the graph
1720   sc-&gt;eliminate_unneeded_control();
1721 
1722   // At this point all the old work has been completely removed from
1723   // the graph and the saved JVMState exists at the point where the
1724   // final toString call used to be.
1725   GraphKit kit(jvms);
1726 
1727   // There may be uncommon traps which are still using the
1728   // intermediate states and these need to be rewritten to point at
1729   // the JVMState at the beginning of the transformation.
1730   sc-&gt;convert_uncommon_traps(kit, jvms);
1731 
1732   // Now insert the logic to compute the size of the string followed
1733   // by all the logic to construct array and resulting string.
1734 
1735   Node* null_string = __ makecon(TypeInstPtr::make(C-&gt;env()-&gt;the_null_string()));
1736 
1737   // Create a region for the overflow checks to merge into.
1738   int args = MAX2(sc-&gt;num_arguments(), 1);
1739   RegionNode* overflow = new RegionNode(args);
1740   kit.gvn().set_type(overflow, Type::CONTROL);
1741 
1742   // Create a hook node to hold onto the individual sizes since they
1743   // are need for the copying phase.
1744   Node* string_sizes = new Node(args);
1745 
1746   Node* coder = __ intcon(0);
1747   Node* length = __ intcon(0);
1748   // If at least one argument is UTF16 encoded, we can fix the encoding.
1749   bool coder_fixed = false;
1750 
1751   if (!CompactStrings) {
1752     // Fix encoding of result string to UTF16
1753     coder_fixed = true;
1754     coder = __ intcon(java_lang_String::CODER_UTF16);
1755   }
1756 
1757   for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1758     Node* arg = sc-&gt;argument(argi);
1759     switch (sc-&gt;mode(argi)) {
1760       case StringConcat::IntMode: {
1761         Node* string_size = int_stringSize(kit, arg);
1762 
1763         // accumulate total
1764         length = __ AddI(length, string_size);
1765 
1766         // Cache this value for the use by int_toString
1767         string_sizes-&gt;init_req(argi, string_size);
1768         break;
1769       }
1770       case StringConcat::StringNullCheckMode: {
1771         const Type* type = kit.gvn().type(arg);
1772         assert(type != TypePtr::NULL_PTR, &quot;missing check&quot;);
1773         if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1774           // Null check with uncommon trap since
1775           // StringBuilder(null) throws exception.
1776           // Use special uncommon trap instead of
1777           // calling normal do_null_check().
1778           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1779           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1780           overflow-&gt;add_req(__ IfFalse(iff));
1781           Node* notnull = __ IfTrue(iff);
1782           kit.set_control(notnull); // set control for the cast_not_null
1783           arg = kit.cast_not_null(arg, false);
1784           sc-&gt;set_argument(argi, arg);
1785         }
1786         assert(kit.gvn().type(arg)-&gt;higher_equal(TypeInstPtr::NOTNULL), &quot;sanity&quot;);
1787         // Fallthrough to add string length.
1788       }
1789       case StringConcat::StringMode: {
1790         const Type* type = kit.gvn().type(arg);
1791         Node* count = NULL;
1792         Node* arg_coder = NULL;
1793         if (type == TypePtr::NULL_PTR) {
1794           // replace the argument with the null checked version
1795           arg = null_string;
1796           sc-&gt;set_argument(argi, arg);
1797           count = kit.load_String_length(arg, true);
1798           arg_coder = kit.load_String_coder(arg, true);
1799         } else if (!type-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
1800           // s = s != null ? s : &quot;null&quot;;
1801           // length = length + (s.count - s.offset);
1802           RegionNode *r = new RegionNode(3);
1803           kit.gvn().set_type(r, Type::CONTROL);
1804           Node *phi = new PhiNode(r, type);
1805           kit.gvn().set_type(phi, phi-&gt;bottom_type());
1806           Node* p = __ Bool(__ CmpP(arg, kit.null()), BoolTest::ne);
1807           IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);
1808           Node* notnull = __ IfTrue(iff);
1809           Node* isnull =  __ IfFalse(iff);
1810           kit.set_control(notnull); // set control for the cast_not_null
1811           r-&gt;init_req(1, notnull);
1812           phi-&gt;init_req(1, kit.cast_not_null(arg, false));
1813           r-&gt;init_req(2, isnull);
1814           phi-&gt;init_req(2, null_string);
1815           kit.set_control(r);
1816           C-&gt;record_for_igvn(r);
1817           C-&gt;record_for_igvn(phi);
1818           // replace the argument with the null checked version
1819           arg = phi;
1820           sc-&gt;set_argument(argi, arg);
1821           count = kit.load_String_length(arg, true);
1822           arg_coder = kit.load_String_coder(arg, true);
1823         } else {
1824           // A corresponding nullcheck will be connected during IGVN MemNode::Ideal_common_DU_postCCP
1825           // kit.control might be a different test, that can be hoisted above the actual nullcheck
1826           // in case, that the control input is not null, Ideal_common_DU_postCCP will not look for a nullcheck.
1827           count = kit.load_String_length(arg, false);
1828           arg_coder = kit.load_String_coder(arg, false);
1829         }
1830         if (arg-&gt;is_Con()) {
1831           // Constant string. Get constant coder and length.
1832           jbyte const_coder = get_constant_coder(kit, arg);
1833           int const_length = get_constant_length(kit, arg);
1834           if (const_coder == java_lang_String::CODER_LATIN1) {
1835             // Can be latin1 encoded
1836             arg_coder = __ intcon(const_coder);
1837             count = __ intcon(const_length);
1838           } else {
1839             // Found UTF16 encoded string. Fix result array encoding to UTF16.
1840             coder_fixed = true;
1841             coder = __ intcon(const_coder);
1842             count = __ intcon(const_length / 2);
1843           }
1844         }
1845 
1846         if (!coder_fixed) {
1847           coder = __ OrI(coder, arg_coder);
1848         }
1849         length = __ AddI(length, count);
1850         string_sizes-&gt;init_req(argi, NULL);
1851         break;
1852       }
1853       case StringConcat::CharMode: {
1854         // one character only
1855         const TypeInt* t = kit.gvn().type(arg)-&gt;is_int();
1856         if (!coder_fixed &amp;&amp; t-&gt;is_con()) {
1857           // Constant char
1858           if (t-&gt;get_con() &lt;= 255) {
1859             // Can be latin1 encoded
1860             coder = __ OrI(coder, __ intcon(java_lang_String::CODER_LATIN1));
1861           } else {
1862             // Must be UTF16 encoded. Fix result array encoding to UTF16.
1863             coder_fixed = true;
1864             coder = __ intcon(java_lang_String::CODER_UTF16);
1865           }
1866         } else if (!coder_fixed) {
1867           // Not constant
1868 #undef __
1869 #define __ ideal.
1870           IdealKit ideal(&amp;kit, true, true);
1871           IdealVariable char_coder(ideal); __ declarations_done();
1872           // Check if character can be latin1 encoded
1873           __ if_then(arg, BoolTest::le, __ ConI(0xFF));
1874             __ set(char_coder, __ ConI(java_lang_String::CODER_LATIN1));
1875           __ else_();
1876             __ set(char_coder, __ ConI(java_lang_String::CODER_UTF16));
1877           __ end_if();
1878           kit.sync_kit(ideal);
1879           coder = __ OrI(coder, __ value(char_coder));
1880 #undef __
1881 #define __ kit.
1882         }
1883         length = __ AddI(length, __ intcon(1));
1884         break;
1885       }
1886       default:
1887         ShouldNotReachHere();
1888     }
1889     if (argi &gt; 0) {
1890       // Check that the sum hasn&#39;t overflowed
1891       IfNode* iff = kit.create_and_map_if(kit.control(),
1892                                           __ Bool(__ CmpI(length, __ intcon(0)), BoolTest::lt),
1893                                           PROB_MIN, COUNT_UNKNOWN);
1894       kit.set_control(__ IfFalse(iff));
1895       overflow-&gt;set_req(argi, __ IfTrue(iff));
1896     }
1897   }
1898 
1899   {
1900     // Hook
1901     PreserveJVMState pjvms(&amp;kit);
1902     kit.set_control(overflow);
1903     C-&gt;record_for_igvn(overflow);
1904     kit.uncommon_trap(Deoptimization::Reason_intrinsic,
1905                       Deoptimization::Action_make_not_entrant);
1906   }
1907 
1908   Node* result;
1909   if (!kit.stopped()) {
1910     assert(CompactStrings || (coder-&gt;is_Con() &amp;&amp; coder-&gt;get_int() == java_lang_String::CODER_UTF16),
1911            &quot;Result string must be UTF16 encoded if CompactStrings is disabled&quot;);
1912 
1913     Node* dst_array = NULL;
1914     if (sc-&gt;num_arguments() == 1 &amp;&amp;
1915         (sc-&gt;mode(0) == StringConcat::StringMode ||
1916          sc-&gt;mode(0) == StringConcat::StringNullCheckMode)) {
1917       // Handle the case when there is only a single String argument.
1918       // In this case, we can just pull the value from the String itself.
1919       dst_array = kit.load_String_value(sc-&gt;argument(0), true);
1920     } else {
1921       // Allocate destination byte array according to coder
1922       dst_array = allocate_byte_array(kit, NULL, __ LShiftI(length, coder));
1923 
1924       // Now copy the string representations into the final byte[]
1925       Node* start = __ intcon(0);
1926       for (int argi = 0; argi &lt; sc-&gt;num_arguments(); argi++) {
1927         Node* arg = sc-&gt;argument(argi);
1928         switch (sc-&gt;mode(argi)) {
1929           case StringConcat::IntMode: {
1930             start = int_getChars(kit, arg, dst_array, coder, start, string_sizes-&gt;in(argi));
1931             break;
1932           }
1933           case StringConcat::StringNullCheckMode:
1934           case StringConcat::StringMode: {
1935             start = copy_string(kit, arg, dst_array, coder, start);
1936             break;
1937           }
1938           case StringConcat::CharMode: {
1939             start = copy_char(kit, arg, dst_array, coder, start);
1940           break;
1941           }
1942           default:
1943             ShouldNotReachHere();
1944         }
1945       }
1946     }
1947 
1948     // If we&#39;re not reusing an existing String allocation then allocate one here.
1949     result = sc-&gt;string_alloc();
1950     if (result == NULL) {
1951       PreserveReexecuteState preexecs(&amp;kit);
1952       // The original jvms is for an allocation of either a String or
1953       // StringBuffer so no stack adjustment is necessary for proper
1954       // reexecution.
1955       kit.jvms()-&gt;set_should_reexecute(true);
1956       result = kit.new_instance(__ makecon(TypeKlassPtr::make(C-&gt;env()-&gt;String_klass())));
1957     }
1958 
1959     // Initialize the string
1960     kit.store_String_value(result, dst_array);
1961     kit.store_String_coder(result, coder);
1962 
1963     // The value field is final. Emit a barrier here to ensure that the effect
1964     // of the initialization is committed to memory before any code publishes
1965     // a reference to the newly constructed object (see Parse::do_exits()).
1966     assert(AllocateNode::Ideal_allocation(result, _gvn) != NULL, &quot;should be newly allocated&quot;);
1967     kit.insert_mem_bar(Op_MemBarRelease, result);
1968   } else {
1969     result = C-&gt;top();
1970   }
1971   // hook up the outgoing control and result
1972   kit.replace_call(sc-&gt;end(), result);
1973 
1974   // Unhook any hook nodes
1975   string_sizes-&gt;disconnect_inputs(NULL, C);
1976   sc-&gt;cleanup();
1977 }
    </pre>
  </body>
</html>