<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLMaskFill.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;sun_java2d_metal_MTLMaskFill.h&quot;
 29 
 30 #include &quot;MTLMaskFill.h&quot;
 31 #include &quot;MTLRenderQueue.h&quot;
 32 #include &quot;MTLVertexCache.h&quot;
 33 
 34 /**
 35  * This implementation first copies the alpha tile into a texture and then
 36  * maps that texture to the destination surface.  This approach appears to
 37  * offer the best performance despite being a two-step process.
 38  *
 39  * When the source paint is a Color, we can simply use the GL_MODULATE
 40  * function to multiply the current color (already premultiplied with the
 41  * extra alpha value from the AlphaComposite) with the alpha value from
 42  * the mask texture tile.  In picture form, this process looks like:
 43  *
 44  *                        A     R    G     B
 45  *     primary color      Pa    Pr   Pg    Pb    (modulated with...)
 46  *     texture unit 0     Ca    Ca   Ca    Ca
 47  *     ---------------------------------------
 48  *     resulting color    Ra    Rr   Rg    Rb
 49  *
 50  * where:
 51  *     Px = current color (already premultiplied by extra alpha)
 52  *     Cx = coverage value from mask tile
 53  *     Rx = resulting color/alpha component
 54  *
 55  * When the source paint is not a Color, it means that we are rendering with
 56  * a complex paint (e.g. GradientPaint, TexturePaint).  In this case, we
 57  * rely on the GL_ARB_multitexture extension to effectively multiply the
 58  * paint fragments (autogenerated on texture unit 1, see the
 59  * MTLPaints_Set{Gradient,Texture,etc}Paint() methods for more details)
 60  * with the coverage values from the mask texture tile (provided on texture
 61  * unit 0), all of which is multiplied with the current color value (which
 62  * contains the extra alpha value).  In picture form:
 63  *
 64  *                        A     R    G     B
 65  *     primary color      Ea    Ea   Ea    Ea    (modulated with...)
 66  *     texture unit 0     Ca    Ca   Ca    Ca    (modulated with...)
 67  *     texture unit 1     Pa    Pr   Pg    Pb
 68  *     ---------------------------------------
 69  *     resulting color    Ra    Rr   Rg    Rb
 70  *
 71  * where:
 72  *     Ea = extra alpha
 73  *     Cx = coverage value from mask tile
 74  *     Px = gradient/texture paint color (generated for each fragment)
 75  *     Rx = resulting color/alpha component
 76  *
 77  * Here are some descriptions of the many variables used in this method:
 78  *   x,y     - upper left corner of the tile destination
 79  *   w,h     - width/height of the mask tile
 80  *   x0      - placekeeper for the original destination x location
 81  *   tw,th   - width/height of the actual texture tile in pixels
 82  *   sx1,sy1 - upper left corner of the mask tile source region
 83  *   sx2,sy2 - lower left corner of the mask tile source region
 84  *   sx,sy   - &quot;current&quot; upper left corner of the mask tile region of interest
 85  */
 86 void
 87 MTLMaskFill_MaskFill(MTLContext *mtlc, BMTLSDOps * dstOps,
 88                      jint x, jint y, jint w, jint h,
 89                      jint maskoff, jint maskscan, jint masklen,
 90                      unsigned char *pMask)
 91 {
 92     J2dTraceLn5(J2D_TRACE_INFO, &quot;MTLMaskFill_MaskFill (x=%d y=%d w=%d h=%d pMask=%p)&quot;, x, y, w, h, dstOps-&gt;pTexture);
 93 
 94     MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 95     jint tw, th, x0;
 96     jint sx1, sy1, sx2, sy2;
 97     jint sx, sy, sw, sh;
 98 
 99     x0 = x;
100     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
101     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
102     sx1 = maskoff % maskscan;
103     sy1 = maskoff / maskscan;
104     sx2 = sx1 + w;
105     sy2 = sy1 + h;
106 
107 
108     for (sy = sy1; sy &lt; sy2; sy += th, y += th) {
109         x = x0;
110         sh = ((sy + th) &gt; sy2) ? (sy2 - sy) : th;
111 
112         for (sx = sx1; sx &lt; sx2; sx += tw, x += tw) {
113             sw = ((sx + tw) &gt; sx2) ? (sx2 - sx) : tw;
114             MTLVertexCache_AddMaskQuad(mtlc,
115                     sx, sy, x, y, sw, sh,
116                     MTLVC_MASK_CACHE_TILE_WIDTH, pMask, dstOps,
117                     MTLVC_MASK_CACHE_TILE_WIDTH);
118         }
119     }
120 
121     MTLVertexCache_DisableMaskCache(mtlc);
122 }
123 
124 JNIEXPORT void JNICALL
125 Java_sun_java2d_metal_MTLMaskFill_maskFill
126     (JNIEnv *env, jobject self,
127      jint x, jint y, jint w, jint h,
128      jint maskoff, jint maskscan, jint masklen,
129      jbyteArray maskArray)
130 {
131     MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
132     BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
133     unsigned char *mask;
134 
135     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLMaskFill_maskFill&quot;);
136 
137     if (maskArray != NULL) {
138         mask = (unsigned char *)
139             (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, NULL);
140     } else {
141         mask = NULL;
142     }
143 
144     MTLMaskFill_MaskFill(mtlc, dstOps,
145                          x, y, w, h,
146                          maskoff, maskscan, masklen, mask);
147 
148     if (mask != NULL) {
149         (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, mask, JNI_ABORT);
150     }
151 }
152 
153 #endif /* !HEADLESS */
    </pre>
  </body>
</html>