<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/sun/java2d/marlin/Dasher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.awt.geom.PathConsumer2D;
  30 import sun.java2d.marlin.TransformingPathConsumer2D.CurveBasicMonotonizer;
  31 import sun.java2d.marlin.TransformingPathConsumer2D.CurveClipSplitter;
  32 
  33 /**
  34  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
  35  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  36  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  37  * dash pattern array and a starting dash phase.
  38  *
  39  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  40  * short dash, whereas Pisces does not draw anything.  The PostScript
  41  * semantics are unclear.
  42  *
  43  */
  44 final class Dasher implements PathConsumer2D, MarlinConst {
  45 
  46     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  47     static final int REC_LIMIT = 16;
  48     static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01
  49     static final float MIN_T_INC = 1.0f / (1 &lt;&lt; REC_LIMIT);
  50 
  51     // More than 24 bits of mantissa means we can no longer accurately
  52     // measure the number of times cycled through the dash array so we
  53     // punt and override the phase to just be 0 past that point.
  54     static final float MAX_CYCLES = 16000000.0f;
  55 
  56     private PathConsumer2D out;
  57     private float[] dash;
  58     private int dashLen;
  59     private float startPhase;
  60     private boolean startDashOn;
  61     private int startIdx;
  62 
  63     private boolean starting;
  64     private boolean needsMoveTo;
  65 
  66     private int idx;
  67     private boolean dashOn;
  68     private float phase;
  69 
  70     // The starting point of the path
  71     private float sx0, sy0;
  72     // the current point
  73     private float cx0, cy0;
  74 
  75     // temporary storage for the current curve
  76     private final float[] curCurvepts;
  77 
  78     // per-thread renderer context
  79     final RendererContext rdrCtx;
  80 
  81     // flag to recycle dash array copy
  82     boolean recycleDashes;
  83 
  84     // We don&#39;t emit the first dash right away. If we did, caps would be
  85     // drawn on it, but we need joins to be drawn if there&#39;s a closePath()
  86     // So, we store the path elements that make up the first dash in the
  87     // buffer below.
  88     private float[] firstSegmentsBuffer; // dynamic array
  89     private int firstSegidx;
  90 
  91     // dashes ref (dirty)
  92     final FloatArrayCache.Reference dashes_ref;
  93     // firstSegmentsBuffer ref (dirty)
  94     final FloatArrayCache.Reference firstSegmentsBuffer_ref;
  95 
  96     // Bounds of the drawing region, at pixel precision.
  97     private float[] clipRect;
  98 
  99     // the outcode of the current point
 100     private int cOutCode = 0;
 101 
 102     private boolean subdivide = DO_CLIP_SUBDIVIDER;
 103 
 104     private final LengthIterator li = new LengthIterator();
 105 
 106     private final CurveClipSplitter curveSplitter;
 107 
 108     private float cycleLen;
 109     private boolean outside;
 110     private float totalSkipLen;
 111 
 112     /**
 113      * Constructs a &lt;code&gt;Dasher&lt;/code&gt;.
 114      * @param rdrCtx per-thread renderer context
 115      */
 116     Dasher(final RendererContext rdrCtx) {
 117         this.rdrCtx = rdrCtx;
 118 
 119         dashes_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); // 1K
 120 
 121         firstSegmentsBuffer_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); // 1K
 122         firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;
 123 
 124         // we need curCurvepts to be able to contain 2 curves because when
 125         // dashing curves, we need to subdivide it
 126         curCurvepts = new float[8 * 2];
 127 
 128         this.curveSplitter = rdrCtx.curveClipSplitter;
 129     }
 130 
 131     /**
 132      * Initialize the &lt;code&gt;Dasher&lt;/code&gt;.
 133      *
 134      * @param out an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 135      * @param dash an array of &lt;code&gt;float&lt;/code&gt;s containing the dash pattern
 136      * @param dashLen length of the given dash array
 137      * @param phase a &lt;code&gt;float&lt;/code&gt; containing the dash phase
 138      * @param recycleDashes true to indicate to recycle the given dash array
 139      * @return this instance
 140      */
 141     Dasher init(final PathConsumer2D out, final float[] dash, final int dashLen,
 142                 float phase, final boolean recycleDashes)
 143     {
 144         this.out = out;
 145 
 146         // Normalize so 0 &lt;= phase &lt; dash[0]
 147         int sidx = 0;
 148         dashOn = true;
 149 
 150         // note: BasicStroke constructor checks dash elements and sum &gt; 0
 151         float sum = 0.0f;
 152         for (int i = 0; i &lt; dashLen; i++) {
 153             sum += dash[i];
 154         }
 155         this.cycleLen = sum;
 156 
 157         float cycles = phase / sum;
 158         if (phase &lt; 0.0f) {
 159             if (-cycles &gt;= MAX_CYCLES) {
 160                 phase = 0.0f;
 161             } else {
 162                 int fullcycles = FloatMath.floor_int(-cycles);
 163                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 164                     dashOn = !dashOn;
 165                 }
 166                 phase += fullcycles * sum;
 167                 while (phase &lt; 0.0f) {
 168                     if (--sidx &lt; 0) {
 169                         sidx = dashLen - 1;
 170                     }
 171                     phase += dash[sidx];
 172                     dashOn = !dashOn;
 173                 }
 174             }
 175         } else if (phase &gt; 0.0f) {
 176             if (cycles &gt;= MAX_CYCLES) {
 177                 phase = 0.0f;
 178             } else {
 179                 int fullcycles = FloatMath.floor_int(cycles);
 180                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 181                     dashOn = !dashOn;
 182                 }
 183                 phase -= fullcycles * sum;
 184                 float d;
 185                 while (phase &gt;= (d = dash[sidx])) {
 186                     phase -= d;
 187                     sidx = (sidx + 1) % dashLen;
 188                     dashOn = !dashOn;
 189                 }
 190             }
 191         }
 192 
 193         this.dash = dash;
 194         this.dashLen = dashLen;
 195         this.phase = phase;
 196         this.startPhase = phase;
 197         this.startDashOn = dashOn;
 198         this.startIdx = sidx;
 199         this.starting = true;
 200         this.needsMoveTo = false;
 201         this.firstSegidx = 0;
 202 
 203         this.recycleDashes = recycleDashes;
 204 
 205         if (rdrCtx.doClip) {
 206             this.clipRect = rdrCtx.clipRect;
 207         } else {
 208             this.clipRect = null;
 209             this.cOutCode = 0;
 210         }
 211         return this; // fluent API
 212     }
 213 
 214     /**
 215      * Disposes this dasher:
 216      * clean up before reusing this instance
 217      */
 218     void dispose() {
 219         if (DO_CLEAN_DIRTY) {
 220             // Force zero-fill dirty arrays:
 221             Arrays.fill(curCurvepts, 0.0f);
 222         }
 223         // Return arrays:
 224         if (recycleDashes) {
 225             dash = dashes_ref.putArray(dash);
 226         }
 227         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 228     }
 229 
 230     float[] copyDashArray(final float[] dashes) {
 231         final int len = dashes.length;
 232         final float[] newDashes;
 233         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 234             newDashes = dashes_ref.initial;
 235         } else {
 236             if (DO_STATS) {
 237                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 238             }
 239             newDashes = dashes_ref.getArray(len);
 240         }
 241         System.arraycopy(dashes, 0, newDashes, 0, len);
 242         return newDashes;
 243     }
 244 
 245     @Override
 246     public void moveTo(final float x0, final float y0) {
 247         if (firstSegidx != 0) {
 248             out.moveTo(sx0, sy0);
 249             emitFirstSegments();
 250         }
 251         this.needsMoveTo = true;
 252         this.idx = startIdx;
 253         this.dashOn = this.startDashOn;
 254         this.phase = this.startPhase;
 255         this.cx0 = x0;
 256         this.cy0 = y0;
 257 
 258         // update starting point:
 259         this.sx0 = x0;
 260         this.sy0 = y0;
 261         this.starting = true;
 262 
 263         if (clipRect != null) {
 264             final int outcode = Helpers.outcode(x0, y0, clipRect);
 265             this.cOutCode = outcode;
 266             this.outside = false;
 267             this.totalSkipLen = 0.0f;
 268         }
 269     }
 270 
 271     private void emitSeg(float[] buf, int off, int type) {
 272         switch (type) {
 273         case 8:
 274             out.curveTo(buf[off    ], buf[off + 1],
 275                         buf[off + 2], buf[off + 3],
 276                         buf[off + 4], buf[off + 5]);
 277             return;
 278         case 6:
 279             out.quadTo(buf[off    ], buf[off + 1],
 280                        buf[off + 2], buf[off + 3]);
 281             return;
 282         case 4:
 283             out.lineTo(buf[off], buf[off + 1]);
 284             return;
 285         default:
 286         }
 287     }
 288 
 289     private void emitFirstSegments() {
 290         final float[] fSegBuf = firstSegmentsBuffer;
 291 
 292         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 293             int type = (int)fSegBuf[i];
 294             emitSeg(fSegBuf, i + 1, type);
 295             i += (type - 1);
 296         }
 297         firstSegidx = 0;
 298     }
 299 
 300     // precondition: pts must be in relative coordinates (relative to x0,y0)
 301     private void goTo(final float[] pts, final int off, final int type,
 302                       final boolean on)
 303     {
 304         final int index = off + type;
 305         final float x = pts[index - 4];
 306         final float y = pts[index - 3];
 307 
 308         if (on) {
 309             if (starting) {
 310                 goTo_starting(pts, off, type);
 311             } else {
 312                 if (needsMoveTo) {
 313                     needsMoveTo = false;
 314                     out.moveTo(cx0, cy0);
 315                 }
 316                 emitSeg(pts, off, type);
 317             }
 318         } else {
 319             if (starting) {
 320                 // low probability test (hotspot)
 321                 starting = false;
 322             }
 323             needsMoveTo = true;
 324         }
 325         this.cx0 = x;
 326         this.cy0 = y;
 327     }
 328 
 329     private void goTo_starting(final float[] pts, final int off, final int type) {
 330         int len = type - 1; // - 2 + 1
 331         int segIdx = firstSegidx;
 332         float[] buf = firstSegmentsBuffer;
 333 
 334         if (segIdx + len  &gt; buf.length) {
 335             if (DO_STATS) {
 336                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 337                     .add(segIdx + len);
 338             }
 339             firstSegmentsBuffer = buf
 340                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 341                                                      segIdx + len);
 342         }
 343         buf[segIdx++] = type;
 344         len--;
 345         // small arraycopy (2, 4 or 6) but with offset:
 346         System.arraycopy(pts, off, buf, segIdx, len);
 347         firstSegidx = segIdx + len;
 348     }
 349 
 350     @Override
 351     public void lineTo(final float x1, final float y1) {
 352         final int outcode0 = this.cOutCode;
 353 
 354         if (clipRect != null) {
 355             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 356 
 357             // Should clip
 358             final int orCode = (outcode0 | outcode1);
 359 
 360             if (orCode != 0) {
 361                 final int sideCode = outcode0 &amp; outcode1;
 362 
 363                 // basic rejection criteria:
 364                 if (sideCode == 0) {
 365                     // ovelap clip:
 366                     if (subdivide) {
 367                         // avoid reentrance
 368                         subdivide = false;
 369                         // subdivide curve =&gt; callback with subdivided parts:
 370                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 371                                                               orCode, this);
 372                         // reentrance is done:
 373                         subdivide = true;
 374                         if (ret) {
 375                             return;
 376                         }
 377                     }
 378                     // already subdivided so render it
 379                 } else {
 380                     this.cOutCode = outcode1;
 381                     skipLineTo(x1, y1);
 382                     return;
 383                 }
 384             }
 385 
 386             this.cOutCode = outcode1;
 387 
 388             if (this.outside) {
 389                 this.outside = false;
 390                 // Adjust current index, phase &amp; dash:
 391                 skipLen();
 392             }
 393         }
 394         _lineTo(x1, y1);
 395     }
 396 
 397     private void _lineTo(final float x1, final float y1) {
 398         final float dx = x1 - cx0;
 399         final float dy = y1 - cy0;
 400 
 401         float len = dx * dx + dy * dy;
 402         if (len == 0.0f) {
 403             return;
 404         }
 405         len = (float) Math.sqrt(len);
 406 
 407         // The scaling factors needed to get the dx and dy of the
 408         // transformed dash segments.
 409         final float cx = dx / len;
 410         final float cy = dy / len;
 411 
 412         final float[] _curCurvepts = curCurvepts;
 413         final float[] _dash = dash;
 414         final int _dashLen = this.dashLen;
 415 
 416         int _idx = idx;
 417         boolean _dashOn = dashOn;
 418         float _phase = phase;
 419 
 420         float leftInThisDashSegment, d;
 421 
 422         while (true) {
 423             d = _dash[_idx];
 424             leftInThisDashSegment = d - _phase;
 425 
 426             if (len &lt;= leftInThisDashSegment) {
 427                 _curCurvepts[0] = x1;
 428                 _curCurvepts[1] = y1;
 429 
 430                 goTo(_curCurvepts, 0, 4, _dashOn);
 431 
 432                 // Advance phase within current dash segment
 433                 _phase += len;
 434 
 435                 // TODO: compare float values using epsilon:
 436                 if (len == leftInThisDashSegment) {
 437                     _phase = 0.0f;
 438                     _idx = (_idx + 1) % _dashLen;
 439                     _dashOn = !_dashOn;
 440                 }
 441                 break;
 442             }
 443 
 444             if (_phase == 0.0f) {
 445                 _curCurvepts[0] = cx0 + d * cx;
 446                 _curCurvepts[1] = cy0 + d * cy;
 447             } else {
 448                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;
 449                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;
 450             }
 451 
 452             goTo(_curCurvepts, 0, 4, _dashOn);
 453 
 454             len -= leftInThisDashSegment;
 455             // Advance to next dash segment
 456             _idx = (_idx + 1) % _dashLen;
 457             _dashOn = !_dashOn;
 458             _phase = 0.0f;
 459         }
 460         // Save local state:
 461         idx = _idx;
 462         dashOn = _dashOn;
 463         phase = _phase;
 464     }
 465 
 466     private void skipLineTo(final float x1, final float y1) {
 467         final float dx = x1 - cx0;
 468         final float dy = y1 - cy0;
 469 
 470         float len = dx * dx + dy * dy;
 471         if (len != 0.0f) {
 472             len = (float)Math.sqrt(len);
 473         }
 474 
 475         // Accumulate skipped length:
 476         this.outside = true;
 477         this.totalSkipLen += len;
 478 
 479         // Fix initial move:
 480         this.needsMoveTo = true;
 481         this.starting = false;
 482 
 483         this.cx0 = x1;
 484         this.cy0 = y1;
 485     }
 486 
 487     public void skipLen() {
 488         float len = this.totalSkipLen;
 489         this.totalSkipLen = 0.0f;
 490 
 491         final float[] _dash = dash;
 492         final int _dashLen = this.dashLen;
 493 
 494         int _idx = idx;
 495         boolean _dashOn = dashOn;
 496         float _phase = phase;
 497 
 498         // -2 to ensure having 2 iterations of the post-loop
 499         // to compensate the remaining phase
 500         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 501 
 502         if (fullcycles &gt; 0L) {
 503             len -= cycleLen * fullcycles;
 504 
 505             final long iterations = fullcycles * _dashLen;
 506             _idx = (int) (iterations + _idx) % _dashLen;
 507             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 508         }
 509 
 510         float leftInThisDashSegment, d;
 511 
 512         while (true) {
 513             d = _dash[_idx];
 514             leftInThisDashSegment = d - _phase;
 515 
 516             if (len &lt;= leftInThisDashSegment) {
 517                 // Advance phase within current dash segment
 518                 _phase += len;
 519 
 520                 // TODO: compare float values using epsilon:
 521                 if (len == leftInThisDashSegment) {
 522                     _phase = 0.0f;
 523                     _idx = (_idx + 1) % _dashLen;
 524                     _dashOn = !_dashOn;
 525                 }
 526                 break;
 527             }
 528 
 529             len -= leftInThisDashSegment;
 530             // Advance to next dash segment
 531             _idx = (_idx + 1) % _dashLen;
 532             _dashOn = !_dashOn;
 533             _phase = 0.0f;
 534         }
 535         // Save local state:
 536         idx = _idx;
 537         dashOn = _dashOn;
 538         phase = _phase;
 539     }
 540 
 541     // preconditions: curCurvepts must be an array of length at least 2 * type,
 542     // that contains the curve we want to dash in the first type elements
 543     private void somethingTo(final int type) {
 544         final float[] _curCurvepts = curCurvepts;
 545         if (pointCurve(_curCurvepts, type)) {
 546             return;
 547         }
 548         final LengthIterator _li = li;
 549         final float[] _dash = dash;
 550         final int _dashLen = this.dashLen;
 551 
 552         _li.initializeIterationOnCurve(_curCurvepts, type);
 553 
 554         int _idx = idx;
 555         boolean _dashOn = dashOn;
 556         float _phase = phase;
 557 
 558         // initially the current curve is at curCurvepts[0...type]
 559         int curCurveoff = 0;
 560         float prevT = 0.0f;
 561         float t;
 562         float leftInThisDashSegment = _dash[_idx] - _phase;
 563 
 564         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0f) {
 565             if (t != 0.0f) {
 566                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
 567                                     _curCurvepts, curCurveoff,
 568                                     _curCurvepts, 0, type);
 569                 prevT = t;
 570                 goTo(_curCurvepts, 2, type, _dashOn);
 571                 curCurveoff = type;
 572             }
 573             // Advance to next dash segment
 574             _idx = (_idx + 1) % _dashLen;
 575             _dashOn = !_dashOn;
 576             _phase = 0.0f;
 577             leftInThisDashSegment = _dash[_idx];
 578         }
 579 
 580         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 581 
 582         _phase += _li.lastSegLen();
 583         if (_phase &gt;= _dash[_idx]) {
 584             _phase = 0.0f;
 585             _idx = (_idx + 1) % _dashLen;
 586             _dashOn = !_dashOn;
 587         }
 588         // Save local state:
 589         idx = _idx;
 590         dashOn = _dashOn;
 591         phase = _phase;
 592 
 593         // reset LengthIterator:
 594         _li.reset();
 595     }
 596 
 597     private void skipSomethingTo(final int type) {
 598         final float[] _curCurvepts = curCurvepts;
 599         if (pointCurve(_curCurvepts, type)) {
 600             return;
 601         }
 602         final LengthIterator _li = li;
 603 
 604         _li.initializeIterationOnCurve(_curCurvepts, type);
 605 
 606         // In contrary to somethingTo(),
 607         // just estimate properly the curve length:
 608         final float len = _li.totalLength();
 609 
 610         // Accumulate skipped length:
 611         this.outside = true;
 612         this.totalSkipLen += len;
 613 
 614         // Fix initial move:
 615         this.needsMoveTo = true;
 616         this.starting = false;
 617     }
 618 
 619     private static boolean pointCurve(final float[] curve, final int type) {
 620         for (int i = 2; i &lt; type; i++) {
 621             if (curve[i] != curve[i-2]) {
 622                 return false;
 623             }
 624         }
 625         return true;
 626     }
 627 
 628     // Objects of this class are used to iterate through curves. They return
 629     // t values where the left side of the curve has a specified length.
 630     // It does this by subdividing the input curve until a certain error
 631     // condition has been met. A recursive subdivision procedure would
 632     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 633     // don&#39;t need all the curves all at once, so what we carry out a
 634     // lazy inorder traversal of the recursion tree (meaning we only move
 635     // through the tree when we need the next subdivided curve). This saves
 636     // us a lot of memory because at any one time we only need to store
 637     // limit+1 curves - one for each level of the tree + 1.
 638     // NOTE: the way we do things here is not enough to traverse a general
 639     // tree; however, the trees we are interested in have the property that
 640     // every non leaf node has exactly 2 children
 641     static final class LengthIterator {
 642         // Holds the curves at various levels of the recursion. The root
 643         // (i.e. the original curve) is at recCurveStack[0] (but then it
 644         // gets subdivided, the left half is put at 1, so most of the time
 645         // only the right half of the original curve is at 0)
 646         private final float[][] recCurveStack; // dirty
 647         // sidesRight[i] indicates whether the node at level i+1 in the path from
 648         // the root to the current leaf is a left or right child of its parent.
 649         private final boolean[] sidesRight; // dirty
 650         private int curveType;
 651         // lastT and nextT delimit the current leaf.
 652         private float nextT;
 653         private float lenAtNextT;
 654         private float lastT;
 655         private float lenAtLastT;
 656         private float lenAtLastSplit;
 657         private float lastSegLen;
 658         // the current level in the recursion tree. 0 is the root. limit
 659         // is the deepest possible leaf.
 660         private int recLevel;
 661         private boolean done;
 662 
 663         // the lengths of the lines of the control polygon. Only its first
 664         // curveType/2 - 1 elements are valid. This is an optimization. See
 665         // next() for more detail.
 666         private final float[] curLeafCtrlPolyLengths = new float[3];
 667 
 668         LengthIterator() {
 669             this.recCurveStack = new float[REC_LIMIT + 1][8];
 670             this.sidesRight = new boolean[REC_LIMIT];
 671             // if any methods are called without first initializing this object
 672             // on a curve, we want it to fail ASAP.
 673             this.nextT = Float.MAX_VALUE;
 674             this.lenAtNextT = Float.MAX_VALUE;
 675             this.lenAtLastSplit = Float.MIN_VALUE;
 676             this.recLevel = Integer.MIN_VALUE;
 677             this.lastSegLen = Float.MAX_VALUE;
 678             this.done = true;
 679         }
 680 
 681         /**
 682          * Reset this LengthIterator.
 683          */
 684         void reset() {
 685             // keep data dirty
 686             // as it appears not useful to reset data:
 687             if (DO_CLEAN_DIRTY) {
 688                 final int recLimit = recCurveStack.length - 1;
 689                 for (int i = recLimit; i &gt;= 0; i--) {
 690                     Arrays.fill(recCurveStack[i], 0.0f);
 691                 }
 692                 Arrays.fill(sidesRight, false);
 693                 Arrays.fill(curLeafCtrlPolyLengths, 0.0f);
 694                 Arrays.fill(nextRoots, 0.0f);
 695                 Arrays.fill(flatLeafCoefCache, 0.0f);
 696                 flatLeafCoefCache[2] = -1.0f;
 697             }
 698         }
 699 
 700         void initializeIterationOnCurve(final float[] pts, final int type) {
 701             // optimize arraycopy (8 values faster than 6 = type):
 702             System.arraycopy(pts, 0, recCurveStack[0], 0, 8);
 703             this.curveType = type;
 704             this.recLevel = 0;
 705             this.lastT = 0.0f;
 706             this.lenAtLastT = 0.0f;
 707             this.nextT = 0.0f;
 708             this.lenAtNextT = 0.0f;
 709             goLeft(); // initializes nextT and lenAtNextT properly
 710             this.lenAtLastSplit = 0.0f;
 711             if (recLevel &gt; 0) {
 712                 this.sidesRight[0] = false;
 713                 this.done = false;
 714             } else {
 715                 // the root of the tree is a leaf so we&#39;re done.
 716                 this.sidesRight[0] = true;
 717                 this.done = true;
 718             }
 719             this.lastSegLen = 0.0f;
 720         }
 721 
 722         // 0 == false, 1 == true, -1 == invalid cached value.
 723         private int cachedHaveLowAcceleration = -1;
 724 
 725         private boolean haveLowAcceleration(final float err) {
 726             if (cachedHaveLowAcceleration == -1) {
 727                 final float len1 = curLeafCtrlPolyLengths[0];
 728                 final float len2 = curLeafCtrlPolyLengths[1];
 729                 // the test below is equivalent to !within(len1/len2, 1, err).
 730                 // It is using a multiplication instead of a division, so it
 731                 // should be a bit faster.
 732                 if (!Helpers.within(len1, len2, err * len2)) {
 733                     cachedHaveLowAcceleration = 0;
 734                     return false;
 735                 }
 736                 if (curveType == 8) {
 737                     final float len3 = curLeafCtrlPolyLengths[2];
 738                     // if len1 is close to 2 and 2 is close to 3, that probably
 739                     // means 1 is close to 3 so the second part of this test might
 740                     // not be needed, but it doesn&#39;t hurt to include it.
 741                     final float errLen3 = err * len3;
 742                     if (!(Helpers.within(len2, len3, errLen3) &amp;&amp;
 743                           Helpers.within(len1, len3, errLen3))) {
 744                         cachedHaveLowAcceleration = 0;
 745                         return false;
 746                     }
 747                 }
 748                 cachedHaveLowAcceleration = 1;
 749                 return true;
 750             }
 751 
 752             return (cachedHaveLowAcceleration == 1);
 753         }
 754 
 755         // we want to avoid allocations/gc so we keep this array so we
 756         // can put roots in it,
 757         private final float[] nextRoots = new float[4];
 758 
 759         // caches the coefficients of the current leaf in its flattened
 760         // form (see inside next() for what that means). The cache is
 761         // invalid when it&#39;s third element is negative, since in any
 762         // valid flattened curve, this would be &gt;= 0.
 763         private final float[] flatLeafCoefCache = new float[]{0.0f, 0.0f, -1.0f, 0.0f};
 764 
 765         // returns the t value where the remaining curve should be split in
 766         // order for the left subdivided curve to have length len. If len
 767         // is &gt;= than the length of the uniterated curve, it returns 1.
 768         float next(final float len) {
 769             final float targetLength = lenAtLastSplit + len;
 770             while (lenAtNextT &lt; targetLength) {
 771                 if (done) {
 772                     lastSegLen = lenAtNextT - lenAtLastSplit;
 773                     return 1.0f;
 774                 }
 775                 goToNextLeaf();
 776             }
 777             lenAtLastSplit = targetLength;
 778             final float leaflen = lenAtNextT - lenAtLastT;
 779             float t = (targetLength - lenAtLastT) / leaflen;
 780 
 781             // cubicRootsInAB is a fairly expensive call, so we just don&#39;t do it
 782             // if the acceleration in this section of the curve is small enough.
 783             if (!haveLowAcceleration(0.05f)) {
 784                 // We flatten the current leaf along the x axis, so that we&#39;re
 785                 // left with a, b, c which define a 1D Bezier curve. We then
 786                 // solve this to get the parameter of the original leaf that
 787                 // gives us the desired length.
 788                 final float[] _flatLeafCoefCache = flatLeafCoefCache;
 789 
 790                 if (_flatLeafCoefCache[2] &lt; 0.0f) {
 791                     float x =     curLeafCtrlPolyLengths[0],
 792                           y = x + curLeafCtrlPolyLengths[1];
 793                     if (curveType == 8) {
 794                         float z = y + curLeafCtrlPolyLengths[2];
 795                         _flatLeafCoefCache[0] = 3.0f * (x - y) + z;
 796                         _flatLeafCoefCache[1] = 3.0f * (y - 2.0f * x);
 797                         _flatLeafCoefCache[2] = 3.0f * x;
 798                         _flatLeafCoefCache[3] = -z;
 799                     } else if (curveType == 6) {
 800                         _flatLeafCoefCache[0] = 0.0f;
 801                         _flatLeafCoefCache[1] = y - 2.0f * x;
 802                         _flatLeafCoefCache[2] = 2.0f * x;
 803                         _flatLeafCoefCache[3] = -y;
 804                     }
 805                 }
 806                 float a = _flatLeafCoefCache[0];
 807                 float b = _flatLeafCoefCache[1];
 808                 float c = _flatLeafCoefCache[2];
 809                 float d = t * _flatLeafCoefCache[3];
 810 
 811                 // we use cubicRootsInAB here, because we want only roots in 0, 1,
 812                 // and our quadratic root finder doesn&#39;t filter, so it&#39;s just a
 813                 // matter of convenience.
 814                 final int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0f, 1.0f);
 815                 if (n == 1 &amp;&amp; !Float.isNaN(nextRoots[0])) {
 816                     t = nextRoots[0];
 817                 }
 818             }
 819             // t is relative to the current leaf, so we must make it a valid parameter
 820             // of the original curve.
 821             t = t * (nextT - lastT) + lastT;
 822             if (t &gt;= 1.0f) {
 823                 t = 1.0f;
 824                 done = true;
 825             }
 826             // even if done = true, if we&#39;re here, that means targetLength
 827             // is equal to, or very, very close to the total length of the
 828             // curve, so lastSegLen won&#39;t be too high. In cases where len
 829             // overshoots the curve, this method will exit in the while
 830             // loop, and lastSegLen will still be set to the right value.
 831             lastSegLen = len;
 832             return t;
 833         }
 834 
 835         float totalLength() {
 836             while (!done) {
 837                 goToNextLeaf();
 838             }
 839             // reset LengthIterator:
 840             reset();
 841 
 842             return lenAtNextT;
 843         }
 844 
 845         float lastSegLen() {
 846             return lastSegLen;
 847         }
 848 
 849         // go to the next leaf (in an inorder traversal) in the recursion tree
 850         // preconditions: must be on a leaf, and that leaf must not be the root.
 851         private void goToNextLeaf() {
 852             // We must go to the first ancestor node that has an unvisited
 853             // right child.
 854             final boolean[] _sides = sidesRight;
 855             int _recLevel = recLevel;
 856             _recLevel--;
 857 
 858             while(_sides[_recLevel]) {
 859                 if (_recLevel == 0) {
 860                     recLevel = 0;
 861                     done = true;
 862                     return;
 863                 }
 864                 _recLevel--;
 865             }
 866 
 867             _sides[_recLevel] = true;
 868             // optimize arraycopy (8 values faster than 6 = type):
 869             System.arraycopy(recCurveStack[_recLevel++], 0,
 870                              recCurveStack[_recLevel], 0, 8);
 871             recLevel = _recLevel;
 872             goLeft();
 873         }
 874 
 875         // go to the leftmost node from the current node. Return its length.
 876         private void goLeft() {
 877             final float len = onLeaf();
 878             if (len &gt;= 0.0f) {
 879                 lastT = nextT;
 880                 lenAtLastT = lenAtNextT;
 881                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 882                 lenAtNextT += len;
 883                 // invalidate caches
 884                 flatLeafCoefCache[2] = -1.0f;
 885                 cachedHaveLowAcceleration = -1;
 886             } else {
 887                 Helpers.subdivide(recCurveStack[recLevel],
 888                                   recCurveStack[recLevel + 1],
 889                                   recCurveStack[recLevel], curveType);
 890 
 891                 sidesRight[recLevel] = false;
 892                 recLevel++;
 893                 goLeft();
 894             }
 895         }
 896 
 897         // this is a bit of a hack. It returns -1 if we&#39;re not on a leaf, and
 898         // the length of the leaf if we are on a leaf.
 899         private float onLeaf() {
 900             final float[] curve = recCurveStack[recLevel];
 901             final int _curveType = curveType;
 902             float polyLen = 0.0f;
 903 
 904             float x0 = curve[0], y0 = curve[1];
 905             for (int i = 2; i &lt; _curveType; i += 2) {
 906                 final float x1 = curve[i], y1 = curve[i + 1];
 907                 final float len = Helpers.linelen(x0, y0, x1, y1);
 908                 polyLen += len;
 909                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;
 910                 x0 = x1;
 911                 y0 = y1;
 912             }
 913 
 914             final float lineLen = Helpers.linelen(curve[0], curve[1], x0, y0);
 915 
 916             if ((polyLen - lineLen) &lt; CURVE_LEN_ERR || recLevel == REC_LIMIT) {
 917                 return (polyLen + lineLen) / 2.0f;
 918             }
 919             return -1.0f;
 920         }
 921     }
 922 
 923     @Override
 924     public void curveTo(final float x1, final float y1,
 925                         final float x2, final float y2,
 926                         final float x3, final float y3)
 927     {
 928         final int outcode0 = this.cOutCode;
 929 
 930         if (clipRect != null) {
 931             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 932             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
 933             final int outcode3 = Helpers.outcode(x3, y3, clipRect);
 934 
 935             // Should clip
 936             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 937             if (orCode != 0) {
 938                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 939 
 940                 // basic rejection criteria:
 941                 if (sideCode == 0) {
 942                     // ovelap clip:
 943                     if (subdivide) {
 944                         // avoid reentrance
 945                         subdivide = false;
 946                         // subdivide curve =&gt; callback with subdivided parts:
 947                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 948                                                                orCode, this);
 949                         // reentrance is done:
 950                         subdivide = true;
 951                         if (ret) {
 952                             return;
 953                         }
 954                     }
 955                     // already subdivided so render it
 956                 } else {
 957                     this.cOutCode = outcode3;
 958                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 959                     return;
 960                 }
 961             }
 962 
 963             this.cOutCode = outcode3;
 964 
 965             if (this.outside) {
 966                 this.outside = false;
 967                 // Adjust current index, phase &amp; dash:
 968                 skipLen();
 969             }
 970         }
 971         _curveTo(x1, y1, x2, y2, x3, y3);
 972     }
 973 
 974     private void _curveTo(final float x1, final float y1,
 975                           final float x2, final float y2,
 976                           final float x3, final float y3)
 977     {
 978         final float[] _curCurvepts = curCurvepts;
 979 
 980         // monotonize curve:
 981         final CurveBasicMonotonizer monotonizer
 982             = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);
 983 
 984         final int nSplits = monotonizer.nbSplits;
 985         final float[] mid = monotonizer.middle;
 986 
 987         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
 988             // optimize arraycopy (8 values faster than 6 = type):
 989             System.arraycopy(mid, off, _curCurvepts, 0, 8);
 990 
 991             somethingTo(8);
 992         }
 993     }
 994 
 995     private void skipCurveTo(final float x1, final float y1,
 996                              final float x2, final float y2,
 997                              final float x3, final float y3)
 998     {
 999         final float[] _curCurvepts = curCurvepts;
1000         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1001         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1002         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1003         _curCurvepts[6] = x3;  _curCurvepts[7] = y3;
1004 
1005         skipSomethingTo(8);
1006 
1007         this.cx0 = x3;
1008         this.cy0 = y3;
1009     }
1010 
1011     @Override
1012     public void quadTo(final float x1, final float y1,
1013                        final float x2, final float y2)
1014     {
1015         final int outcode0 = this.cOutCode;
1016 
1017         if (clipRect != null) {
1018             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
1019             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
1020 
1021             // Should clip
1022             final int orCode = (outcode0 | outcode1 | outcode2);
1023             if (orCode != 0) {
1024                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1025 
1026                 // basic rejection criteria:
1027                 if (sideCode == 0) {
1028                     // ovelap clip:
1029                     if (subdivide) {
1030                         // avoid reentrance
1031                         subdivide = false;
1032                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1033                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1034                                                               x2, y2, orCode, this);
1035                         // reentrance is done:
1036                         subdivide = true;
1037                         if (ret) {
1038                             return;
1039                         }
1040                     }
1041                     // already subdivided so render it
1042                 } else {
1043                     this.cOutCode = outcode2;
1044                     skipQuadTo(x1, y1, x2, y2);
1045                     return;
1046                 }
1047             }
1048 
1049             this.cOutCode = outcode2;
1050 
1051             if (this.outside) {
1052                 this.outside = false;
1053                 // Adjust current index, phase &amp; dash:
1054                 skipLen();
1055             }
1056         }
1057         _quadTo(x1, y1, x2, y2);
1058     }
1059 
1060     private void _quadTo(final float x1, final float y1,
1061                          final float x2, final float y2)
1062     {
1063         final float[] _curCurvepts = curCurvepts;
1064 
1065         // monotonize quad:
1066         final CurveBasicMonotonizer monotonizer
1067             = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);
1068 
1069         final int nSplits = monotonizer.nbSplits;
1070         final float[] mid = monotonizer.middle;
1071 
1072         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1073             // optimize arraycopy (8 values faster than 6 = type):
1074             System.arraycopy(mid, off, _curCurvepts, 0, 8);
1075 
1076             somethingTo(6);
1077         }
1078     }
1079 
1080     private void skipQuadTo(final float x1, final float y1,
1081                             final float x2, final float y2)
1082     {
1083         final float[] _curCurvepts = curCurvepts;
1084         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1085         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1086         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1087 
1088         skipSomethingTo(6);
1089 
1090         this.cx0 = x2;
1091         this.cy0 = y2;
1092     }
1093 
1094     @Override
1095     public void closePath() {
1096         if (cx0 != sx0 || cy0 != sy0) {
1097             lineTo(sx0, sy0);
1098         }
1099         if (firstSegidx != 0) {
1100             if (!dashOn || needsMoveTo) {
1101                 out.moveTo(sx0, sy0);
1102             }
1103             emitFirstSegments();
1104         }
1105         moveTo(sx0, sy0);
1106     }
1107 
1108     @Override
1109     public void pathDone() {
1110         if (firstSegidx != 0) {
1111             out.moveTo(sx0, sy0);
1112             emitFirstSegments();
1113         }
1114         out.pathDone();
1115 
1116         // Dispose this instance:
1117         dispose();
1118     }
1119 
1120     @Override
1121     public long getNativeConsumer() {
1122         throw new InternalError(&quot;Dasher does not use a native consumer&quot;);
1123     }
1124 }
1125 
    </pre>
  </body>
</html>