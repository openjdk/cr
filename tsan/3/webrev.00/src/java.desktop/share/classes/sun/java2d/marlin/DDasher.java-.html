<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/sun/java2d/marlin/DDasher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;
  30 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;
  31 
  32 /**
  33  * The &lt;code&gt;DDasher&lt;/code&gt; class takes a series of linear commands
  34  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  35  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  36  * dash pattern array and a starting dash phase.
  37  *
  38  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  39  * short dash, whereas Pisces does not draw anything.  The PostScript
  40  * semantics are unclear.
  41  *
  42  */
  43 final class DDasher implements DPathConsumer2D, MarlinConst {
  44 
  45     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  46     static final int REC_LIMIT = 16;
  47     static final double CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01 initial
  48     static final double MIN_T_INC = 1.0d / (1 &lt;&lt; REC_LIMIT);
  49 
  50     // More than 24 bits of mantissa means we can no longer accurately
  51     // measure the number of times cycled through the dash array so we
  52     // punt and override the phase to just be 0 past that point.
  53     static final double MAX_CYCLES = 16000000.0d;
  54 
  55     private DPathConsumer2D out;
  56     private double[] dash;
  57     private int dashLen;
  58     private double startPhase;
  59     private boolean startDashOn;
  60     private int startIdx;
  61 
  62     private boolean starting;
  63     private boolean needsMoveTo;
  64 
  65     private int idx;
  66     private boolean dashOn;
  67     private double phase;
  68 
  69     // The starting point of the path
  70     private double sx0, sy0;
  71     // the current point
  72     private double cx0, cy0;
  73 
  74     // temporary storage for the current curve
  75     private final double[] curCurvepts;
  76 
  77     // per-thread renderer context
  78     final DRendererContext rdrCtx;
  79 
  80     // flag to recycle dash array copy
  81     boolean recycleDashes;
  82 
  83     // We don&#39;t emit the first dash right away. If we did, caps would be
  84     // drawn on it, but we need joins to be drawn if there&#39;s a closePath()
  85     // So, we store the path elements that make up the first dash in the
  86     // buffer below.
  87     private double[] firstSegmentsBuffer; // dynamic array
  88     private int firstSegidx;
  89 
  90     // dashes ref (dirty)
  91     final DoubleArrayCache.Reference dashes_ref;
  92     // firstSegmentsBuffer ref (dirty)
  93     final DoubleArrayCache.Reference firstSegmentsBuffer_ref;
  94 
  95     // Bounds of the drawing region, at pixel precision.
  96     private double[] clipRect;
  97 
  98     // the outcode of the current point
  99     private int cOutCode = 0;
 100 
 101     private boolean subdivide = DO_CLIP_SUBDIVIDER;
 102 
 103     private final LengthIterator li = new LengthIterator();
 104 
 105     private final CurveClipSplitter curveSplitter;
 106 
 107     private double cycleLen;
 108     private boolean outside;
 109     private double totalSkipLen;
 110 
 111     /**
 112      * Constructs a &lt;code&gt;DDasher&lt;/code&gt;.
 113      * @param rdrCtx per-thread renderer context
 114      */
 115     DDasher(final DRendererContext rdrCtx) {
 116         this.rdrCtx = rdrCtx;
 117 
 118         dashes_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 119 
 120         firstSegmentsBuffer_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 121         firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;
 122 
 123         // we need curCurvepts to be able to contain 2 curves because when
 124         // dashing curves, we need to subdivide it
 125         curCurvepts = new double[8 * 2];
 126 
 127         this.curveSplitter = rdrCtx.curveClipSplitter;
 128     }
 129 
 130     /**
 131      * Initialize the &lt;code&gt;DDasher&lt;/code&gt;.
 132      *
 133      * @param out an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
 134      * @param dash an array of &lt;code&gt;double&lt;/code&gt;s containing the dash pattern
 135      * @param dashLen length of the given dash array
 136      * @param phase a &lt;code&gt;double&lt;/code&gt; containing the dash phase
 137      * @param recycleDashes true to indicate to recycle the given dash array
 138      * @return this instance
 139      */
 140     DDasher init(final DPathConsumer2D out, final double[] dash, final int dashLen,
 141                 double phase, final boolean recycleDashes)
 142     {
 143         this.out = out;
 144 
 145         // Normalize so 0 &lt;= phase &lt; dash[0]
 146         int sidx = 0;
 147         dashOn = true;
 148 
 149         // note: BasicStroke constructor checks dash elements and sum &gt; 0
 150         double sum = 0.0d;
 151         for (int i = 0; i &lt; dashLen; i++) {
 152             sum += dash[i];
 153         }
 154         this.cycleLen = sum;
 155 
 156         double cycles = phase / sum;
 157         if (phase &lt; 0.0d) {
 158             if (-cycles &gt;= MAX_CYCLES) {
 159                 phase = 0.0d;
 160             } else {
 161                 int fullcycles = FloatMath.floor_int(-cycles);
 162                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 163                     dashOn = !dashOn;
 164                 }
 165                 phase += fullcycles * sum;
 166                 while (phase &lt; 0.0d) {
 167                     if (--sidx &lt; 0) {
 168                         sidx = dashLen - 1;
 169                     }
 170                     phase += dash[sidx];
 171                     dashOn = !dashOn;
 172                 }
 173             }
 174         } else if (phase &gt; 0.0d) {
 175             if (cycles &gt;= MAX_CYCLES) {
 176                 phase = 0.0d;
 177             } else {
 178                 int fullcycles = FloatMath.floor_int(cycles);
 179                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 180                     dashOn = !dashOn;
 181                 }
 182                 phase -= fullcycles * sum;
 183                 double d;
 184                 while (phase &gt;= (d = dash[sidx])) {
 185                     phase -= d;
 186                     sidx = (sidx + 1) % dashLen;
 187                     dashOn = !dashOn;
 188                 }
 189             }
 190         }
 191 
 192         this.dash = dash;
 193         this.dashLen = dashLen;
 194         this.phase = phase;
 195         this.startPhase = phase;
 196         this.startDashOn = dashOn;
 197         this.startIdx = sidx;
 198         this.starting = true;
 199         this.needsMoveTo = false;
 200         this.firstSegidx = 0;
 201 
 202         this.recycleDashes = recycleDashes;
 203 
 204         if (rdrCtx.doClip) {
 205             this.clipRect = rdrCtx.clipRect;
 206         } else {
 207             this.clipRect = null;
 208             this.cOutCode = 0;
 209         }
 210         return this; // fluent API
 211     }
 212 
 213     /**
 214      * Disposes this dasher:
 215      * clean up before reusing this instance
 216      */
 217     void dispose() {
 218         if (DO_CLEAN_DIRTY) {
 219             // Force zero-fill dirty arrays:
 220             Arrays.fill(curCurvepts, 0.0d);
 221         }
 222         // Return arrays:
 223         if (recycleDashes) {
 224             dash = dashes_ref.putArray(dash);
 225         }
 226         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 227     }
 228 
 229     double[] copyDashArray(final float[] dashes) {
 230         final int len = dashes.length;
 231         final double[] newDashes;
 232         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 233             newDashes = dashes_ref.initial;
 234         } else {
 235             if (DO_STATS) {
 236                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 237             }
 238             newDashes = dashes_ref.getArray(len);
 239         }
 240         for (int i = 0; i &lt; len; i++) { newDashes[i] = dashes[i]; }
 241         return newDashes;
 242     }
 243 
 244     @Override
 245     public void moveTo(final double x0, final double y0) {
 246         if (firstSegidx != 0) {
 247             out.moveTo(sx0, sy0);
 248             emitFirstSegments();
 249         }
 250         this.needsMoveTo = true;
 251         this.idx = startIdx;
 252         this.dashOn = this.startDashOn;
 253         this.phase = this.startPhase;
 254         this.cx0 = x0;
 255         this.cy0 = y0;
 256 
 257         // update starting point:
 258         this.sx0 = x0;
 259         this.sy0 = y0;
 260         this.starting = true;
 261 
 262         if (clipRect != null) {
 263             final int outcode = DHelpers.outcode(x0, y0, clipRect);
 264             this.cOutCode = outcode;
 265             this.outside = false;
 266             this.totalSkipLen = 0.0d;
 267         }
 268     }
 269 
 270     private void emitSeg(double[] buf, int off, int type) {
 271         switch (type) {
 272         case 8:
 273             out.curveTo(buf[off    ], buf[off + 1],
 274                         buf[off + 2], buf[off + 3],
 275                         buf[off + 4], buf[off + 5]);
 276             return;
 277         case 6:
 278             out.quadTo(buf[off    ], buf[off + 1],
 279                        buf[off + 2], buf[off + 3]);
 280             return;
 281         case 4:
 282             out.lineTo(buf[off], buf[off + 1]);
 283             return;
 284         default:
 285         }
 286     }
 287 
 288     private void emitFirstSegments() {
 289         final double[] fSegBuf = firstSegmentsBuffer;
 290 
 291         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 292             int type = (int)fSegBuf[i];
 293             emitSeg(fSegBuf, i + 1, type);
 294             i += (type - 1);
 295         }
 296         firstSegidx = 0;
 297     }
 298 
 299     // precondition: pts must be in relative coordinates (relative to x0,y0)
 300     private void goTo(final double[] pts, final int off, final int type,
 301                       final boolean on)
 302     {
 303         final int index = off + type;
 304         final double x = pts[index - 4];
 305         final double y = pts[index - 3];
 306 
 307         if (on) {
 308             if (starting) {
 309                 goTo_starting(pts, off, type);
 310             } else {
 311                 if (needsMoveTo) {
 312                     needsMoveTo = false;
 313                     out.moveTo(cx0, cy0);
 314                 }
 315                 emitSeg(pts, off, type);
 316             }
 317         } else {
 318             if (starting) {
 319                 // low probability test (hotspot)
 320                 starting = false;
 321             }
 322             needsMoveTo = true;
 323         }
 324         this.cx0 = x;
 325         this.cy0 = y;
 326     }
 327 
 328     private void goTo_starting(final double[] pts, final int off, final int type) {
 329         int len = type - 1; // - 2 + 1
 330         int segIdx = firstSegidx;
 331         double[] buf = firstSegmentsBuffer;
 332 
 333         if (segIdx + len  &gt; buf.length) {
 334             if (DO_STATS) {
 335                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 336                     .add(segIdx + len);
 337             }
 338             firstSegmentsBuffer = buf
 339                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 340                                                      segIdx + len);
 341         }
 342         buf[segIdx++] = type;
 343         len--;
 344         // small arraycopy (2, 4 or 6) but with offset:
 345         System.arraycopy(pts, off, buf, segIdx, len);
 346         firstSegidx = segIdx + len;
 347     }
 348 
 349     @Override
 350     public void lineTo(final double x1, final double y1) {
 351         final int outcode0 = this.cOutCode;
 352 
 353         if (clipRect != null) {
 354             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 355 
 356             // Should clip
 357             final int orCode = (outcode0 | outcode1);
 358 
 359             if (orCode != 0) {
 360                 final int sideCode = outcode0 &amp; outcode1;
 361 
 362                 // basic rejection criteria:
 363                 if (sideCode == 0) {
 364                     // ovelap clip:
 365                     if (subdivide) {
 366                         // avoid reentrance
 367                         subdivide = false;
 368                         // subdivide curve =&gt; callback with subdivided parts:
 369                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 370                                                               orCode, this);
 371                         // reentrance is done:
 372                         subdivide = true;
 373                         if (ret) {
 374                             return;
 375                         }
 376                     }
 377                     // already subdivided so render it
 378                 } else {
 379                     this.cOutCode = outcode1;
 380                     skipLineTo(x1, y1);
 381                     return;
 382                 }
 383             }
 384 
 385             this.cOutCode = outcode1;
 386 
 387             if (this.outside) {
 388                 this.outside = false;
 389                 // Adjust current index, phase &amp; dash:
 390                 skipLen();
 391             }
 392         }
 393         _lineTo(x1, y1);
 394     }
 395 
 396     private void _lineTo(final double x1, final double y1) {
 397         final double dx = x1 - cx0;
 398         final double dy = y1 - cy0;
 399 
 400         double len = dx * dx + dy * dy;
 401         if (len == 0.0d) {
 402             return;
 403         }
 404         len = Math.sqrt(len);
 405 
 406         // The scaling factors needed to get the dx and dy of the
 407         // transformed dash segments.
 408         final double cx = dx / len;
 409         final double cy = dy / len;
 410 
 411         final double[] _curCurvepts = curCurvepts;
 412         final double[] _dash = dash;
 413         final int _dashLen = this.dashLen;
 414 
 415         int _idx = idx;
 416         boolean _dashOn = dashOn;
 417         double _phase = phase;
 418 
 419         double leftInThisDashSegment, d;
 420 
 421         while (true) {
 422             d = _dash[_idx];
 423             leftInThisDashSegment = d - _phase;
 424 
 425             if (len &lt;= leftInThisDashSegment) {
 426                 _curCurvepts[0] = x1;
 427                 _curCurvepts[1] = y1;
 428 
 429                 goTo(_curCurvepts, 0, 4, _dashOn);
 430 
 431                 // Advance phase within current dash segment
 432                 _phase += len;
 433 
 434                 // TODO: compare double values using epsilon:
 435                 if (len == leftInThisDashSegment) {
 436                     _phase = 0.0d;
 437                     _idx = (_idx + 1) % _dashLen;
 438                     _dashOn = !_dashOn;
 439                 }
 440                 break;
 441             }
 442 
 443             if (_phase == 0.0d) {
 444                 _curCurvepts[0] = cx0 + d * cx;
 445                 _curCurvepts[1] = cy0 + d * cy;
 446             } else {
 447                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;
 448                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;
 449             }
 450 
 451             goTo(_curCurvepts, 0, 4, _dashOn);
 452 
 453             len -= leftInThisDashSegment;
 454             // Advance to next dash segment
 455             _idx = (_idx + 1) % _dashLen;
 456             _dashOn = !_dashOn;
 457             _phase = 0.0d;
 458         }
 459         // Save local state:
 460         idx = _idx;
 461         dashOn = _dashOn;
 462         phase = _phase;
 463     }
 464 
 465     private void skipLineTo(final double x1, final double y1) {
 466         final double dx = x1 - cx0;
 467         final double dy = y1 - cy0;
 468 
 469         double len = dx * dx + dy * dy;
 470         if (len != 0.0d) {
 471             len = Math.sqrt(len);
 472         }
 473 
 474         // Accumulate skipped length:
 475         this.outside = true;
 476         this.totalSkipLen += len;
 477 
 478         // Fix initial move:
 479         this.needsMoveTo = true;
 480         this.starting = false;
 481 
 482         this.cx0 = x1;
 483         this.cy0 = y1;
 484     }
 485 
 486     public void skipLen() {
 487         double len = this.totalSkipLen;
 488         this.totalSkipLen = 0.0d;
 489 
 490         final double[] _dash = dash;
 491         final int _dashLen = this.dashLen;
 492 
 493         int _idx = idx;
 494         boolean _dashOn = dashOn;
 495         double _phase = phase;
 496 
 497         // -2 to ensure having 2 iterations of the post-loop
 498         // to compensate the remaining phase
 499         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 500 
 501         if (fullcycles &gt; 0L) {
 502             len -= cycleLen * fullcycles;
 503 
 504             final long iterations = fullcycles * _dashLen;
 505             _idx = (int) (iterations + _idx) % _dashLen;
 506             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 507         }
 508 
 509         double leftInThisDashSegment, d;
 510 
 511         while (true) {
 512             d = _dash[_idx];
 513             leftInThisDashSegment = d - _phase;
 514 
 515             if (len &lt;= leftInThisDashSegment) {
 516                 // Advance phase within current dash segment
 517                 _phase += len;
 518 
 519                 // TODO: compare double values using epsilon:
 520                 if (len == leftInThisDashSegment) {
 521                     _phase = 0.0d;
 522                     _idx = (_idx + 1) % _dashLen;
 523                     _dashOn = !_dashOn;
 524                 }
 525                 break;
 526             }
 527 
 528             len -= leftInThisDashSegment;
 529             // Advance to next dash segment
 530             _idx = (_idx + 1) % _dashLen;
 531             _dashOn = !_dashOn;
 532             _phase = 0.0d;
 533         }
 534         // Save local state:
 535         idx = _idx;
 536         dashOn = _dashOn;
 537         phase = _phase;
 538     }
 539 
 540     // preconditions: curCurvepts must be an array of length at least 2 * type,
 541     // that contains the curve we want to dash in the first type elements
 542     private void somethingTo(final int type) {
 543         final double[] _curCurvepts = curCurvepts;
 544         if (pointCurve(_curCurvepts, type)) {
 545             return;
 546         }
 547         final LengthIterator _li = li;
 548         final double[] _dash = dash;
 549         final int _dashLen = this.dashLen;
 550 
 551         _li.initializeIterationOnCurve(_curCurvepts, type);
 552 
 553         int _idx = idx;
 554         boolean _dashOn = dashOn;
 555         double _phase = phase;
 556 
 557         // initially the current curve is at curCurvepts[0...type]
 558         int curCurveoff = 0;
 559         double prevT = 0.0d;
 560         double t;
 561         double leftInThisDashSegment = _dash[_idx] - _phase;
 562 
 563         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0d) {
 564             if (t != 0.0d) {
 565                 DHelpers.subdivideAt((t - prevT) / (1.0d - prevT),
 566                                     _curCurvepts, curCurveoff,
 567                                     _curCurvepts, 0, type);
 568                 prevT = t;
 569                 goTo(_curCurvepts, 2, type, _dashOn);
 570                 curCurveoff = type;
 571             }
 572             // Advance to next dash segment
 573             _idx = (_idx + 1) % _dashLen;
 574             _dashOn = !_dashOn;
 575             _phase = 0.0d;
 576             leftInThisDashSegment = _dash[_idx];
 577         }
 578 
 579         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 580 
 581         _phase += _li.lastSegLen();
 582         if (_phase &gt;= _dash[_idx]) {
 583             _phase = 0.0d;
 584             _idx = (_idx + 1) % _dashLen;
 585             _dashOn = !_dashOn;
 586         }
 587         // Save local state:
 588         idx = _idx;
 589         dashOn = _dashOn;
 590         phase = _phase;
 591 
 592         // reset LengthIterator:
 593         _li.reset();
 594     }
 595 
 596     private void skipSomethingTo(final int type) {
 597         final double[] _curCurvepts = curCurvepts;
 598         if (pointCurve(_curCurvepts, type)) {
 599             return;
 600         }
 601         final LengthIterator _li = li;
 602 
 603         _li.initializeIterationOnCurve(_curCurvepts, type);
 604 
 605         // In contrary to somethingTo(),
 606         // just estimate properly the curve length:
 607         final double len = _li.totalLength();
 608 
 609         // Accumulate skipped length:
 610         this.outside = true;
 611         this.totalSkipLen += len;
 612 
 613         // Fix initial move:
 614         this.needsMoveTo = true;
 615         this.starting = false;
 616     }
 617 
 618     private static boolean pointCurve(final double[] curve, final int type) {
 619         for (int i = 2; i &lt; type; i++) {
 620             if (curve[i] != curve[i-2]) {
 621                 return false;
 622             }
 623         }
 624         return true;
 625     }
 626 
 627     // Objects of this class are used to iterate through curves. They return
 628     // t values where the left side of the curve has a specified length.
 629     // It does this by subdividing the input curve until a certain error
 630     // condition has been met. A recursive subdivision procedure would
 631     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 632     // don&#39;t need all the curves all at once, so what we carry out a
 633     // lazy inorder traversal of the recursion tree (meaning we only move
 634     // through the tree when we need the next subdivided curve). This saves
 635     // us a lot of memory because at any one time we only need to store
 636     // limit+1 curves - one for each level of the tree + 1.
 637     // NOTE: the way we do things here is not enough to traverse a general
 638     // tree; however, the trees we are interested in have the property that
 639     // every non leaf node has exactly 2 children
 640     static final class LengthIterator {
 641         // Holds the curves at various levels of the recursion. The root
 642         // (i.e. the original curve) is at recCurveStack[0] (but then it
 643         // gets subdivided, the left half is put at 1, so most of the time
 644         // only the right half of the original curve is at 0)
 645         private final double[][] recCurveStack; // dirty
 646         // sidesRight[i] indicates whether the node at level i+1 in the path from
 647         // the root to the current leaf is a left or right child of its parent.
 648         private final boolean[] sidesRight; // dirty
 649         private int curveType;
 650         // lastT and nextT delimit the current leaf.
 651         private double nextT;
 652         private double lenAtNextT;
 653         private double lastT;
 654         private double lenAtLastT;
 655         private double lenAtLastSplit;
 656         private double lastSegLen;
 657         // the current level in the recursion tree. 0 is the root. limit
 658         // is the deepest possible leaf.
 659         private int recLevel;
 660         private boolean done;
 661 
 662         // the lengths of the lines of the control polygon. Only its first
 663         // curveType/2 - 1 elements are valid. This is an optimization. See
 664         // next() for more detail.
 665         private final double[] curLeafCtrlPolyLengths = new double[3];
 666 
 667         LengthIterator() {
 668             this.recCurveStack = new double[REC_LIMIT + 1][8];
 669             this.sidesRight = new boolean[REC_LIMIT];
 670             // if any methods are called without first initializing this object
 671             // on a curve, we want it to fail ASAP.
 672             this.nextT = Double.MAX_VALUE;
 673             this.lenAtNextT = Double.MAX_VALUE;
 674             this.lenAtLastSplit = Double.MIN_VALUE;
 675             this.recLevel = Integer.MIN_VALUE;
 676             this.lastSegLen = Double.MAX_VALUE;
 677             this.done = true;
 678         }
 679 
 680         /**
 681          * Reset this LengthIterator.
 682          */
 683         void reset() {
 684             // keep data dirty
 685             // as it appears not useful to reset data:
 686             if (DO_CLEAN_DIRTY) {
 687                 final int recLimit = recCurveStack.length - 1;
 688                 for (int i = recLimit; i &gt;= 0; i--) {
 689                     Arrays.fill(recCurveStack[i], 0.0d);
 690                 }
 691                 Arrays.fill(sidesRight, false);
 692                 Arrays.fill(curLeafCtrlPolyLengths, 0.0d);
 693                 Arrays.fill(nextRoots, 0.0d);
 694                 Arrays.fill(flatLeafCoefCache, 0.0d);
 695                 flatLeafCoefCache[2] = -1.0d;
 696             }
 697         }
 698 
 699         void initializeIterationOnCurve(final double[] pts, final int type) {
 700             // optimize arraycopy (8 values faster than 6 = type):
 701             System.arraycopy(pts, 0, recCurveStack[0], 0, 8);
 702             this.curveType = type;
 703             this.recLevel = 0;
 704             this.lastT = 0.0d;
 705             this.lenAtLastT = 0.0d;
 706             this.nextT = 0.0d;
 707             this.lenAtNextT = 0.0d;
 708             goLeft(); // initializes nextT and lenAtNextT properly
 709             this.lenAtLastSplit = 0.0d;
 710             if (recLevel &gt; 0) {
 711                 this.sidesRight[0] = false;
 712                 this.done = false;
 713             } else {
 714                 // the root of the tree is a leaf so we&#39;re done.
 715                 this.sidesRight[0] = true;
 716                 this.done = true;
 717             }
 718             this.lastSegLen = 0.0d;
 719         }
 720 
 721         // 0 == false, 1 == true, -1 == invalid cached value.
 722         private int cachedHaveLowAcceleration = -1;
 723 
 724         private boolean haveLowAcceleration(final double err) {
 725             if (cachedHaveLowAcceleration == -1) {
 726                 final double len1 = curLeafCtrlPolyLengths[0];
 727                 final double len2 = curLeafCtrlPolyLengths[1];
 728                 // the test below is equivalent to !within(len1/len2, 1, err).
 729                 // It is using a multiplication instead of a division, so it
 730                 // should be a bit faster.
 731                 if (!DHelpers.within(len1, len2, err * len2)) {
 732                     cachedHaveLowAcceleration = 0;
 733                     return false;
 734                 }
 735                 if (curveType == 8) {
 736                     final double len3 = curLeafCtrlPolyLengths[2];
 737                     // if len1 is close to 2 and 2 is close to 3, that probably
 738                     // means 1 is close to 3 so the second part of this test might
 739                     // not be needed, but it doesn&#39;t hurt to include it.
 740                     final double errLen3 = err * len3;
 741                     if (!(DHelpers.within(len2, len3, errLen3) &amp;&amp;
 742                           DHelpers.within(len1, len3, errLen3))) {
 743                         cachedHaveLowAcceleration = 0;
 744                         return false;
 745                     }
 746                 }
 747                 cachedHaveLowAcceleration = 1;
 748                 return true;
 749             }
 750 
 751             return (cachedHaveLowAcceleration == 1);
 752         }
 753 
 754         // we want to avoid allocations/gc so we keep this array so we
 755         // can put roots in it,
 756         private final double[] nextRoots = new double[4];
 757 
 758         // caches the coefficients of the current leaf in its flattened
 759         // form (see inside next() for what that means). The cache is
 760         // invalid when it&#39;s third element is negative, since in any
 761         // valid flattened curve, this would be &gt;= 0.
 762         private final double[] flatLeafCoefCache = new double[]{0.0d, 0.0d, -1.0d, 0.0d};
 763 
 764         // returns the t value where the remaining curve should be split in
 765         // order for the left subdivided curve to have length len. If len
 766         // is &gt;= than the length of the uniterated curve, it returns 1.
 767         double next(final double len) {
 768             final double targetLength = lenAtLastSplit + len;
 769             while (lenAtNextT &lt; targetLength) {
 770                 if (done) {
 771                     lastSegLen = lenAtNextT - lenAtLastSplit;
 772                     return 1.0d;
 773                 }
 774                 goToNextLeaf();
 775             }
 776             lenAtLastSplit = targetLength;
 777             final double leaflen = lenAtNextT - lenAtLastT;
 778             double t = (targetLength - lenAtLastT) / leaflen;
 779 
 780             // cubicRootsInAB is a fairly expensive call, so we just don&#39;t do it
 781             // if the acceleration in this section of the curve is small enough.
 782             if (!haveLowAcceleration(0.05d)) {
 783                 // We flatten the current leaf along the x axis, so that we&#39;re
 784                 // left with a, b, c which define a 1D Bezier curve. We then
 785                 // solve this to get the parameter of the original leaf that
 786                 // gives us the desired length.
 787                 final double[] _flatLeafCoefCache = flatLeafCoefCache;
 788 
 789                 if (_flatLeafCoefCache[2] &lt; 0.0d) {
 790                     double x =     curLeafCtrlPolyLengths[0],
 791                            y = x + curLeafCtrlPolyLengths[1];
 792                     if (curveType == 8) {
 793                         double z = y + curLeafCtrlPolyLengths[2];
 794                         _flatLeafCoefCache[0] = 3.0d * (x - y) + z;
 795                         _flatLeafCoefCache[1] = 3.0d * (y - 2.0d * x);
 796                         _flatLeafCoefCache[2] = 3.0d * x;
 797                         _flatLeafCoefCache[3] = -z;
 798                     } else if (curveType == 6) {
 799                         _flatLeafCoefCache[0] = 0.0d;
 800                         _flatLeafCoefCache[1] = y - 2.0d * x;
 801                         _flatLeafCoefCache[2] = 2.0d * x;
 802                         _flatLeafCoefCache[3] = -y;
 803                     }
 804                 }
 805                 double a = _flatLeafCoefCache[0];
 806                 double b = _flatLeafCoefCache[1];
 807                 double c = _flatLeafCoefCache[2];
 808                 double d = t * _flatLeafCoefCache[3];
 809 
 810                 // we use cubicRootsInAB here, because we want only roots in 0, 1,
 811                 // and our quadratic root finder doesn&#39;t filter, so it&#39;s just a
 812                 // matter of convenience.
 813                 final int n = DHelpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0d, 1.0d);
 814                 if (n == 1 &amp;&amp; !Double.isNaN(nextRoots[0])) {
 815                     t = nextRoots[0];
 816                 }
 817             }
 818             // t is relative to the current leaf, so we must make it a valid parameter
 819             // of the original curve.
 820             t = t * (nextT - lastT) + lastT;
 821             if (t &gt;= 1.0d) {
 822                 t = 1.0d;
 823                 done = true;
 824             }
 825             // even if done = true, if we&#39;re here, that means targetLength
 826             // is equal to, or very, very close to the total length of the
 827             // curve, so lastSegLen won&#39;t be too high. In cases where len
 828             // overshoots the curve, this method will exit in the while
 829             // loop, and lastSegLen will still be set to the right value.
 830             lastSegLen = len;
 831             return t;
 832         }
 833 
 834         double totalLength() {
 835             while (!done) {
 836                 goToNextLeaf();
 837             }
 838             // reset LengthIterator:
 839             reset();
 840 
 841             return lenAtNextT;
 842         }
 843 
 844         double lastSegLen() {
 845             return lastSegLen;
 846         }
 847 
 848         // go to the next leaf (in an inorder traversal) in the recursion tree
 849         // preconditions: must be on a leaf, and that leaf must not be the root.
 850         private void goToNextLeaf() {
 851             // We must go to the first ancestor node that has an unvisited
 852             // right child.
 853             final boolean[] _sides = sidesRight;
 854             int _recLevel = recLevel;
 855             _recLevel--;
 856 
 857             while(_sides[_recLevel]) {
 858                 if (_recLevel == 0) {
 859                     recLevel = 0;
 860                     done = true;
 861                     return;
 862                 }
 863                 _recLevel--;
 864             }
 865 
 866             _sides[_recLevel] = true;
 867             // optimize arraycopy (8 values faster than 6 = type):
 868             System.arraycopy(recCurveStack[_recLevel++], 0,
 869                              recCurveStack[_recLevel], 0, 8);
 870             recLevel = _recLevel;
 871             goLeft();
 872         }
 873 
 874         // go to the leftmost node from the current node. Return its length.
 875         private void goLeft() {
 876             final double len = onLeaf();
 877             if (len &gt;= 0.0d) {
 878                 lastT = nextT;
 879                 lenAtLastT = lenAtNextT;
 880                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 881                 lenAtNextT += len;
 882                 // invalidate caches
 883                 flatLeafCoefCache[2] = -1.0d;
 884                 cachedHaveLowAcceleration = -1;
 885             } else {
 886                 DHelpers.subdivide(recCurveStack[recLevel],
 887                                    recCurveStack[recLevel + 1],
 888                                    recCurveStack[recLevel], curveType);
 889 
 890                 sidesRight[recLevel] = false;
 891                 recLevel++;
 892                 goLeft();
 893             }
 894         }
 895 
 896         // this is a bit of a hack. It returns -1 if we&#39;re not on a leaf, and
 897         // the length of the leaf if we are on a leaf.
 898         private double onLeaf() {
 899             final double[] curve = recCurveStack[recLevel];
 900             final int _curveType = curveType;
 901             double polyLen = 0.0d;
 902 
 903             double x0 = curve[0], y0 = curve[1];
 904             for (int i = 2; i &lt; _curveType; i += 2) {
 905                 final double x1 = curve[i], y1 = curve[i + 1];
 906                 final double len = DHelpers.linelen(x0, y0, x1, y1);
 907                 polyLen += len;
 908                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;
 909                 x0 = x1;
 910                 y0 = y1;
 911             }
 912 
 913             final double lineLen = DHelpers.linelen(curve[0], curve[1], x0, y0);
 914 
 915             if ((polyLen - lineLen) &lt; CURVE_LEN_ERR || recLevel == REC_LIMIT) {
 916                 return (polyLen + lineLen) / 2.0d;
 917             }
 918             return -1.0d;
 919         }
 920     }
 921 
 922     @Override
 923     public void curveTo(final double x1, final double y1,
 924                         final double x2, final double y2,
 925                         final double x3, final double y3)
 926     {
 927         final int outcode0 = this.cOutCode;
 928 
 929         if (clipRect != null) {
 930             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 931             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
 932             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);
 933 
 934             // Should clip
 935             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 936             if (orCode != 0) {
 937                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 938 
 939                 // basic rejection criteria:
 940                 if (sideCode == 0) {
 941                     // ovelap clip:
 942                     if (subdivide) {
 943                         // avoid reentrance
 944                         subdivide = false;
 945                         // subdivide curve =&gt; callback with subdivided parts:
 946                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 947                                                                orCode, this);
 948                         // reentrance is done:
 949                         subdivide = true;
 950                         if (ret) {
 951                             return;
 952                         }
 953                     }
 954                     // already subdivided so render it
 955                 } else {
 956                     this.cOutCode = outcode3;
 957                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 958                     return;
 959                 }
 960             }
 961 
 962             this.cOutCode = outcode3;
 963 
 964             if (this.outside) {
 965                 this.outside = false;
 966                 // Adjust current index, phase &amp; dash:
 967                 skipLen();
 968             }
 969         }
 970         _curveTo(x1, y1, x2, y2, x3, y3);
 971     }
 972 
 973     private void _curveTo(final double x1, final double y1,
 974                           final double x2, final double y2,
 975                           final double x3, final double y3)
 976     {
 977         final double[] _curCurvepts = curCurvepts;
 978 
 979         // monotonize curve:
 980         final CurveBasicMonotonizer monotonizer
 981             = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);
 982 
 983         final int nSplits = monotonizer.nbSplits;
 984         final double[] mid = monotonizer.middle;
 985 
 986         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
 987             // optimize arraycopy (8 values faster than 6 = type):
 988             System.arraycopy(mid, off, _curCurvepts, 0, 8);
 989 
 990             somethingTo(8);
 991         }
 992     }
 993 
 994     private void skipCurveTo(final double x1, final double y1,
 995                              final double x2, final double y2,
 996                              final double x3, final double y3)
 997     {
 998         final double[] _curCurvepts = curCurvepts;
 999         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1000         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1001         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1002         _curCurvepts[6] = x3;  _curCurvepts[7] = y3;
1003 
1004         skipSomethingTo(8);
1005 
1006         this.cx0 = x3;
1007         this.cy0 = y3;
1008     }
1009 
1010     @Override
1011     public void quadTo(final double x1, final double y1,
1012                        final double x2, final double y2)
1013     {
1014         final int outcode0 = this.cOutCode;
1015 
1016         if (clipRect != null) {
1017             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1018             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1019 
1020             // Should clip
1021             final int orCode = (outcode0 | outcode1 | outcode2);
1022             if (orCode != 0) {
1023                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1024 
1025                 // basic rejection criteria:
1026                 if (sideCode == 0) {
1027                     // ovelap clip:
1028                     if (subdivide) {
1029                         // avoid reentrance
1030                         subdivide = false;
1031                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1032                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1033                                                               x2, y2, orCode, this);
1034                         // reentrance is done:
1035                         subdivide = true;
1036                         if (ret) {
1037                             return;
1038                         }
1039                     }
1040                     // already subdivided so render it
1041                 } else {
1042                     this.cOutCode = outcode2;
1043                     skipQuadTo(x1, y1, x2, y2);
1044                     return;
1045                 }
1046             }
1047 
1048             this.cOutCode = outcode2;
1049 
1050             if (this.outside) {
1051                 this.outside = false;
1052                 // Adjust current index, phase &amp; dash:
1053                 skipLen();
1054             }
1055         }
1056         _quadTo(x1, y1, x2, y2);
1057     }
1058 
1059     private void _quadTo(final double x1, final double y1,
1060                          final double x2, final double y2)
1061     {
1062         final double[] _curCurvepts = curCurvepts;
1063 
1064         // monotonize quad:
1065         final CurveBasicMonotonizer monotonizer
1066             = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);
1067 
1068         final int nSplits = monotonizer.nbSplits;
1069         final double[] mid = monotonizer.middle;
1070 
1071         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1072             // optimize arraycopy (8 values faster than 6 = type):
1073             System.arraycopy(mid, off, _curCurvepts, 0, 8);
1074 
1075             somethingTo(6);
1076         }
1077     }
1078 
1079     private void skipQuadTo(final double x1, final double y1,
1080                             final double x2, final double y2)
1081     {
1082         final double[] _curCurvepts = curCurvepts;
1083         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1084         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1085         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1086 
1087         skipSomethingTo(6);
1088 
1089         this.cx0 = x2;
1090         this.cy0 = y2;
1091     }
1092 
1093     @Override
1094     public void closePath() {
1095         if (cx0 != sx0 || cy0 != sy0) {
1096             lineTo(sx0, sy0);
1097         }
1098         if (firstSegidx != 0) {
1099             if (!dashOn || needsMoveTo) {
1100                 out.moveTo(sx0, sy0);
1101             }
1102             emitFirstSegments();
1103         }
1104         moveTo(sx0, sy0);
1105     }
1106 
1107     @Override
1108     public void pathDone() {
1109         if (firstSegidx != 0) {
1110             out.moveTo(sx0, sy0);
1111             emitFirstSegments();
1112         }
1113         out.pathDone();
1114 
1115         // Dispose this instance:
1116         dispose();
1117     }
1118 
1119     @Override
1120     public long getNativeConsumer() {
1121         throw new InternalError(&quot;DDasher does not use a native consumer&quot;);
1122     }
1123 }
1124 
    </pre>
  </body>
</html>