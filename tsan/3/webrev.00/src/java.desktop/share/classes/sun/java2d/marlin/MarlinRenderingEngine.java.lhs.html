<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/java2d/marlin/MarlinRenderingEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.awt.BasicStroke;
  29 import java.awt.Shape;
  30 import java.awt.geom.AffineTransform;
  31 import java.awt.geom.Path2D;
  32 import java.awt.geom.PathIterator;
  33 import java.security.AccessController;
  34 import java.util.Arrays;
  35 import static sun.java2d.marlin.MarlinUtils.logInfo;
  36 import sun.awt.geom.PathConsumer2D;
  37 import sun.java2d.ReentrantContextProvider;
  38 import sun.java2d.ReentrantContextProviderCLQ;
  39 import sun.java2d.ReentrantContextProviderTL;
  40 import sun.java2d.pipe.AATileGenerator;
  41 import sun.java2d.pipe.Region;
  42 import sun.java2d.pipe.RenderingEngine;
  43 import sun.security.action.GetPropertyAction;
  44 
  45 /**
  46  * Marlin RendererEngine implementation (derived from Pisces)
  47  */
  48 public final class MarlinRenderingEngine extends RenderingEngine
  49                                          implements MarlinConst
  50 {
  51     // slightly slower ~2% if enabled stroker clipping (lines) but skipping cap / join handling is few percents faster in specific cases
  52     static final boolean DISABLE_2ND_STROKER_CLIPPING = true;
  53 
  54     static final boolean DO_TRACE_PATH = false;
  55 
  56     static final boolean DO_CLIP = MarlinProperties.isDoClip();
  57     static final boolean DO_CLIP_FILL = true;
  58     static final boolean DO_CLIP_RUNTIME_ENABLE = MarlinProperties.isDoClipRuntimeFlag();
  59 
  60     private static final float MIN_PEN_SIZE = 1.0f / MIN_SUBPIXELS;
  61 
  62     static final float UPPER_BND = Float.MAX_VALUE / 2.0f;
  63     static final float LOWER_BND = -UPPER_BND;
  64 
  65     private enum NormMode {
  66         ON_WITH_AA {
  67             @Override
  68             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  69                                                     final PathIterator src)
  70             {
  71                 // NormalizingPathIterator NearestPixelCenter:
  72                 return rdrCtx.nPCPathIterator.init(src);
  73             }
  74         },
  75         ON_NO_AA{
  76             @Override
  77             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  78                                                     final PathIterator src)
  79             {
  80                 // NearestPixel NormalizingPathIterator:
  81                 return rdrCtx.nPQPathIterator.init(src);
  82             }
  83         },
  84         OFF{
  85             @Override
  86             PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,
  87                                                     final PathIterator src)
  88             {
  89                 // return original path iterator if normalization is disabled:
  90                 return src;
  91             }
  92         };
  93 
  94         abstract PathIterator getNormalizingPathIterator(RendererContext rdrCtx,
  95                                                          PathIterator src);
  96     }
  97 
  98     /**
  99      * Public constructor
 100      */
 101     public MarlinRenderingEngine() {
 102         super();
 103         logSettings(MarlinRenderingEngine.class.getName());
 104     }
 105 
 106     /**
 107      * Create a widened path as specified by the parameters.
 108      * &lt;p&gt;
 109      * The specified {@code src} {@link Shape} is widened according
 110      * to the specified attribute parameters as per the
 111      * {@link BasicStroke} specification.
 112      *
 113      * @param src the source path to be widened
 114      * @param width the width of the widened path as per {@code BasicStroke}
 115      * @param caps the end cap decorations as per {@code BasicStroke}
 116      * @param join the segment join decorations as per {@code BasicStroke}
 117      * @param miterlimit the miter limit as per {@code BasicStroke}
 118      * @param dashes the dash length array as per {@code BasicStroke}
 119      * @param dashphase the initial dash phase as per {@code BasicStroke}
 120      * @return the widened path stored in a new {@code Shape} object
 121      * @since 1.7
 122      */
 123     @Override
 124     public Shape createStrokedShape(Shape src,
 125                                     float width,
 126                                     int caps,
 127                                     int join,
 128                                     float miterlimit,
 129                                     float[] dashes,
 130                                     float dashphase)
 131     {
 132         final RendererContext rdrCtx = getRendererContext();
 133         try {
 134             // initialize a large copyable Path2D to avoid a lot of array growing:
 135             final Path2D.Float p2d = rdrCtx.getPath2D();
 136 
 137             strokeTo(rdrCtx,
 138                      src,
 139                      null,
 140                      width,
 141                      NormMode.OFF,
 142                      caps,
 143                      join,
 144                      miterlimit,
 145                      dashes,
 146                      dashphase,
 147                      rdrCtx.transformerPC2D.wrapPath2D(p2d)
 148                     );
 149 
 150             // Use Path2D copy constructor (trim)
 151             return new Path2D.Float(p2d);
 152 
 153         } finally {
 154             // recycle the RendererContext instance
 155             returnRendererContext(rdrCtx);
 156         }
 157     }
 158 
 159     /**
 160      * Sends the geometry for a widened path as specified by the parameters
 161      * to the specified consumer.
 162      * &lt;p&gt;
 163      * The specified {@code src} {@link Shape} is widened according
 164      * to the parameters specified by the {@link BasicStroke} object.
 165      * Adjustments are made to the path as appropriate for the
 166      * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the
 167      * {@code normalize} boolean parameter is true.
 168      * Adjustments are made to the path as appropriate for the
 169      * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the
 170      * {@code antialias} boolean parameter is true.
 171      * &lt;p&gt;
 172      * The geometry of the widened path is forwarded to the indicated
 173      * {@link PathConsumer2D} object as it is calculated.
 174      *
 175      * @param src the source path to be widened
 176      * @param bs the {@code BasicSroke} object specifying the
 177      *           decorations to be applied to the widened path
 178      * @param normalize indicates whether stroke normalization should
 179      *                  be applied
 180      * @param antialias indicates whether or not adjustments appropriate
 181      *                  to antialiased rendering should be applied
 182      * @param consumer the {@code PathConsumer2D} instance to forward
 183      *                 the widened geometry to
 184      * @since 1.7
 185      */
 186     @Override
 187     public void strokeTo(Shape src,
 188                          AffineTransform at,
 189                          BasicStroke bs,
 190                          boolean thin,
 191                          boolean normalize,
 192                          boolean antialias,
 193                          final PathConsumer2D consumer)
 194     {
 195         final NormMode norm = (normalize) ?
 196                 ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)
 197                 : NormMode.OFF;
 198 
 199         final RendererContext rdrCtx = getRendererContext();
 200         try {
 201             strokeTo(rdrCtx, src, at, bs, thin, norm, antialias, consumer);
 202         } finally {
 203             // recycle the RendererContext instance
 204             returnRendererContext(rdrCtx);
 205         }
 206     }
 207 
 208     void strokeTo(final RendererContext rdrCtx,
 209                   Shape src,
 210                   AffineTransform at,
 211                   BasicStroke bs,
 212                   boolean thin,
 213                   NormMode normalize,
 214                   boolean antialias,
 215                   PathConsumer2D pc2d)
 216     {
 217         float lw;
 218         if (thin) {
 219             if (antialias) {
 220                 lw = userSpaceLineWidth(at, MIN_PEN_SIZE);
 221             } else {
 222                 lw = userSpaceLineWidth(at, 1.0f);
 223             }
 224         } else {
 225             lw = bs.getLineWidth();
 226         }
 227         strokeTo(rdrCtx,
 228                  src,
 229                  at,
 230                  lw,
 231                  normalize,
 232                  bs.getEndCap(),
 233                  bs.getLineJoin(),
 234                  bs.getMiterLimit(),
 235                  bs.getDashArray(),
 236                  bs.getDashPhase(),
 237                  pc2d);
 238     }
 239 
 240     private float userSpaceLineWidth(AffineTransform at, float lw) {
 241 
 242         float widthScale;
 243 
 244         if (at == null) {
 245             widthScale = 1.0f;
 246         } else if ((at.getType() &amp; (AffineTransform.TYPE_GENERAL_TRANSFORM  |
 247                                     AffineTransform.TYPE_GENERAL_SCALE)) != 0) {
<a name="1" id="anc1"></a><span class="line-modified"> 248             widthScale = (float)Math.sqrt(at.getDeterminant());</span>

 249         } else {
 250             // First calculate the &quot;maximum scale&quot; of this transform.
 251             double A = at.getScaleX();       // m00
 252             double C = at.getShearX();       // m01
 253             double B = at.getShearY();       // m10
 254             double D = at.getScaleY();       // m11
 255 
 256             /*
 257              * Given a 2 x 2 affine matrix [ A B ] such that
 258              *                             [ C D ]
 259              * v&#39; = [x&#39; y&#39;] = [Ax + Cy, Bx + Dy], we want to
 260              * find the maximum magnitude (norm) of the vector v&#39;
 261              * with the constraint (x^2 + y^2 = 1).
 262              * The equation to maximize is
 263              *     |v&#39;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
 264              * or  |v&#39;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
 265              * Since sqrt is monotonic we can maximize |v&#39;|^2
 266              * instead and plug in the substitution y = sqrt(1 - x^2).
 267              * Trigonometric equalities can then be used to get
 268              * rid of most of the sqrt terms.
 269              */
 270 
 271             double EA = A*A + B*B;          // x^2 coefficient
 272             double EB = 2.0d * (A*C + B*D); // xy coefficient
 273             double EC = C*C + D*D;          // y^2 coefficient
 274 
 275             /*
 276              * There is a lot of calculus omitted here.
 277              *
 278              * Conceptually, in the interests of understanding the
 279              * terms that the calculus produced we can consider
 280              * that EA and EC end up providing the lengths along
 281              * the major axes and the hypot term ends up being an
 282              * adjustment for the additional length along the off-axis
 283              * angle of rotated or sheared ellipses as well as an
 284              * adjustment for the fact that the equation below
 285              * averages the two major axis lengths.  (Notice that
 286              * the hypot term contains a part which resolves to the
 287              * difference of these two axis lengths in the absence
 288              * of rotation.)
 289              *
 290              * In the calculus, the ratio of the EB and (EA-EC) terms
 291              * ends up being the tangent of 2*theta where theta is
 292              * the angle that the long axis of the ellipse makes
 293              * with the horizontal axis.  Thus, this equation is
 294              * calculating the length of the hypotenuse of a triangle
 295              * along that axis.
 296              */
 297 
 298             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 299             // sqrt omitted, compare to squared limits below.
 300             double widthsquared = ((EA + EC + hypot) / 2.0d);
 301 
 302             widthScale = (float)Math.sqrt(widthsquared);
 303         }
 304 
 305         return (lw / widthScale);
 306     }
 307 
 308     void strokeTo(final RendererContext rdrCtx,
 309                   Shape src,
 310                   AffineTransform at,
 311                   float width,
 312                   NormMode norm,
 313                   int caps,
 314                   int join,
 315                   float miterlimit,
 316                   float[] dashes,
 317                   float dashphase,
 318                   PathConsumer2D pc2d)
 319     {
 320         // We use strokerat so that in Stroker and Dasher we can work only
 321         // with the pre-transformation coordinates. This will repeat a lot of
 322         // computations done in the path iterator, but the alternative is to
 323         // work with transformed paths and compute untransformed coordinates
 324         // as needed. This would be faster but I do not think the complexity
 325         // of working with both untransformed and transformed coordinates in
 326         // the same code is worth it.
 327         // However, if a path&#39;s width is constant after a transformation,
 328         // we can skip all this untransforming.
 329 
 330         // As pathTo() will check transformed coordinates for invalid values
 331         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 332         // transformation before the path processing.
 333         AffineTransform strokerat = null;
 334 
 335         int dashLen = -1;
 336         boolean recycleDashes = false;
 337 
 338         if (at != null &amp;&amp; !at.isIdentity()) {
 339             final double a = at.getScaleX();
 340             final double b = at.getShearX();
 341             final double c = at.getShearY();
 342             final double d = at.getScaleY();
 343             final double det = a * d - c * b;
 344 
 345             if (Math.abs(det) &lt;= (2.0f * Float.MIN_VALUE)) {
 346                 // this rendering engine takes one dimensional curves and turns
 347                 // them into 2D shapes by giving them width.
 348                 // However, if everything is to be passed through a singular
 349                 // transformation, these 2D shapes will be squashed down to 1D
 350                 // again so, nothing can be drawn.
 351 
 352                 // Every path needs an initial moveTo and a pathDone. If these
 353                 // are not there this causes a SIGSEGV in libawt.so (at the time
 354                 // of writing of this comment (September 16, 2010)). Actually,
 355                 // I am not sure if the moveTo is necessary to avoid the SIGSEGV
 356                 // but the pathDone is definitely needed.
 357                 pc2d.moveTo(0.0f, 0.0f);
 358                 pc2d.pathDone();
 359                 return;
 360             }
 361 
 362             // If the transform is a constant multiple of an orthogonal transformation
 363             // then every length is just multiplied by a constant, so we just
 364             // need to transform input paths to stroker and tell stroker
 365             // the scaled width. This condition is satisfied if
 366             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 367             // leave a bit of room for error.
 368             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
 369                 final float scale = (float) Math.sqrt(a*a + c*c);
 370 
 371                 if (dashes != null) {
 372                     recycleDashes = true;
 373                     dashLen = dashes.length;
 374                     dashes = rdrCtx.dasher.copyDashArray(dashes);
 375                     for (int i = 0; i &lt; dashLen; i++) {
 376                         dashes[i] *= scale;
 377                     }
 378                     dashphase *= scale;
 379                 }
 380                 width *= scale;
 381 
 382                 // by now strokerat == null. Input paths to
 383                 // stroker (and maybe dasher) will have the full transform at
 384                 // applied to them and nothing will happen to the output paths.
 385             } else {
 386                 strokerat = at;
 387 
 388                 // by now strokerat == at. Input paths to
 389                 // stroker (and maybe dasher) will have the full transform at
 390                 // applied to them, then they will be normalized, and then
 391                 // the inverse of *only the non translation part of at* will
 392                 // be applied to the normalized paths. This won&#39;t cause problems
 393                 // in stroker, because, suppose at = T*A, where T is just the
 394                 // translation part of at, and A is the rest. T*A has already
 395                 // been applied to Stroker/Dasher&#39;s input. Then Ainv will be
 396                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 397                 // which means that none of stroker&#39;s assumptions about its
 398                 // input will be violated. After all this, A will be applied
 399                 // to stroker&#39;s output.
 400             }
 401         } else {
 402             // either at is null or it&#39;s the identity. In either case
 403             // we don&#39;t transform the path.
 404             at = null;
 405         }
 406 
 407         final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 408 
 409         if (DO_TRACE_PATH) {
 410             // trace Stroker:
 411             pc2d = transformerPC2D.traceStroker(pc2d);
 412         }
 413 
 414         if (USE_SIMPLIFIER) {
 415             // Use simplifier after stroker before Renderer
 416             // to remove collinear segments (notably due to cap square)
 417             pc2d = rdrCtx.simplifier.init(pc2d);
 418         }
 419 
 420         // deltaTransformConsumer may adjust the clip rectangle:
 421         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 422 
 423         // stroker will adjust the clip rectangle (width / miter limit):
 424         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit,
 425                 (dashes == null));
 426 
 427         // Curve Monotizer:
 428         rdrCtx.monotonizer.init(width);
 429 
 430         if (dashes != null) {
 431             if (!recycleDashes) {
 432                 dashLen = dashes.length;
 433             }
 434             if (DO_TRACE_PATH) {
 435                 pc2d = transformerPC2D.traceDasher(pc2d);
 436             }
 437             pc2d = rdrCtx.dasher.init(pc2d, dashes, dashLen, dashphase,
 438                                       recycleDashes);
 439 
 440             if (DISABLE_2ND_STROKER_CLIPPING) {
 441                 // disable stoker clipping
 442                 rdrCtx.stroker.disableClipping();
 443             }
 444 
 445         } else if (rdrCtx.doClip &amp;&amp; (caps != Stroker.CAP_BUTT)) {
 446             if (DO_TRACE_PATH) {
 447                 pc2d = transformerPC2D.traceClosedPathDetector(pc2d);
 448             }
 449 
 450             // If no dash and clip is enabled:
 451             // detect closedPaths (polygons) for caps
 452             pc2d = transformerPC2D.detectClosedPath(pc2d);
 453         }
 454         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 455 
 456         if (DO_TRACE_PATH) {
 457             // trace Input:
 458             pc2d = transformerPC2D.traceInput(pc2d);
 459         }
 460 
 461         final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 462                                          src.getPathIterator(at));
 463 
 464         pathTo(rdrCtx, pi, pc2d);
 465 
 466         /*
 467          * Pipeline seems to be:
 468          * shape.getPathIterator(at)
 469          * -&gt; (NormalizingPathIterator)
 470          * -&gt; (inverseDeltaTransformConsumer)
 471          * -&gt; (Dasher)
 472          * -&gt; Stroker
 473          * -&gt; (deltaTransformConsumer)
 474          *
 475          * -&gt; (CollinearSimplifier) to remove redundant segments
 476          *
 477          * -&gt; pc2d = Renderer (bounding box)
 478          */
 479     }
 480 
 481     private static boolean nearZero(final double num) {
 482         return Math.abs(num) &lt; 2.0d * Math.ulp(num);
 483     }
 484 
 485     abstract static class NormalizingPathIterator implements PathIterator {
 486 
 487         private PathIterator src;
 488 
 489         // the adjustment applied to the current position.
 490         private float curx_adjust, cury_adjust;
 491         // the adjustment applied to the last moveTo position.
 492         private float movx_adjust, movy_adjust;
 493 
 494         private final float[] tmp;
 495 
 496         NormalizingPathIterator(final float[] tmp) {
 497             this.tmp = tmp;
 498         }
 499 
 500         final NormalizingPathIterator init(final PathIterator src) {
 501             this.src = src;
 502             return this; // fluent API
 503         }
 504 
 505         /**
 506          * Disposes this path iterator:
 507          * clean up before reusing this instance
 508          */
 509         final void dispose() {
 510             // free source PathIterator:
 511             this.src = null;
 512         }
 513 
 514         @Override
 515         public final int currentSegment(final float[] coords) {
 516             int lastCoord;
 517             final int type = src.currentSegment(coords);
 518 
 519             switch(type) {
 520                 case PathIterator.SEG_MOVETO:
 521                 case PathIterator.SEG_LINETO:
 522                     lastCoord = 0;
 523                     break;
 524                 case PathIterator.SEG_QUADTO:
 525                     lastCoord = 2;
 526                     break;
 527                 case PathIterator.SEG_CUBICTO:
 528                     lastCoord = 4;
 529                     break;
 530                 case PathIterator.SEG_CLOSE:
 531                     // we don&#39;t want to deal with this case later. We just exit now
 532                     curx_adjust = movx_adjust;
 533                     cury_adjust = movy_adjust;
 534                     return type;
 535                 default:
 536                     throw new InternalError(&quot;Unrecognized curve type&quot;);
 537             }
 538 
 539             // normalize endpoint
 540             float coord, x_adjust, y_adjust;
 541 
 542             coord = coords[lastCoord];
 543             x_adjust = normCoord(coord); // new coord
 544             coords[lastCoord] = x_adjust;
 545             x_adjust -= coord;
 546 
 547             coord = coords[lastCoord + 1];
 548             y_adjust = normCoord(coord); // new coord
 549             coords[lastCoord + 1] = y_adjust;
 550             y_adjust -= coord;
 551 
 552             // now that the end points are done, normalize the control points
 553             switch(type) {
 554                 case PathIterator.SEG_MOVETO:
 555                     movx_adjust = x_adjust;
 556                     movy_adjust = y_adjust;
 557                     break;
 558                 case PathIterator.SEG_LINETO:
 559                     break;
 560                 case PathIterator.SEG_QUADTO:
 561                     coords[0] += (curx_adjust + x_adjust) / 2.0f;
 562                     coords[1] += (cury_adjust + y_adjust) / 2.0f;
 563                     break;
 564                 case PathIterator.SEG_CUBICTO:
 565                     coords[0] += curx_adjust;
 566                     coords[1] += cury_adjust;
 567                     coords[2] += x_adjust;
 568                     coords[3] += y_adjust;
 569                     break;
 570                 case PathIterator.SEG_CLOSE:
 571                     // handled earlier
 572                 default:
 573             }
 574             curx_adjust = x_adjust;
 575             cury_adjust = y_adjust;
 576             return type;
 577         }
 578 
 579         abstract float normCoord(final float coord);
 580 
 581         @Override
 582         public final int currentSegment(final double[] coords) {
 583             final float[] _tmp = tmp; // dirty
 584             int type = this.currentSegment(_tmp);
 585             for (int i = 0; i &lt; 6; i++) {
 586                 coords[i] = _tmp[i];
 587             }
 588             return type;
 589         }
 590 
 591         @Override
 592         public final int getWindingRule() {
 593             return src.getWindingRule();
 594         }
 595 
 596         @Override
 597         public final boolean isDone() {
 598             if (src.isDone()) {
 599                 // Dispose this instance:
 600                 dispose();
 601                 return true;
 602             }
 603             return false;
 604         }
 605 
 606         @Override
 607         public final void next() {
 608             src.next();
 609         }
 610 
 611         static final class NearestPixelCenter
 612                                 extends NormalizingPathIterator
 613         {
 614             NearestPixelCenter(final float[] tmp) {
 615                 super(tmp);
 616             }
 617 
 618             @Override
 619             float normCoord(final float coord) {
 620                 // round to nearest pixel center
 621                 return FloatMath.floor_f(coord) + 0.5f;
 622             }
 623         }
 624 
 625         static final class NearestPixelQuarter
 626                                 extends NormalizingPathIterator
 627         {
 628             NearestPixelQuarter(final float[] tmp) {
 629                 super(tmp);
 630             }
 631 
 632             @Override
 633             float normCoord(final float coord) {
 634                 // round to nearest (0.25, 0.25) pixel quarter
 635                 return FloatMath.floor_f(coord + 0.25f) + 0.25f;
 636             }
 637         }
 638     }
 639 
 640     private static void pathTo(final RendererContext rdrCtx, final PathIterator pi,
 641                                PathConsumer2D pc2d)
 642     {
 643         if (USE_PATH_SIMPLIFIER) {
 644             // Use path simplifier at the first step
 645             // to remove useless points
 646             pc2d = rdrCtx.pathSimplifier.init(pc2d);
 647         }
 648 
 649         // mark context as DIRTY:
 650         rdrCtx.dirty = true;
 651 
 652         pathToLoop(rdrCtx.float6, pi, pc2d);
 653 
 654         // mark context as CLEAN:
 655         rdrCtx.dirty = false;
 656     }
 657 
 658     private static void pathToLoop(final float[] coords, final PathIterator pi,
 659                                    final PathConsumer2D pc2d)
 660     {
 661         // ported from DuctusRenderingEngine.feedConsumer() but simplified:
 662         // - removed skip flag = !subpathStarted
 663         // - removed pathClosed (ie subpathStarted not set to false)
 664         boolean subpathStarted = false;
 665 
 666         for (; !pi.isDone(); pi.next()) {
 667             switch (pi.currentSegment(coords)) {
 668             case PathIterator.SEG_MOVETO:
 669                 /* Checking SEG_MOVETO coordinates if they are out of the
 670                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 671                  * and Infinity values. Skipping next path segment in case of
 672                  * invalid data.
 673                  */
 674                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 675                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 676                 {
 677                     pc2d.moveTo(coords[0], coords[1]);
 678                     subpathStarted = true;
 679                 }
 680                 break;
 681             case PathIterator.SEG_LINETO:
 682                 /* Checking SEG_LINETO coordinates if they are out of the
 683                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 684                  * and Infinity values. Ignoring current path segment in case
 685                  * of invalid data. If segment is skipped its endpoint
 686                  * (if valid) is used to begin new subpath.
 687                  */
 688                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 689                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 690                 {
 691                     if (subpathStarted) {
 692                         pc2d.lineTo(coords[0], coords[1]);
 693                     } else {
 694                         pc2d.moveTo(coords[0], coords[1]);
 695                         subpathStarted = true;
 696                     }
 697                 }
 698                 break;
 699             case PathIterator.SEG_QUADTO:
 700                 // Quadratic curves take two points
 701                 /* Checking SEG_QUADTO coordinates if they are out of the
 702                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 703                  * and Infinity values. Ignoring current path segment in case
 704                  * of invalid endpoints&#39;s data. Equivalent to the SEG_LINETO
 705                  * if endpoint coordinates are valid but there are invalid data
 706                  * among other coordinates
 707                  */
 708                 if (coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 709                     coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 710                 {
 711                     if (subpathStarted) {
 712                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 713                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 714                         {
 715                             pc2d.quadTo(coords[0], coords[1],
 716                                         coords[2], coords[3]);
 717                         } else {
 718                             pc2d.lineTo(coords[2], coords[3]);
 719                         }
 720                     } else {
 721                         pc2d.moveTo(coords[2], coords[3]);
 722                         subpathStarted = true;
 723                     }
 724                 }
 725                 break;
 726             case PathIterator.SEG_CUBICTO:
 727                 // Cubic curves take three points
 728                 /* Checking SEG_CUBICTO coordinates if they are out of the
 729                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 730                  * and Infinity values. Ignoring current path segment in case
 731                  * of invalid endpoints&#39;s data. Equivalent to the SEG_LINETO
 732                  * if endpoint coordinates are valid but there are invalid data
 733                  * among other coordinates
 734                  */
 735                 if (coords[4] &lt; UPPER_BND &amp;&amp; coords[4] &gt; LOWER_BND &amp;&amp;
 736                     coords[5] &lt; UPPER_BND &amp;&amp; coords[5] &gt; LOWER_BND)
 737                 {
 738                     if (subpathStarted) {
 739                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 740                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND &amp;&amp;
 741                             coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 742                             coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 743                         {
 744                             pc2d.curveTo(coords[0], coords[1],
 745                                          coords[2], coords[3],
 746                                          coords[4], coords[5]);
 747                         } else {
 748                             pc2d.lineTo(coords[4], coords[5]);
 749                         }
 750                     } else {
 751                         pc2d.moveTo(coords[4], coords[5]);
 752                         subpathStarted = true;
 753                     }
 754                 }
 755                 break;
 756             case PathIterator.SEG_CLOSE:
 757                 if (subpathStarted) {
 758                     pc2d.closePath();
 759                     // do not set subpathStarted to false
 760                     // in case of missing moveTo() after close()
 761                 }
 762                 break;
 763             default:
 764             }
 765         }
 766         pc2d.pathDone();
 767     }
 768 
 769     /**
 770      * Construct an antialiased tile generator for the given shape with
 771      * the given rendering attributes and store the bounds of the tile
 772      * iteration in the bbox parameter.
 773      * The {@code at} parameter specifies a transform that should affect
 774      * both the shape and the {@code BasicStroke} attributes.
 775      * The {@code clip} parameter specifies the current clip in effect
 776      * in device coordinates and can be used to prune the data for the
 777      * operation, but the renderer is not required to perform any
 778      * clipping.
 779      * If the {@code BasicStroke} parameter is null then the shape
 780      * should be filled as is, otherwise the attributes of the
 781      * {@code BasicStroke} should be used to specify a draw operation.
 782      * The {@code thin} parameter indicates whether or not the
 783      * transformed {@code BasicStroke} represents coordinates smaller
 784      * than the minimum resolution of the antialiasing rasterizer as
 785      * specified by the {@code getMinimumAAPenWidth()} method.
 786      * &lt;p&gt;
 787      * Upon returning, this method will fill the {@code bbox} parameter
 788      * with 4 values indicating the bounds of the iteration of the
 789      * tile generator.
 790      * The iteration order of the tiles will be as specified by the
 791      * pseudo-code:
 792      * &lt;pre&gt;
 793      *     for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
 794      *         for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
 795      *         }
 796      *     }
 797      * &lt;/pre&gt;
 798      * If there is no output to be rendered, this method may return
 799      * null.
 800      *
 801      * @param s the shape to be rendered (fill or draw)
 802      * @param at the transform to be applied to the shape and the
 803      *           stroke attributes
 804      * @param clip the current clip in effect in device coordinates
 805      * @param bs if non-null, a {@code BasicStroke} whose attributes
 806      *           should be applied to this operation
 807      * @param thin true if the transformed stroke attributes are smaller
 808      *             than the minimum dropout pen width
 809      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 810      *                  {@code RenderingHint} is in effect
 811      * @param bbox returns the bounds of the iteration
 812      * @return the {@code AATileGenerator} instance to be consulted
 813      *         for tile coverages, or null if there is no output to render
 814      * @since 1.7
 815      */
 816     @Override
 817     public AATileGenerator getAATileGenerator(Shape s,
 818                                               AffineTransform at,
 819                                               Region clip,
 820                                               BasicStroke bs,
 821                                               boolean thin,
 822                                               boolean normalize,
 823                                               int[] bbox)
 824     {
 825         MarlinTileGenerator ptg = null;
 826         Renderer r = null;
 827 
 828         final RendererContext rdrCtx = getRendererContext();
 829         try {
 830             if (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE &amp;&amp; MarlinProperties.isDoClipAtRuntime())) {
 831                 // Define the initial clip bounds:
 832                 final float[] clipRect = rdrCtx.clipRect;
 833 
 834                 // Adjust the clipping rectangle with the renderer offsets
 835                 final float rdrOffX = Renderer.RDR_OFFSET_X;
 836                 final float rdrOffY = Renderer.RDR_OFFSET_Y;
 837 
 838                 // add a small rounding error:
 839                 final float margin = 1e-3f;
 840 
 841                 clipRect[0] = clip.getLoY()
 842                                 - margin + rdrOffY;
 843                 clipRect[1] = clip.getLoY() + clip.getHeight()
 844                                 + margin + rdrOffY;
 845                 clipRect[2] = clip.getLoX()
 846                                 - margin + rdrOffX;
 847                 clipRect[3] = clip.getLoX() + clip.getWidth()
 848                                 + margin + rdrOffX;
 849 
 850                 if (MarlinConst.DO_LOG_CLIP) {
 851                     MarlinUtils.logInfo(&quot;clipRect (clip): &quot;
 852                                         + Arrays.toString(rdrCtx.clipRect));
 853                 }
 854 
 855                 // Enable clipping:
 856                 rdrCtx.doClip = true;
 857             }
 858 
 859             // Test if at is identity:
 860             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 861                                         : null;
 862 
 863             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 864 
 865             if (bs == null) {
 866                 // fill shape:
 867                 final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 868                                                  s.getPathIterator(_at));
 869 
 870                 // note: Winding rule may be EvenOdd ONLY for fill operations !
 871                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 872                                          clip.getWidth(), clip.getHeight(),
 873                                          pi.getWindingRule());
 874 
 875                 PathConsumer2D pc2d = r;
 876 
 877                 if (DO_CLIP_FILL &amp;&amp; rdrCtx.doClip) {
 878                     if (DO_TRACE_PATH) {
 879                         // trace Filler:
 880                         pc2d = rdrCtx.transformerPC2D.traceFiller(pc2d);
 881                     }
 882                     pc2d = rdrCtx.transformerPC2D.pathClipper(pc2d);
 883                 }
 884 
 885                 if (DO_TRACE_PATH) {
 886                     // trace Input:
 887                     pc2d = rdrCtx.transformerPC2D.traceInput(pc2d);
 888                 }
 889                 pathTo(rdrCtx, pi, pc2d);
 890 
 891             } else {
 892                 // draw shape with given stroke:
 893                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 894                                          clip.getWidth(), clip.getHeight(),
 895                                          WIND_NON_ZERO);
 896 
 897                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 898             }
 899             if (r.endRendering()) {
 900                 ptg = rdrCtx.ptg.init();
 901                 ptg.getBbox(bbox);
 902                 // note: do not returnRendererContext(rdrCtx)
 903                 // as it will be called later by MarlinTileGenerator.dispose()
 904                 r = null;
 905             }
 906         } finally {
 907             if (r != null) {
 908                 // dispose renderer and recycle the RendererContext instance:
 909                 r.dispose();
 910             }
 911         }
 912 
 913         // Return null to cancel AA tile generation (nothing to render)
 914         return ptg;
 915     }
 916 
 917     @Override
 918     public AATileGenerator getAATileGenerator(double x, double y,
 919                                               double dx1, double dy1,
 920                                               double dx2, double dy2,
 921                                               double lw1, double lw2,
 922                                               Region clip,
 923                                               int[] bbox)
 924     {
 925         // REMIND: Deal with large coordinates!
 926         double ldx1, ldy1, ldx2, ldy2;
 927         boolean innerpgram = (lw1 &gt; 0.0d &amp;&amp; lw2 &gt; 0.0d);
 928 
 929         if (innerpgram) {
 930             ldx1 = dx1 * lw1;
 931             ldy1 = dy1 * lw1;
 932             ldx2 = dx2 * lw2;
 933             ldy2 = dy2 * lw2;
 934             x -= (ldx1 + ldx2) / 2.0d;
 935             y -= (ldy1 + ldy2) / 2.0d;
 936             dx1 += ldx1;
 937             dy1 += ldy1;
 938             dx2 += ldx2;
 939             dy2 += ldy2;
 940             if (lw1 &gt; 1.0d &amp;&amp; lw2 &gt; 1.0d) {
 941                 // Inner parallelogram was entirely consumed by stroke...
 942                 innerpgram = false;
 943             }
 944         } else {
 945             ldx1 = ldy1 = ldx2 = ldy2 = 0.0d;
 946         }
 947 
 948         MarlinTileGenerator ptg = null;
 949         Renderer r = null;
 950 
 951         final RendererContext rdrCtx = getRendererContext();
 952         try {
 953             r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 954                                      clip.getWidth(), clip.getHeight(),
 955                                      WIND_EVEN_ODD);
 956 
 957             r.moveTo((float) x, (float) y);
 958             r.lineTo((float) (x+dx1), (float) (y+dy1));
 959             r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));
 960             r.lineTo((float) (x+dx2), (float) (y+dy2));
 961             r.closePath();
 962 
 963             if (innerpgram) {
 964                 x += ldx1 + ldx2;
 965                 y += ldy1 + ldy2;
 966                 dx1 -= 2.0d * ldx1;
 967                 dy1 -= 2.0d * ldy1;
 968                 dx2 -= 2.0d * ldx2;
 969                 dy2 -= 2.0d * ldy2;
 970                 r.moveTo((float) x, (float) y);
 971                 r.lineTo((float) (x+dx1), (float) (y+dy1));
 972                 r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));
 973                 r.lineTo((float) (x+dx2), (float) (y+dy2));
 974                 r.closePath();
 975             }
 976             r.pathDone();
 977 
 978             if (r.endRendering()) {
 979                 ptg = rdrCtx.ptg.init();
 980                 ptg.getBbox(bbox);
 981                 // note: do not returnRendererContext(rdrCtx)
 982                 // as it will be called later by MarlinTileGenerator.dispose()
 983                 r = null;
 984             }
 985         } finally {
 986             if (r != null) {
 987                 // dispose renderer and recycle the RendererContext instance:
 988                 r.dispose();
 989             }
 990         }
 991 
 992         // Return null to cancel AA tile generation (nothing to render)
 993         return ptg;
 994     }
 995 
 996     /**
 997      * Returns the minimum pen width that the antialiasing rasterizer
 998      * can represent without dropouts occuring.
 999      * @since 1.7
1000      */
1001     @Override
1002     public float getMinimumAAPenSize() {
1003         return MIN_PEN_SIZE;
1004     }
1005 
1006     static {
1007         if (PathIterator.WIND_NON_ZERO != WIND_NON_ZERO ||
1008             PathIterator.WIND_EVEN_ODD != WIND_EVEN_ODD ||
1009             BasicStroke.JOIN_MITER != JOIN_MITER ||
1010             BasicStroke.JOIN_ROUND != JOIN_ROUND ||
1011             BasicStroke.JOIN_BEVEL != JOIN_BEVEL ||
1012             BasicStroke.CAP_BUTT != CAP_BUTT ||
1013             BasicStroke.CAP_ROUND != CAP_ROUND ||
1014             BasicStroke.CAP_SQUARE != CAP_SQUARE)
1015         {
1016             throw new InternalError(&quot;mismatched renderer constants&quot;);
1017         }
1018     }
1019 
1020     // --- RendererContext handling ---
1021     // use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext
1022     private static final boolean USE_THREAD_LOCAL;
1023 
1024     // reference type stored in either TL or CLQ
1025     static final int REF_TYPE;
1026 
1027     // Per-thread RendererContext
1028     private static final ReentrantContextProvider&lt;RendererContext&gt; RDR_CTX_PROVIDER;
1029 
1030     // Static initializer to use TL or CLQ mode
1031     static {
1032         USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();
1033 
1034         // Soft reference by default:
1035         final String refType = AccessController.doPrivileged(
1036                             new GetPropertyAction(&quot;sun.java2d.renderer.useRef&quot;,
1037                             &quot;soft&quot;));
1038         switch (refType) {
1039             default:
1040             case &quot;soft&quot;:
1041                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
1042                 break;
1043             case &quot;weak&quot;:
1044                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
1045                 break;
1046             case &quot;hard&quot;:
1047                 REF_TYPE = ReentrantContextProvider.REF_HARD;
1048                 break;
1049         }
1050 
1051         if (USE_THREAD_LOCAL) {
1052             RDR_CTX_PROVIDER = new ReentrantContextProviderTL&lt;RendererContext&gt;(REF_TYPE)
1053                 {
1054                     @Override
1055                     protected RendererContext newContext() {
1056                         return RendererContext.createContext();
1057                     }
1058                 };
1059         } else {
1060             RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ&lt;RendererContext&gt;(REF_TYPE)
1061                 {
1062                     @Override
1063                     protected RendererContext newContext() {
1064                         return RendererContext.createContext();
1065                     }
1066                 };
1067         }
1068     }
1069 
1070     private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;
1071 
1072     private static void logSettings(final String reClass) {
1073         // log information at startup
1074         if (SETTINGS_LOGGED) {
1075             return;
1076         }
1077         SETTINGS_LOGGED = true;
1078 
1079         String refType;
1080         switch (REF_TYPE) {
1081             default:
1082             case ReentrantContextProvider.REF_HARD:
1083                 refType = &quot;hard&quot;;
1084                 break;
1085             case ReentrantContextProvider.REF_SOFT:
1086                 refType = &quot;soft&quot;;
1087                 break;
1088             case ReentrantContextProvider.REF_WEAK:
1089                 refType = &quot;weak&quot;;
1090                 break;
1091         }
1092 
1093         logInfo(&quot;==========================================================&quot;
1094                 + &quot;=====================&quot;);
1095 
1096         logInfo(&quot;Marlin software rasterizer           = ENABLED&quot;);
1097         logInfo(&quot;Version                              = [&quot;
1098                 + Version.getVersion() + &quot;]&quot;);
1099         logInfo(&quot;sun.java2d.renderer                  = &quot;
1100                 + reClass);
1101         logInfo(&quot;sun.java2d.renderer.useThreadLocal   = &quot;
1102                 + USE_THREAD_LOCAL);
1103         logInfo(&quot;sun.java2d.renderer.useRef           = &quot;
1104                 + refType);
1105 
1106         logInfo(&quot;sun.java2d.renderer.edges            = &quot;
1107                 + MarlinConst.INITIAL_EDGES_COUNT);
1108         logInfo(&quot;sun.java2d.renderer.pixelWidth       = &quot;
1109                 + MarlinConst.INITIAL_PIXEL_WIDTH);
1110         logInfo(&quot;sun.java2d.renderer.pixelHeight      = &quot;
1111                 + MarlinConst.INITIAL_PIXEL_HEIGHT);
1112 
1113         logInfo(&quot;sun.java2d.renderer.subPixel_log2_X  = &quot;
1114                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1115         logInfo(&quot;sun.java2d.renderer.subPixel_log2_Y  = &quot;
1116                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1117 
1118         logInfo(&quot;sun.java2d.renderer.tileSize_log2    = &quot;
1119                 + MarlinConst.TILE_H_LG);
1120         logInfo(&quot;sun.java2d.renderer.tileWidth_log2   = &quot;
1121                 + MarlinConst.TILE_W_LG);
1122         logInfo(&quot;sun.java2d.renderer.blockSize_log2   = &quot;
1123                 + MarlinConst.BLOCK_SIZE_LG);
1124 
1125         // RLE / blockFlags settings
1126 
1127         logInfo(&quot;sun.java2d.renderer.forceRLE         = &quot;
1128                 + MarlinProperties.isForceRLE());
1129         logInfo(&quot;sun.java2d.renderer.forceNoRLE       = &quot;
1130                 + MarlinProperties.isForceNoRLE());
1131         logInfo(&quot;sun.java2d.renderer.useTileFlags     = &quot;
1132                 + MarlinProperties.isUseTileFlags());
1133         logInfo(&quot;sun.java2d.renderer.useTileFlags.useHeuristics = &quot;
1134                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1135         logInfo(&quot;sun.java2d.renderer.rleMinWidth      = &quot;
1136                 + MarlinCache.RLE_MIN_WIDTH);
1137 
1138         // optimisation parameters
1139         logInfo(&quot;sun.java2d.renderer.useSimplifier    = &quot;
1140                 + MarlinConst.USE_SIMPLIFIER);
1141         logInfo(&quot;sun.java2d.renderer.usePathSimplifier= &quot;
1142                 + MarlinConst.USE_PATH_SIMPLIFIER);
1143         logInfo(&quot;sun.java2d.renderer.pathSimplifier.pixTol = &quot;
1144                 + MarlinProperties.getPathSimplifierPixelTolerance());
1145 
1146         logInfo(&quot;sun.java2d.renderer.clip             = &quot;
1147                 + MarlinProperties.isDoClip());
1148         logInfo(&quot;sun.java2d.renderer.clip.runtime.enable = &quot;
1149                 + MarlinProperties.isDoClipRuntimeFlag());
1150 
1151         logInfo(&quot;sun.java2d.renderer.clip.subdivider  = &quot;
1152                 + MarlinProperties.isDoClipSubdivider());
1153         logInfo(&quot;sun.java2d.renderer.clip.subdivider.minLength = &quot;
1154                 + MarlinProperties.getSubdividerMinLength());
1155 
1156         // debugging parameters
1157         logInfo(&quot;sun.java2d.renderer.doStats          = &quot;
1158                 + MarlinConst.DO_STATS);
1159         logInfo(&quot;sun.java2d.renderer.doMonitors       = &quot;
1160                 + MarlinConst.DO_MONITORS);
1161         logInfo(&quot;sun.java2d.renderer.doChecks         = &quot;
1162                 + MarlinConst.DO_CHECKS);
1163 
1164         // logging parameters
1165         logInfo(&quot;sun.java2d.renderer.useLogger        = &quot;
1166                 + MarlinConst.USE_LOGGER);
1167         logInfo(&quot;sun.java2d.renderer.logCreateContext = &quot;
1168                 + MarlinConst.LOG_CREATE_CONTEXT);
1169         logInfo(&quot;sun.java2d.renderer.logUnsafeMalloc  = &quot;
1170                 + MarlinConst.LOG_UNSAFE_MALLOC);
1171 
1172         // quality settings
1173         logInfo(&quot;sun.java2d.renderer.curve_len_err    = &quot;
1174                 + MarlinProperties.getCurveLengthError());
1175         logInfo(&quot;sun.java2d.renderer.cubic_dec_d2     = &quot;
1176                 + MarlinProperties.getCubicDecD2());
1177         logInfo(&quot;sun.java2d.renderer.cubic_inc_d1     = &quot;
1178                 + MarlinProperties.getCubicIncD1());
1179         logInfo(&quot;sun.java2d.renderer.quad_dec_d2      = &quot;
1180                 + MarlinProperties.getQuadDecD2());
1181 
1182         logInfo(&quot;Renderer settings:&quot;);
1183         logInfo(&quot;CUB_DEC_BND  = &quot; + Renderer.CUB_DEC_BND);
1184         logInfo(&quot;CUB_INC_BND  = &quot; + Renderer.CUB_INC_BND);
1185         logInfo(&quot;QUAD_DEC_BND = &quot; + Renderer.QUAD_DEC_BND);
1186 
1187         logInfo(&quot;INITIAL_EDGES_CAPACITY               = &quot;
1188                 + MarlinConst.INITIAL_EDGES_CAPACITY);
1189         logInfo(&quot;INITIAL_CROSSING_COUNT               = &quot;
1190                 + Renderer.INITIAL_CROSSING_COUNT);
1191 
1192         logInfo(&quot;==========================================================&quot;
1193                 + &quot;=====================&quot;);
1194     }
1195 
1196     /**
1197      * Get the RendererContext instance dedicated to the current thread
1198      * @return RendererContext instance
1199      */
1200     @SuppressWarnings({&quot;unchecked&quot;})
1201     static RendererContext getRendererContext() {
1202         final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();
1203         if (DO_MONITORS) {
1204             rdrCtx.stats.mon_pre_getAATileGenerator.start();
1205         }
1206         return rdrCtx;
1207     }
1208 
1209     /**
1210      * Reset and return the given RendererContext instance for reuse
1211      * @param rdrCtx RendererContext instance
1212      */
1213     static void returnRendererContext(final RendererContext rdrCtx) {
1214         rdrCtx.dispose();
1215 
1216         if (DO_MONITORS) {
1217             rdrCtx.stats.mon_pre_getAATileGenerator.stop();
1218         }
1219         RDR_CTX_PROVIDER.release(rdrCtx);
1220     }
1221 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>