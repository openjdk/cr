<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/sun/java2d/marlin/DMarlinRenderingEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.awt.BasicStroke;
  29 import java.awt.Shape;
  30 import java.awt.geom.AffineTransform;
  31 import java.awt.geom.Path2D;
  32 import java.awt.geom.PathIterator;
  33 import java.security.AccessController;
  34 import java.util.Arrays;
  35 import sun.awt.geom.PathConsumer2D;
  36 import static sun.java2d.marlin.MarlinUtils.logInfo;
  37 import sun.java2d.ReentrantContextProvider;
  38 import sun.java2d.ReentrantContextProviderCLQ;
  39 import sun.java2d.ReentrantContextProviderTL;
  40 import sun.java2d.pipe.AATileGenerator;
  41 import sun.java2d.pipe.Region;
  42 import sun.java2d.pipe.RenderingEngine;
  43 import sun.security.action.GetPropertyAction;
  44 
  45 /**
  46  * Marlin RendererEngine implementation (derived from Pisces)
  47  */
  48 public final class DMarlinRenderingEngine extends RenderingEngine
  49                                           implements MarlinConst
  50 {
  51     // slightly slower ~2% if enabled stroker clipping (lines) but skipping cap / join handling is few percents faster in specific cases
  52     static final boolean DISABLE_2ND_STROKER_CLIPPING = true;
  53 
  54     static final boolean DO_TRACE_PATH = false;
  55 
  56     static final boolean DO_CLIP = MarlinProperties.isDoClip();
  57     static final boolean DO_CLIP_FILL = true;
  58     static final boolean DO_CLIP_RUNTIME_ENABLE = MarlinProperties.isDoClipRuntimeFlag();
  59 
  60     private static final float MIN_PEN_SIZE = 1.0f / MIN_SUBPIXELS;
  61 
  62     static final double UPPER_BND = Float.MAX_VALUE / 2.0d;
  63     static final double LOWER_BND = -UPPER_BND;
  64 
  65     private enum NormMode {
  66         ON_WITH_AA {
  67             @Override
  68             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  69                                                     final PathIterator src)
  70             {
  71                 // NormalizingPathIterator NearestPixelCenter:
  72                 return rdrCtx.nPCPathIterator.init(src);
  73             }
  74         },
  75         ON_NO_AA{
  76             @Override
  77             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  78                                                     final PathIterator src)
  79             {
  80                 // NearestPixel NormalizingPathIterator:
  81                 return rdrCtx.nPQPathIterator.init(src);
  82             }
  83         },
  84         OFF{
  85             @Override
  86             PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,
  87                                                     final PathIterator src)
  88             {
  89                 // return original path iterator if normalization is disabled:
  90                 return src;
  91             }
  92         };
  93 
  94         abstract PathIterator getNormalizingPathIterator(DRendererContext rdrCtx,
  95                                                          PathIterator src);
  96     }
  97 
  98     /**
  99      * Public constructor
 100      */
 101     public DMarlinRenderingEngine() {
 102         super();
 103         logSettings(DMarlinRenderingEngine.class.getName());
 104     }
 105 
 106     /**
 107      * Create a widened path as specified by the parameters.
 108      * &lt;p&gt;
 109      * The specified {@code src} {@link Shape} is widened according
 110      * to the specified attribute parameters as per the
 111      * {@link BasicStroke} specification.
 112      *
 113      * @param src the source path to be widened
 114      * @param width the width of the widened path as per {@code BasicStroke}
 115      * @param caps the end cap decorations as per {@code BasicStroke}
 116      * @param join the segment join decorations as per {@code BasicStroke}
 117      * @param miterlimit the miter limit as per {@code BasicStroke}
 118      * @param dashes the dash length array as per {@code BasicStroke}
 119      * @param dashphase the initial dash phase as per {@code BasicStroke}
 120      * @return the widened path stored in a new {@code Shape} object
 121      * @since 1.7
 122      */
 123     @Override
 124     public Shape createStrokedShape(Shape src,
 125                                     float width,
 126                                     int caps,
 127                                     int join,
 128                                     float miterlimit,
 129                                     float[] dashes,
 130                                     float dashphase)
 131     {
 132         final DRendererContext rdrCtx = getRendererContext();
 133         try {
 134             // initialize a large copyable Path2D to avoid a lot of array growing:
 135             final Path2D.Double p2d = rdrCtx.getPath2D();
 136 
 137             strokeTo(rdrCtx,
 138                      src,
 139                      null,
 140                      width,
 141                      NormMode.OFF,
 142                      caps,
 143                      join,
 144                      miterlimit,
 145                      dashes,
 146                      dashphase,
 147                      rdrCtx.transformerPC2D.wrapPath2D(p2d)
 148                     );
 149 
 150             // Use Path2D copy constructor (trim)
 151             return new Path2D.Double(p2d);
 152 
 153         } finally {
 154             // recycle the DRendererContext instance
 155             returnRendererContext(rdrCtx);
 156         }
 157     }
 158 
 159     /**
 160      * Sends the geometry for a widened path as specified by the parameters
 161      * to the specified consumer.
 162      * &lt;p&gt;
 163      * The specified {@code src} {@link Shape} is widened according
 164      * to the parameters specified by the {@link BasicStroke} object.
 165      * Adjustments are made to the path as appropriate for the
 166      * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the
 167      * {@code normalize} boolean parameter is true.
 168      * Adjustments are made to the path as appropriate for the
 169      * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the
 170      * {@code antialias} boolean parameter is true.
 171      * &lt;p&gt;
 172      * The geometry of the widened path is forwarded to the indicated
 173      * {@link DPathConsumer2D} object as it is calculated.
 174      *
 175      * @param src the source path to be widened
 176      * @param bs the {@code BasicSroke} object specifying the
 177      *           decorations to be applied to the widened path
 178      * @param normalize indicates whether stroke normalization should
 179      *                  be applied
 180      * @param antialias indicates whether or not adjustments appropriate
 181      *                  to antialiased rendering should be applied
 182      * @param consumer the {@code DPathConsumer2D} instance to forward
 183      *                 the widened geometry to
 184      * @since 1.7
 185      */
 186     @Override
 187     public void strokeTo(Shape src,
 188                          AffineTransform at,
 189                          BasicStroke bs,
 190                          boolean thin,
 191                          boolean normalize,
 192                          boolean antialias,
 193                          final PathConsumer2D consumer)
 194     {
 195         final NormMode norm = (normalize) ?
 196                 ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)
 197                 : NormMode.OFF;
 198 
 199         final DRendererContext rdrCtx = getRendererContext();
 200         try {
 201             strokeTo(rdrCtx, src, at, bs, thin, norm, antialias,
 202                      rdrCtx.p2dAdapter.init(consumer));
 203         } finally {
 204             // recycle the DRendererContext instance
 205             returnRendererContext(rdrCtx);
 206         }
 207     }
 208 
 209     void strokeTo(final DRendererContext rdrCtx,
 210                   Shape src,
 211                   AffineTransform at,
 212                   BasicStroke bs,
 213                   boolean thin,
 214                   NormMode normalize,
 215                   boolean antialias,
 216                   DPathConsumer2D pc2d)
 217     {
 218         double lw;
 219         if (thin) {
 220             if (antialias) {
 221                 lw = userSpaceLineWidth(at, MIN_PEN_SIZE);
 222             } else {
 223                 lw = userSpaceLineWidth(at, 1.0d);
 224             }
 225         } else {
 226             lw = bs.getLineWidth();
 227         }
 228         strokeTo(rdrCtx,
 229                  src,
 230                  at,
 231                  lw,
 232                  normalize,
 233                  bs.getEndCap(),
 234                  bs.getLineJoin(),
 235                  bs.getMiterLimit(),
 236                  bs.getDashArray(),
 237                  bs.getDashPhase(),
 238                  pc2d);
 239     }
 240 
 241     private double userSpaceLineWidth(AffineTransform at, double lw) {
 242 
 243         double widthScale;
 244 
 245         if (at == null) {
 246             widthScale = 1.0d;
 247         } else if ((at.getType() &amp; (AffineTransform.TYPE_GENERAL_TRANSFORM  |
 248                                     AffineTransform.TYPE_GENERAL_SCALE)) != 0) {
 249             widthScale = Math.sqrt(at.getDeterminant());
 250         } else {
 251             // First calculate the &quot;maximum scale&quot; of this transform.
 252             double A = at.getScaleX();       // m00
 253             double C = at.getShearX();       // m01
 254             double B = at.getShearY();       // m10
 255             double D = at.getScaleY();       // m11
 256 
 257             /*
 258              * Given a 2 x 2 affine matrix [ A B ] such that
 259              *                             [ C D ]
 260              * v&#39; = [x&#39; y&#39;] = [Ax + Cy, Bx + Dy], we want to
 261              * find the maximum magnitude (norm) of the vector v&#39;
 262              * with the constraint (x^2 + y^2 = 1).
 263              * The equation to maximize is
 264              *     |v&#39;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
 265              * or  |v&#39;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
 266              * Since sqrt is monotonic we can maximize |v&#39;|^2
 267              * instead and plug in the substitution y = sqrt(1 - x^2).
 268              * Trigonometric equalities can then be used to get
 269              * rid of most of the sqrt terms.
 270              */
 271 
 272             double EA = A*A + B*B;          // x^2 coefficient
 273             double EB = 2.0d * (A*C + B*D); // xy coefficient
 274             double EC = C*C + D*D;          // y^2 coefficient
 275 
 276             /*
 277              * There is a lot of calculus omitted here.
 278              *
 279              * Conceptually, in the interests of understanding the
 280              * terms that the calculus produced we can consider
 281              * that EA and EC end up providing the lengths along
 282              * the major axes and the hypot term ends up being an
 283              * adjustment for the additional length along the off-axis
 284              * angle of rotated or sheared ellipses as well as an
 285              * adjustment for the fact that the equation below
 286              * averages the two major axis lengths.  (Notice that
 287              * the hypot term contains a part which resolves to the
 288              * difference of these two axis lengths in the absence
 289              * of rotation.)
 290              *
 291              * In the calculus, the ratio of the EB and (EA-EC) terms
 292              * ends up being the tangent of 2*theta where theta is
 293              * the angle that the long axis of the ellipse makes
 294              * with the horizontal axis.  Thus, this equation is
 295              * calculating the length of the hypotenuse of a triangle
 296              * along that axis.
 297              */
 298 
 299             double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
 300             // sqrt omitted, compare to squared limits below.
 301             double widthsquared = ((EA + EC + hypot) / 2.0d);
 302 
 303             widthScale = Math.sqrt(widthsquared);
 304         }
 305 
 306         return (lw / widthScale);
 307     }
 308 
 309     void strokeTo(final DRendererContext rdrCtx,
 310                   Shape src,
 311                   AffineTransform at,
 312                   double width,
 313                   NormMode norm,
 314                   int caps,
 315                   int join,
 316                   float miterlimit,
 317                   float[] dashes,
 318                   float dashphase,
 319                   DPathConsumer2D pc2d)
 320     {
 321         // We use strokerat so that in Stroker and Dasher we can work only
 322         // with the pre-transformation coordinates. This will repeat a lot of
 323         // computations done in the path iterator, but the alternative is to
 324         // work with transformed paths and compute untransformed coordinates
 325         // as needed. This would be faster but I do not think the complexity
 326         // of working with both untransformed and transformed coordinates in
 327         // the same code is worth it.
 328         // However, if a path&#39;s width is constant after a transformation,
 329         // we can skip all this untransforming.
 330 
 331         // As pathTo() will check transformed coordinates for invalid values
 332         // (NaN / Infinity) to ignore such points, it is necessary to apply the
 333         // transformation before the path processing.
 334         AffineTransform strokerat = null;
 335 
 336         int dashLen = -1;
 337         boolean recycleDashes = false;
 338         double[] dashesD = null;
 339 
 340         // Ensure converting dashes to double precision:
 341         if (dashes != null) {
 342             recycleDashes = true;
 343             dashLen = dashes.length;
 344             dashesD = rdrCtx.dasher.copyDashArray(dashes);
 345         }
 346 
 347         if (at != null &amp;&amp; !at.isIdentity()) {
 348             final double a = at.getScaleX();
 349             final double b = at.getShearX();
 350             final double c = at.getShearY();
 351             final double d = at.getScaleY();
 352             final double det = a * d - c * b;
 353 
 354             if (Math.abs(det) &lt;= (2.0d * Double.MIN_VALUE)) {
 355                 // this rendering engine takes one dimensional curves and turns
 356                 // them into 2D shapes by giving them width.
 357                 // However, if everything is to be passed through a singular
 358                 // transformation, these 2D shapes will be squashed down to 1D
 359                 // again so, nothing can be drawn.
 360 
 361                 // Every path needs an initial moveTo and a pathDone. If these
 362                 // are not there this causes a SIGSEGV in libawt.so (at the time
 363                 // of writing of this comment (September 16, 2010)). Actually,
 364                 // I am not sure if the moveTo is necessary to avoid the SIGSEGV
 365                 // but the pathDone is definitely needed.
 366                 pc2d.moveTo(0.0d, 0.0d);
 367                 pc2d.pathDone();
 368                 return;
 369             }
 370 
 371             // If the transform is a constant multiple of an orthogonal transformation
 372             // then every length is just multiplied by a constant, so we just
 373             // need to transform input paths to stroker and tell stroker
 374             // the scaled width. This condition is satisfied if
 375             // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
 376             // leave a bit of room for error.
 377             if (nearZero(a*b + c*d) &amp;&amp; nearZero(a*a + c*c - (b*b + d*d))) {
 378                 final double scale = Math.sqrt(a*a + c*c);
 379 
 380                 if (dashesD != null) {
 381                     for (int i = 0; i &lt; dashLen; i++) {
 382                         dashesD[i] *= scale;
 383                     }
 384                     dashphase *= scale;
 385                 }
 386                 width *= scale;
 387 
 388                 // by now strokerat == null. Input paths to
 389                 // stroker (and maybe dasher) will have the full transform at
 390                 // applied to them and nothing will happen to the output paths.
 391             } else {
 392                 strokerat = at;
 393 
 394                 // by now strokerat == at. Input paths to
 395                 // stroker (and maybe dasher) will have the full transform at
 396                 // applied to them, then they will be normalized, and then
 397                 // the inverse of *only the non translation part of at* will
 398                 // be applied to the normalized paths. This won&#39;t cause problems
 399                 // in stroker, because, suppose at = T*A, where T is just the
 400                 // translation part of at, and A is the rest. T*A has already
 401                 // been applied to Stroker/Dasher&#39;s input. Then Ainv will be
 402                 // applied. Ainv*T*A is not equal to T, but it is a translation,
 403                 // which means that none of stroker&#39;s assumptions about its
 404                 // input will be violated. After all this, A will be applied
 405                 // to stroker&#39;s output.
 406             }
 407         } else {
 408             // either at is null or it&#39;s the identity. In either case
 409             // we don&#39;t transform the path.
 410             at = null;
 411         }
 412 
 413         final DTransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;
 414 
 415         if (DO_TRACE_PATH) {
 416             // trace Stroker:
 417             pc2d = transformerPC2D.traceStroker(pc2d);
 418         }
 419 
 420         if (USE_SIMPLIFIER) {
 421             // Use simplifier after stroker before Renderer
 422             // to remove collinear segments (notably due to cap square)
 423             pc2d = rdrCtx.simplifier.init(pc2d);
 424         }
 425 
 426         // deltaTransformConsumer may adjust the clip rectangle:
 427         pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);
 428 
 429         // stroker will adjust the clip rectangle (width / miter limit):
 430         pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit,
 431                 (dashesD == null));
 432 
 433         // Curve Monotizer:
 434         rdrCtx.monotonizer.init(width);
 435 
 436         if (dashesD != null) {
 437             if (DO_TRACE_PATH) {
 438                 pc2d = transformerPC2D.traceDasher(pc2d);
 439             }
 440             pc2d = rdrCtx.dasher.init(pc2d, dashesD, dashLen, dashphase,
 441                                       recycleDashes);
 442 
 443             if (DISABLE_2ND_STROKER_CLIPPING) {
 444                 // disable stoker clipping:
 445                 rdrCtx.stroker.disableClipping();
 446             }
 447 
 448         } else if (rdrCtx.doClip &amp;&amp; (caps != Stroker.CAP_BUTT)) {
 449             if (DO_TRACE_PATH) {
 450                 pc2d = transformerPC2D.traceClosedPathDetector(pc2d);
 451             }
 452 
 453             // If no dash and clip is enabled:
 454             // detect closedPaths (polygons) for caps
 455             pc2d = transformerPC2D.detectClosedPath(pc2d);
 456         }
 457         pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);
 458 
 459         if (DO_TRACE_PATH) {
 460             // trace Input:
 461             pc2d = transformerPC2D.traceInput(pc2d);
 462         }
 463 
 464         final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 465                                          src.getPathIterator(at));
 466 
 467         pathTo(rdrCtx, pi, pc2d);
 468 
 469         /*
 470          * Pipeline seems to be:
 471          * shape.getPathIterator(at)
 472          * -&gt; (NormalizingPathIterator)
 473          * -&gt; (inverseDeltaTransformConsumer)
 474          * -&gt; (Dasher)
 475          * -&gt; Stroker
 476          * -&gt; (deltaTransformConsumer)
 477          *
 478          * -&gt; (CollinearSimplifier) to remove redundant segments
 479          *
 480          * -&gt; pc2d = Renderer (bounding box)
 481          */
 482     }
 483 
 484     private static boolean nearZero(final double num) {
 485         return Math.abs(num) &lt; 2.0d * Math.ulp(num);
 486     }
 487 
 488     abstract static class NormalizingPathIterator implements PathIterator {
 489 
 490         private PathIterator src;
 491 
 492         // the adjustment applied to the current position.
 493         private double curx_adjust, cury_adjust;
 494         // the adjustment applied to the last moveTo position.
 495         private double movx_adjust, movy_adjust;
 496 
 497         private final double[] tmp;
 498 
 499         NormalizingPathIterator(final double[] tmp) {
 500             this.tmp = tmp;
 501         }
 502 
 503         final NormalizingPathIterator init(final PathIterator src) {
 504             this.src = src;
 505             return this; // fluent API
 506         }
 507 
 508         /**
 509          * Disposes this path iterator:
 510          * clean up before reusing this instance
 511          */
 512         final void dispose() {
 513             // free source PathIterator:
 514             this.src = null;
 515         }
 516 
 517         @Override
 518         public final int currentSegment(final double[] coords) {
 519             int lastCoord;
 520             final int type = src.currentSegment(coords);
 521 
 522             switch(type) {
 523                 case PathIterator.SEG_MOVETO:
 524                 case PathIterator.SEG_LINETO:
 525                     lastCoord = 0;
 526                     break;
 527                 case PathIterator.SEG_QUADTO:
 528                     lastCoord = 2;
 529                     break;
 530                 case PathIterator.SEG_CUBICTO:
 531                     lastCoord = 4;
 532                     break;
 533                 case PathIterator.SEG_CLOSE:
 534                     // we don&#39;t want to deal with this case later. We just exit now
 535                     curx_adjust = movx_adjust;
 536                     cury_adjust = movy_adjust;
 537                     return type;
 538                 default:
 539                     throw new InternalError(&quot;Unrecognized curve type&quot;);
 540             }
 541 
 542             // normalize endpoint
 543             double coord, x_adjust, y_adjust;
 544 
 545             coord = coords[lastCoord];
 546             x_adjust = normCoord(coord); // new coord
 547             coords[lastCoord] = x_adjust;
 548             x_adjust -= coord;
 549 
 550             coord = coords[lastCoord + 1];
 551             y_adjust = normCoord(coord); // new coord
 552             coords[lastCoord + 1] = y_adjust;
 553             y_adjust -= coord;
 554 
 555             // now that the end points are done, normalize the control points
 556             switch(type) {
 557                 case PathIterator.SEG_MOVETO:
 558                     movx_adjust = x_adjust;
 559                     movy_adjust = y_adjust;
 560                     break;
 561                 case PathIterator.SEG_LINETO:
 562                     break;
 563                 case PathIterator.SEG_QUADTO:
 564                     coords[0] += (curx_adjust + x_adjust) / 2.0d;
 565                     coords[1] += (cury_adjust + y_adjust) / 2.0d;
 566                     break;
 567                 case PathIterator.SEG_CUBICTO:
 568                     coords[0] += curx_adjust;
 569                     coords[1] += cury_adjust;
 570                     coords[2] += x_adjust;
 571                     coords[3] += y_adjust;
 572                     break;
 573                 case PathIterator.SEG_CLOSE:
 574                     // handled earlier
 575                 default:
 576             }
 577             curx_adjust = x_adjust;
 578             cury_adjust = y_adjust;
 579             return type;
 580         }
 581 
 582         abstract double normCoord(final double coord);
 583 
 584         @Override
 585         public final int currentSegment(final float[] coords) {
 586             final double[] _tmp = tmp; // dirty
 587             int type = this.currentSegment(_tmp);
 588             for (int i = 0; i &lt; 6; i++) {
 589                 coords[i] = (float)_tmp[i];
 590             }
 591             return type;
 592         }
 593 
 594         @Override
 595         public final int getWindingRule() {
 596             return src.getWindingRule();
 597         }
 598 
 599         @Override
 600         public final boolean isDone() {
 601             if (src.isDone()) {
 602                 // Dispose this instance:
 603                 dispose();
 604                 return true;
 605             }
 606             return false;
 607         }
 608 
 609         @Override
 610         public final void next() {
 611             src.next();
 612         }
 613 
 614         static final class NearestPixelCenter
 615                                 extends NormalizingPathIterator
 616         {
 617             NearestPixelCenter(final double[] tmp) {
 618                 super(tmp);
 619             }
 620 
 621             @Override
 622             double normCoord(final double coord) {
 623                 // round to nearest pixel center
 624                 return Math.floor(coord) + 0.5d;
 625             }
 626         }
 627 
 628         static final class NearestPixelQuarter
 629                                 extends NormalizingPathIterator
 630         {
 631             NearestPixelQuarter(final double[] tmp) {
 632                 super(tmp);
 633             }
 634 
 635             @Override
 636             double normCoord(final double coord) {
 637                 // round to nearest (0.25, 0.25) pixel quarter
 638                 return Math.floor(coord + 0.25d) + 0.25d;
 639             }
 640         }
 641     }
 642 
 643     private static void pathTo(final DRendererContext rdrCtx, final PathIterator pi,
 644                                DPathConsumer2D pc2d)
 645     {
 646         if (USE_PATH_SIMPLIFIER) {
 647             // Use path simplifier at the first step
 648             // to remove useless points
 649             pc2d = rdrCtx.pathSimplifier.init(pc2d);
 650         }
 651 
 652         // mark context as DIRTY:
 653         rdrCtx.dirty = true;
 654 
 655         pathToLoop(rdrCtx.double6, pi, pc2d);
 656 
 657         // mark context as CLEAN:
 658         rdrCtx.dirty = false;
 659     }
 660 
 661     private static void pathToLoop(final double[] coords, final PathIterator pi,
 662                                    final DPathConsumer2D pc2d)
 663     {
 664         // ported from DuctusRenderingEngine.feedConsumer() but simplified:
 665         // - removed skip flag = !subpathStarted
 666         // - removed pathClosed (ie subpathStarted not set to false)
 667         boolean subpathStarted = false;
 668 
 669         for (; !pi.isDone(); pi.next()) {
 670             switch (pi.currentSegment(coords)) {
 671             case PathIterator.SEG_MOVETO:
 672                 /* Checking SEG_MOVETO coordinates if they are out of the
 673                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 674                  * and Infinity values. Skipping next path segment in case of
 675                  * invalid data.
 676                  */
 677                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 678                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 679                 {
 680                     pc2d.moveTo(coords[0], coords[1]);
 681                     subpathStarted = true;
 682                 }
 683                 break;
 684             case PathIterator.SEG_LINETO:
 685                 /* Checking SEG_LINETO coordinates if they are out of the
 686                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 687                  * and Infinity values. Ignoring current path segment in case
 688                  * of invalid data. If segment is skipped its endpoint
 689                  * (if valid) is used to begin new subpath.
 690                  */
 691                 if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 692                     coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 693                 {
 694                     if (subpathStarted) {
 695                         pc2d.lineTo(coords[0], coords[1]);
 696                     } else {
 697                         pc2d.moveTo(coords[0], coords[1]);
 698                         subpathStarted = true;
 699                     }
 700                 }
 701                 break;
 702             case PathIterator.SEG_QUADTO:
 703                 // Quadratic curves take two points
 704                 /* Checking SEG_QUADTO coordinates if they are out of the
 705                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 706                  * and Infinity values. Ignoring current path segment in case
 707                  * of invalid endpoints&#39;s data. Equivalent to the SEG_LINETO
 708                  * if endpoint coordinates are valid but there are invalid data
 709                  * among other coordinates
 710                  */
 711                 if (coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 712                     coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 713                 {
 714                     if (subpathStarted) {
 715                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 716                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND)
 717                         {
 718                             pc2d.quadTo(coords[0], coords[1],
 719                                         coords[2], coords[3]);
 720                         } else {
 721                             pc2d.lineTo(coords[2], coords[3]);
 722                         }
 723                     } else {
 724                         pc2d.moveTo(coords[2], coords[3]);
 725                         subpathStarted = true;
 726                     }
 727                 }
 728                 break;
 729             case PathIterator.SEG_CUBICTO:
 730                 // Cubic curves take three points
 731                 /* Checking SEG_CUBICTO coordinates if they are out of the
 732                  * [LOWER_BND, UPPER_BND] range. This check also handles NaN
 733                  * and Infinity values. Ignoring current path segment in case
 734                  * of invalid endpoints&#39;s data. Equivalent to the SEG_LINETO
 735                  * if endpoint coordinates are valid but there are invalid data
 736                  * among other coordinates
 737                  */
 738                 if (coords[4] &lt; UPPER_BND &amp;&amp; coords[4] &gt; LOWER_BND &amp;&amp;
 739                     coords[5] &lt; UPPER_BND &amp;&amp; coords[5] &gt; LOWER_BND)
 740                 {
 741                     if (subpathStarted) {
 742                         if (coords[0] &lt; UPPER_BND &amp;&amp; coords[0] &gt; LOWER_BND &amp;&amp;
 743                             coords[1] &lt; UPPER_BND &amp;&amp; coords[1] &gt; LOWER_BND &amp;&amp;
 744                             coords[2] &lt; UPPER_BND &amp;&amp; coords[2] &gt; LOWER_BND &amp;&amp;
 745                             coords[3] &lt; UPPER_BND &amp;&amp; coords[3] &gt; LOWER_BND)
 746                         {
 747                             pc2d.curveTo(coords[0], coords[1],
 748                                          coords[2], coords[3],
 749                                          coords[4], coords[5]);
 750                         } else {
 751                             pc2d.lineTo(coords[4], coords[5]);
 752                         }
 753                     } else {
 754                         pc2d.moveTo(coords[4], coords[5]);
 755                         subpathStarted = true;
 756                     }
 757                 }
 758                 break;
 759             case PathIterator.SEG_CLOSE:
 760                 if (subpathStarted) {
 761                     pc2d.closePath();
 762                     // do not set subpathStarted to false
 763                     // in case of missing moveTo() after close()
 764                 }
 765                 break;
 766             default:
 767             }
 768         }
 769         pc2d.pathDone();
 770     }
 771 
 772     /**
 773      * Construct an antialiased tile generator for the given shape with
 774      * the given rendering attributes and store the bounds of the tile
 775      * iteration in the bbox parameter.
 776      * The {@code at} parameter specifies a transform that should affect
 777      * both the shape and the {@code BasicStroke} attributes.
 778      * The {@code clip} parameter specifies the current clip in effect
 779      * in device coordinates and can be used to prune the data for the
 780      * operation, but the renderer is not required to perform any
 781      * clipping.
 782      * If the {@code BasicStroke} parameter is null then the shape
 783      * should be filled as is, otherwise the attributes of the
 784      * {@code BasicStroke} should be used to specify a draw operation.
 785      * The {@code thin} parameter indicates whether or not the
 786      * transformed {@code BasicStroke} represents coordinates smaller
 787      * than the minimum resolution of the antialiasing rasterizer as
 788      * specified by the {@code getMinimumAAPenWidth()} method.
 789      * &lt;p&gt;
 790      * Upon returning, this method will fill the {@code bbox} parameter
 791      * with 4 values indicating the bounds of the iteration of the
 792      * tile generator.
 793      * The iteration order of the tiles will be as specified by the
 794      * pseudo-code:
 795      * &lt;pre&gt;
 796      *     for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
 797      *         for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
 798      *         }
 799      *     }
 800      * &lt;/pre&gt;
 801      * If there is no output to be rendered, this method may return
 802      * null.
 803      *
 804      * @param s the shape to be rendered (fill or draw)
 805      * @param at the transform to be applied to the shape and the
 806      *           stroke attributes
 807      * @param clip the current clip in effect in device coordinates
 808      * @param bs if non-null, a {@code BasicStroke} whose attributes
 809      *           should be applied to this operation
 810      * @param thin true if the transformed stroke attributes are smaller
 811      *             than the minimum dropout pen width
 812      * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
 813      *                  {@code RenderingHint} is in effect
 814      * @param bbox returns the bounds of the iteration
 815      * @return the {@code AATileGenerator} instance to be consulted
 816      *         for tile coverages, or null if there is no output to render
 817      * @since 1.7
 818      */
 819     @Override
 820     public AATileGenerator getAATileGenerator(Shape s,
 821                                               AffineTransform at,
 822                                               Region clip,
 823                                               BasicStroke bs,
 824                                               boolean thin,
 825                                               boolean normalize,
 826                                               int[] bbox)
 827     {
 828         MarlinTileGenerator ptg = null;
 829         DRenderer r = null;
 830 
 831         final DRendererContext rdrCtx = getRendererContext();
 832         try {
 833             if (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE &amp;&amp; MarlinProperties.isDoClipAtRuntime())) {
 834                 // Define the initial clip bounds:
 835                 final double[] clipRect = rdrCtx.clipRect;
 836 
 837                 // Adjust the clipping rectangle with the renderer offsets
 838                 final double rdrOffX = DRenderer.RDR_OFFSET_X;
 839                 final double rdrOffY = DRenderer.RDR_OFFSET_Y;
 840 
 841                 // add a small rounding error:
 842                 final double margin = 1e-3d;
 843 
 844                 clipRect[0] = clip.getLoY()
 845                                 - margin + rdrOffY;
 846                 clipRect[1] = clip.getLoY() + clip.getHeight()
 847                                 + margin + rdrOffY;
 848                 clipRect[2] = clip.getLoX()
 849                                 - margin + rdrOffX;
 850                 clipRect[3] = clip.getLoX() + clip.getWidth()
 851                                 + margin + rdrOffX;
 852 
 853                 if (MarlinConst.DO_LOG_CLIP) {
 854                     MarlinUtils.logInfo(&quot;clipRect (clip): &quot;
 855                                         + Arrays.toString(rdrCtx.clipRect));
 856                 }
 857 
 858                 // Enable clipping:
 859                 rdrCtx.doClip = true;
 860             }
 861 
 862             // Test if at is identity:
 863             final AffineTransform _at = (at != null &amp;&amp; !at.isIdentity()) ? at
 864                                         : null;
 865 
 866             final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;
 867 
 868             if (bs == null) {
 869                 // fill shape:
 870                 final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,
 871                                                  s.getPathIterator(_at));
 872 
 873                 // note: Winding rule may be EvenOdd ONLY for fill operations !
 874                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 875                                          clip.getWidth(), clip.getHeight(),
 876                                          pi.getWindingRule());
 877 
 878                 DPathConsumer2D pc2d = r;
 879 
 880                 if (DO_CLIP_FILL &amp;&amp; rdrCtx.doClip) {
 881                     if (DO_TRACE_PATH) {
 882                         // trace Filler:
 883                         pc2d = rdrCtx.transformerPC2D.traceFiller(pc2d);
 884                     }
 885                     pc2d = rdrCtx.transformerPC2D.pathClipper(pc2d);
 886                 }
 887 
 888                 if (DO_TRACE_PATH) {
 889                     // trace Input:
 890                     pc2d = rdrCtx.transformerPC2D.traceInput(pc2d);
 891                 }
 892                 pathTo(rdrCtx, pi, pc2d);
 893 
 894             } else {
 895                 // draw shape with given stroke:
 896                 r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 897                                          clip.getWidth(), clip.getHeight(),
 898                                          WIND_NON_ZERO);
 899 
 900                 strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);
 901             }
 902             if (r.endRendering()) {
 903                 ptg = rdrCtx.ptg.init();
 904                 ptg.getBbox(bbox);
 905                 // note: do not returnRendererContext(rdrCtx)
 906                 // as it will be called later by MarlinTileGenerator.dispose()
 907                 r = null;
 908             }
 909         } finally {
 910             if (r != null) {
 911                 // dispose renderer and recycle the RendererContext instance:
 912                 r.dispose();
 913             }
 914         }
 915 
 916         // Return null to cancel AA tile generation (nothing to render)
 917         return ptg;
 918     }
 919 
 920     @Override
 921     public AATileGenerator getAATileGenerator(double x, double y,
 922                                               double dx1, double dy1,
 923                                               double dx2, double dy2,
 924                                               double lw1, double lw2,
 925                                               Region clip,
 926                                               int[] bbox)
 927     {
 928         // REMIND: Deal with large coordinates!
 929         double ldx1, ldy1, ldx2, ldy2;
 930         boolean innerpgram = (lw1 &gt; 0.0d &amp;&amp; lw2 &gt; 0.0d);
 931 
 932         if (innerpgram) {
 933             ldx1 = dx1 * lw1;
 934             ldy1 = dy1 * lw1;
 935             ldx2 = dx2 * lw2;
 936             ldy2 = dy2 * lw2;
 937             x -= (ldx1 + ldx2) / 2.0d;
 938             y -= (ldy1 + ldy2) / 2.0d;
 939             dx1 += ldx1;
 940             dy1 += ldy1;
 941             dx2 += ldx2;
 942             dy2 += ldy2;
 943             if (lw1 &gt; 1.0d &amp;&amp; lw2 &gt; 1.0d) {
 944                 // Inner parallelogram was entirely consumed by stroke...
 945                 innerpgram = false;
 946             }
 947         } else {
 948             ldx1 = ldy1 = ldx2 = ldy2 = 0.0d;
 949         }
 950 
 951         MarlinTileGenerator ptg = null;
 952         DRenderer r = null;
 953 
 954         final DRendererContext rdrCtx = getRendererContext();
 955         try {
 956             r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),
 957                                      clip.getWidth(), clip.getHeight(),
 958                                      WIND_EVEN_ODD);
 959 
 960             r.moveTo( x,  y);
 961             r.lineTo( (x+dx1),  (y+dy1));
 962             r.lineTo( (x+dx1+dx2),  (y+dy1+dy2));
 963             r.lineTo( (x+dx2),  (y+dy2));
 964             r.closePath();
 965 
 966             if (innerpgram) {
 967                 x += ldx1 + ldx2;
 968                 y += ldy1 + ldy2;
 969                 dx1 -= 2.0d * ldx1;
 970                 dy1 -= 2.0d * ldy1;
 971                 dx2 -= 2.0d * ldx2;
 972                 dy2 -= 2.0d * ldy2;
 973                 r.moveTo( x,  y);
 974                 r.lineTo( (x+dx1),  (y+dy1));
 975                 r.lineTo( (x+dx1+dx2),  (y+dy1+dy2));
 976                 r.lineTo( (x+dx2),  (y+dy2));
 977                 r.closePath();
 978             }
 979             r.pathDone();
 980 
 981             if (r.endRendering()) {
 982                 ptg = rdrCtx.ptg.init();
 983                 ptg.getBbox(bbox);
 984                 // note: do not returnRendererContext(rdrCtx)
 985                 // as it will be called later by MarlinTileGenerator.dispose()
 986                 r = null;
 987             }
 988         } finally {
 989             if (r != null) {
 990                 // dispose renderer and recycle the RendererContext instance:
 991                 r.dispose();
 992             }
 993         }
 994 
 995         // Return null to cancel AA tile generation (nothing to render)
 996         return ptg;
 997     }
 998 
 999     /**
1000      * Returns the minimum pen width that the antialiasing rasterizer
1001      * can represent without dropouts occuring.
1002      * @since 1.7
1003      */
1004     @Override
1005     public float getMinimumAAPenSize() {
1006         return MIN_PEN_SIZE;
1007     }
1008 
1009     static {
1010         if (PathIterator.WIND_NON_ZERO != WIND_NON_ZERO ||
1011             PathIterator.WIND_EVEN_ODD != WIND_EVEN_ODD ||
1012             BasicStroke.JOIN_MITER != JOIN_MITER ||
1013             BasicStroke.JOIN_ROUND != JOIN_ROUND ||
1014             BasicStroke.JOIN_BEVEL != JOIN_BEVEL ||
1015             BasicStroke.CAP_BUTT != CAP_BUTT ||
1016             BasicStroke.CAP_ROUND != CAP_ROUND ||
1017             BasicStroke.CAP_SQUARE != CAP_SQUARE)
1018         {
1019             throw new InternalError(&quot;mismatched renderer constants&quot;);
1020         }
1021     }
1022 
1023     // --- DRendererContext handling ---
1024     // use ThreadLocal or ConcurrentLinkedQueue to get one DRendererContext
1025     private static final boolean USE_THREAD_LOCAL;
1026 
1027     // reference type stored in either TL or CLQ
1028     static final int REF_TYPE;
1029 
1030     // Per-thread DRendererContext
1031     private static final ReentrantContextProvider&lt;DRendererContext&gt; RDR_CTX_PROVIDER;
1032 
1033     // Static initializer to use TL or CLQ mode
1034     static {
1035         USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();
1036 
1037         // Soft reference by default:
1038         final String refType = AccessController.doPrivileged(
1039                             new GetPropertyAction(&quot;sun.java2d.renderer.useRef&quot;,
1040                             &quot;soft&quot;));
1041         switch (refType) {
1042             default:
1043             case &quot;soft&quot;:
1044                 REF_TYPE = ReentrantContextProvider.REF_SOFT;
1045                 break;
1046             case &quot;weak&quot;:
1047                 REF_TYPE = ReentrantContextProvider.REF_WEAK;
1048                 break;
1049             case &quot;hard&quot;:
1050                 REF_TYPE = ReentrantContextProvider.REF_HARD;
1051                 break;
1052         }
1053 
1054         if (USE_THREAD_LOCAL) {
1055             RDR_CTX_PROVIDER = new ReentrantContextProviderTL&lt;DRendererContext&gt;(REF_TYPE)
1056                 {
1057                     @Override
1058                     protected DRendererContext newContext() {
1059                         return DRendererContext.createContext();
1060                     }
1061                 };
1062         } else {
1063             RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ&lt;DRendererContext&gt;(REF_TYPE)
1064                 {
1065                     @Override
1066                     protected DRendererContext newContext() {
1067                         return DRendererContext.createContext();
1068                     }
1069                 };
1070         }
1071     }
1072 
1073     private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;
1074 
1075     private static void logSettings(final String reClass) {
1076         // log information at startup
1077         if (SETTINGS_LOGGED) {
1078             return;
1079         }
1080         SETTINGS_LOGGED = true;
1081 
1082         String refType;
1083         switch (REF_TYPE) {
1084             default:
1085             case ReentrantContextProvider.REF_HARD:
1086                 refType = &quot;hard&quot;;
1087                 break;
1088             case ReentrantContextProvider.REF_SOFT:
1089                 refType = &quot;soft&quot;;
1090                 break;
1091             case ReentrantContextProvider.REF_WEAK:
1092                 refType = &quot;weak&quot;;
1093                 break;
1094         }
1095 
1096         logInfo(&quot;==========================================================&quot;
1097                 + &quot;=====================&quot;);
1098 
1099         logInfo(&quot;Marlin software rasterizer           = ENABLED&quot;);
1100         logInfo(&quot;Version                              = [&quot;
1101                 + Version.getVersion() + &quot;]&quot;);
1102         logInfo(&quot;sun.java2d.renderer                  = &quot;
1103                 + reClass);
1104         logInfo(&quot;sun.java2d.renderer.useThreadLocal   = &quot;
1105                 + USE_THREAD_LOCAL);
1106         logInfo(&quot;sun.java2d.renderer.useRef           = &quot;
1107                 + refType);
1108 
1109         logInfo(&quot;sun.java2d.renderer.edges            = &quot;
1110                 + MarlinConst.INITIAL_EDGES_COUNT);
1111         logInfo(&quot;sun.java2d.renderer.pixelWidth       = &quot;
1112                 + MarlinConst.INITIAL_PIXEL_WIDTH);
1113         logInfo(&quot;sun.java2d.renderer.pixelHeight      = &quot;
1114                 + MarlinConst.INITIAL_PIXEL_HEIGHT);
1115 
1116         logInfo(&quot;sun.java2d.renderer.subPixel_log2_X  = &quot;
1117                 + MarlinConst.SUBPIXEL_LG_POSITIONS_X);
1118         logInfo(&quot;sun.java2d.renderer.subPixel_log2_Y  = &quot;
1119                 + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);
1120 
1121         logInfo(&quot;sun.java2d.renderer.tileSize_log2    = &quot;
1122                 + MarlinConst.TILE_H_LG);
1123         logInfo(&quot;sun.java2d.renderer.tileWidth_log2   = &quot;
1124                 + MarlinConst.TILE_W_LG);
1125         logInfo(&quot;sun.java2d.renderer.blockSize_log2   = &quot;
1126                 + MarlinConst.BLOCK_SIZE_LG);
1127 
1128         // RLE / blockFlags settings
1129 
1130         logInfo(&quot;sun.java2d.renderer.forceRLE         = &quot;
1131                 + MarlinProperties.isForceRLE());
1132         logInfo(&quot;sun.java2d.renderer.forceNoRLE       = &quot;
1133                 + MarlinProperties.isForceNoRLE());
1134         logInfo(&quot;sun.java2d.renderer.useTileFlags     = &quot;
1135                 + MarlinProperties.isUseTileFlags());
1136         logInfo(&quot;sun.java2d.renderer.useTileFlags.useHeuristics = &quot;
1137                 + MarlinProperties.isUseTileFlagsWithHeuristics());
1138         logInfo(&quot;sun.java2d.renderer.rleMinWidth      = &quot;
1139                 + MarlinCache.RLE_MIN_WIDTH);
1140 
1141         // optimisation parameters
1142         logInfo(&quot;sun.java2d.renderer.useSimplifier    = &quot;
1143                 + MarlinConst.USE_SIMPLIFIER);
1144         logInfo(&quot;sun.java2d.renderer.usePathSimplifier= &quot;
1145                 + MarlinConst.USE_PATH_SIMPLIFIER);
1146         logInfo(&quot;sun.java2d.renderer.pathSimplifier.pixTol = &quot;
1147                 + MarlinProperties.getPathSimplifierPixelTolerance());
1148 
1149         logInfo(&quot;sun.java2d.renderer.clip             = &quot;
1150                 + MarlinProperties.isDoClip());
1151         logInfo(&quot;sun.java2d.renderer.clip.runtime.enable = &quot;
1152                 + MarlinProperties.isDoClipRuntimeFlag());
1153 
1154         logInfo(&quot;sun.java2d.renderer.clip.subdivider  = &quot;
1155                 + MarlinProperties.isDoClipSubdivider());
1156         logInfo(&quot;sun.java2d.renderer.clip.subdivider.minLength = &quot;
1157                 + MarlinProperties.getSubdividerMinLength());
1158 
1159         // debugging parameters
1160         logInfo(&quot;sun.java2d.renderer.doStats          = &quot;
1161                 + MarlinConst.DO_STATS);
1162         logInfo(&quot;sun.java2d.renderer.doMonitors       = &quot;
1163                 + MarlinConst.DO_MONITORS);
1164         logInfo(&quot;sun.java2d.renderer.doChecks         = &quot;
1165                 + MarlinConst.DO_CHECKS);
1166 
1167         // logging parameters
1168         logInfo(&quot;sun.java2d.renderer.useLogger        = &quot;
1169                 + MarlinConst.USE_LOGGER);
1170         logInfo(&quot;sun.java2d.renderer.logCreateContext = &quot;
1171                 + MarlinConst.LOG_CREATE_CONTEXT);
1172         logInfo(&quot;sun.java2d.renderer.logUnsafeMalloc  = &quot;
1173                 + MarlinConst.LOG_UNSAFE_MALLOC);
1174 
1175         // quality settings
1176         logInfo(&quot;sun.java2d.renderer.curve_len_err    = &quot;
1177                 + MarlinProperties.getCurveLengthError());
1178         logInfo(&quot;sun.java2d.renderer.cubic_dec_d2     = &quot;
1179                 + MarlinProperties.getCubicDecD2());
1180         logInfo(&quot;sun.java2d.renderer.cubic_inc_d1     = &quot;
1181                 + MarlinProperties.getCubicIncD1());
1182         logInfo(&quot;sun.java2d.renderer.quad_dec_d2      = &quot;
1183                 + MarlinProperties.getQuadDecD2());
1184 
1185         logInfo(&quot;Renderer settings:&quot;);
1186         logInfo(&quot;CUB_DEC_BND  = &quot; + DRenderer.CUB_DEC_BND);
1187         logInfo(&quot;CUB_INC_BND  = &quot; + DRenderer.CUB_INC_BND);
1188         logInfo(&quot;QUAD_DEC_BND = &quot; + DRenderer.QUAD_DEC_BND);
1189 
1190         logInfo(&quot;INITIAL_EDGES_CAPACITY               = &quot;
1191                 + MarlinConst.INITIAL_EDGES_CAPACITY);
1192         logInfo(&quot;INITIAL_CROSSING_COUNT               = &quot;
1193                 + DRenderer.INITIAL_CROSSING_COUNT);
1194 
1195         logInfo(&quot;==========================================================&quot;
1196                 + &quot;=====================&quot;);
1197     }
1198 
1199     /**
1200      * Get the DRendererContext instance dedicated to the current thread
1201      * @return DRendererContext instance
1202      */
1203     @SuppressWarnings({&quot;unchecked&quot;})
1204     static DRendererContext getRendererContext() {
1205         final DRendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();
1206         if (DO_MONITORS) {
1207             rdrCtx.stats.mon_pre_getAATileGenerator.start();
1208         }
1209         return rdrCtx;
1210     }
1211 
1212     /**
1213      * Reset and return the given DRendererContext instance for reuse
1214      * @param rdrCtx DRendererContext instance
1215      */
1216     static void returnRendererContext(final DRendererContext rdrCtx) {
1217         rdrCtx.dispose();
1218 
1219         if (DO_MONITORS) {
1220             rdrCtx.stats.mon_pre_getAATileGenerator.stop();
1221         }
1222         RDR_CTX_PROVIDER.release(rdrCtx);
1223     }
1224 }
    </pre>
  </body>
</html>