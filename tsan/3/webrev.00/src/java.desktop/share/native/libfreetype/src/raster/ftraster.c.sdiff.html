<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/raster/ftraster.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftmisc.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftraster.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/raster/ftraster.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ftraster.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    The FreeType glyph rasterizer (body).                                */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18   /*************************************************************************/</span>
<span class="line-modified">  19   /*                                                                       */</span>
<span class="line-modified">  20   /* This file can be compiled without the rest of the FreeType engine, by */</span>
<span class="line-modified">  21   /* defining the STANDALONE_ macro when compiling it.  You also need to   */</span>
<span class="line-modified">  22   /* put the files `ftimage.h&#39; and `ftmisc.h&#39; into the $(incdir)           */</span>
<span class="line-modified">  23   /* directory.  Typically, you should do something like                   */</span>
<span class="line-modified">  24   /*                                                                       */</span>
<span class="line-modified">  25   /* - copy `src/raster/ftraster.c&#39; (this file) to your current directory  */</span>
<span class="line-modified">  26   /*                                                                       */</span>
<span class="line-modified">  27   /* - copy `include/freetype/ftimage.h&#39; and `src/raster/ftmisc.h&#39; to your */</span>
<span class="line-modified">  28   /*   current directory                                                   */</span>
<span class="line-modified">  29   /*                                                                       */</span>
<span class="line-modified">  30   /* - compile `ftraster&#39; with the STANDALONE_ macro defined, as in        */</span>
<span class="line-modified">  31   /*                                                                       */</span>
<span class="line-modified">  32   /*     cc -c -DSTANDALONE_ ftraster.c                                    */</span>
<span class="line-modified">  33   /*                                                                       */</span>
<span class="line-modified">  34   /* The renderer can be initialized with a call to                        */</span>
<span class="line-modified">  35   /* `ft_standard_raster.raster_new&#39;; a bitmap can be generated            */</span>
<span class="line-modified">  36   /* with a call to `ft_standard_raster.raster_render&#39;.                    */</span>
<span class="line-modified">  37   /*                                                                       */</span>
<span class="line-modified">  38   /* See the comments and documentation in the file `ftimage.h&#39; for more   */</span>
<span class="line-modified">  39   /* details on how the raster works.                                      */</span>
<span class="line-modified">  40   /*                                                                       */</span>
<span class="line-modified">  41   /*************************************************************************/</span>
<span class="line-modified">  42 </span>
<span class="line-modified">  43 </span>
<span class="line-modified">  44   /*************************************************************************/</span>
<span class="line-modified">  45   /*                                                                       */</span>
<span class="line-modified">  46   /* This is a rewrite of the FreeType 1.x scan-line converter             */</span>
<span class="line-modified">  47   /*                                                                       */</span>
<span class="line-modified">  48   /*************************************************************************/</span>
  49 
  50 #ifdef STANDALONE_
  51 
  52   /* The size in bytes of the render pool used by the scan-line converter  */
  53   /* to do all of its work.                                                */
  54 #define FT_RENDER_POOL_SIZE  16384L
  55 
  56 #define FT_CONFIG_STANDARD_LIBRARY_H  &lt;stdlib.h&gt;
  57 
  58 #include &lt;string.h&gt;           /* for memset */
  59 
  60 #include &quot;ftmisc.h&quot;
  61 #include &quot;ftimage.h&quot;
  62 
  63 #else /* !STANDALONE_ */
  64 
  65 #include &lt;ft2build.h&gt;
  66 #include &quot;ftraster.h&quot;
  67 #include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */
<span class="line-modified">  68 </span>
<span class="line-removed">  69 #include &quot;rastpic.h&quot;</span>
  70 
  71 #endif /* !STANDALONE_ */
  72 
  73 
<span class="line-modified">  74   /*************************************************************************/</span>
<span class="line-modified">  75   /*                                                                       */</span>
<span class="line-modified">  76   /* A simple technical note on how the raster works                       */</span>
<span class="line-modified">  77   /* -----------------------------------------------                       */</span>
<span class="line-modified">  78   /*                                                                       */</span>
<span class="line-modified">  79   /*   Converting an outline into a bitmap is achieved in several steps:   */</span>
<span class="line-modified">  80   /*                                                                       */</span>
<span class="line-modified">  81   /*   1 - Decomposing the outline into successive `profiles&#39;.  Each       */</span>
<span class="line-modified">  82   /*       profile is simply an array of scanline intersections on a given */</span>
<span class="line-modified">  83   /*       dimension.  A profile&#39;s main attributes are                     */</span>
<span class="line-modified">  84   /*                                                                       */</span>
<span class="line-modified">  85   /*       o its scanline position boundaries, i.e. `Ymin&#39; and `Ymax&#39;      */</span>
<span class="line-modified">  86   /*                                                                       */</span>
<span class="line-modified">  87   /*       o an array of intersection coordinates for each scanline        */</span>
<span class="line-modified">  88   /*         between `Ymin&#39; and `Ymax&#39;                                     */</span>
<span class="line-modified">  89   /*                                                                       */</span>
<span class="line-modified">  90   /*       o a direction, indicating whether it was built going `up&#39; or    */</span>
<span class="line-modified">  91   /*         `down&#39;, as this is very important for filling rules           */</span>
<span class="line-modified">  92   /*                                                                       */</span>
<span class="line-modified">  93   /*       o its drop-out mode                                             */</span>
<span class="line-modified">  94   /*                                                                       */</span>
<span class="line-modified">  95   /*   2 - Sweeping the target map&#39;s scanlines in order to compute segment */</span>
<span class="line-modified">  96   /*       `spans&#39; which are then filled.  Additionally, this pass         */</span>
<span class="line-modified">  97   /*       performs drop-out control.                                      */</span>
<span class="line-modified">  98   /*                                                                       */</span>
<span class="line-modified">  99   /*   The outline data is parsed during step 1 only.  The profiles are    */</span>
<span class="line-modified"> 100   /*   built from the bottom of the render pool, used as a stack.  The     */</span>
<span class="line-modified"> 101   /*   following graphics shows the profile list under construction:       */</span>
<span class="line-modified"> 102   /*                                                                       */</span>
<span class="line-modified"> 103   /*     __________________________________________________________ _ _    */</span>
<span class="line-modified"> 104   /*    |         |                 |         |                 |          */</span>
<span class="line-modified"> 105   /*    | profile | coordinates for | profile | coordinates for |--&gt;       */</span>
<span class="line-modified"> 106   /*    |    1    |  profile 1      |    2    |  profile 2      |--&gt;       */</span>
<span class="line-modified"> 107   /*    |_________|_________________|_________|_________________|__ _ _    */</span>
<span class="line-modified"> 108   /*                                                                       */</span>
<span class="line-modified"> 109   /*    ^                                                       ^          */</span>
<span class="line-modified"> 110   /*    |                                                       |          */</span>
<span class="line-modified"> 111   /* start of render pool                                      top         */</span>
<span class="line-modified"> 112   /*                                                                       */</span>
<span class="line-modified"> 113   /*   The top of the profile stack is kept in the `top&#39; variable.         */</span>
<span class="line-modified"> 114   /*                                                                       */</span>
<span class="line-modified"> 115   /*   As you can see, a profile record is pushed on top of the render     */</span>
<span class="line-modified"> 116   /*   pool, which is then followed by its coordinates/intersections.  If  */</span>
<span class="line-modified"> 117   /*   a change of direction is detected in the outline, a new profile is  */</span>
<span class="line-modified"> 118   /*   generated until the end of the outline.                             */</span>
<span class="line-modified"> 119   /*                                                                       */</span>
<span class="line-modified"> 120   /*   Note that when all profiles have been generated, the function       */</span>
<span class="line-modified"> 121   /*   Finalize_Profile_Table() is used to record, for each profile, its   */</span>
<span class="line-modified"> 122   /*   bottom-most scanline as well as the scanline above its upmost       */</span>
<span class="line-modified"> 123   /*   boundary.  These positions are called `y-turns&#39; because they (sort  */</span>
<span class="line-modified"> 124   /*   of) correspond to local extrema.  They are stored in a sorted list  */</span>
<span class="line-modified"> 125   /*   built from the top of the render pool as a downwards stack:         */</span>
<span class="line-modified"> 126   /*                                                                       */</span>
<span class="line-modified"> 127   /*      _ _ _______________________________________                      */</span>
<span class="line-modified"> 128   /*                            |                    |                     */</span>
<span class="line-modified"> 129   /*                         &lt;--| sorted list of     |                     */</span>
<span class="line-modified"> 130   /*                         &lt;--|  extrema scanlines |                     */</span>
<span class="line-modified"> 131   /*      _ _ __________________|____________________|                     */</span>
<span class="line-modified"> 132   /*                                                                       */</span>
<span class="line-modified"> 133   /*                            ^                    ^                     */</span>
<span class="line-modified"> 134   /*                            |                    |                     */</span>
<span class="line-modified"> 135   /*                         maxBuff           sizeBuff = end of pool      */</span>
<span class="line-modified"> 136   /*                                                                       */</span>
<span class="line-modified"> 137   /*   This list is later used during the sweep phase in order to          */</span>
<span class="line-modified"> 138   /*   optimize performance (see technical note on the sweep below).       */</span>
<span class="line-modified"> 139   /*                                                                       */</span>
<span class="line-modified"> 140   /*   Of course, the raster detects whether the two stacks collide and    */</span>
<span class="line-modified"> 141   /*   handles the situation properly.                                     */</span>
<span class="line-modified"> 142   /*                                                                       */</span>
<span class="line-modified"> 143   /*************************************************************************/</span>
 144 
 145 
 146   /*************************************************************************/
 147   /*************************************************************************/
 148   /**                                                                     **/
 149   /**  CONFIGURATION MACROS                                               **/
 150   /**                                                                     **/
 151   /*************************************************************************/
 152   /*************************************************************************/
 153 
 154   /* define DEBUG_RASTER if you want to compile a debugging version */
 155 /* #define DEBUG_RASTER */
 156 
 157 
 158   /*************************************************************************/
 159   /*************************************************************************/
 160   /**                                                                     **/
 161   /**  OTHER MACROS (do not change)                                       **/
 162   /**                                                                     **/
 163   /*************************************************************************/
 164   /*************************************************************************/
 165 
<span class="line-modified"> 166   /*************************************************************************/</span>
<span class="line-modified"> 167   /*                                                                       */</span>
<span class="line-modified"> 168   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 169   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 170   /* messages during execution.                                            */</span>
<span class="line-modified"> 171   /*                                                                       */</span>
 172 #undef  FT_COMPONENT
<span class="line-modified"> 173 #define FT_COMPONENT  trace_raster</span>
 174 
 175 
 176 #ifdef STANDALONE_
 177 
 178   /* Auxiliary macros for token concatenation. */
 179 #define FT_ERR_XCAT( x, y )  x ## y
 180 #define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )
 181 
 182   /* This macro is used to indicate that a function parameter is unused. */
 183   /* Its purpose is simply to reduce compiler warnings.  Note also that  */
 184   /* simply defining it as `(void)x&#39; doesn&#39;t avoid warnings with certain */
 185   /* ANSI compilers (e.g. LCC).                                          */
 186 #define FT_UNUSED( x )  (x) = (x)
 187 
 188   /* Disable the tracing mechanism for simplicity -- developers can      */
 189   /* activate it easily by redefining these macros.                      */
 190 #ifndef FT_ERROR
 191 #define FT_ERROR( x )  do { } while ( 0 )     /* nothing */
 192 #endif
 193 
</pre>
<hr />
<pre>
 383   {
 384     Short  y_min;   /* band&#39;s minimum */
 385     Short  y_max;   /* band&#39;s maximum */
 386 
 387   } black_TBand;
 388 
 389 
 390 #define AlignProfileSize \
 391   ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( Long ) )
 392 
 393 
 394 #undef RAS_ARG
 395 #undef RAS_ARGS
 396 #undef RAS_VAR
 397 #undef RAS_VARS
 398 
 399 #ifdef FT_STATIC_RASTER
 400 
 401 
 402 #define RAS_ARGS       /* void */
<span class="line-modified"> 403 #define RAS_ARG        /* void */</span>
 404 
 405 #define RAS_VARS       /* void */
 406 #define RAS_VAR        /* void */
 407 
 408 #define FT_UNUSED_RASTER  do { } while ( 0 )
 409 
 410 
 411 #else /* !FT_STATIC_RASTER */
 412 
 413 
 414 #define RAS_ARGS       black_PWorker  worker,
 415 #define RAS_ARG        black_PWorker  worker
 416 
 417 #define RAS_VARS       worker,
 418 #define RAS_VAR        worker
 419 
 420 #define FT_UNUSED_RASTER  FT_UNUSED( worker )
 421 
 422 
 423 #endif /* !FT_STATIC_RASTER */
</pre>
<hr />
<pre>
 435   Function_Sweep_Span( RAS_ARGS Short       y,
 436                                 FT_F26Dot6  x1,
 437                                 FT_F26Dot6  x2,
 438                                 PProfile    left,
 439                                 PProfile    right );
 440 
 441   typedef void
 442   Function_Sweep_Step( RAS_ARG );
 443 
 444 
 445   /* NOTE: These operations are only valid on 2&#39;s complement processors */
 446 #undef FLOOR
 447 #undef CEILING
 448 #undef TRUNC
 449 #undef SCALED
 450 
 451 #define FLOOR( x )    ( (x) &amp; -ras.precision )
 452 #define CEILING( x )  ( ( (x) + ras.precision - 1 ) &amp; -ras.precision )
 453 #define TRUNC( x )    ( (Long)(x) &gt;&gt; ras.precision_bits )
 454 #define FRAC( x )     ( (x) &amp; ( ras.precision - 1 ) )
<span class="line-modified"> 455 #define SCALED( x )   ( ( (x) &lt; 0 ? -( -(x) &lt;&lt; ras.scale_shift )   \</span>
<span class="line-modified"> 456                                   :  (  (x) &lt;&lt; ras.scale_shift ) ) \</span>
<span class="line-modified"> 457                         - ras.precision_half )</span>
 458 
 459 #define IS_BOTTOM_OVERSHOOT( x ) \
 460           (Bool)( CEILING( x ) - x &gt;= ras.precision_half )
 461 #define IS_TOP_OVERSHOOT( x )    \
 462           (Bool)( x - FLOOR( x ) &gt;= ras.precision_half )
 463 
 464 #if FT_RENDER_POOL_SIZE &gt; 2048
 465 #define FT_MAX_BLACK_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( Long ) )
 466 #else
 467 #define FT_MAX_BLACK_POOL  ( 2048 / sizeof ( Long ) )
 468 #endif
 469 
 470   /* The most used variables are positioned at the top of the structure. */
 471   /* Thus, their offset can be coded with less opcodes, resulting in a   */
 472   /* smaller executable.                                                 */
 473 
 474   struct  black_TWorker_
 475   {
 476     Int         precision_bits;     /* precision related variables         */
 477     Int         precision;
 478     Int         precision_half;
<span class="line-modified"> 479     Int         precision_shift;</span>
 480     Int         precision_step;
 481     Int         precision_jitter;
 482 
<span class="line-removed"> 483     Int         scale_shift;        /* == precision_shift   for bitmaps    */</span>
<span class="line-removed"> 484                                     /* == precision_shift+1 for pixmaps    */</span>
<span class="line-removed"> 485 </span>
 486     PLong       buff;               /* The profiles buffer                 */
 487     PLong       sizeBuff;           /* Render pool size                    */
 488     PLong       maxBuff;            /* Profiles buffer size                */
 489     PLong       top;                /* Current cursor in buffer            */
 490 
 491     FT_Error    error;
 492 
 493     Int         numTurns;           /* number of Y-turns in outline        */
 494 
 495     TPoint*     arc;                /* current Bezier arc pointer          */
 496 
 497     UShort      bWidth;             /* target bitmap width                 */
<span class="line-modified"> 498     PByte       bTarget;            /* target bitmap buffer                */</span>
<span class="line-removed"> 499     PByte       gTarget;            /* target pixmap buffer                */</span>
 500 
 501     Long        lastX, lastY;
 502     Long        minY, maxY;
 503 
 504     UShort      num_Profs;          /* current number of profiles          */
 505 
 506     Bool        fresh;              /* signals a fresh new profile which   */
 507                                     /* `start&#39; field must be completed     */
 508     Bool        joint;              /* signals that the last arc ended     */
 509                                     /* exactly on a scanline.  Allows      */
 510                                     /* removal of doublets                 */
 511     PProfile    cProfile;           /* current profile                     */
 512     PProfile    fProfile;           /* head of linked list of profiles     */
 513     PProfile    gProfile;           /* contour&#39;s first profile in case     */
 514                                     /* of impact                           */
 515 
 516     TStates     state;              /* rendering state                     */
 517 
 518     FT_Bitmap   target;             /* description of target bit/pixmap    */
 519     FT_Outline  outline;
 520 
 521     Long        traceOfs;           /* current offset in target bitmap     */
<span class="line-removed"> 522     Long        traceG;             /* current offset in target pixmap     */</span>
<span class="line-removed"> 523 </span>
 524     Short       traceIncr;          /* sweep&#39;s increment in target bitmap  */
 525 
 526     /* dispatch variables */
 527 
 528     Function_Sweep_Init*  Proc_Sweep_Init;
 529     Function_Sweep_Span*  Proc_Sweep_Span;
 530     Function_Sweep_Span*  Proc_Sweep_Drop;
 531     Function_Sweep_Step*  Proc_Sweep_Step;
 532 
 533     Byte        dropOutControl;     /* current drop_out control method     */
 534 
 535     Bool        second_pass;        /* indicates whether a horizontal pass */
 536                                     /* should be performed to control      */
 537                                     /* drop-out accurately when calling    */
 538                                     /* Render_Glyph.                       */
 539 
 540     TPoint      arcs[3 * MaxBezier + 1]; /* The Bezier stack               */
 541 
 542     black_TBand  band_stack[16];    /* band stack used for sub-banding     */
 543     Int          band_top;          /* band stack top                      */
 544 
 545   };
 546 
 547 
 548   typedef struct  black_TRaster_
 549   {
 550     void*          memory;
 551 
 552   } black_TRaster, *black_PRaster;
 553 
 554 #ifdef FT_STATIC_RASTER
 555 
<span class="line-modified"> 556   static black_TWorker  cur_ras;</span>
<span class="line-removed"> 557 #define ras  cur_ras</span>
 558 
 559 #else /* !FT_STATIC_RASTER */
 560 
 561 #define ras  (*worker)
 562 
 563 #endif /* !FT_STATIC_RASTER */
 564 
 565 
 566   /*************************************************************************/
 567   /*************************************************************************/
 568   /**                                                                     **/
 569   /**  PROFILES COMPUTATION                                               **/
 570   /**                                                                     **/
 571   /*************************************************************************/
 572   /*************************************************************************/
 573 
 574 
<span class="line-modified"> 575   /*************************************************************************/</span>
<span class="line-modified"> 576   /*                                                                       */</span>
<span class="line-modified"> 577   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 578   /*    Set_High_Precision                                                 */</span>
<span class="line-modified"> 579   /*                                                                       */</span>
<span class="line-modified"> 580   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 581   /*    Set precision variables according to param flag.                   */</span>
<span class="line-modified"> 582   /*                                                                       */</span>
<span class="line-modified"> 583   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 584   /*    High :: Set to True for high precision (typically for ppem &lt; 24),  */</span>
<span class="line-modified"> 585   /*            false otherwise.                                           */</span>
<span class="line-modified"> 586   /*                                                                       */</span>

 587   static void
 588   Set_High_Precision( RAS_ARGS Int  High )
 589   {
 590     /*
 591      * `precision_step&#39; is used in `Bezier_Up&#39; to decide when to split a
 592      * given y-monotonous Bezier arc that crosses a scanline before
 593      * approximating it as a straight segment.  The default value of 32 (for
 594      * low accuracy) corresponds to
 595      *
 596      *   32 / 64 == 0.5 pixels,
 597      *
 598      * while for the high accuracy case we have
 599      *
 600      *   256 / (1 &lt;&lt; 12) = 0.0625 pixels.
 601      *
 602      * `precision_jitter&#39; is an epsilon threshold used in
 603      * `Vertical_Sweep_Span&#39; to deal with small imperfections in the Bezier
 604      * decomposition (after all, we are working with approximations only);
 605      * it avoids switching on additional pixels which would cause artifacts
 606      * otherwise.
</pre>
<hr />
<pre>
 608      * The value of `precision_jitter&#39; has been determined heuristically.
 609      *
 610      */
 611 
 612     if ( High )
 613     {
 614       ras.precision_bits   = 12;
 615       ras.precision_step   = 256;
 616       ras.precision_jitter = 30;
 617     }
 618     else
 619     {
 620       ras.precision_bits   = 6;
 621       ras.precision_step   = 32;
 622       ras.precision_jitter = 2;
 623     }
 624 
 625     FT_TRACE6(( &quot;Set_High_Precision(%s)\n&quot;, High ? &quot;true&quot; : &quot;false&quot; ));
 626 
 627     ras.precision       = 1 &lt;&lt; ras.precision_bits;
<span class="line-modified"> 628     ras.precision_half  = ras.precision / 2;</span>
<span class="line-modified"> 629     ras.precision_shift = ras.precision_bits - Pixel_Bits;</span>
 630   }
 631 
 632 
<span class="line-modified"> 633   /*************************************************************************/</span>
<span class="line-modified"> 634   /*                                                                       */</span>
<span class="line-modified"> 635   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 636   /*    New_Profile                                                        */</span>
<span class="line-modified"> 637   /*                                                                       */</span>
<span class="line-modified"> 638   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 639   /*    Create a new profile in the render pool.                           */</span>
<span class="line-modified"> 640   /*                                                                       */</span>
<span class="line-modified"> 641   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 642   /*    aState    :: The state/orientation of the new profile.             */</span>
<span class="line-modified"> 643   /*                                                                       */</span>
<span class="line-modified"> 644   /*    overshoot :: Whether the profile&#39;s unrounded start position        */</span>
<span class="line-modified"> 645   /*                 differs by at least a half pixel.                     */</span>
<span class="line-modified"> 646   /*                                                                       */</span>
<span class="line-modified"> 647   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 648   /*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */</span>
<span class="line-modified"> 649   /*   profile.                                                            */</span>
<span class="line-modified"> 650   /*                                                                       */</span>


 651   static Bool
 652   New_Profile( RAS_ARGS TStates  aState,
 653                         Bool     overshoot )
 654   {
 655     if ( !ras.fProfile )
 656     {
 657       ras.cProfile  = (PProfile)ras.top;
 658       ras.fProfile  = ras.cProfile;
 659       ras.top      += AlignProfileSize;
 660     }
 661 
 662     if ( ras.top &gt;= ras.maxBuff )
 663     {
 664       ras.error = FT_THROW( Overflow );
 665       return FAILURE;
 666     }
 667 
<span class="line-removed"> 668     ras.cProfile-&gt;flags  = 0;</span>
 669     ras.cProfile-&gt;start  = 0;
 670     ras.cProfile-&gt;height = 0;
 671     ras.cProfile-&gt;offset = ras.top;
 672     ras.cProfile-&gt;link   = (PProfile)0;
 673     ras.cProfile-&gt;next   = (PProfile)0;
 674     ras.cProfile-&gt;flags  = ras.dropOutControl;
 675 
 676     switch ( aState )
 677     {
 678     case Ascending_State:
 679       ras.cProfile-&gt;flags |= Flow_Up;
 680       if ( overshoot )
 681         ras.cProfile-&gt;flags |= Overshoot_Bottom;
 682 
 683       FT_TRACE6(( &quot;  new ascending profile = %p\n&quot;, ras.cProfile ));
 684       break;
 685 
 686     case Descending_State:
 687       if ( overshoot )
 688         ras.cProfile-&gt;flags |= Overshoot_Top;
 689       FT_TRACE6(( &quot;  new descending profile = %p\n&quot;, ras.cProfile ));
 690       break;
 691 
 692     default:
 693       FT_ERROR(( &quot;New_Profile: invalid profile direction\n&quot; ));
 694       ras.error = FT_THROW( Invalid );
 695       return FAILURE;
 696     }
 697 
 698     if ( !ras.gProfile )
 699       ras.gProfile = ras.cProfile;
 700 
 701     ras.state = aState;
 702     ras.fresh = TRUE;
 703     ras.joint = FALSE;
 704 
 705     return SUCCESS;
 706   }
 707 
 708 
<span class="line-modified"> 709   /*************************************************************************/</span>
<span class="line-modified"> 710   /*                                                                       */</span>
<span class="line-modified"> 711   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 712   /*    End_Profile                                                        */</span>
<span class="line-modified"> 713   /*                                                                       */</span>
<span class="line-modified"> 714   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 715   /*    Finalize the current profile.                                      */</span>
<span class="line-modified"> 716   /*                                                                       */</span>
<span class="line-modified"> 717   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 718   /*    overshoot :: Whether the profile&#39;s unrounded end position differs  */</span>
<span class="line-modified"> 719   /*                 by at least a half pixel.                             */</span>
<span class="line-modified"> 720   /*                                                                       */</span>
<span class="line-modified"> 721   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 722   /*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */</span>
<span class="line-modified"> 723   /*                                                                       */</span>

 724   static Bool
 725   End_Profile( RAS_ARGS Bool  overshoot )
 726   {
 727     Long  h;
 728 
 729 
 730     h = (Long)( ras.top - ras.cProfile-&gt;offset );
 731 
 732     if ( h &lt; 0 )
 733     {
 734       FT_ERROR(( &quot;End_Profile: negative height encountered\n&quot; ));
 735       ras.error = FT_THROW( Neg_Height );
 736       return FAILURE;
 737     }
 738 
 739     if ( h &gt; 0 )
 740     {
 741       PProfile  oldProfile;
 742 
 743 
</pre>
<hr />
<pre>
 761       ras.cProfile-&gt;height = 0;
 762       ras.cProfile-&gt;offset = ras.top;
 763 
 764       oldProfile-&gt;next = ras.cProfile;
 765       ras.num_Profs++;
 766     }
 767 
 768     if ( ras.top &gt;= ras.maxBuff )
 769     {
 770       FT_TRACE1(( &quot;overflow in End_Profile\n&quot; ));
 771       ras.error = FT_THROW( Overflow );
 772       return FAILURE;
 773     }
 774 
 775     ras.joint = FALSE;
 776 
 777     return SUCCESS;
 778   }
 779 
 780 
<span class="line-modified"> 781   /*************************************************************************/</span>
<span class="line-modified"> 782   /*                                                                       */</span>
<span class="line-modified"> 783   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 784   /*    Insert_Y_Turn                                                      */</span>
<span class="line-modified"> 785   /*                                                                       */</span>
<span class="line-modified"> 786   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 787   /*    Insert a salient into the sorted list placed on top of the render  */</span>
<span class="line-modified"> 788   /*    pool.                                                              */</span>
<span class="line-modified"> 789   /*                                                                       */</span>
<span class="line-modified"> 790   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 791   /*    New y scanline position.                                           */</span>
<span class="line-modified"> 792   /*                                                                       */</span>
<span class="line-modified"> 793   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 794   /*    SUCCESS on success.  FAILURE in case of overflow.                  */</span>
<span class="line-modified"> 795   /*                                                                       */</span>
 796   static Bool
 797   Insert_Y_Turn( RAS_ARGS Int  y )
 798   {
 799     PLong  y_turns;
 800     Int    n;
 801 
 802 
 803     n       = ras.numTurns - 1;
 804     y_turns = ras.sizeBuff - ras.numTurns;
 805 
 806     /* look for first y value that is &lt;= */
 807     while ( n &gt;= 0 &amp;&amp; y &lt; y_turns[n] )
 808       n--;
 809 
 810     /* if it is &lt;, simply insert it, ignore if == */
 811     if ( n &gt;= 0 &amp;&amp; y &gt; y_turns[n] )
 812       do
 813       {
 814         Int  y2 = (Int)y_turns[n];
 815 
</pre>
<hr />
<pre>
 817         y_turns[n] = y;
 818         y = y2;
 819       } while ( --n &gt;= 0 );
 820 
 821     if ( n &lt; 0 )
 822     {
 823       ras.maxBuff--;
 824       if ( ras.maxBuff &lt;= ras.top )
 825       {
 826         ras.error = FT_THROW( Overflow );
 827         return FAILURE;
 828       }
 829       ras.numTurns++;
 830       ras.sizeBuff[-ras.numTurns] = y;
 831     }
 832 
 833     return SUCCESS;
 834   }
 835 
 836 
<span class="line-modified"> 837   /*************************************************************************/</span>
<span class="line-modified"> 838   /*                                                                       */</span>
<span class="line-modified"> 839   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 840   /*    Finalize_Profile_Table                                             */</span>
<span class="line-modified"> 841   /*                                                                       */</span>
<span class="line-modified"> 842   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 843   /*    Adjust all links in the profiles list.                             */</span>
<span class="line-modified"> 844   /*                                                                       */</span>
<span class="line-modified"> 845   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 846   /*    SUCCESS on success.  FAILURE in case of overflow.                  */</span>
<span class="line-modified"> 847   /*                                                                       */</span>
 848   static Bool
 849   Finalize_Profile_Table( RAS_ARG )
 850   {
 851     UShort    n;
 852     PProfile  p;
 853 
 854 
 855     n = ras.num_Profs;
 856     p = ras.fProfile;
 857 
 858     if ( n &gt; 1 &amp;&amp; p )
 859     {
 860       do
 861       {
 862         Int  bottom, top;
 863 
 864 
 865         if ( n &gt; 1 )
 866           p-&gt;link = (PProfile)( p-&gt;offset + p-&gt;height );
 867         else
</pre>
<hr />
<pre>
 877           bottom     = (Int)( p-&gt;start - p-&gt;height + 1 );
 878           top        = (Int)p-&gt;start;
 879           p-&gt;start   = bottom;
 880           p-&gt;offset += p-&gt;height - 1;
 881         }
 882 
 883         if ( Insert_Y_Turn( RAS_VARS bottom )  ||
 884              Insert_Y_Turn( RAS_VARS top + 1 ) )
 885           return FAILURE;
 886 
 887         p = p-&gt;link;
 888       } while ( --n );
 889     }
 890     else
 891       ras.fProfile = NULL;
 892 
 893     return SUCCESS;
 894   }
 895 
 896 
<span class="line-modified"> 897   /*************************************************************************/</span>
<span class="line-modified"> 898   /*                                                                       */</span>
<span class="line-modified"> 899   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 900   /*    Split_Conic                                                        */</span>
<span class="line-modified"> 901   /*                                                                       */</span>
<span class="line-modified"> 902   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 903   /*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */</span>
<span class="line-modified"> 904   /*    stack.                                                             */</span>
<span class="line-modified"> 905   /*                                                                       */</span>
<span class="line-modified"> 906   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 907   /*    None (subdivided Bezier is taken from the top of the stack).       */</span>
<span class="line-modified"> 908   /*                                                                       */</span>
<span class="line-modified"> 909   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 910   /*    This routine is the `beef&#39; of this component.  It is  _the_ inner  */</span>
<span class="line-modified"> 911   /*    loop that should be optimized to hell to get the best performance. */</span>
<span class="line-modified"> 912   /*                                                                       */</span>
 913   static void
 914   Split_Conic( TPoint*  base )
 915   {
 916     Long  a, b;
 917 
 918 
 919     base[4].x = base[2].x;
<span class="line-modified"> 920     b = base[1].x;</span>
<span class="line-modified"> 921     a = base[3].x = ( base[2].x + b ) / 2;</span>
<span class="line-modified"> 922     b = base[1].x = ( base[0].x + b ) / 2;</span>
<span class="line-modified"> 923     base[2].x = ( a + b ) / 2;</span>

 924 
 925     base[4].y = base[2].y;
<span class="line-modified"> 926     b = base[1].y;</span>
<span class="line-modified"> 927     a = base[3].y = ( base[2].y + b ) / 2;</span>
<span class="line-modified"> 928     b = base[1].y = ( base[0].y + b ) / 2;</span>
<span class="line-modified"> 929     base[2].y = ( a + b ) / 2;</span>

 930 
 931     /* hand optimized.  gcc doesn&#39;t seem to be too good at common      */
 932     /* expression substitution and instruction scheduling ;-)          */
 933   }
 934 
 935 
<span class="line-modified"> 936   /*************************************************************************/</span>
<span class="line-modified"> 937   /*                                                                       */</span>
<span class="line-modified"> 938   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 939   /*    Split_Cubic                                                        */</span>
<span class="line-modified"> 940   /*                                                                       */</span>
<span class="line-modified"> 941   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 942   /*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */</span>
<span class="line-modified"> 943   /*    Bezier stack.                                                      */</span>
<span class="line-modified"> 944   /*                                                                       */</span>
<span class="line-modified"> 945   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 946   /*    This routine is the `beef&#39; of the component.  It is one of _the_   */</span>
<span class="line-modified"> 947   /*    inner loops that should be optimized like hell to get the best     */</span>
<span class="line-modified"> 948   /*    performance.                                                       */</span>
<span class="line-modified"> 949   /*                                                                       */</span>
 950   static void
 951   Split_Cubic( TPoint*  base )
 952   {
<span class="line-modified"> 953     Long  a, b, c, d;</span>
 954 
 955 
 956     base[6].x = base[3].x;
<span class="line-modified"> 957     c = base[1].x;</span>
<span class="line-modified"> 958     d = base[2].x;</span>
<span class="line-modified"> 959     base[1].x = a = ( base[0].x + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 960     base[5].x = b = ( base[3].x + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 961     c = ( c + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 962     base[2].x = a = ( a + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 963     base[4].x = b = ( b + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 964     base[3].x = ( a + b + 1 ) &gt;&gt; 1;</span>


 965 
 966     base[6].y = base[3].y;
<span class="line-modified"> 967     c = base[1].y;</span>
<span class="line-modified"> 968     d = base[2].y;</span>
<span class="line-modified"> 969     base[1].y = a = ( base[0].y + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 970     base[5].y = b = ( base[3].y + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 971     c = ( c + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 972     base[2].y = a = ( a + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 973     base[4].y = b = ( b + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified"> 974     base[3].y = ( a + b + 1 ) &gt;&gt; 1;</span>


 975   }
 976 
 977 
<span class="line-modified"> 978   /*************************************************************************/</span>
<span class="line-modified"> 979   /*                                                                       */</span>
<span class="line-modified"> 980   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 981   /*    Line_Up                                                            */</span>
<span class="line-modified"> 982   /*                                                                       */</span>
<span class="line-modified"> 983   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 984   /*    Compute the x-coordinates of an ascending line segment and store   */</span>
<span class="line-modified"> 985   /*    them in the render pool.                                           */</span>
<span class="line-modified"> 986   /*                                                                       */</span>
<span class="line-modified"> 987   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 988   /*    x1   :: The x-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified"> 989   /*                                                                       */</span>
<span class="line-modified"> 990   /*    y1   :: The y-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified"> 991   /*                                                                       */</span>
<span class="line-modified"> 992   /*    x2   :: The x-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified"> 993   /*                                                                       */</span>
<span class="line-modified"> 994   /*    y2   :: The y-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified"> 995   /*                                                                       */</span>
<span class="line-modified"> 996   /*    miny :: A lower vertical clipping bound value.                     */</span>
<span class="line-modified"> 997   /*                                                                       */</span>
<span class="line-modified"> 998   /*    maxy :: An upper vertical clipping bound value.                    */</span>
<span class="line-modified"> 999   /*                                                                       */</span>
<span class="line-modified">1000   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1001   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">1002   /*                                                                       */</span>






1003   static Bool
1004   Line_Up( RAS_ARGS Long  x1,
1005                     Long  y1,
1006                     Long  x2,
1007                     Long  y2,
1008                     Long  miny,
1009                     Long  maxy )
1010   {
1011     Long   Dx, Dy;
1012     Int    e1, e2, f1, f2, size;     /* XXX: is `Short&#39; sufficient? */
1013     Long   Ix, Rx, Ax;
1014 
1015     PLong  top;
1016 
1017 
1018     Dx = x2 - x1;
1019     Dy = y2 - y1;
1020 
1021     if ( Dy &lt;= 0 || y2 &lt; miny || y1 &gt; maxy )
1022       return SUCCESS;
</pre>
<hr />
<pre>
1097 
1098     while ( size &gt; 0 )
1099     {
1100       *top++ = x1;
1101 
1102       x1 += Ix;
1103       Ax += Rx;
1104       if ( Ax &gt;= 0 )
1105       {
1106         Ax -= Dy;
1107         x1 += Dx;
1108       }
1109       size--;
1110     }
1111 
1112     ras.top = top;
1113     return SUCCESS;
1114   }
1115 
1116 
<span class="line-modified">1117   /*************************************************************************/</span>
<span class="line-modified">1118   /*                                                                       */</span>
<span class="line-modified">1119   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1120   /*    Line_Down                                                          */</span>
<span class="line-modified">1121   /*                                                                       */</span>
<span class="line-modified">1122   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1123   /*    Compute the x-coordinates of an descending line segment and store  */</span>
<span class="line-modified">1124   /*    them in the render pool.                                           */</span>
<span class="line-modified">1125   /*                                                                       */</span>
<span class="line-modified">1126   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1127   /*    x1   :: The x-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">1128   /*                                                                       */</span>
<span class="line-modified">1129   /*    y1   :: The y-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">1130   /*                                                                       */</span>
<span class="line-modified">1131   /*    x2   :: The x-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">1132   /*                                                                       */</span>
<span class="line-modified">1133   /*    y2   :: The y-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">1134   /*                                                                       */</span>
<span class="line-modified">1135   /*    miny :: A lower vertical clipping bound value.                     */</span>
<span class="line-modified">1136   /*                                                                       */</span>
<span class="line-modified">1137   /*    maxy :: An upper vertical clipping bound value.                    */</span>
<span class="line-modified">1138   /*                                                                       */</span>
<span class="line-modified">1139   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1140   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">1141   /*                                                                       */</span>






1142   static Bool
1143   Line_Down( RAS_ARGS Long  x1,
1144                       Long  y1,
1145                       Long  x2,
1146                       Long  y2,
1147                       Long  miny,
1148                       Long  maxy )
1149   {
1150     Bool  result, fresh;
1151 
1152 
1153     fresh  = ras.fresh;
1154 
1155     result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );
1156 
1157     if ( fresh &amp;&amp; !ras.fresh )
1158       ras.cProfile-&gt;start = -ras.cProfile-&gt;start;
1159 
1160     return result;
1161   }
1162 
1163 
1164   /* A function type describing the functions used to split Bezier arcs */
1165   typedef void  (*TSplitter)( TPoint*  base );
1166 
1167 
<span class="line-modified">1168   /*************************************************************************/</span>
<span class="line-modified">1169   /*                                                                       */</span>
<span class="line-modified">1170   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1171   /*    Bezier_Up                                                          */</span>
<span class="line-modified">1172   /*                                                                       */</span>
<span class="line-modified">1173   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1174   /*    Compute the x-coordinates of an ascending Bezier arc and store     */</span>
<span class="line-modified">1175   /*    them in the render pool.                                           */</span>
<span class="line-modified">1176   /*                                                                       */</span>
<span class="line-modified">1177   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1178   /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */</span>
<span class="line-modified">1179   /*                                                                       */</span>
<span class="line-modified">1180   /*    splitter :: The function to split Bezier arcs.                     */</span>
<span class="line-modified">1181   /*                                                                       */</span>
<span class="line-modified">1182   /*    miny     :: A lower vertical clipping bound value.                 */</span>
<span class="line-modified">1183   /*                                                                       */</span>
<span class="line-modified">1184   /*    maxy     :: An upper vertical clipping bound value.                */</span>
<span class="line-modified">1185   /*                                                                       */</span>
<span class="line-modified">1186   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1187   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">1188   /*                                                                       */</span>




1189   static Bool
1190   Bezier_Up( RAS_ARGS Int        degree,
1191                       TSplitter  splitter,
1192                       Long       miny,
1193                       Long       maxy )
1194   {
1195     Long   y1, y2, e, e2, e0;
1196     Short  f1;
1197 
1198     TPoint*  arc;
1199     TPoint*  start_arc;
1200 
1201     PLong top;
1202 
1203 
1204     arc = ras.arc;
1205     y1  = arc[degree].y;
1206     y2  = arc[0].y;
1207     top = ras.top;
1208 
</pre>
<hr />
<pre>
1281       else
1282       {
1283         if ( y2 == e )
1284         {
1285           ras.joint  = TRUE;
1286           *top++     = arc[0].x;
1287 
1288           e += ras.precision;
1289         }
1290         arc -= degree;
1291       }
1292     } while ( arc &gt;= start_arc &amp;&amp; e &lt;= e2 );
1293 
1294   Fin:
1295     ras.top  = top;
1296     ras.arc -= degree;
1297     return SUCCESS;
1298   }
1299 
1300 
<span class="line-modified">1301   /*************************************************************************/</span>
<span class="line-modified">1302   /*                                                                       */</span>
<span class="line-modified">1303   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1304   /*    Bezier_Down                                                        */</span>
<span class="line-modified">1305   /*                                                                       */</span>
<span class="line-modified">1306   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1307   /*    Compute the x-coordinates of an descending Bezier arc and store    */</span>
<span class="line-modified">1308   /*    them in the render pool.                                           */</span>
<span class="line-modified">1309   /*                                                                       */</span>
<span class="line-modified">1310   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1311   /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */</span>
<span class="line-modified">1312   /*                                                                       */</span>
<span class="line-modified">1313   /*    splitter :: The function to split Bezier arcs.                     */</span>
<span class="line-modified">1314   /*                                                                       */</span>
<span class="line-modified">1315   /*    miny     :: A lower vertical clipping bound value.                 */</span>
<span class="line-modified">1316   /*                                                                       */</span>
<span class="line-modified">1317   /*    maxy     :: An upper vertical clipping bound value.                */</span>
<span class="line-modified">1318   /*                                                                       */</span>
<span class="line-modified">1319   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1320   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">1321   /*                                                                       */</span>




1322   static Bool
1323   Bezier_Down( RAS_ARGS Int        degree,
1324                         TSplitter  splitter,
1325                         Long       miny,
1326                         Long       maxy )
1327   {
1328     TPoint*  arc = ras.arc;
1329     Bool     result, fresh;
1330 
1331 
1332     arc[0].y = -arc[0].y;
1333     arc[1].y = -arc[1].y;
1334     arc[2].y = -arc[2].y;
1335     if ( degree &gt; 2 )
1336       arc[3].y = -arc[3].y;
1337 
1338     fresh = ras.fresh;
1339 
1340     result = Bezier_Up( RAS_VARS degree, splitter, -maxy, -miny );
1341 
1342     if ( fresh &amp;&amp; !ras.fresh )
1343       ras.cProfile-&gt;start = -ras.cProfile-&gt;start;
1344 
1345     arc[0].y = -arc[0].y;
1346     return result;
1347   }
1348 
1349 
<span class="line-modified">1350   /*************************************************************************/</span>
<span class="line-modified">1351   /*                                                                       */</span>
<span class="line-modified">1352   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1353   /*    Line_To                                                            */</span>
<span class="line-modified">1354   /*                                                                       */</span>
<span class="line-modified">1355   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1356   /*    Inject a new line segment and adjust the Profiles list.            */</span>
<span class="line-modified">1357   /*                                                                       */</span>
<span class="line-modified">1358   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1359   /*   x :: The x-coordinate of the segment&#39;s end point (its start point   */</span>
<span class="line-modified">1360   /*        is stored in `lastX&#39;).                                         */</span>
<span class="line-modified">1361   /*                                                                       */</span>
<span class="line-modified">1362   /*   y :: The y-coordinate of the segment&#39;s end point (its start point   */</span>
<span class="line-modified">1363   /*        is stored in `lastY&#39;).                                         */</span>
<span class="line-modified">1364   /*                                                                       */</span>
<span class="line-modified">1365   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1366   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">1367   /*   profile.                                                            */</span>
<span class="line-modified">1368   /*                                                                       */</span>


1369   static Bool
1370   Line_To( RAS_ARGS Long  x,
1371                     Long  y )
1372   {
1373     /* First, detect a change of direction */
1374 
1375     switch ( ras.state )
1376     {
1377     case Unknown_State:
1378       if ( y &gt; ras.lastY )
1379       {
1380         if ( New_Profile( RAS_VARS Ascending_State,
1381                                    IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
1382           return FAILURE;
1383       }
1384       else
1385       {
1386         if ( y &lt; ras.lastY )
1387           if ( New_Profile( RAS_VARS Descending_State,
1388                                      IS_TOP_OVERSHOOT( ras.lastY ) ) )
</pre>
<hr />
<pre>
1424         return FAILURE;
1425       break;
1426 
1427     case Descending_State:
1428       if ( Line_Down( RAS_VARS ras.lastX, ras.lastY,
1429                                x, y, ras.minY, ras.maxY ) )
1430         return FAILURE;
1431       break;
1432 
1433     default:
1434       ;
1435     }
1436 
1437     ras.lastX = x;
1438     ras.lastY = y;
1439 
1440     return SUCCESS;
1441   }
1442 
1443 
<span class="line-modified">1444   /*************************************************************************/</span>
<span class="line-modified">1445   /*                                                                       */</span>
<span class="line-modified">1446   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1447   /*    Conic_To                                                           */</span>
<span class="line-modified">1448   /*                                                                       */</span>
<span class="line-modified">1449   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1450   /*    Inject a new conic arc and adjust the profile list.                */</span>
<span class="line-modified">1451   /*                                                                       */</span>
<span class="line-modified">1452   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1453   /*   cx :: The x-coordinate of the arc&#39;s new control point.              */</span>
<span class="line-modified">1454   /*                                                                       */</span>
<span class="line-modified">1455   /*   cy :: The y-coordinate of the arc&#39;s new control point.              */</span>
<span class="line-modified">1456   /*                                                                       */</span>
<span class="line-modified">1457   /*   x  :: The x-coordinate of the arc&#39;s end point (its start point is   */</span>
<span class="line-modified">1458   /*         stored in `lastX&#39;).                                           */</span>
<span class="line-modified">1459   /*                                                                       */</span>
<span class="line-modified">1460   /*   y  :: The y-coordinate of the arc&#39;s end point (its start point is   */</span>
<span class="line-modified">1461   /*         stored in `lastY&#39;).                                           */</span>
<span class="line-modified">1462   /*                                                                       */</span>
<span class="line-modified">1463   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1464   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">1465   /*   profile.                                                            */</span>
<span class="line-modified">1466   /*                                                                       */</span>




1467   static Bool
1468   Conic_To( RAS_ARGS Long  cx,
1469                      Long  cy,
1470                      Long  x,
1471                      Long  y )
1472   {
1473     Long     y1, y2, y3, x3, ymin, ymax;
1474     TStates  state_bez;
1475 
1476 
1477     ras.arc      = ras.arcs;
1478     ras.arc[2].x = ras.lastX;
1479     ras.arc[2].y = ras.lastY;
1480     ras.arc[1].x = cx;
1481     ras.arc[1].y = cy;
1482     ras.arc[0].x = x;
1483     ras.arc[0].y = y;
1484 
1485     do
1486     {
</pre>
<hr />
<pre>
1541           if ( Bezier_Up( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
1542             goto Fail;
1543         }
1544         else
1545           if ( Bezier_Down( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
1546             goto Fail;
1547       }
1548 
1549     } while ( ras.arc &gt;= ras.arcs );
1550 
1551     ras.lastX = x3;
1552     ras.lastY = y3;
1553 
1554     return SUCCESS;
1555 
1556   Fail:
1557     return FAILURE;
1558   }
1559 
1560 
<span class="line-modified">1561   /*************************************************************************/</span>
<span class="line-modified">1562   /*                                                                       */</span>
<span class="line-modified">1563   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1564   /*    Cubic_To                                                           */</span>
<span class="line-modified">1565   /*                                                                       */</span>
<span class="line-modified">1566   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1567   /*    Inject a new cubic arc and adjust the profile list.                */</span>
<span class="line-modified">1568   /*                                                                       */</span>
<span class="line-modified">1569   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1570   /*   cx1 :: The x-coordinate of the arc&#39;s first new control point.       */</span>
<span class="line-modified">1571   /*                                                                       */</span>
<span class="line-modified">1572   /*   cy1 :: The y-coordinate of the arc&#39;s first new control point.       */</span>
<span class="line-modified">1573   /*                                                                       */</span>
<span class="line-modified">1574   /*   cx2 :: The x-coordinate of the arc&#39;s second new control point.      */</span>
<span class="line-modified">1575   /*                                                                       */</span>
<span class="line-modified">1576   /*   cy2 :: The y-coordinate of the arc&#39;s second new control point.      */</span>
<span class="line-modified">1577   /*                                                                       */</span>
<span class="line-modified">1578   /*   x   :: The x-coordinate of the arc&#39;s end point (its start point is  */</span>
<span class="line-modified">1579   /*          stored in `lastX&#39;).                                          */</span>
<span class="line-modified">1580   /*                                                                       */</span>
<span class="line-modified">1581   /*   y   :: The y-coordinate of the arc&#39;s end point (its start point is  */</span>
<span class="line-modified">1582   /*          stored in `lastY&#39;).                                          */</span>
<span class="line-modified">1583   /*                                                                       */</span>
<span class="line-modified">1584   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1585   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">1586   /*   profile.                                                            */</span>
<span class="line-modified">1587   /*                                                                       */</span>






1588   static Bool
1589   Cubic_To( RAS_ARGS Long  cx1,
1590                      Long  cy1,
1591                      Long  cx2,
1592                      Long  cy2,
1593                      Long  x,
1594                      Long  y )
1595   {
1596     Long     y1, y2, y3, y4, x4, ymin1, ymax1, ymin2, ymax2;
1597     TStates  state_bez;
1598 
1599 
1600     ras.arc      = ras.arcs;
1601     ras.arc[3].x = ras.lastX;
1602     ras.arc[3].y = ras.lastY;
1603     ras.arc[2].x = cx1;
1604     ras.arc[2].y = cy1;
1605     ras.arc[1].x = cx2;
1606     ras.arc[1].y = cy2;
1607     ras.arc[0].x = x;
</pre>
<hr />
<pre>
1688     ras.lastY = y4;
1689 
1690     return SUCCESS;
1691 
1692   Fail:
1693     return FAILURE;
1694   }
1695 
1696 
1697 #undef  SWAP_
1698 #define SWAP_( x, y )  do                \
1699                        {                 \
1700                          Long  swap = x; \
1701                                          \
1702                                          \
1703                          x = y;          \
1704                          y = swap;       \
1705                        } while ( 0 )
1706 
1707 
<span class="line-modified">1708   /*************************************************************************/</span>
<span class="line-modified">1709   /*                                                                       */</span>
<span class="line-modified">1710   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1711   /*    Decompose_Curve                                                    */</span>
<span class="line-modified">1712   /*                                                                       */</span>
<span class="line-modified">1713   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1714   /*    Scan the outline arrays in order to emit individual segments and   */</span>
<span class="line-modified">1715   /*    Beziers by calling Line_To() and Bezier_To().  It handles all      */</span>
<span class="line-modified">1716   /*    weird cases, like when the first point is off the curve, or when   */</span>
<span class="line-modified">1717   /*    there are simply no `on&#39; points in the contour!                    */</span>
<span class="line-modified">1718   /*                                                                       */</span>
<span class="line-modified">1719   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1720   /*    first   :: The index of the first point in the contour.            */</span>
<span class="line-modified">1721   /*                                                                       */</span>
<span class="line-modified">1722   /*    last    :: The index of the last point in the contour.             */</span>
<span class="line-modified">1723   /*                                                                       */</span>
<span class="line-modified">1724   /*    flipped :: If set, flip the direction of the curve.                */</span>
<span class="line-modified">1725   /*                                                                       */</span>
<span class="line-modified">1726   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1727   /*    SUCCESS on success, FAILURE on error.                              */</span>
<span class="line-modified">1728   /*                                                                       */</span>



1729   static Bool
1730   Decompose_Curve( RAS_ARGS UShort  first,
1731                             UShort  last,
1732                             Int     flipped )
1733   {
1734     FT_Vector   v_last;
1735     FT_Vector   v_control;
1736     FT_Vector   v_start;
1737 
1738     FT_Vector*  points;
1739     FT_Vector*  point;
1740     FT_Vector*  limit;
1741     char*       tags;
1742 
1743     UInt        tag;       /* current point&#39;s state           */
1744 
1745 
1746     points = ras.outline.points;
1747     limit  = points + last;
1748 
</pre>
<hr />
<pre>
1917           goto Close;
1918         }
1919       }
1920     }
1921 
1922     /* close the contour with a line segment */
1923     if ( Line_To( RAS_VARS v_start.x, v_start.y ) )
1924       goto Fail;
1925 
1926   Close:
1927     return SUCCESS;
1928 
1929   Invalid_Outline:
1930     ras.error = FT_THROW( Invalid );
1931 
1932   Fail:
1933     return FAILURE;
1934   }
1935 
1936 
<span class="line-modified">1937   /*************************************************************************/</span>
<span class="line-modified">1938   /*                                                                       */</span>
<span class="line-modified">1939   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1940   /*    Convert_Glyph                                                      */</span>
<span class="line-modified">1941   /*                                                                       */</span>
<span class="line-modified">1942   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1943   /*    Convert a glyph into a series of segments and arcs and make a      */</span>
<span class="line-modified">1944   /*    profiles list with them.                                           */</span>
<span class="line-modified">1945   /*                                                                       */</span>
<span class="line-modified">1946   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1947   /*    flipped :: If set, flip the direction of curve.                    */</span>
<span class="line-modified">1948   /*                                                                       */</span>
<span class="line-modified">1949   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1950   /*    SUCCESS on success, FAILURE if any error was encountered during    */</span>
<span class="line-modified">1951   /*    rendering.                                                         */</span>
<span class="line-modified">1952   /*                                                                       */</span>

1953   static Bool
1954   Convert_Glyph( RAS_ARGS Int  flipped )
1955   {
1956     Int   i;
1957     UInt  start;
1958 
1959 
1960     ras.fProfile = NULL;
1961     ras.joint    = FALSE;
1962     ras.fresh    = FALSE;
1963 
1964     ras.maxBuff  = ras.sizeBuff - AlignProfileSize;
1965 
1966     ras.numTurns = 0;
1967 
1968     ras.cProfile         = (PProfile)ras.top;
1969     ras.cProfile-&gt;offset = ras.top;
1970     ras.num_Profs        = 0;
1971 
1972     start = 0;
</pre>
<hr />
<pre>
2011       if ( ras.gProfile )
2012         lastProfile-&gt;next = ras.gProfile;
2013     }
2014 
2015     if ( Finalize_Profile_Table( RAS_VAR ) )
2016       return FAILURE;
2017 
2018     return (Bool)( ras.top &lt; ras.maxBuff ? SUCCESS : FAILURE );
2019   }
2020 
2021 
2022   /*************************************************************************/
2023   /*************************************************************************/
2024   /**                                                                     **/
2025   /**  SCAN-LINE SWEEPS AND DRAWING                                       **/
2026   /**                                                                     **/
2027   /*************************************************************************/
2028   /*************************************************************************/
2029 
2030 
<span class="line-modified">2031   /*************************************************************************/</span>
<span class="line-modified">2032   /*                                                                       */</span>
<span class="line-modified">2033   /*  Init_Linked                                                          */</span>
<span class="line-modified">2034   /*                                                                       */</span>
<span class="line-modified">2035   /*    Initializes an empty linked list.                                  */</span>
<span class="line-modified">2036   /*                                                                       */</span>
2037   static void
2038   Init_Linked( TProfileList*  l )
2039   {
2040     *l = NULL;
2041   }
2042 
2043 
<span class="line-modified">2044   /*************************************************************************/</span>
<span class="line-modified">2045   /*                                                                       */</span>
<span class="line-modified">2046   /*  InsNew                                                               */</span>
<span class="line-modified">2047   /*                                                                       */</span>
<span class="line-modified">2048   /*    Inserts a new profile in a linked list.                            */</span>
<span class="line-modified">2049   /*                                                                       */</span>
2050   static void
2051   InsNew( PProfileList  list,
2052           PProfile      profile )
2053   {
2054     PProfile  *old, current;
2055     Long       x;
2056 
2057 
2058     old     = list;
2059     current = *old;
2060     x       = profile-&gt;X;
2061 
2062     while ( current )
2063     {
2064       if ( x &lt; current-&gt;X )
2065         break;
2066       old     = &amp;current-&gt;link;
2067       current = *old;
2068     }
2069 
2070     profile-&gt;link = current;
2071     *old          = profile;
2072   }
2073 
2074 
<span class="line-modified">2075   /*************************************************************************/</span>
<span class="line-modified">2076   /*                                                                       */</span>
<span class="line-modified">2077   /*  DelOld                                                               */</span>
<span class="line-modified">2078   /*                                                                       */</span>
<span class="line-modified">2079   /*    Removes an old profile from a linked list.                         */</span>
<span class="line-modified">2080   /*                                                                       */</span>
2081   static void
2082   DelOld( PProfileList  list,
2083           PProfile      profile )
2084   {
2085     PProfile  *old, current;
2086 
2087 
2088     old     = list;
2089     current = *old;
2090 
2091     while ( current )
2092     {
2093       if ( current == profile )
2094       {
2095         *old = current-&gt;link;
2096         return;
2097       }
2098 
2099       old     = &amp;current-&gt;link;
2100       current = *old;
2101     }
2102 
2103     /* we should never get there, unless the profile was not part of */
2104     /* the list.                                                     */
2105   }
2106 
2107 
<span class="line-modified">2108   /*************************************************************************/</span>
<span class="line-modified">2109   /*                                                                       */</span>
<span class="line-modified">2110   /*  Sort                                                                 */</span>
<span class="line-modified">2111   /*                                                                       */</span>
<span class="line-modified">2112   /*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */</span>
<span class="line-modified">2113   /*    an algorithm which is fast in this case.  Bubble sort is enough    */</span>
<span class="line-modified">2114   /*    and simple.                                                        */</span>
<span class="line-modified">2115   /*                                                                       */</span>
2116   static void
2117   Sort( PProfileList  list )
2118   {
2119     PProfile  *old, current, next;
2120 
2121 
2122     /* First, set the new X coordinate of each profile */
2123     current = *list;
2124     while ( current )
2125     {
2126       current-&gt;X       = *current-&gt;offset;
2127       current-&gt;offset += ( current-&gt;flags &amp; Flow_Up ) ? 1 : -1;
2128       current-&gt;height--;
2129       current = current-&gt;link;
2130     }
2131 
2132     /* Then sort them */
2133     old     = list;
2134     current = *old;
2135 
</pre>
<hr />
<pre>
2146         current = *old;
2147 
2148         if ( !current )
2149           return;
2150       }
2151       else
2152       {
2153         *old          = next;
2154         current-&gt;link = next-&gt;link;
2155         next-&gt;link    = current;
2156 
2157         old     = list;
2158         current = *old;
2159       }
2160 
2161       next = current-&gt;link;
2162     }
2163   }
2164 
2165 
<span class="line-modified">2166   /*************************************************************************/</span>
<span class="line-modified">2167   /*                                                                       */</span>
<span class="line-modified">2168   /*  Vertical Sweep Procedure Set                                         */</span>
<span class="line-modified">2169   /*                                                                       */</span>
<span class="line-modified">2170   /*  These four routines are used during the vertical black/white sweep   */</span>
<span class="line-modified">2171   /*  phase by the generic Draw_Sweep() function.                          */</span>
<span class="line-modified">2172   /*                                                                       */</span>
<span class="line-modified">2173   /*************************************************************************/</span>
2174 
2175   static void
2176   Vertical_Sweep_Init( RAS_ARGS Short*  min,
2177                                 Short*  max )
2178   {
2179     Long  pitch = ras.target.pitch;
2180 
2181     FT_UNUSED( max );
2182 
2183 
2184     ras.traceIncr = (Short)-pitch;
2185     ras.traceOfs  = -*min * pitch;
<span class="line-removed">2186     if ( pitch &gt; 0 )</span>
<span class="line-removed">2187       ras.traceOfs += (Long)( ras.target.rows - 1 ) * pitch;</span>
2188   }
2189 
2190 
2191   static void
2192   Vertical_Sweep_Span( RAS_ARGS Short       y,
2193                                 FT_F26Dot6  x1,
2194                                 FT_F26Dot6  x2,
2195                                 PProfile    left,
2196                                 PProfile    right )
2197   {
2198     Long   e1, e2;
2199     Byte*  target;
2200 
2201     Int  dropOutControl = left-&gt;flags &amp; 7;
2202 
2203     FT_UNUSED( y );
2204     FT_UNUSED( left );
2205     FT_UNUSED( right );
2206 
2207 
2208     /* in high-precision mode, we need 12 digits after the comma to */
2209     /* represent multiples of 1/(1&lt;&lt;12) = 1/4096                    */
2210     FT_TRACE7(( &quot;  y=%d x=[%.12f;%.12f], drop-out=%d&quot;,
2211                 y,
2212                 x1 / (double)ras.precision,
2213                 x2 / (double)ras.precision,
2214                 dropOutControl ));
2215 
2216     /* Drop-out control */
2217 
<span class="line-modified">2218     e1 = TRUNC( CEILING( x1 ) );</span>

2219 


2220     if ( dropOutControl != 2                             &amp;&amp;
<span class="line-modified">2221          x2 - x1 - ras.precision &lt;= ras.precision_jitter )</span>

2222       e2 = e1;
<span class="line-modified">2223     else</span>
<span class="line-modified">2224       e2 = TRUNC( FLOOR( x2 ) );</span>

2225 
2226     if ( e2 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
2227     {
2228       Int   c1, c2;
2229       Byte  f1, f2;
2230 
2231 
2232       if ( e1 &lt; 0 )
2233         e1 = 0;
2234       if ( e2 &gt;= ras.bWidth )
2235         e2 = ras.bWidth - 1;
2236 
2237       FT_TRACE7(( &quot; -&gt; x=[%d;%d]&quot;, e1, e2 ));
2238 
2239       c1 = (Short)( e1 &gt;&gt; 3 );
2240       c2 = (Short)( e2 &gt;&gt; 3 );
2241 
2242       f1 = (Byte)  ( 0xFF &gt;&gt; ( e1 &amp; 7 ) );
2243       f2 = (Byte) ~( 0x7F &gt;&gt; ( e2 &amp; 7 ) );
2244 
<span class="line-modified">2245       target = ras.bTarget + ras.traceOfs + c1;</span>
2246       c2 -= c1;
2247 
2248       if ( c2 &gt; 0 )
2249       {
2250         target[0] |= f1;
2251 
2252         /* memset() is slower than the following code on many platforms. */
2253         /* This is due to the fact that, in the vast majority of cases,  */
2254         /* the span length in bytes is relatively small.                 */
<span class="line-modified">2255         c2--;</span>
<span class="line-removed">2256         while ( c2 &gt; 0 )</span>
<span class="line-removed">2257         {</span>
2258           *(++target) = 0xFF;
<span class="line-modified">2259           c2--;</span>
<span class="line-removed">2260         }</span>
2261         target[1] |= f2;
2262       }
2263       else
2264         *target |= ( f1 &amp; f2 );
2265     }
2266 
2267     FT_TRACE7(( &quot;\n&quot; ));
2268   }
2269 
2270 
2271   static void
2272   Vertical_Sweep_Drop( RAS_ARGS Short       y,
2273                                 FT_F26Dot6  x1,
2274                                 FT_F26Dot6  x2,
2275                                 PProfile    left,
2276                                 PProfile    right )
2277   {
2278     Long   e1, e2, pxl;
2279     Short  c1, f1;
2280 
</pre>
<hr />
<pre>
2383           goto Exit;  /* no drop-out control */
2384         }
2385 
2386         /* undocumented but confirmed: If the drop-out would result in a  */
2387         /* pixel outside of the bounding box, use the pixel inside of the */
2388         /* bounding box instead                                           */
2389         if ( pxl &lt; 0 )
2390           pxl = e1;
2391         else if ( TRUNC( pxl ) &gt;= ras.bWidth )
2392           pxl = e2;
2393 
2394         /* check that the other pixel isn&#39;t set */
2395         e1 = ( pxl == e1 ) ? e2 : e1;
2396 
2397         e1 = TRUNC( e1 );
2398 
2399         c1 = (Short)( e1 &gt;&gt; 3 );
2400         f1 = (Short)( e1 &amp;  7 );
2401 
2402         if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth                      &amp;&amp;
<span class="line-modified">2403              ras.bTarget[ras.traceOfs + c1] &amp; ( 0x80 &gt;&gt; f1 ) )</span>
2404           goto Exit;
2405       }
2406       else
2407         goto Exit;
2408     }
2409 
2410     e1 = TRUNC( pxl );
2411 
2412     if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
2413     {
2414       FT_TRACE7(( &quot; -&gt; x=%d (drop-out)&quot;, e1 ));
2415 
2416       c1 = (Short)( e1 &gt;&gt; 3 );
2417       f1 = (Short)( e1 &amp; 7 );
2418 
<span class="line-modified">2419       ras.bTarget[ras.traceOfs + c1] |= (char)( 0x80 &gt;&gt; f1 );</span>
2420     }
2421 
2422   Exit:
2423     FT_TRACE7(( &quot;\n&quot; ));
2424   }
2425 
2426 
2427   static void
2428   Vertical_Sweep_Step( RAS_ARG )
2429   {
2430     ras.traceOfs += ras.traceIncr;
2431   }
2432 
2433 
<span class="line-modified">2434   /***********************************************************************/</span>
<span class="line-modified">2435   /*                                                                     */</span>
<span class="line-modified">2436   /*  Horizontal Sweep Procedure Set                                     */</span>
<span class="line-modified">2437   /*                                                                     */</span>
<span class="line-modified">2438   /*  These four routines are used during the horizontal black/white     */</span>
<span class="line-modified">2439   /*  sweep phase by the generic Draw_Sweep() function.                  */</span>
<span class="line-modified">2440   /*                                                                     */</span>
<span class="line-modified">2441   /***********************************************************************/</span>
2442 
2443   static void
2444   Horizontal_Sweep_Init( RAS_ARGS Short*  min,
2445                                   Short*  max )
2446   {
2447     /* nothing, really */
2448     FT_UNUSED_RASTER;
2449     FT_UNUSED( min );
2450     FT_UNUSED( max );
2451   }
2452 
2453 
2454   static void
2455   Horizontal_Sweep_Span( RAS_ARGS Short       y,
2456                                   FT_F26Dot6  x1,
2457                                   FT_F26Dot6  x2,
2458                                   PProfile    left,
2459                                   PProfile    right )
2460   {
2461     FT_UNUSED( left );
</pre>
<hr />
<pre>
2466     {
2467       Long  e1, e2;
2468 
2469 
2470       FT_TRACE7(( &quot;  x=%d y=[%.12f;%.12f]&quot;,
2471                   y,
2472                   x1 / (double)ras.precision,
2473                   x2 / (double)ras.precision ));
2474 
2475       e1 = CEILING( x1 );
2476       e2 = FLOOR  ( x2 );
2477 
2478       if ( e1 == e2 )
2479       {
2480         e1 = TRUNC( e1 );
2481 
2482         if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
2483         {
2484           Byte   f1;
2485           PByte  bits;
<span class="line-removed">2486           PByte  p;</span>
2487 
2488 
2489           FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
2490 
<span class="line-modified">2491           bits = ras.bTarget + ( y &gt;&gt; 3 );</span>
2492           f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
<span class="line-removed">2493           p    = bits - e1 * ras.target.pitch;</span>
2494 
<span class="line-modified">2495           if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">2496             p += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
<span class="line-removed">2497 </span>
<span class="line-removed">2498           p[0] |= f1;</span>
2499         }
2500       }
2501 
2502       FT_TRACE7(( &quot;\n&quot; ));
2503     }
2504   }
2505 
2506 
2507   static void
2508   Horizontal_Sweep_Drop( RAS_ARGS Short       y,
2509                                   FT_F26Dot6  x1,
2510                                   FT_F26Dot6  x2,
2511                                   PProfile    left,
2512                                   PProfile    right )
2513   {
2514     Long   e1, e2, pxl;
2515     PByte  bits;
2516     Byte   f1;
2517 
2518 
</pre>
<hr />
<pre>
2580             pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
2581           break;
2582 
2583         default: /* modes 2, 3, 6, 7 */
2584           goto Exit;  /* no drop-out control */
2585         }
2586 
2587         /* undocumented but confirmed: If the drop-out would result in a  */
2588         /* pixel outside of the bounding box, use the pixel inside of the */
2589         /* bounding box instead                                           */
2590         if ( pxl &lt; 0 )
2591           pxl = e1;
2592         else if ( (ULong)( TRUNC( pxl ) ) &gt;= ras.target.rows )
2593           pxl = e2;
2594 
2595         /* check that the other pixel isn&#39;t set */
2596         e1 = ( pxl == e1 ) ? e2 : e1;
2597 
2598         e1 = TRUNC( e1 );
2599 
<span class="line-modified">2600         bits = ras.bTarget + ( y &gt;&gt; 3 );</span>
2601         f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
2602 
<span class="line-removed">2603         bits -= e1 * ras.target.pitch;</span>
<span class="line-removed">2604         if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">2605           bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
<span class="line-removed">2606 </span>
2607         if ( e1 &gt;= 0                     &amp;&amp;
2608              (ULong)e1 &lt; ras.target.rows &amp;&amp;
2609              *bits &amp; f1                  )
2610           goto Exit;
2611       }
2612       else
2613         goto Exit;
2614     }
2615 
2616     e1 = TRUNC( pxl );
2617 
2618     if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
2619     {
2620       FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
2621 
<span class="line-modified">2622       bits  = ras.bTarget + ( y &gt;&gt; 3 );</span>
2623       f1    = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
<span class="line-removed">2624       bits -= e1 * ras.target.pitch;</span>
<span class="line-removed">2625 </span>
<span class="line-removed">2626       if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">2627         bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
2628 
2629       bits[0] |= f1;
2630     }
2631 
2632   Exit:
2633     FT_TRACE7(( &quot;\n&quot; ));
2634   }
2635 
2636 
2637   static void
2638   Horizontal_Sweep_Step( RAS_ARG )
2639   {
2640     /* Nothing, really */
2641     FT_UNUSED_RASTER;
2642   }
2643 
2644 
<span class="line-modified">2645   /*************************************************************************/</span>
<span class="line-modified">2646   /*                                                                       */</span>
<span class="line-modified">2647   /*  Generic Sweep Drawing routine                                        */</span>
<span class="line-modified">2648   /*                                                                       */</span>
<span class="line-modified">2649   /*************************************************************************/</span>
2650 
2651   static Bool
2652   Draw_Sweep( RAS_ARG )
2653   {
2654     Short         y, y_change, y_height;
2655 
2656     PProfile      P, Q, P_Left, P_Right;
2657 
2658     Short         min_Y, max_Y, top, bottom, dropouts;
2659 
2660     Long          x1, x2, xs, e1, e2;
2661 
2662     TProfileList  waiting;
2663     TProfileList  draw_left, draw_right;
2664 
2665 
2666     /* initialize empty linked lists */
2667 
2668     Init_Linked( &amp;waiting );
2669 
</pre>
<hr />
<pre>
2747         P = Q;
2748       }
2749 
2750       /* sort the drawing lists */
2751 
2752       Sort( &amp;draw_left );
2753       Sort( &amp;draw_right );
2754 
2755       y_change = (Short)ras.sizeBuff[-ras.numTurns--];
2756       y_height = (Short)( y_change - y );
2757 
2758       while ( y &lt; y_change )
2759       {
2760         /* let&#39;s trace */
2761 
2762         dropouts = 0;
2763 
2764         P_Left  = draw_left;
2765         P_Right = draw_right;
2766 
<span class="line-modified">2767         while ( P_Left )</span>
2768         {
2769           x1 = P_Left -&gt;X;
2770           x2 = P_Right-&gt;X;
2771 
2772           if ( x1 &gt; x2 )
2773           {
2774             xs = x1;
2775             x1 = x2;
2776             x2 = xs;
2777           }
2778 
2779           e1 = FLOOR( x1 );
2780           e2 = CEILING( x2 );
2781 
2782           if ( x2 - x1 &lt;= ras.precision &amp;&amp;
2783                e1 != x1 &amp;&amp; e2 != x2     )
2784           {
2785             if ( e1 &gt; e2 || e2 == e1 + ras.precision )
2786             {
2787               Int  dropOutControl = P_Left-&gt;flags &amp; 7;
</pre>
<hr />
<pre>
2848         if ( P-&gt;height == 0 )
2849           DelOld( &amp;draw_right, P );
2850         P = Q;
2851       }
2852     }
2853 
2854     /* for gray-scaling, flush the bitmap scanline cache */
2855     while ( y &lt;= max_Y )
2856     {
2857       ras.Proc_Sweep_Step( RAS_VAR );
2858       y++;
2859     }
2860 
2861     return SUCCESS;
2862 
2863   Scan_DropOuts:
2864 
2865     P_Left  = draw_left;
2866     P_Right = draw_right;
2867 
<span class="line-modified">2868     while ( P_Left )</span>
2869     {
2870       if ( P_Left-&gt;countL )
2871       {
2872         P_Left-&gt;countL = 0;
2873 #if 0
2874         dropouts--;  /* -- this is useful when debugging only */
2875 #endif
2876         ras.Proc_Sweep_Drop( RAS_VARS y,
2877                                       P_Left-&gt;X,
2878                                       P_Right-&gt;X,
2879                                       P_Left,
2880                                       P_Right );
2881       }
2882 
2883       P_Left  = P_Left-&gt;link;
2884       P_Right = P_Right-&gt;link;
2885     }
2886 
2887     goto Next_Line;
2888   }
2889 
2890 
<span class="line-modified">2891   /*************************************************************************/</span>
<span class="line-modified">2892   /*                                                                       */</span>
<span class="line-modified">2893   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2894   /*    Render_Single_Pass                                                 */</span>
<span class="line-modified">2895   /*                                                                       */</span>
<span class="line-modified">2896   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2897   /*    Perform one sweep with sub-banding.                                */</span>
<span class="line-modified">2898   /*                                                                       */</span>
<span class="line-modified">2899   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2900   /*    flipped :: If set, flip the direction of the outline.              */</span>
<span class="line-modified">2901   /*                                                                       */</span>
<span class="line-modified">2902   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2903   /*    Renderer error code.                                               */</span>
<span class="line-modified">2904   /*                                                                       */</span>

























































































2905   static int
2906   Render_Single_Pass( RAS_ARGS Bool  flipped )
2907   {
2908     Short  i, j, k;
2909 
2910 
2911     while ( ras.band_top &gt;= 0 )
2912     {
2913       ras.maxY = (Long)ras.band_stack[ras.band_top].y_max * ras.precision;
2914       ras.minY = (Long)ras.band_stack[ras.band_top].y_min * ras.precision;
2915 
2916       ras.top = ras.buff;
2917 
2918       ras.error = Raster_Err_None;
2919 
2920       if ( Convert_Glyph( RAS_VARS flipped ) )
2921       {
2922         if ( ras.error != Raster_Err_Overflow )
2923           return FAILURE;
2924 
</pre>
<hr />
<pre>
2946         ras.band_stack[ras.band_top + 1].y_min = k;
2947         ras.band_stack[ras.band_top + 1].y_max = j;
2948 
2949         ras.band_stack[ras.band_top].y_max = (Short)( k - 1 );
2950 
2951         ras.band_top++;
2952       }
2953       else
2954       {
2955         if ( ras.fProfile )
2956           if ( Draw_Sweep( RAS_VAR ) )
2957              return ras.error;
2958         ras.band_top--;
2959       }
2960     }
2961 
2962     return SUCCESS;
2963   }
2964 
2965 
<span class="line-modified">2966   /*************************************************************************/</span>
<span class="line-modified">2967   /*                                                                       */</span>
<span class="line-modified">2968   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2969   /*    Render_Glyph                                                       */</span>
<span class="line-modified">2970   /*                                                                       */</span>
<span class="line-modified">2971   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2972   /*    Render a glyph in a bitmap.  Sub-banding if needed.                */</span>
<span class="line-modified">2973   /*                                                                       */</span>
<span class="line-modified">2974   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2975   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2976   /*                                                                       */</span>
2977   static FT_Error
2978   Render_Glyph( RAS_ARG )
2979   {
2980     FT_Error  error;
2981 
2982 
2983     Set_High_Precision( RAS_VARS ras.outline.flags &amp;
2984                                  FT_OUTLINE_HIGH_PRECISION );
<span class="line-removed">2985     ras.scale_shift = ras.precision_shift;</span>
2986 
2987     if ( ras.outline.flags &amp; FT_OUTLINE_IGNORE_DROPOUTS )
2988       ras.dropOutControl = 2;
2989     else
2990     {
2991       if ( ras.outline.flags &amp; FT_OUTLINE_SMART_DROPOUTS )
2992         ras.dropOutControl = 4;
2993       else
2994         ras.dropOutControl = 0;
2995 
2996       if ( !( ras.outline.flags &amp; FT_OUTLINE_INCLUDE_STUBS ) )
2997         ras.dropOutControl += 1;
2998     }
2999 
3000     ras.second_pass = (Bool)( !( ras.outline.flags      &amp;
3001                                  FT_OUTLINE_SINGLE_PASS ) );
3002 
3003     /* Vertical Sweep */
3004     FT_TRACE7(( &quot;Vertical pass (ftraster)\n&quot; ));
3005 
3006     ras.Proc_Sweep_Init = Vertical_Sweep_Init;
3007     ras.Proc_Sweep_Span = Vertical_Sweep_Span;
3008     ras.Proc_Sweep_Drop = Vertical_Sweep_Drop;
3009     ras.Proc_Sweep_Step = Vertical_Sweep_Step;
3010 
3011     ras.band_top            = 0;
3012     ras.band_stack[0].y_min = 0;
3013     ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );
3014 
3015     ras.bWidth  = (UShort)ras.target.width;
<span class="line-modified">3016     ras.bTarget = (Byte*)ras.target.buffer;</span>



3017 
3018     if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )
3019       return error;
3020 
3021     /* Horizontal Sweep */
3022     if ( ras.second_pass &amp;&amp; ras.dropOutControl != 2 )
3023     {
3024       FT_TRACE7(( &quot;Horizontal pass (ftraster)\n&quot; ));
3025 
3026       ras.Proc_Sweep_Init = Horizontal_Sweep_Init;
3027       ras.Proc_Sweep_Span = Horizontal_Sweep_Span;
3028       ras.Proc_Sweep_Drop = Horizontal_Sweep_Drop;
3029       ras.Proc_Sweep_Step = Horizontal_Sweep_Step;
3030 
3031       ras.band_top            = 0;
3032       ras.band_stack[0].y_min = 0;
3033       ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );
3034 
3035       if ( ( error = Render_Single_Pass( RAS_VARS 1 ) ) != 0 )
3036         return error;
</pre>
<hr />
<pre>
3129   static int
3130   ft_black_set_mode( FT_Raster  raster,
3131                      ULong      mode,
3132                      void*      args )
3133   {
3134     FT_UNUSED( raster );
3135     FT_UNUSED( mode );
3136     FT_UNUSED( args );
3137 
3138     return 0;
3139   }
3140 
3141 
3142   static int
3143   ft_black_render( FT_Raster                raster,
3144                    const FT_Raster_Params*  params )
3145   {
3146     const FT_Outline*  outline    = (const FT_Outline*)params-&gt;source;
3147     const FT_Bitmap*   target_map = params-&gt;target;
3148 

3149     black_TWorker  worker[1];

3150 
3151     Long  buffer[FT_MAX_BLACK_POOL];
3152 
3153 
3154     if ( !raster )
3155       return FT_THROW( Not_Ini );
3156 
3157     if ( !outline )
3158       return FT_THROW( Invalid );
3159 
3160     /* return immediately if the outline is empty */
3161     if ( outline-&gt;n_points == 0 || outline-&gt;n_contours &lt;= 0 )
3162       return Raster_Err_None;
3163 
3164     if ( !outline-&gt;contours || !outline-&gt;points )
3165       return FT_THROW( Invalid );
3166 
3167     if ( outline-&gt;n_points !=
3168            outline-&gt;contours[outline-&gt;n_contours - 1] + 1 )
3169       return FT_THROW( Invalid );
3170 
3171     /* this version of the raster does not support direct rendering, sorry */
3172     if ( params-&gt;flags &amp; FT_RASTER_FLAG_DIRECT )
3173       return FT_THROW( Unsupported );
3174 
3175     if ( params-&gt;flags &amp; FT_RASTER_FLAG_AA )
3176       return FT_THROW( Unsupported );
3177 
3178     if ( !target_map )
3179       return FT_THROW( Invalid );
3180 
3181     /* nothing to do */
3182     if ( !target_map-&gt;width || !target_map-&gt;rows )
3183       return Raster_Err_None;
3184 
3185     if ( !target_map-&gt;buffer )
3186       return FT_THROW( Invalid );
3187 
<span class="line-removed">3188     /* reject too large outline coordinates */</span>
<span class="line-removed">3189     {</span>
<span class="line-removed">3190       FT_Vector*  vec   = outline-&gt;points;</span>
<span class="line-removed">3191       FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="line-removed">3192 </span>
<span class="line-removed">3193 </span>
<span class="line-removed">3194       for ( ; vec &lt; limit; vec++ )</span>
<span class="line-removed">3195       {</span>
<span class="line-removed">3196         if ( vec-&gt;x &lt; -0x1000000L || vec-&gt;x &gt; 0x1000000L ||</span>
<span class="line-removed">3197              vec-&gt;y &lt; -0x1000000L || vec-&gt;y &gt; 0x1000000L )</span>
<span class="line-removed">3198          return FT_THROW( Invalid );</span>
<span class="line-removed">3199       }</span>
<span class="line-removed">3200     }</span>
<span class="line-removed">3201 </span>
3202     ras.outline = *outline;
3203     ras.target  = *target_map;
3204 
<span class="line-modified">3205     worker-&gt;buff     = buffer;</span>
<span class="line-modified">3206     worker-&gt;sizeBuff = (&amp;buffer)[1]; /* Points to right after buffer. */</span>
3207 
3208     return Render_Glyph( RAS_VAR );
3209   }
3210 
3211 
3212   FT_DEFINE_RASTER_FUNCS(
3213     ft_standard_raster,
3214 
3215     FT_GLYPH_FORMAT_OUTLINE,
3216 
3217     (FT_Raster_New_Func)     ft_black_new,       /* raster_new      */
3218     (FT_Raster_Reset_Func)   ft_black_reset,     /* raster_reset    */
3219     (FT_Raster_Set_Mode_Func)ft_black_set_mode,  /* raster_set_mode */
3220     (FT_Raster_Render_Func)  ft_black_render,    /* raster_render   */
3221     (FT_Raster_Done_Func)    ft_black_done       /* raster_done     */
3222   )
3223 
3224 
3225 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ftraster.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   The FreeType glyph rasterizer (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18   /**************************************************************************</span>
<span class="line-modified">  19    *</span>
<span class="line-modified">  20    * This file can be compiled without the rest of the FreeType engine, by</span>
<span class="line-modified">  21    * defining the STANDALONE_ macro when compiling it.  You also need to</span>
<span class="line-modified">  22    * put the files `ftimage.h&#39; and `ftmisc.h&#39; into the $(incdir)</span>
<span class="line-modified">  23    * directory.  Typically, you should do something like</span>
<span class="line-modified">  24    *</span>
<span class="line-modified">  25    * - copy `src/raster/ftraster.c&#39; (this file) to your current directory</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * - copy `include/freetype/ftimage.h&#39; and `src/raster/ftmisc.h&#39; to your</span>
<span class="line-modified">  28    *   current directory</span>
<span class="line-modified">  29    *</span>
<span class="line-modified">  30    * - compile `ftraster&#39; with the STANDALONE_ macro defined, as in</span>
<span class="line-modified">  31    *</span>
<span class="line-modified">  32    *     cc -c -DSTANDALONE_ ftraster.c</span>
<span class="line-modified">  33    *</span>
<span class="line-modified">  34    * The renderer can be initialized with a call to</span>
<span class="line-modified">  35    * `ft_standard_raster.raster_new&#39;; a bitmap can be generated</span>
<span class="line-modified">  36    * with a call to `ft_standard_raster.raster_render&#39;.</span>
<span class="line-modified">  37    *</span>
<span class="line-modified">  38    * See the comments and documentation in the file `ftimage.h&#39; for more</span>
<span class="line-modified">  39    * details on how the raster works.</span>
<span class="line-modified">  40    *</span>
<span class="line-modified">  41    */</span>
<span class="line-modified">  42 </span>
<span class="line-modified">  43 </span>
<span class="line-modified">  44   /**************************************************************************</span>
<span class="line-modified">  45    *</span>
<span class="line-modified">  46    * This is a rewrite of the FreeType 1.x scan-line converter</span>
<span class="line-modified">  47    *</span>
<span class="line-modified">  48    */</span>
  49 
  50 #ifdef STANDALONE_
  51 
  52   /* The size in bytes of the render pool used by the scan-line converter  */
  53   /* to do all of its work.                                                */
  54 #define FT_RENDER_POOL_SIZE  16384L
  55 
  56 #define FT_CONFIG_STANDARD_LIBRARY_H  &lt;stdlib.h&gt;
  57 
  58 #include &lt;string.h&gt;           /* for memset */
  59 
  60 #include &quot;ftmisc.h&quot;
  61 #include &quot;ftimage.h&quot;
  62 
  63 #else /* !STANDALONE_ */
  64 
  65 #include &lt;ft2build.h&gt;
  66 #include &quot;ftraster.h&quot;
  67 #include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */
<span class="line-modified">  68 #include FT_OUTLINE_H         /* for FT_Outline_Get_CBox              */</span>

  69 
  70 #endif /* !STANDALONE_ */
  71 
  72 
<span class="line-modified">  73   /**************************************************************************</span>
<span class="line-modified">  74    *</span>
<span class="line-modified">  75    * A simple technical note on how the raster works</span>
<span class="line-modified">  76    * -----------------------------------------------</span>
<span class="line-modified">  77    *</span>
<span class="line-modified">  78    *   Converting an outline into a bitmap is achieved in several steps:</span>
<span class="line-modified">  79    *</span>
<span class="line-modified">  80    *   1 - Decomposing the outline into successive `profiles&#39;.  Each</span>
<span class="line-modified">  81    *       profile is simply an array of scanline intersections on a given</span>
<span class="line-modified">  82    *       dimension.  A profile&#39;s main attributes are</span>
<span class="line-modified">  83    *</span>
<span class="line-modified">  84    *       o its scanline position boundaries, i.e. `Ymin&#39; and `Ymax&#39;</span>
<span class="line-modified">  85    *</span>
<span class="line-modified">  86    *       o an array of intersection coordinates for each scanline</span>
<span class="line-modified">  87    *         between `Ymin&#39; and `Ymax&#39;</span>
<span class="line-modified">  88    *</span>
<span class="line-modified">  89    *       o a direction, indicating whether it was built going `up&#39; or</span>
<span class="line-modified">  90    *         `down&#39;, as this is very important for filling rules</span>
<span class="line-modified">  91    *</span>
<span class="line-modified">  92    *       o its drop-out mode</span>
<span class="line-modified">  93    *</span>
<span class="line-modified">  94    *   2 - Sweeping the target map&#39;s scanlines in order to compute segment</span>
<span class="line-modified">  95    *       `spans&#39; which are then filled.  Additionally, this pass</span>
<span class="line-modified">  96    *       performs drop-out control.</span>
<span class="line-modified">  97    *</span>
<span class="line-modified">  98    *   The outline data is parsed during step 1 only.  The profiles are</span>
<span class="line-modified">  99    *   built from the bottom of the render pool, used as a stack.  The</span>
<span class="line-modified"> 100    *   following graphics shows the profile list under construction:</span>
<span class="line-modified"> 101    *</span>
<span class="line-modified"> 102    *    __________________________________________________________ _ _</span>
<span class="line-modified"> 103    *   |         |                 |         |                 |</span>
<span class="line-modified"> 104    *   | profile | coordinates for | profile | coordinates for |--&gt;</span>
<span class="line-modified"> 105    *   |    1    |  profile 1      |    2    |  profile 2      |--&gt;</span>
<span class="line-modified"> 106    *   |_________|_________________|_________|_________________|__ _ _</span>
<span class="line-modified"> 107    *</span>
<span class="line-modified"> 108    *   ^                                                       ^</span>
<span class="line-modified"> 109    *   |                                                       |</span>
<span class="line-modified"> 110    * start of render pool                                      top</span>
<span class="line-modified"> 111    *</span>
<span class="line-modified"> 112    *   The top of the profile stack is kept in the `top&#39; variable.</span>
<span class="line-modified"> 113    *</span>
<span class="line-modified"> 114    *   As you can see, a profile record is pushed on top of the render</span>
<span class="line-modified"> 115    *   pool, which is then followed by its coordinates/intersections.  If</span>
<span class="line-modified"> 116    *   a change of direction is detected in the outline, a new profile is</span>
<span class="line-modified"> 117    *   generated until the end of the outline.</span>
<span class="line-modified"> 118    *</span>
<span class="line-modified"> 119    *   Note that when all profiles have been generated, the function</span>
<span class="line-modified"> 120    *   Finalize_Profile_Table() is used to record, for each profile, its</span>
<span class="line-modified"> 121    *   bottom-most scanline as well as the scanline above its upmost</span>
<span class="line-modified"> 122    *   boundary.  These positions are called `y-turns&#39; because they (sort</span>
<span class="line-modified"> 123    *   of) correspond to local extrema.  They are stored in a sorted list</span>
<span class="line-modified"> 124    *   built from the top of the render pool as a downwards stack:</span>
<span class="line-modified"> 125    *</span>
<span class="line-modified"> 126    *     _ _ _______________________________________</span>
<span class="line-modified"> 127    *                           |                    |</span>
<span class="line-modified"> 128    *                        &lt;--| sorted list of     |</span>
<span class="line-modified"> 129    *                        &lt;--|  extrema scanlines |</span>
<span class="line-modified"> 130    *     _ _ __________________|____________________|</span>
<span class="line-modified"> 131    *</span>
<span class="line-modified"> 132    *                           ^                    ^</span>
<span class="line-modified"> 133    *                           |                    |</span>
<span class="line-modified"> 134    *                         maxBuff           sizeBuff = end of pool</span>
<span class="line-modified"> 135    *</span>
<span class="line-modified"> 136    *   This list is later used during the sweep phase in order to</span>
<span class="line-modified"> 137    *   optimize performance (see technical note on the sweep below).</span>
<span class="line-modified"> 138    *</span>
<span class="line-modified"> 139    *   Of course, the raster detects whether the two stacks collide and</span>
<span class="line-modified"> 140    *   handles the situation properly.</span>
<span class="line-modified"> 141    *</span>
<span class="line-modified"> 142    */</span>
 143 
 144 
 145   /*************************************************************************/
 146   /*************************************************************************/
 147   /**                                                                     **/
 148   /**  CONFIGURATION MACROS                                               **/
 149   /**                                                                     **/
 150   /*************************************************************************/
 151   /*************************************************************************/
 152 
 153   /* define DEBUG_RASTER if you want to compile a debugging version */
 154 /* #define DEBUG_RASTER */
 155 
 156 
 157   /*************************************************************************/
 158   /*************************************************************************/
 159   /**                                                                     **/
 160   /**  OTHER MACROS (do not change)                                       **/
 161   /**                                                                     **/
 162   /*************************************************************************/
 163   /*************************************************************************/
 164 
<span class="line-modified"> 165   /**************************************************************************</span>
<span class="line-modified"> 166    *</span>
<span class="line-modified"> 167    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 168    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 169    * messages during execution.</span>
<span class="line-modified"> 170    */</span>
 171 #undef  FT_COMPONENT
<span class="line-modified"> 172 #define FT_COMPONENT  raster</span>
 173 
 174 
 175 #ifdef STANDALONE_
 176 
 177   /* Auxiliary macros for token concatenation. */
 178 #define FT_ERR_XCAT( x, y )  x ## y
 179 #define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )
 180 
 181   /* This macro is used to indicate that a function parameter is unused. */
 182   /* Its purpose is simply to reduce compiler warnings.  Note also that  */
 183   /* simply defining it as `(void)x&#39; doesn&#39;t avoid warnings with certain */
 184   /* ANSI compilers (e.g. LCC).                                          */
 185 #define FT_UNUSED( x )  (x) = (x)
 186 
 187   /* Disable the tracing mechanism for simplicity -- developers can      */
 188   /* activate it easily by redefining these macros.                      */
 189 #ifndef FT_ERROR
 190 #define FT_ERROR( x )  do { } while ( 0 )     /* nothing */
 191 #endif
 192 
</pre>
<hr />
<pre>
 382   {
 383     Short  y_min;   /* band&#39;s minimum */
 384     Short  y_max;   /* band&#39;s maximum */
 385 
 386   } black_TBand;
 387 
 388 
 389 #define AlignProfileSize \
 390   ( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( Long ) )
 391 
 392 
 393 #undef RAS_ARG
 394 #undef RAS_ARGS
 395 #undef RAS_VAR
 396 #undef RAS_VARS
 397 
 398 #ifdef FT_STATIC_RASTER
 399 
 400 
 401 #define RAS_ARGS       /* void */
<span class="line-modified"> 402 #define RAS_ARG        void</span>
 403 
 404 #define RAS_VARS       /* void */
 405 #define RAS_VAR        /* void */
 406 
 407 #define FT_UNUSED_RASTER  do { } while ( 0 )
 408 
 409 
 410 #else /* !FT_STATIC_RASTER */
 411 
 412 
 413 #define RAS_ARGS       black_PWorker  worker,
 414 #define RAS_ARG        black_PWorker  worker
 415 
 416 #define RAS_VARS       worker,
 417 #define RAS_VAR        worker
 418 
 419 #define FT_UNUSED_RASTER  FT_UNUSED( worker )
 420 
 421 
 422 #endif /* !FT_STATIC_RASTER */
</pre>
<hr />
<pre>
 434   Function_Sweep_Span( RAS_ARGS Short       y,
 435                                 FT_F26Dot6  x1,
 436                                 FT_F26Dot6  x2,
 437                                 PProfile    left,
 438                                 PProfile    right );
 439 
 440   typedef void
 441   Function_Sweep_Step( RAS_ARG );
 442 
 443 
 444   /* NOTE: These operations are only valid on 2&#39;s complement processors */
 445 #undef FLOOR
 446 #undef CEILING
 447 #undef TRUNC
 448 #undef SCALED
 449 
 450 #define FLOOR( x )    ( (x) &amp; -ras.precision )
 451 #define CEILING( x )  ( ( (x) + ras.precision - 1 ) &amp; -ras.precision )
 452 #define TRUNC( x )    ( (Long)(x) &gt;&gt; ras.precision_bits )
 453 #define FRAC( x )     ( (x) &amp; ( ras.precision - 1 ) )
<span class="line-modified"> 454 </span>
<span class="line-modified"> 455   /* scale and shift grid to pixel centers */</span>
<span class="line-modified"> 456 #define SCALED( x )   ( (x) * ras.precision_scale - ras.precision_half )</span>
 457 
 458 #define IS_BOTTOM_OVERSHOOT( x ) \
 459           (Bool)( CEILING( x ) - x &gt;= ras.precision_half )
 460 #define IS_TOP_OVERSHOOT( x )    \
 461           (Bool)( x - FLOOR( x ) &gt;= ras.precision_half )
 462 
 463 #if FT_RENDER_POOL_SIZE &gt; 2048
 464 #define FT_MAX_BLACK_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( Long ) )
 465 #else
 466 #define FT_MAX_BLACK_POOL  ( 2048 / sizeof ( Long ) )
 467 #endif
 468 
 469   /* The most used variables are positioned at the top of the structure. */
 470   /* Thus, their offset can be coded with less opcodes, resulting in a   */
 471   /* smaller executable.                                                 */
 472 
 473   struct  black_TWorker_
 474   {
 475     Int         precision_bits;     /* precision related variables         */
 476     Int         precision;
 477     Int         precision_half;
<span class="line-modified"> 478     Int         precision_scale;</span>
 479     Int         precision_step;
 480     Int         precision_jitter;
 481 



 482     PLong       buff;               /* The profiles buffer                 */
 483     PLong       sizeBuff;           /* Render pool size                    */
 484     PLong       maxBuff;            /* Profiles buffer size                */
 485     PLong       top;                /* Current cursor in buffer            */
 486 
 487     FT_Error    error;
 488 
 489     Int         numTurns;           /* number of Y-turns in outline        */
 490 
 491     TPoint*     arc;                /* current Bezier arc pointer          */
 492 
 493     UShort      bWidth;             /* target bitmap width                 */
<span class="line-modified"> 494     PByte       bOrigin;            /* target bitmap bottom-left origin    */</span>

 495 
 496     Long        lastX, lastY;
 497     Long        minY, maxY;
 498 
 499     UShort      num_Profs;          /* current number of profiles          */
 500 
 501     Bool        fresh;              /* signals a fresh new profile which   */
 502                                     /* `start&#39; field must be completed     */
 503     Bool        joint;              /* signals that the last arc ended     */
 504                                     /* exactly on a scanline.  Allows      */
 505                                     /* removal of doublets                 */
 506     PProfile    cProfile;           /* current profile                     */
 507     PProfile    fProfile;           /* head of linked list of profiles     */
 508     PProfile    gProfile;           /* contour&#39;s first profile in case     */
 509                                     /* of impact                           */
 510 
 511     TStates     state;              /* rendering state                     */
 512 
 513     FT_Bitmap   target;             /* description of target bit/pixmap    */
 514     FT_Outline  outline;
 515 
 516     Long        traceOfs;           /* current offset in target bitmap     */


 517     Short       traceIncr;          /* sweep&#39;s increment in target bitmap  */
 518 
 519     /* dispatch variables */
 520 
 521     Function_Sweep_Init*  Proc_Sweep_Init;
 522     Function_Sweep_Span*  Proc_Sweep_Span;
 523     Function_Sweep_Span*  Proc_Sweep_Drop;
 524     Function_Sweep_Step*  Proc_Sweep_Step;
 525 
 526     Byte        dropOutControl;     /* current drop_out control method     */
 527 
 528     Bool        second_pass;        /* indicates whether a horizontal pass */
 529                                     /* should be performed to control      */
 530                                     /* drop-out accurately when calling    */
 531                                     /* Render_Glyph.                       */
 532 
 533     TPoint      arcs[3 * MaxBezier + 1]; /* The Bezier stack               */
 534 
 535     black_TBand  band_stack[16];    /* band stack used for sub-banding     */
 536     Int          band_top;          /* band stack top                      */
 537 
 538   };
 539 
 540 
 541   typedef struct  black_TRaster_
 542   {
 543     void*          memory;
 544 
 545   } black_TRaster, *black_PRaster;
 546 
 547 #ifdef FT_STATIC_RASTER
 548 
<span class="line-modified"> 549   static black_TWorker  ras;</span>

 550 
 551 #else /* !FT_STATIC_RASTER */
 552 
 553 #define ras  (*worker)
 554 
 555 #endif /* !FT_STATIC_RASTER */
 556 
 557 
 558   /*************************************************************************/
 559   /*************************************************************************/
 560   /**                                                                     **/
 561   /**  PROFILES COMPUTATION                                               **/
 562   /**                                                                     **/
 563   /*************************************************************************/
 564   /*************************************************************************/
 565 
 566 
<span class="line-modified"> 567   /**************************************************************************</span>
<span class="line-modified"> 568    *</span>
<span class="line-modified"> 569    * @Function:</span>
<span class="line-modified"> 570    *   Set_High_Precision</span>
<span class="line-modified"> 571    *</span>
<span class="line-modified"> 572    * @Description:</span>
<span class="line-modified"> 573    *   Set precision variables according to param flag.</span>
<span class="line-modified"> 574    *</span>
<span class="line-modified"> 575    * @Input:</span>
<span class="line-modified"> 576    *   High ::</span>
<span class="line-modified"> 577    *     Set to True for high precision (typically for ppem &lt; 24),</span>
<span class="line-modified"> 578    *     false otherwise.</span>
<span class="line-added"> 579    */</span>
 580   static void
 581   Set_High_Precision( RAS_ARGS Int  High )
 582   {
 583     /*
 584      * `precision_step&#39; is used in `Bezier_Up&#39; to decide when to split a
 585      * given y-monotonous Bezier arc that crosses a scanline before
 586      * approximating it as a straight segment.  The default value of 32 (for
 587      * low accuracy) corresponds to
 588      *
 589      *   32 / 64 == 0.5 pixels,
 590      *
 591      * while for the high accuracy case we have
 592      *
 593      *   256 / (1 &lt;&lt; 12) = 0.0625 pixels.
 594      *
 595      * `precision_jitter&#39; is an epsilon threshold used in
 596      * `Vertical_Sweep_Span&#39; to deal with small imperfections in the Bezier
 597      * decomposition (after all, we are working with approximations only);
 598      * it avoids switching on additional pixels which would cause artifacts
 599      * otherwise.
</pre>
<hr />
<pre>
 601      * The value of `precision_jitter&#39; has been determined heuristically.
 602      *
 603      */
 604 
 605     if ( High )
 606     {
 607       ras.precision_bits   = 12;
 608       ras.precision_step   = 256;
 609       ras.precision_jitter = 30;
 610     }
 611     else
 612     {
 613       ras.precision_bits   = 6;
 614       ras.precision_step   = 32;
 615       ras.precision_jitter = 2;
 616     }
 617 
 618     FT_TRACE6(( &quot;Set_High_Precision(%s)\n&quot;, High ? &quot;true&quot; : &quot;false&quot; ));
 619 
 620     ras.precision       = 1 &lt;&lt; ras.precision_bits;
<span class="line-modified"> 621     ras.precision_half  = ras.precision &gt;&gt; 1;</span>
<span class="line-modified"> 622     ras.precision_scale = ras.precision &gt;&gt; Pixel_Bits;</span>
 623   }
 624 
 625 
<span class="line-modified"> 626   /**************************************************************************</span>
<span class="line-modified"> 627    *</span>
<span class="line-modified"> 628    * @Function:</span>
<span class="line-modified"> 629    *   New_Profile</span>
<span class="line-modified"> 630    *</span>
<span class="line-modified"> 631    * @Description:</span>
<span class="line-modified"> 632    *   Create a new profile in the render pool.</span>
<span class="line-modified"> 633    *</span>
<span class="line-modified"> 634    * @Input:</span>
<span class="line-modified"> 635    *   aState ::</span>
<span class="line-modified"> 636    *     The state/orientation of the new profile.</span>
<span class="line-modified"> 637    *</span>
<span class="line-modified"> 638    *   overshoot ::</span>
<span class="line-modified"> 639    *     Whether the profile&#39;s unrounded start position</span>
<span class="line-modified"> 640    *     differs by at least a half pixel.</span>
<span class="line-modified"> 641    *</span>
<span class="line-modified"> 642    * @Return:</span>
<span class="line-modified"> 643    *  SUCCESS on success.  FAILURE in case of overflow or of incoherent</span>
<span class="line-added"> 644    *  profile.</span>
<span class="line-added"> 645    */</span>
 646   static Bool
 647   New_Profile( RAS_ARGS TStates  aState,
 648                         Bool     overshoot )
 649   {
 650     if ( !ras.fProfile )
 651     {
 652       ras.cProfile  = (PProfile)ras.top;
 653       ras.fProfile  = ras.cProfile;
 654       ras.top      += AlignProfileSize;
 655     }
 656 
 657     if ( ras.top &gt;= ras.maxBuff )
 658     {
 659       ras.error = FT_THROW( Overflow );
 660       return FAILURE;
 661     }
 662 

 663     ras.cProfile-&gt;start  = 0;
 664     ras.cProfile-&gt;height = 0;
 665     ras.cProfile-&gt;offset = ras.top;
 666     ras.cProfile-&gt;link   = (PProfile)0;
 667     ras.cProfile-&gt;next   = (PProfile)0;
 668     ras.cProfile-&gt;flags  = ras.dropOutControl;
 669 
 670     switch ( aState )
 671     {
 672     case Ascending_State:
 673       ras.cProfile-&gt;flags |= Flow_Up;
 674       if ( overshoot )
 675         ras.cProfile-&gt;flags |= Overshoot_Bottom;
 676 
 677       FT_TRACE6(( &quot;  new ascending profile = %p\n&quot;, ras.cProfile ));
 678       break;
 679 
 680     case Descending_State:
 681       if ( overshoot )
 682         ras.cProfile-&gt;flags |= Overshoot_Top;
 683       FT_TRACE6(( &quot;  new descending profile = %p\n&quot;, ras.cProfile ));
 684       break;
 685 
 686     default:
 687       FT_ERROR(( &quot;New_Profile: invalid profile direction\n&quot; ));
 688       ras.error = FT_THROW( Invalid );
 689       return FAILURE;
 690     }
 691 
 692     if ( !ras.gProfile )
 693       ras.gProfile = ras.cProfile;
 694 
 695     ras.state = aState;
 696     ras.fresh = TRUE;
 697     ras.joint = FALSE;
 698 
 699     return SUCCESS;
 700   }
 701 
 702 
<span class="line-modified"> 703   /**************************************************************************</span>
<span class="line-modified"> 704    *</span>
<span class="line-modified"> 705    * @Function:</span>
<span class="line-modified"> 706    *   End_Profile</span>
<span class="line-modified"> 707    *</span>
<span class="line-modified"> 708    * @Description:</span>
<span class="line-modified"> 709    *   Finalize the current profile.</span>
<span class="line-modified"> 710    *</span>
<span class="line-modified"> 711    * @Input:</span>
<span class="line-modified"> 712    *   overshoot ::</span>
<span class="line-modified"> 713    *     Whether the profile&#39;s unrounded end position differs</span>
<span class="line-modified"> 714    *     by at least a half pixel.</span>
<span class="line-modified"> 715    *</span>
<span class="line-modified"> 716    * @Return:</span>
<span class="line-modified"> 717    *   SUCCESS on success.  FAILURE in case of overflow or incoherency.</span>
<span class="line-added"> 718    */</span>
 719   static Bool
 720   End_Profile( RAS_ARGS Bool  overshoot )
 721   {
 722     Long  h;
 723 
 724 
 725     h = (Long)( ras.top - ras.cProfile-&gt;offset );
 726 
 727     if ( h &lt; 0 )
 728     {
 729       FT_ERROR(( &quot;End_Profile: negative height encountered\n&quot; ));
 730       ras.error = FT_THROW( Neg_Height );
 731       return FAILURE;
 732     }
 733 
 734     if ( h &gt; 0 )
 735     {
 736       PProfile  oldProfile;
 737 
 738 
</pre>
<hr />
<pre>
 756       ras.cProfile-&gt;height = 0;
 757       ras.cProfile-&gt;offset = ras.top;
 758 
 759       oldProfile-&gt;next = ras.cProfile;
 760       ras.num_Profs++;
 761     }
 762 
 763     if ( ras.top &gt;= ras.maxBuff )
 764     {
 765       FT_TRACE1(( &quot;overflow in End_Profile\n&quot; ));
 766       ras.error = FT_THROW( Overflow );
 767       return FAILURE;
 768     }
 769 
 770     ras.joint = FALSE;
 771 
 772     return SUCCESS;
 773   }
 774 
 775 
<span class="line-modified"> 776   /**************************************************************************</span>
<span class="line-modified"> 777    *</span>
<span class="line-modified"> 778    * @Function:</span>
<span class="line-modified"> 779    *   Insert_Y_Turn</span>
<span class="line-modified"> 780    *</span>
<span class="line-modified"> 781    * @Description:</span>
<span class="line-modified"> 782    *   Insert a salient into the sorted list placed on top of the render</span>
<span class="line-modified"> 783    *   pool.</span>
<span class="line-modified"> 784    *</span>
<span class="line-modified"> 785    * @Input:</span>
<span class="line-modified"> 786    *   New y scanline position.</span>
<span class="line-modified"> 787    *</span>
<span class="line-modified"> 788    * @Return:</span>
<span class="line-modified"> 789    *   SUCCESS on success.  FAILURE in case of overflow.</span>
<span class="line-modified"> 790    */</span>
 791   static Bool
 792   Insert_Y_Turn( RAS_ARGS Int  y )
 793   {
 794     PLong  y_turns;
 795     Int    n;
 796 
 797 
 798     n       = ras.numTurns - 1;
 799     y_turns = ras.sizeBuff - ras.numTurns;
 800 
 801     /* look for first y value that is &lt;= */
 802     while ( n &gt;= 0 &amp;&amp; y &lt; y_turns[n] )
 803       n--;
 804 
 805     /* if it is &lt;, simply insert it, ignore if == */
 806     if ( n &gt;= 0 &amp;&amp; y &gt; y_turns[n] )
 807       do
 808       {
 809         Int  y2 = (Int)y_turns[n];
 810 
</pre>
<hr />
<pre>
 812         y_turns[n] = y;
 813         y = y2;
 814       } while ( --n &gt;= 0 );
 815 
 816     if ( n &lt; 0 )
 817     {
 818       ras.maxBuff--;
 819       if ( ras.maxBuff &lt;= ras.top )
 820       {
 821         ras.error = FT_THROW( Overflow );
 822         return FAILURE;
 823       }
 824       ras.numTurns++;
 825       ras.sizeBuff[-ras.numTurns] = y;
 826     }
 827 
 828     return SUCCESS;
 829   }
 830 
 831 
<span class="line-modified"> 832   /**************************************************************************</span>
<span class="line-modified"> 833    *</span>
<span class="line-modified"> 834    * @Function:</span>
<span class="line-modified"> 835    *   Finalize_Profile_Table</span>
<span class="line-modified"> 836    *</span>
<span class="line-modified"> 837    * @Description:</span>
<span class="line-modified"> 838    *   Adjust all links in the profiles list.</span>
<span class="line-modified"> 839    *</span>
<span class="line-modified"> 840    * @Return:</span>
<span class="line-modified"> 841    *   SUCCESS on success.  FAILURE in case of overflow.</span>
<span class="line-modified"> 842    */</span>
 843   static Bool
 844   Finalize_Profile_Table( RAS_ARG )
 845   {
 846     UShort    n;
 847     PProfile  p;
 848 
 849 
 850     n = ras.num_Profs;
 851     p = ras.fProfile;
 852 
 853     if ( n &gt; 1 &amp;&amp; p )
 854     {
 855       do
 856       {
 857         Int  bottom, top;
 858 
 859 
 860         if ( n &gt; 1 )
 861           p-&gt;link = (PProfile)( p-&gt;offset + p-&gt;height );
 862         else
</pre>
<hr />
<pre>
 872           bottom     = (Int)( p-&gt;start - p-&gt;height + 1 );
 873           top        = (Int)p-&gt;start;
 874           p-&gt;start   = bottom;
 875           p-&gt;offset += p-&gt;height - 1;
 876         }
 877 
 878         if ( Insert_Y_Turn( RAS_VARS bottom )  ||
 879              Insert_Y_Turn( RAS_VARS top + 1 ) )
 880           return FAILURE;
 881 
 882         p = p-&gt;link;
 883       } while ( --n );
 884     }
 885     else
 886       ras.fProfile = NULL;
 887 
 888     return SUCCESS;
 889   }
 890 
 891 
<span class="line-modified"> 892   /**************************************************************************</span>
<span class="line-modified"> 893    *</span>
<span class="line-modified"> 894    * @Function:</span>
<span class="line-modified"> 895    *   Split_Conic</span>
<span class="line-modified"> 896    *</span>
<span class="line-modified"> 897    * @Description:</span>
<span class="line-modified"> 898    *   Subdivide one conic Bezier into two joint sub-arcs in the Bezier</span>
<span class="line-modified"> 899    *   stack.</span>
<span class="line-modified"> 900    *</span>
<span class="line-modified"> 901    * @Input:</span>
<span class="line-modified"> 902    *   None (subdivided Bezier is taken from the top of the stack).</span>
<span class="line-modified"> 903    *</span>
<span class="line-modified"> 904    * @Note:</span>
<span class="line-modified"> 905    *   This routine is the `beef&#39; of this component.  It is  _the_ inner</span>
<span class="line-modified"> 906    *   loop that should be optimized to hell to get the best performance.</span>
<span class="line-modified"> 907    */</span>
 908   static void
 909   Split_Conic( TPoint*  base )
 910   {
 911     Long  a, b;
 912 
 913 
 914     base[4].x = base[2].x;
<span class="line-modified"> 915     a = base[0].x + base[1].x;</span>
<span class="line-modified"> 916     b = base[1].x + base[2].x;</span>
<span class="line-modified"> 917     base[3].x = b &gt;&gt; 1;</span>
<span class="line-modified"> 918     base[2].x = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added"> 919     base[1].x = a &gt;&gt; 1;</span>
 920 
 921     base[4].y = base[2].y;
<span class="line-modified"> 922     a = base[0].y + base[1].y;</span>
<span class="line-modified"> 923     b = base[1].y + base[2].y;</span>
<span class="line-modified"> 924     base[3].y = b &gt;&gt; 1;</span>
<span class="line-modified"> 925     base[2].y = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added"> 926     base[1].y = a &gt;&gt; 1;</span>
 927 
 928     /* hand optimized.  gcc doesn&#39;t seem to be too good at common      */
 929     /* expression substitution and instruction scheduling ;-)          */
 930   }
 931 
 932 
<span class="line-modified"> 933   /**************************************************************************</span>
<span class="line-modified"> 934    *</span>
<span class="line-modified"> 935    * @Function:</span>
<span class="line-modified"> 936    *   Split_Cubic</span>
<span class="line-modified"> 937    *</span>
<span class="line-modified"> 938    * @Description:</span>
<span class="line-modified"> 939    *   Subdivide a third-order Bezier arc into two joint sub-arcs in the</span>
<span class="line-modified"> 940    *   Bezier stack.</span>
<span class="line-modified"> 941    *</span>
<span class="line-modified"> 942    * @Note:</span>
<span class="line-modified"> 943    *   This routine is the `beef&#39; of the component.  It is one of _the_</span>
<span class="line-modified"> 944    *   inner loops that should be optimized like hell to get the best</span>
<span class="line-modified"> 945    *   performance.</span>
<span class="line-modified"> 946    */</span>
 947   static void
 948   Split_Cubic( TPoint*  base )
 949   {
<span class="line-modified"> 950     Long  a, b, c;</span>
 951 
 952 
 953     base[6].x = base[3].x;
<span class="line-modified"> 954     a = base[0].x + base[1].x;</span>
<span class="line-modified"> 955     b = base[1].x + base[2].x;</span>
<span class="line-modified"> 956     c = base[2].x + base[3].x;</span>
<span class="line-modified"> 957     base[5].x = c &gt;&gt; 1;</span>
<span class="line-modified"> 958     c += b;</span>
<span class="line-modified"> 959     base[4].x = c &gt;&gt; 2;</span>
<span class="line-modified"> 960     base[1].x = a &gt;&gt; 1;</span>
<span class="line-modified"> 961     a += b;</span>
<span class="line-added"> 962     base[2].x = a &gt;&gt; 2;</span>
<span class="line-added"> 963     base[3].x = ( a + c ) &gt;&gt; 3;</span>
 964 
 965     base[6].y = base[3].y;
<span class="line-modified"> 966     a = base[0].y + base[1].y;</span>
<span class="line-modified"> 967     b = base[1].y + base[2].y;</span>
<span class="line-modified"> 968     c = base[2].y + base[3].y;</span>
<span class="line-modified"> 969     base[5].y = c &gt;&gt; 1;</span>
<span class="line-modified"> 970     c += b;</span>
<span class="line-modified"> 971     base[4].y = c &gt;&gt; 2;</span>
<span class="line-modified"> 972     base[1].y = a &gt;&gt; 1;</span>
<span class="line-modified"> 973     a += b;</span>
<span class="line-added"> 974     base[2].y = a &gt;&gt; 2;</span>
<span class="line-added"> 975     base[3].y = ( a + c ) &gt;&gt; 3;</span>
 976   }
 977 
 978 
<span class="line-modified"> 979   /**************************************************************************</span>
<span class="line-modified"> 980    *</span>
<span class="line-modified"> 981    * @Function:</span>
<span class="line-modified"> 982    *   Line_Up</span>
<span class="line-modified"> 983    *</span>
<span class="line-modified"> 984    * @Description:</span>
<span class="line-modified"> 985    *   Compute the x-coordinates of an ascending line segment and store</span>
<span class="line-modified"> 986    *   them in the render pool.</span>
<span class="line-modified"> 987    *</span>
<span class="line-modified"> 988    * @Input:</span>
<span class="line-modified"> 989    *   x1 ::</span>
<span class="line-modified"> 990    *     The x-coordinate of the segment&#39;s start point.</span>
<span class="line-modified"> 991    *</span>
<span class="line-modified"> 992    *   y1 ::</span>
<span class="line-modified"> 993    *     The y-coordinate of the segment&#39;s start point.</span>
<span class="line-modified"> 994    *</span>
<span class="line-modified"> 995    *   x2 ::</span>
<span class="line-modified"> 996    *     The x-coordinate of the segment&#39;s end point.</span>
<span class="line-modified"> 997    *</span>
<span class="line-modified"> 998    *   y2 ::</span>
<span class="line-modified"> 999    *     The y-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">1000    *</span>
<span class="line-modified">1001    *   miny ::</span>
<span class="line-modified">1002    *     A lower vertical clipping bound value.</span>
<span class="line-modified">1003    *</span>
<span class="line-added">1004    *   maxy ::</span>
<span class="line-added">1005    *     An upper vertical clipping bound value.</span>
<span class="line-added">1006    *</span>
<span class="line-added">1007    * @Return:</span>
<span class="line-added">1008    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">1009    */</span>
1010   static Bool
1011   Line_Up( RAS_ARGS Long  x1,
1012                     Long  y1,
1013                     Long  x2,
1014                     Long  y2,
1015                     Long  miny,
1016                     Long  maxy )
1017   {
1018     Long   Dx, Dy;
1019     Int    e1, e2, f1, f2, size;     /* XXX: is `Short&#39; sufficient? */
1020     Long   Ix, Rx, Ax;
1021 
1022     PLong  top;
1023 
1024 
1025     Dx = x2 - x1;
1026     Dy = y2 - y1;
1027 
1028     if ( Dy &lt;= 0 || y2 &lt; miny || y1 &gt; maxy )
1029       return SUCCESS;
</pre>
<hr />
<pre>
1104 
1105     while ( size &gt; 0 )
1106     {
1107       *top++ = x1;
1108 
1109       x1 += Ix;
1110       Ax += Rx;
1111       if ( Ax &gt;= 0 )
1112       {
1113         Ax -= Dy;
1114         x1 += Dx;
1115       }
1116       size--;
1117     }
1118 
1119     ras.top = top;
1120     return SUCCESS;
1121   }
1122 
1123 
<span class="line-modified">1124   /**************************************************************************</span>
<span class="line-modified">1125    *</span>
<span class="line-modified">1126    * @Function:</span>
<span class="line-modified">1127    *   Line_Down</span>
<span class="line-modified">1128    *</span>
<span class="line-modified">1129    * @Description:</span>
<span class="line-modified">1130    *   Compute the x-coordinates of an descending line segment and store</span>
<span class="line-modified">1131    *   them in the render pool.</span>
<span class="line-modified">1132    *</span>
<span class="line-modified">1133    * @Input:</span>
<span class="line-modified">1134    *   x1 ::</span>
<span class="line-modified">1135    *     The x-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">1136    *</span>
<span class="line-modified">1137    *   y1 ::</span>
<span class="line-modified">1138    *     The y-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">1139    *</span>
<span class="line-modified">1140    *   x2 ::</span>
<span class="line-modified">1141    *     The x-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">1142    *</span>
<span class="line-modified">1143    *   y2 ::</span>
<span class="line-modified">1144    *     The y-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">1145    *</span>
<span class="line-modified">1146    *   miny ::</span>
<span class="line-modified">1147    *     A lower vertical clipping bound value.</span>
<span class="line-modified">1148    *</span>
<span class="line-added">1149    *   maxy ::</span>
<span class="line-added">1150    *     An upper vertical clipping bound value.</span>
<span class="line-added">1151    *</span>
<span class="line-added">1152    * @Return:</span>
<span class="line-added">1153    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">1154    */</span>
1155   static Bool
1156   Line_Down( RAS_ARGS Long  x1,
1157                       Long  y1,
1158                       Long  x2,
1159                       Long  y2,
1160                       Long  miny,
1161                       Long  maxy )
1162   {
1163     Bool  result, fresh;
1164 
1165 
1166     fresh  = ras.fresh;
1167 
1168     result = Line_Up( RAS_VARS x1, -y1, x2, -y2, -maxy, -miny );
1169 
1170     if ( fresh &amp;&amp; !ras.fresh )
1171       ras.cProfile-&gt;start = -ras.cProfile-&gt;start;
1172 
1173     return result;
1174   }
1175 
1176 
1177   /* A function type describing the functions used to split Bezier arcs */
1178   typedef void  (*TSplitter)( TPoint*  base );
1179 
1180 
<span class="line-modified">1181   /**************************************************************************</span>
<span class="line-modified">1182    *</span>
<span class="line-modified">1183    * @Function:</span>
<span class="line-modified">1184    *   Bezier_Up</span>
<span class="line-modified">1185    *</span>
<span class="line-modified">1186    * @Description:</span>
<span class="line-modified">1187    *   Compute the x-coordinates of an ascending Bezier arc and store</span>
<span class="line-modified">1188    *   them in the render pool.</span>
<span class="line-modified">1189    *</span>
<span class="line-modified">1190    * @Input:</span>
<span class="line-modified">1191    *   degree ::</span>
<span class="line-modified">1192    *     The degree of the Bezier arc (either 2 or 3).</span>
<span class="line-modified">1193    *</span>
<span class="line-modified">1194    *   splitter ::</span>
<span class="line-modified">1195    *     The function to split Bezier arcs.</span>
<span class="line-modified">1196    *</span>
<span class="line-modified">1197    *   miny ::</span>
<span class="line-modified">1198    *     A lower vertical clipping bound value.</span>
<span class="line-modified">1199    *</span>
<span class="line-modified">1200    *   maxy ::</span>
<span class="line-modified">1201    *     An upper vertical clipping bound value.</span>
<span class="line-added">1202    *</span>
<span class="line-added">1203    * @Return:</span>
<span class="line-added">1204    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">1205    */</span>
1206   static Bool
1207   Bezier_Up( RAS_ARGS Int        degree,
1208                       TSplitter  splitter,
1209                       Long       miny,
1210                       Long       maxy )
1211   {
1212     Long   y1, y2, e, e2, e0;
1213     Short  f1;
1214 
1215     TPoint*  arc;
1216     TPoint*  start_arc;
1217 
1218     PLong top;
1219 
1220 
1221     arc = ras.arc;
1222     y1  = arc[degree].y;
1223     y2  = arc[0].y;
1224     top = ras.top;
1225 
</pre>
<hr />
<pre>
1298       else
1299       {
1300         if ( y2 == e )
1301         {
1302           ras.joint  = TRUE;
1303           *top++     = arc[0].x;
1304 
1305           e += ras.precision;
1306         }
1307         arc -= degree;
1308       }
1309     } while ( arc &gt;= start_arc &amp;&amp; e &lt;= e2 );
1310 
1311   Fin:
1312     ras.top  = top;
1313     ras.arc -= degree;
1314     return SUCCESS;
1315   }
1316 
1317 
<span class="line-modified">1318   /**************************************************************************</span>
<span class="line-modified">1319    *</span>
<span class="line-modified">1320    * @Function:</span>
<span class="line-modified">1321    *   Bezier_Down</span>
<span class="line-modified">1322    *</span>
<span class="line-modified">1323    * @Description:</span>
<span class="line-modified">1324    *   Compute the x-coordinates of an descending Bezier arc and store</span>
<span class="line-modified">1325    *   them in the render pool.</span>
<span class="line-modified">1326    *</span>
<span class="line-modified">1327    * @Input:</span>
<span class="line-modified">1328    *   degree ::</span>
<span class="line-modified">1329    *     The degree of the Bezier arc (either 2 or 3).</span>
<span class="line-modified">1330    *</span>
<span class="line-modified">1331    *   splitter ::</span>
<span class="line-modified">1332    *     The function to split Bezier arcs.</span>
<span class="line-modified">1333    *</span>
<span class="line-modified">1334    *   miny ::</span>
<span class="line-modified">1335    *     A lower vertical clipping bound value.</span>
<span class="line-modified">1336    *</span>
<span class="line-modified">1337    *   maxy ::</span>
<span class="line-modified">1338    *     An upper vertical clipping bound value.</span>
<span class="line-added">1339    *</span>
<span class="line-added">1340    * @Return:</span>
<span class="line-added">1341    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">1342    */</span>
1343   static Bool
1344   Bezier_Down( RAS_ARGS Int        degree,
1345                         TSplitter  splitter,
1346                         Long       miny,
1347                         Long       maxy )
1348   {
1349     TPoint*  arc = ras.arc;
1350     Bool     result, fresh;
1351 
1352 
1353     arc[0].y = -arc[0].y;
1354     arc[1].y = -arc[1].y;
1355     arc[2].y = -arc[2].y;
1356     if ( degree &gt; 2 )
1357       arc[3].y = -arc[3].y;
1358 
1359     fresh = ras.fresh;
1360 
1361     result = Bezier_Up( RAS_VARS degree, splitter, -maxy, -miny );
1362 
1363     if ( fresh &amp;&amp; !ras.fresh )
1364       ras.cProfile-&gt;start = -ras.cProfile-&gt;start;
1365 
1366     arc[0].y = -arc[0].y;
1367     return result;
1368   }
1369 
1370 
<span class="line-modified">1371   /**************************************************************************</span>
<span class="line-modified">1372    *</span>
<span class="line-modified">1373    * @Function:</span>
<span class="line-modified">1374    *   Line_To</span>
<span class="line-modified">1375    *</span>
<span class="line-modified">1376    * @Description:</span>
<span class="line-modified">1377    *   Inject a new line segment and adjust the Profiles list.</span>
<span class="line-modified">1378    *</span>
<span class="line-modified">1379    * @Input:</span>
<span class="line-modified">1380    *  x ::</span>
<span class="line-modified">1381    *    The x-coordinate of the segment&#39;s end point (its start point</span>
<span class="line-modified">1382    *    is stored in `lastX&#39;).</span>
<span class="line-modified">1383    *</span>
<span class="line-modified">1384    *  y ::</span>
<span class="line-modified">1385    *    The y-coordinate of the segment&#39;s end point (its start point</span>
<span class="line-modified">1386    *    is stored in `lastY&#39;).</span>
<span class="line-modified">1387    *</span>
<span class="line-modified">1388    * @Return:</span>
<span class="line-modified">1389    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">1390    *  profile.</span>
<span class="line-added">1391    */</span>
1392   static Bool
1393   Line_To( RAS_ARGS Long  x,
1394                     Long  y )
1395   {
1396     /* First, detect a change of direction */
1397 
1398     switch ( ras.state )
1399     {
1400     case Unknown_State:
1401       if ( y &gt; ras.lastY )
1402       {
1403         if ( New_Profile( RAS_VARS Ascending_State,
1404                                    IS_BOTTOM_OVERSHOOT( ras.lastY ) ) )
1405           return FAILURE;
1406       }
1407       else
1408       {
1409         if ( y &lt; ras.lastY )
1410           if ( New_Profile( RAS_VARS Descending_State,
1411                                      IS_TOP_OVERSHOOT( ras.lastY ) ) )
</pre>
<hr />
<pre>
1447         return FAILURE;
1448       break;
1449 
1450     case Descending_State:
1451       if ( Line_Down( RAS_VARS ras.lastX, ras.lastY,
1452                                x, y, ras.minY, ras.maxY ) )
1453         return FAILURE;
1454       break;
1455 
1456     default:
1457       ;
1458     }
1459 
1460     ras.lastX = x;
1461     ras.lastY = y;
1462 
1463     return SUCCESS;
1464   }
1465 
1466 
<span class="line-modified">1467   /**************************************************************************</span>
<span class="line-modified">1468    *</span>
<span class="line-modified">1469    * @Function:</span>
<span class="line-modified">1470    *   Conic_To</span>
<span class="line-modified">1471    *</span>
<span class="line-modified">1472    * @Description:</span>
<span class="line-modified">1473    *   Inject a new conic arc and adjust the profile list.</span>
<span class="line-modified">1474    *</span>
<span class="line-modified">1475    * @Input:</span>
<span class="line-modified">1476    *  cx ::</span>
<span class="line-modified">1477    *    The x-coordinate of the arc&#39;s new control point.</span>
<span class="line-modified">1478    *</span>
<span class="line-modified">1479    *  cy ::</span>
<span class="line-modified">1480    *    The y-coordinate of the arc&#39;s new control point.</span>
<span class="line-modified">1481    *</span>
<span class="line-modified">1482    *  x ::</span>
<span class="line-modified">1483    *    The x-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">1484    *    stored in `lastX&#39;).</span>
<span class="line-modified">1485    *</span>
<span class="line-modified">1486    *  y ::</span>
<span class="line-modified">1487    *    The y-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">1488    *    stored in `lastY&#39;).</span>
<span class="line-modified">1489    *</span>
<span class="line-added">1490    * @Return:</span>
<span class="line-added">1491    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">1492    *  profile.</span>
<span class="line-added">1493    */</span>
1494   static Bool
1495   Conic_To( RAS_ARGS Long  cx,
1496                      Long  cy,
1497                      Long  x,
1498                      Long  y )
1499   {
1500     Long     y1, y2, y3, x3, ymin, ymax;
1501     TStates  state_bez;
1502 
1503 
1504     ras.arc      = ras.arcs;
1505     ras.arc[2].x = ras.lastX;
1506     ras.arc[2].y = ras.lastY;
1507     ras.arc[1].x = cx;
1508     ras.arc[1].y = cy;
1509     ras.arc[0].x = x;
1510     ras.arc[0].y = y;
1511 
1512     do
1513     {
</pre>
<hr />
<pre>
1568           if ( Bezier_Up( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
1569             goto Fail;
1570         }
1571         else
1572           if ( Bezier_Down( RAS_VARS 2, Split_Conic, ras.minY, ras.maxY ) )
1573             goto Fail;
1574       }
1575 
1576     } while ( ras.arc &gt;= ras.arcs );
1577 
1578     ras.lastX = x3;
1579     ras.lastY = y3;
1580 
1581     return SUCCESS;
1582 
1583   Fail:
1584     return FAILURE;
1585   }
1586 
1587 
<span class="line-modified">1588   /**************************************************************************</span>
<span class="line-modified">1589    *</span>
<span class="line-modified">1590    * @Function:</span>
<span class="line-modified">1591    *   Cubic_To</span>
<span class="line-modified">1592    *</span>
<span class="line-modified">1593    * @Description:</span>
<span class="line-modified">1594    *   Inject a new cubic arc and adjust the profile list.</span>
<span class="line-modified">1595    *</span>
<span class="line-modified">1596    * @Input:</span>
<span class="line-modified">1597    *  cx1 ::</span>
<span class="line-modified">1598    *    The x-coordinate of the arc&#39;s first new control point.</span>
<span class="line-modified">1599    *</span>
<span class="line-modified">1600    *  cy1 ::</span>
<span class="line-modified">1601    *    The y-coordinate of the arc&#39;s first new control point.</span>
<span class="line-modified">1602    *</span>
<span class="line-modified">1603    *  cx2 ::</span>
<span class="line-modified">1604    *    The x-coordinate of the arc&#39;s second new control point.</span>
<span class="line-modified">1605    *</span>
<span class="line-modified">1606    *  cy2 ::</span>
<span class="line-modified">1607    *    The y-coordinate of the arc&#39;s second new control point.</span>
<span class="line-modified">1608    *</span>
<span class="line-modified">1609    *  x ::</span>
<span class="line-modified">1610    *    The x-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">1611    *    stored in `lastX&#39;).</span>
<span class="line-modified">1612    *</span>
<span class="line-modified">1613    *  y ::</span>
<span class="line-modified">1614    *    The y-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-added">1615    *    stored in `lastY&#39;).</span>
<span class="line-added">1616    *</span>
<span class="line-added">1617    * @Return:</span>
<span class="line-added">1618    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">1619    *  profile.</span>
<span class="line-added">1620    */</span>
1621   static Bool
1622   Cubic_To( RAS_ARGS Long  cx1,
1623                      Long  cy1,
1624                      Long  cx2,
1625                      Long  cy2,
1626                      Long  x,
1627                      Long  y )
1628   {
1629     Long     y1, y2, y3, y4, x4, ymin1, ymax1, ymin2, ymax2;
1630     TStates  state_bez;
1631 
1632 
1633     ras.arc      = ras.arcs;
1634     ras.arc[3].x = ras.lastX;
1635     ras.arc[3].y = ras.lastY;
1636     ras.arc[2].x = cx1;
1637     ras.arc[2].y = cy1;
1638     ras.arc[1].x = cx2;
1639     ras.arc[1].y = cy2;
1640     ras.arc[0].x = x;
</pre>
<hr />
<pre>
1721     ras.lastY = y4;
1722 
1723     return SUCCESS;
1724 
1725   Fail:
1726     return FAILURE;
1727   }
1728 
1729 
1730 #undef  SWAP_
1731 #define SWAP_( x, y )  do                \
1732                        {                 \
1733                          Long  swap = x; \
1734                                          \
1735                                          \
1736                          x = y;          \
1737                          y = swap;       \
1738                        } while ( 0 )
1739 
1740 
<span class="line-modified">1741   /**************************************************************************</span>
<span class="line-modified">1742    *</span>
<span class="line-modified">1743    * @Function:</span>
<span class="line-modified">1744    *   Decompose_Curve</span>
<span class="line-modified">1745    *</span>
<span class="line-modified">1746    * @Description:</span>
<span class="line-modified">1747    *   Scan the outline arrays in order to emit individual segments and</span>
<span class="line-modified">1748    *   Beziers by calling Line_To() and Bezier_To().  It handles all</span>
<span class="line-modified">1749    *   weird cases, like when the first point is off the curve, or when</span>
<span class="line-modified">1750    *   there are simply no `on&#39; points in the contour!</span>
<span class="line-modified">1751    *</span>
<span class="line-modified">1752    * @Input:</span>
<span class="line-modified">1753    *   first ::</span>
<span class="line-modified">1754    *     The index of the first point in the contour.</span>
<span class="line-modified">1755    *</span>
<span class="line-modified">1756    *   last ::</span>
<span class="line-modified">1757    *     The index of the last point in the contour.</span>
<span class="line-modified">1758    *</span>
<span class="line-modified">1759    *   flipped ::</span>
<span class="line-modified">1760    *     If set, flip the direction of the curve.</span>
<span class="line-modified">1761    *</span>
<span class="line-added">1762    * @Return:</span>
<span class="line-added">1763    *   SUCCESS on success, FAILURE on error.</span>
<span class="line-added">1764    */</span>
1765   static Bool
1766   Decompose_Curve( RAS_ARGS UShort  first,
1767                             UShort  last,
1768                             Int     flipped )
1769   {
1770     FT_Vector   v_last;
1771     FT_Vector   v_control;
1772     FT_Vector   v_start;
1773 
1774     FT_Vector*  points;
1775     FT_Vector*  point;
1776     FT_Vector*  limit;
1777     char*       tags;
1778 
1779     UInt        tag;       /* current point&#39;s state           */
1780 
1781 
1782     points = ras.outline.points;
1783     limit  = points + last;
1784 
</pre>
<hr />
<pre>
1953           goto Close;
1954         }
1955       }
1956     }
1957 
1958     /* close the contour with a line segment */
1959     if ( Line_To( RAS_VARS v_start.x, v_start.y ) )
1960       goto Fail;
1961 
1962   Close:
1963     return SUCCESS;
1964 
1965   Invalid_Outline:
1966     ras.error = FT_THROW( Invalid );
1967 
1968   Fail:
1969     return FAILURE;
1970   }
1971 
1972 
<span class="line-modified">1973   /**************************************************************************</span>
<span class="line-modified">1974    *</span>
<span class="line-modified">1975    * @Function:</span>
<span class="line-modified">1976    *   Convert_Glyph</span>
<span class="line-modified">1977    *</span>
<span class="line-modified">1978    * @Description:</span>
<span class="line-modified">1979    *   Convert a glyph into a series of segments and arcs and make a</span>
<span class="line-modified">1980    *   profiles list with them.</span>
<span class="line-modified">1981    *</span>
<span class="line-modified">1982    * @Input:</span>
<span class="line-modified">1983    *   flipped ::</span>
<span class="line-modified">1984    *     If set, flip the direction of curve.</span>
<span class="line-modified">1985    *</span>
<span class="line-modified">1986    * @Return:</span>
<span class="line-modified">1987    *   SUCCESS on success, FAILURE if any error was encountered during</span>
<span class="line-modified">1988    *   rendering.</span>
<span class="line-added">1989    */</span>
1990   static Bool
1991   Convert_Glyph( RAS_ARGS Int  flipped )
1992   {
1993     Int   i;
1994     UInt  start;
1995 
1996 
1997     ras.fProfile = NULL;
1998     ras.joint    = FALSE;
1999     ras.fresh    = FALSE;
2000 
2001     ras.maxBuff  = ras.sizeBuff - AlignProfileSize;
2002 
2003     ras.numTurns = 0;
2004 
2005     ras.cProfile         = (PProfile)ras.top;
2006     ras.cProfile-&gt;offset = ras.top;
2007     ras.num_Profs        = 0;
2008 
2009     start = 0;
</pre>
<hr />
<pre>
2048       if ( ras.gProfile )
2049         lastProfile-&gt;next = ras.gProfile;
2050     }
2051 
2052     if ( Finalize_Profile_Table( RAS_VAR ) )
2053       return FAILURE;
2054 
2055     return (Bool)( ras.top &lt; ras.maxBuff ? SUCCESS : FAILURE );
2056   }
2057 
2058 
2059   /*************************************************************************/
2060   /*************************************************************************/
2061   /**                                                                     **/
2062   /**  SCAN-LINE SWEEPS AND DRAWING                                       **/
2063   /**                                                                     **/
2064   /*************************************************************************/
2065   /*************************************************************************/
2066 
2067 
<span class="line-modified">2068   /**************************************************************************</span>
<span class="line-modified">2069    *</span>
<span class="line-modified">2070    * Init_Linked</span>
<span class="line-modified">2071    *</span>
<span class="line-modified">2072    *   Initializes an empty linked list.</span>
<span class="line-modified">2073    */</span>
2074   static void
2075   Init_Linked( TProfileList*  l )
2076   {
2077     *l = NULL;
2078   }
2079 
2080 
<span class="line-modified">2081   /**************************************************************************</span>
<span class="line-modified">2082    *</span>
<span class="line-modified">2083    * InsNew</span>
<span class="line-modified">2084    *</span>
<span class="line-modified">2085    *   Inserts a new profile in a linked list.</span>
<span class="line-modified">2086    */</span>
2087   static void
2088   InsNew( PProfileList  list,
2089           PProfile      profile )
2090   {
2091     PProfile  *old, current;
2092     Long       x;
2093 
2094 
2095     old     = list;
2096     current = *old;
2097     x       = profile-&gt;X;
2098 
2099     while ( current )
2100     {
2101       if ( x &lt; current-&gt;X )
2102         break;
2103       old     = &amp;current-&gt;link;
2104       current = *old;
2105     }
2106 
2107     profile-&gt;link = current;
2108     *old          = profile;
2109   }
2110 
2111 
<span class="line-modified">2112   /**************************************************************************</span>
<span class="line-modified">2113    *</span>
<span class="line-modified">2114    * DelOld</span>
<span class="line-modified">2115    *</span>
<span class="line-modified">2116    *   Removes an old profile from a linked list.</span>
<span class="line-modified">2117    */</span>
2118   static void
2119   DelOld( PProfileList  list,
2120           PProfile      profile )
2121   {
2122     PProfile  *old, current;
2123 
2124 
2125     old     = list;
2126     current = *old;
2127 
2128     while ( current )
2129     {
2130       if ( current == profile )
2131       {
2132         *old = current-&gt;link;
2133         return;
2134       }
2135 
2136       old     = &amp;current-&gt;link;
2137       current = *old;
2138     }
2139 
2140     /* we should never get there, unless the profile was not part of */
2141     /* the list.                                                     */
2142   }
2143 
2144 
<span class="line-modified">2145   /**************************************************************************</span>
<span class="line-modified">2146    *</span>
<span class="line-modified">2147    * Sort</span>
<span class="line-modified">2148    *</span>
<span class="line-modified">2149    *   Sorts a trace list.  In 95%, the list is already sorted.  We need</span>
<span class="line-modified">2150    *   an algorithm which is fast in this case.  Bubble sort is enough</span>
<span class="line-modified">2151    *   and simple.</span>
<span class="line-modified">2152    */</span>
2153   static void
2154   Sort( PProfileList  list )
2155   {
2156     PProfile  *old, current, next;
2157 
2158 
2159     /* First, set the new X coordinate of each profile */
2160     current = *list;
2161     while ( current )
2162     {
2163       current-&gt;X       = *current-&gt;offset;
2164       current-&gt;offset += ( current-&gt;flags &amp; Flow_Up ) ? 1 : -1;
2165       current-&gt;height--;
2166       current = current-&gt;link;
2167     }
2168 
2169     /* Then sort them */
2170     old     = list;
2171     current = *old;
2172 
</pre>
<hr />
<pre>
2183         current = *old;
2184 
2185         if ( !current )
2186           return;
2187       }
2188       else
2189       {
2190         *old          = next;
2191         current-&gt;link = next-&gt;link;
2192         next-&gt;link    = current;
2193 
2194         old     = list;
2195         current = *old;
2196       }
2197 
2198       next = current-&gt;link;
2199     }
2200   }
2201 
2202 
<span class="line-modified">2203   /**************************************************************************</span>
<span class="line-modified">2204    *</span>
<span class="line-modified">2205    * Vertical Sweep Procedure Set</span>
<span class="line-modified">2206    *</span>
<span class="line-modified">2207    * These four routines are used during the vertical black/white sweep</span>
<span class="line-modified">2208    * phase by the generic Draw_Sweep() function.</span>
<span class="line-modified">2209    *</span>
<span class="line-modified">2210    */</span>
2211 
2212   static void
2213   Vertical_Sweep_Init( RAS_ARGS Short*  min,
2214                                 Short*  max )
2215   {
2216     Long  pitch = ras.target.pitch;
2217 
2218     FT_UNUSED( max );
2219 
2220 
2221     ras.traceIncr = (Short)-pitch;
2222     ras.traceOfs  = -*min * pitch;


2223   }
2224 
2225 
2226   static void
2227   Vertical_Sweep_Span( RAS_ARGS Short       y,
2228                                 FT_F26Dot6  x1,
2229                                 FT_F26Dot6  x2,
2230                                 PProfile    left,
2231                                 PProfile    right )
2232   {
2233     Long   e1, e2;
2234     Byte*  target;
2235 
2236     Int  dropOutControl = left-&gt;flags &amp; 7;
2237 
2238     FT_UNUSED( y );
2239     FT_UNUSED( left );
2240     FT_UNUSED( right );
2241 
2242 
2243     /* in high-precision mode, we need 12 digits after the comma to */
2244     /* represent multiples of 1/(1&lt;&lt;12) = 1/4096                    */
2245     FT_TRACE7(( &quot;  y=%d x=[%.12f;%.12f], drop-out=%d&quot;,
2246                 y,
2247                 x1 / (double)ras.precision,
2248                 x2 / (double)ras.precision,
2249                 dropOutControl ));
2250 
2251     /* Drop-out control */
2252 
<span class="line-modified">2253     e1 = CEILING( x1 );</span>
<span class="line-added">2254     e2 = FLOOR( x2 );</span>
2255 
<span class="line-added">2256     /* take care of the special case where both the left */</span>
<span class="line-added">2257     /* and right contour lie exactly on pixel centers    */</span>
2258     if ( dropOutControl != 2                             &amp;&amp;
<span class="line-modified">2259          x2 - x1 - ras.precision &lt;= ras.precision_jitter &amp;&amp;</span>
<span class="line-added">2260          e1 != x1 &amp;&amp; e2 != x2                            )</span>
2261       e2 = e1;
<span class="line-modified">2262 </span>
<span class="line-modified">2263     e1 = TRUNC( e1 );</span>
<span class="line-added">2264     e2 = TRUNC( e2 );</span>
2265 
2266     if ( e2 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
2267     {
2268       Int   c1, c2;
2269       Byte  f1, f2;
2270 
2271 
2272       if ( e1 &lt; 0 )
2273         e1 = 0;
2274       if ( e2 &gt;= ras.bWidth )
2275         e2 = ras.bWidth - 1;
2276 
2277       FT_TRACE7(( &quot; -&gt; x=[%d;%d]&quot;, e1, e2 ));
2278 
2279       c1 = (Short)( e1 &gt;&gt; 3 );
2280       c2 = (Short)( e2 &gt;&gt; 3 );
2281 
2282       f1 = (Byte)  ( 0xFF &gt;&gt; ( e1 &amp; 7 ) );
2283       f2 = (Byte) ~( 0x7F &gt;&gt; ( e2 &amp; 7 ) );
2284 
<span class="line-modified">2285       target = ras.bOrigin + ras.traceOfs + c1;</span>
2286       c2 -= c1;
2287 
2288       if ( c2 &gt; 0 )
2289       {
2290         target[0] |= f1;
2291 
2292         /* memset() is slower than the following code on many platforms. */
2293         /* This is due to the fact that, in the vast majority of cases,  */
2294         /* the span length in bytes is relatively small.                 */
<span class="line-modified">2295         while ( --c2 &gt; 0 )</span>


2296           *(++target) = 0xFF;
<span class="line-modified">2297 </span>

2298         target[1] |= f2;
2299       }
2300       else
2301         *target |= ( f1 &amp; f2 );
2302     }
2303 
2304     FT_TRACE7(( &quot;\n&quot; ));
2305   }
2306 
2307 
2308   static void
2309   Vertical_Sweep_Drop( RAS_ARGS Short       y,
2310                                 FT_F26Dot6  x1,
2311                                 FT_F26Dot6  x2,
2312                                 PProfile    left,
2313                                 PProfile    right )
2314   {
2315     Long   e1, e2, pxl;
2316     Short  c1, f1;
2317 
</pre>
<hr />
<pre>
2420           goto Exit;  /* no drop-out control */
2421         }
2422 
2423         /* undocumented but confirmed: If the drop-out would result in a  */
2424         /* pixel outside of the bounding box, use the pixel inside of the */
2425         /* bounding box instead                                           */
2426         if ( pxl &lt; 0 )
2427           pxl = e1;
2428         else if ( TRUNC( pxl ) &gt;= ras.bWidth )
2429           pxl = e2;
2430 
2431         /* check that the other pixel isn&#39;t set */
2432         e1 = ( pxl == e1 ) ? e2 : e1;
2433 
2434         e1 = TRUNC( e1 );
2435 
2436         c1 = (Short)( e1 &gt;&gt; 3 );
2437         f1 = (Short)( e1 &amp;  7 );
2438 
2439         if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth                      &amp;&amp;
<span class="line-modified">2440              ras.bOrigin[ras.traceOfs + c1] &amp; ( 0x80 &gt;&gt; f1 ) )</span>
2441           goto Exit;
2442       }
2443       else
2444         goto Exit;
2445     }
2446 
2447     e1 = TRUNC( pxl );
2448 
2449     if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
2450     {
2451       FT_TRACE7(( &quot; -&gt; x=%d (drop-out)&quot;, e1 ));
2452 
2453       c1 = (Short)( e1 &gt;&gt; 3 );
2454       f1 = (Short)( e1 &amp; 7 );
2455 
<span class="line-modified">2456       ras.bOrigin[ras.traceOfs + c1] |= (char)( 0x80 &gt;&gt; f1 );</span>
2457     }
2458 
2459   Exit:
2460     FT_TRACE7(( &quot;\n&quot; ));
2461   }
2462 
2463 
2464   static void
2465   Vertical_Sweep_Step( RAS_ARG )
2466   {
2467     ras.traceOfs += ras.traceIncr;
2468   }
2469 
2470 
<span class="line-modified">2471   /************************************************************************</span>
<span class="line-modified">2472    *</span>
<span class="line-modified">2473    * Horizontal Sweep Procedure Set</span>
<span class="line-modified">2474    *</span>
<span class="line-modified">2475    * These four routines are used during the horizontal black/white</span>
<span class="line-modified">2476    * sweep phase by the generic Draw_Sweep() function.</span>
<span class="line-modified">2477    *</span>
<span class="line-modified">2478    */</span>
2479 
2480   static void
2481   Horizontal_Sweep_Init( RAS_ARGS Short*  min,
2482                                   Short*  max )
2483   {
2484     /* nothing, really */
2485     FT_UNUSED_RASTER;
2486     FT_UNUSED( min );
2487     FT_UNUSED( max );
2488   }
2489 
2490 
2491   static void
2492   Horizontal_Sweep_Span( RAS_ARGS Short       y,
2493                                   FT_F26Dot6  x1,
2494                                   FT_F26Dot6  x2,
2495                                   PProfile    left,
2496                                   PProfile    right )
2497   {
2498     FT_UNUSED( left );
</pre>
<hr />
<pre>
2503     {
2504       Long  e1, e2;
2505 
2506 
2507       FT_TRACE7(( &quot;  x=%d y=[%.12f;%.12f]&quot;,
2508                   y,
2509                   x1 / (double)ras.precision,
2510                   x2 / (double)ras.precision ));
2511 
2512       e1 = CEILING( x1 );
2513       e2 = FLOOR  ( x2 );
2514 
2515       if ( e1 == e2 )
2516       {
2517         e1 = TRUNC( e1 );
2518 
2519         if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
2520         {
2521           Byte   f1;
2522           PByte  bits;

2523 
2524 
2525           FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
2526 
<span class="line-modified">2527           bits = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
2528           f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );

2529 
<span class="line-modified">2530           bits[0] |= f1;</span>



2531         }
2532       }
2533 
2534       FT_TRACE7(( &quot;\n&quot; ));
2535     }
2536   }
2537 
2538 
2539   static void
2540   Horizontal_Sweep_Drop( RAS_ARGS Short       y,
2541                                   FT_F26Dot6  x1,
2542                                   FT_F26Dot6  x2,
2543                                   PProfile    left,
2544                                   PProfile    right )
2545   {
2546     Long   e1, e2, pxl;
2547     PByte  bits;
2548     Byte   f1;
2549 
2550 
</pre>
<hr />
<pre>
2612             pxl = FLOOR( ( x1 + x2 - 1 ) / 2 + ras.precision_half );
2613           break;
2614 
2615         default: /* modes 2, 3, 6, 7 */
2616           goto Exit;  /* no drop-out control */
2617         }
2618 
2619         /* undocumented but confirmed: If the drop-out would result in a  */
2620         /* pixel outside of the bounding box, use the pixel inside of the */
2621         /* bounding box instead                                           */
2622         if ( pxl &lt; 0 )
2623           pxl = e1;
2624         else if ( (ULong)( TRUNC( pxl ) ) &gt;= ras.target.rows )
2625           pxl = e2;
2626 
2627         /* check that the other pixel isn&#39;t set */
2628         e1 = ( pxl == e1 ) ? e2 : e1;
2629 
2630         e1 = TRUNC( e1 );
2631 
<span class="line-modified">2632         bits = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
2633         f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
2634 




2635         if ( e1 &gt;= 0                     &amp;&amp;
2636              (ULong)e1 &lt; ras.target.rows &amp;&amp;
2637              *bits &amp; f1                  )
2638           goto Exit;
2639       }
2640       else
2641         goto Exit;
2642     }
2643 
2644     e1 = TRUNC( pxl );
2645 
2646     if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
2647     {
2648       FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
2649 
<span class="line-modified">2650       bits  = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
2651       f1    = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );




2652 
2653       bits[0] |= f1;
2654     }
2655 
2656   Exit:
2657     FT_TRACE7(( &quot;\n&quot; ));
2658   }
2659 
2660 
2661   static void
2662   Horizontal_Sweep_Step( RAS_ARG )
2663   {
2664     /* Nothing, really */
2665     FT_UNUSED_RASTER;
2666   }
2667 
2668 
<span class="line-modified">2669   /**************************************************************************</span>
<span class="line-modified">2670    *</span>
<span class="line-modified">2671    * Generic Sweep Drawing routine</span>
<span class="line-modified">2672    *</span>
<span class="line-modified">2673    */</span>
2674 
2675   static Bool
2676   Draw_Sweep( RAS_ARG )
2677   {
2678     Short         y, y_change, y_height;
2679 
2680     PProfile      P, Q, P_Left, P_Right;
2681 
2682     Short         min_Y, max_Y, top, bottom, dropouts;
2683 
2684     Long          x1, x2, xs, e1, e2;
2685 
2686     TProfileList  waiting;
2687     TProfileList  draw_left, draw_right;
2688 
2689 
2690     /* initialize empty linked lists */
2691 
2692     Init_Linked( &amp;waiting );
2693 
</pre>
<hr />
<pre>
2771         P = Q;
2772       }
2773 
2774       /* sort the drawing lists */
2775 
2776       Sort( &amp;draw_left );
2777       Sort( &amp;draw_right );
2778 
2779       y_change = (Short)ras.sizeBuff[-ras.numTurns--];
2780       y_height = (Short)( y_change - y );
2781 
2782       while ( y &lt; y_change )
2783       {
2784         /* let&#39;s trace */
2785 
2786         dropouts = 0;
2787 
2788         P_Left  = draw_left;
2789         P_Right = draw_right;
2790 
<span class="line-modified">2791         while ( P_Left &amp;&amp; P_Right )</span>
2792         {
2793           x1 = P_Left -&gt;X;
2794           x2 = P_Right-&gt;X;
2795 
2796           if ( x1 &gt; x2 )
2797           {
2798             xs = x1;
2799             x1 = x2;
2800             x2 = xs;
2801           }
2802 
2803           e1 = FLOOR( x1 );
2804           e2 = CEILING( x2 );
2805 
2806           if ( x2 - x1 &lt;= ras.precision &amp;&amp;
2807                e1 != x1 &amp;&amp; e2 != x2     )
2808           {
2809             if ( e1 &gt; e2 || e2 == e1 + ras.precision )
2810             {
2811               Int  dropOutControl = P_Left-&gt;flags &amp; 7;
</pre>
<hr />
<pre>
2872         if ( P-&gt;height == 0 )
2873           DelOld( &amp;draw_right, P );
2874         P = Q;
2875       }
2876     }
2877 
2878     /* for gray-scaling, flush the bitmap scanline cache */
2879     while ( y &lt;= max_Y )
2880     {
2881       ras.Proc_Sweep_Step( RAS_VAR );
2882       y++;
2883     }
2884 
2885     return SUCCESS;
2886 
2887   Scan_DropOuts:
2888 
2889     P_Left  = draw_left;
2890     P_Right = draw_right;
2891 
<span class="line-modified">2892     while ( P_Left &amp;&amp; P_Right )</span>
2893     {
2894       if ( P_Left-&gt;countL )
2895       {
2896         P_Left-&gt;countL = 0;
2897 #if 0
2898         dropouts--;  /* -- this is useful when debugging only */
2899 #endif
2900         ras.Proc_Sweep_Drop( RAS_VARS y,
2901                                       P_Left-&gt;X,
2902                                       P_Right-&gt;X,
2903                                       P_Left,
2904                                       P_Right );
2905       }
2906 
2907       P_Left  = P_Left-&gt;link;
2908       P_Right = P_Right-&gt;link;
2909     }
2910 
2911     goto Next_Line;
2912   }
2913 
2914 
<span class="line-modified">2915 #ifdef STANDALONE_</span>
<span class="line-modified">2916 </span>
<span class="line-modified">2917   /**************************************************************************</span>
<span class="line-modified">2918    *</span>
<span class="line-modified">2919    * The following functions should only compile in stand-alone mode,</span>
<span class="line-modified">2920    * i.e., when building this component without the rest of FreeType.</span>
<span class="line-modified">2921    *</span>
<span class="line-modified">2922    */</span>
<span class="line-modified">2923 </span>
<span class="line-modified">2924   /**************************************************************************</span>
<span class="line-modified">2925    *</span>
<span class="line-modified">2926    * @Function:</span>
<span class="line-modified">2927    *   FT_Outline_Get_CBox</span>
<span class="line-modified">2928    *</span>
<span class="line-added">2929    * @Description:</span>
<span class="line-added">2930    *   Return an outline&#39;s `control box&#39;.  The control box encloses all</span>
<span class="line-added">2931    *   the outline&#39;s points, including Bzier control points.  Though it</span>
<span class="line-added">2932    *   coincides with the exact bounding box for most glyphs, it can be</span>
<span class="line-added">2933    *   slightly larger in some situations (like when rotating an outline</span>
<span class="line-added">2934    *   that contains Bzier outside arcs).</span>
<span class="line-added">2935    *</span>
<span class="line-added">2936    *   Computing the control box is very fast, while getting the bounding</span>
<span class="line-added">2937    *   box can take much more time as it needs to walk over all segments</span>
<span class="line-added">2938    *   and arcs in the outline.  To get the latter, you can use the</span>
<span class="line-added">2939    *   `ftbbox&#39; component, which is dedicated to this single task.</span>
<span class="line-added">2940    *</span>
<span class="line-added">2941    * @Input:</span>
<span class="line-added">2942    *   outline ::</span>
<span class="line-added">2943    *     A pointer to the source outline descriptor.</span>
<span class="line-added">2944    *</span>
<span class="line-added">2945    * @Output:</span>
<span class="line-added">2946    *   acbox ::</span>
<span class="line-added">2947    *     The outline&#39;s control box.</span>
<span class="line-added">2948    *</span>
<span class="line-added">2949    * @Note:</span>
<span class="line-added">2950    *   See @FT_Glyph_Get_CBox for a discussion of tricky fonts.</span>
<span class="line-added">2951    */</span>
<span class="line-added">2952 </span>
<span class="line-added">2953   static void</span>
<span class="line-added">2954   FT_Outline_Get_CBox( const FT_Outline*  outline,</span>
<span class="line-added">2955                        FT_BBox           *acbox )</span>
<span class="line-added">2956   {</span>
<span class="line-added">2957     Long  xMin, yMin, xMax, yMax;</span>
<span class="line-added">2958 </span>
<span class="line-added">2959 </span>
<span class="line-added">2960     if ( outline &amp;&amp; acbox )</span>
<span class="line-added">2961     {</span>
<span class="line-added">2962       if ( outline-&gt;n_points == 0 )</span>
<span class="line-added">2963       {</span>
<span class="line-added">2964         xMin = 0;</span>
<span class="line-added">2965         yMin = 0;</span>
<span class="line-added">2966         xMax = 0;</span>
<span class="line-added">2967         yMax = 0;</span>
<span class="line-added">2968       }</span>
<span class="line-added">2969       else</span>
<span class="line-added">2970       {</span>
<span class="line-added">2971         FT_Vector*  vec   = outline-&gt;points;</span>
<span class="line-added">2972         FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="line-added">2973 </span>
<span class="line-added">2974 </span>
<span class="line-added">2975         xMin = xMax = vec-&gt;x;</span>
<span class="line-added">2976         yMin = yMax = vec-&gt;y;</span>
<span class="line-added">2977         vec++;</span>
<span class="line-added">2978 </span>
<span class="line-added">2979         for ( ; vec &lt; limit; vec++ )</span>
<span class="line-added">2980         {</span>
<span class="line-added">2981           Long  x, y;</span>
<span class="line-added">2982 </span>
<span class="line-added">2983 </span>
<span class="line-added">2984           x = vec-&gt;x;</span>
<span class="line-added">2985           if ( x &lt; xMin ) xMin = x;</span>
<span class="line-added">2986           if ( x &gt; xMax ) xMax = x;</span>
<span class="line-added">2987 </span>
<span class="line-added">2988           y = vec-&gt;y;</span>
<span class="line-added">2989           if ( y &lt; yMin ) yMin = y;</span>
<span class="line-added">2990           if ( y &gt; yMax ) yMax = y;</span>
<span class="line-added">2991         }</span>
<span class="line-added">2992       }</span>
<span class="line-added">2993       acbox-&gt;xMin = xMin;</span>
<span class="line-added">2994       acbox-&gt;xMax = xMax;</span>
<span class="line-added">2995       acbox-&gt;yMin = yMin;</span>
<span class="line-added">2996       acbox-&gt;yMax = yMax;</span>
<span class="line-added">2997     }</span>
<span class="line-added">2998   }</span>
<span class="line-added">2999 </span>
<span class="line-added">3000 #endif /* STANDALONE_ */</span>
<span class="line-added">3001 </span>
<span class="line-added">3002 </span>
<span class="line-added">3003   /**************************************************************************</span>
<span class="line-added">3004    *</span>
<span class="line-added">3005    * @Function:</span>
<span class="line-added">3006    *   Render_Single_Pass</span>
<span class="line-added">3007    *</span>
<span class="line-added">3008    * @Description:</span>
<span class="line-added">3009    *   Perform one sweep with sub-banding.</span>
<span class="line-added">3010    *</span>
<span class="line-added">3011    * @Input:</span>
<span class="line-added">3012    *   flipped ::</span>
<span class="line-added">3013    *     If set, flip the direction of the outline.</span>
<span class="line-added">3014    *</span>
<span class="line-added">3015    * @Return:</span>
<span class="line-added">3016    *   Renderer error code.</span>
<span class="line-added">3017    */</span>
3018   static int
3019   Render_Single_Pass( RAS_ARGS Bool  flipped )
3020   {
3021     Short  i, j, k;
3022 
3023 
3024     while ( ras.band_top &gt;= 0 )
3025     {
3026       ras.maxY = (Long)ras.band_stack[ras.band_top].y_max * ras.precision;
3027       ras.minY = (Long)ras.band_stack[ras.band_top].y_min * ras.precision;
3028 
3029       ras.top = ras.buff;
3030 
3031       ras.error = Raster_Err_None;
3032 
3033       if ( Convert_Glyph( RAS_VARS flipped ) )
3034       {
3035         if ( ras.error != Raster_Err_Overflow )
3036           return FAILURE;
3037 
</pre>
<hr />
<pre>
3059         ras.band_stack[ras.band_top + 1].y_min = k;
3060         ras.band_stack[ras.band_top + 1].y_max = j;
3061 
3062         ras.band_stack[ras.band_top].y_max = (Short)( k - 1 );
3063 
3064         ras.band_top++;
3065       }
3066       else
3067       {
3068         if ( ras.fProfile )
3069           if ( Draw_Sweep( RAS_VAR ) )
3070              return ras.error;
3071         ras.band_top--;
3072       }
3073     }
3074 
3075     return SUCCESS;
3076   }
3077 
3078 
<span class="line-modified">3079   /**************************************************************************</span>
<span class="line-modified">3080    *</span>
<span class="line-modified">3081    * @Function:</span>
<span class="line-modified">3082    *   Render_Glyph</span>
<span class="line-modified">3083    *</span>
<span class="line-modified">3084    * @Description:</span>
<span class="line-modified">3085    *   Render a glyph in a bitmap.  Sub-banding if needed.</span>
<span class="line-modified">3086    *</span>
<span class="line-modified">3087    * @Return:</span>
<span class="line-modified">3088    *   FreeType error code.  0 means success.</span>
<span class="line-modified">3089    */</span>
3090   static FT_Error
3091   Render_Glyph( RAS_ARG )
3092   {
3093     FT_Error  error;
3094 
3095 
3096     Set_High_Precision( RAS_VARS ras.outline.flags &amp;
3097                                  FT_OUTLINE_HIGH_PRECISION );

3098 
3099     if ( ras.outline.flags &amp; FT_OUTLINE_IGNORE_DROPOUTS )
3100       ras.dropOutControl = 2;
3101     else
3102     {
3103       if ( ras.outline.flags &amp; FT_OUTLINE_SMART_DROPOUTS )
3104         ras.dropOutControl = 4;
3105       else
3106         ras.dropOutControl = 0;
3107 
3108       if ( !( ras.outline.flags &amp; FT_OUTLINE_INCLUDE_STUBS ) )
3109         ras.dropOutControl += 1;
3110     }
3111 
3112     ras.second_pass = (Bool)( !( ras.outline.flags      &amp;
3113                                  FT_OUTLINE_SINGLE_PASS ) );
3114 
3115     /* Vertical Sweep */
3116     FT_TRACE7(( &quot;Vertical pass (ftraster)\n&quot; ));
3117 
3118     ras.Proc_Sweep_Init = Vertical_Sweep_Init;
3119     ras.Proc_Sweep_Span = Vertical_Sweep_Span;
3120     ras.Proc_Sweep_Drop = Vertical_Sweep_Drop;
3121     ras.Proc_Sweep_Step = Vertical_Sweep_Step;
3122 
3123     ras.band_top            = 0;
3124     ras.band_stack[0].y_min = 0;
3125     ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );
3126 
3127     ras.bWidth  = (UShort)ras.target.width;
<span class="line-modified">3128     ras.bOrigin = (Byte*)ras.target.buffer;</span>
<span class="line-added">3129 </span>
<span class="line-added">3130     if ( ras.target.pitch &gt; 0 )</span>
<span class="line-added">3131       ras.bOrigin += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
3132 
3133     if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )
3134       return error;
3135 
3136     /* Horizontal Sweep */
3137     if ( ras.second_pass &amp;&amp; ras.dropOutControl != 2 )
3138     {
3139       FT_TRACE7(( &quot;Horizontal pass (ftraster)\n&quot; ));
3140 
3141       ras.Proc_Sweep_Init = Horizontal_Sweep_Init;
3142       ras.Proc_Sweep_Span = Horizontal_Sweep_Span;
3143       ras.Proc_Sweep_Drop = Horizontal_Sweep_Drop;
3144       ras.Proc_Sweep_Step = Horizontal_Sweep_Step;
3145 
3146       ras.band_top            = 0;
3147       ras.band_stack[0].y_min = 0;
3148       ras.band_stack[0].y_max = (Short)( ras.target.width - 1 );
3149 
3150       if ( ( error = Render_Single_Pass( RAS_VARS 1 ) ) != 0 )
3151         return error;
</pre>
<hr />
<pre>
3244   static int
3245   ft_black_set_mode( FT_Raster  raster,
3246                      ULong      mode,
3247                      void*      args )
3248   {
3249     FT_UNUSED( raster );
3250     FT_UNUSED( mode );
3251     FT_UNUSED( args );
3252 
3253     return 0;
3254   }
3255 
3256 
3257   static int
3258   ft_black_render( FT_Raster                raster,
3259                    const FT_Raster_Params*  params )
3260   {
3261     const FT_Outline*  outline    = (const FT_Outline*)params-&gt;source;
3262     const FT_Bitmap*   target_map = params-&gt;target;
3263 
<span class="line-added">3264 #ifndef FT_STATIC_RASTER</span>
3265     black_TWorker  worker[1];
<span class="line-added">3266 #endif</span>
3267 
3268     Long  buffer[FT_MAX_BLACK_POOL];
3269 
3270 
3271     if ( !raster )
3272       return FT_THROW( Not_Ini );
3273 
3274     if ( !outline )
3275       return FT_THROW( Invalid );
3276 
3277     /* return immediately if the outline is empty */
3278     if ( outline-&gt;n_points == 0 || outline-&gt;n_contours &lt;= 0 )
3279       return Raster_Err_None;
3280 
3281     if ( !outline-&gt;contours || !outline-&gt;points )
3282       return FT_THROW( Invalid );
3283 
3284     if ( outline-&gt;n_points !=
3285            outline-&gt;contours[outline-&gt;n_contours - 1] + 1 )
3286       return FT_THROW( Invalid );
3287 
3288     /* this version of the raster does not support direct rendering, sorry */
3289     if ( params-&gt;flags &amp; FT_RASTER_FLAG_DIRECT )
3290       return FT_THROW( Unsupported );
3291 
3292     if ( params-&gt;flags &amp; FT_RASTER_FLAG_AA )
3293       return FT_THROW( Unsupported );
3294 
3295     if ( !target_map )
3296       return FT_THROW( Invalid );
3297 
3298     /* nothing to do */
3299     if ( !target_map-&gt;width || !target_map-&gt;rows )
3300       return Raster_Err_None;
3301 
3302     if ( !target_map-&gt;buffer )
3303       return FT_THROW( Invalid );
3304 














3305     ras.outline = *outline;
3306     ras.target  = *target_map;
3307 
<span class="line-modified">3308     ras.buff     = buffer;</span>
<span class="line-modified">3309     ras.sizeBuff = (&amp;buffer)[1]; /* Points to right after buffer. */</span>
3310 
3311     return Render_Glyph( RAS_VAR );
3312   }
3313 
3314 
3315   FT_DEFINE_RASTER_FUNCS(
3316     ft_standard_raster,
3317 
3318     FT_GLYPH_FORMAT_OUTLINE,
3319 
3320     (FT_Raster_New_Func)     ft_black_new,       /* raster_new      */
3321     (FT_Raster_Reset_Func)   ft_black_reset,     /* raster_reset    */
3322     (FT_Raster_Set_Mode_Func)ft_black_set_mode,  /* raster_set_mode */
3323     (FT_Raster_Render_Func)  ft_black_render,    /* raster_render   */
3324     (FT_Raster_Done_Func)    ft_black_done       /* raster_done     */
3325   )
3326 
3327 
3328 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="ftmisc.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftraster.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>