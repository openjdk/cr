<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/ttload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ttload.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Load the basic TrueType tables, i.e., tables that can be either in</span>
<span class="line-modified">   6  *   TTF or OTF fonts (body).</span>
<span class="line-modified">   7  *</span>
<span class="line-modified">   8  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   9  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  10  *</span>
<span class="line-modified">  11  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  12  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  13  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  14  * this file you indicate that you have read the license and</span>
<span class="line-modified">  15  * understand and accept it fully.</span>
<span class="line-modified">  16  *</span>
<span class="line-modified">  17  */</span>
  18 
  19 
  20 #include &lt;ft2build.h&gt;
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_STREAM_H
  23 #include FT_TRUETYPE_TAGS_H
  24 #include &quot;ttload.h&quot;
  25 
  26 #include &quot;sferrors.h&quot;
  27 
  28 
<a name="2" id="anc2"></a><span class="line-modified">  29   /**************************************************************************</span>
<span class="line-modified">  30    *</span>
<span class="line-modified">  31    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  32    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  33    * messages during execution.</span>
<span class="line-modified">  34    */</span>
  35 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  36 #define FT_COMPONENT  ttload</span>
<span class="line-modified">  37 </span>
<span class="line-modified">  38 </span>
<span class="line-modified">  39   /**************************************************************************</span>
<span class="line-modified">  40    *</span>
<span class="line-modified">  41    * @Function:</span>
<span class="line-modified">  42    *   tt_face_lookup_table</span>
<span class="line-modified">  43    *</span>
<span class="line-modified">  44    * @Description:</span>
<span class="line-modified">  45    *   Looks for a TrueType table by name.</span>
<span class="line-modified">  46    *</span>
<span class="line-modified">  47    * @Input:</span>
<span class="line-modified">  48    *   face ::</span>
<span class="line-modified">  49    *     A face object handle.</span>
<span class="line-modified">  50    *</span>
<span class="line-modified">  51    *   tag ::</span>
<span class="line-modified">  52    *     The searched tag.</span>
<span class="line-modified">  53    *</span>
<span class="line-modified">  54    * @Return:</span>
<span class="line-added">  55    *   A pointer to the table directory entry.  0 if not found.</span>
<span class="line-added">  56    */</span>
  57   FT_LOCAL_DEF( TT_Table  )
  58   tt_face_lookup_table( TT_Face   face,
  59                         FT_ULong  tag  )
  60   {
  61     TT_Table  entry;
  62     TT_Table  limit;
  63 #ifdef FT_DEBUG_LEVEL_TRACE
  64     FT_Bool   zero_length = FALSE;
  65 #endif
  66 
  67 
  68     FT_TRACE4(( &quot;tt_face_lookup_table: %08p, `%c%c%c%c&#39; -- &quot;,
  69                 face,
  70                 (FT_Char)( tag &gt;&gt; 24 ),
  71                 (FT_Char)( tag &gt;&gt; 16 ),
  72                 (FT_Char)( tag &gt;&gt; 8  ),
  73                 (FT_Char)( tag       ) ));
  74 
  75     entry = face-&gt;dir_tables;
  76     limit = entry + face-&gt;num_tables;
  77 
  78     for ( ; entry &lt; limit; entry++ )
  79     {
  80       /* For compatibility with Windows, we consider    */
  81       /* zero-length tables the same as missing tables. */
  82       if ( entry-&gt;Tag == tag )
  83       {
  84         if ( entry-&gt;Length != 0 )
  85         {
  86           FT_TRACE4(( &quot;found table.\n&quot; ));
  87           return entry;
  88         }
  89 #ifdef FT_DEBUG_LEVEL_TRACE
  90         zero_length = TRUE;
  91 #endif
  92       }
  93     }
  94 
  95 #ifdef FT_DEBUG_LEVEL_TRACE
  96     if ( zero_length )
  97       FT_TRACE4(( &quot;ignoring empty table\n&quot; ));
  98     else
  99       FT_TRACE4(( &quot;could not find table\n&quot; ));
 100 #endif
 101 
 102     return NULL;
 103   }
 104 
 105 
<a name="4" id="anc4"></a><span class="line-modified"> 106   /**************************************************************************</span>
<span class="line-modified"> 107    *</span>
<span class="line-modified"> 108    * @Function:</span>
<span class="line-modified"> 109    *   tt_face_goto_table</span>
<span class="line-modified"> 110    *</span>
<span class="line-modified"> 111    * @Description:</span>
<span class="line-modified"> 112    *   Looks for a TrueType table by name, then seek a stream to it.</span>
<span class="line-modified"> 113    *</span>
<span class="line-modified"> 114    * @Input:</span>
<span class="line-modified"> 115    *   face ::</span>
<span class="line-modified"> 116    *     A face object handle.</span>
<span class="line-modified"> 117    *</span>
<span class="line-modified"> 118    *   tag ::</span>
<span class="line-modified"> 119    *     The searched tag.</span>
<span class="line-modified"> 120    *</span>
<span class="line-modified"> 121    *   stream ::</span>
<span class="line-modified"> 122    *     The stream to seek when the table is found.</span>
<span class="line-modified"> 123    *</span>
<span class="line-modified"> 124    * @Output:</span>
<span class="line-modified"> 125    *   length ::</span>
<span class="line-modified"> 126    *     The length of the table if found, undefined otherwise.</span>
<span class="line-added"> 127    *</span>
<span class="line-added"> 128    * @Return:</span>
<span class="line-added"> 129    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 130    */</span>
 131   FT_LOCAL_DEF( FT_Error )
 132   tt_face_goto_table( TT_Face    face,
 133                       FT_ULong   tag,
 134                       FT_Stream  stream,
 135                       FT_ULong*  length )
 136   {
 137     TT_Table  table;
 138     FT_Error  error;
 139 
 140 
 141     table = tt_face_lookup_table( face, tag );
 142     if ( table )
 143     {
 144       if ( length )
 145         *length = table-&gt;Length;
 146 
 147       if ( FT_STREAM_SEEK( table-&gt;Offset ) )
 148         goto Exit;
 149     }
 150     else
 151       error = FT_THROW( Table_Missing );
 152 
 153   Exit:
 154     return error;
 155   }
 156 
 157 
 158   /* Here, we                                                         */
 159   /*                                                                  */
 160   /* - check that `num_tables&#39; is valid (and adjust it if necessary); */
 161   /*   also return the number of valid table entries                  */
 162   /*                                                                  */
 163   /* - look for a `head&#39; table, check its size, and parse it to check */
 164   /*   whether its `magic&#39; field is correctly set                     */
 165   /*                                                                  */
 166   /* - errors (except errors returned by stream handling)             */
 167   /*                                                                  */
 168   /*     SFNT_Err_Unknown_File_Format:                                */
 169   /*       no table is defined in directory, it is not sfnt-wrapped   */
 170   /*       data                                                       */
 171   /*     SFNT_Err_Table_Missing:                                      */
 172   /*       table directory is valid, but essential tables             */
 173   /*       (head/bhed/SING) are missing                               */
 174   /*                                                                  */
 175   static FT_Error
 176   check_table_dir( SFNT_Header  sfnt,
 177                    FT_Stream    stream,
 178                    FT_UShort*   valid )
 179   {
 180     FT_Error   error;
 181     FT_UShort  nn, valid_entries = 0;
 182     FT_UInt    has_head = 0, has_sing = 0, has_meta = 0;
 183     FT_ULong   offset = sfnt-&gt;offset + 12;
 184 
 185     static const FT_Frame_Field  table_dir_entry_fields[] =
 186     {
 187 #undef  FT_STRUCTURE
 188 #define FT_STRUCTURE  TT_TableRec
 189 
 190       FT_FRAME_START( 16 ),
 191         FT_FRAME_ULONG( Tag ),
 192         FT_FRAME_ULONG( CheckSum ),
 193         FT_FRAME_ULONG( Offset ),
 194         FT_FRAME_ULONG( Length ),
 195       FT_FRAME_END
 196     };
 197 
 198 
 199     if ( FT_STREAM_SEEK( offset ) )
 200       goto Exit;
 201 
 202     for ( nn = 0; nn &lt; sfnt-&gt;num_tables; nn++ )
 203     {
 204       TT_TableRec  table;
 205 
 206 
 207       if ( FT_STREAM_READ_FIELDS( table_dir_entry_fields, &amp;table ) )
 208       {
 209         nn--;
 210         FT_TRACE2(( &quot;check_table_dir:&quot;
 211                     &quot; can read only %d table%s in font (instead of %d)\n&quot;,
 212                     nn, nn == 1 ? &quot;&quot; : &quot;s&quot;, sfnt-&gt;num_tables ));
 213         sfnt-&gt;num_tables = nn;
 214         break;
 215       }
 216 
 217       /* we ignore invalid tables */
 218 
 219       if ( table.Offset &gt; stream-&gt;size )
 220       {
 221         FT_TRACE2(( &quot;check_table_dir: table entry %d invalid\n&quot;, nn ));
 222         continue;
 223       }
 224       else if ( table.Length &gt; stream-&gt;size - table.Offset )
 225       {
 226         /* Some tables have such a simple structure that clipping its     */
 227         /* contents is harmless.  This also makes FreeType less sensitive */
 228         /* to invalid table lengths (which programs like Acroread seem to */
 229         /* ignore in general).                                            */
 230 
 231         if ( table.Tag == TTAG_hmtx ||
 232              table.Tag == TTAG_vmtx )
 233           valid_entries++;
 234         else
 235         {
 236           FT_TRACE2(( &quot;check_table_dir: table entry %d invalid\n&quot;, nn ));
 237           continue;
 238         }
 239       }
 240       else
 241         valid_entries++;
 242 
 243       if ( table.Tag == TTAG_head || table.Tag == TTAG_bhed )
 244       {
 245         FT_UInt32  magic;
 246 
 247 
 248 #ifndef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 249         if ( table.Tag == TTAG_head )
 250 #endif
 251           has_head = 1;
 252 
 253         /*
 254          * The table length should be 0x36, but certain font tools make it
 255          * 0x38, so we will just check that it is greater.
 256          *
 257          * Note that according to the specification, the table must be
 258          * padded to 32-bit lengths, but this doesn&#39;t apply to the value of
 259          * its `Length&#39; field!
 260          *
 261          */
 262         if ( table.Length &lt; 0x36 )
 263         {
 264           FT_TRACE2(( &quot;check_table_dir:&quot;
 265                       &quot; `head&#39; or `bhed&#39; table too small\n&quot; ));
 266           error = FT_THROW( Table_Missing );
 267           goto Exit;
 268         }
 269 
 270         if ( FT_STREAM_SEEK( table.Offset + 12 ) ||
 271              FT_READ_ULONG( magic )              )
 272           goto Exit;
 273 
 274         if ( magic != 0x5F0F3CF5UL )
 275           FT_TRACE2(( &quot;check_table_dir:&quot;
 276                       &quot; invalid magic number in `head&#39; or `bhed&#39; table\n&quot;));
 277 
 278         if ( FT_STREAM_SEEK( offset + ( nn + 1 ) * 16 ) )
 279           goto Exit;
 280       }
 281       else if ( table.Tag == TTAG_SING )
 282         has_sing = 1;
 283       else if ( table.Tag == TTAG_META )
 284         has_meta = 1;
 285     }
 286 
 287     *valid = valid_entries;
 288 
 289     if ( !valid_entries )
 290     {
 291       FT_TRACE2(( &quot;check_table_dir: no valid tables found\n&quot; ));
 292       error = FT_THROW( Unknown_File_Format );
 293       goto Exit;
 294     }
 295 
 296     /* if `sing&#39; and `meta&#39; tables are present, there is no `head&#39; table */
 297     if ( has_head || ( has_sing &amp;&amp; has_meta ) )
 298     {
 299       error = FT_Err_Ok;
 300       goto Exit;
 301     }
 302     else
 303     {
 304       FT_TRACE2(( &quot;check_table_dir:&quot; ));
 305 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 306       FT_TRACE2(( &quot; neither `head&#39;, `bhed&#39;, nor `sing&#39; table found\n&quot; ));
 307 #else
 308       FT_TRACE2(( &quot; neither `head&#39; nor `sing&#39; table found\n&quot; ));
 309 #endif
 310       error = FT_THROW( Table_Missing );
 311     }
 312 
 313   Exit:
 314     return error;
 315   }
 316 
 317 
<a name="5" id="anc5"></a><span class="line-modified"> 318   /**************************************************************************</span>
<span class="line-modified"> 319    *</span>
<span class="line-modified"> 320    * @Function:</span>
<span class="line-modified"> 321    *   tt_face_load_font_dir</span>
<span class="line-modified"> 322    *</span>
<span class="line-modified"> 323    * @Description:</span>
<span class="line-modified"> 324    *   Loads the header of a SFNT font file.</span>
<span class="line-modified"> 325    *</span>
<span class="line-modified"> 326    * @Input:</span>
<span class="line-modified"> 327    *   face ::</span>
<span class="line-modified"> 328    *     A handle to the target face object.</span>
<span class="line-modified"> 329    *</span>
<span class="line-modified"> 330    *   stream ::</span>
<span class="line-modified"> 331    *     The input stream.</span>
<span class="line-modified"> 332    *</span>
<span class="line-modified"> 333    * @Output:</span>
<span class="line-modified"> 334    *   sfnt ::</span>
<span class="line-modified"> 335    *     The SFNT header.</span>
<span class="line-modified"> 336    *</span>
<span class="line-modified"> 337    * @Return:</span>
<span class="line-modified"> 338    *   FreeType error code.  0 means success.</span>
<span class="line-modified"> 339    *</span>
<span class="line-added"> 340    * @Note:</span>
<span class="line-added"> 341    *   The stream cursor must be at the beginning of the font directory.</span>
<span class="line-added"> 342    */</span>
 343   FT_LOCAL_DEF( FT_Error )
 344   tt_face_load_font_dir( TT_Face    face,
 345                          FT_Stream  stream )
 346   {
 347     SFNT_HeaderRec  sfnt;
 348     FT_Error        error;
 349     FT_Memory       memory = stream-&gt;memory;
 350     FT_UShort       nn, valid_entries = 0;
 351 
 352     static const FT_Frame_Field  offset_table_fields[] =
 353     {
 354 #undef  FT_STRUCTURE
 355 #define FT_STRUCTURE  SFNT_HeaderRec
 356 
 357       FT_FRAME_START( 8 ),
 358         FT_FRAME_USHORT( num_tables ),
 359         FT_FRAME_USHORT( search_range ),
 360         FT_FRAME_USHORT( entry_selector ),
 361         FT_FRAME_USHORT( range_shift ),
 362       FT_FRAME_END
 363     };
 364 
 365 
 366     FT_TRACE2(( &quot;tt_face_load_font_dir: %08p\n&quot;, face ));
 367 
 368     /* read the offset table */
 369 
 370     sfnt.offset = FT_STREAM_POS();
 371 
 372     if ( FT_READ_ULONG( sfnt.format_tag )                    ||
 373          FT_STREAM_READ_FIELDS( offset_table_fields, &amp;sfnt ) )
 374       goto Exit;
 375 
 376     /* many fonts don&#39;t have these fields set correctly */
 377 #if 0
 378     if ( sfnt.search_range != 1 &lt;&lt; ( sfnt.entry_selector + 4 )        ||
 379          sfnt.search_range + sfnt.range_shift != sfnt.num_tables &lt;&lt; 4 )
 380       return FT_THROW( Unknown_File_Format );
 381 #endif
 382 
 383     /* load the table directory */
 384 
 385     FT_TRACE2(( &quot;-- Number of tables: %10u\n&quot;,    sfnt.num_tables ));
 386     FT_TRACE2(( &quot;-- Format version:   0x%08lx\n&quot;, sfnt.format_tag ));
 387 
 388     if ( sfnt.format_tag != TTAG_OTTO )
 389     {
 390       /* check first */
 391       error = check_table_dir( &amp;sfnt, stream, &amp;valid_entries );
 392       if ( error )
 393       {
 394         FT_TRACE2(( &quot;tt_face_load_font_dir:&quot;
 395                     &quot; invalid table directory for TrueType\n&quot; ));
 396         goto Exit;
 397       }
 398     }
 399     else
 400       valid_entries = sfnt.num_tables;
 401 
 402     face-&gt;num_tables = valid_entries;
 403     face-&gt;format_tag = sfnt.format_tag;
 404 
 405     if ( FT_QNEW_ARRAY( face-&gt;dir_tables, face-&gt;num_tables ) )
 406       goto Exit;
 407 
 408     if ( FT_STREAM_SEEK( sfnt.offset + 12 )      ||
 409          FT_FRAME_ENTER( sfnt.num_tables * 16L ) )
 410       goto Exit;
 411 
 412     FT_TRACE2(( &quot;\n&quot;
 413                 &quot;  tag    offset    length   checksum\n&quot;
 414                 &quot;  ----------------------------------\n&quot; ));
 415 
 416     valid_entries = 0;
 417     for ( nn = 0; nn &lt; sfnt.num_tables; nn++ )
 418     {
 419       TT_TableRec  entry;
 420       FT_UShort    i;
 421       FT_Bool      duplicate;
 422 
 423 
 424       entry.Tag      = FT_GET_TAG4();
 425       entry.CheckSum = FT_GET_ULONG();
 426       entry.Offset   = FT_GET_ULONG();
 427       entry.Length   = FT_GET_ULONG();
 428 
 429       /* ignore invalid tables that can&#39;t be sanitized */
 430 
 431       if ( entry.Offset &gt; stream-&gt;size )
 432         continue;
 433       else if ( entry.Length &gt; stream-&gt;size - entry.Offset )
 434       {
 435         if ( entry.Tag == TTAG_hmtx ||
 436              entry.Tag == TTAG_vmtx )
 437         {
 438 #ifdef FT_DEBUG_LEVEL_TRACE
 439           FT_ULong  old_length = entry.Length;
 440 #endif
 441 
 442 
 443           /* make metrics table length a multiple of 4 */
 444           entry.Length = ( stream-&gt;size - entry.Offset ) &amp; ~3U;
 445 
 446           FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx&quot;
 447                       &quot; (sanitized; original length %08lx)&quot;,
 448                       (FT_Char)( entry.Tag &gt;&gt; 24 ),
 449                       (FT_Char)( entry.Tag &gt;&gt; 16 ),
 450                       (FT_Char)( entry.Tag &gt;&gt; 8  ),
 451                       (FT_Char)( entry.Tag       ),
 452                       entry.Offset,
 453                       entry.Length,
 454                       entry.CheckSum,
 455                       old_length ));
 456         }
 457         else
 458           continue;
 459       }
 460 #ifdef FT_DEBUG_LEVEL_TRACE
 461       else
 462         FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx&quot;,
 463                     (FT_Char)( entry.Tag &gt;&gt; 24 ),
 464                     (FT_Char)( entry.Tag &gt;&gt; 16 ),
 465                     (FT_Char)( entry.Tag &gt;&gt; 8  ),
 466                     (FT_Char)( entry.Tag       ),
 467                     entry.Offset,
 468                     entry.Length,
 469                     entry.CheckSum ));
 470 #endif
 471 
 472       /* ignore duplicate tables â€“ the first one wins */
 473       duplicate = 0;
 474       for ( i = 0; i &lt; valid_entries; i++ )
 475       {
 476         if ( face-&gt;dir_tables[i].Tag == entry.Tag )
 477         {
 478           duplicate = 1;
 479           break;
 480         }
 481       }
 482       if ( duplicate )
 483       {
 484         FT_TRACE2(( &quot;  (duplicate, ignored)\n&quot; ));
 485         continue;
 486       }
 487       else
 488       {
 489         FT_TRACE2(( &quot;\n&quot; ));
 490 
 491         /* we finally have a valid entry */
 492         face-&gt;dir_tables[valid_entries++] = entry;
 493       }
 494     }
 495 
 496     /* final adjustment to number of tables */
 497     face-&gt;num_tables = valid_entries;
 498 
 499     FT_FRAME_EXIT();
 500 
 501     FT_TRACE2(( &quot;table directory loaded\n\n&quot; ));
 502 
 503   Exit:
 504     return error;
 505   }
 506 
 507 
<a name="6" id="anc6"></a><span class="line-modified"> 508   /**************************************************************************</span>
<span class="line-modified"> 509    *</span>
<span class="line-modified"> 510    * @Function:</span>
<span class="line-modified"> 511    *   tt_face_load_any</span>
<span class="line-modified"> 512    *</span>
<span class="line-modified"> 513    * @Description:</span>
<span class="line-modified"> 514    *   Loads any font table into client memory.</span>
<span class="line-modified"> 515    *</span>
<span class="line-modified"> 516    * @Input:</span>
<span class="line-modified"> 517    *   face ::</span>
<span class="line-modified"> 518    *     The face object to look for.</span>
<span class="line-modified"> 519    *</span>
<span class="line-modified"> 520    *   tag ::</span>
<span class="line-modified"> 521    *     The tag of table to load.  Use the value 0 if you want</span>
<span class="line-modified"> 522    *     to access the whole font file, else set this parameter</span>
<span class="line-modified"> 523    *     to a valid TrueType table tag that you can forge with</span>
<span class="line-modified"> 524    *     the MAKE_TT_TAG macro.</span>
<span class="line-modified"> 525    *</span>
<span class="line-modified"> 526    *   offset ::</span>
<span class="line-modified"> 527    *     The starting offset in the table (or the file if</span>
<span class="line-modified"> 528    *     tag == 0).</span>
<span class="line-modified"> 529    *</span>
<span class="line-modified"> 530    *   length ::</span>
<span class="line-modified"> 531    *     The address of the decision variable:</span>
<span class="line-modified"> 532    *</span>
<span class="line-modified"> 533    *     If length == NULL:</span>
<span class="line-modified"> 534    *       Loads the whole table.  Returns an error if</span>
<span class="line-modified"> 535    *       `offset&#39; == 0!</span>
<span class="line-modified"> 536    *</span>
<span class="line-modified"> 537    *     If *length == 0:</span>
<span class="line-modified"> 538    *       Exits immediately; returning the length of the given</span>
<span class="line-modified"> 539    *       table or of the font file, depending on the value of</span>
<span class="line-modified"> 540    *       `tag&#39;.</span>
<span class="line-modified"> 541    *</span>
<span class="line-modified"> 542    *     If *length != 0:</span>
<span class="line-modified"> 543    *       Loads the next `length&#39; bytes of table or font,</span>
<span class="line-modified"> 544    *       starting at offset `offset&#39; (in table or font too).</span>
<span class="line-modified"> 545    *</span>
<span class="line-modified"> 546    * @Output:</span>
<span class="line-modified"> 547    *   buffer ::</span>
<span class="line-added"> 548    *     The address of target buffer.</span>
<span class="line-added"> 549    *</span>
<span class="line-added"> 550    * @Return:</span>
<span class="line-added"> 551    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 552    */</span>
 553   FT_LOCAL_DEF( FT_Error )
 554   tt_face_load_any( TT_Face    face,
 555                     FT_ULong   tag,
 556                     FT_Long    offset,
 557                     FT_Byte*   buffer,
 558                     FT_ULong*  length )
 559   {
 560     FT_Error   error;
 561     FT_Stream  stream;
 562     TT_Table   table;
 563     FT_ULong   size;
 564 
 565 
 566     if ( tag != 0 )
 567     {
 568       /* look for tag in font directory */
 569       table = tt_face_lookup_table( face, tag );
 570       if ( !table )
 571       {
 572         error = FT_THROW( Table_Missing );
 573         goto Exit;
 574       }
 575 
 576       offset += table-&gt;Offset;
 577       size    = table-&gt;Length;
 578     }
 579     else
 580       /* tag == 0 -- the user wants to access the font file directly */
 581       size = face-&gt;root.stream-&gt;size;
 582 
 583     if ( length &amp;&amp; *length == 0 )
 584     {
 585       *length = size;
 586 
 587       return FT_Err_Ok;
 588     }
 589 
 590     if ( length )
 591       size = *length;
 592 
 593     stream = face-&gt;root.stream;
 594     /* the `if&#39; is syntactic sugar for picky compilers */
 595     if ( FT_STREAM_READ_AT( offset, buffer, size ) )
 596       goto Exit;
 597 
 598   Exit:
 599     return error;
 600   }
 601 
 602 
<a name="7" id="anc7"></a><span class="line-modified"> 603   /**************************************************************************</span>
<span class="line-modified"> 604    *</span>
<span class="line-modified"> 605    * @Function:</span>
<span class="line-modified"> 606    *   tt_face_load_generic_header</span>
<span class="line-modified"> 607    *</span>
<span class="line-modified"> 608    * @Description:</span>
<span class="line-modified"> 609    *   Loads the TrueType table `head&#39; or `bhed&#39;.</span>
<span class="line-modified"> 610    *</span>
<span class="line-modified"> 611    * @Input:</span>
<span class="line-modified"> 612    *   face ::</span>
<span class="line-modified"> 613    *     A handle to the target face object.</span>
<span class="line-modified"> 614    *</span>
<span class="line-modified"> 615    *   stream ::</span>
<span class="line-modified"> 616    *     The input stream.</span>
<span class="line-modified"> 617    *</span>
<span class="line-modified"> 618    * @Return:</span>
<span class="line-added"> 619    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 620    */</span>
 621   static FT_Error
 622   tt_face_load_generic_header( TT_Face    face,
 623                                FT_Stream  stream,
 624                                FT_ULong   tag )
 625   {
 626     FT_Error    error;
 627     TT_Header*  header;
 628 
 629     static const FT_Frame_Field  header_fields[] =
 630     {
 631 #undef  FT_STRUCTURE
 632 #define FT_STRUCTURE  TT_Header
 633 
 634       FT_FRAME_START( 54 ),
 635         FT_FRAME_ULONG ( Table_Version ),
 636         FT_FRAME_ULONG ( Font_Revision ),
 637         FT_FRAME_LONG  ( CheckSum_Adjust ),
 638         FT_FRAME_LONG  ( Magic_Number ),
 639         FT_FRAME_USHORT( Flags ),
 640         FT_FRAME_USHORT( Units_Per_EM ),
<a name="8" id="anc8"></a><span class="line-modified"> 641         FT_FRAME_ULONG ( Created[0] ),</span>
<span class="line-modified"> 642         FT_FRAME_ULONG ( Created[1] ),</span>
<span class="line-modified"> 643         FT_FRAME_ULONG ( Modified[0] ),</span>
<span class="line-modified"> 644         FT_FRAME_ULONG ( Modified[1] ),</span>
 645         FT_FRAME_SHORT ( xMin ),
 646         FT_FRAME_SHORT ( yMin ),
 647         FT_FRAME_SHORT ( xMax ),
 648         FT_FRAME_SHORT ( yMax ),
 649         FT_FRAME_USHORT( Mac_Style ),
 650         FT_FRAME_USHORT( Lowest_Rec_PPEM ),
 651         FT_FRAME_SHORT ( Font_Direction ),
 652         FT_FRAME_SHORT ( Index_To_Loc_Format ),
 653         FT_FRAME_SHORT ( Glyph_Data_Format ),
 654       FT_FRAME_END
 655     };
 656 
 657 
 658     error = face-&gt;goto_table( face, tag, stream, 0 );
 659     if ( error )
 660       goto Exit;
 661 
 662     header = &amp;face-&gt;header;
 663 
 664     if ( FT_STREAM_READ_FIELDS( header_fields, header ) )
 665       goto Exit;
 666 
 667     FT_TRACE3(( &quot;Units per EM: %4u\n&quot;, header-&gt;Units_Per_EM ));
 668     FT_TRACE3(( &quot;IndexToLoc:   %4d\n&quot;, header-&gt;Index_To_Loc_Format ));
 669 
 670   Exit:
 671     return error;
 672   }
 673 
 674 
 675   FT_LOCAL_DEF( FT_Error )
 676   tt_face_load_head( TT_Face    face,
 677                      FT_Stream  stream )
 678   {
 679     return tt_face_load_generic_header( face, stream, TTAG_head );
 680   }
 681 
 682 
 683 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 684 
 685   FT_LOCAL_DEF( FT_Error )
 686   tt_face_load_bhed( TT_Face    face,
 687                      FT_Stream  stream )
 688   {
 689     return tt_face_load_generic_header( face, stream, TTAG_bhed );
 690   }
 691 
 692 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 693 
 694 
<a name="9" id="anc9"></a><span class="line-modified"> 695   /**************************************************************************</span>
<span class="line-modified"> 696    *</span>
<span class="line-modified"> 697    * @Function:</span>
<span class="line-modified"> 698    *   tt_face_load_maxp</span>
<span class="line-modified"> 699    *</span>
<span class="line-modified"> 700    * @Description:</span>
<span class="line-modified"> 701    *   Loads the maximum profile into a face object.</span>
<span class="line-modified"> 702    *</span>
<span class="line-modified"> 703    * @Input:</span>
<span class="line-modified"> 704    *   face ::</span>
<span class="line-modified"> 705    *     A handle to the target face object.</span>
<span class="line-modified"> 706    *</span>
<span class="line-modified"> 707    *   stream ::</span>
<span class="line-modified"> 708    *     The input stream.</span>
<span class="line-modified"> 709    *</span>
<span class="line-modified"> 710    * @Return:</span>
<span class="line-added"> 711    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 712    */</span>
 713   FT_LOCAL_DEF( FT_Error )
 714   tt_face_load_maxp( TT_Face    face,
 715                      FT_Stream  stream )
 716   {
 717     FT_Error        error;
 718     TT_MaxProfile*  maxProfile = &amp;face-&gt;max_profile;
 719 
 720     static const FT_Frame_Field  maxp_fields[] =
 721     {
 722 #undef  FT_STRUCTURE
 723 #define FT_STRUCTURE  TT_MaxProfile
 724 
 725       FT_FRAME_START( 6 ),
 726         FT_FRAME_LONG  ( version ),
 727         FT_FRAME_USHORT( numGlyphs ),
 728       FT_FRAME_END
 729     };
 730 
 731     static const FT_Frame_Field  maxp_fields_extra[] =
 732     {
 733       FT_FRAME_START( 26 ),
 734         FT_FRAME_USHORT( maxPoints ),
 735         FT_FRAME_USHORT( maxContours ),
 736         FT_FRAME_USHORT( maxCompositePoints ),
 737         FT_FRAME_USHORT( maxCompositeContours ),
 738         FT_FRAME_USHORT( maxZones ),
 739         FT_FRAME_USHORT( maxTwilightPoints ),
 740         FT_FRAME_USHORT( maxStorage ),
 741         FT_FRAME_USHORT( maxFunctionDefs ),
 742         FT_FRAME_USHORT( maxInstructionDefs ),
 743         FT_FRAME_USHORT( maxStackElements ),
 744         FT_FRAME_USHORT( maxSizeOfInstructions ),
 745         FT_FRAME_USHORT( maxComponentElements ),
 746         FT_FRAME_USHORT( maxComponentDepth ),
 747       FT_FRAME_END
 748     };
 749 
 750 
 751     error = face-&gt;goto_table( face, TTAG_maxp, stream, 0 );
 752     if ( error )
 753       goto Exit;
 754 
 755     if ( FT_STREAM_READ_FIELDS( maxp_fields, maxProfile ) )
 756       goto Exit;
 757 
 758     maxProfile-&gt;maxPoints             = 0;
 759     maxProfile-&gt;maxContours           = 0;
 760     maxProfile-&gt;maxCompositePoints    = 0;
 761     maxProfile-&gt;maxCompositeContours  = 0;
 762     maxProfile-&gt;maxZones              = 0;
 763     maxProfile-&gt;maxTwilightPoints     = 0;
 764     maxProfile-&gt;maxStorage            = 0;
 765     maxProfile-&gt;maxFunctionDefs       = 0;
 766     maxProfile-&gt;maxInstructionDefs    = 0;
 767     maxProfile-&gt;maxStackElements      = 0;
 768     maxProfile-&gt;maxSizeOfInstructions = 0;
 769     maxProfile-&gt;maxComponentElements  = 0;
 770     maxProfile-&gt;maxComponentDepth     = 0;
 771 
 772     if ( maxProfile-&gt;version &gt;= 0x10000L )
 773     {
 774       if ( FT_STREAM_READ_FIELDS( maxp_fields_extra, maxProfile ) )
 775         goto Exit;
 776 
 777       /* XXX: an adjustment that is necessary to load certain */
 778       /*      broken fonts like `Keystrokes MT&#39; :-(           */
 779       /*                                                      */
 780       /*   We allocate 64 function entries by default when    */
 781       /*   the maxFunctionDefs value is smaller.              */
 782 
 783       if ( maxProfile-&gt;maxFunctionDefs &lt; 64 )
 784         maxProfile-&gt;maxFunctionDefs = 64;
 785 
 786       /* we add 4 phantom points later */
 787       if ( maxProfile-&gt;maxTwilightPoints &gt; ( 0xFFFFU - 4 ) )
 788       {
 789         FT_TRACE0(( &quot;tt_face_load_maxp:&quot;
 790                     &quot; too much twilight points in `maxp&#39; table;\n&quot;
 791                     &quot;                  &quot;
 792                     &quot; some glyphs might be rendered incorrectly\n&quot; ));
 793 
 794         maxProfile-&gt;maxTwilightPoints = 0xFFFFU - 4;
 795       }
 796     }
 797 
 798     FT_TRACE3(( &quot;numGlyphs: %u\n&quot;, maxProfile-&gt;numGlyphs ));
 799 
 800   Exit:
 801     return error;
 802   }
 803 
 804 
<a name="10" id="anc10"></a><span class="line-modified"> 805   /**************************************************************************</span>
<span class="line-modified"> 806    *</span>
<span class="line-modified"> 807    * @Function:</span>
<span class="line-modified"> 808    *   tt_face_load_name</span>
<span class="line-modified"> 809    *</span>
<span class="line-modified"> 810    * @Description:</span>
<span class="line-modified"> 811    *   Loads the name records.</span>
<span class="line-modified"> 812    *</span>
<span class="line-modified"> 813    * @Input:</span>
<span class="line-modified"> 814    *   face ::</span>
<span class="line-modified"> 815    *     A handle to the target face object.</span>
<span class="line-modified"> 816    *</span>
<span class="line-modified"> 817    *   stream ::</span>
<span class="line-modified"> 818    *     The input stream.</span>
<span class="line-modified"> 819    *</span>
<span class="line-modified"> 820    * @Return:</span>
<span class="line-added"> 821    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 822    */</span>
 823   FT_LOCAL_DEF( FT_Error )
 824   tt_face_load_name( TT_Face    face,
 825                      FT_Stream  stream )
 826   {
 827     FT_Error      error;
 828     FT_Memory     memory = stream-&gt;memory;
 829     FT_ULong      table_pos, table_len;
 830     FT_ULong      storage_start, storage_limit;
 831     TT_NameTable  table;
 832 
 833     static const FT_Frame_Field  name_table_fields[] =
 834     {
 835 #undef  FT_STRUCTURE
 836 #define FT_STRUCTURE  TT_NameTableRec
 837 
 838       FT_FRAME_START( 6 ),
 839         FT_FRAME_USHORT( format ),
 840         FT_FRAME_USHORT( numNameRecords ),
 841         FT_FRAME_USHORT( storageOffset ),
 842       FT_FRAME_END
 843     };
 844 
 845     static const FT_Frame_Field  name_record_fields[] =
 846     {
 847 #undef  FT_STRUCTURE
 848 #define FT_STRUCTURE  TT_NameRec
 849 
 850       /* no FT_FRAME_START */
 851         FT_FRAME_USHORT( platformID ),
 852         FT_FRAME_USHORT( encodingID ),
 853         FT_FRAME_USHORT( languageID ),
 854         FT_FRAME_USHORT( nameID ),
 855         FT_FRAME_USHORT( stringLength ),
 856         FT_FRAME_USHORT( stringOffset ),
 857       FT_FRAME_END
 858     };
 859 
 860     static const FT_Frame_Field  langTag_record_fields[] =
 861     {
 862 #undef  FT_STRUCTURE
 863 #define FT_STRUCTURE  TT_LangTagRec
 864 
 865       /* no FT_FRAME_START */
 866         FT_FRAME_USHORT( stringLength ),
 867         FT_FRAME_USHORT( stringOffset ),
 868       FT_FRAME_END
 869     };
 870 
 871 
 872     table         = &amp;face-&gt;name_table;
 873     table-&gt;stream = stream;
 874 
 875     error = face-&gt;goto_table( face, TTAG_name, stream, &amp;table_len );
 876     if ( error )
 877       goto Exit;
 878 
 879     table_pos = FT_STREAM_POS();
 880 
 881     if ( FT_STREAM_READ_FIELDS( name_table_fields, table ) )
 882       goto Exit;
 883 
 884     /* Some popular Asian fonts have an invalid `storageOffset&#39; value (it */
 885     /* should be at least `6 + 12*numNameRecords&#39;).  However, the string  */
 886     /* offsets, computed as `storageOffset + entry-&gt;stringOffset&#39;, are    */
 887     /* valid pointers within the name table...                            */
 888     /*                                                                    */
 889     /* We thus can&#39;t check `storageOffset&#39; right now.                     */
 890     /*                                                                    */
 891     storage_start = table_pos + 6 + 12 * table-&gt;numNameRecords;
 892     storage_limit = table_pos + table_len;
 893 
 894     if ( storage_start &gt; storage_limit )
 895     {
 896       FT_ERROR(( &quot;tt_face_load_name: invalid `name&#39; table\n&quot; ));
 897       error = FT_THROW( Name_Table_Missing );
 898       goto Exit;
 899     }
 900 
 901     /* `name&#39; format 1 contains additional language tag records, */
 902     /* which we load first                                       */
 903     if ( table-&gt;format == 1 )
 904     {
 905       if ( FT_STREAM_SEEK( storage_start )            ||
 906            FT_READ_USHORT( table-&gt;numLangTagRecords ) )
 907         goto Exit;
 908 
 909       storage_start += 2 + 4 * table-&gt;numLangTagRecords;
 910 
 911       /* allocate language tag records array */
 912       if ( FT_NEW_ARRAY( table-&gt;langTags, table-&gt;numLangTagRecords ) ||
 913            FT_FRAME_ENTER( table-&gt;numLangTagRecords * 4 )            )
 914         goto Exit;
 915 
 916       /* load language tags */
 917       {
 918         TT_LangTag  entry = table-&gt;langTags;
 919         TT_LangTag  limit = entry + table-&gt;numLangTagRecords;
 920 
 921 
 922         for ( ; entry &lt; limit; entry++ )
 923         {
 924           (void)FT_STREAM_READ_FIELDS( langTag_record_fields, entry );
 925 
 926           /* check that the langTag string is within the table */
 927           entry-&gt;stringOffset += table_pos + table-&gt;storageOffset;
 928           if ( entry-&gt;stringOffset                       &lt; storage_start ||
 929                entry-&gt;stringOffset + entry-&gt;stringLength &gt; storage_limit )
 930           {
 931             /* invalid entry; ignore it */
 932             entry-&gt;stringLength = 0;
 933           }
 934         }
 935       }
 936 
 937       FT_FRAME_EXIT();
 938 
 939       (void)FT_STREAM_SEEK( table_pos + 6 );
 940     }
 941 
 942     /* allocate name records array */
 943     if ( FT_NEW_ARRAY( table-&gt;names, table-&gt;numNameRecords ) ||
 944          FT_FRAME_ENTER( table-&gt;numNameRecords * 12 )        )
 945       goto Exit;
 946 
 947     /* load name records */
 948     {
 949       TT_Name  entry = table-&gt;names;
 950       FT_UInt  count = table-&gt;numNameRecords;
 951 
 952 
 953       for ( ; count &gt; 0; count-- )
 954       {
 955         if ( FT_STREAM_READ_FIELDS( name_record_fields, entry ) )
 956           continue;
 957 
 958         /* check that the name is not empty */
 959         if ( entry-&gt;stringLength == 0 )
 960           continue;
 961 
 962         /* check that the name string is within the table */
 963         entry-&gt;stringOffset += table_pos + table-&gt;storageOffset;
 964         if ( entry-&gt;stringOffset                       &lt; storage_start ||
 965              entry-&gt;stringOffset + entry-&gt;stringLength &gt; storage_limit )
 966         {
 967           /* invalid entry; ignore it */
 968           continue;
 969         }
 970 
 971         /* assure that we have a valid language tag ID, and   */
 972         /* that the corresponding langTag entry is valid, too */
 973         if ( table-&gt;format == 1 &amp;&amp; entry-&gt;languageID &gt;= 0x8000U )
 974         {
 975           if ( entry-&gt;languageID - 0x8000U &gt;= table-&gt;numLangTagRecords    ||
 976                !table-&gt;langTags[entry-&gt;languageID - 0x8000U].stringLength )
 977           {
 978             /* invalid entry; ignore it */
 979             continue;
 980           }
 981         }
 982 
 983         entry++;
 984       }
 985 
 986       /* reduce array size to the actually used elements */
 987       count = (FT_UInt)( entry - table-&gt;names );
 988       (void)FT_RENEW_ARRAY( table-&gt;names,
 989                             table-&gt;numNameRecords,
 990                             count );
 991       table-&gt;numNameRecords = count;
 992     }
 993 
 994     FT_FRAME_EXIT();
 995 
 996     /* everything went well, update face-&gt;num_names */
 997     face-&gt;num_names = (FT_UShort)table-&gt;numNameRecords;
 998 
 999   Exit:
1000     return error;
1001   }
1002 
1003 
<a name="11" id="anc11"></a><span class="line-modified">1004   /**************************************************************************</span>
<span class="line-modified">1005    *</span>
<span class="line-modified">1006    * @Function:</span>
<span class="line-modified">1007    *   tt_face_free_name</span>
<span class="line-modified">1008    *</span>
<span class="line-modified">1009    * @Description:</span>
<span class="line-modified">1010    *   Frees the name records.</span>
<span class="line-modified">1011    *</span>
<span class="line-modified">1012    * @Input:</span>
<span class="line-modified">1013    *   face ::</span>
<span class="line-modified">1014    *     A handle to the target face object.</span>
<span class="line-added">1015    */</span>
1016   FT_LOCAL_DEF( void )
1017   tt_face_free_name( TT_Face  face )
1018   {
1019     FT_Memory     memory = face-&gt;root.driver-&gt;root.memory;
1020     TT_NameTable  table  = &amp;face-&gt;name_table;
1021 
1022 
1023     if ( table-&gt;names )
1024     {
1025       TT_Name  entry = table-&gt;names;
1026       TT_Name  limit = entry + table-&gt;numNameRecords;
1027 
1028 
1029       for ( ; entry &lt; limit; entry++ )
1030         FT_FREE( entry-&gt;string );
1031 
1032       FT_FREE( table-&gt;names );
1033     }
1034 
1035     if ( table-&gt;langTags )
1036     {
1037       TT_LangTag  entry = table-&gt;langTags;
1038       TT_LangTag  limit = entry + table-&gt;numLangTagRecords;
1039 
1040 
1041       for ( ; entry &lt; limit; entry++ )
1042         FT_FREE( entry-&gt;string );
1043 
1044       FT_FREE( table-&gt;langTags );
1045     }
1046 
1047     table-&gt;numNameRecords    = 0;
1048     table-&gt;numLangTagRecords = 0;
1049     table-&gt;format            = 0;
1050     table-&gt;storageOffset     = 0;
1051   }
1052 
1053 
<a name="12" id="anc12"></a><span class="line-modified">1054   /**************************************************************************</span>
<span class="line-modified">1055    *</span>
<span class="line-modified">1056    * @Function:</span>
<span class="line-modified">1057    *   tt_face_load_cmap</span>
<span class="line-modified">1058    *</span>
<span class="line-modified">1059    * @Description:</span>
<span class="line-modified">1060    *   Loads the cmap directory in a face object.  The cmaps themselves</span>
<span class="line-modified">1061    *   are loaded on demand in the `ttcmap.c&#39; module.</span>
<span class="line-modified">1062    *</span>
<span class="line-modified">1063    * @Input:</span>
<span class="line-modified">1064    *   face ::</span>
<span class="line-modified">1065    *     A handle to the target face object.</span>
<span class="line-modified">1066    *</span>
<span class="line-modified">1067    *   stream ::</span>
<span class="line-modified">1068    *     A handle to the input stream.</span>
<span class="line-modified">1069    *</span>
<span class="line-modified">1070    * @Return:</span>
<span class="line-added">1071    *   FreeType error code.  0 means success.</span>
<span class="line-added">1072    */</span>
1073 
1074   FT_LOCAL_DEF( FT_Error )
1075   tt_face_load_cmap( TT_Face    face,
1076                      FT_Stream  stream )
1077   {
1078     FT_Error  error;
1079 
1080 
1081     error = face-&gt;goto_table( face, TTAG_cmap, stream, &amp;face-&gt;cmap_size );
1082     if ( error )
1083       goto Exit;
1084 
1085     if ( FT_FRAME_EXTRACT( face-&gt;cmap_size, face-&gt;cmap_table ) )
1086       face-&gt;cmap_size = 0;
1087 
1088   Exit:
1089     return error;
1090   }
1091 
1092 
1093 
<a name="13" id="anc13"></a><span class="line-modified">1094   /**************************************************************************</span>
<span class="line-modified">1095    *</span>
<span class="line-modified">1096    * @Function:</span>
<span class="line-modified">1097    *   tt_face_load_os2</span>
<span class="line-modified">1098    *</span>
<span class="line-modified">1099    * @Description:</span>
<span class="line-modified">1100    *   Loads the OS2 table.</span>
<span class="line-modified">1101    *</span>
<span class="line-modified">1102    * @Input:</span>
<span class="line-modified">1103    *   face ::</span>
<span class="line-modified">1104    *     A handle to the target face object.</span>
<span class="line-modified">1105    *</span>
<span class="line-modified">1106    *   stream ::</span>
<span class="line-modified">1107    *     A handle to the input stream.</span>
<span class="line-modified">1108    *</span>
<span class="line-modified">1109    * @Return:</span>
<span class="line-added">1110    *   FreeType error code.  0 means success.</span>
<span class="line-added">1111    */</span>
1112   FT_LOCAL_DEF( FT_Error )
1113   tt_face_load_os2( TT_Face    face,
1114                     FT_Stream  stream )
1115   {
1116     FT_Error  error;
1117     TT_OS2*   os2;
1118 
1119     static const FT_Frame_Field  os2_fields[] =
1120     {
1121 #undef  FT_STRUCTURE
1122 #define FT_STRUCTURE  TT_OS2
1123 
1124       FT_FRAME_START( 78 ),
1125         FT_FRAME_USHORT( version ),
1126         FT_FRAME_SHORT ( xAvgCharWidth ),
1127         FT_FRAME_USHORT( usWeightClass ),
1128         FT_FRAME_USHORT( usWidthClass ),
1129         FT_FRAME_SHORT ( fsType ),
1130         FT_FRAME_SHORT ( ySubscriptXSize ),
1131         FT_FRAME_SHORT ( ySubscriptYSize ),
1132         FT_FRAME_SHORT ( ySubscriptXOffset ),
1133         FT_FRAME_SHORT ( ySubscriptYOffset ),
1134         FT_FRAME_SHORT ( ySuperscriptXSize ),
1135         FT_FRAME_SHORT ( ySuperscriptYSize ),
1136         FT_FRAME_SHORT ( ySuperscriptXOffset ),
1137         FT_FRAME_SHORT ( ySuperscriptYOffset ),
1138         FT_FRAME_SHORT ( yStrikeoutSize ),
1139         FT_FRAME_SHORT ( yStrikeoutPosition ),
1140         FT_FRAME_SHORT ( sFamilyClass ),
1141         FT_FRAME_BYTE  ( panose[0] ),
1142         FT_FRAME_BYTE  ( panose[1] ),
1143         FT_FRAME_BYTE  ( panose[2] ),
1144         FT_FRAME_BYTE  ( panose[3] ),
1145         FT_FRAME_BYTE  ( panose[4] ),
1146         FT_FRAME_BYTE  ( panose[5] ),
1147         FT_FRAME_BYTE  ( panose[6] ),
1148         FT_FRAME_BYTE  ( panose[7] ),
1149         FT_FRAME_BYTE  ( panose[8] ),
1150         FT_FRAME_BYTE  ( panose[9] ),
1151         FT_FRAME_ULONG ( ulUnicodeRange1 ),
1152         FT_FRAME_ULONG ( ulUnicodeRange2 ),
1153         FT_FRAME_ULONG ( ulUnicodeRange3 ),
1154         FT_FRAME_ULONG ( ulUnicodeRange4 ),
1155         FT_FRAME_BYTE  ( achVendID[0] ),
1156         FT_FRAME_BYTE  ( achVendID[1] ),
1157         FT_FRAME_BYTE  ( achVendID[2] ),
1158         FT_FRAME_BYTE  ( achVendID[3] ),
1159 
1160         FT_FRAME_USHORT( fsSelection ),
1161         FT_FRAME_USHORT( usFirstCharIndex ),
1162         FT_FRAME_USHORT( usLastCharIndex ),
1163         FT_FRAME_SHORT ( sTypoAscender ),
1164         FT_FRAME_SHORT ( sTypoDescender ),
1165         FT_FRAME_SHORT ( sTypoLineGap ),
1166         FT_FRAME_USHORT( usWinAscent ),
1167         FT_FRAME_USHORT( usWinDescent ),
1168       FT_FRAME_END
1169     };
1170 
1171     /* `OS/2&#39; version 1 and newer */
1172     static const FT_Frame_Field  os2_fields_extra1[] =
1173     {
1174       FT_FRAME_START( 8 ),
1175         FT_FRAME_ULONG( ulCodePageRange1 ),
1176         FT_FRAME_ULONG( ulCodePageRange2 ),
1177       FT_FRAME_END
1178     };
1179 
1180     /* `OS/2&#39; version 2 and newer */
1181     static const FT_Frame_Field  os2_fields_extra2[] =
1182     {
1183       FT_FRAME_START( 10 ),
1184         FT_FRAME_SHORT ( sxHeight ),
1185         FT_FRAME_SHORT ( sCapHeight ),
1186         FT_FRAME_USHORT( usDefaultChar ),
1187         FT_FRAME_USHORT( usBreakChar ),
1188         FT_FRAME_USHORT( usMaxContext ),
1189       FT_FRAME_END
1190     };
1191 
1192     /* `OS/2&#39; version 5 and newer */
1193     static const FT_Frame_Field  os2_fields_extra5[] =
1194     {
1195       FT_FRAME_START( 4 ),
1196         FT_FRAME_USHORT( usLowerOpticalPointSize ),
1197         FT_FRAME_USHORT( usUpperOpticalPointSize ),
1198       FT_FRAME_END
1199     };
1200 
1201 
1202     /* We now support old Mac fonts where the OS/2 table doesn&#39;t  */
1203     /* exist.  Simply put, we set the `version&#39; field to 0xFFFF   */
1204     /* and test this value each time we need to access the table. */
1205     error = face-&gt;goto_table( face, TTAG_OS2, stream, 0 );
1206     if ( error )
1207       goto Exit;
1208 
1209     os2 = &amp;face-&gt;os2;
1210 
1211     if ( FT_STREAM_READ_FIELDS( os2_fields, os2 ) )
1212       goto Exit;
1213 
1214     os2-&gt;ulCodePageRange1        = 0;
1215     os2-&gt;ulCodePageRange2        = 0;
1216     os2-&gt;sxHeight                = 0;
1217     os2-&gt;sCapHeight              = 0;
1218     os2-&gt;usDefaultChar           = 0;
1219     os2-&gt;usBreakChar             = 0;
1220     os2-&gt;usMaxContext            = 0;
1221     os2-&gt;usLowerOpticalPointSize = 0;
1222     os2-&gt;usUpperOpticalPointSize = 0xFFFF;
1223 
1224     if ( os2-&gt;version &gt;= 0x0001 )
1225     {
1226       /* only version 1 tables */
1227       if ( FT_STREAM_READ_FIELDS( os2_fields_extra1, os2 ) )
1228         goto Exit;
1229 
1230       if ( os2-&gt;version &gt;= 0x0002 )
1231       {
1232         /* only version 2 tables */
1233         if ( FT_STREAM_READ_FIELDS( os2_fields_extra2, os2 ) )
1234           goto Exit;
1235 
1236         if ( os2-&gt;version &gt;= 0x0005 )
1237         {
1238           /* only version 5 tables */
1239           if ( FT_STREAM_READ_FIELDS( os2_fields_extra5, os2 ) )
1240             goto Exit;
1241         }
1242       }
1243     }
1244 
1245     FT_TRACE3(( &quot;sTypoAscender:  %4d\n&quot;,   os2-&gt;sTypoAscender ));
1246     FT_TRACE3(( &quot;sTypoDescender: %4d\n&quot;,   os2-&gt;sTypoDescender ));
1247     FT_TRACE3(( &quot;usWinAscent:    %4u\n&quot;,   os2-&gt;usWinAscent ));
1248     FT_TRACE3(( &quot;usWinDescent:   %4u\n&quot;,   os2-&gt;usWinDescent ));
1249     FT_TRACE3(( &quot;fsSelection:    0x%2x\n&quot;, os2-&gt;fsSelection ));
1250 
1251   Exit:
1252     return error;
1253   }
1254 
1255 
<a name="14" id="anc14"></a><span class="line-modified">1256   /**************************************************************************</span>
<span class="line-modified">1257    *</span>
<span class="line-modified">1258    * @Function:</span>
<span class="line-modified">1259    *   tt_face_load_postscript</span>
<span class="line-modified">1260    *</span>
<span class="line-modified">1261    * @Description:</span>
<span class="line-modified">1262    *   Loads the Postscript table.</span>
<span class="line-modified">1263    *</span>
<span class="line-modified">1264    * @Input:</span>
<span class="line-modified">1265    *   face ::</span>
<span class="line-modified">1266    *     A handle to the target face object.</span>
<span class="line-modified">1267    *</span>
<span class="line-modified">1268    *   stream ::</span>
<span class="line-modified">1269    *     A handle to the input stream.</span>
<span class="line-modified">1270    *</span>
<span class="line-modified">1271    * @Return:</span>
<span class="line-added">1272    *   FreeType error code.  0 means success.</span>
<span class="line-added">1273    */</span>
1274   FT_LOCAL_DEF( FT_Error )
1275   tt_face_load_post( TT_Face    face,
1276                      FT_Stream  stream )
1277   {
1278     FT_Error        error;
1279     TT_Postscript*  post = &amp;face-&gt;postscript;
1280 
1281     static const FT_Frame_Field  post_fields[] =
1282     {
1283 #undef  FT_STRUCTURE
1284 #define FT_STRUCTURE  TT_Postscript
1285 
1286       FT_FRAME_START( 32 ),
1287         FT_FRAME_LONG ( FormatType ),
1288         FT_FRAME_LONG ( italicAngle ),
1289         FT_FRAME_SHORT( underlinePosition ),
1290         FT_FRAME_SHORT( underlineThickness ),
1291         FT_FRAME_ULONG( isFixedPitch ),
1292         FT_FRAME_ULONG( minMemType42 ),
1293         FT_FRAME_ULONG( maxMemType42 ),
1294         FT_FRAME_ULONG( minMemType1 ),
1295         FT_FRAME_ULONG( maxMemType1 ),
1296       FT_FRAME_END
1297     };
1298 
1299 
1300     error = face-&gt;goto_table( face, TTAG_post, stream, 0 );
1301     if ( error )
1302       return error;
1303 
1304     if ( FT_STREAM_READ_FIELDS( post_fields, post ) )
1305       return error;
1306 
1307     /* we don&#39;t load the glyph names, we do that in another */
1308     /* module (ttpost).                                     */
1309 
1310     FT_TRACE3(( &quot;FormatType:   0x%x\n&quot;, post-&gt;FormatType ));
1311     FT_TRACE3(( &quot;isFixedPitch:   %s\n&quot;, post-&gt;isFixedPitch
1312                                         ? &quot;  yes&quot; : &quot;   no&quot; ));
1313 
1314     return FT_Err_Ok;
1315   }
1316 
1317 
<a name="15" id="anc15"></a><span class="line-modified">1318   /**************************************************************************</span>
<span class="line-modified">1319    *</span>
<span class="line-modified">1320    * @Function:</span>
<span class="line-modified">1321    *   tt_face_load_pclt</span>
<span class="line-modified">1322    *</span>
<span class="line-modified">1323    * @Description:</span>
<span class="line-modified">1324    *   Loads the PCL 5 Table.</span>
<span class="line-modified">1325    *</span>
<span class="line-modified">1326    * @Input:</span>
<span class="line-modified">1327    *   face ::</span>
<span class="line-modified">1328    *     A handle to the target face object.</span>
<span class="line-modified">1329    *</span>
<span class="line-modified">1330    *   stream ::</span>
<span class="line-modified">1331    *     A handle to the input stream.</span>
<span class="line-modified">1332    *</span>
<span class="line-modified">1333    * @Return:</span>
<span class="line-added">1334    *   FreeType error code.  0 means success.</span>
<span class="line-added">1335    */</span>
1336   FT_LOCAL_DEF( FT_Error )
1337   tt_face_load_pclt( TT_Face    face,
1338                      FT_Stream  stream )
1339   {
1340     static const FT_Frame_Field  pclt_fields[] =
1341     {
1342 #undef  FT_STRUCTURE
1343 #define FT_STRUCTURE  TT_PCLT
1344 
1345       FT_FRAME_START( 54 ),
1346         FT_FRAME_ULONG ( Version ),
1347         FT_FRAME_ULONG ( FontNumber ),
1348         FT_FRAME_USHORT( Pitch ),
1349         FT_FRAME_USHORT( xHeight ),
1350         FT_FRAME_USHORT( Style ),
1351         FT_FRAME_USHORT( TypeFamily ),
1352         FT_FRAME_USHORT( CapHeight ),
1353         FT_FRAME_USHORT( SymbolSet ),
1354         FT_FRAME_BYTES ( TypeFace, 16 ),
1355         FT_FRAME_BYTES ( CharacterComplement, 8 ),
1356         FT_FRAME_BYTES ( FileName, 6 ),
1357         FT_FRAME_CHAR  ( StrokeWeight ),
1358         FT_FRAME_CHAR  ( WidthType ),
1359         FT_FRAME_BYTE  ( SerifStyle ),
1360         FT_FRAME_BYTE  ( Reserved ),
1361       FT_FRAME_END
1362     };
1363 
1364     FT_Error  error;
1365     TT_PCLT*  pclt = &amp;face-&gt;pclt;
1366 
1367 
1368     /* optional table */
1369     error = face-&gt;goto_table( face, TTAG_PCLT, stream, 0 );
1370     if ( error )
1371       goto Exit;
1372 
1373     if ( FT_STREAM_READ_FIELDS( pclt_fields, pclt ) )
1374       goto Exit;
1375 
1376   Exit:
1377     return error;
1378   }
1379 
1380 
<a name="16" id="anc16"></a><span class="line-modified">1381   /**************************************************************************</span>
<span class="line-modified">1382    *</span>
<span class="line-modified">1383    * @Function:</span>
<span class="line-modified">1384    *   tt_face_load_gasp</span>
<span class="line-modified">1385    *</span>
<span class="line-modified">1386    * @Description:</span>
<span class="line-modified">1387    *   Loads the `gasp&#39; table into a face object.</span>
<span class="line-modified">1388    *</span>
<span class="line-modified">1389    * @Input:</span>
<span class="line-modified">1390    *   face ::</span>
<span class="line-modified">1391    *     A handle to the target face object.</span>
<span class="line-modified">1392    *</span>
<span class="line-modified">1393    *   stream ::</span>
<span class="line-modified">1394    *     The input stream.</span>
<span class="line-modified">1395    *</span>
<span class="line-modified">1396    * @Return:</span>
<span class="line-added">1397    *   FreeType error code.  0 means success.</span>
<span class="line-added">1398    */</span>
1399   FT_LOCAL_DEF( FT_Error )
1400   tt_face_load_gasp( TT_Face    face,
1401                      FT_Stream  stream )
1402   {
1403     FT_Error   error;
1404     FT_Memory  memory = stream-&gt;memory;
1405 
1406     FT_UInt        j,num_ranges;
1407     TT_GaspRange   gaspranges = NULL;
1408 
1409 
1410     /* the gasp table is optional */
1411     error = face-&gt;goto_table( face, TTAG_gasp, stream, 0 );
1412     if ( error )
1413       goto Exit;
1414 
1415     if ( FT_FRAME_ENTER( 4L ) )
1416       goto Exit;
1417 
1418     face-&gt;gasp.version   = FT_GET_USHORT();
1419     face-&gt;gasp.numRanges = FT_GET_USHORT();
1420 
1421     FT_FRAME_EXIT();
1422 
1423     /* only support versions 0 and 1 of the table */
1424     if ( face-&gt;gasp.version &gt;= 2 )
1425     {
1426       face-&gt;gasp.numRanges = 0;
1427       error = FT_THROW( Invalid_Table );
1428       goto Exit;
1429     }
1430 
1431     num_ranges = face-&gt;gasp.numRanges;
1432     FT_TRACE3(( &quot;numRanges: %u\n&quot;, num_ranges ));
1433 
1434     if ( FT_QNEW_ARRAY( face-&gt;gasp.gaspRanges, num_ranges ) ||
1435          FT_FRAME_ENTER( num_ranges * 4L )                  )
1436       goto Exit;
1437 
1438     gaspranges = face-&gt;gasp.gaspRanges;
1439 
1440     for ( j = 0; j &lt; num_ranges; j++ )
1441     {
1442       gaspranges[j].maxPPEM  = FT_GET_USHORT();
1443       gaspranges[j].gaspFlag = FT_GET_USHORT();
1444 
1445       FT_TRACE3(( &quot;gaspRange %d: rangeMaxPPEM %5d, rangeGaspBehavior 0x%x\n&quot;,
1446                   j,
1447                   gaspranges[j].maxPPEM,
1448                   gaspranges[j].gaspFlag ));
1449     }
1450 
1451     FT_FRAME_EXIT();
1452 
1453   Exit:
1454     return error;
1455   }
1456 
1457 
1458 /* END */
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>