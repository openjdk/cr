<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/raster/ftraster.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftmisc.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftraster.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/raster/ftraster.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,53 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ftraster.c                                                             */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    The FreeType glyph rasterizer (body).                                */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* This file can be compiled without the rest of the FreeType engine, by */</span>
<span class="line-modified">!   /* defining the STANDALONE_ macro when compiling it.  You also need to   */</span>
<span class="line-modified">!   /* put the files `ftimage.h&#39; and `ftmisc.h&#39; into the $(incdir)           */</span>
<span class="line-modified">!   /* directory.  Typically, you should do something like                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - copy `src/raster/ftraster.c&#39; (this file) to your current directory  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - copy `include/freetype/ftimage.h&#39; and `src/raster/ftmisc.h&#39; to your */</span>
<span class="line-modified">!   /*   current directory                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - compile `ftraster&#39; with the STANDALONE_ macro defined, as in        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*     cc -c -DSTANDALONE_ ftraster.c                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The renderer can be initialized with a call to                        */</span>
<span class="line-modified">!   /* `ft_standard_raster.raster_new&#39;; a bitmap can be generated            */</span>
<span class="line-modified">!   /* with a call to `ft_standard_raster.raster_render&#39;.                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* See the comments and documentation in the file `ftimage.h&#39; for more   */</span>
<span class="line-modified">!   /* details on how the raster works.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* This is a rewrite of the FreeType 1.x scan-line converter             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
  #ifdef STANDALONE_
  
    /* The size in bytes of the render pool used by the scan-line converter  */
    /* to do all of its work.                                                */
<span class="line-new-header">--- 1,53 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ftraster.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   The FreeType glyph rasterizer (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * This file can be compiled without the rest of the FreeType engine, by</span>
<span class="line-modified">!    * defining the STANDALONE_ macro when compiling it.  You also need to</span>
<span class="line-modified">!    * put the files `ftimage.h&#39; and `ftmisc.h&#39; into the $(incdir)</span>
<span class="line-modified">!    * directory.  Typically, you should do something like</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - copy `src/raster/ftraster.c&#39; (this file) to your current directory</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - copy `include/freetype/ftimage.h&#39; and `src/raster/ftmisc.h&#39; to your</span>
<span class="line-modified">!    *   current directory</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - compile `ftraster&#39; with the STANDALONE_ macro defined, as in</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *     cc -c -DSTANDALONE_ ftraster.c</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The renderer can be initialized with a call to</span>
<span class="line-modified">!    * `ft_standard_raster.raster_new&#39;; a bitmap can be generated</span>
<span class="line-modified">!    * with a call to `ft_standard_raster.raster_render&#39;.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * See the comments and documentation in the file `ftimage.h&#39; for more</span>
<span class="line-modified">!    * details on how the raster works.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * This is a rewrite of the FreeType 1.x scan-line converter</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
  #ifdef STANDALONE_
  
    /* The size in bytes of the render pool used by the scan-line converter  */
    /* to do all of its work.                                                */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,86 ***</span>
  #else /* !STANDALONE_ */
  
  #include &lt;ft2build.h&gt;
  #include &quot;ftraster.h&quot;
  #include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */
<span class="line-modified">! </span>
<span class="line-removed">- #include &quot;rastpic.h&quot;</span>
  
  #endif /* !STANDALONE_ */
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* A simple technical note on how the raster works                       */</span>
<span class="line-modified">!   /* -----------------------------------------------                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   Converting an outline into a bitmap is achieved in several steps:   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   1 - Decomposing the outline into successive `profiles&#39;.  Each       */</span>
<span class="line-modified">!   /*       profile is simply an array of scanline intersections on a given */</span>
<span class="line-modified">!   /*       dimension.  A profile&#39;s main attributes are                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*       o its scanline position boundaries, i.e. `Ymin&#39; and `Ymax&#39;      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*       o an array of intersection coordinates for each scanline        */</span>
<span class="line-modified">!   /*         between `Ymin&#39; and `Ymax&#39;                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*       o a direction, indicating whether it was built going `up&#39; or    */</span>
<span class="line-modified">!   /*         `down&#39;, as this is very important for filling rules           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*       o its drop-out mode                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   2 - Sweeping the target map&#39;s scanlines in order to compute segment */</span>
<span class="line-modified">!   /*       `spans&#39; which are then filled.  Additionally, this pass         */</span>
<span class="line-modified">!   /*       performs drop-out control.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   The outline data is parsed during step 1 only.  The profiles are    */</span>
<span class="line-modified">!   /*   built from the bottom of the render pool, used as a stack.  The     */</span>
<span class="line-modified">!   /*   following graphics shows the profile list under construction:       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*     __________________________________________________________ _ _    */</span>
<span class="line-modified">!   /*    |         |                 |         |                 |          */</span>
<span class="line-modified">!   /*    | profile | coordinates for | profile | coordinates for |--&gt;       */</span>
<span class="line-modified">!   /*    |    1    |  profile 1      |    2    |  profile 2      |--&gt;       */</span>
<span class="line-modified">!   /*    |_________|_________________|_________|_________________|__ _ _    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    ^                                                       ^          */</span>
<span class="line-modified">!   /*    |                                                       |          */</span>
<span class="line-modified">!   /* start of render pool                                      top         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   The top of the profile stack is kept in the `top&#39; variable.         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   As you can see, a profile record is pushed on top of the render     */</span>
<span class="line-modified">!   /*   pool, which is then followed by its coordinates/intersections.  If  */</span>
<span class="line-modified">!   /*   a change of direction is detected in the outline, a new profile is  */</span>
<span class="line-modified">!   /*   generated until the end of the outline.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   Note that when all profiles have been generated, the function       */</span>
<span class="line-modified">!   /*   Finalize_Profile_Table() is used to record, for each profile, its   */</span>
<span class="line-modified">!   /*   bottom-most scanline as well as the scanline above its upmost       */</span>
<span class="line-modified">!   /*   boundary.  These positions are called `y-turns&#39; because they (sort  */</span>
<span class="line-modified">!   /*   of) correspond to local extrema.  They are stored in a sorted list  */</span>
<span class="line-modified">!   /*   built from the top of the render pool as a downwards stack:         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*      _ _ _______________________________________                      */</span>
<span class="line-modified">!   /*                            |                    |                     */</span>
<span class="line-modified">!   /*                         &lt;--| sorted list of     |                     */</span>
<span class="line-modified">!   /*                         &lt;--|  extrema scanlines |                     */</span>
<span class="line-modified">!   /*      _ _ __________________|____________________|                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*                            ^                    ^                     */</span>
<span class="line-modified">!   /*                            |                    |                     */</span>
<span class="line-modified">!   /*                         maxBuff           sizeBuff = end of pool      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   This list is later used during the sweep phase in order to          */</span>
<span class="line-modified">!   /*   optimize performance (see technical note on the sweep below).       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   Of course, the raster detects whether the two stacks collide and    */</span>
<span class="line-modified">!   /*   handles the situation properly.                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /**                                                                     **/
<span class="line-new-header">--- 63,85 ---</span>
  #else /* !STANDALONE_ */
  
  #include &lt;ft2build.h&gt;
  #include &quot;ftraster.h&quot;
  #include FT_INTERNAL_CALC_H   /* for FT_MulDiv and FT_MulDiv_No_Round */
<span class="line-modified">! #include FT_OUTLINE_H         /* for FT_Outline_Get_CBox              */</span>
  
  #endif /* !STANDALONE_ */
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * A simple technical note on how the raster works</span>
<span class="line-modified">!    * -----------------------------------------------</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Converting an outline into a bitmap is achieved in several steps:</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   1 - Decomposing the outline into successive `profiles&#39;.  Each</span>
<span class="line-modified">!    *       profile is simply an array of scanline intersections on a given</span>
<span class="line-modified">!    *       dimension.  A profile&#39;s main attributes are</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *       o its scanline position boundaries, i.e. `Ymin&#39; and `Ymax&#39;</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *       o an array of intersection coordinates for each scanline</span>
<span class="line-modified">!    *         between `Ymin&#39; and `Ymax&#39;</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *       o a direction, indicating whether it was built going `up&#39; or</span>
<span class="line-modified">!    *         `down&#39;, as this is very important for filling rules</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *       o its drop-out mode</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   2 - Sweeping the target map&#39;s scanlines in order to compute segment</span>
<span class="line-modified">!    *       `spans&#39; which are then filled.  Additionally, this pass</span>
<span class="line-modified">!    *       performs drop-out control.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   The outline data is parsed during step 1 only.  The profiles are</span>
<span class="line-modified">!    *   built from the bottom of the render pool, used as a stack.  The</span>
<span class="line-modified">!    *   following graphics shows the profile list under construction:</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *    __________________________________________________________ _ _</span>
<span class="line-modified">!    *   |         |                 |         |                 |</span>
<span class="line-modified">!    *   | profile | coordinates for | profile | coordinates for |--&gt;</span>
<span class="line-modified">!    *   |    1    |  profile 1      |    2    |  profile 2      |--&gt;</span>
<span class="line-modified">!    *   |_________|_________________|_________|_________________|__ _ _</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   ^                                                       ^</span>
<span class="line-modified">!    *   |                                                       |</span>
<span class="line-modified">!    * start of render pool                                      top</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   The top of the profile stack is kept in the `top&#39; variable.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   As you can see, a profile record is pushed on top of the render</span>
<span class="line-modified">!    *   pool, which is then followed by its coordinates/intersections.  If</span>
<span class="line-modified">!    *   a change of direction is detected in the outline, a new profile is</span>
<span class="line-modified">!    *   generated until the end of the outline.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Note that when all profiles have been generated, the function</span>
<span class="line-modified">!    *   Finalize_Profile_Table() is used to record, for each profile, its</span>
<span class="line-modified">!    *   bottom-most scanline as well as the scanline above its upmost</span>
<span class="line-modified">!    *   boundary.  These positions are called `y-turns&#39; because they (sort</span>
<span class="line-modified">!    *   of) correspond to local extrema.  They are stored in a sorted list</span>
<span class="line-modified">!    *   built from the top of the render pool as a downwards stack:</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *     _ _ _______________________________________</span>
<span class="line-modified">!    *                           |                    |</span>
<span class="line-modified">!    *                        &lt;--| sorted list of     |</span>
<span class="line-modified">!    *                        &lt;--|  extrema scanlines |</span>
<span class="line-modified">!    *     _ _ __________________|____________________|</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *                           ^                    ^</span>
<span class="line-modified">!    *                           |                    |</span>
<span class="line-modified">!    *                         maxBuff           sizeBuff = end of pool</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   This list is later used during the sweep phase in order to</span>
<span class="line-modified">!    *   optimize performance (see technical note on the sweep below).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Of course, the raster detects whether the two stacks collide and</span>
<span class="line-modified">!    *   handles the situation properly.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /**                                                                     **/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,18 ***</span>
    /**  OTHER MACROS (do not change)                                       **/
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_raster</span>
  
  
  #ifdef STANDALONE_
  
    /* Auxiliary macros for token concatenation. */
<span class="line-new-header">--- 160,18 ---</span>
    /**  OTHER MACROS (do not change)                                       **/
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  raster</span>
  
  
  #ifdef STANDALONE_
  
    /* Auxiliary macros for token concatenation. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,11 ***</span>
  
  #ifdef FT_STATIC_RASTER
  
  
  #define RAS_ARGS       /* void */
<span class="line-modified">! #define RAS_ARG        /* void */</span>
  
  #define RAS_VARS       /* void */
  #define RAS_VAR        /* void */
  
  #define FT_UNUSED_RASTER  do { } while ( 0 )
<span class="line-new-header">--- 397,11 ---</span>
  
  #ifdef FT_STATIC_RASTER
  
  
  #define RAS_ARGS       /* void */
<span class="line-modified">! #define RAS_ARG        void</span>
  
  #define RAS_VARS       /* void */
  #define RAS_VAR        /* void */
  
  #define FT_UNUSED_RASTER  do { } while ( 0 )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,13 ***</span>
  
  #define FLOOR( x )    ( (x) &amp; -ras.precision )
  #define CEILING( x )  ( ( (x) + ras.precision - 1 ) &amp; -ras.precision )
  #define TRUNC( x )    ( (Long)(x) &gt;&gt; ras.precision_bits )
  #define FRAC( x )     ( (x) &amp; ( ras.precision - 1 ) )
<span class="line-modified">! #define SCALED( x )   ( ( (x) &lt; 0 ? -( -(x) &lt;&lt; ras.scale_shift )   \</span>
<span class="line-modified">!                                   :  (  (x) &lt;&lt; ras.scale_shift ) ) \</span>
<span class="line-modified">!                         - ras.precision_half )</span>
  
  #define IS_BOTTOM_OVERSHOOT( x ) \
            (Bool)( CEILING( x ) - x &gt;= ras.precision_half )
  #define IS_TOP_OVERSHOOT( x )    \
            (Bool)( x - FLOOR( x ) &gt;= ras.precision_half )
<span class="line-new-header">--- 449,13 ---</span>
  
  #define FLOOR( x )    ( (x) &amp; -ras.precision )
  #define CEILING( x )  ( ( (x) + ras.precision - 1 ) &amp; -ras.precision )
  #define TRUNC( x )    ( (Long)(x) &gt;&gt; ras.precision_bits )
  #define FRAC( x )     ( (x) &amp; ( ras.precision - 1 ) )
<span class="line-modified">! </span>
<span class="line-modified">!   /* scale and shift grid to pixel centers */</span>
<span class="line-modified">! #define SCALED( x )   ( (x) * ras.precision_scale - ras.precision_half )</span>
  
  #define IS_BOTTOM_OVERSHOOT( x ) \
            (Bool)( CEILING( x ) - x &gt;= ras.precision_half )
  #define IS_TOP_OVERSHOOT( x )    \
            (Bool)( x - FLOOR( x ) &gt;= ras.precision_half )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,17 ***</span>
    struct  black_TWorker_
    {
      Int         precision_bits;     /* precision related variables         */
      Int         precision;
      Int         precision_half;
<span class="line-modified">!     Int         precision_shift;</span>
      Int         precision_step;
      Int         precision_jitter;
  
<span class="line-removed">-     Int         scale_shift;        /* == precision_shift   for bitmaps    */</span>
<span class="line-removed">-                                     /* == precision_shift+1 for pixmaps    */</span>
<span class="line-removed">- </span>
      PLong       buff;               /* The profiles buffer                 */
      PLong       sizeBuff;           /* Render pool size                    */
      PLong       maxBuff;            /* Profiles buffer size                */
      PLong       top;                /* Current cursor in buffer            */
  
<span class="line-new-header">--- 473,14 ---</span>
    struct  black_TWorker_
    {
      Int         precision_bits;     /* precision related variables         */
      Int         precision;
      Int         precision_half;
<span class="line-modified">!     Int         precision_scale;</span>
      Int         precision_step;
      Int         precision_jitter;
  
      PLong       buff;               /* The profiles buffer                 */
      PLong       sizeBuff;           /* Render pool size                    */
      PLong       maxBuff;            /* Profiles buffer size                */
      PLong       top;                /* Current cursor in buffer            */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,12 ***</span>
      Int         numTurns;           /* number of Y-turns in outline        */
  
      TPoint*     arc;                /* current Bezier arc pointer          */
  
      UShort      bWidth;             /* target bitmap width                 */
<span class="line-modified">!     PByte       bTarget;            /* target bitmap buffer                */</span>
<span class="line-removed">-     PByte       gTarget;            /* target pixmap buffer                */</span>
  
      Long        lastX, lastY;
      Long        minY, maxY;
  
      UShort      num_Profs;          /* current number of profiles          */
<span class="line-new-header">--- 489,11 ---</span>
      Int         numTurns;           /* number of Y-turns in outline        */
  
      TPoint*     arc;                /* current Bezier arc pointer          */
  
      UShort      bWidth;             /* target bitmap width                 */
<span class="line-modified">!     PByte       bOrigin;            /* target bitmap bottom-left origin    */</span>
  
      Long        lastX, lastY;
      Long        minY, maxY;
  
      UShort      num_Profs;          /* current number of profiles          */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,12 ***</span>
  
      FT_Bitmap   target;             /* description of target bit/pixmap    */
      FT_Outline  outline;
  
      Long        traceOfs;           /* current offset in target bitmap     */
<span class="line-removed">-     Long        traceG;             /* current offset in target pixmap     */</span>
<span class="line-removed">- </span>
      Short       traceIncr;          /* sweep&#39;s increment in target bitmap  */
  
      /* dispatch variables */
  
      Function_Sweep_Init*  Proc_Sweep_Init;
<span class="line-new-header">--- 512,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,12 ***</span>
  
    } black_TRaster, *black_PRaster;
  
  #ifdef FT_STATIC_RASTER
  
<span class="line-modified">!   static black_TWorker  cur_ras;</span>
<span class="line-removed">- #define ras  cur_ras</span>
  
  #else /* !FT_STATIC_RASTER */
  
  #define ras  (*worker)
  
<span class="line-new-header">--- 544,11 ---</span>
  
    } black_TRaster, *black_PRaster;
  
  #ifdef FT_STATIC_RASTER
  
<span class="line-modified">!   static black_TWorker  ras;</span>
  
  #else /* !FT_STATIC_RASTER */
  
  #define ras  (*worker)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,22 ***</span>
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Set_High_Precision                                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Set precision variables according to param flag.                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    High :: Set to True for high precision (typically for ppem &lt; 24),  */</span>
<span class="line-modified">!   /*            false otherwise.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Set_High_Precision( RAS_ARGS Int  High )
    {
      /*
       * `precision_step&#39; is used in `Bezier_Up&#39; to decide when to split a
<span class="line-new-header">--- 562,23 ---</span>
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Set_High_Precision</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Set precision variables according to param flag.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   High ::</span>
<span class="line-modified">!    *     Set to True for high precision (typically for ppem &lt; 24),</span>
<span class="line-modified">!    *     false otherwise.</span>
<span class="line-added">+    */</span>
    static void
    Set_High_Precision( RAS_ARGS Int  High )
    {
      /*
       * `precision_step&#39; is used in `Bezier_Up&#39; to decide when to split a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,33 ***</span>
      }
  
      FT_TRACE6(( &quot;Set_High_Precision(%s)\n&quot;, High ? &quot;true&quot; : &quot;false&quot; ));
  
      ras.precision       = 1 &lt;&lt; ras.precision_bits;
<span class="line-modified">!     ras.precision_half  = ras.precision / 2;</span>
<span class="line-modified">!     ras.precision_shift = ras.precision_bits - Pixel_Bits;</span>
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    New_Profile                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Create a new profile in the render pool.                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    aState    :: The state/orientation of the new profile.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    overshoot :: Whether the profile&#39;s unrounded start position        */</span>
<span class="line-modified">!   /*                 differs by at least a half pixel.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */</span>
<span class="line-modified">!   /*   profile.                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    New_Profile( RAS_ARGS TStates  aState,
                          Bool     overshoot )
    {
      if ( !ras.fProfile )
<span class="line-new-header">--- 616,35 ---</span>
      }
  
      FT_TRACE6(( &quot;Set_High_Precision(%s)\n&quot;, High ? &quot;true&quot; : &quot;false&quot; ));
  
      ras.precision       = 1 &lt;&lt; ras.precision_bits;
<span class="line-modified">!     ras.precision_half  = ras.precision &gt;&gt; 1;</span>
<span class="line-modified">!     ras.precision_scale = ras.precision &gt;&gt; Pixel_Bits;</span>
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   New_Profile</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Create a new profile in the render pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   aState ::</span>
<span class="line-modified">!    *     The state/orientation of the new profile.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   overshoot ::</span>
<span class="line-modified">!    *     Whether the profile&#39;s unrounded start position</span>
<span class="line-modified">!    *     differs by at least a half pixel.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *  SUCCESS on success.  FAILURE in case of overflow or of incoherent</span>
<span class="line-added">+    *  profile.</span>
<span class="line-added">+    */</span>
    static Bool
    New_Profile( RAS_ARGS TStates  aState,
                          Bool     overshoot )
    {
      if ( !ras.fProfile )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,11 ***</span>
      {
        ras.error = FT_THROW( Overflow );
        return FAILURE;
      }
  
<span class="line-removed">-     ras.cProfile-&gt;flags  = 0;</span>
      ras.cProfile-&gt;start  = 0;
      ras.cProfile-&gt;height = 0;
      ras.cProfile-&gt;offset = ras.top;
      ras.cProfile-&gt;link   = (PProfile)0;
      ras.cProfile-&gt;next   = (PProfile)0;
<span class="line-new-header">--- 658,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,25 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    End_Profile                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Finalize the current profile.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    overshoot :: Whether the profile&#39;s unrounded end position differs  */</span>
<span class="line-modified">!   /*                 by at least a half pixel.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    End_Profile( RAS_ARGS Bool  overshoot )
    {
      Long  h;
  
<span class="line-new-header">--- 698,26 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   End_Profile</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Finalize the current profile.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   overshoot ::</span>
<span class="line-modified">!    *     Whether the profile&#39;s unrounded end position differs</span>
<span class="line-modified">!    *     by at least a half pixel.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   SUCCESS on success.  FAILURE in case of overflow or incoherency.</span>
<span class="line-added">+    */</span>
    static Bool
    End_Profile( RAS_ARGS Bool  overshoot )
    {
      Long  h;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 776,25 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Insert_Y_Turn                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Insert a salient into the sorted list placed on top of the render  */</span>
<span class="line-modified">!   /*    pool.                                                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    New y scanline position.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success.  FAILURE in case of overflow.                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Insert_Y_Turn( RAS_ARGS Int  y )
    {
      PLong  y_turns;
      Int    n;
<span class="line-new-header">--- 771,25 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Insert_Y_Turn</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Insert a salient into the sorted list placed on top of the render</span>
<span class="line-modified">!    *   pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   New y scanline position.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   SUCCESS on success.  FAILURE in case of overflow.</span>
<span class="line-modified">!    */</span>
    static Bool
    Insert_Y_Turn( RAS_ARGS Int  y )
    {
      PLong  y_turns;
      Int    n;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,21 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Finalize_Profile_Table                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Adjust all links in the profiles list.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success.  FAILURE in case of overflow.                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Finalize_Profile_Table( RAS_ARG )
    {
      UShort    n;
      PProfile  p;
<span class="line-new-header">--- 827,21 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Finalize_Profile_Table</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Adjust all links in the profiles list.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   SUCCESS on success.  FAILURE in case of overflow.</span>
<span class="line-modified">!    */</span>
    static Bool
    Finalize_Profile_Table( RAS_ARG )
    {
      UShort    n;
      PProfile  p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 892,116 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Split_Conic                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */</span>
<span class="line-modified">!   /*    stack.                                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    None (subdivided Bezier is taken from the top of the stack).       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">!   /*    This routine is the `beef&#39; of this component.  It is  _the_ inner  */</span>
<span class="line-modified">!   /*    loop that should be optimized to hell to get the best performance. */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Split_Conic( TPoint*  base )
    {
      Long  a, b;
  
  
      base[4].x = base[2].x;
<span class="line-modified">!     b = base[1].x;</span>
<span class="line-modified">!     a = base[3].x = ( base[2].x + b ) / 2;</span>
<span class="line-modified">!     b = base[1].x = ( base[0].x + b ) / 2;</span>
<span class="line-modified">!     base[2].x = ( a + b ) / 2;</span>
  
      base[4].y = base[2].y;
<span class="line-modified">!     b = base[1].y;</span>
<span class="line-modified">!     a = base[3].y = ( base[2].y + b ) / 2;</span>
<span class="line-modified">!     b = base[1].y = ( base[0].y + b ) / 2;</span>
<span class="line-modified">!     base[2].y = ( a + b ) / 2;</span>
  
      /* hand optimized.  gcc doesn&#39;t seem to be too good at common      */
      /* expression substitution and instruction scheduling ;-)          */
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Split_Cubic                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */</span>
<span class="line-modified">!   /*    Bezier stack.                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">!   /*    This routine is the `beef&#39; of the component.  It is one of _the_   */</span>
<span class="line-modified">!   /*    inner loops that should be optimized like hell to get the best     */</span>
<span class="line-modified">!   /*    performance.                                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Split_Cubic( TPoint*  base )
    {
<span class="line-modified">!     Long  a, b, c, d;</span>
  
  
      base[6].x = base[3].x;
<span class="line-modified">!     c = base[1].x;</span>
<span class="line-modified">!     d = base[2].x;</span>
<span class="line-modified">!     base[1].x = a = ( base[0].x + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[5].x = b = ( base[3].x + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     c = ( c + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].x = a = ( a + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[4].x = b = ( b + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[3].x = ( a + b + 1 ) &gt;&gt; 1;</span>
  
      base[6].y = base[3].y;
<span class="line-modified">!     c = base[1].y;</span>
<span class="line-modified">!     d = base[2].y;</span>
<span class="line-modified">!     base[1].y = a = ( base[0].y + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[5].y = b = ( base[3].y + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     c = ( c + d + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].y = a = ( a + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[4].y = b = ( b + c + 1 ) &gt;&gt; 1;</span>
<span class="line-modified">!     base[3].y = ( a + b + 1 ) &gt;&gt; 1;</span>
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Line_Up                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Compute the x-coordinates of an ascending line segment and store   */</span>
<span class="line-modified">!   /*    them in the render pool.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    x1   :: The x-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    y1   :: The y-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    x2   :: The x-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    y2   :: The y-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    miny :: A lower vertical clipping bound value.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    maxy :: An upper vertical clipping bound value.                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Line_Up( RAS_ARGS Long  x1,
                      Long  y1,
                      Long  x2,
                      Long  y2,
<span class="line-new-header">--- 887,128 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Split_Conic</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Subdivide one conic Bezier into two joint sub-arcs in the Bezier</span>
<span class="line-modified">!    *   stack.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   None (subdivided Bezier is taken from the top of the stack).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Note:</span>
<span class="line-modified">!    *   This routine is the `beef&#39; of this component.  It is  _the_ inner</span>
<span class="line-modified">!    *   loop that should be optimized to hell to get the best performance.</span>
<span class="line-modified">!    */</span>
    static void
    Split_Conic( TPoint*  base )
    {
      Long  a, b;
  
  
      base[4].x = base[2].x;
<span class="line-modified">!     a = base[0].x + base[1].x;</span>
<span class="line-modified">!     b = base[1].x + base[2].x;</span>
<span class="line-modified">!     base[3].x = b &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].x = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added">+     base[1].x = a &gt;&gt; 1;</span>
  
      base[4].y = base[2].y;
<span class="line-modified">!     a = base[0].y + base[1].y;</span>
<span class="line-modified">!     b = base[1].y + base[2].y;</span>
<span class="line-modified">!     base[3].y = b &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].y = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added">+     base[1].y = a &gt;&gt; 1;</span>
  
      /* hand optimized.  gcc doesn&#39;t seem to be too good at common      */
      /* expression substitution and instruction scheduling ;-)          */
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Split_Cubic</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Subdivide a third-order Bezier arc into two joint sub-arcs in the</span>
<span class="line-modified">!    *   Bezier stack.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Note:</span>
<span class="line-modified">!    *   This routine is the `beef&#39; of the component.  It is one of _the_</span>
<span class="line-modified">!    *   inner loops that should be optimized like hell to get the best</span>
<span class="line-modified">!    *   performance.</span>
<span class="line-modified">!    */</span>
    static void
    Split_Cubic( TPoint*  base )
    {
<span class="line-modified">!     Long  a, b, c;</span>
  
  
      base[6].x = base[3].x;
<span class="line-modified">!     a = base[0].x + base[1].x;</span>
<span class="line-modified">!     b = base[1].x + base[2].x;</span>
<span class="line-modified">!     c = base[2].x + base[3].x;</span>
<span class="line-modified">!     base[5].x = c &gt;&gt; 1;</span>
<span class="line-modified">!     c += b;</span>
<span class="line-modified">!     base[4].x = c &gt;&gt; 2;</span>
<span class="line-modified">!     base[1].x = a &gt;&gt; 1;</span>
<span class="line-modified">!     a += b;</span>
<span class="line-added">+     base[2].x = a &gt;&gt; 2;</span>
<span class="line-added">+     base[3].x = ( a + c ) &gt;&gt; 3;</span>
  
      base[6].y = base[3].y;
<span class="line-modified">!     a = base[0].y + base[1].y;</span>
<span class="line-modified">!     b = base[1].y + base[2].y;</span>
<span class="line-modified">!     c = base[2].y + base[3].y;</span>
<span class="line-modified">!     base[5].y = c &gt;&gt; 1;</span>
<span class="line-modified">!     c += b;</span>
<span class="line-modified">!     base[4].y = c &gt;&gt; 2;</span>
<span class="line-modified">!     base[1].y = a &gt;&gt; 1;</span>
<span class="line-modified">!     a += b;</span>
<span class="line-added">+     base[2].y = a &gt;&gt; 2;</span>
<span class="line-added">+     base[3].y = ( a + c ) &gt;&gt; 3;</span>
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Line_Up</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Compute the x-coordinates of an ascending line segment and store</span>
<span class="line-modified">!    *   them in the render pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   x1 ::</span>
<span class="line-modified">!    *     The x-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   y1 ::</span>
<span class="line-modified">!    *     The y-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   x2 ::</span>
<span class="line-modified">!    *     The x-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   y2 ::</span>
<span class="line-modified">!    *     The y-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   miny ::</span>
<span class="line-modified">!    *     A lower vertical clipping bound value.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    *   maxy ::</span>
<span class="line-added">+    *     An upper vertical clipping bound value.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">+    */</span>
    static Bool
    Line_Up( RAS_ARGS Long  x1,
                      Long  y1,
                      Long  x2,
                      Long  y2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1112,35 ***</span>
      ras.top = top;
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Line_Down                                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Compute the x-coordinates of an descending line segment and store  */</span>
<span class="line-modified">!   /*    them in the render pool.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    x1   :: The x-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    y1   :: The y-coordinate of the segment&#39;s start point.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    x2   :: The x-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    y2   :: The y-coordinate of the segment&#39;s end point.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    miny :: A lower vertical clipping bound value.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    maxy :: An upper vertical clipping bound value.                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Line_Down( RAS_ARGS Long  x1,
                        Long  y1,
                        Long  x2,
                        Long  y2,
<span class="line-new-header">--- 1119,41 ---</span>
      ras.top = top;
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Line_Down</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Compute the x-coordinates of an descending line segment and store</span>
<span class="line-modified">!    *   them in the render pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   x1 ::</span>
<span class="line-modified">!    *     The x-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   y1 ::</span>
<span class="line-modified">!    *     The y-coordinate of the segment&#39;s start point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   x2 ::</span>
<span class="line-modified">!    *     The x-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   y2 ::</span>
<span class="line-modified">!    *     The y-coordinate of the segment&#39;s end point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   miny ::</span>
<span class="line-modified">!    *     A lower vertical clipping bound value.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    *   maxy ::</span>
<span class="line-added">+    *     An upper vertical clipping bound value.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">+    */</span>
    static Bool
    Line_Down( RAS_ARGS Long  x1,
                        Long  y1,
                        Long  x2,
                        Long  y2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1163,31 ***</span>
  
    /* A function type describing the functions used to split Bezier arcs */
    typedef void  (*TSplitter)( TPoint*  base );
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Bezier_Up                                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Compute the x-coordinates of an ascending Bezier arc and store     */</span>
<span class="line-modified">!   /*    them in the render pool.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    splitter :: The function to split Bezier arcs.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    miny     :: A lower vertical clipping bound value.                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    maxy     :: An upper vertical clipping bound value.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Bezier_Up( RAS_ARGS Int        degree,
                        TSplitter  splitter,
                        Long       miny,
                        Long       maxy )
<span class="line-new-header">--- 1176,35 ---</span>
  
    /* A function type describing the functions used to split Bezier arcs */
    typedef void  (*TSplitter)( TPoint*  base );
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Bezier_Up</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Compute the x-coordinates of an ascending Bezier arc and store</span>
<span class="line-modified">!    *   them in the render pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   degree ::</span>
<span class="line-modified">!    *     The degree of the Bezier arc (either 2 or 3).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   splitter ::</span>
<span class="line-modified">!    *     The function to split Bezier arcs.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   miny ::</span>
<span class="line-modified">!    *     A lower vertical clipping bound value.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   maxy ::</span>
<span class="line-modified">!    *     An upper vertical clipping bound value.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">+    */</span>
    static Bool
    Bezier_Up( RAS_ARGS Int        degree,
                        TSplitter  splitter,
                        Long       miny,
                        Long       maxy )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1296,31 ***</span>
      ras.arc -= degree;
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Bezier_Down                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Compute the x-coordinates of an descending Bezier arc and store    */</span>
<span class="line-modified">!   /*    them in the render pool.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    degree   :: The degree of the Bezier arc (either 2 or 3).          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    splitter :: The function to split Bezier arcs.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    miny     :: A lower vertical clipping bound value.                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    maxy     :: An upper vertical clipping bound value.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE on render pool overflow.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Bezier_Down( RAS_ARGS Int        degree,
                          TSplitter  splitter,
                          Long       miny,
                          Long       maxy )
<span class="line-new-header">--- 1313,35 ---</span>
      ras.arc -= degree;
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Bezier_Down</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Compute the x-coordinates of an descending Bezier arc and store</span>
<span class="line-modified">!    *   them in the render pool.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   degree ::</span>
<span class="line-modified">!    *     The degree of the Bezier arc (either 2 or 3).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   splitter ::</span>
<span class="line-modified">!    *     The function to split Bezier arcs.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   miny ::</span>
<span class="line-modified">!    *     A lower vertical clipping bound value.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   maxy ::</span>
<span class="line-modified">!    *     An upper vertical clipping bound value.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   SUCCESS on success, FAILURE on render pool overflow.</span>
<span class="line-added">+    */</span>
    static Bool
    Bezier_Down( RAS_ARGS Int        degree,
                          TSplitter  splitter,
                          Long       miny,
                          Long       maxy )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1345,29 ***</span>
      arc[0].y = -arc[0].y;
      return result;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Line_To                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Inject a new line segment and adjust the Profiles list.            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*   x :: The x-coordinate of the segment&#39;s end point (its start point   */</span>
<span class="line-modified">!   /*        is stored in `lastX&#39;).                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   y :: The y-coordinate of the segment&#39;s end point (its start point   */</span>
<span class="line-modified">!   /*        is stored in `lastY&#39;).                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">!   /*   profile.                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Line_To( RAS_ARGS Long  x,
                      Long  y )
    {
      /* First, detect a change of direction */
<span class="line-new-header">--- 1366,31 ---</span>
      arc[0].y = -arc[0].y;
      return result;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Line_To</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Inject a new line segment and adjust the Profiles list.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *  x ::</span>
<span class="line-modified">!    *    The x-coordinate of the segment&#39;s end point (its start point</span>
<span class="line-modified">!    *    is stored in `lastX&#39;).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  y ::</span>
<span class="line-modified">!    *    The y-coordinate of the segment&#39;s end point (its start point</span>
<span class="line-modified">!    *    is stored in `lastY&#39;).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">+    *  profile.</span>
<span class="line-added">+    */</span>
    static Bool
    Line_To( RAS_ARGS Long  x,
                      Long  y )
    {
      /* First, detect a change of direction */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1439,33 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Conic_To                                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Inject a new conic arc and adjust the profile list.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*   cx :: The x-coordinate of the arc&#39;s new control point.              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   cy :: The y-coordinate of the arc&#39;s new control point.              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   x  :: The x-coordinate of the arc&#39;s end point (its start point is   */</span>
<span class="line-modified">!   /*         stored in `lastX&#39;).                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   y  :: The y-coordinate of the arc&#39;s end point (its start point is   */</span>
<span class="line-modified">!   /*         stored in `lastY&#39;).                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">!   /*   profile.                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Conic_To( RAS_ARGS Long  cx,
                       Long  cy,
                       Long  x,
                       Long  y )
<span class="line-new-header">--- 1462,37 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Conic_To</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Inject a new conic arc and adjust the profile list.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *  cx ::</span>
<span class="line-modified">!    *    The x-coordinate of the arc&#39;s new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  cy ::</span>
<span class="line-modified">!    *    The y-coordinate of the arc&#39;s new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  x ::</span>
<span class="line-modified">!    *    The x-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">!    *    stored in `lastX&#39;).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  y ::</span>
<span class="line-modified">!    *    The y-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">!    *    stored in `lastY&#39;).</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">+    *  profile.</span>
<span class="line-added">+    */</span>
    static Bool
    Conic_To( RAS_ARGS Long  cx,
                       Long  cy,
                       Long  x,
                       Long  y )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1556,37 ***</span>
    Fail:
      return FAILURE;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Cubic_To                                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Inject a new cubic arc and adjust the profile list.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*   cx1 :: The x-coordinate of the arc&#39;s first new control point.       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   cy1 :: The y-coordinate of the arc&#39;s first new control point.       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   cx2 :: The x-coordinate of the arc&#39;s second new control point.      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   cy2 :: The y-coordinate of the arc&#39;s second new control point.      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   x   :: The x-coordinate of the arc&#39;s end point (its start point is  */</span>
<span class="line-modified">!   /*          stored in `lastX&#39;).                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   y   :: The y-coordinate of the arc&#39;s end point (its start point is  */</span>
<span class="line-modified">!   /*          stored in `lastY&#39;).                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */</span>
<span class="line-modified">!   /*   profile.                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Cubic_To( RAS_ARGS Long  cx1,
                       Long  cy1,
                       Long  cx2,
                       Long  cy2,
<span class="line-new-header">--- 1583,43 ---</span>
    Fail:
      return FAILURE;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Cubic_To</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Inject a new cubic arc and adjust the profile list.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *  cx1 ::</span>
<span class="line-modified">!    *    The x-coordinate of the arc&#39;s first new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  cy1 ::</span>
<span class="line-modified">!    *    The y-coordinate of the arc&#39;s first new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  cx2 ::</span>
<span class="line-modified">!    *    The x-coordinate of the arc&#39;s second new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  cy2 ::</span>
<span class="line-modified">!    *    The y-coordinate of the arc&#39;s second new control point.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  x ::</span>
<span class="line-modified">!    *    The x-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-modified">!    *    stored in `lastX&#39;).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *  y ::</span>
<span class="line-modified">!    *    The y-coordinate of the arc&#39;s end point (its start point is</span>
<span class="line-added">+    *    stored in `lastY&#39;).</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *  SUCCESS on success, FAILURE on render pool overflow or incorrect</span>
<span class="line-added">+    *  profile.</span>
<span class="line-added">+    */</span>
    static Bool
    Cubic_To( RAS_ARGS Long  cx1,
                       Long  cy1,
                       Long  cx2,
                       Long  cy2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1703,31 ***</span>
                           x = y;          \
                           y = swap;       \
                         } while ( 0 )
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Decompose_Curve                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Scan the outline arrays in order to emit individual segments and   */</span>
<span class="line-modified">!   /*    Beziers by calling Line_To() and Bezier_To().  It handles all      */</span>
<span class="line-modified">!   /*    weird cases, like when the first point is off the curve, or when   */</span>
<span class="line-modified">!   /*    there are simply no `on&#39; points in the contour!                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    first   :: The index of the first point in the contour.            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    last    :: The index of the last point in the contour.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    flipped :: If set, flip the direction of the curve.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE on error.                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Decompose_Curve( RAS_ARGS UShort  first,
                              UShort  last,
                              Int     flipped )
    {
<span class="line-new-header">--- 1736,34 ---</span>
                           x = y;          \
                           y = swap;       \
                         } while ( 0 )
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Decompose_Curve</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Scan the outline arrays in order to emit individual segments and</span>
<span class="line-modified">!    *   Beziers by calling Line_To() and Bezier_To().  It handles all</span>
<span class="line-modified">!    *   weird cases, like when the first point is off the curve, or when</span>
<span class="line-modified">!    *   there are simply no `on&#39; points in the contour!</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   first ::</span>
<span class="line-modified">!    *     The index of the first point in the contour.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   last ::</span>
<span class="line-modified">!    *     The index of the last point in the contour.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   flipped ::</span>
<span class="line-modified">!    *     If set, flip the direction of the curve.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   SUCCESS on success, FAILURE on error.</span>
<span class="line-added">+    */</span>
    static Bool
    Decompose_Curve( RAS_ARGS UShort  first,
                              UShort  last,
                              Int     flipped )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1932,26 ***</span>
    Fail:
      return FAILURE;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Convert_Glyph                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Convert a glyph into a series of segments and arcs and make a      */</span>
<span class="line-modified">!   /*    profiles list with them.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    flipped :: If set, flip the direction of curve.                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    SUCCESS on success, FAILURE if any error was encountered during    */</span>
<span class="line-modified">!   /*    rendering.                                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static Bool
    Convert_Glyph( RAS_ARGS Int  flipped )
    {
      Int   i;
      UInt  start;
<span class="line-new-header">--- 1968,27 ---</span>
    Fail:
      return FAILURE;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Convert_Glyph</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Convert a glyph into a series of segments and arcs and make a</span>
<span class="line-modified">!    *   profiles list with them.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   flipped ::</span>
<span class="line-modified">!    *     If set, flip the direction of curve.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   SUCCESS on success, FAILURE if any error was encountered during</span>
<span class="line-modified">!    *   rendering.</span>
<span class="line-added">+    */</span>
    static Bool
    Convert_Glyph( RAS_ARGS Int  flipped )
    {
      Int   i;
      UInt  start;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2026,29 ***</span>
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  Init_Linked                                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Initializes an empty linked list.                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Init_Linked( TProfileList*  l )
    {
      *l = NULL;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  InsNew                                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Inserts a new profile in a linked list.                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    InsNew( PProfileList  list,
            PProfile      profile )
    {
      PProfile  *old, current;
<span class="line-new-header">--- 2063,29 ---</span>
    /**                                                                     **/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Init_Linked</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Initializes an empty linked list.</span>
<span class="line-modified">!    */</span>
    static void
    Init_Linked( TProfileList*  l )
    {
      *l = NULL;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * InsNew</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Inserts a new profile in a linked list.</span>
<span class="line-modified">!    */</span>
    static void
    InsNew( PProfileList  list,
            PProfile      profile )
    {
      PProfile  *old, current;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2070,16 ***</span>
      profile-&gt;link = current;
      *old          = profile;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  DelOld                                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Removes an old profile from a linked list.                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    DelOld( PProfileList  list,
            PProfile      profile )
    {
      PProfile  *old, current;
<span class="line-new-header">--- 2107,16 ---</span>
      profile-&gt;link = current;
      *old          = profile;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * DelOld</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Removes an old profile from a linked list.</span>
<span class="line-modified">!    */</span>
    static void
    DelOld( PProfileList  list,
            PProfile      profile )
    {
      PProfile  *old, current;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2103,18 ***</span>
      /* we should never get there, unless the profile was not part of */
      /* the list.                                                     */
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  Sort                                                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */</span>
<span class="line-modified">!   /*    an algorithm which is fast in this case.  Bubble sort is enough    */</span>
<span class="line-modified">!   /*    and simple.                                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Sort( PProfileList  list )
    {
      PProfile  *old, current, next;
  
<span class="line-new-header">--- 2140,18 ---</span>
      /* we should never get there, unless the profile was not part of */
      /* the list.                                                     */
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Sort</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Sorts a trace list.  In 95%, the list is already sorted.  We need</span>
<span class="line-modified">!    *   an algorithm which is fast in this case.  Bubble sort is enough</span>
<span class="line-modified">!    *   and simple.</span>
<span class="line-modified">!    */</span>
    static void
    Sort( PProfileList  list )
    {
      PProfile  *old, current, next;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2161,18 ***</span>
        next = current-&gt;link;
      }
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  Vertical Sweep Procedure Set                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  These four routines are used during the vertical black/white sweep   */</span>
<span class="line-modified">!   /*  phase by the generic Draw_Sweep() function.                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
    static void
    Vertical_Sweep_Init( RAS_ARGS Short*  min,
                                  Short*  max )
    {
<span class="line-new-header">--- 2198,18 ---</span>
        next = current-&gt;link;
      }
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Vertical Sweep Procedure Set</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * These four routines are used during the vertical black/white sweep</span>
<span class="line-modified">!    * phase by the generic Draw_Sweep() function.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
    static void
    Vertical_Sweep_Init( RAS_ARGS Short*  min,
                                  Short*  max )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2181,12 ***</span>
      FT_UNUSED( max );
  
  
      ras.traceIncr = (Short)-pitch;
      ras.traceOfs  = -*min * pitch;
<span class="line-removed">-     if ( pitch &gt; 0 )</span>
<span class="line-removed">-       ras.traceOfs += (Long)( ras.target.rows - 1 ) * pitch;</span>
    }
  
  
    static void
    Vertical_Sweep_Span( RAS_ARGS Short       y,
<span class="line-new-header">--- 2218,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2213,17 ***</span>
                  x2 / (double)ras.precision,
                  dropOutControl ));
  
      /* Drop-out control */
  
<span class="line-modified">!     e1 = TRUNC( CEILING( x1 ) );</span>
  
      if ( dropOutControl != 2                             &amp;&amp;
<span class="line-modified">!          x2 - x1 - ras.precision &lt;= ras.precision_jitter )</span>
        e2 = e1;
<span class="line-modified">!     else</span>
<span class="line-modified">!       e2 = TRUNC( FLOOR( x2 ) );</span>
  
      if ( e2 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
      {
        Int   c1, c2;
        Byte  f1, f2;
<span class="line-new-header">--- 2248,22 ---</span>
                  x2 / (double)ras.precision,
                  dropOutControl ));
  
      /* Drop-out control */
  
<span class="line-modified">!     e1 = CEILING( x1 );</span>
<span class="line-added">+     e2 = FLOOR( x2 );</span>
  
<span class="line-added">+     /* take care of the special case where both the left */</span>
<span class="line-added">+     /* and right contour lie exactly on pixel centers    */</span>
      if ( dropOutControl != 2                             &amp;&amp;
<span class="line-modified">!          x2 - x1 - ras.precision &lt;= ras.precision_jitter &amp;&amp;</span>
<span class="line-added">+          e1 != x1 &amp;&amp; e2 != x2                            )</span>
        e2 = e1;
<span class="line-modified">! </span>
<span class="line-modified">!     e1 = TRUNC( e1 );</span>
<span class="line-added">+     e2 = TRUNC( e2 );</span>
  
      if ( e2 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth )
      {
        Int   c1, c2;
        Byte  f1, f2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2240,26 ***</span>
        c2 = (Short)( e2 &gt;&gt; 3 );
  
        f1 = (Byte)  ( 0xFF &gt;&gt; ( e1 &amp; 7 ) );
        f2 = (Byte) ~( 0x7F &gt;&gt; ( e2 &amp; 7 ) );
  
<span class="line-modified">!       target = ras.bTarget + ras.traceOfs + c1;</span>
        c2 -= c1;
  
        if ( c2 &gt; 0 )
        {
          target[0] |= f1;
  
          /* memset() is slower than the following code on many platforms. */
          /* This is due to the fact that, in the vast majority of cases,  */
          /* the span length in bytes is relatively small.                 */
<span class="line-modified">!         c2--;</span>
<span class="line-removed">-         while ( c2 &gt; 0 )</span>
<span class="line-removed">-         {</span>
            *(++target) = 0xFF;
<span class="line-modified">!           c2--;</span>
<span class="line-removed">-         }</span>
          target[1] |= f2;
        }
        else
          *target |= ( f1 &amp; f2 );
      }
<span class="line-new-header">--- 2280,23 ---</span>
        c2 = (Short)( e2 &gt;&gt; 3 );
  
        f1 = (Byte)  ( 0xFF &gt;&gt; ( e1 &amp; 7 ) );
        f2 = (Byte) ~( 0x7F &gt;&gt; ( e2 &amp; 7 ) );
  
<span class="line-modified">!       target = ras.bOrigin + ras.traceOfs + c1;</span>
        c2 -= c1;
  
        if ( c2 &gt; 0 )
        {
          target[0] |= f1;
  
          /* memset() is slower than the following code on many platforms. */
          /* This is due to the fact that, in the vast majority of cases,  */
          /* the span length in bytes is relatively small.                 */
<span class="line-modified">!         while ( --c2 &gt; 0 )</span>
            *(++target) = 0xFF;
<span class="line-modified">! </span>
          target[1] |= f2;
        }
        else
          *target |= ( f1 &amp; f2 );
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2398,11 ***</span>
  
          c1 = (Short)( e1 &gt;&gt; 3 );
          f1 = (Short)( e1 &amp;  7 );
  
          if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth                      &amp;&amp;
<span class="line-modified">!              ras.bTarget[ras.traceOfs + c1] &amp; ( 0x80 &gt;&gt; f1 ) )</span>
            goto Exit;
        }
        else
          goto Exit;
      }
<span class="line-new-header">--- 2435,11 ---</span>
  
          c1 = (Short)( e1 &gt;&gt; 3 );
          f1 = (Short)( e1 &amp;  7 );
  
          if ( e1 &gt;= 0 &amp;&amp; e1 &lt; ras.bWidth                      &amp;&amp;
<span class="line-modified">!              ras.bOrigin[ras.traceOfs + c1] &amp; ( 0x80 &gt;&gt; f1 ) )</span>
            goto Exit;
        }
        else
          goto Exit;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2414,11 ***</span>
        FT_TRACE7(( &quot; -&gt; x=%d (drop-out)&quot;, e1 ));
  
        c1 = (Short)( e1 &gt;&gt; 3 );
        f1 = (Short)( e1 &amp; 7 );
  
<span class="line-modified">!       ras.bTarget[ras.traceOfs + c1] |= (char)( 0x80 &gt;&gt; f1 );</span>
      }
  
    Exit:
      FT_TRACE7(( &quot;\n&quot; ));
    }
<span class="line-new-header">--- 2451,11 ---</span>
        FT_TRACE7(( &quot; -&gt; x=%d (drop-out)&quot;, e1 ));
  
        c1 = (Short)( e1 &gt;&gt; 3 );
        f1 = (Short)( e1 &amp; 7 );
  
<span class="line-modified">!       ras.bOrigin[ras.traceOfs + c1] |= (char)( 0x80 &gt;&gt; f1 );</span>
      }
  
    Exit:
      FT_TRACE7(( &quot;\n&quot; ));
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2429,18 ***</span>
    {
      ras.traceOfs += ras.traceIncr;
    }
  
  
<span class="line-modified">!   /***********************************************************************/</span>
<span class="line-modified">!   /*                                                                     */</span>
<span class="line-modified">!   /*  Horizontal Sweep Procedure Set                                     */</span>
<span class="line-modified">!   /*                                                                     */</span>
<span class="line-modified">!   /*  These four routines are used during the horizontal black/white     */</span>
<span class="line-modified">!   /*  sweep phase by the generic Draw_Sweep() function.                  */</span>
<span class="line-modified">!   /*                                                                     */</span>
<span class="line-modified">!   /***********************************************************************/</span>
  
    static void
    Horizontal_Sweep_Init( RAS_ARGS Short*  min,
                                    Short*  max )
    {
<span class="line-new-header">--- 2466,18 ---</span>
    {
      ras.traceOfs += ras.traceIncr;
    }
  
  
<span class="line-modified">!   /************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Horizontal Sweep Procedure Set</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * These four routines are used during the horizontal black/white</span>
<span class="line-modified">!    * sweep phase by the generic Draw_Sweep() function.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
    static void
    Horizontal_Sweep_Init( RAS_ARGS Short*  min,
                                    Short*  max )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2481,23 ***</span>
  
          if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
          {
            Byte   f1;
            PByte  bits;
<span class="line-removed">-           PByte  p;</span>
  
  
            FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
  
<span class="line-modified">!           bits = ras.bTarget + ( y &gt;&gt; 3 );</span>
            f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
<span class="line-removed">-           p    = bits - e1 * ras.target.pitch;</span>
  
<span class="line-modified">!           if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">-             p += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           p[0] |= f1;</span>
          }
        }
  
        FT_TRACE7(( &quot;\n&quot; ));
      }
<span class="line-new-header">--- 2518,18 ---</span>
  
          if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
          {
            Byte   f1;
            PByte  bits;
  
  
            FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
  
<span class="line-modified">!           bits = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
            f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
  
<span class="line-modified">!           bits[0] |= f1;</span>
          }
        }
  
        FT_TRACE7(( &quot;\n&quot; ));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2595,17 ***</span>
          /* check that the other pixel isn&#39;t set */
          e1 = ( pxl == e1 ) ? e2 : e1;
  
          e1 = TRUNC( e1 );
  
<span class="line-modified">!         bits = ras.bTarget + ( y &gt;&gt; 3 );</span>
          f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
  
<span class="line-removed">-         bits -= e1 * ras.target.pitch;</span>
<span class="line-removed">-         if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">-           bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
<span class="line-removed">- </span>
          if ( e1 &gt;= 0                     &amp;&amp;
               (ULong)e1 &lt; ras.target.rows &amp;&amp;
               *bits &amp; f1                  )
            goto Exit;
        }
<span class="line-new-header">--- 2627,13 ---</span>
          /* check that the other pixel isn&#39;t set */
          e1 = ( pxl == e1 ) ? e2 : e1;
  
          e1 = TRUNC( e1 );
  
<span class="line-modified">!         bits = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
          f1   = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
  
          if ( e1 &gt;= 0                     &amp;&amp;
               (ULong)e1 &lt; ras.target.rows &amp;&amp;
               *bits &amp; f1                  )
            goto Exit;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2617,16 ***</span>
  
      if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
      {
        FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
  
<span class="line-modified">!       bits  = ras.bTarget + ( y &gt;&gt; 3 );</span>
        f1    = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
<span class="line-removed">-       bits -= e1 * ras.target.pitch;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if ( ras.target.pitch &gt; 0 )</span>
<span class="line-removed">-         bits += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
  
        bits[0] |= f1;
      }
  
    Exit:
<span class="line-new-header">--- 2645,12 ---</span>
  
      if ( e1 &gt;= 0 &amp;&amp; (ULong)e1 &lt; ras.target.rows )
      {
        FT_TRACE7(( &quot; -&gt; y=%d (drop-out)&quot;, e1 ));
  
<span class="line-modified">!       bits  = ras.bOrigin + ( y &gt;&gt; 3 ) - e1 * ras.target.pitch;</span>
        f1    = (Byte)( 0x80 &gt;&gt; ( y &amp; 7 ) );
  
        bits[0] |= f1;
      }
  
    Exit:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2640,15 ***</span>
      /* Nothing, really */
      FT_UNUSED_RASTER;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  Generic Sweep Drawing routine                                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
    static Bool
    Draw_Sweep( RAS_ARG )
    {
      Short         y, y_change, y_height;
<span class="line-new-header">--- 2664,15 ---</span>
      /* Nothing, really */
      FT_UNUSED_RASTER;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Generic Sweep Drawing routine</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
    static Bool
    Draw_Sweep( RAS_ARG )
    {
      Short         y, y_change, y_height;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2762,11 ***</span>
          dropouts = 0;
  
          P_Left  = draw_left;
          P_Right = draw_right;
  
<span class="line-modified">!         while ( P_Left )</span>
          {
            x1 = P_Left -&gt;X;
            x2 = P_Right-&gt;X;
  
            if ( x1 &gt; x2 )
<span class="line-new-header">--- 2786,11 ---</span>
          dropouts = 0;
  
          P_Left  = draw_left;
          P_Right = draw_right;
  
<span class="line-modified">!         while ( P_Left &amp;&amp; P_Right )</span>
          {
            x1 = P_Left -&gt;X;
            x2 = P_Right-&gt;X;
  
            if ( x1 &gt; x2 )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2863,11 ***</span>
    Scan_DropOuts:
  
      P_Left  = draw_left;
      P_Right = draw_right;
  
<span class="line-modified">!     while ( P_Left )</span>
      {
        if ( P_Left-&gt;countL )
        {
          P_Left-&gt;countL = 0;
  #if 0
<span class="line-new-header">--- 2887,11 ---</span>
    Scan_DropOuts:
  
      P_Left  = draw_left;
      P_Right = draw_right;
  
<span class="line-modified">!     while ( P_Left &amp;&amp; P_Right )</span>
      {
        if ( P_Left-&gt;countL )
        {
          P_Left-&gt;countL = 0;
  #if 0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2886,24 ***</span>
  
      goto Next_Line;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Render_Single_Pass                                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Perform one sweep with sub-banding.                                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    flipped :: If set, flip the direction of the outline.              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    Renderer error code.                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static int
    Render_Single_Pass( RAS_ARGS Bool  flipped )
    {
      Short  i, j, k;
  
<span class="line-new-header">--- 2910,113 ---</span>
  
      goto Next_Line;
    }
  
  
<span class="line-modified">! #ifdef STANDALONE_</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The following functions should only compile in stand-alone mode,</span>
<span class="line-modified">!    * i.e., when building this component without the rest of FreeType.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   FT_Outline_Get_CBox</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Description:</span>
<span class="line-added">+    *   Return an outline&#39;s `control box&#39;.  The control box encloses all</span>
<span class="line-added">+    *   the outline&#39;s points, including Bzier control points.  Though it</span>
<span class="line-added">+    *   coincides with the exact bounding box for most glyphs, it can be</span>
<span class="line-added">+    *   slightly larger in some situations (like when rotating an outline</span>
<span class="line-added">+    *   that contains Bzier outside arcs).</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   Computing the control box is very fast, while getting the bounding</span>
<span class="line-added">+    *   box can take much more time as it needs to walk over all segments</span>
<span class="line-added">+    *   and arcs in the outline.  To get the latter, you can use the</span>
<span class="line-added">+    *   `ftbbox&#39; component, which is dedicated to this single task.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Input:</span>
<span class="line-added">+    *   outline ::</span>
<span class="line-added">+    *     A pointer to the source outline descriptor.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Output:</span>
<span class="line-added">+    *   acbox ::</span>
<span class="line-added">+    *     The outline&#39;s control box.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Note:</span>
<span class="line-added">+    *   See @FT_Glyph_Get_CBox for a discussion of tricky fonts.</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+   static void</span>
<span class="line-added">+   FT_Outline_Get_CBox( const FT_Outline*  outline,</span>
<span class="line-added">+                        FT_BBox           *acbox )</span>
<span class="line-added">+   {</span>
<span class="line-added">+     Long  xMin, yMin, xMax, yMax;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     if ( outline &amp;&amp; acbox )</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if ( outline-&gt;n_points == 0 )</span>
<span class="line-added">+       {</span>
<span class="line-added">+         xMin = 0;</span>
<span class="line-added">+         yMin = 0;</span>
<span class="line-added">+         xMax = 0;</span>
<span class="line-added">+         yMax = 0;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       else</span>
<span class="line-added">+       {</span>
<span class="line-added">+         FT_Vector*  vec   = outline-&gt;points;</span>
<span class="line-added">+         FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+         xMin = xMax = vec-&gt;x;</span>
<span class="line-added">+         yMin = yMax = vec-&gt;y;</span>
<span class="line-added">+         vec++;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for ( ; vec &lt; limit; vec++ )</span>
<span class="line-added">+         {</span>
<span class="line-added">+           Long  x, y;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+           x = vec-&gt;x;</span>
<span class="line-added">+           if ( x &lt; xMin ) xMin = x;</span>
<span class="line-added">+           if ( x &gt; xMax ) xMax = x;</span>
<span class="line-added">+ </span>
<span class="line-added">+           y = vec-&gt;y;</span>
<span class="line-added">+           if ( y &lt; yMin ) yMin = y;</span>
<span class="line-added">+           if ( y &gt; yMax ) yMax = y;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       acbox-&gt;xMin = xMin;</span>
<span class="line-added">+       acbox-&gt;xMax = xMax;</span>
<span class="line-added">+       acbox-&gt;yMin = yMin;</span>
<span class="line-added">+       acbox-&gt;yMax = yMax;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif /* STANDALONE_ */</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   /**************************************************************************</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Function:</span>
<span class="line-added">+    *   Render_Single_Pass</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Description:</span>
<span class="line-added">+    *   Perform one sweep with sub-banding.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Input:</span>
<span class="line-added">+    *   flipped ::</span>
<span class="line-added">+    *     If set, flip the direction of the outline.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   Renderer error code.</span>
<span class="line-added">+    */</span>
    static int
    Render_Single_Pass( RAS_ARGS Bool  flipped )
    {
      Short  i, j, k;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2961,30 ***</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Render_Glyph                                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Render a glyph in a bitmap.  Sub-banding if needed.                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    Render_Glyph( RAS_ARG )
    {
      FT_Error  error;
  
  
      Set_High_Precision( RAS_VARS ras.outline.flags &amp;
                                   FT_OUTLINE_HIGH_PRECISION );
<span class="line-removed">-     ras.scale_shift = ras.precision_shift;</span>
  
      if ( ras.outline.flags &amp; FT_OUTLINE_IGNORE_DROPOUTS )
        ras.dropOutControl = 2;
      else
      {
<span class="line-new-header">--- 3074,29 ---</span>
  
      return SUCCESS;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Render_Glyph</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Render a glyph in a bitmap.  Sub-banding if needed.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   FreeType error code.  0 means success.</span>
<span class="line-modified">!    */</span>
    static FT_Error
    Render_Glyph( RAS_ARG )
    {
      FT_Error  error;
  
  
      Set_High_Precision( RAS_VARS ras.outline.flags &amp;
                                   FT_OUTLINE_HIGH_PRECISION );
  
      if ( ras.outline.flags &amp; FT_OUTLINE_IGNORE_DROPOUTS )
        ras.dropOutControl = 2;
      else
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3011,11 ***</span>
      ras.band_top            = 0;
      ras.band_stack[0].y_min = 0;
      ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );
  
      ras.bWidth  = (UShort)ras.target.width;
<span class="line-modified">!     ras.bTarget = (Byte*)ras.target.buffer;</span>
  
      if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )
        return error;
  
      /* Horizontal Sweep */
<span class="line-new-header">--- 3123,14 ---</span>
      ras.band_top            = 0;
      ras.band_stack[0].y_min = 0;
      ras.band_stack[0].y_max = (Short)( ras.target.rows - 1 );
  
      ras.bWidth  = (UShort)ras.target.width;
<span class="line-modified">!     ras.bOrigin = (Byte*)ras.target.buffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ( ras.target.pitch &gt; 0 )</span>
<span class="line-added">+       ras.bOrigin += (Long)( ras.target.rows - 1 ) * ras.target.pitch;</span>
  
      if ( ( error = Render_Single_Pass( RAS_VARS 0 ) ) != 0 )
        return error;
  
      /* Horizontal Sweep */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3144,11 ***</span>
<span class="line-new-header">--- 3259,13 ---</span>
                     const FT_Raster_Params*  params )
    {
      const FT_Outline*  outline    = (const FT_Outline*)params-&gt;source;
      const FT_Bitmap*   target_map = params-&gt;target;
  
<span class="line-added">+ #ifndef FT_STATIC_RASTER</span>
      black_TWorker  worker[1];
<span class="line-added">+ #endif</span>
  
      Long  buffer[FT_MAX_BLACK_POOL];
  
  
      if ( !raster )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3183,29 ***</span>
        return Raster_Err_None;
  
      if ( !target_map-&gt;buffer )
        return FT_THROW( Invalid );
  
<span class="line-removed">-     /* reject too large outline coordinates */</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       FT_Vector*  vec   = outline-&gt;points;</span>
<span class="line-removed">-       FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-       for ( ; vec &lt; limit; vec++ )</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         if ( vec-&gt;x &lt; -0x1000000L || vec-&gt;x &gt; 0x1000000L ||</span>
<span class="line-removed">-              vec-&gt;y &lt; -0x1000000L || vec-&gt;y &gt; 0x1000000L )</span>
<span class="line-removed">-          return FT_THROW( Invalid );</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      ras.outline = *outline;
      ras.target  = *target_map;
  
<span class="line-modified">!     worker-&gt;buff     = buffer;</span>
<span class="line-modified">!     worker-&gt;sizeBuff = (&amp;buffer)[1]; /* Points to right after buffer. */</span>
  
      return Render_Glyph( RAS_VAR );
    }
  
  
<span class="line-new-header">--- 3300,15 ---</span>
        return Raster_Err_None;
  
      if ( !target_map-&gt;buffer )
        return FT_THROW( Invalid );
  
      ras.outline = *outline;
      ras.target  = *target_map;
  
<span class="line-modified">!     ras.buff     = buffer;</span>
<span class="line-modified">!     ras.sizeBuff = (&amp;buffer)[1]; /* Points to right after buffer. */</span>
  
      return Render_Glyph( RAS_VAR );
    }
  
  
</pre>
<center><a href="ftmisc.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftraster.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>