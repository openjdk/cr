<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-jstf-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,236 ***</span>
   *
   * Red Hat Author(s): Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-map-private.hh&quot;</span>
<span class="line-modified">! </span>
  #include &quot;hb-ot-layout-gdef-table.hh&quot;
  #include &quot;hb-ot-layout-gsub-table.hh&quot;
  #include &quot;hb-ot-layout-gpos-table.hh&quot;
<span class="line-modified">! </span>
<span class="line-modified">! // Just so we compile them; unused otherwise:</span>
<span class="line-removed">- #include &quot;hb-ot-layout-base-table.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-ot-layout-jstf-table.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-ot-color-colr-table.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-ot-color-cpal-table.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-ot-color-sbix-table.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-ot-color-svg-table.hh&quot;</span>
  #include &quot;hb-ot-name-table.hh&quot;
<span class="line-modified">! #include &quot;hb-map-private.hh&quot;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- hb_ot_layout_t *</span>
<span class="line-removed">- _hb_ot_layout_create (hb_face_t *face)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));</span>
<span class="line-removed">-   if (unlikely (!layout))</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   layout-&gt;gdef_blob = OT::Sanitizer&lt;OT::GDEF&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GDEF));</span>
<span class="line-removed">-   layout-&gt;gdef = layout-&gt;gdef_blob-&gt;as&lt;OT::GDEF&gt; ();</span>
  
<span class="line-modified">!   layout-&gt;gsub_blob = OT::Sanitizer&lt;OT::GSUB&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GSUB));</span>
<span class="line-modified">!   layout-&gt;gsub = layout-&gt;gsub_blob-&gt;as&lt;OT::GSUB&gt; ();</span>
  
<span class="line-removed">-   layout-&gt;gpos_blob = OT::Sanitizer&lt;OT::GPOS&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GPOS));</span>
<span class="line-removed">-   layout-&gt;gpos = layout-&gt;gpos_blob-&gt;as&lt;OT::GPOS&gt; ();</span>
  
<span class="line-modified">!   layout-&gt;math.init (face);</span>
<span class="line-modified">!   layout-&gt;fvar.init (face);</span>
<span class="line-modified">!   layout-&gt;avar.init (face);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified">!      * See this thread for why we finally had to bend in and do this:</span>
<span class="line-removed">-      * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     unsigned int gdef_len = layout-&gt;gdef_blob-&gt;length;</span>
<span class="line-removed">-     unsigned int gsub_len = layout-&gt;gsub_blob-&gt;length;</span>
<span class="line-removed">-     unsigned int gpos_len = layout-&gt;gpos_blob-&gt;length;</span>
<span class="line-removed">-     if (0</span>
<span class="line-removed">-       /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-removed">-       || (442 == gdef_len &amp;&amp; 42038 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-removed">-       || (430 == gdef_len &amp;&amp; 40662 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-removed">-       || (442 == gdef_len &amp;&amp; 39116 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-removed">-       || (430 == gdef_len &amp;&amp; 39374 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-removed">-       || (490 == gdef_len &amp;&amp; 41638 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-removed">-       || (478 == gdef_len &amp;&amp; 41902 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">-     )</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       /* In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-removed">-        * ASCII double quotation mark U+0022, mapped to glyph 5, has wrong</span>
<span class="line-removed">-        * glyph class 3 (mark) in GDEF.  Nuke the GDEF to avoid zero-width</span>
<span class="line-removed">-        * double-quote.  See:</span>
<span class="line-removed">-        * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">-        */</span>
<span class="line-removed">-      if (3 == layout-&gt;gdef-&gt;get_glyph_class (5))</span>
<span class="line-removed">-        layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else if (0</span>
<span class="line-removed">-       /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-removed">-       || (898 == gdef_len &amp;&amp; 46470 == gpos_len &amp;&amp; 12554 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-removed">-       || (910 == gdef_len &amp;&amp; 47732 == gpos_len &amp;&amp; 12566 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-removed">-       || (928 == gdef_len &amp;&amp; 59332 == gpos_len &amp;&amp; 23298 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-removed">-       || (940 == gdef_len &amp;&amp; 60732 == gpos_len &amp;&amp; 23310 == gsub_len)</span>
<span class="line-removed">-       /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed">-       || (964 == gdef_len &amp;&amp; 60072 == gpos_len &amp;&amp; 23836 == gsub_len)</span>
<span class="line-removed">-       /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed">-       || (976 == gdef_len &amp;&amp; 61456 == gpos_len &amp;&amp; 23832 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-removed">-       || (994 == gdef_len &amp;&amp; 60336 == gpos_len &amp;&amp; 24474 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-removed">-       || (1006 == gdef_len &amp;&amp; 61740 == gpos_len &amp;&amp; 24470 == gsub_len)</span>
<span class="line-removed">-       /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed">-       || (1006 == gdef_len &amp;&amp; 61346 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed">-       /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed">-       || (1018 == gdef_len &amp;&amp; 62828 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-removed">-       || (1006 == gdef_len &amp;&amp; 61352 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-removed">-       || (1018 == gdef_len &amp;&amp; 62834 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-removed">-       || (832 == gdef_len &amp;&amp; 47162 == gpos_len &amp;&amp; 7324 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-removed">-       || (844 == gdef_len &amp;&amp; 45474 == gpos_len &amp;&amp; 7302 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-removed">-       || (180 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 13054 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-removed">-       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12638 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-removed">-       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12690 == gsub_len)</span>
<span class="line-removed">-       /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-removed">-       /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-removed">-       || (188 == gdef_len &amp;&amp; 3852 == gpos_len &amp;&amp; 248 == gsub_len)</span>
<span class="line-removed">-       /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-removed">-       /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-removed">-       || (188 == gdef_len &amp;&amp; 3426 == gpos_len &amp;&amp; 264 == gsub_len)</span>
<span class="line-removed">-       /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-removed">-       || (1058 == gdef_len &amp;&amp; 11818 == gpos_len &amp;&amp; 47032 == gsub_len)</span>
<span class="line-removed">-       /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-removed">-       || (1046 == gdef_len &amp;&amp; 12600 == gpos_len &amp;&amp; 47030 == gsub_len)</span>
<span class="line-removed">-       /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-removed">-       || (1058 == gdef_len &amp;&amp; 16770 == gpos_len &amp;&amp; 71796 == gsub_len)</span>
<span class="line-removed">-       /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-removed">-       || (1046 == gdef_len &amp;&amp; 17862 == gpos_len &amp;&amp; 71790 == gsub_len)</span>
<span class="line-removed">-       /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-removed">-       || (1046 == gdef_len &amp;&amp; 17112 == gpos_len &amp;&amp; 71788 == gsub_len)</span>
<span class="line-removed">-       /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-removed">-       || (1058 == gdef_len &amp;&amp; 17514 == gpos_len &amp;&amp; 71794 == gsub_len)</span>
<span class="line-removed">-       /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-removed">-       || (1330 == gdef_len &amp;&amp; 57938 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed">-       /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-removed">-       || (1330 == gdef_len &amp;&amp; 58972 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed">-       /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-removed">-        *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-removed">-       || (1004 == gdef_len &amp;&amp; 14836 == gpos_len &amp;&amp; 59092 == gsub_len)</span>
<span class="line-removed">-     )</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       /* Many versions of Tahoma have bad GDEF tables that incorrectly classify some spacing marks</span>
<span class="line-removed">-        * such as certain IPA symbols as glyph class 3. So do older versions of Microsoft Himalaya,</span>
<span class="line-removed">-        * and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-removed">-        * Nuke the GDEF tables of these fonts to avoid unwanted width-zeroing.</span>
<span class="line-removed">-        * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-removed">-        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-removed">-        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-removed">-        */</span>
<span class="line-removed">-       layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  
<span class="line-removed">-   layout-&gt;gsub_lookup_count = layout-&gt;gsub-&gt;get_lookup_count ();</span>
<span class="line-removed">-   layout-&gt;gpos_lookup_count = layout-&gt;gpos-&gt;get_lookup_count ();</span>
  
<span class="line-modified">!   layout-&gt;gsub_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gsub-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>
<span class="line-modified">!   layout-&gt;gpos_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gpos-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>
  
<span class="line-modified">!   if (unlikely ((layout-&gt;gsub_lookup_count &amp;&amp; !layout-&gt;gsub_accels) ||</span>
<span class="line-modified">!                 (layout-&gt;gpos_lookup_count &amp;&amp; !layout-&gt;gpos_accels)))</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     _hb_ot_layout_destroy (layout);</span>
<span class="line-modified">!     return nullptr;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-modified">!     layout-&gt;gsub_accels[i].init (layout-&gt;gsub-&gt;get_lookup (i));</span>
<span class="line-modified">!   for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-modified">!     layout-&gt;gpos_accels[i].init (layout-&gt;gpos-&gt;get_lookup (i));</span>
  
<span class="line-modified">!   return layout;</span>
  }
  
  void
<span class="line-modified">! _hb_ot_layout_destroy (hb_ot_layout_t *layout)</span>
  {
<span class="line-modified">!   if (layout-&gt;gsub_accels)</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-removed">-       layout-&gt;gsub_accels[i].fini ();</span>
<span class="line-removed">-   if (layout-&gt;gpos_accels)</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-removed">-       layout-&gt;gpos_accels[i].fini ();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   free (layout-&gt;gsub_accels);</span>
<span class="line-removed">-   free (layout-&gt;gpos_accels);</span>
  
<span class="line-modified">!   hb_blob_destroy (layout-&gt;gdef_blob);</span>
<span class="line-removed">-   hb_blob_destroy (layout-&gt;gsub_blob);</span>
<span class="line-removed">-   hb_blob_destroy (layout-&gt;gpos_blob);</span>
  
<span class="line-modified">!   layout-&gt;math.fini ();</span>
<span class="line-removed">-   layout-&gt;fvar.fini ();</span>
<span class="line-removed">-   layout-&gt;avar.fini ();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   free (layout);</span>
  }
  
<span class="line-removed">- // static inline const OT::BASE&amp;</span>
<span class="line-removed">- // _get_base (hb_face_t *face)</span>
<span class="line-removed">- // {</span>
<span class="line-removed">- //   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::BASE);</span>
<span class="line-removed">- //   hb_ot_layout_t * layout = hb_ot_layout_from_face (face);</span>
<span class="line-removed">- //   return *(layout-&gt;base.get ());</span>
<span class="line-removed">- // }</span>
  
<span class="line-modified">! static inline const OT::GDEF&amp;</span>
<span class="line-modified">! _get_gdef (hb_face_t *face)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GDEF);</span>
<span class="line-modified">!   return *hb_ot_layout_from_face (face)-&gt;gdef;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! static inline const OT::GSUB&amp;</span>
<span class="line-removed">- _get_gsub (hb_face_t *face)</span>
  {
<span class="line-modified">!   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GSUB);</span>
<span class="line-modified">!   return *hb_ot_layout_from_face (face)-&gt;gsub;</span>
  }
<span class="line-modified">! static inline const OT::GPOS&amp;</span>
<span class="line-modified">! _get_gpos (hb_face_t *face)</span>
  {
<span class="line-modified">!   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GPOS);</span>
<span class="line-modified">!   return *hb_ot_layout_from_face (face)-&gt;gpos;</span>
  }
  
<span class="line-modified">! /*</span>
<span class="line-removed">-  * GDEF</span>
<span class="line-removed">-  */</span>
  
  hb_bool_t
  hb_ot_layout_has_glyph_classes (hb_face_t *face)
  {
<span class="line-modified">!   return _get_gdef (face).has_glyph_classes ();</span>
  }
  
  /**
   * hb_ot_layout_get_glyph_class:
   *
<span class="line-new-header">--- 26,205 ---</span>
   *
   * Red Hat Author(s): Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-map.hh&quot;</span>
<span class="line-added">+ #include &quot;hb-map.hh&quot;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #include &quot;hb-ot-kern-table.hh&quot;</span>
<span class="line-added">+ #include &quot;hb-ot-gasp-table.hh&quot; // Just so we compile it; unused otherwise.</span>
  #include &quot;hb-ot-layout-gdef-table.hh&quot;
  #include &quot;hb-ot-layout-gsub-table.hh&quot;
  #include &quot;hb-ot-layout-gpos-table.hh&quot;
<span class="line-modified">! #include &quot;hb-ot-layout-base-table.hh&quot; // Just so we compile it; unused otherwise.</span>
<span class="line-modified">! #include &quot;hb-ot-layout-jstf-table.hh&quot; // Just so we compile it; unused otherwise.</span>
  #include &quot;hb-ot-name-table.hh&quot;
<span class="line-modified">! #include &quot;hb-ot-os2-table.hh&quot;</span>
  
<span class="line-modified">! #include &quot;hb-aat-layout-lcar-table.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-aat-layout-morx-table.hh&quot;</span>
  
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * SECTION:hb-ot-layout</span>
<span class="line-modified">!  * @title: hb-ot-layout</span>
<span class="line-modified">!  * @short_description: OpenType Layout</span>
<span class="line-modified">!  * @include: hb-ot.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Functions for querying OpenType Layout features in the font face.</span>
<span class="line-modified">!  **/</span>
  
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * kern</span>
<span class="line-added">+  */</span>
  
<span class="line-modified">! bool</span>
<span class="line-modified">! hb_ot_layout_has_kerning (hb_face_t *face)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   return face-&gt;table.kern-&gt;has_data ();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! bool</span>
<span class="line-modified">! hb_ot_layout_has_machine_kerning (hb_face_t *face)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   return face-&gt;table.kern-&gt;has_state_machine ();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool</span>
<span class="line-added">+ hb_ot_layout_has_cross_kerning (hb_face_t *face)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return face-&gt;table.kern-&gt;has_cross_stream ();</span>
  }
  
  void
<span class="line-modified">! hb_ot_layout_kern (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">+                    hb_font_t *font,</span>
<span class="line-added">+                    hb_buffer_t  *buffer)</span>
  {
<span class="line-modified">!   hb_blob_t *blob = font-&gt;face-&gt;table.kern.get_blob ();</span>
<span class="line-modified">!   const AAT::kern&amp; kern = *blob-&gt;as&lt;AAT::kern&gt; ();</span>
  
<span class="line-modified">!   AAT::hb_aat_apply_context_t c (plan, font, buffer, blob);</span>
  
<span class="line-modified">!   kern.apply (&amp;c);</span>
  }
  
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * GDEF</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool</span>
<span class="line-modified">! OT::GDEF::is_blacklisted (hb_blob_t *blob,</span>
<span class="line-modified">!                           hb_face_t *face) const</span>
  {
<span class="line-modified">!   /* The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified">!    * See this thread for why we finally had to bend in and do this:</span>
<span class="line-added">+    * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-added">+    * ASCII double quotation mark U+0022 has wrong glyph class 3 (mark)</span>
<span class="line-added">+    * in GDEF.  Many versions of Tahoma have bad GDEF tables that</span>
<span class="line-added">+    * incorrectly classify some spacing marks such as certain IPA</span>
<span class="line-added">+    * symbols as glyph class 3. So do older versions of Microsoft</span>
<span class="line-added">+    * Himalaya, and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * Nuke the GDEF tables of to avoid unwanted width-zeroing.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-added">+    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-added">+    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-added">+    */</span>
<span class="line-added">+ #define ENCODE(x,y,z) (((uint64_t) (x) &lt;&lt; 48) | ((uint64_t) (y) &lt;&lt; 24) | (uint64_t) (z))</span>
<span class="line-added">+   switch ENCODE(blob-&gt;length,</span>
<span class="line-added">+                 face-&gt;table.GSUB-&gt;table.get_length (),</span>
<span class="line-added">+                 face-&gt;table.GPOS-&gt;table.get_length ())</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-added">+     case ENCODE (442, 2874, 42038):</span>
<span class="line-added">+     /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-added">+     case ENCODE (430, 2874, 40662):</span>
<span class="line-added">+     /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-added">+     case ENCODE (442, 2874, 39116):</span>
<span class="line-added">+     /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-added">+     case ENCODE (430, 2874, 39374):</span>
<span class="line-added">+     /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-added">+     case ENCODE (490, 3046, 41638):</span>
<span class="line-added">+     /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-added">+     case ENCODE (478, 3046, 41902):</span>
<span class="line-added">+     /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-added">+     case ENCODE (898, 12554, 46470):</span>
<span class="line-added">+     /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-added">+     case ENCODE (910, 12566, 47732):</span>
<span class="line-added">+     /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-added">+     case ENCODE (928, 23298, 59332):</span>
<span class="line-added">+     /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-added">+     case ENCODE (940, 23310, 60732):</span>
<span class="line-added">+     /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added">+     case ENCODE (964, 23836, 60072):</span>
<span class="line-added">+     /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added">+     case ENCODE (976, 23832, 61456):</span>
<span class="line-added">+     /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-added">+     case ENCODE (994, 24474, 60336):</span>
<span class="line-added">+     /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-added">+     case ENCODE (1006, 24470, 61740):</span>
<span class="line-added">+     /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added">+     case ENCODE (1006, 24576, 61346):</span>
<span class="line-added">+     /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added">+     case ENCODE (1018, 24572, 62828):</span>
<span class="line-added">+     /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-added">+     case ENCODE (1006, 24576, 61352):</span>
<span class="line-added">+     /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-added">+     case ENCODE (1018, 24572, 62834):</span>
<span class="line-added">+     /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-added">+     case ENCODE (832, 7324, 47162):</span>
<span class="line-added">+     /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-added">+     case ENCODE (844, 7302, 45474):</span>
<span class="line-added">+     /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-added">+     case ENCODE (180, 13054, 7254):</span>
<span class="line-added">+     /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-added">+     case ENCODE (192, 12638, 7254):</span>
<span class="line-added">+     /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-added">+     case ENCODE (192, 12690, 7254):</span>
<span class="line-added">+     /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-added">+     /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-added">+     case ENCODE (188, 248, 3852):</span>
<span class="line-added">+     /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-added">+     /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-added">+     case ENCODE (188, 264, 3426):</span>
<span class="line-added">+     /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-added">+     case ENCODE (1058, 47032, 11818):</span>
<span class="line-added">+     /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-added">+     case ENCODE (1046, 47030, 12600):</span>
<span class="line-added">+     /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-added">+     case ENCODE (1058, 71796, 16770):</span>
<span class="line-added">+     /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-added">+     case ENCODE (1046, 71790, 17862):</span>
<span class="line-added">+     /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-added">+     case ENCODE (1046, 71788, 17112):</span>
<span class="line-added">+     /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-added">+     case ENCODE (1058, 71794, 17514):</span>
<span class="line-added">+     /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-added">+     case ENCODE (1330, 109904, 57938):</span>
<span class="line-added">+     /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-added">+     case ENCODE (1330, 109904, 58972):</span>
<span class="line-added">+     /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-added">+      *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-added">+     case ENCODE (1004, 59092, 14836):</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+ #undef ENCODE</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
  }
<span class="line-modified">! </span>
<span class="line-modified">! static void</span>
<span class="line-added">+ _hb_ot_layout_set_glyph_props (hb_font_t *font,</span>
<span class="line-added">+                                hb_buffer_t *buffer)</span>
  {
<span class="line-modified">!   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
<span class="line-modified">! </span>
<span class="line-added">+   const OT::GDEF &amp;gdef = *font-&gt;face-&gt;table.GDEF-&gt;table;</span>
<span class="line-added">+   unsigned int count = buffer-&gt;len;</span>
<span class="line-added">+   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-added">+     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-added">+     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! /* Public API */</span>
  
  hb_bool_t
  hb_ot_layout_has_glyph_classes (hb_face_t *face)
  {
<span class="line-modified">!   return face-&gt;table.GDEF-&gt;table-&gt;has_glyph_classes ();</span>
  }
  
  /**
   * hb_ot_layout_get_glyph_class:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,11 ***</span>
   **/
  hb_ot_layout_glyph_class_t
  hb_ot_layout_get_glyph_class (hb_face_t      *face,
                                hb_codepoint_t  glyph)
  {
<span class="line-modified">!   return (hb_ot_layout_glyph_class_t) _get_gdef (face).get_glyph_class (glyph);</span>
  }
  
  /**
   * hb_ot_layout_get_glyphs_in_class:
   *
<span class="line-new-header">--- 232,11 ---</span>
   **/
  hb_ot_layout_glyph_class_t
  hb_ot_layout_get_glyph_class (hb_face_t      *face,
                                hb_codepoint_t  glyph)
  {
<span class="line-modified">!   return (hb_ot_layout_glyph_class_t) face-&gt;table.GDEF-&gt;table-&gt;get_glyph_class (glyph);</span>
  }
  
  /**
   * hb_ot_layout_get_glyphs_in_class:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,57 ***</span>
  void
  hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
                                    hb_ot_layout_glyph_class_t  klass,
                                    hb_set_t                   *glyphs /* OUT */)
  {
<span class="line-modified">!   return _get_gdef (face).get_glyphs_in_class (klass, glyphs);</span>
  }
  
  unsigned int
  hb_ot_layout_get_attach_points (hb_face_t      *face,
                                  hb_codepoint_t  glyph,
                                  unsigned int    start_offset,
                                  unsigned int   *point_count /* IN/OUT */,
                                  unsigned int   *point_array /* OUT */)
  {
<span class="line-modified">!   return _get_gdef (face).get_attach_points (glyph, start_offset, point_count, point_array);</span>
  }
  
  unsigned int
  hb_ot_layout_get_ligature_carets (hb_font_t      *font,
                                    hb_direction_t  direction,
                                    hb_codepoint_t  glyph,
                                    unsigned int    start_offset,
                                    unsigned int   *caret_count /* IN/OUT */,
                                    hb_position_t  *caret_array /* OUT */)
  {
<span class="line-modified">!   return _get_gdef (font-&gt;face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>
  }
  
  
  /*
   * GSUB/GPOS
   */
  
  static const OT::GSUBGPOS&amp;
  get_gsubgpos_table (hb_face_t *face,
                      hb_tag_t   table_tag)
  {
    switch (table_tag) {
<span class="line-modified">!     case HB_OT_TAG_GSUB: return _get_gsub (face);</span>
<span class="line-modified">!     case HB_OT_TAG_GPOS: return _get_gpos (face);</span>
      default:             return Null(OT::GSUBGPOS);
    }
  }
  
  
  unsigned int
  hb_ot_layout_table_get_script_tags (hb_face_t    *face,
                                      hb_tag_t      table_tag,
                                      unsigned int  start_offset,
                                      unsigned int *script_count /* IN/OUT */,
<span class="line-modified">!                                     hb_tag_t     *script_tags /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
  
    return g.get_script_tags (start_offset, script_count, script_tags);
  }
<span class="line-new-header">--- 245,100 ---</span>
  void
  hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
                                    hb_ot_layout_glyph_class_t  klass,
                                    hb_set_t                   *glyphs /* OUT */)
  {
<span class="line-modified">!   return face-&gt;table.GDEF-&gt;table-&gt;get_glyphs_in_class (klass, glyphs);</span>
  }
  
  unsigned int
  hb_ot_layout_get_attach_points (hb_face_t      *face,
                                  hb_codepoint_t  glyph,
                                  unsigned int    start_offset,
                                  unsigned int   *point_count /* IN/OUT */,
                                  unsigned int   *point_array /* OUT */)
  {
<span class="line-modified">!   return face-&gt;table.GDEF-&gt;table-&gt;get_attach_points (glyph,</span>
<span class="line-added">+                                                      start_offset,</span>
<span class="line-added">+                                                      point_count,</span>
<span class="line-added">+                                                      point_array);</span>
  }
  
  unsigned int
  hb_ot_layout_get_ligature_carets (hb_font_t      *font,
                                    hb_direction_t  direction,
                                    hb_codepoint_t  glyph,
                                    unsigned int    start_offset,
                                    unsigned int   *caret_count /* IN/OUT */,
                                    hb_position_t  *caret_array /* OUT */)
  {
<span class="line-modified">!   unsigned int result_caret_count = 0;</span>
<span class="line-added">+   unsigned int result = font-&gt;face-&gt;table.GDEF-&gt;table-&gt;get_lig_carets (font, direction, glyph, start_offset, &amp;result_caret_count, caret_array);</span>
<span class="line-added">+   if (result)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (caret_count) *caret_count = result_caret_count;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   else</span>
<span class="line-added">+     result = font-&gt;face-&gt;table.lcar-&gt;get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>
<span class="line-added">+   return result;</span>
  }
  
  
  /*
   * GSUB/GPOS
   */
  
<span class="line-added">+ bool</span>
<span class="line-added">+ OT::GSUB::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added">+                           hb_face_t *face) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* Mac OS X prefers morx over GSUB.  It also ships with various Indic fonts,</span>
<span class="line-added">+    * all by &#39;MUTF&#39; foundry (Tamil MN, Tamil Sangam MN, etc.), that have broken</span>
<span class="line-added">+    * GSUB/GPOS tables.  Some have GSUB with zero scripts, those are ignored by</span>
<span class="line-added">+    * our morx/GSUB preference code.  But if GSUB has non-zero scripts, we tend</span>
<span class="line-added">+    * to prefer it over morx because we want to be consistent with other OpenType</span>
<span class="line-added">+    * shapers.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * To work around broken Indic Mac system fonts, we ignore GSUB table if</span>
<span class="line-added">+    * OS/2 VendorId is &#39;MUTF&#39; and font has morx table as well.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1410</span>
<span class="line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1348</span>
<span class="line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1391</span>
<span class="line-added">+    */</span>
<span class="line-added">+   if (unlikely (face-&gt;table.OS2-&gt;achVendID == HB_TAG (&#39;M&#39;,&#39;U&#39;,&#39;T&#39;,&#39;F&#39;) &amp;&amp;</span>
<span class="line-added">+                 face-&gt;table.morx-&gt;has_data ()))</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool</span>
<span class="line-added">+ OT::GPOS::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added">+                           hb_face_t *face HB_UNUSED) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static const OT::GSUBGPOS&amp;
  get_gsubgpos_table (hb_face_t *face,
                      hb_tag_t   table_tag)
  {
    switch (table_tag) {
<span class="line-modified">!     case HB_OT_TAG_GSUB: return *face-&gt;table.GSUB-&gt;table;</span>
<span class="line-modified">!     case HB_OT_TAG_GPOS: return *face-&gt;table.GPOS-&gt;table;</span>
      default:             return Null(OT::GSUBGPOS);
    }
  }
  
  
  unsigned int
  hb_ot_layout_table_get_script_tags (hb_face_t    *face,
                                      hb_tag_t      table_tag,
                                      unsigned int  start_offset,
                                      unsigned int *script_count /* IN/OUT */,
<span class="line-modified">!                                     hb_tag_t     *script_tags  /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
  
    return g.get_script_tags (start_offset, script_count, script_tags);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,22 ***</span>
  hb_ot_layout_table_choose_script (hb_face_t      *face,
                                    hb_tag_t        table_tag,
                                    const hb_tag_t *script_tags,
                                    unsigned int   *script_index,
                                    hb_tag_t       *chosen_script)
  {
    static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
  
<span class="line-modified">!   while (*script_tags)</span>
    {
<span class="line-modified">!     if (g.find_script_index (*script_tags, script_index)) {</span>
        if (chosen_script)
<span class="line-modified">!         *chosen_script = *script_tags;</span>
        return true;
      }
<span class="line-removed">-     script_tags++;</span>
    }
  
    /* try finding &#39;DFLT&#39; */
    if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
      if (chosen_script)
<span class="line-new-header">--- 379,41 ---</span>
  hb_ot_layout_table_choose_script (hb_face_t      *face,
                                    hb_tag_t        table_tag,
                                    const hb_tag_t *script_tags,
                                    unsigned int   *script_index,
                                    hb_tag_t       *chosen_script)
<span class="line-added">+ {</span>
<span class="line-added">+   const hb_tag_t *t;</span>
<span class="line-added">+   for (t = script_tags; *t; t++);</span>
<span class="line-added">+   return hb_ot_layout_table_select_script (face, table_tag, t - script_tags, script_tags, script_index, chosen_script);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_ot_layout_table_select_script:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ hb_bool_t</span>
<span class="line-added">+ hb_ot_layout_table_select_script (hb_face_t      *face,</span>
<span class="line-added">+                                   hb_tag_t        table_tag,</span>
<span class="line-added">+                                   unsigned int    script_count,</span>
<span class="line-added">+                                   const hb_tag_t *script_tags,</span>
<span class="line-added">+                                   unsigned int   *script_index  /* OUT */,</span>
<span class="line-added">+                                   hb_tag_t       *chosen_script /* OUT */)</span>
  {
    static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
<span class="line-added">+   unsigned int i;</span>
  
<span class="line-modified">!   for (i = 0; i &lt; script_count; i++)</span>
    {
<span class="line-modified">!     if (g.find_script_index (script_tags[i], script_index))</span>
<span class="line-added">+     {</span>
        if (chosen_script)
<span class="line-modified">!         *chosen_script = script_tags[i];</span>
        return true;
      }
    }
  
    /* try finding &#39;DFLT&#39; */
    if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
      if (chosen_script)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,18 ***</span>
  unsigned int
  hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
                                       hb_tag_t      table_tag,
                                       unsigned int  start_offset,
                                       unsigned int *feature_count /* IN/OUT */,
<span class="line-modified">!                                      hb_tag_t     *feature_tags /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
  
    return g.get_feature_tags (start_offset, feature_count, feature_tags);
  }
  
<span class="line-modified">! hb_bool_t</span>
  hb_ot_layout_table_find_feature (hb_face_t    *face,
                                   hb_tag_t      table_tag,
                                   hb_tag_t      feature_tag,
                                   unsigned int *feature_index)
  {
<span class="line-new-header">--- 445,18 ---</span>
  unsigned int
  hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
                                       hb_tag_t      table_tag,
                                       unsigned int  start_offset,
                                       unsigned int *feature_count /* IN/OUT */,
<span class="line-modified">!                                      hb_tag_t     *feature_tags  /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
  
    return g.get_feature_tags (start_offset, feature_count, feature_tags);
  }
  
<span class="line-modified">! bool</span>
  hb_ot_layout_table_find_feature (hb_face_t    *face,
                                   hb_tag_t      table_tag,
                                   hb_tag_t      feature_tag,
                                   unsigned int *feature_index)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
  hb_ot_layout_script_get_language_tags (hb_face_t    *face,
                                         hb_tag_t      table_tag,
                                         unsigned int  script_index,
                                         unsigned int  start_offset,
                                         unsigned int *language_count /* IN/OUT */,
<span class="line-modified">!                                        hb_tag_t     *language_tags /* OUT */)</span>
  {
    const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
  
    return s.get_lang_sys_tags (start_offset, language_count, language_tags);
  }
<span class="line-new-header">--- 481,11 ---</span>
  hb_ot_layout_script_get_language_tags (hb_face_t    *face,
                                         hb_tag_t      table_tag,
                                         unsigned int  script_index,
                                         unsigned int  start_offset,
                                         unsigned int *language_count /* IN/OUT */,
<span class="line-modified">!                                        hb_tag_t     *language_tags  /* OUT */)</span>
  {
    const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
  
    return s.get_lang_sys_tags (start_offset, language_count, language_tags);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,18 ***</span>
  hb_ot_layout_script_find_language (hb_face_t    *face,
                                     hb_tag_t      table_tag,
                                     unsigned int  script_index,
                                     hb_tag_t      language_tag,
                                     unsigned int *language_index)
  {
    static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
    const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
  
<span class="line-modified">!   if (s.find_lang_sys_index (language_tag, language_index))</span>
<span class="line-modified">!     return true;</span>
  
<span class="line-modified">!   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */</span>
    if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
      return false;
  
    if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
    return false;
<span class="line-new-header">--- 494,43 ---</span>
  hb_ot_layout_script_find_language (hb_face_t    *face,
                                     hb_tag_t      table_tag,
                                     unsigned int  script_index,
                                     hb_tag_t      language_tag,
                                     unsigned int *language_index)
<span class="line-added">+ {</span>
<span class="line-added">+   return hb_ot_layout_script_select_language (face,</span>
<span class="line-added">+                                               table_tag,</span>
<span class="line-added">+                                               script_index,</span>
<span class="line-added">+                                               1,</span>
<span class="line-added">+                                               &amp;language_tag,</span>
<span class="line-added">+                                               language_index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_ot_layout_script_select_language:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ hb_bool_t</span>
<span class="line-added">+ hb_ot_layout_script_select_language (hb_face_t      *face,</span>
<span class="line-added">+                                      hb_tag_t        table_tag,</span>
<span class="line-added">+                                      unsigned int    script_index,</span>
<span class="line-added">+                                      unsigned int    language_count,</span>
<span class="line-added">+                                      const hb_tag_t *language_tags,</span>
<span class="line-added">+                                      unsigned int   *language_index /* OUT */)</span>
  {
    static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
    const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
<span class="line-added">+   unsigned int i;</span>
  
<span class="line-modified">!   for (i = 0; i &lt; language_count; i++)</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     if (s.find_lang_sys_index (language_tags[i], language_index))</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   /* try finding &#39;dflt&#39; */</span>
    if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
      return false;
  
    if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
    return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,11 ***</span>
  hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
                                             hb_tag_t      table_tag,
                                             unsigned int  script_index,
                                             unsigned int  language_index,
                                             unsigned int  start_offset,
<span class="line-modified">!                                            unsigned int *feature_count /* IN/OUT */,</span>
                                             unsigned int *feature_indexes /* OUT */)
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
    const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
  
<span class="line-new-header">--- 578,11 ---</span>
  hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
                                             hb_tag_t      table_tag,
                                             unsigned int  script_index,
                                             unsigned int  language_index,
                                             unsigned int  start_offset,
<span class="line-modified">!                                            unsigned int *feature_count   /* IN/OUT */,</span>
                                             unsigned int *feature_indexes /* OUT */)
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
    const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,11 ***</span>
                                          hb_tag_t      table_tag,
                                          unsigned int  script_index,
                                          unsigned int  language_index,
                                          unsigned int  start_offset,
                                          unsigned int *feature_count /* IN/OUT */,
<span class="line-modified">!                                         hb_tag_t     *feature_tags /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
    const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
  
    static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
<span class="line-new-header">--- 594,11 ---</span>
                                          hb_tag_t      table_tag,
                                          unsigned int  script_index,
                                          unsigned int  language_index,
                                          unsigned int  start_offset,
                                          unsigned int *feature_count /* IN/OUT */,
<span class="line-modified">!                                         hb_tag_t     *feature_tags  /* OUT */)</span>
  {
    const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
    const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
  
    static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,11 ***</span>
  unsigned int
  hb_ot_layout_feature_get_lookups (hb_face_t    *face,
                                    hb_tag_t      table_tag,
                                    unsigned int  feature_index,
                                    unsigned int  start_offset,
<span class="line-modified">!                                   unsigned int *lookup_count /* IN/OUT */,</span>
                                    unsigned int *lookup_indexes /* OUT */)
  {
    return hb_ot_layout_feature_with_variations_get_lookups (face,
                                                             table_tag,
                                                             feature_index,
<span class="line-new-header">--- 648,11 ---</span>
  unsigned int
  hb_ot_layout_feature_get_lookups (hb_face_t    *face,
                                    hb_tag_t      table_tag,
                                    unsigned int  feature_index,
                                    unsigned int  start_offset,
<span class="line-modified">!                                   unsigned int *lookup_count   /* IN/OUT */,</span>
                                    unsigned int *lookup_indexes /* OUT */)
  {
    return hb_ot_layout_feature_with_variations_get_lookups (face,
                                                             table_tag,
                                                             feature_index,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,243 ***</span>
   **/
  unsigned int
  hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
                                       hb_tag_t      table_tag)
  {
<span class="line-modified">!   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return 0;</span>
<span class="line-removed">-   switch (table_tag)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     case HB_OT_TAG_GSUB:</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       return hb_ot_layout_from_face (face)-&gt;gsub_lookup_count;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case HB_OT_TAG_GPOS:</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       return hb_ot_layout_from_face (face)-&gt;gpos_lookup_count;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return 0;</span>
  }
  
<span class="line-modified">! static void</span>
<span class="line-modified">! _hb_ot_layout_collect_lookups_lookups (hb_face_t      *face,</span>
<span class="line-removed">-                                        hb_tag_t        table_tag,</span>
<span class="line-removed">-                                        unsigned int    feature_index,</span>
<span class="line-removed">-                                        hb_set_t       *lookup_indexes /* OUT */)</span>
  {
<span class="line-modified">!   unsigned int lookup_indices[32];</span>
<span class="line-modified">!   unsigned int offset, len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   offset = 0;</span>
<span class="line-modified">!   do {</span>
<span class="line-modified">!     len = ARRAY_LENGTH (lookup_indices);</span>
<span class="line-modified">!     hb_ot_layout_feature_get_lookups (face,</span>
<span class="line-modified">!                                       table_tag,</span>
<span class="line-modified">!                                       feature_index,</span>
<span class="line-modified">!                                       offset, &amp;len,</span>
<span class="line-modified">!                                       lookup_indices);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-modified">!       lookup_indexes-&gt;add (lookup_indices[i]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     offset += len;</span>
<span class="line-modified">!   } while (len == ARRAY_LENGTH (lookup_indices));</span>
<span class="line-modified">! }</span>
  
  static void
<span class="line-modified">! _hb_ot_layout_collect_lookups_features (hb_face_t      *face,</span>
<span class="line-modified">!                                         hb_tag_t        table_tag,</span>
<span class="line-modified">!                                         unsigned int    script_index,</span>
<span class="line-removed">-                                         unsigned int    language_index,</span>
<span class="line-removed">-                                         const hb_tag_t *features,</span>
<span class="line-removed">-                                         hb_set_t       *lookup_indexes /* OUT */)</span>
  {
    if (!features)
    {
<span class="line-modified">!     unsigned int required_feature_index;</span>
<span class="line-modified">!     if (hb_ot_layout_language_get_required_feature (face,</span>
<span class="line-modified">!                                                     table_tag,</span>
<span class="line-modified">!                                                     script_index,</span>
<span class="line-modified">!                                                     language_index,</span>
<span class="line-removed">-                                                     &amp;required_feature_index,</span>
<span class="line-removed">-                                                     nullptr))</span>
<span class="line-removed">-       _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed">-                                              table_tag,</span>
<span class="line-removed">-                                              required_feature_index,</span>
<span class="line-removed">-                                              lookup_indexes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* All features */</span>
<span class="line-removed">-     unsigned int feature_indices[32];</span>
<span class="line-removed">-     unsigned int offset, len;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     offset = 0;</span>
<span class="line-removed">-     do {</span>
<span class="line-removed">-       len = ARRAY_LENGTH (feature_indices);</span>
<span class="line-removed">-       hb_ot_layout_language_get_feature_indexes (face,</span>
<span class="line-removed">-                                                  table_tag,</span>
<span class="line-removed">-                                                  script_index,</span>
<span class="line-removed">-                                                  language_index,</span>
<span class="line-removed">-                                                  offset, &amp;len,</span>
<span class="line-removed">-                                                  feature_indices);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-removed">-         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed">-                                                table_tag,</span>
<span class="line-removed">-                                                feature_indices[i],</span>
<span class="line-removed">-                                                lookup_indexes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       offset += len;</span>
<span class="line-removed">-     } while (len == ARRAY_LENGTH (feature_indices));</span>
    }
    else
    {
      for (; *features; features++)
      {
<span class="line-modified">!       unsigned int feature_index;</span>
<span class="line-modified">!       if (hb_ot_layout_language_find_feature (face,</span>
<span class="line-modified">!                                               table_tag,</span>
<span class="line-modified">!                                               script_index,</span>
<span class="line-modified">!                                               language_index,</span>
<span class="line-modified">!                                               *features,</span>
<span class="line-modified">!                                               &amp;feature_index))</span>
<span class="line-modified">!         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-modified">!                                                table_tag,</span>
<span class="line-modified">!                                                feature_index,</span>
<span class="line-modified">!                                                lookup_indexes);</span>
      }
    }
  }
  
  static void
<span class="line-modified">! _hb_ot_layout_collect_lookups_languages (hb_face_t      *face,</span>
<span class="line-modified">!                                          hb_tag_t        table_tag,</span>
<span class="line-modified">!                                          unsigned int    script_index,</span>
<span class="line-modified">!                                          const hb_tag_t *languages,</span>
<span class="line-removed">-                                          const hb_tag_t *features,</span>
<span class="line-removed">-                                          hb_set_t       *lookup_indexes /* OUT */)</span>
  {
<span class="line-modified">!   _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed">-                                           table_tag,</span>
<span class="line-removed">-                                           script_index,</span>
<span class="line-removed">-                                           HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX,</span>
<span class="line-removed">-                                           features,</span>
<span class="line-removed">-                                           lookup_indexes);</span>
  
    if (!languages)
    {
<span class="line-modified">!     /* All languages */</span>
<span class="line-modified">!     unsigned int count = hb_ot_layout_script_get_language_tags (face,</span>
<span class="line-modified">!                                                                 table_tag,</span>
<span class="line-modified">!                                                                 script_index,</span>
<span class="line-modified">!                                                                 0, nullptr, nullptr);</span>
      for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<span class="line-modified">!       _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-modified">!                                               table_tag,</span>
<span class="line-modified">!                                               script_index,</span>
<span class="line-removed">-                                               language_index,</span>
<span class="line-removed">-                                               features,</span>
<span class="line-removed">-                                               lookup_indexes);</span>
    }
    else
    {
      for (; *languages; languages++)
      {
        unsigned int language_index;
<span class="line-modified">!       if (hb_ot_layout_script_find_language (face,</span>
<span class="line-modified">!                                              table_tag,</span>
<span class="line-modified">!                                              script_index,</span>
<span class="line-modified">!                                              *languages,</span>
<span class="line-removed">-                                              &amp;language_index))</span>
<span class="line-removed">-         _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed">-                                                 table_tag,</span>
<span class="line-removed">-                                                 script_index,</span>
<span class="line-removed">-                                                 language_index,</span>
<span class="line-removed">-                                                 features,</span>
<span class="line-removed">-                                                 lookup_indexes);</span>
      }
    }
  }
  
  /**
<span class="line-modified">!  * hb_ot_layout_collect_lookups:</span>
   *
<span class="line-modified">!  * Since: 0.9.8</span>
   **/
  void
<span class="line-modified">! hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-modified">!                               hb_tag_t        table_tag,</span>
<span class="line-modified">!                               const hb_tag_t *scripts,</span>
<span class="line-modified">!                               const hb_tag_t *languages,</span>
<span class="line-modified">!                               const hb_tag_t *features,</span>
<span class="line-modified">!                               hb_set_t       *lookup_indexes /* OUT */)</span>
  {
    if (!scripts)
    {
<span class="line-modified">!     /* All scripts */</span>
<span class="line-modified">!     unsigned int count = hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-removed">-                                                              table_tag,</span>
<span class="line-removed">-                                                              0, nullptr, nullptr);</span>
      for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<span class="line-modified">!       _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-modified">!                                                table_tag,</span>
<span class="line-modified">!                                                script_index,</span>
<span class="line-modified">!                                                languages,</span>
<span class="line-removed">-                                                features,</span>
<span class="line-removed">-                                                lookup_indexes);</span>
    }
    else
    {
      for (; *scripts; scripts++)
      {
        unsigned int script_index;
<span class="line-modified">!       if (hb_ot_layout_table_find_script (face,</span>
<span class="line-modified">!                                           table_tag,</span>
<span class="line-modified">!                                           *scripts,</span>
<span class="line-modified">!                                           &amp;script_index))</span>
<span class="line-modified">!         _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-removed">-                                                  table_tag,</span>
<span class="line-removed">-                                                  script_index,</span>
<span class="line-removed">-                                                  languages,</span>
<span class="line-removed">-                                                  features,</span>
<span class="line-removed">-                                                  lookup_indexes);</span>
      }
    }
  }
  
  /**
   * hb_ot_layout_lookup_collect_glyphs:
   *
   * Since: 0.9.7
   **/
  void
  hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
                                      hb_tag_t      table_tag,
                                      unsigned int  lookup_index,
<span class="line-modified">!                                     hb_set_t     *glyphs_before, /* OUT. May be nullptr */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_input,  /* OUT. May be nullptr */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_after,  /* OUT. May be nullptr */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_output  /* OUT. May be nullptr */)</span>
  {
<span class="line-removed">-   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return;</span>
<span class="line-removed">- </span>
    OT::hb_collect_glyphs_context_t c (face,
                                       glyphs_before,
                                       glyphs_input,
                                       glyphs_after,
                                       glyphs_output);
  
    switch (table_tag)
    {
      case HB_OT_TAG_GSUB:
      {
<span class="line-modified">!       const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
        l.collect_glyphs (&amp;c);
        return;
      }
      case HB_OT_TAG_GPOS:
      {
<span class="line-modified">!       const OT::PosLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gpos-&gt;get_lookup (lookup_index);</span>
        l.collect_glyphs (&amp;c);
        return;
      }
    }
  }
<span class="line-new-header">--- 669,236 ---</span>
   **/
  unsigned int
  hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
                                       hb_tag_t      table_tag)
  {
<span class="line-modified">!   return get_gsubgpos_table (face, table_tag).get_lookup_count ();</span>
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! struct hb_collect_features_context_t</span>
  {
<span class="line-modified">!   hb_collect_features_context_t (hb_face_t       *face,</span>
<span class="line-modified">!                                  hb_tag_t         table_tag,</span>
<span class="line-modified">!                                  hb_set_t        *feature_indexes_)</span>
<span class="line-modified">!     : g (get_gsubgpos_table (face, table_tag)),</span>
<span class="line-modified">!       feature_indexes (feature_indexes_),</span>
<span class="line-modified">!       script_count(0),langsys_count(0) {}</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool visited (const OT::Script &amp;s)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-modified">!      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-modified">!     if (unlikely (!s.has_default_lang_sys () &amp;&amp;</span>
<span class="line-modified">!                   !s.get_lang_sys_count ()))</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (script_count++ &gt; HB_MAX_SCRIPTS)</span>
<span class="line-modified">!       return true;</span>
<span class="line-modified">! </span>
<span class="line-added">+     return visited (s, visited_script);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   bool visited (const OT::LangSys &amp;l)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-added">+      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-added">+     if (unlikely (!l.has_required_feature () &amp;&amp;</span>
<span class="line-added">+                   !l.get_feature_count ()))</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (langsys_count++ &gt; HB_MAX_LANGSYS)</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return visited (l, visited_langsys);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   private:</span>
<span class="line-added">+   template &lt;typename T&gt;</span>
<span class="line-added">+   bool visited (const T &amp;p, hb_set_t &amp;visited_set)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) &amp;p - (uintptr_t) &amp;g);</span>
<span class="line-added">+      if (visited_set.has (delta))</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     visited_set.add (delta);</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   const OT::GSUBGPOS &amp;g;</span>
<span class="line-added">+   hb_set_t           *feature_indexes;</span>
<span class="line-added">+ </span>
<span class="line-added">+   private:</span>
<span class="line-added">+   hb_set_t visited_script;</span>
<span class="line-added">+   hb_set_t visited_langsys;</span>
<span class="line-added">+   unsigned int script_count;</span>
<span class="line-added">+   unsigned int langsys_count;</span>
<span class="line-added">+ };</span>
  
  static void
<span class="line-modified">! langsys_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified">!                           const OT::LangSys  &amp;l,</span>
<span class="line-modified">!                           const hb_tag_t     *features)</span>
  {
<span class="line-added">+   if (c-&gt;visited (l)) return;</span>
<span class="line-added">+ </span>
    if (!features)
    {
<span class="line-modified">!     /* All features. */</span>
<span class="line-modified">!     if (l.has_required_feature ())</span>
<span class="line-modified">!       c-&gt;feature_indexes-&gt;add (l.get_required_feature_index ());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     l.add_feature_indexes_to (c-&gt;feature_indexes);</span>
    }
    else
    {
<span class="line-added">+     /* Ugh. Any faster way? */</span>
      for (; *features; features++)
      {
<span class="line-modified">!       hb_tag_t feature_tag = *features;</span>
<span class="line-modified">!       unsigned int num_features = l.get_feature_count ();</span>
<span class="line-modified">!       for (unsigned int i = 0; i &lt; num_features; i++)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         unsigned int feature_index = l.get_feature_index (i);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (feature_tag == c-&gt;g.get_feature_tag (feature_index))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           c-&gt;feature_indexes-&gt;add (feature_index);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-added">+       }</span>
      }
    }
  }
  
  static void
<span class="line-modified">! script_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified">!                          const OT::Script   &amp;s,</span>
<span class="line-modified">!                          const hb_tag_t *languages,</span>
<span class="line-modified">!                          const hb_tag_t *features)</span>
  {
<span class="line-modified">!   if (c-&gt;visited (s)) return;</span>
  
    if (!languages)
    {
<span class="line-modified">!     /* All languages. */</span>
<span class="line-modified">!     if (s.has_default_lang_sys ())</span>
<span class="line-modified">!       langsys_collect_features (c,</span>
<span class="line-modified">!                                 s.get_default_lang_sys (),</span>
<span class="line-modified">!                                 features);</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned int count = s.get_lang_sys_count ();</span>
      for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<span class="line-modified">!       langsys_collect_features (c,</span>
<span class="line-modified">!                                 s.get_lang_sys (language_index),</span>
<span class="line-modified">!                                 features);</span>
    }
    else
    {
      for (; *languages; languages++)
      {
        unsigned int language_index;
<span class="line-modified">!       if (s.find_lang_sys_index (*languages, &amp;language_index))</span>
<span class="line-modified">!         langsys_collect_features (c,</span>
<span class="line-modified">!                                   s.get_lang_sys (language_index),</span>
<span class="line-modified">!                                   features);</span>
      }
    }
  }
  
  /**
<span class="line-modified">!  * hb_ot_layout_collect_features:</span>
   *
<span class="line-modified">!  * Since: 1.8.5</span>
   **/
  void
<span class="line-modified">! hb_ot_layout_collect_features (hb_face_t      *face,</span>
<span class="line-modified">!                                hb_tag_t        table_tag,</span>
<span class="line-modified">!                                const hb_tag_t *scripts,</span>
<span class="line-modified">!                                const hb_tag_t *languages,</span>
<span class="line-modified">!                                const hb_tag_t *features,</span>
<span class="line-modified">!                                hb_set_t       *feature_indexes /* OUT */)</span>
  {
<span class="line-added">+   hb_collect_features_context_t c (face, table_tag, feature_indexes);</span>
    if (!scripts)
    {
<span class="line-modified">!     /* All scripts. */</span>
<span class="line-modified">!     unsigned int count = c.g.get_script_count ();</span>
      for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<span class="line-modified">!       script_collect_features (&amp;c,</span>
<span class="line-modified">!                                c.g.get_script (script_index),</span>
<span class="line-modified">!                                languages,</span>
<span class="line-modified">!                                features);</span>
    }
    else
    {
      for (; *scripts; scripts++)
      {
        unsigned int script_index;
<span class="line-modified">!       if (c.g.find_script_index (*scripts, &amp;script_index))</span>
<span class="line-modified">!         script_collect_features (&amp;c,</span>
<span class="line-modified">!                                  c.g.get_script (script_index),</span>
<span class="line-modified">!                                  languages,</span>
<span class="line-modified">!                                  features);</span>
      }
    }
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_ot_layout_collect_lookups:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 0.9.8</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-added">+                               hb_tag_t        table_tag,</span>
<span class="line-added">+                               const hb_tag_t *scripts,</span>
<span class="line-added">+                               const hb_tag_t *languages,</span>
<span class="line-added">+                               const hb_tag_t *features,</span>
<span class="line-added">+                               hb_set_t       *lookup_indexes /* OUT */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_set_t feature_indexes;</span>
<span class="line-added">+   hb_ot_layout_collect_features (face, table_tag, scripts, languages, features, &amp;feature_indexes);</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (hb_codepoint_t feature_index = HB_SET_VALUE_INVALID;</span>
<span class="line-added">+        hb_set_next (&amp;feature_indexes, &amp;feature_index);)</span>
<span class="line-added">+     g.get_feature (feature_index).add_lookup_indexes_to (lookup_indexes);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * hb_ot_layout_lookup_collect_glyphs:
   *
   * Since: 0.9.7
   **/
  void
  hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
                                      hb_tag_t      table_tag,
                                      unsigned int  lookup_index,
<span class="line-modified">!                                     hb_set_t     *glyphs_before, /* OUT.  May be NULL */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_input,  /* OUT.  May be NULL */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_after,  /* OUT.  May be NULL */</span>
<span class="line-modified">!                                     hb_set_t     *glyphs_output  /* OUT.  May be NULL */)</span>
  {
    OT::hb_collect_glyphs_context_t c (face,
                                       glyphs_before,
                                       glyphs_input,
                                       glyphs_after,
                                       glyphs_output);
  
    switch (table_tag)
    {
      case HB_OT_TAG_GSUB:
      {
<span class="line-modified">!       const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
        l.collect_glyphs (&amp;c);
        return;
      }
      case HB_OT_TAG_GPOS:
      {
<span class="line-modified">!       const OT::PosLookup&amp; l = face-&gt;table.GPOS-&gt;table-&gt;get_lookup (lookup_index);</span>
        l.collect_glyphs (&amp;c);
        return;
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 892,11 ***</span>
   */
  
  hb_bool_t
  hb_ot_layout_has_substitution (hb_face_t *face)
  {
<span class="line-modified">!   return &amp;_get_gsub (face) != &amp;Null(OT::GSUB);</span>
  }
  
  /**
   * hb_ot_layout_lookup_would_substitute:
   *
<span class="line-new-header">--- 941,11 ---</span>
   */
  
  hb_bool_t
  hb_ot_layout_has_substitution (hb_face_t *face)
  {
<span class="line-modified">!   return face-&gt;table.GSUB-&gt;table-&gt;has_data ();</span>
  }
  
  /**
   * hb_ot_layout_lookup_would_substitute:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,33 ***</span>
                                        unsigned int          lookup_index,
                                        const hb_codepoint_t *glyphs,
                                        unsigned int          glyphs_length,
                                        hb_bool_t             zero_context)
  {
<span class="line-modified">!   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return false;</span>
<span class="line-modified">!   return hb_ot_layout_lookup_would_substitute_fast (face, lookup_index, glyphs, glyphs_length, zero_context);</span>
  }
  
<span class="line-modified">! hb_bool_t</span>
  hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
                                             unsigned int          lookup_index,
                                             const hb_codepoint_t *glyphs,
                                             unsigned int          glyphs_length,
<span class="line-modified">!                                            hb_bool_t             zero_context)</span>
  {
<span class="line-modified">!   if (unlikely (lookup_index &gt;= hb_ot_layout_from_face (face)-&gt;gsub_lookup_count)) return false;</span>
    OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
  
<span class="line-modified">!   const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
  
<span class="line-modified">!   return l.would_apply (&amp;c, &amp;hb_ot_layout_from_face (face)-&gt;gsub_accels[lookup_index]);</span>
  }
  
  void
<span class="line-modified">! hb_ot_layout_substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>
  {
<span class="line-modified">!   OT::GSUB::substitute_start (font, buffer);</span>
  }
  
  /**
   * hb_ot_layout_lookup_substitute_closure:
   *
<span class="line-new-header">--- 956,86 ---</span>
                                        unsigned int          lookup_index,
                                        const hb_codepoint_t *glyphs,
                                        unsigned int          glyphs_length,
                                        hb_bool_t             zero_context)
  {
<span class="line-modified">!   return hb_ot_layout_lookup_would_substitute_fast (face,</span>
<span class="line-modified">!                                                     lookup_index,</span>
<span class="line-added">+                                                     glyphs, glyphs_length,</span>
<span class="line-added">+                                                     zero_context);</span>
  }
  
<span class="line-modified">! bool</span>
  hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
                                             unsigned int          lookup_index,
                                             const hb_codepoint_t *glyphs,
                                             unsigned int          glyphs_length,
<span class="line-modified">!                                            bool                  zero_context)</span>
  {
<span class="line-modified">!   if (unlikely (lookup_index &gt;= face-&gt;table.GSUB-&gt;lookup_count)) return false;</span>
    OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
  
<span class="line-modified">!   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
  
<span class="line-modified">!   return l.would_apply (&amp;c, &amp;face-&gt;table.GSUB-&gt;accels[lookup_index]);</span>
  }
  
  void
<span class="line-modified">! hb_ot_layout_substitute_start (hb_font_t    *font,</span>
<span class="line-added">+                                hb_buffer_t  *buffer)</span>
  {
<span class="line-modified">! _hb_ot_layout_set_glyph_props (font, buffer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,</span>
<span class="line-added">+                                     bool (*filter) (const hb_glyph_info_t *info))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* Merge clusters and delete filtered glyphs.</span>
<span class="line-added">+    * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-added">+   unsigned int j = 0;</span>
<span class="line-added">+   unsigned int count = buffer-&gt;len;</span>
<span class="line-added">+   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-added">+   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-added">+   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (filter (&amp;info[i]))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       /* Merge clusters.</span>
<span class="line-added">+        * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-added">+ </span>
<span class="line-added">+       unsigned int cluster = info[i].cluster;</span>
<span class="line-added">+       if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-added">+         continue; /* Cluster survives; do nothing. */</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (j)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         /* Merge cluster backward. */</span>
<span class="line-added">+         if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-added">+         {</span>
<span class="line-added">+           unsigned int mask = info[i].mask;</span>
<span class="line-added">+           unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-added">+           for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-added">+             buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (i + 1 &lt; count)</span>
<span class="line-added">+         buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-added">+ </span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (j != i)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       info[j] = info[i];</span>
<span class="line-added">+       pos[j] = pos[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+     j++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   buffer-&gt;len = j;</span>
  }
  
  /**
   * hb_ot_layout_lookup_substitute_closure:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 942,14 ***</span>
  void
  hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
                                          unsigned int  lookup_index,
                                          hb_set_t     *glyphs)
  {
<span class="line-modified">!   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
    OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
  
<span class="line-modified">!   const OT::SubstLookup&amp; l = _get_gsub (face).get_lookup (lookup_index);</span>
  
    l.closure (&amp;c, lookup_index);
  }
  
  /**
<span class="line-new-header">--- 1044,14 ---</span>
  void
  hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
                                          unsigned int  lookup_index,
                                          hb_set_t     *glyphs)
  {
<span class="line-modified">!   hb_map_t done_lookups;</span>
    OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
  
<span class="line-modified">!   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
  
    l.closure (&amp;c, lookup_index);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 963,14 ***</span>
  void
  hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
                                           const hb_set_t *lookups,
                                           hb_set_t       *glyphs)
  {
<span class="line-modified">!   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
    OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<span class="line-modified">!   const OT::GSUB&amp; gsub = _get_gsub (face);</span>
  
    unsigned int glyphs_length;
    do
    {
      glyphs_length = glyphs-&gt;get_population ();
      if (lookups != nullptr)
<span class="line-new-header">--- 1065,15 ---</span>
  void
  hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
                                           const hb_set_t *lookups,
                                           hb_set_t       *glyphs)
  {
<span class="line-modified">!   hb_map_t done_lookups;</span>
    OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<span class="line-modified">!   const OT::GSUB&amp; gsub = *face-&gt;table.GSUB-&gt;table;</span>
  
<span class="line-added">+   unsigned int iteration_count = 0;</span>
    unsigned int glyphs_length;
    do
    {
      glyphs_length = glyphs-&gt;get_population ();
      if (lookups != nullptr)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 981,21 ***</span>
      else
      {
        for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
          gsub.get_lookup (i).closure (&amp;c, i);
      }
<span class="line-modified">!   } while (glyphs_length != glyphs-&gt;get_population ());</span>
  }
  
  /*
   * OT::GPOS
   */
  
  hb_bool_t
  hb_ot_layout_has_positioning (hb_face_t *face)
  {
<span class="line-modified">!   return &amp;_get_gpos (face) != &amp;Null(OT::GPOS);</span>
  }
  
  void
  hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
  {
<span class="line-new-header">--- 1084,22 ---</span>
      else
      {
        for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
          gsub.get_lookup (i).closure (&amp;c, i);
      }
<span class="line-modified">!   } while (iteration_count++ &lt;= HB_CLOSURE_MAX_STAGES &amp;&amp;</span>
<span class="line-added">+            glyphs_length != glyphs-&gt;get_population ());</span>
  }
  
  /*
   * OT::GPOS
   */
  
  hb_bool_t
  hb_ot_layout_has_positioning (hb_face_t *face)
  {
<span class="line-modified">!   return face-&gt;table.GPOS-&gt;table-&gt;has_data ();</span>
  }
  
  void
  hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1018,18 ***</span>
   * hb_ot_layout_get_size_params:
   *
   * Since: 0.9.10
   **/
  hb_bool_t
<span class="line-modified">! hb_ot_layout_get_size_params (hb_face_t    *face,</span>
<span class="line-modified">!                               unsigned int *design_size,       /* OUT.  May be nullptr */</span>
<span class="line-modified">!                               unsigned int *subfamily_id,      /* OUT.  May be nullptr */</span>
<span class="line-modified">!                               unsigned int *subfamily_name_id, /* OUT.  May be nullptr */</span>
<span class="line-modified">!                               unsigned int *range_start,       /* OUT.  May be nullptr */</span>
<span class="line-modified">!                               unsigned int *range_end          /* OUT.  May be nullptr */)</span>
  {
<span class="line-modified">!   const OT::GPOS &amp;gpos = _get_gpos (face);</span>
    const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
  
    unsigned int num_features = gpos.get_feature_count ();
    for (unsigned int i = 0; i &lt; num_features; i++)
    {
<span class="line-new-header">--- 1122,18 ---</span>
   * hb_ot_layout_get_size_params:
   *
   * Since: 0.9.10
   **/
  hb_bool_t
<span class="line-modified">! hb_ot_layout_get_size_params (hb_face_t       *face,</span>
<span class="line-modified">!                               unsigned int    *design_size,       /* OUT.  May be NULL */</span>
<span class="line-modified">!                               unsigned int    *subfamily_id,      /* OUT.  May be NULL */</span>
<span class="line-modified">!                               hb_ot_name_id_t *subfamily_name_id, /* OUT.  May be NULL */</span>
<span class="line-modified">!                               unsigned int    *range_start,       /* OUT.  May be NULL */</span>
<span class="line-modified">!                               unsigned int    *range_end          /* OUT.  May be NULL */)</span>
  {
<span class="line-modified">!   const OT::GPOS &amp;gpos = *face-&gt;table.GPOS-&gt;table;</span>
    const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
  
    unsigned int num_features = gpos.get_feature_count ();
    for (unsigned int i = 0; i &lt; num_features; i++)
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,139 ***</span>
        const OT::Feature &amp;f = gpos.get_feature (i);
        const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
  
        if (params.designSize)
        {
<span class="line-modified">! #define PARAM(a, A) if (a) *a = params.A</span>
<span class="line-modified">!         PARAM (design_size, designSize);</span>
<span class="line-modified">!         PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">!         PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">!         PARAM (range_start, rangeStart);</span>
<span class="line-removed">-         PARAM (range_end, rangeEnd);</span>
<span class="line-removed">- #undef PARAM</span>
  
          return true;
        }
      }
    }
  
<span class="line-modified">! #define PARAM(a, A) if (a) *a = 0</span>
<span class="line-modified">!   PARAM (design_size, designSize);</span>
<span class="line-modified">!   PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">!   PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">!   PARAM (range_start, rangeStart);</span>
<span class="line-removed">-   PARAM (range_end, rangeEnd);</span>
<span class="line-removed">- #undef PARAM</span>
  
    return false;
  }
  
  
  /*
   * Parts of different types are implemented here such that they have direct
   * access to GSUB/GPOS lookups.
   */
  
  
  struct GSUBProxy
  {
<span class="line-modified">!   static const unsigned int table_index = 0;</span>
<span class="line-modified">!   static const bool inplace = false;</span>
    typedef OT::SubstLookup Lookup;
  
    GSUBProxy (hb_face_t *face) :
<span class="line-modified">!     table (*hb_ot_layout_from_face (face)-&gt;gsub),</span>
<span class="line-modified">!     accels (hb_ot_layout_from_face (face)-&gt;gsub_accels) {}</span>
  
    const OT::GSUB &amp;table;
<span class="line-modified">!   const hb_ot_layout_lookup_accelerator_t *accels;</span>
  };
  
  struct GPOSProxy
  {
<span class="line-modified">!   static const unsigned int table_index = 1;</span>
<span class="line-modified">!   static const bool inplace = true;</span>
    typedef OT::PosLookup Lookup;
  
    GPOSProxy (hb_face_t *face) :
<span class="line-modified">!     table (*hb_ot_layout_from_face (face)-&gt;gpos),</span>
<span class="line-modified">!     accels (hb_ot_layout_from_face (face)-&gt;gpos_accels) {}</span>
  
    const OT::GPOS &amp;table;
<span class="line-modified">!   const hb_ot_layout_lookup_accelerator_t *accels;</span>
  };
  
  
<span class="line-removed">- struct hb_get_subtables_context_t :</span>
<span class="line-removed">-        OT::hb_dispatch_context_t&lt;hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY&gt;</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   template &lt;typename Type&gt;</span>
<span class="line-removed">-   static inline bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     const Type *typed_obj = (const Type *) obj;</span>
<span class="line-removed">-     return typed_obj-&gt;apply (c);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   struct hb_applicable_t</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     inline void init (const void *obj_, hb_apply_func_t apply_func_)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       obj = obj_;</span>
<span class="line-removed">-       apply_func = apply_func_;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     inline bool apply (OT::hb_ot_apply_context_t *c) const { return apply_func (obj, c); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private:</span>
<span class="line-removed">-     const void *obj;</span>
<span class="line-removed">-     hb_apply_func_t apply_func;</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   typedef hb_auto_t&lt;hb_vector_t&lt;hb_applicable_t&gt; &gt; array_t;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Dispatch interface. */</span>
<span class="line-removed">-   inline const char *get_name (void) { return &quot;GET_SUBTABLES&quot;; }</span>
<span class="line-removed">-   template &lt;typename T&gt;</span>
<span class="line-removed">-   inline return_t dispatch (const T &amp;obj)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     hb_applicable_t *entry = array.push();</span>
<span class="line-removed">-     entry-&gt;init (&amp;obj, apply_to&lt;T&gt;);</span>
<span class="line-removed">-     return HB_VOID;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   static return_t default_return_value (void) { return HB_VOID; }</span>
<span class="line-removed">-   bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hb_get_subtables_context_t (array_t &amp;array_) :</span>
<span class="line-removed">-                               array (array_),</span>
<span class="line-removed">-                               debug_depth (0) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   array_t &amp;array;</span>
<span class="line-removed">-   unsigned int debug_depth;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  static inline bool
  apply_forward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">!                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">-                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
  {
    bool ret = false;
    hb_buffer_t *buffer = c-&gt;buffer;
    while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
    {
      bool applied = false;
      if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
          (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
          c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
       {
<span class="line-modified">!        for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">-          if (subtables[i].apply (c))</span>
<span class="line-removed">-          {</span>
<span class="line-removed">-            applied = true;</span>
<span class="line-removed">-            break;</span>
<span class="line-removed">-          }</span>
       }
  
      if (applied)
        ret = true;
      else
<span class="line-new-header">--- 1142,206 ---</span>
        const OT::Feature &amp;f = gpos.get_feature (i);
        const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
  
        if (params.designSize)
        {
<span class="line-modified">!         if (design_size) *design_size = params.designSize;</span>
<span class="line-modified">!         if (subfamily_id) *subfamily_id = params.subfamilyID;</span>
<span class="line-modified">!         if (subfamily_name_id) *subfamily_name_id = params.subfamilyNameID;</span>
<span class="line-modified">!         if (range_start) *range_start = params.rangeStart;</span>
<span class="line-modified">!         if (range_end) *range_end = params.rangeEnd;</span>
  
          return true;
        }
      }
    }
  
<span class="line-modified">!   if (design_size) *design_size = 0;</span>
<span class="line-modified">!   if (subfamily_id) *subfamily_id = 0;</span>
<span class="line-modified">!   if (subfamily_name_id) *subfamily_name_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified">!   if (range_start) *range_start = 0;</span>
<span class="line-modified">!   if (range_end) *range_end = 0;</span>
  
    return false;
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_ot_layout_feature_get_name_ids:</span>
<span class="line-added">+  * @face: #hb_face_t to work upon</span>
<span class="line-added">+  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">+  * @feature_index: index of feature to query.</span>
<span class="line-added">+  * @label_id: (out) (allow-none): The name table name ID that specifies a string</span>
<span class="line-added">+  *            for a user-interface label for this feature. (May be NULL.)</span>
<span class="line-added">+  * @tooltip_id: (out) (allow-none): The name table name ID that specifies a string</span>
<span class="line-added">+  *              that an application can use for tooltip text for this</span>
<span class="line-added">+  *              feature. (May be NULL.)</span>
<span class="line-added">+  * @sample_id: (out) (allow-none): The name table name ID that specifies sample text</span>
<span class="line-added">+  *             that illustrates the effect of this feature. (May be NULL.)</span>
<span class="line-added">+  * @num_named_parameters: (out) (allow-none):  Number of named parameters. (May be zero.)</span>
<span class="line-added">+  * @first_param_id: (out) (allow-none): The first name table name ID used to specify</span>
<span class="line-added">+  *                  strings for user-interface labels for the feature</span>
<span class="line-added">+  *                  parameters. (Must be zero if numParameters is zero.)</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Fetches name indices from feature parameters for &quot;Stylistic Set&quot; (&#39;ssXX&#39;) or</span>
<span class="line-added">+  * &quot;Character Variant&quot; (&#39;cvXX&#39;) features.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Return value: true if data found, false otherwise</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ hb_bool_t</span>
<span class="line-added">+ hb_ot_layout_feature_get_name_ids (hb_face_t       *face,</span>
<span class="line-added">+                                    hb_tag_t         table_tag,</span>
<span class="line-added">+                                    unsigned int     feature_index,</span>
<span class="line-added">+                                    hb_ot_name_id_t *label_id,             /* OUT.  May be NULL */</span>
<span class="line-added">+                                    hb_ot_name_id_t *tooltip_id,           /* OUT.  May be NULL */</span>
<span class="line-added">+                                    hb_ot_name_id_t *sample_id,            /* OUT.  May be NULL */</span>
<span class="line-added">+                                    unsigned int    *num_named_parameters, /* OUT.  May be NULL */</span>
<span class="line-added">+                                    hb_ot_name_id_t *first_param_id        /* OUT.  May be NULL */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">+   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">+   if (&amp;feature_params != &amp;Null (OT::FeatureParams))</span>
<span class="line-added">+   {</span>
<span class="line-added">+     const OT::FeatureParamsStylisticSet&amp; ss_params =</span>
<span class="line-added">+       feature_params.get_stylistic_set_params (feature_tag);</span>
<span class="line-added">+     if (&amp;ss_params != &amp;Null (OT::FeatureParamsStylisticSet)) /* ssXX */</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (label_id) *label_id = ss_params.uiNameID;</span>
<span class="line-added">+       // ssXX features don&#39;t have the rest</span>
<span class="line-added">+       if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+       if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+       if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">+       if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">+       feature_params.get_character_variants_params (feature_tag);</span>
<span class="line-added">+     if (&amp;cv_params != &amp;Null (OT::FeatureParamsCharacterVariants)) /* cvXX */</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (label_id) *label_id = cv_params.featUILableNameID;</span>
<span class="line-added">+       if (tooltip_id) *tooltip_id = cv_params.featUITooltipTextNameID;</span>
<span class="line-added">+       if (sample_id) *sample_id = cv_params.sampleTextNameID;</span>
<span class="line-added">+       if (num_named_parameters) *num_named_parameters = cv_params.numNamedParameters;</span>
<span class="line-added">+       if (first_param_id) *first_param_id = cv_params.firstParamUILabelNameID;</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (label_id) *label_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+   if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+   if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+   if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">+   if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_ot_layout_feature_get_characters:</span>
<span class="line-added">+  * @face: #hb_face_t to work upon</span>
<span class="line-added">+  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">+  * @feature_index: index of feature to query.</span>
<span class="line-added">+  * @start_offset: In case the resulting char_count was equal to its input value, there</span>
<span class="line-added">+  *                is a chance there were more characters on the tag so this API can be</span>
<span class="line-added">+  *                called with an offset till resulting char_count gets to a number</span>
<span class="line-added">+  *                lower than input buffer (or consider using just a bigger buffer for</span>
<span class="line-added">+  *                one shot copying).</span>
<span class="line-added">+  * @char_count: (inout) (allow-none): The count of characters for which this feature</span>
<span class="line-added">+  *              provides glyph variants. (May be zero.)</span>
<span class="line-added">+  * @characters: (out caller-allocates) (array length=char_count): A buffer pointer. The Unicode codepoints</span>
<span class="line-added">+  *              of the characters for which this feature provides glyph variants.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Fetches characters listed by designer under feature parameters for &quot;Character</span>
<span class="line-added">+  * Variant&quot; (&quot;cvXX&quot;) features.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Return value: Number of total sample characters in the cvXX feature.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ unsigned int</span>
<span class="line-added">+ hb_ot_layout_feature_get_characters (hb_face_t      *face,</span>
<span class="line-added">+                                      hb_tag_t        table_tag,</span>
<span class="line-added">+                                      unsigned int    feature_index,</span>
<span class="line-added">+                                      unsigned int    start_offset,</span>
<span class="line-added">+                                      unsigned int   *char_count, /* IN/OUT.  May be NULL */</span>
<span class="line-added">+                                      hb_codepoint_t *characters  /* OUT.     May be NULL */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">+   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">+ </span>
<span class="line-added">+   const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">+     feature_params.get_character_variants_params(feature_tag);</span>
<span class="line-added">+ </span>
<span class="line-added">+   unsigned int len = 0;</span>
<span class="line-added">+   if (char_count &amp;&amp; characters &amp;&amp; start_offset &lt; cv_params.characters.len)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     len = MIN (cv_params.characters.len - start_offset, *char_count);</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; len; ++i)</span>
<span class="line-added">+       characters[i] = cv_params.characters[start_offset + i];</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (char_count) *char_count = len;</span>
<span class="line-added">+   return cv_params.characters.len;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  
  /*
   * Parts of different types are implemented here such that they have direct
   * access to GSUB/GPOS lookups.
   */
  
  
  struct GSUBProxy
  {
<span class="line-modified">!   static constexpr unsigned table_index = 0u;</span>
<span class="line-modified">!   static constexpr bool inplace = false;</span>
    typedef OT::SubstLookup Lookup;
  
    GSUBProxy (hb_face_t *face) :
<span class="line-modified">!     table (*face-&gt;table.GSUB-&gt;table),</span>
<span class="line-modified">!     accels (face-&gt;table.GSUB-&gt;accels) {}</span>
  
    const OT::GSUB &amp;table;
<span class="line-modified">!   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
  };
  
  struct GPOSProxy
  {
<span class="line-modified">!   static constexpr unsigned table_index = 1u;</span>
<span class="line-modified">!   static constexpr bool inplace = true;</span>
    typedef OT::PosLookup Lookup;
  
    GPOSProxy (hb_face_t *face) :
<span class="line-modified">!     table (*face-&gt;table.GPOS-&gt;table),</span>
<span class="line-modified">!     accels (face-&gt;table.GPOS-&gt;accels) {}</span>
  
    const OT::GPOS &amp;table;
<span class="line-modified">!   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
  };
  
  
  static inline bool
  apply_forward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">!                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    bool ret = false;
    hb_buffer_t *buffer = c-&gt;buffer;
    while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
    {
      bool applied = false;
      if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
          (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
          c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
       {
<span class="line-modified">!        applied = accel.apply (c);</span>
       }
  
      if (applied)
        ret = true;
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1179,28 ***</span>
    return ret;
  }
  
  static inline bool
  apply_backward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">!                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">-                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
  {
    bool ret = false;
    hb_buffer_t *buffer = c-&gt;buffer;
    do
    {
      if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
          (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
          c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<span class="line-modified">!     {</span>
<span class="line-modified">!      for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">-        if (subtables[i].apply (c))</span>
<span class="line-removed">-        {</span>
<span class="line-removed">-          ret = true;</span>
<span class="line-removed">-          break;</span>
<span class="line-removed">-        }</span>
<span class="line-removed">-     }</span>
      /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
      buffer-&gt;idx--;
  
    }
    while ((int) buffer-&gt;idx &gt;= 0);
<span class="line-new-header">--- 1350,21 ---</span>
    return ret;
  }
  
  static inline bool
  apply_backward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">!                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    bool ret = false;
    hb_buffer_t *buffer = c-&gt;buffer;
    do
    {
      if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
          (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
          c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<span class="line-modified">!      ret |= accel.apply (c);</span>
<span class="line-modified">! </span>
      /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
      buffer-&gt;idx--;
  
    }
    while ((int) buffer-&gt;idx &gt;= 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,32 ***</span>
  
  template &lt;typename Proxy&gt;
  static inline void
  apply_string (OT::hb_ot_apply_context_t *c,
                const typename Proxy::Lookup &amp;lookup,
<span class="line-modified">!               const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
      return;
  
    c-&gt;set_lookup_props (lookup.get_props ());
  
<span class="line-removed">-   hb_get_subtables_context_t::array_t subtables;</span>
<span class="line-removed">-   hb_get_subtables_context_t c_get_subtables (subtables);</span>
<span class="line-removed">-   lookup.dispatch (&amp;c_get_subtables);</span>
<span class="line-removed">- </span>
    if (likely (!lookup.is_reverse ()))
    {
      /* in/out forward substitution/positioning */
<span class="line-modified">!     if (Proxy::table_index == 0)</span>
        buffer-&gt;clear_output ();
      buffer-&gt;idx = 0;
  
      bool ret;
<span class="line-modified">!     ret = apply_forward (c, accel, subtables);</span>
      if (ret)
      {
        if (!Proxy::inplace)
          buffer-&gt;swap_buffers ();
        else
<span class="line-new-header">--- 1373,28 ---</span>
  
  template &lt;typename Proxy&gt;
  static inline void
  apply_string (OT::hb_ot_apply_context_t *c,
                const typename Proxy::Lookup &amp;lookup,
<span class="line-modified">!               const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
      return;
  
    c-&gt;set_lookup_props (lookup.get_props ());
  
    if (likely (!lookup.is_reverse ()))
    {
      /* in/out forward substitution/positioning */
<span class="line-modified">!     if (Proxy::table_index == 0u)</span>
        buffer-&gt;clear_output ();
      buffer-&gt;idx = 0;
  
      bool ret;
<span class="line-modified">!     ret = apply_forward (c, accel);</span>
      if (ret)
      {
        if (!Proxy::inplace)
          buffer-&gt;swap_buffers ();
        else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1242,15 ***</span>
      }
    }
    else
    {
      /* in-place backward substitution/positioning */
<span class="line-modified">!     if (Proxy::table_index == 0)</span>
        buffer-&gt;remove_output ();
      buffer-&gt;idx = buffer-&gt;len - 1;
  
<span class="line-modified">!     apply_backward (c, accel, subtables);</span>
    }
  }
  
  template &lt;typename Proxy&gt;
  inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
<span class="line-new-header">--- 1402,15 ---</span>
      }
    }
    else
    {
      /* in-place backward substitution/positioning */
<span class="line-modified">!     if (Proxy::table_index == 0u)</span>
        buffer-&gt;remove_output ();
      buffer-&gt;idx = buffer-&gt;len - 1;
  
<span class="line-modified">!     apply_backward (c, accel);</span>
    }
  }
  
  template &lt;typename Proxy&gt;
  inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,20 ***</span>
    const unsigned int table_index = proxy.table_index;
    unsigned int i = 0;
    OT::hb_ot_apply_context_t c (table_index, font, buffer);
    c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
  
<span class="line-modified">!   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].len; stage_index++) {</span>
      const stage_map_t *stage = &amp;stages[table_index][stage_index];
      for (; i &lt; stage-&gt;last_lookup; i++)
      {
        unsigned int lookup_index = lookups[table_index][i].index;
        if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
        c.set_lookup_index (lookup_index);
        c.set_lookup_mask (lookups[table_index][i].mask);
        c.set_auto_zwj (lookups[table_index][i].auto_zwj);
        c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
        apply_string&lt;Proxy&gt; (&amp;c,
                             proxy.table.get_lookup (lookup_index),
                             proxy.accels[lookup_index]);
        (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
      }
<span class="line-new-header">--- 1421,25 ---</span>
    const unsigned int table_index = proxy.table_index;
    unsigned int i = 0;
    OT::hb_ot_apply_context_t c (table_index, font, buffer);
    c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
  
<span class="line-modified">!   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].length; stage_index++) {</span>
      const stage_map_t *stage = &amp;stages[table_index][stage_index];
      for (; i &lt; stage-&gt;last_lookup; i++)
      {
        unsigned int lookup_index = lookups[table_index][i].index;
        if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
        c.set_lookup_index (lookup_index);
        c.set_lookup_mask (lookups[table_index][i].mask);
        c.set_auto_zwj (lookups[table_index][i].auto_zwj);
        c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
<span class="line-added">+       if (lookups[table_index][i].random)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         c.set_random (true);</span>
<span class="line-added">+         buffer-&gt;unsafe_to_break_all ();</span>
<span class="line-added">+       }</span>
        apply_string&lt;Proxy&gt; (&amp;c,
                             proxy.table.get_lookup (lookup_index),
                             proxy.accels[lookup_index]);
        (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1300,33 ***</span>
  }
  
  void
  hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
                                  const OT::SubstLookup &amp;lookup,
<span class="line-modified">!                                 const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
  }
  
  
  
  
  /*
<span class="line-modified">!  * OT::BASE</span>
   */
  
<span class="line-modified">! // /**</span>
<span class="line-modified">! //  * hb_ot_base_has_data:</span>
<span class="line-modified">! //  * @face: #hb_face_t to test</span>
<span class="line-modified">! //  *</span>
<span class="line-modified">! //  * This function allows to verify the presence of an OpenType BASE table on the</span>
<span class="line-modified">! //  * face.</span>
<span class="line-modified">! //  *</span>
<span class="line-modified">! //  * Return value: true if face has a BASE table, false otherwise</span>
<span class="line-modified">! //  *</span>
<span class="line-modified">! //  * Since: XXX</span>
<span class="line-modified">! //  **/</span>
<span class="line-modified">! // hb_bool_t</span>
<span class="line-modified">! // hb_ot_base_has_data (hb_face_t *face)</span>
<span class="line-modified">! // {</span>
<span class="line-modified">! //   return &amp;_get_base (face) != &amp;Null(OT::BASE);</span>
<span class="line-modified">! // }</span>
<span class="line-new-header">--- 1465,67 ---</span>
  }
  
  void
  hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
                                  const OT::SubstLookup &amp;lookup,
<span class="line-modified">!                                 const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
  {
    apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
  }
  
<span class="line-added">+ #if 0</span>
<span class="line-added">+ static const OT::BASE&amp; _get_base (hb_face_t *face)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return *face-&gt;table.BASE;</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ hb_bool_t</span>
<span class="line-added">+ hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">+                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">+                            hb_direction_t           direction,</span>
<span class="line-added">+                            hb_tag_t                 script_tag,</span>
<span class="line-added">+                            hb_tag_t                 language_tag,</span>
<span class="line-added">+                            hb_position_t           *coord        /* OUT.  May be NULL. */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   const OT::BASE &amp;base = _get_base (font-&gt;face);</span>
<span class="line-added">+   bool result = base.get_baseline (font, baseline, direction, script_tag,</span>
<span class="line-added">+                                    language_tag, coord);</span>
  
<span class="line-added">+   /* TODO: Simulate https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags#ideographic-em-box */</span>
<span class="line-added">+   if (!result &amp;&amp; coord) *coord = 0;</span>
  
<span class="line-added">+   if (coord) *coord = font-&gt;em_scale_dir (*coord, direction);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* To be moved to public header */</span>
  /*
<span class="line-modified">!  * BASE</span>
   */
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * hb_ot_layout_baseline_t:</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Since: DONTREPLACEME</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! typedef enum {</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_HANG = HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_ICFB = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_ICFT = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;t&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_IDEO = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;e&#39;,&#39;o&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_IDTB = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;t&#39;,&#39;b&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_MATH = HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;t&#39;,&#39;h&#39;),</span>
<span class="line-modified">!   HB_OT_LAYOUT_BASELINE_ROMN = HB_TAG(&#39;r&#39;,&#39;o&#39;,&#39;m&#39;,&#39;n&#39;)</span>
<span class="line-modified">! } hb_ot_layout_baseline_t;</span>
<span class="line-added">+ </span>
<span class="line-added">+ HB_EXTERN hb_bool_t</span>
<span class="line-added">+ hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">+                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">+                            hb_direction_t           direction,</span>
<span class="line-added">+                            hb_tag_t                 script_tag,</span>
<span class="line-added">+                            hb_tag_t                 language_tag,</span>
<span class="line-added">+                            hb_position_t           *coord        /* OUT.  May be NULL. */);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
</pre>
<center><a href="hb-ot-layout-jstf-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>