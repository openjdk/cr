<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-khmer-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-layout-private.hh&quot;</span>
 29 
 30 
 31 /*
 32  * Khmer shaper.
 33  */
 34 
<a name="2" id="anc2"></a><span class="line-modified"> 35 struct feature_list_t {</span>
<span class="line-removed"> 36   hb_tag_t tag;</span>
<span class="line-removed"> 37   hb_ot_map_feature_flags_t flags;</span>
<span class="line-removed"> 38 };</span>
<span class="line-removed"> 39 </span>
<span class="line-removed"> 40 static const feature_list_t</span>
 41 khmer_features[] =
 42 {
 43   /*
 44    * Basic features.
<a name="3" id="anc3"></a><span class="line-modified"> 45    * These features are applied in order, one at a time, after initial_reordering.</span>
 46    */
<a name="4" id="anc4"></a><span class="line-modified"> 47   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 48   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 49   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 50   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 51   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_NONE},</span>
 52   /*
 53    * Other features.
<a name="5" id="anc5"></a><span class="line-modified"> 54    * These features are applied all at once, after final_reordering.</span>
<span class="line-modified"> 55    * Default Bengali font in Windows for example has intermixed</span>
<span class="line-modified"> 56    * lookups for init,pres,abvs,blws features.</span>






 57    */
<a name="6" id="anc6"></a><span class="line-removed"> 58   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 59   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 60   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 61   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 62   /* Positioning features, though we don&#39;t care about the types. */</span>
 63   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 64   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 65   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 66 };
 67 
 68 /*
 69  * Must be in the same order as the khmer_features array.
 70  */
 71 enum {
 72   PREF,
 73   BLWF,
 74   ABVF,
 75   PSTF,
 76   CFAR,
 77 
 78   _PRES,
 79   _ABVS,
 80   _BLWS,
 81   _PSTS,
<a name="7" id="anc7"></a>
 82   _DIST,
 83   _ABVM,
 84   _BLWM,
 85 
 86   KHMER_NUM_FEATURES,
<a name="8" id="anc8"></a><span class="line-modified"> 87   KHMER_BASIC_FEATURES = _PRES /* Don&#39;t forget to update this! */</span>
 88 };
 89 
 90 static void
 91 setup_syllables (const hb_ot_shape_plan_t *plan,
 92                  hb_font_t *font,
 93                  hb_buffer_t *buffer);
 94 static void
<a name="9" id="anc9"></a><span class="line-modified"> 95 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 96                     hb_font_t *font,</span>
<span class="line-modified"> 97                     hb_buffer_t *buffer);</span>
<span class="line-removed"> 98 static void</span>
<span class="line-removed"> 99 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">100                   hb_font_t *font,</span>
<span class="line-removed">101                   hb_buffer_t *buffer);</span>
102 static void
103 clear_syllables (const hb_ot_shape_plan_t *plan,
104                  hb_font_t *font,
105                  hb_buffer_t *buffer);
106 
107 static void
108 collect_features_khmer (hb_ot_shape_planner_t *plan)
109 {
110   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
111 
112   /* Do this before any lookups have been applied. */
113   map-&gt;add_gsub_pause (setup_syllables);
<a name="10" id="anc10"></a>
114 
<a name="11" id="anc11"></a><span class="line-modified">115   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-modified">116   /* The Indic specs do not require ccmp, but we apply it here since if</span>
<span class="line-modified">117    * there is a use of it, it&#39;s typically at the beginning. */</span>
<span class="line-modified">118   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">119 </span>







120 
121   unsigned int i = 0;
<a name="12" id="anc12"></a><span class="line-modified">122   map-&gt;add_gsub_pause (initial_reordering);</span>
<span class="line-modified">123   for (; i &lt; KHMER_BASIC_FEATURES; i++) {</span>
<span class="line-removed">124     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">125     map-&gt;add_gsub_pause (nullptr);</span>
<span class="line-removed">126   }</span>
<span class="line-removed">127   map-&gt;add_gsub_pause (final_reordering);</span>
<span class="line-removed">128   for (; i &lt; KHMER_NUM_FEATURES; i++) {</span>
<span class="line-removed">129     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131 </span>
<span class="line-removed">132   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-removed">133   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
134 
135   map-&gt;add_gsub_pause (clear_syllables);
<a name="13" id="anc13"></a>


136 }
137 
138 static void
139 override_features_khmer (hb_ot_shape_planner_t *plan)
140 {
<a name="14" id="anc14"></a>






141   /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
142   if (hb_options ().uniscribe_bug_compatible)
143   {
<a name="15" id="anc15"></a><span class="line-modified">144     plan-&gt;map.add_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), 0, F_GLOBAL);</span>
145   }
146 
<a name="16" id="anc16"></a><span class="line-modified">147   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
148 }
149 
150 
151 struct would_substitute_feature_t
152 {
<a name="17" id="anc17"></a><span class="line-modified">153   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
154   {
155     zero_context = zero_context_;
156     map-&gt;get_stage_lookups (0/*GSUB*/,
157                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
158                             &amp;lookups, &amp;count);
159   }
160 
<a name="18" id="anc18"></a><span class="line-modified">161   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">162                                 unsigned int          glyphs_count,</span>
<span class="line-modified">163                                 hb_face_t            *face) const</span>
164   {
165     for (unsigned int i = 0; i &lt; count; i++)
166       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
167         return true;
168     return false;
169   }
170 
171   private:
172   const hb_ot_map_t::lookup_map_t *lookups;
173   unsigned int count;
174   bool zero_context;
175 };
176 
177 struct khmer_shape_plan_t
178 {
<a name="19" id="anc19"></a><span class="line-modified">179   ASSERT_POD ();</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
182   {
183     hb_codepoint_t glyph = virama_glyph;
184     if (unlikely (virama_glyph == (hb_codepoint_t) -1))
185     {
186       if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
187         glyph = 0;
188       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
189        * Maybe one day... */
190 
191       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
192        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */
193       virama_glyph = glyph;
194     }
195 
196     *pglyph = glyph;
197     return glyph != 0;
198   }
199 
200   mutable hb_codepoint_t virama_glyph;
201 
202   would_substitute_feature_t pref;
203 
204   hb_mask_t mask_array[KHMER_NUM_FEATURES];
205 };
206 
207 static void *
208 data_create_khmer (const hb_ot_shape_plan_t *plan)
209 {
210   khmer_shape_plan_t *khmer_plan = (khmer_shape_plan_t *) calloc (1, sizeof (khmer_shape_plan_t));
211   if (unlikely (!khmer_plan))
212     return nullptr;
213 
214   khmer_plan-&gt;virama_glyph = (hb_codepoint_t) -1;
215 
216   khmer_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), true);
217 
218   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (khmer_plan-&gt;mask_array); i++)
219     khmer_plan-&gt;mask_array[i] = (khmer_features[i].flags &amp; F_GLOBAL) ?
220                                  0 : plan-&gt;map.get_1_mask (khmer_features[i].tag);
221 
222   return khmer_plan;
223 }
224 
225 static void
226 data_destroy_khmer (void *data)
227 {
228   free (data);
229 }
230 
231 
232 enum syllable_type_t {
233   consonant_syllable,
234   broken_cluster,
235   non_khmer_cluster,
236 };
237 
238 #include &quot;hb-ot-shape-complex-khmer-machine.hh&quot;
239 
240 static void
241 setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,
242                    hb_buffer_t              *buffer,
243                    hb_font_t                *font HB_UNUSED)
244 {
245   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);
<a name="20" id="anc20"></a><span class="line-removed">246   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_position);</span>
247 
248   /* We cannot setup masks here.  We save information about characters
249    * and setup masks later on in a pause-callback. */
250 
251   unsigned int count = buffer-&gt;len;
252   hb_glyph_info_t *info = buffer-&gt;info;
253   for (unsigned int i = 0; i &lt; count; i++)
254     set_khmer_properties (info[i]);
255 }
256 
257 static void
258 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
259                  hb_font_t *font HB_UNUSED,
260                  hb_buffer_t *buffer)
261 {
262   find_syllables (buffer);
263   foreach_syllable (buffer, start, end)
264     buffer-&gt;unsafe_to_break (start, end);
265 }
266 
<a name="21" id="anc21"></a><span class="line-removed">267 static int</span>
<span class="line-removed">268 compare_khmer_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270   int a = pa-&gt;khmer_position();</span>
<span class="line-removed">271   int b = pb-&gt;khmer_position();</span>
<span class="line-removed">272 </span>
<span class="line-removed">273   return a &lt; b ? -1 : a == b ? 0 : +1;</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 
277 /* Rules from:
278  * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
279 
280 static void
<a name="22" id="anc22"></a><span class="line-modified">281 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">282                                        hb_face_t *face,</span>
<span class="line-modified">283                                        hb_buffer_t *buffer,</span>
<span class="line-modified">284                                        unsigned int start, unsigned int end)</span>
285 {
286   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
287   hb_glyph_info_t *info = buffer-&gt;info;
288 
<a name="23" id="anc23"></a><span class="line-modified">289   /* 1. Khmer shaping assumes that a syllable will begin with a Cons, IndV, or Number. */</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   /* The first consonant is always the base. */</span>
<span class="line-removed">292   unsigned int base = start;</span>
<span class="line-removed">293   info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">294 </span>
<span class="line-removed">295   /* Mark all subsequent consonants as below. */</span>
<span class="line-removed">296   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">297     if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">298       info[i].khmer_position() = POS_BELOW_C;</span>
<span class="line-removed">299 </span>
<span class="line-removed">300   /* Mark final consonants.  A final consonant is one appearing after a matra,</span>
<span class="line-removed">301    * like in Khmer. */</span>
<span class="line-removed">302   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">303     if (info[i].khmer_category() == OT_M) {</span>
<span class="line-removed">304       for (unsigned int j = i + 1; j &lt; end; j++)</span>
<span class="line-removed">305         if (is_consonant_or_vowel (info[j])) {</span>
<span class="line-removed">306           info[j].khmer_position() = POS_FINAL_C;</span>
<span class="line-removed">307           break;</span>
<span class="line-removed">308         }</span>
<span class="line-removed">309       break;</span>
<span class="line-removed">310     }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312   /* Attach misc marks to previous char to move with them. */</span>
<span class="line-removed">313   {</span>
<span class="line-removed">314     khmer_position_t last_pos = POS_START;</span>
<span class="line-removed">315     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">316     {</span>
<span class="line-removed">317       if ((FLAG_UNSAFE (info[i].khmer_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_Coeng))))</span>
<span class="line-removed">318       {</span>
<span class="line-removed">319         info[i].khmer_position() = last_pos;</span>
<span class="line-removed">320         if (unlikely (info[i].khmer_category() == OT_Coeng &amp;&amp;</span>
<span class="line-removed">321                       info[i].khmer_position() == POS_PRE_M))</span>
<span class="line-removed">322         {</span>
<span class="line-removed">323           /*</span>
<span class="line-removed">324            * Uniscribe doesn&#39;t move the Halant with Left Matra.</span>
<span class="line-removed">325            * TEST: U+092B,U+093F,U+094DE</span>
<span class="line-removed">326            * We follow.  This is important for the Sinhala</span>
<span class="line-removed">327            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA</span>
<span class="line-removed">328            * where U+0DD9 is a left matra and U+0DCA is the virama.</span>
<span class="line-removed">329            * We don&#39;t want to move the virama with the left matra.</span>
<span class="line-removed">330            * TEST: U+0D9A,U+0DDA</span>
<span class="line-removed">331            */</span>
<span class="line-removed">332           for (unsigned int j = i; j &gt; start; j--)</span>
<span class="line-removed">333             if (info[j - 1].khmer_position() != POS_PRE_M) {</span>
<span class="line-removed">334               info[i].khmer_position() = info[j - 1].khmer_position();</span>
<span class="line-removed">335               break;</span>
<span class="line-removed">336             }</span>
<span class="line-removed">337         }</span>
<span class="line-removed">338       } else if (info[i].khmer_position() != POS_SMVD) {</span>
<span class="line-removed">339         last_pos = (khmer_position_t) info[i].khmer_position();</span>
<span class="line-removed">340       }</span>
<span class="line-removed">341     }</span>
<span class="line-removed">342   }</span>
<span class="line-removed">343   /* For post-base consonants let them own anything before them</span>
<span class="line-removed">344    * since the last consonant or matra. */</span>
<span class="line-removed">345   {</span>
<span class="line-removed">346     unsigned int last = base;</span>
<span class="line-removed">347     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">348       if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">349       {</span>
<span class="line-removed">350         for (unsigned int j = last + 1; j &lt; i; j++)</span>
<span class="line-removed">351           if (info[j].khmer_position() &lt; POS_SMVD)</span>
<span class="line-removed">352             info[j].khmer_position() = info[i].khmer_position();</span>
<span class="line-removed">353         last = i;</span>
<span class="line-removed">354       } else if (info[i].khmer_category() == OT_M)</span>
<span class="line-removed">355         last = i;</span>
<span class="line-removed">356   }</span>
<span class="line-removed">357 </span>
358   {
<a name="24" id="anc24"></a><span class="line-removed">359     /* Use syllable() for sort accounting temporarily. */</span>
<span class="line-removed">360     unsigned int syllable = info[start].syllable();</span>
<span class="line-removed">361     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">362       info[i].syllable() = i - start;</span>
<span class="line-removed">363 </span>
<span class="line-removed">364     /* Sit tight, rock &#39;n roll! */</span>
<span class="line-removed">365     hb_stable_sort (info + start, end - start, compare_khmer_order);</span>
<span class="line-removed">366     /* Find base again */</span>
<span class="line-removed">367     base = end;</span>
<span class="line-removed">368     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">369       if (info[i].khmer_position() == POS_BASE_C)</span>
<span class="line-removed">370       {</span>
<span class="line-removed">371         base = i;</span>
<span class="line-removed">372         break;</span>
<span class="line-removed">373       }</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     if (unlikely (end - start &gt;= 127))</span>
<span class="line-removed">376       buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">377     else</span>
<span class="line-removed">378       /* Note!  syllable() is a one-byte field. */</span>
<span class="line-removed">379       for (unsigned int i = base; i &lt; end; i++)</span>
<span class="line-removed">380         if (info[i].syllable() != 255)</span>
<span class="line-removed">381         {</span>
<span class="line-removed">382           unsigned int max = i;</span>
<span class="line-removed">383           unsigned int j = start + info[i].syllable();</span>
<span class="line-removed">384           while (j != i)</span>
<span class="line-removed">385           {</span>
<span class="line-removed">386             max = MAX (max, j);</span>
<span class="line-removed">387             unsigned int next = start + info[j].syllable();</span>
<span class="line-removed">388             info[j].syllable() = 255; /* So we don&#39;t process j later again. */</span>
<span class="line-removed">389             j = next;</span>
<span class="line-removed">390           }</span>
<span class="line-removed">391           if (i != max)</span>
<span class="line-removed">392             buffer-&gt;merge_clusters (i, max + 1);</span>
<span class="line-removed">393         }</span>
<span class="line-removed">394 </span>
<span class="line-removed">395     /* Put syllable back in. */</span>
<span class="line-removed">396     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">397       info[i].syllable() = syllable;</span>
<span class="line-removed">398   }</span>
<span class="line-removed">399 </span>
<span class="line-removed">400   /* Setup masks now */</span>
<span class="line-removed">401 </span>
<span class="line-removed">402   {</span>
<span class="line-removed">403     hb_mask_t mask;</span>
<span class="line-removed">404 </span>
405     /* Post-base */
<a name="25" id="anc25"></a><span class="line-modified">406     mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">407     for (unsigned int i = base + 1; i &lt; end; i++)</span>
408       info[i].mask  |= mask;
409   }
410 
<a name="26" id="anc26"></a><span class="line-modified">411   unsigned int pref_len = 2;</span>
<span class="line-modified">412   if (khmer_plan-&gt;mask_array[PREF] &amp;&amp; base + pref_len &lt; end)</span>
413   {
<a name="27" id="anc27"></a><span class="line-modified">414     /* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. */</span>
<span class="line-modified">415     for (unsigned int i = base + 1; i + pref_len - 1 &lt; end; i++) {</span>
<span class="line-modified">416       hb_codepoint_t glyphs[2];</span>
<span class="line-modified">417       for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">418         glyphs[j] = info[i + j].codepoint;</span>
<span class="line-modified">419       if (khmer_plan-&gt;pref.would_substitute (glyphs, pref_len, face))</span>











420       {
<a name="28" id="anc28"></a><span class="line-modified">421         for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">422           info[i++].mask |= khmer_plan-&gt;mask_array[PREF];</span>








423 
424         /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
425          * Read the feature spec.
426          * This allows distinguishing the following cases with MS Khmer fonts:
427          * U+1784,U+17D2,U+179A,U+17D2,U+1782
428          * U+1784,U+17D2,U+1782,U+17D2,U+179A
429          */
430         if (khmer_plan-&gt;mask_array[CFAR])
<a name="29" id="anc29"></a><span class="line-modified">431           for (; i &lt; end; i++)</span>
<span class="line-modified">432             info[i].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
433 
<a name="30" id="anc30"></a><span class="line-modified">434         break;</span>
435       }
436     }
<a name="31" id="anc31"></a>









437   }
438 }
439 
440 static void
441 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
442                              hb_face_t *face,
443                              hb_buffer_t *buffer,
444                              unsigned int start, unsigned int end)
445 {
446   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
447   switch (syllable_type)
448   {
449     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
450     case consonant_syllable:
<a name="32" id="anc32"></a><span class="line-modified">451      initial_reordering_consonant_syllable (plan, face, buffer, start, end);</span>
452      break;
453 
454     case non_khmer_cluster:
455       break;
456   }
457 }
458 
459 static inline void
460 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
461                        hb_font_t *font,
462                        hb_buffer_t *buffer)
463 {
464   /* Note: This loop is extra overhead, but should not be measurable. */
465   bool has_broken_syllables = false;
466   unsigned int count = buffer-&gt;len;
467   hb_glyph_info_t *info = buffer-&gt;info;
468   for (unsigned int i = 0; i &lt; count; i++)
469     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
470     {
471       has_broken_syllables = true;
472       break;
473     }
474   if (likely (!has_broken_syllables))
475     return;
476 
477 
478   hb_codepoint_t dottedcircle_glyph;
479   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
480     return;
481 
482   hb_glyph_info_t dottedcircle = {0};
483   dottedcircle.codepoint = 0x25CCu;
484   set_khmer_properties (dottedcircle);
485   dottedcircle.codepoint = dottedcircle_glyph;
486 
487   buffer-&gt;clear_output ();
488 
489   buffer-&gt;idx = 0;
490   unsigned int last_syllable = 0;
491   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
492   {
493     unsigned int syllable = buffer-&gt;cur().syllable();
494     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
495     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
496     {
497       last_syllable = syllable;
498 
499       hb_glyph_info_t ginfo = dottedcircle;
500       ginfo.cluster = buffer-&gt;cur().cluster;
501       ginfo.mask = buffer-&gt;cur().mask;
502       ginfo.syllable() = buffer-&gt;cur().syllable();
503       /* TODO Set glyph_props? */
504 
505       /* Insert dottedcircle after possible Repha. */
506       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
507              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
508              buffer-&gt;cur().khmer_category() == OT_Repha)
509         buffer-&gt;next_glyph ();
510 
511       buffer-&gt;output_info (ginfo);
512     }
513     else
514       buffer-&gt;next_glyph ();
515   }
<a name="33" id="anc33"></a><span class="line-removed">516 </span>
517   buffer-&gt;swap_buffers ();
518 }
519 
520 static void
<a name="34" id="anc34"></a><span class="line-modified">521 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">522                     hb_font_t *font,</span>
<span class="line-modified">523                     hb_buffer_t *buffer)</span>
524 {
525   insert_dotted_circles (plan, font, buffer);
526 
527   foreach_syllable (buffer, start, end)
528     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<a name="35" id="anc35"></a><span class="line-removed">529 }</span>
<span class="line-removed">530 </span>
<span class="line-removed">531 static void</span>
<span class="line-removed">532 final_reordering_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">533                            hb_buffer_t *buffer,</span>
<span class="line-removed">534                            unsigned int start, unsigned int end)</span>
<span class="line-removed">535 {</span>
<span class="line-removed">536   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;</span>
<span class="line-removed">537   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">538 </span>
<span class="line-removed">539 </span>
<span class="line-removed">540   /* This function relies heavily on halant glyphs.  Lots of ligation</span>
<span class="line-removed">541    * and possibly multiple substitutions happened prior to this</span>
<span class="line-removed">542    * phase, and that might have messed up our properties.  Recover</span>
<span class="line-removed">543    * from a particular case of that where we&#39;re fairly sure that a</span>
<span class="line-removed">544    * class of OT_Coeng is desired but has been lost. */</span>
<span class="line-removed">545   if (khmer_plan-&gt;virama_glyph)</span>
<span class="line-removed">546   {</span>
<span class="line-removed">547     unsigned int virama_glyph = khmer_plan-&gt;virama_glyph;</span>
<span class="line-removed">548     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">549       if (info[i].codepoint == virama_glyph &amp;&amp;</span>
<span class="line-removed">550           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">551           _hb_glyph_info_multiplied (&amp;info[i]))</span>
<span class="line-removed">552       {</span>
<span class="line-removed">553         /* This will make sure that this glyph passes is_coeng() test. */</span>
<span class="line-removed">554         info[i].khmer_category() = OT_Coeng;</span>
<span class="line-removed">555         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);</span>
<span class="line-removed">556       }</span>
<span class="line-removed">557   }</span>
<span class="line-removed">558 </span>
<span class="line-removed">559 </span>
<span class="line-removed">560   /* 4. Final reordering:</span>
<span class="line-removed">561    *</span>
<span class="line-removed">562    * After the localized forms and basic shaping forms GSUB features have been</span>
<span class="line-removed">563    * applied (see below), the shaping engine performs some final glyph</span>
<span class="line-removed">564    * reordering before applying all the remaining font features to the entire</span>
<span class="line-removed">565    * syllable.</span>
<span class="line-removed">566    */</span>
<span class="line-removed">567 </span>
<span class="line-removed">568   bool try_pref = !!khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-removed">569 </span>
<span class="line-removed">570   /* Find base again */</span>
<span class="line-removed">571   unsigned int base;</span>
<span class="line-removed">572   for (base = start; base &lt; end; base++)</span>
<span class="line-removed">573     if (info[base].khmer_position() &gt;= POS_BASE_C)</span>
<span class="line-removed">574     {</span>
<span class="line-removed">575       if (try_pref &amp;&amp; base + 1 &lt; end)</span>
<span class="line-removed">576       {</span>
<span class="line-removed">577         for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">578           if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">579           {</span>
<span class="line-removed">580             if (!(_hb_glyph_info_substituted (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">581                   _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i])))</span>
<span class="line-removed">582             {</span>
<span class="line-removed">583               /* Ok, this was a &#39;pref&#39; candidate but didn&#39;t form any.</span>
<span class="line-removed">584                * Base is around here... */</span>
<span class="line-removed">585               base = i;</span>
<span class="line-removed">586               while (base &lt; end &amp;&amp; is_coeng (info[base]))</span>
<span class="line-removed">587                 base++;</span>
<span class="line-removed">588               info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">589 </span>
<span class="line-removed">590               try_pref = false;</span>
<span class="line-removed">591             }</span>
<span class="line-removed">592             break;</span>
<span class="line-removed">593           }</span>
<span class="line-removed">594       }</span>
<span class="line-removed">595 </span>
<span class="line-removed">596       if (start &lt; base &amp;&amp; info[base].khmer_position() &gt; POS_BASE_C)</span>
<span class="line-removed">597         base--;</span>
<span class="line-removed">598       break;</span>
<span class="line-removed">599     }</span>
<span class="line-removed">600   if (base == end &amp;&amp; start &lt; base &amp;&amp;</span>
<span class="line-removed">601       is_one_of (info[base - 1], FLAG (OT_ZWJ)))</span>
<span class="line-removed">602     base--;</span>
<span class="line-removed">603   if (base &lt; end)</span>
<span class="line-removed">604     while (start &lt; base &amp;&amp;</span>
<span class="line-removed">605            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_Coeng))))</span>
<span class="line-removed">606       base--;</span>
<span class="line-removed">607 </span>
<span class="line-removed">608 </span>
<span class="line-removed">609   /*   o Reorder matras:</span>
<span class="line-removed">610    *</span>
<span class="line-removed">611    *     If a pre-base matra character had been reordered before applying basic</span>
<span class="line-removed">612    *     features, the glyph can be moved closer to the main consonant based on</span>
<span class="line-removed">613    *     whether half-forms had been formed. Actual position for the matra is</span>
<span class="line-removed">614    *     defined as “after last standalone halant glyph, after initial matra</span>
<span class="line-removed">615    *     position and before the main consonant”. If ZWJ or ZWNJ follow this</span>
<span class="line-removed">616    *     halant, position is moved after it.</span>
<span class="line-removed">617    */</span>
<span class="line-removed">618 </span>
<span class="line-removed">619   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */</span>
<span class="line-removed">620   {</span>
<span class="line-removed">621     /* If we lost track of base, alas, position before last thingy. */</span>
<span class="line-removed">622     unsigned int new_pos = base == end ? base - 2 : base - 1;</span>
<span class="line-removed">623 </span>
<span class="line-removed">624     while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">625            !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_Coeng)))))</span>
<span class="line-removed">626       new_pos--;</span>
<span class="line-removed">627 </span>
<span class="line-removed">628     /* If we found no Halant we are done.</span>
<span class="line-removed">629      * Otherwise only proceed if the Halant does</span>
<span class="line-removed">630      * not belong to the Matra itself! */</span>
<span class="line-removed">631     if (is_coeng (info[new_pos]) &amp;&amp;</span>
<span class="line-removed">632         info[new_pos].khmer_position() != POS_PRE_M)</span>
<span class="line-removed">633     {</span>
<span class="line-removed">634       /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">635       if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))</span>
<span class="line-removed">636         new_pos++;</span>
<span class="line-removed">637     }</span>
<span class="line-removed">638     else</span>
<span class="line-removed">639       new_pos = start; /* No move. */</span>
<span class="line-removed">640 </span>
<span class="line-removed">641     if (start &lt; new_pos &amp;&amp; info[new_pos].khmer_position () != POS_PRE_M)</span>
<span class="line-removed">642     {</span>
<span class="line-removed">643       /* Now go see if there&#39;s actually any matras... */</span>
<span class="line-removed">644       for (unsigned int i = new_pos; i &gt; start; i--)</span>
<span class="line-removed">645         if (info[i - 1].khmer_position () == POS_PRE_M)</span>
<span class="line-removed">646         {</span>
<span class="line-removed">647           unsigned int old_pos = i - 1;</span>
<span class="line-removed">648           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */</span>
<span class="line-removed">649             base--;</span>
<span class="line-removed">650 </span>
<span class="line-removed">651           hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">652           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));</span>
<span class="line-removed">653           info[new_pos] = tmp;</span>
<span class="line-removed">654 </span>
<span class="line-removed">655           /* Note: this merge_clusters() is intentionally *after* the reordering.</span>
<span class="line-removed">656            * Indic matra reordering is special and tricky... */</span>
<span class="line-removed">657           buffer-&gt;merge_clusters (new_pos, MIN (end, base + 1));</span>
<span class="line-removed">658 </span>
<span class="line-removed">659           new_pos--;</span>
<span class="line-removed">660         }</span>
<span class="line-removed">661     } else {</span>
<span class="line-removed">662       for (unsigned int i = start; i &lt; base; i++)</span>
<span class="line-removed">663         if (info[i].khmer_position () == POS_PRE_M) {</span>
<span class="line-removed">664           buffer-&gt;merge_clusters (i, MIN (end, base + 1));</span>
<span class="line-removed">665           break;</span>
<span class="line-removed">666         }</span>
<span class="line-removed">667     }</span>
<span class="line-removed">668   }</span>
<span class="line-removed">669 </span>
<span class="line-removed">670 </span>
<span class="line-removed">671   /*   o Reorder pre-base-reordering consonants:</span>
<span class="line-removed">672    *</span>
<span class="line-removed">673    *     If a pre-base-reordering consonant is found, reorder it according to</span>
<span class="line-removed">674    *     the following rules:</span>
<span class="line-removed">675    */</span>
<span class="line-removed">676 </span>
<span class="line-removed">677   if (try_pref &amp;&amp; base + 1 &lt; end) /* Otherwise there can&#39;t be any pre-base-reordering Ra. */</span>
<span class="line-removed">678   {</span>
<span class="line-removed">679     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">680       if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">681       {</span>
<span class="line-removed">682         /*       1. Only reorder a glyph produced by substitution during application</span>
<span class="line-removed">683          *          of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with</span>
<span class="line-removed">684          *          the feature generally but block it in certain contexts.)</span>
<span class="line-removed">685          */</span>
<span class="line-removed">686         /* Note: We just check that something got substituted.  We don&#39;t check that</span>
<span class="line-removed">687          * the &lt;pref&gt; feature actually did it...</span>
<span class="line-removed">688          *</span>
<span class="line-removed">689          * Reorder pref only if it ligated. */</span>
<span class="line-removed">690         if (_hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i]))</span>
<span class="line-removed">691         {</span>
<span class="line-removed">692           /*</span>
<span class="line-removed">693            *       2. Try to find a target position the same way as for pre-base matra.</span>
<span class="line-removed">694            *          If it is found, reorder pre-base consonant glyph.</span>
<span class="line-removed">695            *</span>
<span class="line-removed">696            *       3. If position is not found, reorder immediately before main</span>
<span class="line-removed">697            *          consonant.</span>
<span class="line-removed">698            */</span>
<span class="line-removed">699 </span>
<span class="line-removed">700           unsigned int new_pos = base;</span>
<span class="line-removed">701           while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">702                  !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_Coeng))))</span>
<span class="line-removed">703             new_pos--;</span>
<span class="line-removed">704 </span>
<span class="line-removed">705           /* In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a</span>
<span class="line-removed">706            * split matra, it should be reordered to *before* the left part of such matra. */</span>
<span class="line-removed">707           if (new_pos &gt; start &amp;&amp; info[new_pos - 1].khmer_category() == OT_M)</span>
<span class="line-removed">708           {</span>
<span class="line-removed">709             unsigned int old_pos = i;</span>
<span class="line-removed">710             for (unsigned int j = base + 1; j &lt; old_pos; j++)</span>
<span class="line-removed">711               if (info[j].khmer_category() == OT_M)</span>
<span class="line-removed">712               {</span>
<span class="line-removed">713                 new_pos--;</span>
<span class="line-removed">714                 break;</span>
<span class="line-removed">715               }</span>
<span class="line-removed">716           }</span>
<span class="line-removed">717 </span>
<span class="line-removed">718           if (new_pos &gt; start &amp;&amp; is_coeng (info[new_pos - 1]))</span>
<span class="line-removed">719           {</span>
<span class="line-removed">720             /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">721             if (new_pos &lt; end &amp;&amp; is_joiner (info[new_pos]))</span>
<span class="line-removed">722               new_pos++;</span>
<span class="line-removed">723           }</span>
<span class="line-removed">724 </span>
<span class="line-removed">725           {</span>
<span class="line-removed">726             unsigned int old_pos = i;</span>
<span class="line-removed">727 </span>
<span class="line-removed">728             buffer-&gt;merge_clusters (new_pos, old_pos + 1);</span>
<span class="line-removed">729             hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">730             memmove (&amp;info[new_pos + 1], &amp;info[new_pos], (old_pos - new_pos) * sizeof (info[0]));</span>
<span class="line-removed">731             info[new_pos] = tmp;</span>
<span class="line-removed">732 </span>
<span class="line-removed">733             if (new_pos &lt;= base &amp;&amp; base &lt; old_pos)</span>
<span class="line-removed">734               base++;</span>
<span class="line-removed">735           }</span>
<span class="line-removed">736         }</span>
<span class="line-removed">737 </span>
<span class="line-removed">738         break;</span>
<span class="line-removed">739       }</span>
<span class="line-removed">740   }</span>
<span class="line-removed">741 </span>
<span class="line-removed">742 </span>
<span class="line-removed">743   /*</span>
<span class="line-removed">744    * Finish off the clusters and go home!</span>
<span class="line-removed">745    */</span>
<span class="line-removed">746   if (hb_options ().uniscribe_bug_compatible)</span>
<span class="line-removed">747   {</span>
<span class="line-removed">748     /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.</span>
<span class="line-removed">749      * This means, half forms are submerged into the main consonant&#39;s cluster.</span>
<span class="line-removed">750      * This is unnecessary, and makes cursor positioning harder, but that&#39;s what</span>
<span class="line-removed">751      * Uniscribe does. */</span>
<span class="line-removed">752     buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">753   }</span>
<span class="line-removed">754 }</span>
<span class="line-removed">755 </span>
<span class="line-removed">756 </span>
<span class="line-removed">757 static void</span>
<span class="line-removed">758 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">759                   hb_font_t *font HB_UNUSED,</span>
<span class="line-removed">760                   hb_buffer_t *buffer)</span>
<span class="line-removed">761 {</span>
<span class="line-removed">762   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">763   if (unlikely (!count)) return;</span>
<span class="line-removed">764 </span>
<span class="line-removed">765   foreach_syllable (buffer, start, end)</span>
<span class="line-removed">766     final_reordering_syllable (plan, buffer, start, end);</span>
767 
768   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);
<a name="36" id="anc36"></a><span class="line-removed">769   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_position);</span>
770 }
771 
<a name="37" id="anc37"></a><span class="line-removed">772 </span>
773 static void
774 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
775                  hb_font_t *font HB_UNUSED,
776                  hb_buffer_t *buffer)
777 {
778   hb_glyph_info_t *info = buffer-&gt;info;
779   unsigned int count = buffer-&gt;len;
780   for (unsigned int i = 0; i &lt; count; i++)
781     info[i].syllable() = 0;
782 }
783 
784 
785 static bool
786 decompose_khmer (const hb_ot_shape_normalize_context_t *c,
787                  hb_codepoint_t  ab,
788                  hb_codepoint_t *a,
789                  hb_codepoint_t *b)
790 {
791   switch (ab)
792   {
793     /*
794      * Decompose split matras that don&#39;t have Unicode decompositions.
795      */
796 
797     /* Khmer */
798     case 0x17BEu  : *a = 0x17C1u; *b= 0x17BEu; return true;
799     case 0x17BFu  : *a = 0x17C1u; *b= 0x17BFu; return true;
800     case 0x17C0u  : *a = 0x17C1u; *b= 0x17C0u; return true;
801     case 0x17C4u  : *a = 0x17C1u; *b= 0x17C4u; return true;
802     case 0x17C5u  : *a = 0x17C1u; *b= 0x17C5u; return true;
803   }
804 
805   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);
806 }
807 
808 static bool
809 compose_khmer (const hb_ot_shape_normalize_context_t *c,
810                hb_codepoint_t  a,
811                hb_codepoint_t  b,
812                hb_codepoint_t *ab)
813 {
814   /* Avoid recomposing split matras. */
815   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
816     return false;
817 
818   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
819 }
820 
821 
822 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =
823 {
824   collect_features_khmer,
825   override_features_khmer,
826   data_create_khmer,
827   data_destroy_khmer,
828   nullptr, /* preprocess_text */
829   nullptr, /* postprocess_glyphs */
830   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
831   decompose_khmer,
832   compose_khmer,
833   setup_masks_khmer,
<a name="38" id="anc38"></a><span class="line-modified">834   nullptr, /* disable_otl */</span>
835   nullptr, /* reorder_marks */
836   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
837   false, /* fallback_position */
838 };
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>