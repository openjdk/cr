<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psOldGen.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psParallelCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psParallelCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
<span class="line-modified">  33 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
<span class="line-removed">  36 #include &quot;gc/parallel/pcTasks.hpp&quot;</span>
  37 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  38 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  39 #include &quot;gc/parallel/psOldGen.hpp&quot;
  40 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  41 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;

  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/referencePolicy.hpp&quot;
  53 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  54 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="line-modified">  55 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

  56 #include &quot;gc/shared/weakProcessor.hpp&quot;


  57 #include &quot;logging/log.hpp&quot;
  58 #include &quot;memory/iterator.inline.hpp&quot;
  59 #include &quot;memory/resourceArea.hpp&quot;

  60 #include &quot;oops/access.inline.hpp&quot;
  61 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  62 #include &quot;oops/instanceKlass.inline.hpp&quot;
  63 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  64 #include &quot;oops/methodData.hpp&quot;
  65 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  66 #include &quot;oops/oop.inline.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/safepoint.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;services/management.hpp&quot;
  72 #include &quot;services/memTracker.hpp&quot;
  73 #include &quot;services/memoryService.hpp&quot;
  74 #include &quot;utilities/align.hpp&quot;
  75 #include &quot;utilities/debug.hpp&quot;
  76 #include &quot;utilities/events.hpp&quot;
  77 #include &quot;utilities/formatBuffer.hpp&quot;
  78 #include &quot;utilities/macros.hpp&quot;
  79 #include &quot;utilities/stack.inline.hpp&quot;



  80 
  81 #include &lt;math.h&gt;
  82 
  83 // All sizes are in HeapWords.
  84 const size_t ParallelCompactData::Log2RegionSize  = 16; // 64K words
  85 const size_t ParallelCompactData::RegionSize      = (size_t)1 &lt;&lt; Log2RegionSize;
  86 const size_t ParallelCompactData::RegionSizeBytes =
  87   RegionSize &lt;&lt; LogHeapWordSize;
  88 const size_t ParallelCompactData::RegionSizeOffsetMask = RegionSize - 1;
  89 const size_t ParallelCompactData::RegionAddrOffsetMask = RegionSizeBytes - 1;
  90 const size_t ParallelCompactData::RegionAddrMask       = ~RegionAddrOffsetMask;
  91 
  92 const size_t ParallelCompactData::Log2BlockSize   = 7; // 128 words
  93 const size_t ParallelCompactData::BlockSize       = (size_t)1 &lt;&lt; Log2BlockSize;
  94 const size_t ParallelCompactData::BlockSizeBytes  =
  95   BlockSize &lt;&lt; LogHeapWordSize;
  96 const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;
  97 const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;
  98 const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;
  99 
</pre>
<hr />
<pre>
 389   const MutableSpace* space;
 390   do {
 391     space = space_info[id].space();
 392     print_initial_summary_data(summary_data, space);
 393   } while (++id &lt; PSParallelCompact::eden_space_id);
 394 
 395   do {
 396     space = space_info[id].space();
 397     print_generic_summary_data(summary_data, space-&gt;bottom(), space-&gt;top());
 398   } while (++id &lt; PSParallelCompact::last_space_id);
 399 }
 400 #endif  // #ifndef PRODUCT
 401 
 402 #ifdef  ASSERT
 403 size_t add_obj_count;
 404 size_t add_obj_size;
 405 size_t mark_bitmap_count;
 406 size_t mark_bitmap_size;
 407 #endif  // #ifdef ASSERT
 408 
<span class="line-modified"> 409 ParallelCompactData::ParallelCompactData()</span>
<span class="line-modified"> 410 {</span>
<span class="line-modified"> 411   _region_start = 0;</span>
<span class="line-modified"> 412 </span>
<span class="line-modified"> 413   _region_vspace = 0;</span>
<span class="line-modified"> 414   _reserved_byte_size = 0;</span>
<span class="line-modified"> 415   _region_data = 0;</span>
<span class="line-modified"> 416   _region_count = 0;</span>
<span class="line-modified"> 417 </span>
<span class="line-modified"> 418   _block_vspace = 0;</span>
<span class="line-removed"> 419   _block_data = 0;</span>
<span class="line-removed"> 420   _block_count = 0;</span>
<span class="line-removed"> 421 }</span>
 422 
 423 bool ParallelCompactData::initialize(MemRegion covered_region)
 424 {
 425   _region_start = covered_region.start();
 426   const size_t region_size = covered_region.word_size();
 427   DEBUG_ONLY(_region_end = _region_start + region_size;)
 428 
 429   assert(region_align_down(_region_start) == _region_start,
 430          &quot;region start not aligned&quot;);
 431   assert((region_size &amp; RegionSizeOffsetMask) == 0,
 432          &quot;region size not a multiple of RegionSize&quot;);
 433 
 434   bool result = initialize_region_data(region_size) &amp;&amp; initialize_block_data();
 435   return result;
 436 }
 437 
 438 PSVirtualSpace*
 439 ParallelCompactData::create_vspace(size_t count, size_t element_size)
 440 {
 441   const size_t raw_bytes = count * element_size;
</pre>
<hr />
<pre>
 512 {
 513   const RegionData* cur_cp = region(region_idx);
 514   const RegionData* const end_cp = region(region_count() - 1);
 515 
 516   HeapWord* result = region_to_addr(region_idx);
 517   if (cur_cp &lt; end_cp) {
 518     do {
 519       result += cur_cp-&gt;partial_obj_size();
 520     } while (cur_cp-&gt;partial_obj_size() == RegionSize &amp;&amp; ++cur_cp &lt; end_cp);
 521   }
 522   return result;
 523 }
 524 
 525 void ParallelCompactData::add_obj(HeapWord* addr, size_t len)
 526 {
 527   const size_t obj_ofs = pointer_delta(addr, _region_start);
 528   const size_t beg_region = obj_ofs &gt;&gt; Log2RegionSize;
 529   const size_t end_region = (obj_ofs + len - 1) &gt;&gt; Log2RegionSize;
 530 
 531   DEBUG_ONLY(Atomic::inc(&amp;add_obj_count);)
<span class="line-modified"> 532   DEBUG_ONLY(Atomic::add(len, &amp;add_obj_size);)</span>
 533 
 534   if (beg_region == end_region) {
 535     // All in one region.
 536     _region_data[beg_region].add_live_obj(len);
 537     return;
 538   }
 539 
 540   // First region.
 541   const size_t beg_ofs = region_offset(addr);
 542   _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);
 543 
 544   Klass* klass = ((oop)addr)-&gt;klass();
 545   // Middle regions--completely spanned by this object.
 546   for (size_t region = beg_region + 1; region &lt; end_region; ++region) {
 547     _region_data[region].set_partial_obj_size(RegionSize);
 548     _region_data[region].set_partial_obj_addr(addr);
 549   }
 550 
 551   // Last region.
 552   const size_t end_ofs = region_offset(addr + len - 1);
</pre>
<hr />
<pre>
 941   _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) / 100.0;
 942   _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) / 100.0;
 943   _dwl_first_term = 1.0 / (sqrt(2.0 * M_PI) * _dwl_std_dev);
 944   DEBUG_ONLY(_dwl_initialized = true;)
 945   _dwl_adjustment = normal_distribution(1.0);
 946 }
 947 
 948 void
 949 PSParallelCompact::clear_data_covering_space(SpaceId id)
 950 {
 951   // At this point, top is the value before GC, new_top() is the value that will
 952   // be set at the end of GC.  The marking bitmap is cleared to top; nothing
 953   // should be marked above top.  The summary data is cleared to the larger of
 954   // top &amp; new_top.
 955   MutableSpace* const space = _space_info[id].space();
 956   HeapWord* const bot = space-&gt;bottom();
 957   HeapWord* const top = space-&gt;top();
 958   HeapWord* const max_top = MAX2(top, _space_info[id].new_top());
 959 
 960   const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);
<span class="line-modified"> 961   const idx_t end_bit = BitMap::word_align_up(_mark_bitmap.addr_to_bit(top));</span>
 962   _mark_bitmap.clear_range(beg_bit, end_bit);
 963 
 964   const size_t beg_region = _summary_data.addr_to_region_idx(bot);
 965   const size_t end_region =
 966     _summary_data.addr_to_region_idx(_summary_data.region_align_up(max_top));
 967   _summary_data.clear_range(beg_region, end_region);
 968 
 969   // Clear the data used to &#39;split&#39; regions.
 970   SplitInfo&amp; split_info = _space_info[id].split_info();
 971   if (split_info.is_valid()) {
 972     split_info.clear();
 973   }
 974   DEBUG_ONLY(split_info.verify_clear();)
 975 }
 976 
 977 void PSParallelCompact::pre_compact()
 978 {
 979   // Update the from &amp; to space pointers in space_info, since they are swapped
 980   // at each young gen gc.  Do the update unconditionally (even though a
 981   // promotion failure does not swap spaces) because an unknown number of young
</pre>
<hr />
<pre>
 997   heap-&gt;print_heap_before_gc();
 998   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
 999 
1000   // Fill in TLABs
1001   heap-&gt;ensure_parsability(true);  // retire TLABs
1002 
1003   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1004     HandleMark hm;  // Discard invalid handles created during verification
1005     Universe::verify(&quot;Before GC&quot;);
1006   }
1007 
1008   // Verify object start arrays
1009   if (VerifyObjectStartArray &amp;&amp;
1010       VerifyBeforeGC) {
1011     heap-&gt;old_gen()-&gt;verify_object_start_array();
1012   }
1013 
1014   DEBUG_ONLY(mark_bitmap()-&gt;verify_clear();)
1015   DEBUG_ONLY(summary_data().verify_clear();)
1016 
<span class="line-removed">1017   // Have worker threads release resources the next time they run a task.</span>
<span class="line-removed">1018   gc_task_manager()-&gt;release_all_resources();</span>
<span class="line-removed">1019 </span>
1020   ParCompactionManager::reset_all_bitmap_query_caches();
1021 }
1022 
1023 void PSParallelCompact::post_compact()
1024 {
1025   GCTraceTime(Info, gc, phases) tm(&quot;Post Compact&quot;, &amp;_gc_timer);

1026 
1027   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1028     // Clear the marking bitmap, summary data and split info.
1029     clear_data_covering_space(SpaceId(id));
1030     // Update top().  Must be done after clearing the bitmap and summary data.
1031     _space_info[id].publish_new_top();
1032   }
1033 
1034   MutableSpace* const eden_space = _space_info[eden_space_id].space();
1035   MutableSpace* const from_space = _space_info[from_space_id].space();
1036   MutableSpace* const to_space   = _space_info[to_space_id].space();
1037 
1038   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1039   bool eden_empty = eden_space-&gt;is_empty();
1040   if (!eden_empty) {
1041     eden_empty = absorb_live_data_from_eden(heap-&gt;size_policy(),
1042                                             heap-&gt;young_gen(), heap-&gt;old_gen());
1043   }
1044 
1045   // Update heap occupancy information which is used as input to the soft ref
1046   // clearing policy at the next gc.
1047   Universe::update_heap_info_at_gc();
1048 
1049   bool young_gen_empty = eden_empty &amp;&amp; from_space-&gt;is_empty() &amp;&amp;
1050     to_space-&gt;is_empty();
1051 
1052   PSCardTable* ct = heap-&gt;card_table();
1053   MemRegion old_mr = heap-&gt;old_gen()-&gt;reserved();
1054   if (young_gen_empty) {
1055     ct-&gt;clear(MemRegion(old_mr.start(), old_mr.end()));
1056   } else {
1057     ct-&gt;invalidate(MemRegion(old_mr.start(), old_mr.end()));
1058   }
1059 
1060   // Delete metaspaces for unloaded class loaders and clean up loader_data graph
1061   ClassLoaderDataGraph::purge();
1062   MetaspaceUtils::verify_metrics();
1063 
<span class="line-modified">1064   heap-&gt;prune_nmethods();</span>
<span class="line-removed">1065   JvmtiExport::gc_epilogue();</span>
1066 
1067 #if COMPILER2_OR_JVMCI
1068   DerivedPointerTable::update_pointers();
1069 #endif
1070 
1071   if (ZapUnusedHeapArea) {
1072     heap-&gt;gen_mangle_unused_area();
1073   }
1074 
1075   // Update time of last GC
1076   reset_millis_since_last_gc();
1077 }
1078 
1079 HeapWord*
1080 PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,
1081                                                     bool maximum_compaction)
1082 {
1083   const size_t region_size = ParallelCompactData::RegionSize;
1084   const ParallelCompactData&amp; sd = summary_data();
1085 
</pre>
<hr />
<pre>
1097   }
1098 
1099   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1100   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1101   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1102   if (maximum_compaction || cp == end_cp || interval_ended) {
1103     _maximum_compaction_gc_num = total_invocations();
1104     return sd.region_to_addr(cp);
1105   }
1106 
1107   HeapWord* const new_top = _space_info[id].new_top();
1108   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1109   const size_t space_used = space-&gt;used_in_words();
1110   const size_t space_capacity = space-&gt;capacity_in_words();
1111 
1112   const double cur_density = double(space_live) / space_capacity;
1113   const double deadwood_density =
1114     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1115   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1116 
<span class="line-modified">1117   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1118     tty-&gt;print_cr(&quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1119                   cur_density, deadwood_density, deadwood_goal);</span>
<span class="line-modified">1120     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1121                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1122                   space_live, space_used,</span>
<span class="line-modified">1123                   space_capacity);</span>
<span class="line-modified">1124   }</span>
1125 
1126   // XXX - Use binary search?
1127   HeapWord* dense_prefix = sd.region_to_addr(cp);
1128   const RegionData* full_cp = cp;
1129   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1130   while (cp &lt; end_cp) {
1131     HeapWord* region_destination = cp-&gt;destination();
1132     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
<span class="line-modified">1133     if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1134       tty-&gt;print_cr(&quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;</span>
<span class="line-modified">1135                     &quot;dp=&quot; PTR_FORMAT &quot; &quot; &quot;cdw=&quot; SIZE_FORMAT_W(8),</span>
<span class="line-modified">1136                     sd.region(cp), p2i(region_destination),</span>
<span class="line-modified">1137                     p2i(dense_prefix), cur_deadwood);</span>
<span class="line-modified">1138     }</span>
1139 
1140     if (cur_deadwood &gt;= deadwood_goal) {
1141       // Found the region that has the correct amount of deadwood to the left.
1142       // This typically occurs after crossing a fairly sparse set of regions, so
1143       // iterate backwards over those sparse regions, looking for the region
1144       // that has the lowest density of live objects &#39;to the right.&#39;
1145       size_t space_to_left = sd.region(cp) * region_size;
1146       size_t live_to_left = space_to_left - cur_deadwood;
1147       size_t space_to_right = space_capacity - space_to_left;
1148       size_t live_to_right = space_live - live_to_left;
1149       double density_to_right = double(live_to_right) / space_to_right;
1150       while (cp &gt; full_cp) {
1151         --cp;
1152         const size_t prev_region_live_to_right = live_to_right -
1153           cp-&gt;data_size();
1154         const size_t prev_region_space_to_right = space_to_right + region_size;
1155         double prev_region_density_to_right =
1156           double(prev_region_live_to_right) / prev_region_space_to_right;
1157         if (density_to_right &lt;= prev_region_density_to_right) {
1158           return dense_prefix;
1159         }
<span class="line-modified">1160         if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1161           tty-&gt;print_cr(&quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;</span>
<span class="line-modified">1162                         &quot;pc_d2r=%10.8f&quot;, sd.region(cp), density_to_right,</span>
<span class="line-modified">1163                         prev_region_density_to_right);</span>
<span class="line-modified">1164         }</span>


1165         dense_prefix -= region_size;
1166         live_to_right = prev_region_live_to_right;
1167         space_to_right = prev_region_space_to_right;
1168         density_to_right = prev_region_density_to_right;
1169       }
1170       return dense_prefix;
1171     }
1172 
1173     dense_prefix += region_size;
1174     ++cp;
1175   }
1176 
1177   return dense_prefix;
1178 }
1179 
1180 #ifndef PRODUCT
1181 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1182                                                  const SpaceId id,
1183                                                  const bool maximum_compaction,
1184                                                  HeapWord* const addr)
1185 {
1186   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1187   RegionData* const cp = summary_data().region(region_idx);
1188   const MutableSpace* const space = _space_info[id].space();
1189   HeapWord* const new_top = _space_info[id].new_top();
1190 
1191   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1192   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1193   const size_t space_cap = space-&gt;capacity_in_words();
1194   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1195   const size_t live_to_right = new_top - cp-&gt;destination();
1196   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1197 
<span class="line-modified">1198   tty-&gt;print_cr(&quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;</span>
<span class="line-modified">1199                 &quot;spl=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1200                 &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;</span>
<span class="line-modified">1201                 &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT</span>
<span class="line-modified">1202                 &quot; ratio=%10.8f&quot;,</span>
<span class="line-modified">1203                 algorithm, p2i(addr), region_idx,</span>
<span class="line-modified">1204                 space_live,</span>
<span class="line-modified">1205                 dead_to_left, dead_to_left_pct,</span>
<span class="line-modified">1206                 dead_to_right, live_to_right,</span>
<span class="line-modified">1207                 double(dead_to_right) / live_to_right);</span>

1208 }
1209 #endif  // #ifndef PRODUCT
1210 
1211 // Return a fraction indicating how much of the generation can be treated as
1212 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1213 // based on the density of live objects in the generation to determine a limit,
1214 // which is then adjusted so the return value is min_percent when the density is
1215 // 1.
1216 //
1217 // The following table shows some return values for a different values of the
1218 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1219 // min_percent is 1.
1220 //
1221 //                          fraction allowed as dead wood
1222 //         -----------------------------------------------------------------
1223 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1224 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1225 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1226 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1227 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
</pre>
<hr />
<pre>
1395   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1396   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1397   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1398     total_invocations() == HeapFirstMaximumCompactionCount;
1399   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1400     _maximum_compaction_gc_num = total_invocations();
1401     return sd.region_to_addr(full_cp);
1402   }
1403 
1404   const size_t space_live = pointer_delta(new_top, bottom);
1405   const size_t space_used = space-&gt;used_in_words();
1406   const size_t space_capacity = space-&gt;capacity_in_words();
1407 
1408   const double density = double(space_live) / double(space_capacity);
1409   const size_t min_percent_free = MarkSweepDeadRatio;
1410   const double limiter = dead_wood_limiter(density, min_percent_free);
1411   const size_t dead_wood_max = space_used - space_live;
1412   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1413                                       dead_wood_max);
1414 
<span class="line-modified">1415   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1416     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1417                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1418                   space_live, space_used,</span>
<span class="line-modified">1419                   space_capacity);</span>
<span class="line-modified">1420     tty-&gt;print_cr(&quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;</span>
<span class="line-modified">1421                   &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1422                   density, min_percent_free, limiter,</span>
<span class="line-modified">1423                   dead_wood_max, dead_wood_limit);</span>
<span class="line-modified">1424   }</span>
1425 
1426   // Locate the region with the desired amount of dead space to the left.
1427   const RegionData* const limit_cp =
1428     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1429 
1430   // Scan from the first region with dead space to the limit region and find the
1431   // one with the best (largest) reclaimed ratio.
1432   double best_ratio = 0.0;
1433   const RegionData* best_cp = full_cp;
1434   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1435     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1436     if (tmp_ratio &gt; best_ratio) {
1437       best_cp = cp;
1438       best_ratio = tmp_ratio;
1439     }
1440   }
1441 
1442   return sd.region_to_addr(best_cp);
1443 }
1444 
</pre>
<hr />
<pre>
1518     _mark_bitmap.mark_obj(obj_beg, obj_len);
1519     _summary_data.add_obj(obj_beg, obj_len);
1520     assert(start_array(id) != NULL, &quot;sanity&quot;);
1521     start_array(id)-&gt;allocate_block(obj_beg);
1522   }
1523 }
1524 
1525 void
1526 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1527 {
1528   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1529   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1530          &quot;should have been reset in summarize_spaces_quick()&quot;);
1531 
1532   const MutableSpace* space = _space_info[id].space();
1533   if (_space_info[id].new_top() != space-&gt;bottom()) {
1534     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1535     _space_info[id].set_dense_prefix(dense_prefix_end);
1536 
1537 #ifndef PRODUCT
<span class="line-modified">1538     if (TraceParallelOldGCDensePrefix) {</span>
1539       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1540                                dense_prefix_end);
1541       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1542       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1543     }
1544 #endif  // #ifndef PRODUCT
1545 
1546     // Recompute the summary data, taking into account the dense prefix.  If
1547     // every last byte will be reclaimed, then the existing summary data which
1548     // compacts everything can be left in place.
1549     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1550       // If dead space crosses the dense prefix boundary, it is (at least
1551       // partially) filled with a dummy object, marked live and added to the
1552       // summary data.  This simplifies the copy/update phase and must be done
1553       // before the final locations of objects are determined, to prevent
1554       // leaving a fragment of dead space that is too small to fill.
1555       fill_dense_prefix_end(id);
1556 
1557       // Compute the destination of each Region, and thus each object.
1558       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
</pre>
<hr />
<pre>
1592       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1593       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1594       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1595       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1596       src_space_id, space_names[src_space_id],
1597       dst_space_id, space_names[dst_space_id],
1598       p2i(src_beg), p2i(src_end),
1599       _summary_data.addr_to_region_idx(src_beg),
1600       _summary_data.addr_to_region_idx(src_end),
1601       p2i(dst_beg), p2i(dst_end),
1602       _summary_data.addr_to_region_idx(dst_beg),
1603       _summary_data.addr_to_region_idx(dst_end));
1604 }
1605 #endif  // #ifndef PRODUCT
1606 
1607 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1608                                       bool maximum_compaction)
1609 {
1610   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1611 
<span class="line-modified">1612 #ifdef  ASSERT</span>
<span class="line-modified">1613   if (TraceParallelOldGCMarkingPhase) {</span>
<span class="line-modified">1614     tty-&gt;print_cr(&quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1615                   &quot;add_obj_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1616                   add_obj_count, add_obj_size * HeapWordSize);</span>
<span class="line-modified">1617     tty-&gt;print_cr(&quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1618                   &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1619                   mark_bitmap_count, mark_bitmap_size * HeapWordSize);</span>
<span class="line-modified">1620   }</span>
<span class="line-modified">1621 #endif  // #ifdef ASSERT</span>
1622 
1623   // Quick summarization of each space into itself, to see how much is live.
1624   summarize_spaces_quick();
1625 
1626   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1627   NOT_PRODUCT(print_region_ranges());
1628   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1629 
1630   // The amount of live data that will end up in old space (assuming it fits).
1631   size_t old_space_total_live = 0;
1632   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1633     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1634                                           _space_info[id].space()-&gt;bottom());
1635   }
1636 
1637   MutableSpace* const old_space = _space_info[old_space_id].space();
1638   const size_t old_capacity = old_space-&gt;capacity_in_words();
1639   if (old_space_total_live &gt; old_capacity) {
1640     // XXX - should also try to expand
1641     maximum_compaction = true;
</pre>
<hr />
<pre>
1695                                      space-&gt;bottom(), dst_space_end,
1696                                      new_top_addr);
1697       assert(done, &quot;space must fit when compacted into itself&quot;);
1698       assert(*new_top_addr &lt;= space-&gt;top(), &quot;usage should not grow&quot;);
1699     }
1700   }
1701 
1702   log_develop_trace(gc, compaction)(&quot;Summary_phase:  after final summarization&quot;);
1703   NOT_PRODUCT(print_region_ranges());
1704   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1705 }
1706 
1707 // This method should contain all heap-specific policy for invoking a full
1708 // collection.  invoke_no_policy() will only attempt to compact the heap; it
1709 // will do nothing further.  If we need to bail out for policy reasons, scavenge
1710 // before full gc, or any other specialized behavior, it needs to be added here.
1711 //
1712 // Note that this method should only be called from the vm_thread while at a
1713 // safepoint.
1714 //
<span class="line-modified">1715 // Note that the all_soft_refs_clear flag in the collector policy</span>
1716 // may be true because this method can be called without intervening
1717 // activity.  For example when the heap space is tight and full measure
1718 // are being taken to free space.
1719 void PSParallelCompact::invoke(bool maximum_heap_compaction) {
1720   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
1721   assert(Thread::current() == (Thread*)VMThread::vm_thread(),
1722          &quot;should be in vm thread&quot;);
1723 
1724   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1725   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1726   assert(!heap-&gt;is_gc_active(), &quot;not reentrant&quot;);
1727 
1728   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
1729   IsGCActiveMark mark;
1730 
1731   if (ScavengeBeforeFullGC) {
1732     PSScavenge::invoke_no_policy();
1733   }
1734 
1735   const bool clear_all_soft_refs =
</pre>
<hr />
<pre>
1748   if (GCLocker::check_active_before_gc()) {
1749     return false;
1750   }
1751 
1752   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1753 
1754   GCIdMark gc_id_mark;
1755   _gc_timer.register_gc_start();
1756   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
1757 
1758   TimeStamp marking_start;
1759   TimeStamp compaction_start;
1760   TimeStamp collection_exit;
1761 
1762   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1763   PSYoungGen* young_gen = heap-&gt;young_gen();
1764   PSOldGen* old_gen = heap-&gt;old_gen();
1765   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
1766 
1767   // The scope of casr should end after code that can change
<span class="line-modified">1768   // CollectorPolicy::_should_clear_all_soft_refs.</span>
1769   ClearedAllSoftRefs casr(maximum_heap_compaction,
1770                           heap-&gt;soft_ref_policy());
1771 
1772   if (ZapUnusedHeapArea) {
1773     // Save information needed to minimize mangling
1774     heap-&gt;record_gen_tops_before_GC();
1775   }
1776 
1777   // Make sure data structures are sane, make the heap parsable, and do other
1778   // miscellaneous bookkeeping.
1779   pre_compact();
1780 
<span class="line-modified">1781   PreGCValues pre_gc_values(heap);</span>
1782 
1783   // Get the compaction manager reserved for the VM thread.
1784   ParCompactionManager* const vmthread_cm =
<span class="line-modified">1785     ParCompactionManager::manager_array(gc_task_manager()-&gt;workers());</span>
1786 
1787   {
1788     ResourceMark rm;
1789     HandleMark hm;
1790 
<span class="line-modified">1791     // Set the number of GC threads to be used in this collection</span>
<span class="line-modified">1792     gc_task_manager()-&gt;set_active_gang();</span>
<span class="line-modified">1793     gc_task_manager()-&gt;task_idle_workers();</span>


1794 
1795     GCTraceCPUTime tcpu;
1796     GCTraceTime(Info, gc) tm(&quot;Pause Full&quot;, NULL, gc_cause, true);
1797 
1798     heap-&gt;pre_full_gc_dump(&amp;_gc_timer);
1799 
1800     TraceCollectorStats tcs(counters());
1801     TraceMemoryManagerStats tms(heap-&gt;old_gc_manager(), gc_cause);
1802 
1803     if (log_is_enabled(Debug, gc, heap, exit)) {
1804       accumulated_time()-&gt;start();
1805     }
1806 
1807     // Let the size policy know we&#39;re starting
1808     size_policy-&gt;major_collection_begin();
1809 
1810 #if COMPILER2_OR_JVMCI
1811     DerivedPointerTable::clear();
1812 #endif
1813 
</pre>
<hr />
<pre>
1905 
1906       log_debug(gc, ergo)(&quot;AdaptiveSizeStop: collection: %d &quot;, heap-&gt;total_collections());
1907     }
1908 
1909     if (UsePerfData) {
1910       PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
1911       counters-&gt;update_counters();
1912       counters-&gt;update_old_capacity(old_gen-&gt;capacity_in_bytes());
1913       counters-&gt;update_young_capacity(young_gen-&gt;capacity_in_bytes());
1914     }
1915 
1916     heap-&gt;resize_all_tlabs();
1917 
1918     // Resize the metaspace capacity after a collection
1919     MetaspaceGC::compute_new_size();
1920 
1921     if (log_is_enabled(Debug, gc, heap, exit)) {
1922       accumulated_time()-&gt;stop();
1923     }
1924 
<span class="line-modified">1925     young_gen-&gt;print_used_change(pre_gc_values.young_gen_used());</span>
<span class="line-removed">1926     old_gen-&gt;print_used_change(pre_gc_values.old_gen_used());</span>
<span class="line-removed">1927     MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());</span>
1928 
1929     // Track memory usage and detect low memory
1930     MemoryService::track_memory_usage();
1931     heap-&gt;update_counters();
<span class="line-removed">1932     gc_task_manager()-&gt;release_idle_workers();</span>
1933 
1934     heap-&gt;post_full_gc_dump(&amp;_gc_timer);
1935   }
1936 
1937 #ifdef ASSERT
1938   for (size_t i = 0; i &lt; ParallelGCThreads + 1; ++i) {
1939     ParCompactionManager* const cm =
1940       ParCompactionManager::manager_array(int(i));
1941     assert(cm-&gt;marking_stack()-&gt;is_empty(),       &quot;should be empty&quot;);
1942     assert(cm-&gt;region_stack()-&gt;is_empty(), &quot;Region stack &quot; SIZE_FORMAT &quot; is not empty&quot;, i);
1943   }
1944 #endif // ASSERT
1945 
1946   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1947     HandleMark hm;  // Discard invalid handles created during verification
1948     Universe::verify(&quot;After GC&quot;);
1949   }
1950 
1951   // Re-verify object start arrays
1952   if (VerifyObjectStartArray &amp;&amp;
1953       VerifyAfterGC) {
1954     old_gen-&gt;verify_object_start_array();
1955   }
1956 
1957   if (ZapUnusedHeapArea) {
1958     old_gen-&gt;object_space()-&gt;check_mangled_unused_area_complete();
1959   }
1960 
1961   NOT_PRODUCT(ref_processor()-&gt;verify_no_references_recorded());
1962 
1963   collection_exit.update();
1964 
1965   heap-&gt;print_heap_after_gc();
1966   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
1967 
1968   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
1969                          marking_start.ticks(), compaction_start.ticks(),
1970                          collection_exit.ticks());
<span class="line-removed">1971   gc_task_manager()-&gt;print_task_time_stamps();</span>
<span class="line-removed">1972 </span>
<span class="line-removed">1973 #ifdef TRACESPINNING</span>
<span class="line-removed">1974   ParallelTaskTerminator::print_termination_counts();</span>
<span class="line-removed">1975 #endif</span>
1976 
1977   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
1978 
1979   _gc_timer.register_gc_end();
1980 
1981   _gc_tracer.report_dense_prefix(dense_prefix(old_space_id));
1982   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
1983 
1984   return true;
1985 }
1986 
1987 bool PSParallelCompact::absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1988                                              PSYoungGen* young_gen,
1989                                              PSOldGen* old_gen) {
1990   MutableSpace* const eden_space = young_gen-&gt;eden_space();
1991   assert(!eden_space-&gt;is_empty(), &quot;eden must be non-empty&quot;);
1992   assert(young_gen-&gt;virtual_space()-&gt;alignment() ==
1993          old_gen-&gt;virtual_space()-&gt;alignment(), &quot;alignments do not match&quot;);
1994 
<span class="line-modified">1995   // We also return false when it&#39;s a heterogenous heap because old generation cannot absorb data from eden</span>
1996   // when it is allocated on different memory (example, nv-dimm) than young.
1997   if (!(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary) ||
<span class="line-modified">1998       ParallelScavengeHeap::heap()-&gt;ps_collector_policy()-&gt;is_hetero_heap()) {</span>
1999     return false;
2000   }
2001 
2002   // Both generations must be completely committed.
2003   if (young_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2004     return false;
2005   }
2006   if (old_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2007     return false;
2008   }
2009 
2010   // Figure out how much to take from eden.  Include the average amount promoted
2011   // in the total; otherwise the next young gen GC will simply bail out to a
2012   // full GC.
2013   const size_t alignment = old_gen-&gt;virtual_space()-&gt;alignment();
2014   const size_t eden_used = eden_space-&gt;used_in_bytes();
2015   const size_t promoted = (size_t)size_policy-&gt;avg_promoted()-&gt;padded_average();
2016   const size_t absorb_size = align_up(eden_used + promoted, alignment);
2017   const size_t eden_capacity = eden_space-&gt;capacity_in_bytes();
2018 
</pre>
<hr />
<pre>
2056   young_gen-&gt;reset_after_change();
2057   old_space-&gt;set_top(new_top);
2058   old_space-&gt;set_end(new_top);
2059   old_gen-&gt;reset_after_change();
2060 
2061   // Update the object start array for the filler object and the data from eden.
2062   ObjectStartArray* const start_array = old_gen-&gt;start_array();
2063   for (HeapWord* p = unused_start; p &lt; new_top; p += oop(p)-&gt;size()) {
2064     start_array-&gt;allocate_block(p);
2065   }
2066 
2067   // Could update the promoted average here, but it is not typically updated at
2068   // full GCs and the value to use is unclear.  Something like
2069   //
2070   // cur_promoted_avg + absorb_size / number_of_scavenges_since_last_full_gc.
2071 
2072   size_policy-&gt;set_bytes_absorbed_from_eden(absorb_size);
2073   return true;
2074 }
2075 
<span class="line-removed">2076 GCTaskManager* const PSParallelCompact::gc_task_manager() {</span>
<span class="line-removed">2077   assert(ParallelScavengeHeap::gc_task_manager() != NULL,</span>
<span class="line-removed">2078     &quot;shouldn&#39;t return NULL&quot;);</span>
<span class="line-removed">2079   return ParallelScavengeHeap::gc_task_manager();</span>
<span class="line-removed">2080 }</span>
<span class="line-removed">2081 </span>
2082 class PCAddThreadRootsMarkingTaskClosure : public ThreadClosure {
2083 private:
<span class="line-modified">2084   GCTaskQueue* _q;</span>
2085 
2086 public:
<span class="line-modified">2087   PCAddThreadRootsMarkingTaskClosure(GCTaskQueue* q) : _q(q) { }</span>
<span class="line-modified">2088   void do_thread(Thread* t) {</span>
<span class="line-modified">2089     _q-&gt;enqueue(new ThreadRootsMarkingTask(t));</span>
































































































































































2090   }
2091 };
2092 
2093 void PSParallelCompact::marking_phase(ParCompactionManager* cm,
2094                                       bool maximum_heap_compaction,
2095                                       ParallelOldTracer *gc_tracer) {
2096   // Recursively traverse all live objects and mark them
2097   GCTraceTime(Info, gc, phases) tm(&quot;Marking Phase&quot;, &amp;_gc_timer);
2098 
2099   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-modified">2100   uint parallel_gc_threads = heap-&gt;gc_task_manager()-&gt;workers();</span>
<span class="line-removed">2101   uint active_gc_threads = heap-&gt;gc_task_manager()-&gt;active_workers();</span>
<span class="line-removed">2102   TaskQueueSetSuper* qset = ParCompactionManager::stack_array();</span>
<span class="line-removed">2103   TaskTerminator terminator(active_gc_threads, qset);</span>
2104 
2105   PCMarkAndPushClosure mark_and_push_closure(cm);
2106   ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
2107 
2108   // Need new claim bits before marking starts.
2109   ClassLoaderDataGraph::clear_claimed_marks();
2110 
2111   {
2112     GCTraceTime(Debug, gc, phases) tm(&quot;Par Mark&quot;, &amp;_gc_timer);
2113 
<span class="line-modified">2114     ParallelScavengeHeap::ParStrongRootsScope psrs;</span>
<span class="line-modified">2115 </span>
<span class="line-removed">2116     GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::universe));</span>
<span class="line-removed">2119     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::jni_handles));</span>
<span class="line-removed">2120     // We scan the thread roots in parallel</span>
<span class="line-removed">2121     PCAddThreadRootsMarkingTaskClosure cl(q);</span>
<span class="line-removed">2122     Threads::java_threads_and_vm_thread_do(&amp;cl);</span>
<span class="line-removed">2123     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::object_synchronizer));</span>
<span class="line-removed">2124     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::management));</span>
<span class="line-removed">2125     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::system_dictionary));</span>
<span class="line-removed">2126     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::class_loader_data));</span>
<span class="line-removed">2127     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::jvmti));</span>
<span class="line-removed">2128     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::code_cache));</span>
<span class="line-removed">2129 </span>
<span class="line-removed">2130     if (active_gc_threads &gt; 1) {</span>
<span class="line-removed">2131       for (uint j = 0; j &lt; active_gc_threads; j++) {</span>
<span class="line-removed">2132         q-&gt;enqueue(new StealMarkingTask(terminator.terminator()));</span>
<span class="line-removed">2133       }</span>
<span class="line-removed">2134     }</span>
<span class="line-removed">2135 </span>
<span class="line-removed">2136     gc_task_manager()-&gt;execute_and_wait(q);</span>
2137   }
2138 
2139   // Process reference objects found during marking
2140   {
2141     GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
2142 
2143     ReferenceProcessorStats stats;
2144     ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, ref_processor()-&gt;max_num_queues());
2145 
2146     if (ref_processor()-&gt;processing_is_mt()) {
2147       ref_processor()-&gt;set_active_mt_degree(active_gc_threads);
2148 
2149       RefProcTaskExecutor task_executor;
2150       stats = ref_processor()-&gt;process_discovered_references(
2151         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure,
2152         &amp;task_executor, &amp;pt);
2153     } else {
2154       stats = ref_processor()-&gt;process_discovered_references(
2155         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure, NULL,
2156         &amp;pt);
</pre>
<hr />
<pre>
2162 
2163   // This is the point where the entire marking should have completed.
2164   assert(cm-&gt;marking_stacks_empty(), &quot;Marking should have completed&quot;);
2165 
2166   {
2167     GCTraceTime(Debug, gc, phases) tm(&quot;Weak Processing&quot;, &amp;_gc_timer);
2168     WeakProcessor::weak_oops_do(is_alive_closure(), &amp;do_nothing_cl);
2169   }
2170 
2171   {
2172     GCTraceTime(Debug, gc, phases) tm_m(&quot;Class Unloading&quot;, &amp;_gc_timer);
2173 
2174     // Follow system dictionary roots and unload classes.
2175     bool purged_class = SystemDictionary::do_unloading(&amp;_gc_timer);
2176 
2177     // Unload nmethods.
2178     CodeCache::do_unloading(is_alive_closure(), purged_class);
2179 
2180     // Prune dead klasses from subklass/sibling/implementor lists.
2181     Klass::clean_weak_klass_links(purged_class);



2182   }
2183 
2184   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2185 }
2186 
2187 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2188   // Adjust the pointers to reflect the new locations
2189   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2190 
2191   // Need new claim bits when tracing through and adjusting pointers.
2192   ClassLoaderDataGraph::clear_claimed_marks();
2193 
2194   PCAdjustPointerClosure oop_closure(cm);
2195 
2196   // General strong roots.
2197   Universe::oops_do(&amp;oop_closure);
2198   JNIHandles::oops_do(&amp;oop_closure);   // Global (strong) JNI handles
2199   Threads::oops_do(&amp;oop_closure, NULL);
2200   ObjectSynchronizer::oops_do(&amp;oop_closure);
2201   Management::oops_do(&amp;oop_closure);
2202   JvmtiExport::oops_do(&amp;oop_closure);
2203   SystemDictionary::oops_do(&amp;oop_closure);
2204   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2205   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2206 
2207   // Now adjust pointers in remaining weak roots.  (All of which should
2208   // have been cleared if they pointed to non-surviving objects.)
2209   WeakProcessor::oops_do(&amp;oop_closure);
2210 
2211   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2212   CodeCache::blobs_do(&amp;adjust_from_blobs);
<span class="line-modified">2213   AOTLoader::oops_do(&amp;oop_closure);</span>

2214   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2215   // Roots were visited so references into the young gen in roots
2216   // may have been scanned.  Process them also.
2217   // Should the reference processor have a span that excludes
2218   // young gen objects?
2219   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2220 }
2221 
2222 // Helper class to print 8 region numbers per line and then print the total at the end.
2223 class FillableRegionLogger : public StackObj {
2224 private:
2225   Log(gc, compaction) log;
2226   static const int LineLength = 8;
2227   size_t _regions[LineLength];
2228   int _next_index;
2229   bool _enabled;
2230   size_t _total_regions;
2231 public:
2232   FillableRegionLogger() : _next_index(0), _enabled(log_develop_is_enabled(Trace, gc, compaction)), _total_regions(0) { }
2233   ~FillableRegionLogger() {
</pre>
<hr />
<pre>
2241     FormatBuffer&lt;&gt; line(&quot;Fillable: &quot;);
2242     for (int i = 0; i &lt; _next_index; i++) {
2243       line.append(&quot; &quot; SIZE_FORMAT_W(7), _regions[i]);
2244     }
2245     log.trace(&quot;%s&quot;, line.buffer());
2246     _next_index = 0;
2247   }
2248 
2249   void handle(size_t region) {
2250     if (!_enabled) {
2251       return;
2252     }
2253     _regions[_next_index++] = region;
2254     if (_next_index == LineLength) {
2255       print_line();
2256     }
2257     _total_regions++;
2258   }
2259 };
2260 
<span class="line-modified">2261 void PSParallelCompact::prepare_region_draining_tasks(GCTaskQueue* q,</span>
<span class="line-removed">2262                                                       uint parallel_gc_threads)</span>
2263 {
2264   GCTraceTime(Trace, gc, phases) tm(&quot;Drain Task Setup&quot;, &amp;_gc_timer);
2265 
2266   // Find the threads that are active
<span class="line-modified">2267   unsigned int which = 0;</span>
2268 
2269   // Find all regions that are available (can be filled immediately) and
2270   // distribute them to the thread stacks.  The iteration is done in reverse
2271   // order (high to low) so the regions will be removed in ascending order.
2272 
2273   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2274 
<span class="line-removed">2275   which = 0;</span>
2276   // id + 1 is used to test termination so unsigned  can
2277   // be used with an old_space_id == 0.
2278   FillableRegionLogger region_logger;
2279   for (unsigned int id = to_space_id; id + 1 &gt; old_space_id; --id) {
2280     SpaceInfo* const space_info = _space_info + id;
2281     MutableSpace* const space = space_info-&gt;space();
2282     HeapWord* const new_top = space_info-&gt;new_top();
2283 
2284     const size_t beg_region = sd.addr_to_region_idx(space_info-&gt;dense_prefix());
2285     const size_t end_region =
2286       sd.addr_to_region_idx(sd.region_align_up(new_top));
2287 
2288     for (size_t cur = end_region - 1; cur + 1 &gt; beg_region; --cur) {
2289       if (sd.region(cur)-&gt;claim_unsafe()) {
<span class="line-modified">2290         ParCompactionManager* cm = ParCompactionManager::manager_array(which);</span>


2291         cm-&gt;region_stack()-&gt;push(cur);
2292         region_logger.handle(cur);
2293         // Assign regions to tasks in round-robin fashion.
<span class="line-modified">2294         if (++which == parallel_gc_threads) {</span>
<span class="line-modified">2295           which = 0;</span>
2296         }
2297       }
2298     }
2299     region_logger.print_line();
2300   }
2301 }
2302 






























2303 #define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4
2304 
<span class="line-modified">2305 void PSParallelCompact::enqueue_dense_prefix_tasks(GCTaskQueue* q,</span>
<span class="line-modified">2306                                                     uint parallel_gc_threads) {</span>
2307   GCTraceTime(Trace, gc, phases) tm(&quot;Dense Prefix Task Setup&quot;, &amp;_gc_timer);
2308 
2309   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2310 
2311   // Iterate over all the spaces adding tasks for updating
2312   // regions in the dense prefix.  Assume that 1 gc thread
2313   // will work on opening the gaps and the remaining gc threads
2314   // will work on the dense prefix.
2315   unsigned int space_id;
2316   for (space_id = old_space_id; space_id &lt; last_space_id; ++ space_id) {
2317     HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();
2318     const MutableSpace* const space = _space_info[space_id].space();
2319 
2320     if (dense_prefix_end == space-&gt;bottom()) {
2321       // There is no dense prefix for this space.
2322       continue;
2323     }
2324 
2325     // The dense prefix is before this region.
2326     size_t region_index_end_dense_prefix =
</pre>
<hr />
<pre>
2349         tasks_for_dense_prefix = parallel_gc_threads;
2350       } else {
2351         // Over partition
2352         tasks_for_dense_prefix = parallel_gc_threads *
2353           PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;
2354       }
2355       size_t regions_per_thread = total_dense_prefix_regions /
2356         tasks_for_dense_prefix;
2357       // Give each thread at least 1 region.
2358       if (regions_per_thread == 0) {
2359         regions_per_thread = 1;
2360       }
2361 
2362       for (uint k = 0; k &lt; tasks_for_dense_prefix; k++) {
2363         if (region_index_start &gt;= region_index_end_dense_prefix) {
2364           break;
2365         }
2366         // region_index_end is not processed
2367         size_t region_index_end = MIN2(region_index_start + regions_per_thread,
2368                                        region_index_end_dense_prefix);
<span class="line-modified">2369         q-&gt;enqueue(new UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2370                                              region_index_start,</span>
<span class="line-modified">2371                                              region_index_end));</span>
2372         region_index_start = region_index_end;
2373       }
2374     }
2375     // This gets any part of the dense prefix that did not
2376     // fit evenly.
2377     if (region_index_start &lt; region_index_end_dense_prefix) {
<span class="line-modified">2378       q-&gt;enqueue(new UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2379                                            region_index_start,</span>
<span class="line-modified">2380                                            region_index_end_dense_prefix));</span>
2381     }
2382   }
2383 }
2384 
<span class="line-removed">2385 void PSParallelCompact::enqueue_region_stealing_tasks(</span>
<span class="line-removed">2386                                      GCTaskQueue* q,</span>
<span class="line-removed">2387                                      ParallelTaskTerminator* terminator_ptr,</span>
<span class="line-removed">2388                                      uint parallel_gc_threads) {</span>
<span class="line-removed">2389   GCTraceTime(Trace, gc, phases) tm(&quot;Steal Task Setup&quot;, &amp;_gc_timer);</span>
<span class="line-removed">2390 </span>
<span class="line-removed">2391   // Once a thread has drained it&#39;s stack, it should try to steal regions from</span>
<span class="line-removed">2392   // other threads.</span>
<span class="line-removed">2393   for (uint j = 0; j &lt; parallel_gc_threads; j++) {</span>
<span class="line-removed">2394     q-&gt;enqueue(new CompactionWithStealingTask(terminator_ptr));</span>
<span class="line-removed">2395   }</span>
<span class="line-removed">2396 }</span>
<span class="line-removed">2397 </span>
2398 #ifdef ASSERT
2399 // Write a histogram of the number of times the block table was filled for a
2400 // region.
2401 void PSParallelCompact::write_block_fill_histogram()
2402 {
2403   if (!log_develop_is_enabled(Trace, gc, compaction)) {
2404     return;
2405   }
2406 
2407   Log(gc, compaction) log;
2408   ResourceMark rm;
2409   LogStream ls(log.trace());
2410   outputStream* out = &amp;ls;
2411 
2412   typedef ParallelCompactData::RegionData rd_t;
2413   ParallelCompactData&amp; sd = summary_data();
2414 
2415   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2416     MutableSpace* const spc = _space_info[id].space();
2417     if (spc-&gt;bottom() != spc-&gt;top()) {
</pre>
<hr />
<pre>
2420       const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);
2421 
2422       size_t histo[5] = { 0, 0, 0, 0, 0 };
2423       const size_t histo_len = sizeof(histo) / sizeof(size_t);
2424       const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));
2425 
2426       for (const rd_t* cur = beg; cur &lt; end; ++cur) {
2427         ++histo[MIN2(cur-&gt;blocks_filled_count(), histo_len - 1)];
2428       }
2429       out-&gt;print(&quot;Block fill histogram: %u %-4s&quot; SIZE_FORMAT_W(5), id, space_names[id], region_cnt);
2430       for (size_t i = 0; i &lt; histo_len; ++i) {
2431         out-&gt;print(&quot; &quot; SIZE_FORMAT_W(5) &quot; %5.1f%%&quot;,
2432                    histo[i], 100.0 * histo[i] / region_cnt);
2433       }
2434       out-&gt;cr();
2435     }
2436   }
2437 }
2438 #endif // #ifdef ASSERT
2439 






























































2440 void PSParallelCompact::compact() {
2441   GCTraceTime(Info, gc, phases) tm(&quot;Compaction Phase&quot;, &amp;_gc_timer);
2442 
2443   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2444   PSOldGen* old_gen = heap-&gt;old_gen();
2445   old_gen-&gt;start_array()-&gt;reset();
<span class="line-modified">2446   uint parallel_gc_threads = heap-&gt;gc_task_manager()-&gt;workers();</span>
<span class="line-removed">2447   uint active_gc_threads = heap-&gt;gc_task_manager()-&gt;active_workers();</span>
<span class="line-removed">2448   TaskQueueSetSuper* qset = ParCompactionManager::region_array();</span>
<span class="line-removed">2449   TaskTerminator terminator(active_gc_threads, qset);</span>
2450 
<span class="line-modified">2451   GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-modified">2452   prepare_region_draining_tasks(q, active_gc_threads);</span>
<span class="line-modified">2453   enqueue_dense_prefix_tasks(q, active_gc_threads);</span>
<span class="line-modified">2454   enqueue_region_stealing_tasks(q, terminator.terminator(), active_gc_threads);</span>






2455 
2456   {
2457     GCTraceTime(Trace, gc, phases) tm(&quot;Par Compact&quot;, &amp;_gc_timer);
2458 
<span class="line-modified">2459     gc_task_manager()-&gt;execute_and_wait(q);</span>

2460 
2461 #ifdef  ASSERT
2462     // Verify that all regions have been processed before the deferred updates.
2463     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2464       verify_complete(SpaceId(id));
2465     }
2466 #endif
2467   }
2468 
2469   {
2470     // Update the deferred objects, if any.  Any compaction manager can be used.
2471     GCTraceTime(Trace, gc, phases) tm(&quot;Deferred Updates&quot;, &amp;_gc_timer);
2472     ParCompactionManager* cm = ParCompactionManager::manager_array(0);
2473     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2474       update_deferred_objects(cm, SpaceId(id));
2475     }
2476   }
2477 
2478   DEBUG_ONLY(write_block_fill_histogram());
2479 }
</pre>
<hr />
<pre>
2625       }
2626       cm-&gt;update_contents(oop(addr));
2627       assert(oopDesc::is_oop_or_null(oop(addr)), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(oop(addr)));
2628     }
2629   }
2630 }
2631 
2632 // Skip over count live words starting from beg, and return the address of the
2633 // next live word.  Unless marked, the word corresponding to beg is assumed to
2634 // be dead.  Callers must either ensure beg does not correspond to the middle of
2635 // an object, or account for those live words in some other way.  Callers must
2636 // also ensure that there are enough live words in the range [beg, end) to skip.
2637 HeapWord*
2638 PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)
2639 {
2640   assert(count &gt; 0, &quot;sanity&quot;);
2641 
2642   ParMarkBitMap* m = mark_bitmap();
2643   idx_t bits_to_skip = m-&gt;words_to_bits(count);
2644   idx_t cur_beg = m-&gt;addr_to_bit(beg);
<span class="line-modified">2645   const idx_t search_end = BitMap::word_align_up(m-&gt;addr_to_bit(end));</span>
2646 
2647   do {
2648     cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2649     idx_t cur_end = m-&gt;find_obj_end(cur_beg, search_end);
2650     const size_t obj_bits = cur_end - cur_beg + 1;
2651     if (obj_bits &gt; bits_to_skip) {
2652       return m-&gt;bit_to_addr(cur_beg + bits_to_skip);
2653     }
2654     bits_to_skip -= obj_bits;
2655     cur_beg = cur_end + 1;
2656   } while (bits_to_skip &gt; 0);
2657 
2658   // Skipping the desired number of words landed just past the end of an object.
2659   // Find the start of the next object.
2660   cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2661   assert(cur_beg &lt; m-&gt;addr_to_bit(end), &quot;not enough live words to skip&quot;);
2662   return m-&gt;bit_to_addr(cur_beg);
2663 }
2664 
2665 HeapWord* PSParallelCompact::first_src_addr(HeapWord* const dest_addr,
</pre>
<hr />
<pre>
2738   MutableSpace* const src_space = _space_info[src_space_id].space();
2739   HeapWord* const beg_addr = sd.region_to_addr(beg_region);
2740   assert(src_space-&gt;contains(beg_addr) || beg_addr == src_space-&gt;end(),
2741          &quot;src_space_id does not match beg_addr&quot;);
2742   assert(src_space-&gt;contains(end_addr) || end_addr == src_space-&gt;end(),
2743          &quot;src_space_id does not match end_addr&quot;);
2744 #endif // #ifdef ASSERT
2745 
2746   RegionData* const beg = sd.region(beg_region);
2747   RegionData* const end = sd.addr_to_region_ptr(sd.region_align_up(end_addr));
2748 
2749   // Regions up to new_top() are enqueued if they become available.
2750   HeapWord* const new_top = _space_info[src_space_id].new_top();
2751   RegionData* const enqueue_end =
2752     sd.addr_to_region_ptr(sd.region_align_up(new_top));
2753 
2754   for (RegionData* cur = beg; cur &lt; end; ++cur) {
2755     assert(cur-&gt;data_size() &gt; 0, &quot;region must have live data&quot;);
2756     cur-&gt;decrement_destination_count();
2757     if (cur &lt; enqueue_end &amp;&amp; cur-&gt;available() &amp;&amp; cur-&gt;claim()) {
<span class="line-modified">2758       cm-&gt;push_region(sd.region(cur));</span>










2759     }
2760   }
2761 }
2762 
2763 size_t PSParallelCompact::next_src_region(MoveAndUpdateClosure&amp; closure,
2764                                           SpaceId&amp; src_space_id,
2765                                           HeapWord*&amp; src_space_top,
2766                                           HeapWord* end_addr)
2767 {
2768   typedef ParallelCompactData::RegionData RegionData;
2769 
2770   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2771   const size_t region_size = ParallelCompactData::RegionSize;
2772 
2773   size_t src_region_idx = 0;
2774 
2775   // Skip empty regions (if any) up to the top of the space.
2776   HeapWord* const src_aligned_up = sd.region_align_up(end_addr);
2777   RegionData* src_region_ptr = sd.addr_to_region_ptr(src_aligned_up);
2778   HeapWord* const top_aligned_up = sd.region_align_up(src_space_top);
</pre>
<hr />
<pre>
2816                  &quot;first live obj in the space must match the destination&quot;);
2817           assert(src_cp-&gt;partial_obj_size() == 0,
2818                  &quot;a space cannot begin with a partial obj&quot;);
2819 
2820           src_space_id = SpaceId(space_id);
2821           src_space_top = space-&gt;top();
2822           const size_t src_region_idx = sd.region(src_cp);
2823           closure.set_source(sd.region_to_addr(src_region_idx));
2824           return src_region_idx;
2825         } else {
2826           assert(src_cp-&gt;data_size() == 0, &quot;sanity&quot;);
2827         }
2828       }
2829     }
2830   } while (++space_id &lt; last_space_id);
2831 
2832   assert(false, &quot;no source region was found&quot;);
2833   return 0;
2834 }
2835 
<span class="line-modified">2836 void PSParallelCompact::fill_region(ParCompactionManager* cm, size_t region_idx)</span>
2837 {
2838   typedef ParMarkBitMap::IterationStatus IterationStatus;
<span class="line-removed">2839   const size_t RegionSize = ParallelCompactData::RegionSize;</span>
2840   ParMarkBitMap* const bitmap = mark_bitmap();
2841   ParallelCompactData&amp; sd = summary_data();
2842   RegionData* const region_ptr = sd.region(region_idx);
2843 
<span class="line-removed">2844   // Get the items needed to construct the closure.</span>
<span class="line-removed">2845   HeapWord* dest_addr = sd.region_to_addr(region_idx);</span>
<span class="line-removed">2846   SpaceId dest_space_id = space_id(dest_addr);</span>
<span class="line-removed">2847   ObjectStartArray* start_array = _space_info[dest_space_id].start_array();</span>
<span class="line-removed">2848   HeapWord* new_top = _space_info[dest_space_id].new_top();</span>
<span class="line-removed">2849   assert(dest_addr &lt; new_top, &quot;sanity&quot;);</span>
<span class="line-removed">2850   const size_t words = MIN2(pointer_delta(new_top, dest_addr), RegionSize);</span>
<span class="line-removed">2851 </span>
2852   // Get the source region and related info.
2853   size_t src_region_idx = region_ptr-&gt;source_region();
2854   SpaceId src_space_id = space_id(sd.region_to_addr(src_region_idx));
2855   HeapWord* src_space_top = _space_info[src_space_id].space()-&gt;top();

2856 
<span class="line-removed">2857   MoveAndUpdateClosure closure(bitmap, cm, start_array, dest_addr, words);</span>
2858   closure.set_source(first_src_addr(dest_addr, src_space_id, src_region_idx));
2859 
2860   // Adjust src_region_idx to prepare for decrementing destination counts (the
2861   // destination count is not decremented when a region is copied to itself).
2862   if (src_region_idx == region_idx) {
2863     src_region_idx += 1;
2864   }
2865 
2866   if (bitmap-&gt;is_unmarked(closure.source())) {
2867     // The first source word is in the middle of an object; copy the remainder
2868     // of the object or as much as will fit.  The fact that pointer updates were
2869     // deferred will be noted when the object header is processed.
2870     HeapWord* const old_src_addr = closure.source();
2871     closure.copy_partial_obj();
2872     if (closure.is_full()) {
2873       decrement_destination_counts(cm, src_space_id, src_region_idx,
2874                                    closure.source());
2875       region_ptr-&gt;set_deferred_obj_addr(NULL);
<span class="line-modified">2876       region_ptr-&gt;set_completed();</span>
2877       return;
2878     }
2879 
2880     HeapWord* const end_addr = sd.region_align_down(closure.source());
2881     if (sd.region_align_down(old_src_addr) != end_addr) {
2882       // The partial object was copied from more than one source region.
2883       decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
2884 
2885       // Move to the next source region, possibly switching spaces as well.  All
2886       // args except end_addr may be modified.
2887       src_region_idx = next_src_region(closure, src_space_id, src_space_top,
2888                                        end_addr);
2889     }
2890   }
2891 
2892   do {
2893     HeapWord* const cur_addr = closure.source();
2894     HeapWord* const end_addr = MIN2(sd.region_align_up(cur_addr + 1),
2895                                     src_space_top);
2896     IterationStatus status = bitmap-&gt;iterate(&amp;closure, cur_addr, end_addr);
</pre>
<hr />
<pre>
2905       HeapWord* const obj_end = bitmap-&gt;find_obj_end(obj_beg, range_end);
2906       if (obj_end &lt; range_end) {
2907         // The end was found; the entire object will fit.
2908         status = closure.do_addr(obj_beg, bitmap-&gt;obj_size(obj_beg, obj_end));
2909         assert(status != ParMarkBitMap::would_overflow, &quot;sanity&quot;);
2910       } else {
2911         // The end was not found; the object will not fit.
2912         assert(range_end &lt; src_space_top, &quot;obj cannot cross space boundary&quot;);
2913         status = ParMarkBitMap::would_overflow;
2914       }
2915     }
2916 
2917     if (status == ParMarkBitMap::would_overflow) {
2918       // The last object did not fit.  Note that interior oop updates were
2919       // deferred, then copy enough of the object to fill the region.
2920       region_ptr-&gt;set_deferred_obj_addr(closure.destination());
2921       status = closure.copy_until_full(); // copies from closure.source()
2922 
2923       decrement_destination_counts(cm, src_space_id, src_region_idx,
2924                                    closure.source());
<span class="line-modified">2925       region_ptr-&gt;set_completed();</span>
2926       return;
2927     }
2928 
2929     if (status == ParMarkBitMap::full) {
2930       decrement_destination_counts(cm, src_space_id, src_region_idx,
2931                                    closure.source());
2932       region_ptr-&gt;set_deferred_obj_addr(NULL);
<span class="line-modified">2933       region_ptr-&gt;set_completed();</span>
2934       return;
2935     }
2936 
2937     decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
2938 
2939     // Move to the next source region, possibly switching spaces as well.  All
2940     // args except end_addr may be modified.
2941     src_region_idx = next_src_region(closure, src_space_id, src_space_top,
2942                                      end_addr);
2943   } while (true);
2944 }
2945 


























































































2946 void PSParallelCompact::fill_blocks(size_t region_idx)
2947 {
2948   // Fill in the block table elements for the specified region.  Each block
2949   // table element holds the number of live words in the region that are to the
2950   // left of the first object that starts in the block.  Thus only blocks in
2951   // which an object starts need to be filled.
2952   //
2953   // The algorithm scans the section of the bitmap that corresponds to the
2954   // region, keeping a running total of the live words.  When an object start is
2955   // found, if it&#39;s the first to start in the block that contains it, the
2956   // current total is written to the block table element.
2957   const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;
2958   const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;
2959   const size_t RegionSize = ParallelCompactData::RegionSize;
2960 
2961   ParallelCompactData&amp; sd = summary_data();
2962   const size_t partial_obj_size = sd.region(region_idx)-&gt;partial_obj_size();
2963   if (partial_obj_size &gt;= RegionSize) {
2964     return; // No objects start in this region.
2965   }
</pre>
<hr />
<pre>
2977   const size_t range_end = beg_bit + bitmap-&gt;words_to_bits(RegionSize);
2978   size_t live_bits = bitmap-&gt;words_to_bits(partial_obj_size);
2979   beg_bit = bitmap-&gt;find_obj_beg(beg_bit + live_bits, range_end);
2980   while (beg_bit &lt; range_end) {
2981     const size_t new_block = beg_bit &gt;&gt; Log2BitsPerBlock;
2982     if (new_block != cur_block) {
2983       cur_block = new_block;
2984       sd.block(cur_block)-&gt;set_offset(bitmap-&gt;bits_to_words(live_bits));
2985     }
2986 
2987     const size_t end_bit = bitmap-&gt;find_obj_end(beg_bit, range_end);
2988     if (end_bit &lt; range_end - 1) {
2989       live_bits += end_bit - beg_bit + 1;
2990       beg_bit = bitmap-&gt;find_obj_beg(end_bit + 1, range_end);
2991     } else {
2992       return;
2993     }
2994   }
2995 }
2996 
<span class="line-removed">2997 void</span>
<span class="line-removed">2998 PSParallelCompact::move_and_update(ParCompactionManager* cm, SpaceId space_id) {</span>
<span class="line-removed">2999   const MutableSpace* sp = space(space_id);</span>
<span class="line-removed">3000   if (sp-&gt;is_empty()) {</span>
<span class="line-removed">3001     return;</span>
<span class="line-removed">3002   }</span>
<span class="line-removed">3003 </span>
<span class="line-removed">3004   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();</span>
<span class="line-removed">3005   ParMarkBitMap* const bitmap = mark_bitmap();</span>
<span class="line-removed">3006   HeapWord* const dp_addr = dense_prefix(space_id);</span>
<span class="line-removed">3007   HeapWord* beg_addr = sp-&gt;bottom();</span>
<span class="line-removed">3008   HeapWord* end_addr = sp-&gt;top();</span>
<span class="line-removed">3009 </span>
<span class="line-removed">3010   assert(beg_addr &lt;= dp_addr &amp;&amp; dp_addr &lt;= end_addr, &quot;bad dense prefix&quot;);</span>
<span class="line-removed">3011 </span>
<span class="line-removed">3012   const size_t beg_region = sd.addr_to_region_idx(beg_addr);</span>
<span class="line-removed">3013   const size_t dp_region = sd.addr_to_region_idx(dp_addr);</span>
<span class="line-removed">3014   if (beg_region &lt; dp_region) {</span>
<span class="line-removed">3015     update_and_deadwood_in_dense_prefix(cm, space_id, beg_region, dp_region);</span>
<span class="line-removed">3016   }</span>
<span class="line-removed">3017 </span>
<span class="line-removed">3018   // The destination of the first live object that starts in the region is one</span>
<span class="line-removed">3019   // past the end of the partial object entering the region (if any).</span>
<span class="line-removed">3020   HeapWord* const dest_addr = sd.partial_obj_end(dp_region);</span>
<span class="line-removed">3021   HeapWord* const new_top = _space_info[space_id].new_top();</span>
<span class="line-removed">3022   assert(new_top &gt;= dest_addr, &quot;bad new_top value&quot;);</span>
<span class="line-removed">3023   const size_t words = pointer_delta(new_top, dest_addr);</span>
<span class="line-removed">3024 </span>
<span class="line-removed">3025   if (words &gt; 0) {</span>
<span class="line-removed">3026     ObjectStartArray* start_array = _space_info[space_id].start_array();</span>
<span class="line-removed">3027     MoveAndUpdateClosure closure(bitmap, cm, start_array, dest_addr, words);</span>
<span class="line-removed">3028 </span>
<span class="line-removed">3029     ParMarkBitMap::IterationStatus status;</span>
<span class="line-removed">3030     status = bitmap-&gt;iterate(&amp;closure, dest_addr, end_addr);</span>
<span class="line-removed">3031     assert(status == ParMarkBitMap::full, &quot;iteration not complete&quot;);</span>
<span class="line-removed">3032     assert(bitmap-&gt;find_obj_beg(closure.source(), end_addr) == end_addr,</span>
<span class="line-removed">3033            &quot;live objects skipped because closure is full&quot;);</span>
<span class="line-removed">3034   }</span>
<span class="line-removed">3035 }</span>
<span class="line-removed">3036 </span>
3037 jlong PSParallelCompact::millis_since_last_gc() {
3038   // We need a monotonically non-decreasing time in ms but
3039   // os::javaTimeMillis() does not guarantee monotonicity.
3040   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3041   jlong ret_val = now - _time_of_last_gc;
3042   // XXX See note in genCollectedHeap::millis_since_last_gc().
3043   if (ret_val &lt; 0) {
3044     NOT_PRODUCT(log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT, ret_val);)
3045     return 0;
3046   }
3047   return ret_val;
3048 }
3049 
3050 void PSParallelCompact::reset_millis_since_last_gc() {
3051   // We need a monotonically non-decreasing time in ms but
3052   // os::javaTimeMillis() does not guarantee monotonicity.
3053   _time_of_last_gc = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3054 }
3055 
3056 ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()
3057 {
<span class="line-modified">3058   if (source() != destination()) {</span>
3059     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3060     Copy::aligned_conjoint_words(source(), destination(), words_remaining());</span>
3061   }
3062   update_state(words_remaining());
3063   assert(is_full(), &quot;sanity&quot;);
3064   return ParMarkBitMap::full;
3065 }
3066 
3067 void MoveAndUpdateClosure::copy_partial_obj()
3068 {
3069   size_t words = words_remaining();
3070 
3071   HeapWord* const range_end = MIN2(source() + words, bitmap()-&gt;region_end());
3072   HeapWord* const end_addr = bitmap()-&gt;find_obj_end(source(), range_end);
3073   if (end_addr &lt; range_end) {
3074     words = bitmap()-&gt;obj_size(source(), end_addr);
3075   }
3076 
3077   // This test is necessary; if omitted, the pointer updates to a partial object
3078   // that crosses the dense prefix boundary could be overwritten.
<span class="line-modified">3079   if (source() != destination()) {</span>
3080     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3081     Copy::aligned_conjoint_words(source(), destination(), words);</span>
3082   }
3083   update_state(words);
3084 }
3085 






3086 ParMarkBitMapClosure::IterationStatus
3087 MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {
3088   assert(destination() != NULL, &quot;sanity&quot;);
3089   assert(bitmap()-&gt;obj_size(addr) == words, &quot;bad size&quot;);
3090 
3091   _source = addr;
3092   assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==
3093          destination(), &quot;wrong destination&quot;);
3094 
3095   if (words &gt; words_remaining()) {
3096     return ParMarkBitMap::would_overflow;
3097   }
3098 
3099   // The start_array must be updated even if the object is not moving.
3100   if (_start_array != NULL) {
3101     _start_array-&gt;allocate_block(destination());
3102   }
3103 
<span class="line-modified">3104   if (destination() != source()) {</span>
3105     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3106     Copy::aligned_conjoint_words(source(), destination(), words);</span>
3107   }
3108 
<span class="line-modified">3109   oop moved_oop = (oop) destination();</span>
3110   compaction_manager()-&gt;update_contents(moved_oop);
3111   assert(oopDesc::is_oop_or_null(moved_oop), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(moved_oop));
3112 
3113   update_state(words);
<span class="line-modified">3114   assert(destination() == (HeapWord*)moved_oop + moved_oop-&gt;size(), &quot;sanity&quot;);</span>
3115   return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;
3116 }
3117 



















3118 UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,
3119                                      ParCompactionManager* cm,
3120                                      PSParallelCompact::SpaceId space_id) :
3121   ParMarkBitMapClosure(mbm, cm),
3122   _space_id(space_id),
3123   _start_array(PSParallelCompact::start_array(space_id))
3124 {
3125 }
3126 
3127 // Updates the references in the object to their new values.
3128 ParMarkBitMapClosure::IterationStatus
3129 UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {
3130   do_addr(addr);
3131   return ParMarkBitMap::incomplete;
3132 }
3133 
3134 FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :
3135   ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),
3136   _start_array(PSParallelCompact::start_array(space_id))
3137 {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
<span class="line-modified">  33 #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;

  36 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  37 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  38 #include &quot;gc/parallel/psOldGen.hpp&quot;
  39 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  40 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
<span class="line-added">  41 #include &quot;gc/parallel/psRootType.hpp&quot;</span>
  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/referencePolicy.hpp&quot;
  53 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  54 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="line-modified">  55 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
<span class="line-added">  56 #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
  57 #include &quot;gc/shared/weakProcessor.hpp&quot;
<span class="line-added">  58 #include &quot;gc/shared/workerPolicy.hpp&quot;</span>
<span class="line-added">  59 #include &quot;gc/shared/workgroup.hpp&quot;</span>
  60 #include &quot;logging/log.hpp&quot;
  61 #include &quot;memory/iterator.inline.hpp&quot;
  62 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  63 #include &quot;memory/universe.hpp&quot;</span>
  64 #include &quot;oops/access.inline.hpp&quot;
  65 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  66 #include &quot;oops/instanceKlass.inline.hpp&quot;
  67 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;runtime/atomic.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/safepoint.hpp&quot;
  74 #include &quot;runtime/vmThread.hpp&quot;
  75 #include &quot;services/management.hpp&quot;
  76 #include &quot;services/memTracker.hpp&quot;
  77 #include &quot;services/memoryService.hpp&quot;
  78 #include &quot;utilities/align.hpp&quot;
  79 #include &quot;utilities/debug.hpp&quot;
  80 #include &quot;utilities/events.hpp&quot;
  81 #include &quot;utilities/formatBuffer.hpp&quot;
  82 #include &quot;utilities/macros.hpp&quot;
  83 #include &quot;utilities/stack.inline.hpp&quot;
<span class="line-added">  84 #if INCLUDE_JVMCI</span>
<span class="line-added">  85 #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="line-added">  86 #endif</span>
  87 
  88 #include &lt;math.h&gt;
  89 
  90 // All sizes are in HeapWords.
  91 const size_t ParallelCompactData::Log2RegionSize  = 16; // 64K words
  92 const size_t ParallelCompactData::RegionSize      = (size_t)1 &lt;&lt; Log2RegionSize;
  93 const size_t ParallelCompactData::RegionSizeBytes =
  94   RegionSize &lt;&lt; LogHeapWordSize;
  95 const size_t ParallelCompactData::RegionSizeOffsetMask = RegionSize - 1;
  96 const size_t ParallelCompactData::RegionAddrOffsetMask = RegionSizeBytes - 1;
  97 const size_t ParallelCompactData::RegionAddrMask       = ~RegionAddrOffsetMask;
  98 
  99 const size_t ParallelCompactData::Log2BlockSize   = 7; // 128 words
 100 const size_t ParallelCompactData::BlockSize       = (size_t)1 &lt;&lt; Log2BlockSize;
 101 const size_t ParallelCompactData::BlockSizeBytes  =
 102   BlockSize &lt;&lt; LogHeapWordSize;
 103 const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;
 104 const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;
 105 const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;
 106 
</pre>
<hr />
<pre>
 396   const MutableSpace* space;
 397   do {
 398     space = space_info[id].space();
 399     print_initial_summary_data(summary_data, space);
 400   } while (++id &lt; PSParallelCompact::eden_space_id);
 401 
 402   do {
 403     space = space_info[id].space();
 404     print_generic_summary_data(summary_data, space-&gt;bottom(), space-&gt;top());
 405   } while (++id &lt; PSParallelCompact::last_space_id);
 406 }
 407 #endif  // #ifndef PRODUCT
 408 
 409 #ifdef  ASSERT
 410 size_t add_obj_count;
 411 size_t add_obj_size;
 412 size_t mark_bitmap_count;
 413 size_t mark_bitmap_size;
 414 #endif  // #ifdef ASSERT
 415 
<span class="line-modified"> 416 ParallelCompactData::ParallelCompactData() :</span>
<span class="line-modified"> 417   _region_start(NULL),</span>
<span class="line-modified"> 418   DEBUG_ONLY(_region_end(NULL) COMMA)</span>
<span class="line-modified"> 419   _region_vspace(NULL),</span>
<span class="line-modified"> 420   _reserved_byte_size(0),</span>
<span class="line-modified"> 421   _region_data(NULL),</span>
<span class="line-modified"> 422   _region_count(0),</span>
<span class="line-modified"> 423   _block_vspace(NULL),</span>
<span class="line-modified"> 424   _block_data(NULL),</span>
<span class="line-modified"> 425   _block_count(0) {}</span>



 426 
 427 bool ParallelCompactData::initialize(MemRegion covered_region)
 428 {
 429   _region_start = covered_region.start();
 430   const size_t region_size = covered_region.word_size();
 431   DEBUG_ONLY(_region_end = _region_start + region_size;)
 432 
 433   assert(region_align_down(_region_start) == _region_start,
 434          &quot;region start not aligned&quot;);
 435   assert((region_size &amp; RegionSizeOffsetMask) == 0,
 436          &quot;region size not a multiple of RegionSize&quot;);
 437 
 438   bool result = initialize_region_data(region_size) &amp;&amp; initialize_block_data();
 439   return result;
 440 }
 441 
 442 PSVirtualSpace*
 443 ParallelCompactData::create_vspace(size_t count, size_t element_size)
 444 {
 445   const size_t raw_bytes = count * element_size;
</pre>
<hr />
<pre>
 516 {
 517   const RegionData* cur_cp = region(region_idx);
 518   const RegionData* const end_cp = region(region_count() - 1);
 519 
 520   HeapWord* result = region_to_addr(region_idx);
 521   if (cur_cp &lt; end_cp) {
 522     do {
 523       result += cur_cp-&gt;partial_obj_size();
 524     } while (cur_cp-&gt;partial_obj_size() == RegionSize &amp;&amp; ++cur_cp &lt; end_cp);
 525   }
 526   return result;
 527 }
 528 
 529 void ParallelCompactData::add_obj(HeapWord* addr, size_t len)
 530 {
 531   const size_t obj_ofs = pointer_delta(addr, _region_start);
 532   const size_t beg_region = obj_ofs &gt;&gt; Log2RegionSize;
 533   const size_t end_region = (obj_ofs + len - 1) &gt;&gt; Log2RegionSize;
 534 
 535   DEBUG_ONLY(Atomic::inc(&amp;add_obj_count);)
<span class="line-modified"> 536   DEBUG_ONLY(Atomic::add(&amp;add_obj_size, len);)</span>
 537 
 538   if (beg_region == end_region) {
 539     // All in one region.
 540     _region_data[beg_region].add_live_obj(len);
 541     return;
 542   }
 543 
 544   // First region.
 545   const size_t beg_ofs = region_offset(addr);
 546   _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);
 547 
 548   Klass* klass = ((oop)addr)-&gt;klass();
 549   // Middle regions--completely spanned by this object.
 550   for (size_t region = beg_region + 1; region &lt; end_region; ++region) {
 551     _region_data[region].set_partial_obj_size(RegionSize);
 552     _region_data[region].set_partial_obj_addr(addr);
 553   }
 554 
 555   // Last region.
 556   const size_t end_ofs = region_offset(addr + len - 1);
</pre>
<hr />
<pre>
 945   _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) / 100.0;
 946   _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) / 100.0;
 947   _dwl_first_term = 1.0 / (sqrt(2.0 * M_PI) * _dwl_std_dev);
 948   DEBUG_ONLY(_dwl_initialized = true;)
 949   _dwl_adjustment = normal_distribution(1.0);
 950 }
 951 
 952 void
 953 PSParallelCompact::clear_data_covering_space(SpaceId id)
 954 {
 955   // At this point, top is the value before GC, new_top() is the value that will
 956   // be set at the end of GC.  The marking bitmap is cleared to top; nothing
 957   // should be marked above top.  The summary data is cleared to the larger of
 958   // top &amp; new_top.
 959   MutableSpace* const space = _space_info[id].space();
 960   HeapWord* const bot = space-&gt;bottom();
 961   HeapWord* const top = space-&gt;top();
 962   HeapWord* const max_top = MAX2(top, _space_info[id].new_top());
 963 
 964   const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);
<span class="line-modified"> 965   const idx_t end_bit = _mark_bitmap.align_range_end(_mark_bitmap.addr_to_bit(top));</span>
 966   _mark_bitmap.clear_range(beg_bit, end_bit);
 967 
 968   const size_t beg_region = _summary_data.addr_to_region_idx(bot);
 969   const size_t end_region =
 970     _summary_data.addr_to_region_idx(_summary_data.region_align_up(max_top));
 971   _summary_data.clear_range(beg_region, end_region);
 972 
 973   // Clear the data used to &#39;split&#39; regions.
 974   SplitInfo&amp; split_info = _space_info[id].split_info();
 975   if (split_info.is_valid()) {
 976     split_info.clear();
 977   }
 978   DEBUG_ONLY(split_info.verify_clear();)
 979 }
 980 
 981 void PSParallelCompact::pre_compact()
 982 {
 983   // Update the from &amp; to space pointers in space_info, since they are swapped
 984   // at each young gen gc.  Do the update unconditionally (even though a
 985   // promotion failure does not swap spaces) because an unknown number of young
</pre>
<hr />
<pre>
1001   heap-&gt;print_heap_before_gc();
1002   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
1003 
1004   // Fill in TLABs
1005   heap-&gt;ensure_parsability(true);  // retire TLABs
1006 
1007   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1008     HandleMark hm;  // Discard invalid handles created during verification
1009     Universe::verify(&quot;Before GC&quot;);
1010   }
1011 
1012   // Verify object start arrays
1013   if (VerifyObjectStartArray &amp;&amp;
1014       VerifyBeforeGC) {
1015     heap-&gt;old_gen()-&gt;verify_object_start_array();
1016   }
1017 
1018   DEBUG_ONLY(mark_bitmap()-&gt;verify_clear();)
1019   DEBUG_ONLY(summary_data().verify_clear();)
1020 



1021   ParCompactionManager::reset_all_bitmap_query_caches();
1022 }
1023 
1024 void PSParallelCompact::post_compact()
1025 {
1026   GCTraceTime(Info, gc, phases) tm(&quot;Post Compact&quot;, &amp;_gc_timer);
<span class="line-added">1027   ParCompactionManager::remove_all_shadow_regions();</span>
1028 
1029   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1030     // Clear the marking bitmap, summary data and split info.
1031     clear_data_covering_space(SpaceId(id));
1032     // Update top().  Must be done after clearing the bitmap and summary data.
1033     _space_info[id].publish_new_top();
1034   }
1035 
1036   MutableSpace* const eden_space = _space_info[eden_space_id].space();
1037   MutableSpace* const from_space = _space_info[from_space_id].space();
1038   MutableSpace* const to_space   = _space_info[to_space_id].space();
1039 
1040   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1041   bool eden_empty = eden_space-&gt;is_empty();
1042   if (!eden_empty) {
1043     eden_empty = absorb_live_data_from_eden(heap-&gt;size_policy(),
1044                                             heap-&gt;young_gen(), heap-&gt;old_gen());
1045   }
1046 
1047   // Update heap occupancy information which is used as input to the soft ref
1048   // clearing policy at the next gc.
1049   Universe::update_heap_info_at_gc();
1050 
1051   bool young_gen_empty = eden_empty &amp;&amp; from_space-&gt;is_empty() &amp;&amp;
1052     to_space-&gt;is_empty();
1053 
1054   PSCardTable* ct = heap-&gt;card_table();
1055   MemRegion old_mr = heap-&gt;old_gen()-&gt;reserved();
1056   if (young_gen_empty) {
1057     ct-&gt;clear(MemRegion(old_mr.start(), old_mr.end()));
1058   } else {
1059     ct-&gt;invalidate(MemRegion(old_mr.start(), old_mr.end()));
1060   }
1061 
1062   // Delete metaspaces for unloaded class loaders and clean up loader_data graph
1063   ClassLoaderDataGraph::purge();
1064   MetaspaceUtils::verify_metrics();
1065 
<span class="line-modified">1066   heap-&gt;prune_scavengable_nmethods();</span>

1067 
1068 #if COMPILER2_OR_JVMCI
1069   DerivedPointerTable::update_pointers();
1070 #endif
1071 
1072   if (ZapUnusedHeapArea) {
1073     heap-&gt;gen_mangle_unused_area();
1074   }
1075 
1076   // Update time of last GC
1077   reset_millis_since_last_gc();
1078 }
1079 
1080 HeapWord*
1081 PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,
1082                                                     bool maximum_compaction)
1083 {
1084   const size_t region_size = ParallelCompactData::RegionSize;
1085   const ParallelCompactData&amp; sd = summary_data();
1086 
</pre>
<hr />
<pre>
1098   }
1099 
1100   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1101   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1102   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1103   if (maximum_compaction || cp == end_cp || interval_ended) {
1104     _maximum_compaction_gc_num = total_invocations();
1105     return sd.region_to_addr(cp);
1106   }
1107 
1108   HeapWord* const new_top = _space_info[id].new_top();
1109   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1110   const size_t space_used = space-&gt;used_in_words();
1111   const size_t space_capacity = space-&gt;capacity_in_words();
1112 
1113   const double cur_density = double(space_live) / space_capacity;
1114   const double deadwood_density =
1115     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1116   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1117 
<span class="line-modified">1118   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1119       &quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1120       cur_density, deadwood_density, deadwood_goal);</span>
<span class="line-modified">1121   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1122       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1123       &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1124       space_live, space_used,</span>
<span class="line-modified">1125       space_capacity);</span>
1126 
1127   // XXX - Use binary search?
1128   HeapWord* dense_prefix = sd.region_to_addr(cp);
1129   const RegionData* full_cp = cp;
1130   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1131   while (cp &lt; end_cp) {
1132     HeapWord* region_destination = cp-&gt;destination();
1133     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
<span class="line-modified">1134 </span>
<span class="line-modified">1135     log_develop_trace(gc, compaction)(</span>
<span class="line-modified">1136         &quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;</span>
<span class="line-modified">1137         &quot;dp=&quot; PTR_FORMAT &quot; cdw=&quot; SIZE_FORMAT_W(8),</span>
<span class="line-modified">1138         sd.region(cp), p2i(region_destination),</span>
<span class="line-modified">1139         p2i(dense_prefix), cur_deadwood);</span>
1140 
1141     if (cur_deadwood &gt;= deadwood_goal) {
1142       // Found the region that has the correct amount of deadwood to the left.
1143       // This typically occurs after crossing a fairly sparse set of regions, so
1144       // iterate backwards over those sparse regions, looking for the region
1145       // that has the lowest density of live objects &#39;to the right.&#39;
1146       size_t space_to_left = sd.region(cp) * region_size;
1147       size_t live_to_left = space_to_left - cur_deadwood;
1148       size_t space_to_right = space_capacity - space_to_left;
1149       size_t live_to_right = space_live - live_to_left;
1150       double density_to_right = double(live_to_right) / space_to_right;
1151       while (cp &gt; full_cp) {
1152         --cp;
1153         const size_t prev_region_live_to_right = live_to_right -
1154           cp-&gt;data_size();
1155         const size_t prev_region_space_to_right = space_to_right + region_size;
1156         double prev_region_density_to_right =
1157           double(prev_region_live_to_right) / prev_region_space_to_right;
1158         if (density_to_right &lt;= prev_region_density_to_right) {
1159           return dense_prefix;
1160         }
<span class="line-modified">1161 </span>
<span class="line-modified">1162         log_develop_trace(gc, compaction)(</span>
<span class="line-modified">1163             &quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;</span>
<span class="line-modified">1164             &quot;pc_d2r=%10.8f&quot;,</span>
<span class="line-modified">1165             sd.region(cp), density_to_right,</span>
<span class="line-added">1166             prev_region_density_to_right);</span>
<span class="line-added">1167 </span>
1168         dense_prefix -= region_size;
1169         live_to_right = prev_region_live_to_right;
1170         space_to_right = prev_region_space_to_right;
1171         density_to_right = prev_region_density_to_right;
1172       }
1173       return dense_prefix;
1174     }
1175 
1176     dense_prefix += region_size;
1177     ++cp;
1178   }
1179 
1180   return dense_prefix;
1181 }
1182 
1183 #ifndef PRODUCT
1184 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1185                                                  const SpaceId id,
1186                                                  const bool maximum_compaction,
1187                                                  HeapWord* const addr)
1188 {
1189   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1190   RegionData* const cp = summary_data().region(region_idx);
1191   const MutableSpace* const space = _space_info[id].space();
1192   HeapWord* const new_top = _space_info[id].new_top();
1193 
1194   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1195   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1196   const size_t space_cap = space-&gt;capacity_in_words();
1197   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1198   const size_t live_to_right = new_top - cp-&gt;destination();
1199   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1200 
<span class="line-modified">1201   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1202       &quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;</span>
<span class="line-modified">1203       &quot;spl=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1204       &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;</span>
<span class="line-modified">1205       &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1206       &quot;ratio=%10.8f&quot;,</span>
<span class="line-modified">1207       algorithm, p2i(addr), region_idx,</span>
<span class="line-modified">1208       space_live,</span>
<span class="line-modified">1209       dead_to_left, dead_to_left_pct,</span>
<span class="line-modified">1210       dead_to_right, live_to_right,</span>
<span class="line-added">1211       double(dead_to_right) / live_to_right);</span>
1212 }
1213 #endif  // #ifndef PRODUCT
1214 
1215 // Return a fraction indicating how much of the generation can be treated as
1216 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1217 // based on the density of live objects in the generation to determine a limit,
1218 // which is then adjusted so the return value is min_percent when the density is
1219 // 1.
1220 //
1221 // The following table shows some return values for a different values of the
1222 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1223 // min_percent is 1.
1224 //
1225 //                          fraction allowed as dead wood
1226 //         -----------------------------------------------------------------
1227 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1228 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1229 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1230 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1231 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
</pre>
<hr />
<pre>
1399   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1400   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1401   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1402     total_invocations() == HeapFirstMaximumCompactionCount;
1403   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1404     _maximum_compaction_gc_num = total_invocations();
1405     return sd.region_to_addr(full_cp);
1406   }
1407 
1408   const size_t space_live = pointer_delta(new_top, bottom);
1409   const size_t space_used = space-&gt;used_in_words();
1410   const size_t space_capacity = space-&gt;capacity_in_words();
1411 
1412   const double density = double(space_live) / double(space_capacity);
1413   const size_t min_percent_free = MarkSweepDeadRatio;
1414   const double limiter = dead_wood_limiter(density, min_percent_free);
1415   const size_t dead_wood_max = space_used - space_live;
1416   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1417                                       dead_wood_max);
1418 
<span class="line-modified">1419   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1420       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1421       &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1422       space_live, space_used,</span>
<span class="line-modified">1423       space_capacity);</span>
<span class="line-modified">1424   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1425       &quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;</span>
<span class="line-modified">1426       &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1427       density, min_percent_free, limiter,</span>
<span class="line-modified">1428       dead_wood_max, dead_wood_limit);</span>
1429 
1430   // Locate the region with the desired amount of dead space to the left.
1431   const RegionData* const limit_cp =
1432     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1433 
1434   // Scan from the first region with dead space to the limit region and find the
1435   // one with the best (largest) reclaimed ratio.
1436   double best_ratio = 0.0;
1437   const RegionData* best_cp = full_cp;
1438   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1439     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1440     if (tmp_ratio &gt; best_ratio) {
1441       best_cp = cp;
1442       best_ratio = tmp_ratio;
1443     }
1444   }
1445 
1446   return sd.region_to_addr(best_cp);
1447 }
1448 
</pre>
<hr />
<pre>
1522     _mark_bitmap.mark_obj(obj_beg, obj_len);
1523     _summary_data.add_obj(obj_beg, obj_len);
1524     assert(start_array(id) != NULL, &quot;sanity&quot;);
1525     start_array(id)-&gt;allocate_block(obj_beg);
1526   }
1527 }
1528 
1529 void
1530 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1531 {
1532   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1533   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1534          &quot;should have been reset in summarize_spaces_quick()&quot;);
1535 
1536   const MutableSpace* space = _space_info[id].space();
1537   if (_space_info[id].new_top() != space-&gt;bottom()) {
1538     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1539     _space_info[id].set_dense_prefix(dense_prefix_end);
1540 
1541 #ifndef PRODUCT
<span class="line-modified">1542     if (log_is_enabled(Debug, gc, compaction)) {</span>
1543       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1544                                dense_prefix_end);
1545       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1546       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1547     }
1548 #endif  // #ifndef PRODUCT
1549 
1550     // Recompute the summary data, taking into account the dense prefix.  If
1551     // every last byte will be reclaimed, then the existing summary data which
1552     // compacts everything can be left in place.
1553     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1554       // If dead space crosses the dense prefix boundary, it is (at least
1555       // partially) filled with a dummy object, marked live and added to the
1556       // summary data.  This simplifies the copy/update phase and must be done
1557       // before the final locations of objects are determined, to prevent
1558       // leaving a fragment of dead space that is too small to fill.
1559       fill_dense_prefix_end(id);
1560 
1561       // Compute the destination of each Region, and thus each object.
1562       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
</pre>
<hr />
<pre>
1596       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1597       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1598       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1599       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1600       src_space_id, space_names[src_space_id],
1601       dst_space_id, space_names[dst_space_id],
1602       p2i(src_beg), p2i(src_end),
1603       _summary_data.addr_to_region_idx(src_beg),
1604       _summary_data.addr_to_region_idx(src_end),
1605       p2i(dst_beg), p2i(dst_end),
1606       _summary_data.addr_to_region_idx(dst_beg),
1607       _summary_data.addr_to_region_idx(dst_end));
1608 }
1609 #endif  // #ifndef PRODUCT
1610 
1611 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1612                                       bool maximum_compaction)
1613 {
1614   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1615 
<span class="line-modified">1616   log_develop_debug(gc, marking)(</span>
<span class="line-modified">1617       &quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1618       &quot;add_obj_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1619       add_obj_count,</span>
<span class="line-modified">1620       add_obj_size * HeapWordSize);</span>
<span class="line-modified">1621   log_develop_debug(gc, marking)(</span>
<span class="line-modified">1622       &quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1623       &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1624       mark_bitmap_count,</span>
<span class="line-modified">1625       mark_bitmap_size * HeapWordSize);</span>
1626 
1627   // Quick summarization of each space into itself, to see how much is live.
1628   summarize_spaces_quick();
1629 
1630   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1631   NOT_PRODUCT(print_region_ranges());
1632   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1633 
1634   // The amount of live data that will end up in old space (assuming it fits).
1635   size_t old_space_total_live = 0;
1636   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1637     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1638                                           _space_info[id].space()-&gt;bottom());
1639   }
1640 
1641   MutableSpace* const old_space = _space_info[old_space_id].space();
1642   const size_t old_capacity = old_space-&gt;capacity_in_words();
1643   if (old_space_total_live &gt; old_capacity) {
1644     // XXX - should also try to expand
1645     maximum_compaction = true;
</pre>
<hr />
<pre>
1699                                      space-&gt;bottom(), dst_space_end,
1700                                      new_top_addr);
1701       assert(done, &quot;space must fit when compacted into itself&quot;);
1702       assert(*new_top_addr &lt;= space-&gt;top(), &quot;usage should not grow&quot;);
1703     }
1704   }
1705 
1706   log_develop_trace(gc, compaction)(&quot;Summary_phase:  after final summarization&quot;);
1707   NOT_PRODUCT(print_region_ranges());
1708   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1709 }
1710 
1711 // This method should contain all heap-specific policy for invoking a full
1712 // collection.  invoke_no_policy() will only attempt to compact the heap; it
1713 // will do nothing further.  If we need to bail out for policy reasons, scavenge
1714 // before full gc, or any other specialized behavior, it needs to be added here.
1715 //
1716 // Note that this method should only be called from the vm_thread while at a
1717 // safepoint.
1718 //
<span class="line-modified">1719 // Note that the all_soft_refs_clear flag in the soft ref policy</span>
1720 // may be true because this method can be called without intervening
1721 // activity.  For example when the heap space is tight and full measure
1722 // are being taken to free space.
1723 void PSParallelCompact::invoke(bool maximum_heap_compaction) {
1724   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
1725   assert(Thread::current() == (Thread*)VMThread::vm_thread(),
1726          &quot;should be in vm thread&quot;);
1727 
1728   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1729   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1730   assert(!heap-&gt;is_gc_active(), &quot;not reentrant&quot;);
1731 
1732   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
1733   IsGCActiveMark mark;
1734 
1735   if (ScavengeBeforeFullGC) {
1736     PSScavenge::invoke_no_policy();
1737   }
1738 
1739   const bool clear_all_soft_refs =
</pre>
<hr />
<pre>
1752   if (GCLocker::check_active_before_gc()) {
1753     return false;
1754   }
1755 
1756   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1757 
1758   GCIdMark gc_id_mark;
1759   _gc_timer.register_gc_start();
1760   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
1761 
1762   TimeStamp marking_start;
1763   TimeStamp compaction_start;
1764   TimeStamp collection_exit;
1765 
1766   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1767   PSYoungGen* young_gen = heap-&gt;young_gen();
1768   PSOldGen* old_gen = heap-&gt;old_gen();
1769   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
1770 
1771   // The scope of casr should end after code that can change
<span class="line-modified">1772   // SoftRefPolicy::_should_clear_all_soft_refs.</span>
1773   ClearedAllSoftRefs casr(maximum_heap_compaction,
1774                           heap-&gt;soft_ref_policy());
1775 
1776   if (ZapUnusedHeapArea) {
1777     // Save information needed to minimize mangling
1778     heap-&gt;record_gen_tops_before_GC();
1779   }
1780 
1781   // Make sure data structures are sane, make the heap parsable, and do other
1782   // miscellaneous bookkeeping.
1783   pre_compact();
1784 
<span class="line-modified">1785   const PreGenGCValues pre_gc_values = heap-&gt;get_pre_gc_values();</span>
1786 
1787   // Get the compaction manager reserved for the VM thread.
1788   ParCompactionManager* const vmthread_cm =
<span class="line-modified">1789     ParCompactionManager::manager_array(ParallelScavengeHeap::heap()-&gt;workers().total_workers());</span>
1790 
1791   {
1792     ResourceMark rm;
1793     HandleMark hm;
1794 
<span class="line-modified">1795     const uint active_workers =</span>
<span class="line-modified">1796       WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()-&gt;workers().total_workers(),</span>
<span class="line-modified">1797                                         ParallelScavengeHeap::heap()-&gt;workers().active_workers(),</span>
<span class="line-added">1798                                         Threads::number_of_non_daemon_threads());</span>
<span class="line-added">1799     ParallelScavengeHeap::heap()-&gt;workers().update_active_workers(active_workers);</span>
1800 
1801     GCTraceCPUTime tcpu;
1802     GCTraceTime(Info, gc) tm(&quot;Pause Full&quot;, NULL, gc_cause, true);
1803 
1804     heap-&gt;pre_full_gc_dump(&amp;_gc_timer);
1805 
1806     TraceCollectorStats tcs(counters());
1807     TraceMemoryManagerStats tms(heap-&gt;old_gc_manager(), gc_cause);
1808 
1809     if (log_is_enabled(Debug, gc, heap, exit)) {
1810       accumulated_time()-&gt;start();
1811     }
1812 
1813     // Let the size policy know we&#39;re starting
1814     size_policy-&gt;major_collection_begin();
1815 
1816 #if COMPILER2_OR_JVMCI
1817     DerivedPointerTable::clear();
1818 #endif
1819 
</pre>
<hr />
<pre>
1911 
1912       log_debug(gc, ergo)(&quot;AdaptiveSizeStop: collection: %d &quot;, heap-&gt;total_collections());
1913     }
1914 
1915     if (UsePerfData) {
1916       PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
1917       counters-&gt;update_counters();
1918       counters-&gt;update_old_capacity(old_gen-&gt;capacity_in_bytes());
1919       counters-&gt;update_young_capacity(young_gen-&gt;capacity_in_bytes());
1920     }
1921 
1922     heap-&gt;resize_all_tlabs();
1923 
1924     // Resize the metaspace capacity after a collection
1925     MetaspaceGC::compute_new_size();
1926 
1927     if (log_is_enabled(Debug, gc, heap, exit)) {
1928       accumulated_time()-&gt;stop();
1929     }
1930 
<span class="line-modified">1931     heap-&gt;print_heap_change(pre_gc_values);</span>


1932 
1933     // Track memory usage and detect low memory
1934     MemoryService::track_memory_usage();
1935     heap-&gt;update_counters();

1936 
1937     heap-&gt;post_full_gc_dump(&amp;_gc_timer);
1938   }
1939 
1940 #ifdef ASSERT
1941   for (size_t i = 0; i &lt; ParallelGCThreads + 1; ++i) {
1942     ParCompactionManager* const cm =
1943       ParCompactionManager::manager_array(int(i));
1944     assert(cm-&gt;marking_stack()-&gt;is_empty(),       &quot;should be empty&quot;);
1945     assert(cm-&gt;region_stack()-&gt;is_empty(), &quot;Region stack &quot; SIZE_FORMAT &quot; is not empty&quot;, i);
1946   }
1947 #endif // ASSERT
1948 
1949   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1950     HandleMark hm;  // Discard invalid handles created during verification
1951     Universe::verify(&quot;After GC&quot;);
1952   }
1953 
1954   // Re-verify object start arrays
1955   if (VerifyObjectStartArray &amp;&amp;
1956       VerifyAfterGC) {
1957     old_gen-&gt;verify_object_start_array();
1958   }
1959 
1960   if (ZapUnusedHeapArea) {
1961     old_gen-&gt;object_space()-&gt;check_mangled_unused_area_complete();
1962   }
1963 
1964   NOT_PRODUCT(ref_processor()-&gt;verify_no_references_recorded());
1965 
1966   collection_exit.update();
1967 
1968   heap-&gt;print_heap_after_gc();
1969   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
1970 
1971   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
1972                          marking_start.ticks(), compaction_start.ticks(),
1973                          collection_exit.ticks());





1974 
1975   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
1976 
1977   _gc_timer.register_gc_end();
1978 
1979   _gc_tracer.report_dense_prefix(dense_prefix(old_space_id));
1980   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
1981 
1982   return true;
1983 }
1984 
1985 bool PSParallelCompact::absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1986                                              PSYoungGen* young_gen,
1987                                              PSOldGen* old_gen) {
1988   MutableSpace* const eden_space = young_gen-&gt;eden_space();
1989   assert(!eden_space-&gt;is_empty(), &quot;eden must be non-empty&quot;);
1990   assert(young_gen-&gt;virtual_space()-&gt;alignment() ==
1991          old_gen-&gt;virtual_space()-&gt;alignment(), &quot;alignments do not match&quot;);
1992 
<span class="line-modified">1993   // We also return false when it&#39;s a heterogeneous heap because old generation cannot absorb data from eden</span>
1994   // when it is allocated on different memory (example, nv-dimm) than young.
1995   if (!(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary) ||
<span class="line-modified">1996       ParallelArguments::is_heterogeneous_heap()) {</span>
1997     return false;
1998   }
1999 
2000   // Both generations must be completely committed.
2001   if (young_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2002     return false;
2003   }
2004   if (old_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2005     return false;
2006   }
2007 
2008   // Figure out how much to take from eden.  Include the average amount promoted
2009   // in the total; otherwise the next young gen GC will simply bail out to a
2010   // full GC.
2011   const size_t alignment = old_gen-&gt;virtual_space()-&gt;alignment();
2012   const size_t eden_used = eden_space-&gt;used_in_bytes();
2013   const size_t promoted = (size_t)size_policy-&gt;avg_promoted()-&gt;padded_average();
2014   const size_t absorb_size = align_up(eden_used + promoted, alignment);
2015   const size_t eden_capacity = eden_space-&gt;capacity_in_bytes();
2016 
</pre>
<hr />
<pre>
2054   young_gen-&gt;reset_after_change();
2055   old_space-&gt;set_top(new_top);
2056   old_space-&gt;set_end(new_top);
2057   old_gen-&gt;reset_after_change();
2058 
2059   // Update the object start array for the filler object and the data from eden.
2060   ObjectStartArray* const start_array = old_gen-&gt;start_array();
2061   for (HeapWord* p = unused_start; p &lt; new_top; p += oop(p)-&gt;size()) {
2062     start_array-&gt;allocate_block(p);
2063   }
2064 
2065   // Could update the promoted average here, but it is not typically updated at
2066   // full GCs and the value to use is unclear.  Something like
2067   //
2068   // cur_promoted_avg + absorb_size / number_of_scavenges_since_last_full_gc.
2069 
2070   size_policy-&gt;set_bytes_absorbed_from_eden(absorb_size);
2071   return true;
2072 }
2073 






2074 class PCAddThreadRootsMarkingTaskClosure : public ThreadClosure {
2075 private:
<span class="line-modified">2076   uint _worker_id;</span>
2077 
2078 public:
<span class="line-modified">2079   PCAddThreadRootsMarkingTaskClosure(uint worker_id) : _worker_id(worker_id) { }</span>
<span class="line-modified">2080   void do_thread(Thread* thread) {</span>
<span class="line-modified">2081     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">2082 </span>
<span class="line-added">2083     ResourceMark rm;</span>
<span class="line-added">2084 </span>
<span class="line-added">2085     ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(_worker_id);</span>
<span class="line-added">2086 </span>
<span class="line-added">2087     PCMarkAndPushClosure mark_and_push_closure(cm);</span>
<span class="line-added">2088     MarkingCodeBlobClosure mark_and_push_in_blobs(&amp;mark_and_push_closure, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">2089 </span>
<span class="line-added">2090     thread-&gt;oops_do(&amp;mark_and_push_closure, &amp;mark_and_push_in_blobs);</span>
<span class="line-added">2091 </span>
<span class="line-added">2092     // Do the real work</span>
<span class="line-added">2093     cm-&gt;follow_marking_stacks();</span>
<span class="line-added">2094   }</span>
<span class="line-added">2095 };</span>
<span class="line-added">2096 </span>
<span class="line-added">2097 static void mark_from_roots_work(ParallelRootType::Value root_type, uint worker_id) {</span>
<span class="line-added">2098   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">2099 </span>
<span class="line-added">2100   ParCompactionManager* cm =</span>
<span class="line-added">2101     ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2102   PCMarkAndPushClosure mark_and_push_closure(cm);</span>
<span class="line-added">2103 </span>
<span class="line-added">2104   switch (root_type) {</span>
<span class="line-added">2105     case ParallelRootType::universe:</span>
<span class="line-added">2106       Universe::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2107       break;</span>
<span class="line-added">2108 </span>
<span class="line-added">2109     case ParallelRootType::jni_handles:</span>
<span class="line-added">2110       JNIHandles::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2111       break;</span>
<span class="line-added">2112 </span>
<span class="line-added">2113     case ParallelRootType::object_synchronizer:</span>
<span class="line-added">2114       ObjectSynchronizer::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2115       break;</span>
<span class="line-added">2116 </span>
<span class="line-added">2117     case ParallelRootType::management:</span>
<span class="line-added">2118       Management::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2119       break;</span>
<span class="line-added">2120 </span>
<span class="line-added">2121     case ParallelRootType::jvmti:</span>
<span class="line-added">2122       JvmtiExport::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2123       break;</span>
<span class="line-added">2124 </span>
<span class="line-added">2125     case ParallelRootType::system_dictionary:</span>
<span class="line-added">2126       SystemDictionary::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2127       break;</span>
<span class="line-added">2128 </span>
<span class="line-added">2129     case ParallelRootType::class_loader_data:</span>
<span class="line-added">2130       {</span>
<span class="line-added">2131         CLDToOopClosure cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);</span>
<span class="line-added">2132         ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);</span>
<span class="line-added">2133       }</span>
<span class="line-added">2134       break;</span>
<span class="line-added">2135 </span>
<span class="line-added">2136     case ParallelRootType::code_cache:</span>
<span class="line-added">2137       // Do not treat nmethods as strong roots for mark/sweep, since we can unload them.</span>
<span class="line-added">2138       //ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure(&amp;mark_and_push_closure));</span>
<span class="line-added">2139       AOTLoader::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-added">2140       break;</span>
<span class="line-added">2141 </span>
<span class="line-added">2142     case ParallelRootType::sentinel:</span>
<span class="line-added">2143     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds</span>
<span class="line-added">2144       fatal(&quot;Bad enumeration value: %u&quot;, root_type);</span>
<span class="line-added">2145       break;</span>
<span class="line-added">2146   }</span>
<span class="line-added">2147 </span>
<span class="line-added">2148   // Do the real work</span>
<span class="line-added">2149   cm-&gt;follow_marking_stacks();</span>
<span class="line-added">2150 }</span>
<span class="line-added">2151 </span>
<span class="line-added">2152 static void steal_marking_work(TaskTerminator&amp; terminator, uint worker_id) {</span>
<span class="line-added">2153   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">2154 </span>
<span class="line-added">2155   ParCompactionManager* cm =</span>
<span class="line-added">2156     ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2157 </span>
<span class="line-added">2158   oop obj = NULL;</span>
<span class="line-added">2159   ObjArrayTask task;</span>
<span class="line-added">2160   do {</span>
<span class="line-added">2161     while (ParCompactionManager::steal_objarray(worker_id,  task)) {</span>
<span class="line-added">2162       cm-&gt;follow_array((objArrayOop)task.obj(), task.index());</span>
<span class="line-added">2163       cm-&gt;follow_marking_stacks();</span>
<span class="line-added">2164     }</span>
<span class="line-added">2165     while (ParCompactionManager::steal(worker_id, obj)) {</span>
<span class="line-added">2166       cm-&gt;follow_contents(obj);</span>
<span class="line-added">2167       cm-&gt;follow_marking_stacks();</span>
<span class="line-added">2168     }</span>
<span class="line-added">2169   } while (!terminator.offer_termination());</span>
<span class="line-added">2170 }</span>
<span class="line-added">2171 </span>
<span class="line-added">2172 class MarkFromRootsTask : public AbstractGangTask {</span>
<span class="line-added">2173   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="line-added">2174   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do</span>
<span class="line-added">2175   SequentialSubTasksDone _subtasks;</span>
<span class="line-added">2176   TaskTerminator _terminator;</span>
<span class="line-added">2177   uint _active_workers;</span>
<span class="line-added">2178 </span>
<span class="line-added">2179 public:</span>
<span class="line-added">2180   MarkFromRootsTask(uint active_workers) :</span>
<span class="line-added">2181       AbstractGangTask(&quot;MarkFromRootsTask&quot;),</span>
<span class="line-added">2182       _strong_roots_scope(active_workers),</span>
<span class="line-added">2183       _subtasks(),</span>
<span class="line-added">2184       _terminator(active_workers, ParCompactionManager::oop_task_queues()),</span>
<span class="line-added">2185       _active_workers(active_workers) {</span>
<span class="line-added">2186     _subtasks.set_n_threads(active_workers);</span>
<span class="line-added">2187     _subtasks.set_n_tasks(ParallelRootType::sentinel);</span>
<span class="line-added">2188   }</span>
<span class="line-added">2189 </span>
<span class="line-added">2190   virtual void work(uint worker_id) {</span>
<span class="line-added">2191     for (uint task = 0; _subtasks.try_claim_task(task); /*empty*/ ) {</span>
<span class="line-added">2192       mark_from_roots_work(static_cast&lt;ParallelRootType::Value&gt;(task), worker_id);</span>
<span class="line-added">2193     }</span>
<span class="line-added">2194     _subtasks.all_tasks_completed();</span>
<span class="line-added">2195 </span>
<span class="line-added">2196     PCAddThreadRootsMarkingTaskClosure closure(worker_id);</span>
<span class="line-added">2197     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);</span>
<span class="line-added">2198 </span>
<span class="line-added">2199     if (_active_workers &gt; 1) {</span>
<span class="line-added">2200       steal_marking_work(_terminator, worker_id);</span>
<span class="line-added">2201     }</span>
<span class="line-added">2202   }</span>
<span class="line-added">2203 };</span>
<span class="line-added">2204 </span>
<span class="line-added">2205 class PCRefProcTask : public AbstractGangTask {</span>
<span class="line-added">2206   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="line-added">2207   ProcessTask&amp; _task;</span>
<span class="line-added">2208   uint _ergo_workers;</span>
<span class="line-added">2209   TaskTerminator _terminator;</span>
<span class="line-added">2210 </span>
<span class="line-added">2211 public:</span>
<span class="line-added">2212   PCRefProcTask(ProcessTask&amp; task, uint ergo_workers) :</span>
<span class="line-added">2213       AbstractGangTask(&quot;PCRefProcTask&quot;),</span>
<span class="line-added">2214       _task(task),</span>
<span class="line-added">2215       _ergo_workers(ergo_workers),</span>
<span class="line-added">2216       _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {</span>
<span class="line-added">2217   }</span>
<span class="line-added">2218 </span>
<span class="line-added">2219   virtual void work(uint worker_id) {</span>
<span class="line-added">2220     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-added">2221     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">2222 </span>
<span class="line-added">2223     ParCompactionManager* cm =</span>
<span class="line-added">2224       ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2225     PCMarkAndPushClosure mark_and_push_closure(cm);</span>
<span class="line-added">2226     ParCompactionManager::FollowStackClosure follow_stack_closure(cm);</span>
<span class="line-added">2227     _task.work(worker_id, *PSParallelCompact::is_alive_closure(),</span>
<span class="line-added">2228                mark_and_push_closure, follow_stack_closure);</span>
<span class="line-added">2229 </span>
<span class="line-added">2230     steal_marking_work(_terminator, worker_id);</span>
<span class="line-added">2231   }</span>
<span class="line-added">2232 };</span>
<span class="line-added">2233 </span>
<span class="line-added">2234 class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {</span>
<span class="line-added">2235   void execute(ProcessTask&amp; process_task, uint ergo_workers) {</span>
<span class="line-added">2236     assert(ParallelScavengeHeap::heap()-&gt;workers().active_workers() == ergo_workers,</span>
<span class="line-added">2237            &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,</span>
<span class="line-added">2238            ergo_workers, ParallelScavengeHeap::heap()-&gt;workers().active_workers());</span>
<span class="line-added">2239 </span>
<span class="line-added">2240     PCRefProcTask task(process_task, ergo_workers);</span>
<span class="line-added">2241     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
2242   }
2243 };
2244 
2245 void PSParallelCompact::marking_phase(ParCompactionManager* cm,
2246                                       bool maximum_heap_compaction,
2247                                       ParallelOldTracer *gc_tracer) {
2248   // Recursively traverse all live objects and mark them
2249   GCTraceTime(Info, gc, phases) tm(&quot;Marking Phase&quot;, &amp;_gc_timer);
2250 
2251   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-modified">2252   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();</span>



2253 
2254   PCMarkAndPushClosure mark_and_push_closure(cm);
2255   ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
2256 
2257   // Need new claim bits before marking starts.
2258   ClassLoaderDataGraph::clear_claimed_marks();
2259 
2260   {
2261     GCTraceTime(Debug, gc, phases) tm(&quot;Par Mark&quot;, &amp;_gc_timer);
2262 
<span class="line-modified">2263     MarkFromRootsTask task(active_gc_threads);</span>
<span class="line-modified">2264     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>





















2265   }
2266 
2267   // Process reference objects found during marking
2268   {
2269     GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
2270 
2271     ReferenceProcessorStats stats;
2272     ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, ref_processor()-&gt;max_num_queues());
2273 
2274     if (ref_processor()-&gt;processing_is_mt()) {
2275       ref_processor()-&gt;set_active_mt_degree(active_gc_threads);
2276 
2277       RefProcTaskExecutor task_executor;
2278       stats = ref_processor()-&gt;process_discovered_references(
2279         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure,
2280         &amp;task_executor, &amp;pt);
2281     } else {
2282       stats = ref_processor()-&gt;process_discovered_references(
2283         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure, NULL,
2284         &amp;pt);
</pre>
<hr />
<pre>
2290 
2291   // This is the point where the entire marking should have completed.
2292   assert(cm-&gt;marking_stacks_empty(), &quot;Marking should have completed&quot;);
2293 
2294   {
2295     GCTraceTime(Debug, gc, phases) tm(&quot;Weak Processing&quot;, &amp;_gc_timer);
2296     WeakProcessor::weak_oops_do(is_alive_closure(), &amp;do_nothing_cl);
2297   }
2298 
2299   {
2300     GCTraceTime(Debug, gc, phases) tm_m(&quot;Class Unloading&quot;, &amp;_gc_timer);
2301 
2302     // Follow system dictionary roots and unload classes.
2303     bool purged_class = SystemDictionary::do_unloading(&amp;_gc_timer);
2304 
2305     // Unload nmethods.
2306     CodeCache::do_unloading(is_alive_closure(), purged_class);
2307 
2308     // Prune dead klasses from subklass/sibling/implementor lists.
2309     Klass::clean_weak_klass_links(purged_class);
<span class="line-added">2310 </span>
<span class="line-added">2311     // Clean JVMCI metadata handles.</span>
<span class="line-added">2312     JVMCI_ONLY(JVMCI::do_unloading(purged_class));</span>
2313   }
2314 
2315   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2316 }
2317 
2318 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2319   // Adjust the pointers to reflect the new locations
2320   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2321 
2322   // Need new claim bits when tracing through and adjusting pointers.
2323   ClassLoaderDataGraph::clear_claimed_marks();
2324 
2325   PCAdjustPointerClosure oop_closure(cm);
2326 
2327   // General strong roots.
2328   Universe::oops_do(&amp;oop_closure);
2329   JNIHandles::oops_do(&amp;oop_closure);   // Global (strong) JNI handles
2330   Threads::oops_do(&amp;oop_closure, NULL);
2331   ObjectSynchronizer::oops_do(&amp;oop_closure);
2332   Management::oops_do(&amp;oop_closure);
2333   JvmtiExport::oops_do(&amp;oop_closure);
2334   SystemDictionary::oops_do(&amp;oop_closure);
2335   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2336   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2337 
2338   // Now adjust pointers in remaining weak roots.  (All of which should
2339   // have been cleared if they pointed to non-surviving objects.)
2340   WeakProcessor::oops_do(&amp;oop_closure);
2341 
2342   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2343   CodeCache::blobs_do(&amp;adjust_from_blobs);
<span class="line-modified">2344   AOT_ONLY(AOTLoader::oops_do(&amp;oop_closure);)</span>
<span class="line-added">2345 </span>
2346   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2347   // Roots were visited so references into the young gen in roots
2348   // may have been scanned.  Process them also.
2349   // Should the reference processor have a span that excludes
2350   // young gen objects?
2351   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2352 }
2353 
2354 // Helper class to print 8 region numbers per line and then print the total at the end.
2355 class FillableRegionLogger : public StackObj {
2356 private:
2357   Log(gc, compaction) log;
2358   static const int LineLength = 8;
2359   size_t _regions[LineLength];
2360   int _next_index;
2361   bool _enabled;
2362   size_t _total_regions;
2363 public:
2364   FillableRegionLogger() : _next_index(0), _enabled(log_develop_is_enabled(Trace, gc, compaction)), _total_regions(0) { }
2365   ~FillableRegionLogger() {
</pre>
<hr />
<pre>
2373     FormatBuffer&lt;&gt; line(&quot;Fillable: &quot;);
2374     for (int i = 0; i &lt; _next_index; i++) {
2375       line.append(&quot; &quot; SIZE_FORMAT_W(7), _regions[i]);
2376     }
2377     log.trace(&quot;%s&quot;, line.buffer());
2378     _next_index = 0;
2379   }
2380 
2381   void handle(size_t region) {
2382     if (!_enabled) {
2383       return;
2384     }
2385     _regions[_next_index++] = region;
2386     if (_next_index == LineLength) {
2387       print_line();
2388     }
2389     _total_regions++;
2390   }
2391 };
2392 
<span class="line-modified">2393 void PSParallelCompact::prepare_region_draining_tasks(uint parallel_gc_threads)</span>

2394 {
2395   GCTraceTime(Trace, gc, phases) tm(&quot;Drain Task Setup&quot;, &amp;_gc_timer);
2396 
2397   // Find the threads that are active
<span class="line-modified">2398   uint worker_id = 0;</span>
2399 
2400   // Find all regions that are available (can be filled immediately) and
2401   // distribute them to the thread stacks.  The iteration is done in reverse
2402   // order (high to low) so the regions will be removed in ascending order.
2403 
2404   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2405 

2406   // id + 1 is used to test termination so unsigned  can
2407   // be used with an old_space_id == 0.
2408   FillableRegionLogger region_logger;
2409   for (unsigned int id = to_space_id; id + 1 &gt; old_space_id; --id) {
2410     SpaceInfo* const space_info = _space_info + id;
2411     MutableSpace* const space = space_info-&gt;space();
2412     HeapWord* const new_top = space_info-&gt;new_top();
2413 
2414     const size_t beg_region = sd.addr_to_region_idx(space_info-&gt;dense_prefix());
2415     const size_t end_region =
2416       sd.addr_to_region_idx(sd.region_align_up(new_top));
2417 
2418     for (size_t cur = end_region - 1; cur + 1 &gt; beg_region; --cur) {
2419       if (sd.region(cur)-&gt;claim_unsafe()) {
<span class="line-modified">2420         ParCompactionManager* cm = ParCompactionManager::manager_array(worker_id);</span>
<span class="line-added">2421         bool result = sd.region(cur)-&gt;mark_normal();</span>
<span class="line-added">2422         assert(result, &quot;Must succeed at this point.&quot;);</span>
2423         cm-&gt;region_stack()-&gt;push(cur);
2424         region_logger.handle(cur);
2425         // Assign regions to tasks in round-robin fashion.
<span class="line-modified">2426         if (++worker_id == parallel_gc_threads) {</span>
<span class="line-modified">2427           worker_id = 0;</span>
2428         }
2429       }
2430     }
2431     region_logger.print_line();
2432   }
2433 }
2434 
<span class="line-added">2435 class TaskQueue : StackObj {</span>
<span class="line-added">2436   volatile uint _counter;</span>
<span class="line-added">2437   uint _size;</span>
<span class="line-added">2438   uint _insert_index;</span>
<span class="line-added">2439   PSParallelCompact::UpdateDensePrefixTask* _backing_array;</span>
<span class="line-added">2440 public:</span>
<span class="line-added">2441   explicit TaskQueue(uint size) : _counter(0), _size(size), _insert_index(0), _backing_array(NULL) {</span>
<span class="line-added">2442     _backing_array = NEW_C_HEAP_ARRAY(PSParallelCompact::UpdateDensePrefixTask, _size, mtGC);</span>
<span class="line-added">2443   }</span>
<span class="line-added">2444   ~TaskQueue() {</span>
<span class="line-added">2445     assert(_counter &gt;= _insert_index, &quot;not all queue elements were claimed&quot;);</span>
<span class="line-added">2446     FREE_C_HEAP_ARRAY(T, _backing_array);</span>
<span class="line-added">2447   }</span>
<span class="line-added">2448 </span>
<span class="line-added">2449   void push(const PSParallelCompact::UpdateDensePrefixTask&amp; value) {</span>
<span class="line-added">2450     assert(_insert_index &lt; _size, &quot;too small backing array&quot;);</span>
<span class="line-added">2451     _backing_array[_insert_index++] = value;</span>
<span class="line-added">2452   }</span>
<span class="line-added">2453 </span>
<span class="line-added">2454   bool try_claim(PSParallelCompact::UpdateDensePrefixTask&amp; reference) {</span>
<span class="line-added">2455     uint claimed = Atomic::fetch_and_add(&amp;_counter, 1u);</span>
<span class="line-added">2456     if (claimed &lt; _insert_index) {</span>
<span class="line-added">2457       reference = _backing_array[claimed];</span>
<span class="line-added">2458       return true;</span>
<span class="line-added">2459     } else {</span>
<span class="line-added">2460       return false;</span>
<span class="line-added">2461     }</span>
<span class="line-added">2462   }</span>
<span class="line-added">2463 };</span>
<span class="line-added">2464 </span>
2465 #define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4
2466 
<span class="line-modified">2467 void PSParallelCompact::enqueue_dense_prefix_tasks(TaskQueue&amp; task_queue,</span>
<span class="line-modified">2468                                                    uint parallel_gc_threads) {</span>
2469   GCTraceTime(Trace, gc, phases) tm(&quot;Dense Prefix Task Setup&quot;, &amp;_gc_timer);
2470 
2471   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2472 
2473   // Iterate over all the spaces adding tasks for updating
2474   // regions in the dense prefix.  Assume that 1 gc thread
2475   // will work on opening the gaps and the remaining gc threads
2476   // will work on the dense prefix.
2477   unsigned int space_id;
2478   for (space_id = old_space_id; space_id &lt; last_space_id; ++ space_id) {
2479     HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();
2480     const MutableSpace* const space = _space_info[space_id].space();
2481 
2482     if (dense_prefix_end == space-&gt;bottom()) {
2483       // There is no dense prefix for this space.
2484       continue;
2485     }
2486 
2487     // The dense prefix is before this region.
2488     size_t region_index_end_dense_prefix =
</pre>
<hr />
<pre>
2511         tasks_for_dense_prefix = parallel_gc_threads;
2512       } else {
2513         // Over partition
2514         tasks_for_dense_prefix = parallel_gc_threads *
2515           PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;
2516       }
2517       size_t regions_per_thread = total_dense_prefix_regions /
2518         tasks_for_dense_prefix;
2519       // Give each thread at least 1 region.
2520       if (regions_per_thread == 0) {
2521         regions_per_thread = 1;
2522       }
2523 
2524       for (uint k = 0; k &lt; tasks_for_dense_prefix; k++) {
2525         if (region_index_start &gt;= region_index_end_dense_prefix) {
2526           break;
2527         }
2528         // region_index_end is not processed
2529         size_t region_index_end = MIN2(region_index_start + regions_per_thread,
2530                                        region_index_end_dense_prefix);
<span class="line-modified">2531         task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2532                                               region_index_start,</span>
<span class="line-modified">2533                                               region_index_end));</span>
2534         region_index_start = region_index_end;
2535       }
2536     }
2537     // This gets any part of the dense prefix that did not
2538     // fit evenly.
2539     if (region_index_start &lt; region_index_end_dense_prefix) {
<span class="line-modified">2540       task_queue.push(UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2541                                             region_index_start,</span>
<span class="line-modified">2542                                             region_index_end_dense_prefix));</span>
2543     }
2544   }
2545 }
2546 













2547 #ifdef ASSERT
2548 // Write a histogram of the number of times the block table was filled for a
2549 // region.
2550 void PSParallelCompact::write_block_fill_histogram()
2551 {
2552   if (!log_develop_is_enabled(Trace, gc, compaction)) {
2553     return;
2554   }
2555 
2556   Log(gc, compaction) log;
2557   ResourceMark rm;
2558   LogStream ls(log.trace());
2559   outputStream* out = &amp;ls;
2560 
2561   typedef ParallelCompactData::RegionData rd_t;
2562   ParallelCompactData&amp; sd = summary_data();
2563 
2564   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2565     MutableSpace* const spc = _space_info[id].space();
2566     if (spc-&gt;bottom() != spc-&gt;top()) {
</pre>
<hr />
<pre>
2569       const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);
2570 
2571       size_t histo[5] = { 0, 0, 0, 0, 0 };
2572       const size_t histo_len = sizeof(histo) / sizeof(size_t);
2573       const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));
2574 
2575       for (const rd_t* cur = beg; cur &lt; end; ++cur) {
2576         ++histo[MIN2(cur-&gt;blocks_filled_count(), histo_len - 1)];
2577       }
2578       out-&gt;print(&quot;Block fill histogram: %u %-4s&quot; SIZE_FORMAT_W(5), id, space_names[id], region_cnt);
2579       for (size_t i = 0; i &lt; histo_len; ++i) {
2580         out-&gt;print(&quot; &quot; SIZE_FORMAT_W(5) &quot; %5.1f%%&quot;,
2581                    histo[i], 100.0 * histo[i] / region_cnt);
2582       }
2583       out-&gt;cr();
2584     }
2585   }
2586 }
2587 #endif // #ifdef ASSERT
2588 
<span class="line-added">2589 static void compaction_with_stealing_work(TaskTerminator* terminator, uint worker_id) {</span>
<span class="line-added">2590   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">2591 </span>
<span class="line-added">2592   ParCompactionManager* cm =</span>
<span class="line-added">2593     ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2594 </span>
<span class="line-added">2595   // Drain the stacks that have been preloaded with regions</span>
<span class="line-added">2596   // that are ready to fill.</span>
<span class="line-added">2597 </span>
<span class="line-added">2598   cm-&gt;drain_region_stacks();</span>
<span class="line-added">2599 </span>
<span class="line-added">2600   guarantee(cm-&gt;region_stack()-&gt;is_empty(), &quot;Not empty&quot;);</span>
<span class="line-added">2601 </span>
<span class="line-added">2602   size_t region_index = 0;</span>
<span class="line-added">2603 </span>
<span class="line-added">2604   while (true) {</span>
<span class="line-added">2605     if (ParCompactionManager::steal(worker_id, region_index)) {</span>
<span class="line-added">2606       PSParallelCompact::fill_and_update_region(cm, region_index);</span>
<span class="line-added">2607       cm-&gt;drain_region_stacks();</span>
<span class="line-added">2608     } else if (PSParallelCompact::steal_unavailable_region(cm, region_index)) {</span>
<span class="line-added">2609       // Fill and update an unavailable region with the help of a shadow region</span>
<span class="line-added">2610       PSParallelCompact::fill_and_update_shadow_region(cm, region_index);</span>
<span class="line-added">2611       cm-&gt;drain_region_stacks();</span>
<span class="line-added">2612     } else {</span>
<span class="line-added">2613       if (terminator-&gt;offer_termination()) {</span>
<span class="line-added">2614         break;</span>
<span class="line-added">2615       }</span>
<span class="line-added">2616       // Go around again.</span>
<span class="line-added">2617     }</span>
<span class="line-added">2618   }</span>
<span class="line-added">2619   return;</span>
<span class="line-added">2620 }</span>
<span class="line-added">2621 </span>
<span class="line-added">2622 class UpdateDensePrefixAndCompactionTask: public AbstractGangTask {</span>
<span class="line-added">2623   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="line-added">2624   TaskQueue&amp; _tq;</span>
<span class="line-added">2625   TaskTerminator _terminator;</span>
<span class="line-added">2626   uint _active_workers;</span>
<span class="line-added">2627 </span>
<span class="line-added">2628 public:</span>
<span class="line-added">2629   UpdateDensePrefixAndCompactionTask(TaskQueue&amp; tq, uint active_workers) :</span>
<span class="line-added">2630       AbstractGangTask(&quot;UpdateDensePrefixAndCompactionTask&quot;),</span>
<span class="line-added">2631       _tq(tq),</span>
<span class="line-added">2632       _terminator(active_workers, ParCompactionManager::region_task_queues()),</span>
<span class="line-added">2633       _active_workers(active_workers) {</span>
<span class="line-added">2634   }</span>
<span class="line-added">2635   virtual void work(uint worker_id) {</span>
<span class="line-added">2636     ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2637 </span>
<span class="line-added">2638     for (PSParallelCompact::UpdateDensePrefixTask task; _tq.try_claim(task); /* empty */) {</span>
<span class="line-added">2639       PSParallelCompact::update_and_deadwood_in_dense_prefix(cm,</span>
<span class="line-added">2640                                                              task._space_id,</span>
<span class="line-added">2641                                                              task._region_index_start,</span>
<span class="line-added">2642                                                              task._region_index_end);</span>
<span class="line-added">2643     }</span>
<span class="line-added">2644 </span>
<span class="line-added">2645     // Once a thread has drained it&#39;s stack, it should try to steal regions from</span>
<span class="line-added">2646     // other threads.</span>
<span class="line-added">2647     compaction_with_stealing_work(&amp;_terminator, worker_id);</span>
<span class="line-added">2648   }</span>
<span class="line-added">2649 };</span>
<span class="line-added">2650 </span>
2651 void PSParallelCompact::compact() {
2652   GCTraceTime(Info, gc, phases) tm(&quot;Compaction Phase&quot;, &amp;_gc_timer);
2653 
2654   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2655   PSOldGen* old_gen = heap-&gt;old_gen();
2656   old_gen-&gt;start_array()-&gt;reset();
<span class="line-modified">2657   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();</span>



2658 
<span class="line-modified">2659   // for [0..last_space_id)</span>
<span class="line-modified">2660   //     for [0..active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)</span>
<span class="line-modified">2661   //         push</span>
<span class="line-modified">2662   //     push</span>
<span class="line-added">2663   //</span>
<span class="line-added">2664   // max push count is thus: last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1)</span>
<span class="line-added">2665   TaskQueue task_queue(last_space_id * (active_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING + 1));</span>
<span class="line-added">2666   initialize_shadow_regions(active_gc_threads);</span>
<span class="line-added">2667   prepare_region_draining_tasks(active_gc_threads);</span>
<span class="line-added">2668   enqueue_dense_prefix_tasks(task_queue, active_gc_threads);</span>
2669 
2670   {
2671     GCTraceTime(Trace, gc, phases) tm(&quot;Par Compact&quot;, &amp;_gc_timer);
2672 
<span class="line-modified">2673     UpdateDensePrefixAndCompactionTask task(task_queue, active_gc_threads);</span>
<span class="line-added">2674     ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
2675 
2676 #ifdef  ASSERT
2677     // Verify that all regions have been processed before the deferred updates.
2678     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2679       verify_complete(SpaceId(id));
2680     }
2681 #endif
2682   }
2683 
2684   {
2685     // Update the deferred objects, if any.  Any compaction manager can be used.
2686     GCTraceTime(Trace, gc, phases) tm(&quot;Deferred Updates&quot;, &amp;_gc_timer);
2687     ParCompactionManager* cm = ParCompactionManager::manager_array(0);
2688     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2689       update_deferred_objects(cm, SpaceId(id));
2690     }
2691   }
2692 
2693   DEBUG_ONLY(write_block_fill_histogram());
2694 }
</pre>
<hr />
<pre>
2840       }
2841       cm-&gt;update_contents(oop(addr));
2842       assert(oopDesc::is_oop_or_null(oop(addr)), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(oop(addr)));
2843     }
2844   }
2845 }
2846 
2847 // Skip over count live words starting from beg, and return the address of the
2848 // next live word.  Unless marked, the word corresponding to beg is assumed to
2849 // be dead.  Callers must either ensure beg does not correspond to the middle of
2850 // an object, or account for those live words in some other way.  Callers must
2851 // also ensure that there are enough live words in the range [beg, end) to skip.
2852 HeapWord*
2853 PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)
2854 {
2855   assert(count &gt; 0, &quot;sanity&quot;);
2856 
2857   ParMarkBitMap* m = mark_bitmap();
2858   idx_t bits_to_skip = m-&gt;words_to_bits(count);
2859   idx_t cur_beg = m-&gt;addr_to_bit(beg);
<span class="line-modified">2860   const idx_t search_end = m-&gt;align_range_end(m-&gt;addr_to_bit(end));</span>
2861 
2862   do {
2863     cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2864     idx_t cur_end = m-&gt;find_obj_end(cur_beg, search_end);
2865     const size_t obj_bits = cur_end - cur_beg + 1;
2866     if (obj_bits &gt; bits_to_skip) {
2867       return m-&gt;bit_to_addr(cur_beg + bits_to_skip);
2868     }
2869     bits_to_skip -= obj_bits;
2870     cur_beg = cur_end + 1;
2871   } while (bits_to_skip &gt; 0);
2872 
2873   // Skipping the desired number of words landed just past the end of an object.
2874   // Find the start of the next object.
2875   cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2876   assert(cur_beg &lt; m-&gt;addr_to_bit(end), &quot;not enough live words to skip&quot;);
2877   return m-&gt;bit_to_addr(cur_beg);
2878 }
2879 
2880 HeapWord* PSParallelCompact::first_src_addr(HeapWord* const dest_addr,
</pre>
<hr />
<pre>
2953   MutableSpace* const src_space = _space_info[src_space_id].space();
2954   HeapWord* const beg_addr = sd.region_to_addr(beg_region);
2955   assert(src_space-&gt;contains(beg_addr) || beg_addr == src_space-&gt;end(),
2956          &quot;src_space_id does not match beg_addr&quot;);
2957   assert(src_space-&gt;contains(end_addr) || end_addr == src_space-&gt;end(),
2958          &quot;src_space_id does not match end_addr&quot;);
2959 #endif // #ifdef ASSERT
2960 
2961   RegionData* const beg = sd.region(beg_region);
2962   RegionData* const end = sd.addr_to_region_ptr(sd.region_align_up(end_addr));
2963 
2964   // Regions up to new_top() are enqueued if they become available.
2965   HeapWord* const new_top = _space_info[src_space_id].new_top();
2966   RegionData* const enqueue_end =
2967     sd.addr_to_region_ptr(sd.region_align_up(new_top));
2968 
2969   for (RegionData* cur = beg; cur &lt; end; ++cur) {
2970     assert(cur-&gt;data_size() &gt; 0, &quot;region must have live data&quot;);
2971     cur-&gt;decrement_destination_count();
2972     if (cur &lt; enqueue_end &amp;&amp; cur-&gt;available() &amp;&amp; cur-&gt;claim()) {
<span class="line-modified">2973       if (cur-&gt;mark_normal()) {</span>
<span class="line-added">2974         cm-&gt;push_region(sd.region(cur));</span>
<span class="line-added">2975       } else if (cur-&gt;mark_copied()) {</span>
<span class="line-added">2976         // Try to copy the content of the shadow region back to its corresponding</span>
<span class="line-added">2977         // heap region if the shadow region is filled. Otherwise, the GC thread</span>
<span class="line-added">2978         // fills the shadow region will copy the data back (see</span>
<span class="line-added">2979         // MoveAndUpdateShadowClosure::complete_region).</span>
<span class="line-added">2980         copy_back(sd.region_to_addr(cur-&gt;shadow_region()), sd.region_to_addr(cur));</span>
<span class="line-added">2981         ParCompactionManager::push_shadow_region_mt_safe(cur-&gt;shadow_region());</span>
<span class="line-added">2982         cur-&gt;set_completed();</span>
<span class="line-added">2983       }</span>
2984     }
2985   }
2986 }
2987 
2988 size_t PSParallelCompact::next_src_region(MoveAndUpdateClosure&amp; closure,
2989                                           SpaceId&amp; src_space_id,
2990                                           HeapWord*&amp; src_space_top,
2991                                           HeapWord* end_addr)
2992 {
2993   typedef ParallelCompactData::RegionData RegionData;
2994 
2995   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2996   const size_t region_size = ParallelCompactData::RegionSize;
2997 
2998   size_t src_region_idx = 0;
2999 
3000   // Skip empty regions (if any) up to the top of the space.
3001   HeapWord* const src_aligned_up = sd.region_align_up(end_addr);
3002   RegionData* src_region_ptr = sd.addr_to_region_ptr(src_aligned_up);
3003   HeapWord* const top_aligned_up = sd.region_align_up(src_space_top);
</pre>
<hr />
<pre>
3041                  &quot;first live obj in the space must match the destination&quot;);
3042           assert(src_cp-&gt;partial_obj_size() == 0,
3043                  &quot;a space cannot begin with a partial obj&quot;);
3044 
3045           src_space_id = SpaceId(space_id);
3046           src_space_top = space-&gt;top();
3047           const size_t src_region_idx = sd.region(src_cp);
3048           closure.set_source(sd.region_to_addr(src_region_idx));
3049           return src_region_idx;
3050         } else {
3051           assert(src_cp-&gt;data_size() == 0, &quot;sanity&quot;);
3052         }
3053       }
3054     }
3055   } while (++space_id &lt; last_space_id);
3056 
3057   assert(false, &quot;no source region was found&quot;);
3058   return 0;
3059 }
3060 
<span class="line-modified">3061 void PSParallelCompact::fill_region(ParCompactionManager* cm, MoveAndUpdateClosure&amp; closure, size_t region_idx)</span>
3062 {
3063   typedef ParMarkBitMap::IterationStatus IterationStatus;

3064   ParMarkBitMap* const bitmap = mark_bitmap();
3065   ParallelCompactData&amp; sd = summary_data();
3066   RegionData* const region_ptr = sd.region(region_idx);
3067 








3068   // Get the source region and related info.
3069   size_t src_region_idx = region_ptr-&gt;source_region();
3070   SpaceId src_space_id = space_id(sd.region_to_addr(src_region_idx));
3071   HeapWord* src_space_top = _space_info[src_space_id].space()-&gt;top();
<span class="line-added">3072   HeapWord* dest_addr = sd.region_to_addr(region_idx);</span>
3073 

3074   closure.set_source(first_src_addr(dest_addr, src_space_id, src_region_idx));
3075 
3076   // Adjust src_region_idx to prepare for decrementing destination counts (the
3077   // destination count is not decremented when a region is copied to itself).
3078   if (src_region_idx == region_idx) {
3079     src_region_idx += 1;
3080   }
3081 
3082   if (bitmap-&gt;is_unmarked(closure.source())) {
3083     // The first source word is in the middle of an object; copy the remainder
3084     // of the object or as much as will fit.  The fact that pointer updates were
3085     // deferred will be noted when the object header is processed.
3086     HeapWord* const old_src_addr = closure.source();
3087     closure.copy_partial_obj();
3088     if (closure.is_full()) {
3089       decrement_destination_counts(cm, src_space_id, src_region_idx,
3090                                    closure.source());
3091       region_ptr-&gt;set_deferred_obj_addr(NULL);
<span class="line-modified">3092       closure.complete_region(cm, dest_addr, region_ptr);</span>
3093       return;
3094     }
3095 
3096     HeapWord* const end_addr = sd.region_align_down(closure.source());
3097     if (sd.region_align_down(old_src_addr) != end_addr) {
3098       // The partial object was copied from more than one source region.
3099       decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
3100 
3101       // Move to the next source region, possibly switching spaces as well.  All
3102       // args except end_addr may be modified.
3103       src_region_idx = next_src_region(closure, src_space_id, src_space_top,
3104                                        end_addr);
3105     }
3106   }
3107 
3108   do {
3109     HeapWord* const cur_addr = closure.source();
3110     HeapWord* const end_addr = MIN2(sd.region_align_up(cur_addr + 1),
3111                                     src_space_top);
3112     IterationStatus status = bitmap-&gt;iterate(&amp;closure, cur_addr, end_addr);
</pre>
<hr />
<pre>
3121       HeapWord* const obj_end = bitmap-&gt;find_obj_end(obj_beg, range_end);
3122       if (obj_end &lt; range_end) {
3123         // The end was found; the entire object will fit.
3124         status = closure.do_addr(obj_beg, bitmap-&gt;obj_size(obj_beg, obj_end));
3125         assert(status != ParMarkBitMap::would_overflow, &quot;sanity&quot;);
3126       } else {
3127         // The end was not found; the object will not fit.
3128         assert(range_end &lt; src_space_top, &quot;obj cannot cross space boundary&quot;);
3129         status = ParMarkBitMap::would_overflow;
3130       }
3131     }
3132 
3133     if (status == ParMarkBitMap::would_overflow) {
3134       // The last object did not fit.  Note that interior oop updates were
3135       // deferred, then copy enough of the object to fill the region.
3136       region_ptr-&gt;set_deferred_obj_addr(closure.destination());
3137       status = closure.copy_until_full(); // copies from closure.source()
3138 
3139       decrement_destination_counts(cm, src_space_id, src_region_idx,
3140                                    closure.source());
<span class="line-modified">3141       closure.complete_region(cm, dest_addr, region_ptr);</span>
3142       return;
3143     }
3144 
3145     if (status == ParMarkBitMap::full) {
3146       decrement_destination_counts(cm, src_space_id, src_region_idx,
3147                                    closure.source());
3148       region_ptr-&gt;set_deferred_obj_addr(NULL);
<span class="line-modified">3149       closure.complete_region(cm, dest_addr, region_ptr);</span>
3150       return;
3151     }
3152 
3153     decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
3154 
3155     // Move to the next source region, possibly switching spaces as well.  All
3156     // args except end_addr may be modified.
3157     src_region_idx = next_src_region(closure, src_space_id, src_space_top,
3158                                      end_addr);
3159   } while (true);
3160 }
3161 
<span class="line-added">3162 void PSParallelCompact::fill_and_update_region(ParCompactionManager* cm, size_t region_idx)</span>
<span class="line-added">3163 {</span>
<span class="line-added">3164   MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);</span>
<span class="line-added">3165   fill_region(cm, cl, region_idx);</span>
<span class="line-added">3166 }</span>
<span class="line-added">3167 </span>
<span class="line-added">3168 void PSParallelCompact::fill_and_update_shadow_region(ParCompactionManager* cm, size_t region_idx)</span>
<span class="line-added">3169 {</span>
<span class="line-added">3170   // Get a shadow region first</span>
<span class="line-added">3171   ParallelCompactData&amp; sd = summary_data();</span>
<span class="line-added">3172   RegionData* const region_ptr = sd.region(region_idx);</span>
<span class="line-added">3173   size_t shadow_region = ParCompactionManager::pop_shadow_region_mt_safe(region_ptr);</span>
<span class="line-added">3174   // The InvalidShadow return value indicates the corresponding heap region is available,</span>
<span class="line-added">3175   // so use MoveAndUpdateClosure to fill the normal region. Otherwise, use</span>
<span class="line-added">3176   // MoveAndUpdateShadowClosure to fill the acquired shadow region.</span>
<span class="line-added">3177   if (shadow_region == ParCompactionManager::InvalidShadow) {</span>
<span class="line-added">3178     MoveAndUpdateClosure cl(mark_bitmap(), cm, region_idx);</span>
<span class="line-added">3179     region_ptr-&gt;shadow_to_normal();</span>
<span class="line-added">3180     return fill_region(cm, cl, region_idx);</span>
<span class="line-added">3181   } else {</span>
<span class="line-added">3182     MoveAndUpdateShadowClosure cl(mark_bitmap(), cm, region_idx, shadow_region);</span>
<span class="line-added">3183     return fill_region(cm, cl, region_idx);</span>
<span class="line-added">3184   }</span>
<span class="line-added">3185 }</span>
<span class="line-added">3186 </span>
<span class="line-added">3187 void PSParallelCompact::copy_back(HeapWord *shadow_addr, HeapWord *region_addr)</span>
<span class="line-added">3188 {</span>
<span class="line-added">3189   Copy::aligned_conjoint_words(shadow_addr, region_addr, _summary_data.RegionSize);</span>
<span class="line-added">3190 }</span>
<span class="line-added">3191 </span>
<span class="line-added">3192 bool PSParallelCompact::steal_unavailable_region(ParCompactionManager* cm, size_t &amp;region_idx)</span>
<span class="line-added">3193 {</span>
<span class="line-added">3194   size_t next = cm-&gt;next_shadow_region();</span>
<span class="line-added">3195   ParallelCompactData&amp; sd = summary_data();</span>
<span class="line-added">3196   size_t old_new_top = sd.addr_to_region_idx(_space_info[old_space_id].new_top());</span>
<span class="line-added">3197   uint active_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().active_workers();</span>
<span class="line-added">3198 </span>
<span class="line-added">3199   while (next &lt; old_new_top) {</span>
<span class="line-added">3200     if (sd.region(next)-&gt;mark_shadow()) {</span>
<span class="line-added">3201       region_idx = next;</span>
<span class="line-added">3202       return true;</span>
<span class="line-added">3203     }</span>
<span class="line-added">3204     next = cm-&gt;move_next_shadow_region_by(active_gc_threads);</span>
<span class="line-added">3205   }</span>
<span class="line-added">3206 </span>
<span class="line-added">3207   return false;</span>
<span class="line-added">3208 }</span>
<span class="line-added">3209 </span>
<span class="line-added">3210 // The shadow region is an optimization to address region dependencies in full GC. The basic</span>
<span class="line-added">3211 // idea is making more regions available by temporally storing their live objects in empty</span>
<span class="line-added">3212 // shadow regions to resolve dependencies between them and the destination regions. Therefore,</span>
<span class="line-added">3213 // GC threads need not wait destination regions to be available before processing sources.</span>
<span class="line-added">3214 //</span>
<span class="line-added">3215 // A typical workflow would be:</span>
<span class="line-added">3216 // After draining its own stack and failing to steal from others, a GC worker would pick an</span>
<span class="line-added">3217 // unavailable region (destination count &gt; 0) and get a shadow region. Then the worker fills</span>
<span class="line-added">3218 // the shadow region by copying live objects from source regions of the unavailable one. Once</span>
<span class="line-added">3219 // the unavailable region becomes available, the data in the shadow region will be copied back.</span>
<span class="line-added">3220 // Shadow regions are empty regions in the to-space and regions between top and end of other spaces.</span>
<span class="line-added">3221 //</span>
<span class="line-added">3222 // For more details, please refer to 4.2 of the VEE&#39;19 paper:</span>
<span class="line-added">3223 // Haoyu Li, Mingyu Wu, Binyu Zang, and Haibo Chen. 2019. ScissorGC: scalable and efficient</span>
<span class="line-added">3224 // compaction for Java full garbage collection. In Proceedings of the 15th ACM SIGPLAN/SIGOPS</span>
<span class="line-added">3225 // International Conference on Virtual Execution Environments (VEE 2019). ACM, New York, NY, USA,</span>
<span class="line-added">3226 // 108-121. DOI: https://doi.org/10.1145/3313808.3313820</span>
<span class="line-added">3227 void PSParallelCompact::initialize_shadow_regions(uint parallel_gc_threads)</span>
<span class="line-added">3228 {</span>
<span class="line-added">3229   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();</span>
<span class="line-added">3230 </span>
<span class="line-added">3231   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {</span>
<span class="line-added">3232     SpaceInfo* const space_info = _space_info + id;</span>
<span class="line-added">3233     MutableSpace* const space = space_info-&gt;space();</span>
<span class="line-added">3234 </span>
<span class="line-added">3235     const size_t beg_region =</span>
<span class="line-added">3236       sd.addr_to_region_idx(sd.region_align_up(MAX2(space_info-&gt;new_top(), space-&gt;top())));</span>
<span class="line-added">3237     const size_t end_region =</span>
<span class="line-added">3238       sd.addr_to_region_idx(sd.region_align_down(space-&gt;end()));</span>
<span class="line-added">3239 </span>
<span class="line-added">3240     for (size_t cur = beg_region; cur &lt; end_region; ++cur) {</span>
<span class="line-added">3241       ParCompactionManager::push_shadow_region(cur);</span>
<span class="line-added">3242     }</span>
<span class="line-added">3243   }</span>
<span class="line-added">3244 </span>
<span class="line-added">3245   size_t beg_region = sd.addr_to_region_idx(_space_info[old_space_id].dense_prefix());</span>
<span class="line-added">3246   for (uint i = 0; i &lt; parallel_gc_threads; i++) {</span>
<span class="line-added">3247     ParCompactionManager *cm = ParCompactionManager::manager_array(i);</span>
<span class="line-added">3248     cm-&gt;set_next_shadow_region(beg_region + i);</span>
<span class="line-added">3249   }</span>
<span class="line-added">3250 }</span>
<span class="line-added">3251 </span>
3252 void PSParallelCompact::fill_blocks(size_t region_idx)
3253 {
3254   // Fill in the block table elements for the specified region.  Each block
3255   // table element holds the number of live words in the region that are to the
3256   // left of the first object that starts in the block.  Thus only blocks in
3257   // which an object starts need to be filled.
3258   //
3259   // The algorithm scans the section of the bitmap that corresponds to the
3260   // region, keeping a running total of the live words.  When an object start is
3261   // found, if it&#39;s the first to start in the block that contains it, the
3262   // current total is written to the block table element.
3263   const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;
3264   const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;
3265   const size_t RegionSize = ParallelCompactData::RegionSize;
3266 
3267   ParallelCompactData&amp; sd = summary_data();
3268   const size_t partial_obj_size = sd.region(region_idx)-&gt;partial_obj_size();
3269   if (partial_obj_size &gt;= RegionSize) {
3270     return; // No objects start in this region.
3271   }
</pre>
<hr />
<pre>
3283   const size_t range_end = beg_bit + bitmap-&gt;words_to_bits(RegionSize);
3284   size_t live_bits = bitmap-&gt;words_to_bits(partial_obj_size);
3285   beg_bit = bitmap-&gt;find_obj_beg(beg_bit + live_bits, range_end);
3286   while (beg_bit &lt; range_end) {
3287     const size_t new_block = beg_bit &gt;&gt; Log2BitsPerBlock;
3288     if (new_block != cur_block) {
3289       cur_block = new_block;
3290       sd.block(cur_block)-&gt;set_offset(bitmap-&gt;bits_to_words(live_bits));
3291     }
3292 
3293     const size_t end_bit = bitmap-&gt;find_obj_end(beg_bit, range_end);
3294     if (end_bit &lt; range_end - 1) {
3295       live_bits += end_bit - beg_bit + 1;
3296       beg_bit = bitmap-&gt;find_obj_beg(end_bit + 1, range_end);
3297     } else {
3298       return;
3299     }
3300   }
3301 }
3302 








































3303 jlong PSParallelCompact::millis_since_last_gc() {
3304   // We need a monotonically non-decreasing time in ms but
3305   // os::javaTimeMillis() does not guarantee monotonicity.
3306   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3307   jlong ret_val = now - _time_of_last_gc;
3308   // XXX See note in genCollectedHeap::millis_since_last_gc().
3309   if (ret_val &lt; 0) {
3310     NOT_PRODUCT(log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT, ret_val);)
3311     return 0;
3312   }
3313   return ret_val;
3314 }
3315 
3316 void PSParallelCompact::reset_millis_since_last_gc() {
3317   // We need a monotonically non-decreasing time in ms but
3318   // os::javaTimeMillis() does not guarantee monotonicity.
3319   _time_of_last_gc = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3320 }
3321 
3322 ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()
3323 {
<span class="line-modified">3324   if (source() != copy_destination()) {</span>
3325     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3326     Copy::aligned_conjoint_words(source(), copy_destination(), words_remaining());</span>
3327   }
3328   update_state(words_remaining());
3329   assert(is_full(), &quot;sanity&quot;);
3330   return ParMarkBitMap::full;
3331 }
3332 
3333 void MoveAndUpdateClosure::copy_partial_obj()
3334 {
3335   size_t words = words_remaining();
3336 
3337   HeapWord* const range_end = MIN2(source() + words, bitmap()-&gt;region_end());
3338   HeapWord* const end_addr = bitmap()-&gt;find_obj_end(source(), range_end);
3339   if (end_addr &lt; range_end) {
3340     words = bitmap()-&gt;obj_size(source(), end_addr);
3341   }
3342 
3343   // This test is necessary; if omitted, the pointer updates to a partial object
3344   // that crosses the dense prefix boundary could be overwritten.
<span class="line-modified">3345   if (source() != copy_destination()) {</span>
3346     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3347     Copy::aligned_conjoint_words(source(), copy_destination(), words);</span>
3348   }
3349   update_state(words);
3350 }
3351 
<span class="line-added">3352 void MoveAndUpdateClosure::complete_region(ParCompactionManager *cm, HeapWord *dest_addr,</span>
<span class="line-added">3353                                            PSParallelCompact::RegionData *region_ptr) {</span>
<span class="line-added">3354   assert(region_ptr-&gt;shadow_state() == ParallelCompactData::RegionData::NormalRegion, &quot;Region should be finished&quot;);</span>
<span class="line-added">3355   region_ptr-&gt;set_completed();</span>
<span class="line-added">3356 }</span>
<span class="line-added">3357 </span>
3358 ParMarkBitMapClosure::IterationStatus
3359 MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {
3360   assert(destination() != NULL, &quot;sanity&quot;);
3361   assert(bitmap()-&gt;obj_size(addr) == words, &quot;bad size&quot;);
3362 
3363   _source = addr;
3364   assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==
3365          destination(), &quot;wrong destination&quot;);
3366 
3367   if (words &gt; words_remaining()) {
3368     return ParMarkBitMap::would_overflow;
3369   }
3370 
3371   // The start_array must be updated even if the object is not moving.
3372   if (_start_array != NULL) {
3373     _start_array-&gt;allocate_block(destination());
3374   }
3375 
<span class="line-modified">3376   if (copy_destination() != source()) {</span>
3377     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<span class="line-modified">3378     Copy::aligned_conjoint_words(source(), copy_destination(), words);</span>
3379   }
3380 
<span class="line-modified">3381   oop moved_oop = (oop) copy_destination();</span>
3382   compaction_manager()-&gt;update_contents(moved_oop);
3383   assert(oopDesc::is_oop_or_null(moved_oop), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(moved_oop));
3384 
3385   update_state(words);
<span class="line-modified">3386   assert(copy_destination() == cast_from_oop&lt;HeapWord*&gt;(moved_oop) + moved_oop-&gt;size(), &quot;sanity&quot;);</span>
3387   return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;
3388 }
3389 
<span class="line-added">3390 void MoveAndUpdateShadowClosure::complete_region(ParCompactionManager *cm, HeapWord *dest_addr,</span>
<span class="line-added">3391                                                  PSParallelCompact::RegionData *region_ptr) {</span>
<span class="line-added">3392   assert(region_ptr-&gt;shadow_state() == ParallelCompactData::RegionData::ShadowRegion, &quot;Region should be shadow&quot;);</span>
<span class="line-added">3393   // Record the shadow region index</span>
<span class="line-added">3394   region_ptr-&gt;set_shadow_region(_shadow);</span>
<span class="line-added">3395   // Mark the shadow region as filled to indicate the data is ready to be</span>
<span class="line-added">3396   // copied back</span>
<span class="line-added">3397   region_ptr-&gt;mark_filled();</span>
<span class="line-added">3398   // Try to copy the content of the shadow region back to its corresponding</span>
<span class="line-added">3399   // heap region if available; the GC thread that decreases the destination</span>
<span class="line-added">3400   // count to zero will do the copying otherwise (see</span>
<span class="line-added">3401   // PSParallelCompact::decrement_destination_counts).</span>
<span class="line-added">3402   if (((region_ptr-&gt;available() &amp;&amp; region_ptr-&gt;claim()) || region_ptr-&gt;claimed()) &amp;&amp; region_ptr-&gt;mark_copied()) {</span>
<span class="line-added">3403     region_ptr-&gt;set_completed();</span>
<span class="line-added">3404     PSParallelCompact::copy_back(PSParallelCompact::summary_data().region_to_addr(_shadow), dest_addr);</span>
<span class="line-added">3405     ParCompactionManager::push_shadow_region_mt_safe(_shadow);</span>
<span class="line-added">3406   }</span>
<span class="line-added">3407 }</span>
<span class="line-added">3408 </span>
3409 UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,
3410                                      ParCompactionManager* cm,
3411                                      PSParallelCompact::SpaceId space_id) :
3412   ParMarkBitMapClosure(mbm, cm),
3413   _space_id(space_id),
3414   _start_array(PSParallelCompact::start_array(space_id))
3415 {
3416 }
3417 
3418 // Updates the references in the object to their new values.
3419 ParMarkBitMapClosure::IterationStatus
3420 UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {
3421   do_addr(addr);
3422   return ParMarkBitMap::incomplete;
3423 }
3424 
3425 FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :
3426   ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),
3427   _start_array(PSParallelCompact::start_array(space_id))
3428 {
</pre>
</td>
</tr>
</table>
<center><a href="psOldGen.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psParallelCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>