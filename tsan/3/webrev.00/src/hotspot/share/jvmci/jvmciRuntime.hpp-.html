<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
 25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
 26 
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/arguments.hpp&quot;
 30 #include &quot;runtime/deoptimization.hpp&quot;
 31 
 32 #define JVMCI_ERROR(...)       \
 33   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return; }
 34 
 35 #define JVMCI_ERROR_(ret, ...) \
 36   { Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::jdk_vm_ci_common_JVMCIError(), __VA_ARGS__); return ret; }
 37 
 38 #define JVMCI_ERROR_0(...)    JVMCI_ERROR_(0, __VA_ARGS__)
 39 #define JVMCI_ERROR_NULL(...) JVMCI_ERROR_(NULL, __VA_ARGS__)
 40 #define JVMCI_ERROR_OK(...)   JVMCI_ERROR_(JVMCIEnv::ok, __VA_ARGS__)
 41 #define CHECK_OK              CHECK_(JVMCIEnv::ok)
 42 
 43 class JVMCIRuntime: public AllStatic {
 44  public:
 45   // Constants describing whether JVMCI wants to be able to adjust the compilation
 46   // level selected for a method by the VM compilation policy and if so, based on
 47   // what information about the method being schedule for compilation.
 48   enum CompLevelAdjustment {
 49      none = 0,             // no adjustment
 50      by_holder = 1,        // adjust based on declaring class of method
 51      by_full_signature = 2 // adjust based on declaring class, name and signature of method
 52   };
 53 
 54  private:
 55   static jobject _HotSpotJVMCIRuntime_instance;
 56   static bool _HotSpotJVMCIRuntime_initialized;
 57   static bool _well_known_classes_initialized;
 58 
 59   static CompLevelAdjustment _comp_level_adjustment;
 60 
 61   static bool _shutdown_called;
 62 
 63   static CompLevel adjust_comp_level_inner(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);
 64 
 65  public:
 66   static bool is_HotSpotJVMCIRuntime_initialized() {
 67     return _HotSpotJVMCIRuntime_initialized;
 68   }
 69 
 70   /**
 71    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
 72    */
 73   static Handle get_HotSpotJVMCIRuntime(TRAPS);
 74 
 75   static jobject get_HotSpotJVMCIRuntime_jobject(TRAPS) {
 76     initialize_JVMCI(CHECK_NULL);
 77     assert(_HotSpotJVMCIRuntime_initialized, &quot;must be&quot;);
 78     return _HotSpotJVMCIRuntime_instance;
 79   }
 80 
 81   static Handle callStatic(const char* className, const char* methodName, const char* returnType, JavaCallArguments* args, TRAPS);
 82 
 83   /**
 84    * Determines if the VM is sufficiently booted to initialize JVMCI.
 85    */
 86   static bool can_initialize_JVMCI();
 87 
 88   /**
 89    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
 90    */
 91   static void initialize_JVMCI(TRAPS);
 92 
 93   /**
 94    * Explicitly initialize HotSpotJVMCIRuntime itself
 95    */
 96   static void initialize_HotSpotJVMCIRuntime(TRAPS);
 97 
 98   static void initialize_well_known_classes(TRAPS);
 99 
100   static void metadata_do(void f(Metadata*));
101 
102   static void shutdown(TRAPS);
103 
104   static void bootstrap_finished(TRAPS);
105 
106   static bool shutdown_called() {
107     return _shutdown_called;
108   }
109 
110   /**
111    * Lets JVMCI modify the compilation level currently selected for a method by
112    * the VM compilation policy.
113    *
114    * @param method the method being scheduled for compilation
115    * @param is_osr specifies if the compilation is an OSR compilation
116    * @param level the compilation level currently selected by the VM compilation policy
117    * @param thread the current thread
118    * @return the compilation level to use for the compilation
119    */
120   static CompLevel adjust_comp_level(const methodHandle&amp; method, bool is_osr, CompLevel level, JavaThread* thread);
121 
122   static BasicType kindToBasicType(Handle kind, TRAPS);
123 
124   static void new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail);
125   static void new_array_common(JavaThread* thread, Klass* klass, jint length, bool null_on_fail);
126   static void new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail);
127   static void dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail);
128   static void dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail);
129 
130   // The following routines are called from compiled JVMCI code
131 
132   // When allocation fails, these stubs:
133   // 1. Exercise -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError handling and also
134   //    post a JVMTI_EVENT_RESOURCE_EXHAUSTED event if the failure is an OutOfMemroyError
135   // 2. Return NULL with a pending exception.
136   // Compiled code must ensure these stubs are not called twice for the same allocation
137   // site due to the non-repeatable side effects in the case of OOME.
138   static void new_instance(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, false); }
139   static void new_array(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, false); }
140   static void new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, false); }
141   static void dynamic_new_array(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, false); }
142   static void dynamic_new_instance(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, false); }
143 
144   // When allocation fails, these stubs return NULL and have no pending exception. Compiled code
145   // can use these stubs if a failed allocation will be retried (e.g., by deoptimizing and
146   // re-executing in the interpreter).
147   static void new_instance_or_null(JavaThread* thread, Klass* klass) { new_instance_common(thread, klass, true); }
148   static void new_array_or_null(JavaThread* thread, Klass* klass, jint length) { new_array_common(thread, klass, length, true); }
149   static void new_multi_array_or_null(JavaThread* thread, Klass* klass, int rank, jint* dims) { new_multi_array_common(thread, klass, rank, dims, true); }
150   static void dynamic_new_array_or_null(JavaThread* thread, oopDesc* element_mirror, jint length) { dynamic_new_array_common(thread, element_mirror, length, true); }
151   static void dynamic_new_instance_or_null(JavaThread* thread, oopDesc* type_mirror) { dynamic_new_instance_common(thread, type_mirror, true); }
152 
153   static jboolean thread_is_interrupted(JavaThread* thread, oopDesc* obj, jboolean clear_interrupted);
154   static void vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3);
155   static jint identity_hash_code(JavaThread* thread, oopDesc* obj);
156   static address exception_handler_for_pc(JavaThread* thread);
157   static void monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock);
158   static void monitorexit (JavaThread* thread, oopDesc* obj, BasicLock* lock);
159   static jboolean object_notify(JavaThread* thread, oopDesc* obj);
160   static jboolean object_notifyAll(JavaThread* thread, oopDesc* obj);
161   static void vm_error(JavaThread* thread, jlong where, jlong format, jlong value);
162   static oopDesc* load_and_clear_exception(JavaThread* thread);
163   static void log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3);
164   static void log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline);
165   // Print the passed in object, optionally followed by a newline.  If
166   // as_string is true and the object is a java.lang.String then it
167   // printed as a string, otherwise the type of the object is printed
168   // followed by its address.
169   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
170 #if INCLUDE_G1GC
171   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
172   static void write_barrier_post(JavaThread* thread, void* card);
173 #endif
174   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
175 
176   // used to throw exceptions from compiled JVMCI code
177   static void throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
178   // helper methods to throw exception with complex messages
179   static void throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
180   static void throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
181 
182   // Forces initialization of the JVMCI runtime.
183   static void force_initialization(TRAPS);
184 
185   // Test only function
186   static int test_deoptimize_call_int(JavaThread* thread, int value);
187 };
188 
189 // Tracing macros.
190 
191 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else
192 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else
193 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else
194 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else
195 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else
196 
197 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(&quot;JVMCITrace-1: &quot;), true))) ; else tty-&gt;print_cr
198 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(&quot;   JVMCITrace-2: &quot;), true))) ; else tty-&gt;print_cr
199 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(&quot;      JVMCITrace-3: &quot;), true))) ; else tty-&gt;print_cr
200 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(&quot;         JVMCITrace-4: &quot;), true))) ; else tty-&gt;print_cr
201 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(&quot;            JVMCITrace-5: &quot;), true))) ; else tty-&gt;print_cr
202 
203 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
    </pre>
  </body>
</html>