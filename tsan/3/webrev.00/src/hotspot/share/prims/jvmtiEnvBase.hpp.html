<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvmtiEnvBase.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_PRIMS_JVMTIENVBASE_HPP
 26 #define SHARE_PRIMS_JVMTIENVBASE_HPP
 27 
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;prims/jvmtiEnvThreadState.hpp&quot;
 30 #include &quot;prims/jvmtiEventController.hpp&quot;
 31 #include &quot;prims/jvmtiThreadState.hpp&quot;
 32 #include &quot;oops/oopHandle.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;runtime/fieldDescriptor.hpp&quot;
 35 #include &quot;runtime/frame.hpp&quot;
 36 #include &quot;runtime/thread.hpp&quot;
 37 #include &quot;runtime/vmOperations.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 #include &quot;utilities/macros.hpp&quot;
 40 
 41 //
 42 // Forward Declarations
 43 //
 44 
 45 class JvmtiEnv;
 46 class JvmtiThreadState;
 47 class JvmtiRawMonitor; // for jvmtiEnv.hpp
 48 class JvmtiEventControllerPrivate;
 49 class JvmtiTagMap;
 50 
 51 
 52 
 53 // One JvmtiEnv object is created per jvmti attachment;
 54 // done via JNI GetEnv() call. Multiple attachments are
 55 // allowed in jvmti.
 56 
 57 class JvmtiEnvBase : public CHeapObj&lt;mtInternal&gt; {
 58 
 59  private:
 60 
 61 #if INCLUDE_JVMTI
 62   static JvmtiEnvBase*     _head_environment;  // head of environment list
 63 #endif // INCLUDE_JVMTI
 64 
 65   static bool              _globally_initialized;
 66   static jvmtiPhase        _phase;
 67   static volatile int      _dying_thread_env_iteration_count;
 68 
 69  public:
 70 
 71   enum {
 72     JDK15_JVMTI_VERSION = JVMTI_VERSION_1_0 +  33,  /* version: 1.0.33  */
 73     JDK16_JVMTI_VERSION = JVMTI_VERSION_1_1 + 102,  /* version: 1.1.102 */
 74     JDK17_JVMTI_VERSION = JVMTI_VERSION_1_2 +   2   /* version: 1.2.2   */
 75   };
 76 
 77   static jvmtiPhase  get_phase()                    { return _phase; }
 78   static jvmtiPhase  get_phase(jvmtiEnv* env)       { return ((JvmtiEnvBase*)JvmtiEnv_from_jvmti_env(env))-&gt;phase(); }
 79   static void  set_phase(jvmtiPhase phase)          { _phase = phase; }
 80   static bool is_vm_live()                          { return _phase == JVMTI_PHASE_LIVE; }
 81 
 82   static void entering_dying_thread_env_iteration() { ++_dying_thread_env_iteration_count; }
 83   static void leaving_dying_thread_env_iteration()  { --_dying_thread_env_iteration_count; }
 84   static bool is_inside_dying_thread_env_iteration(){ return _dying_thread_env_iteration_count &gt; 0; }
 85 
 86  private:
 87 
 88   enum {
 89       JVMTI_MAGIC    = 0x71EE,
 90       DISPOSED_MAGIC = 0xDEFC,
 91       BAD_MAGIC      = 0xDEAD
 92   };
 93 
 94   jvmtiEnv _jvmti_external;
 95   jint _magic;
 96   jint _version;  // version value passed to JNI GetEnv()
 97   JvmtiEnvBase* _next;
 98   bool _is_retransformable;
 99   const void *_env_local_storage;     // per env agent allocated data.
100   jvmtiEventCallbacks _event_callbacks;
101   jvmtiExtEventCallbacks _ext_event_callbacks;
102   JvmtiTagMap* volatile _tag_map;
103   JvmtiEnvEventEnable _env_event_enable;
104   jvmtiCapabilities _current_capabilities;
105   jvmtiCapabilities _prohibited_capabilities;
106   volatile bool _class_file_load_hook_ever_enabled;
107   static volatile bool _needs_clean_up;
108   char** _native_method_prefixes;
109   int    _native_method_prefix_count;
110 
111  protected:
112   JvmtiEnvBase(jint version);
113   ~JvmtiEnvBase();
114   void dispose();
115   void env_dispose();
116 
117   void set_env_local_storage(const void* data)     { _env_local_storage = data; }
118   const void* get_env_local_storage()              { return _env_local_storage; }
119 
120   void record_class_file_load_hook_enabled();
121   void record_first_time_class_file_load_hook_enabled();
122 
123   char** get_native_method_prefixes()              { return _native_method_prefixes; }
124   int    get_native_method_prefix_count()          { return _native_method_prefix_count; }
125   jvmtiError set_native_method_prefixes(jint prefix_count, char** prefixes);
126 
127  private:
128   friend class JvmtiEventControllerPrivate;
129   void initialize();
130   void set_event_callbacks(const jvmtiEventCallbacks* callbacks, jint size_of_callbacks);
131   static void globally_initialize();
132   static void periodic_clean_up();
133 
134   friend class JvmtiEnvIterator;
135   JvmtiEnv* next_environment()                     { return (JvmtiEnv*)_next; }
136   void set_next_environment(JvmtiEnvBase* env)     { _next = env; }
137   static JvmtiEnv* head_environment()              {
138     JVMTI_ONLY(return (JvmtiEnv*)_head_environment);
139     NOT_JVMTI(return NULL);
140   }
141 
142  public:
143 
144   jvmtiPhase  phase();
145   bool is_valid();
146 
147   bool use_version_1_0_semantics();  // agent asked for version 1.0
148   bool use_version_1_1_semantics();  // agent asked for version 1.1
149   bool use_version_1_2_semantics();  // agent asked for version 1.2
150 
151   bool is_retransformable()                        { return _is_retransformable; }
152 
153   static ByteSize jvmti_external_offset() {
154     return byte_offset_of(JvmtiEnvBase, _jvmti_external);
155   };
156 
157   static JvmtiEnv* JvmtiEnv_from_jvmti_env(jvmtiEnv *env) {
158     return (JvmtiEnv*)((intptr_t)env - in_bytes(jvmti_external_offset()));
159   };
160 
161   jvmtiCapabilities *get_capabilities()             { return &amp;_current_capabilities; }
162 
163   jvmtiCapabilities *get_prohibited_capabilities()  { return &amp;_prohibited_capabilities; }
164 
165   bool early_class_hook_env() {
166     return get_capabilities()-&gt;can_generate_early_class_hook_events != 0
167         &amp;&amp; get_capabilities()-&gt;can_generate_all_class_hook_events != 0;
168   }
169 
170   bool early_vmstart_env() {
171     return get_capabilities()-&gt;can_generate_early_vmstart != 0;
172   }
173 
174   static char** get_all_native_method_prefixes(int* count_ptr);
175 
176   // This test will answer true when all environments have been disposed and some have
177   // not yet been deallocated.  As a result, this test should only be used as an
178   // optimization for the no environment case.
179   static bool environments_might_exist() {
180     return head_environment() != NULL;
181   }
182 
183   static void check_for_periodic_clean_up();
184 
185   JvmtiEnvEventEnable *env_event_enable() {
186     return &amp;_env_event_enable;
187   }
188 
189   jvmtiError allocate(jlong size, unsigned char** mem_ptr) {
190     if (size &lt; 0) {
191       return JVMTI_ERROR_ILLEGAL_ARGUMENT;
192     }
193     if (size == 0) {
194       *mem_ptr = NULL;
195     } else {
196       *mem_ptr = (unsigned char *)os::malloc((size_t)size, mtInternal);
197       if (*mem_ptr == NULL) {
198         return JVMTI_ERROR_OUT_OF_MEMORY;
199       }
200     }
201     return JVMTI_ERROR_NONE;
202   }
203 
204   jvmtiError deallocate(unsigned char* mem) {
205     if (mem != NULL) {
206       os::free(mem);
207     }
208     return JVMTI_ERROR_NONE;
209   }
210 
211 
212   // Memory functions
213   unsigned char* jvmtiMalloc(jlong size);  // don&#39;t use this - call allocate
214 
215   // method to create a local handle
216   jobject jni_reference(Handle hndl);
217 
218   // method to create a local handle.
219   // This function allows caller to specify which
220   // threads local handle table to use.
221   jobject jni_reference(JavaThread *thread, Handle hndl);
222 
223   // method to destroy a local handle
224   void destroy_jni_reference(jobject jobj);
225 
226   // method to destroy a local handle.
227   // This function allows caller to specify which
228   // threads local handle table to use.
229   void destroy_jni_reference(JavaThread *thread, jobject jobj);
230 
231   jvmtiEnv* jvmti_external() { return &amp;_jvmti_external; };
232 
233 // Event Dispatch
234 
235   bool has_callback(jvmtiEvent event_type) {
236     assert(event_type &gt;= JVMTI_MIN_EVENT_TYPE_VAL &amp;&amp;
237            event_type &lt;= JVMTI_MAX_EVENT_TYPE_VAL, &quot;checking&quot;);
238     return ((void**)&amp;_event_callbacks)[event_type-JVMTI_MIN_EVENT_TYPE_VAL] != NULL;
239   }
240 
241   jvmtiEventCallbacks* callbacks() {
242     return &amp;_event_callbacks;
243   }
244 
245   jvmtiExtEventCallbacks* ext_callbacks() {
246     return &amp;_ext_event_callbacks;
247   }
248 
249   void set_tag_map(JvmtiTagMap* tag_map) {
250     _tag_map = tag_map;
251   }
252 
253   JvmtiTagMap* tag_map() {
254     return _tag_map;
255   }
256 
257   JvmtiTagMap* tag_map_acquire() {
258     return Atomic::load_acquire(&amp;_tag_map);
259   }
260 
261   void release_set_tag_map(JvmtiTagMap* tag_map) {
262     Atomic::release_store(&amp;_tag_map, tag_map);
263   }
264 
265   // return true if event is enabled globally or for any thread
266   // True only if there is a callback for it.
267   bool is_enabled(jvmtiEvent event_type) {
268     return _env_event_enable.is_enabled(event_type);
269   }
270 
271 // Random Utilities
272 
273  protected:
274   // helper methods for creating arrays of global JNI Handles from local Handles
275   // allocated into environment specific storage
276   jobject * new_jobjectArray(int length, Handle *handles);
277   jthread * new_jthreadArray(int length, Handle *handles);
278   jthreadGroup * new_jthreadGroupArray(int length, Handle *handles);
279 
280   // convert to a jni jclass from a non-null Klass*
281   jclass get_jni_class_non_null(Klass* k);
282 
283   jint count_locked_objects(JavaThread *java_thread, Handle hobj);
284   jvmtiError get_locked_objects_in_frame(JavaThread *calling_thread,
285                                    JavaThread* java_thread,
286                                    javaVFrame *jvf,
287                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitors_list,
288                                    jint depth);
289   vframe* vframeFor(JavaThread* java_thread, jint depth);
290 
291  public:
292   // get a field descriptor for the specified class and field
293   static bool get_field_descriptor(Klass* k, jfieldID field, fieldDescriptor* fd);
294 
295   // JVMTI API helper functions which are called at safepoint or thread is suspended.
296   jvmtiError get_frame_count(JvmtiThreadState *state, jint *count_ptr);
297   jvmtiError get_frame_location(JavaThread* java_thread, jint depth,
298                                               jmethodID* method_ptr, jlocation* location_ptr);
299   jvmtiError get_object_monitor_usage(JavaThread *calling_thread,
300                                                     jobject object, jvmtiMonitorUsage* info_ptr);
301   jvmtiError get_stack_trace(JavaThread *java_thread,
302                                            jint stack_depth, jint max_count,
303                                            jvmtiFrameInfo* frame_buffer, jint* count_ptr);
304   jvmtiError get_current_contended_monitor(JavaThread *calling_thread,
305                                                          JavaThread *java_thread,
306                                                          jobject *monitor_ptr);
307   jvmtiError get_owned_monitors(JavaThread *calling_thread, JavaThread* java_thread,
308                           GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors_list);
309   jvmtiError check_top_frame(JavaThread* current_thread, JavaThread* java_thread,
310                              jvalue value, TosState tos, Handle* ret_ob_h);
311   jvmtiError force_early_return(JavaThread* java_thread, jvalue value, TosState tos);
312 };
313 
314 // This class is the only safe means of iterating through environments.
315 // Note that this iteratation includes invalid environments pending
316 // deallocation -- in fact, some uses depend on this behavior.
317 
318 class JvmtiEnvIterator : public StackObj {
319  private:
320   bool _entry_was_marked;
321  public:
322   JvmtiEnvIterator() {
323     if (Threads::number_of_threads() == 0) {
324       _entry_was_marked = false; // we are single-threaded, no need
325     } else {
326       Thread::current()-&gt;entering_jvmti_env_iteration();
327       _entry_was_marked = true;
328     }
329   }
330   ~JvmtiEnvIterator() {
331     if (_entry_was_marked) {
332       Thread::current()-&gt;leaving_jvmti_env_iteration();
333     }
334   }
335   JvmtiEnv* first()                 { return JvmtiEnvBase::head_environment(); }
336   JvmtiEnv* next(JvmtiEnvBase* env) { return env-&gt;next_environment(); }
337 };
338 
339 // VM operation to update for pop top frame.
340 class VM_UpdateForPopTopFrame : public VM_Operation {
341 private:
342   JvmtiThreadState* _state;
343   jvmtiError _result;
344 
345 public:
346   VM_UpdateForPopTopFrame(JvmtiThreadState* state) {
347     _state = state;
348     _result = JVMTI_ERROR_NONE;
349   }
350   VMOp_Type type() const { return VMOp_UpdateForPopTopFrame; }
351   jvmtiError result() { return _result; }
352   void doit();
353 };
354 
355 // VM operation to set frame pop.
356 class VM_SetFramePop : public VM_Operation {
357 private:
358   JvmtiEnv *_env;
359   JvmtiThreadState* _state;
360   jint _depth;
361   jvmtiError _result;
362 
363 public:
364   VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {
365     _env = env;
366     _state = state;
367     _depth = depth;
368     _result = JVMTI_ERROR_NONE;
369   }
370   // Nested operation must be allowed for the VM_EnterInterpOnlyMode that is
371   // called from the JvmtiEventControllerPrivate::recompute_thread_enabled.
372   bool allow_nested_vm_operations() const { return true; }
373   VMOp_Type type() const { return VMOp_SetFramePop; }
374   jvmtiError result() { return _result; }
375   void doit();
376 };
377 
378 
379 // VM operation to get monitor information with stack depth.
380 class VM_GetOwnedMonitorInfo : public VM_Operation {
381 private:
382   JvmtiEnv *_env;
383   JavaThread* _calling_thread;
384   JavaThread *_java_thread;
385   jvmtiError _result;
386   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
387 
388 public:
389   VM_GetOwnedMonitorInfo(JvmtiEnv* env, JavaThread* calling_thread,
390                                    JavaThread* java_thread,
391                                    GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt;* owned_monitor_list) {
392     _env = env;
393     _calling_thread = calling_thread;
394     _java_thread = java_thread;
395     _owned_monitors_list = owned_monitor_list;
396     _result = JVMTI_ERROR_NONE;
397   }
398   VMOp_Type type() const { return VMOp_GetOwnedMonitorInfo; }
399   void doit();
400   jvmtiError result() { return _result; }
401 };
402 
403 
404 // VM operation to get object monitor usage.
405 class VM_GetObjectMonitorUsage : public VM_Operation {
406 private:
407   JvmtiEnv *_env;
408   jobject _object;
409   JavaThread* _calling_thread;
410   jvmtiMonitorUsage* _info_ptr;
411   jvmtiError _result;
412 
413 public:
414   VM_GetObjectMonitorUsage(JvmtiEnv *env, JavaThread* calling_thread, jobject object, jvmtiMonitorUsage* info_ptr) {
415     _env = env;
416     _object = object;
417     _calling_thread = calling_thread;
418     _info_ptr = info_ptr;
419   }
420   VMOp_Type type() const { return VMOp_GetObjectMonitorUsage; }
421   jvmtiError result() { return _result; }
422   void doit() {
423     _result = ((JvmtiEnvBase*) _env)-&gt;get_object_monitor_usage(_calling_thread, _object, _info_ptr);
424   }
425 
426 };
427 
428 // VM operation to get current contended monitor.
429 class VM_GetCurrentContendedMonitor : public VM_Operation {
430 private:
431   JvmtiEnv *_env;
432   JavaThread *_calling_thread;
433   JavaThread *_java_thread;
434   jobject *_owned_monitor_ptr;
435   jvmtiError _result;
436 
437 public:
438   VM_GetCurrentContendedMonitor(JvmtiEnv *env, JavaThread *calling_thread, JavaThread *java_thread, jobject *mon_ptr) {
439     _env = env;
440     _calling_thread = calling_thread;
441     _java_thread = java_thread;
442     _owned_monitor_ptr = mon_ptr;
443   }
444   VMOp_Type type() const { return VMOp_GetCurrentContendedMonitor; }
445   jvmtiError result() { return _result; }
446   void doit();
447 };
448 
449 // VM operation to get stack trace at safepoint.
450 class VM_GetStackTrace : public VM_Operation {
451 private:
452   JvmtiEnv *_env;
453   JavaThread *_java_thread;
454   jint _start_depth;
455   jint _max_count;
456   jvmtiFrameInfo *_frame_buffer;
457   jint *_count_ptr;
458   jvmtiError _result;
459 
460 public:
461   VM_GetStackTrace(JvmtiEnv *env, JavaThread *java_thread,
462                    jint start_depth, jint max_count,
463                    jvmtiFrameInfo* frame_buffer, jint* count_ptr) {
464     _env = env;
465     _java_thread = java_thread;
466     _start_depth = start_depth;
467     _max_count = max_count;
468     _frame_buffer = frame_buffer;
469     _count_ptr = count_ptr;
470   }
471   jvmtiError result() { return _result; }
472   VMOp_Type type() const { return VMOp_GetStackTrace; }
473   void doit();
474 };
475 
476 // forward declaration
477 struct StackInfoNode;
478 
479 // VM operation to get stack trace at safepoint.
480 class VM_GetMultipleStackTraces : public VM_Operation {
481 private:
482   JvmtiEnv *_env;
483   jint _max_frame_count;
484   jvmtiStackInfo *_stack_info;
485   jvmtiError _result;
486   int _frame_count_total;
487   struct StackInfoNode *_head;
488 
489   JvmtiEnvBase *env()                 { return (JvmtiEnvBase *)_env; }
490   jint max_frame_count()              { return _max_frame_count; }
491   struct StackInfoNode *head()        { return _head; }
492   void set_head(StackInfoNode *head)  { _head = head; }
493 
494 protected:
495   void set_result(jvmtiError result)  { _result = result; }
496   void fill_frames(jthread jt, JavaThread *thr, oop thread_oop);
497   void allocate_and_fill_stacks(jint thread_count);
498 
499 public:
500   VM_GetMultipleStackTraces(JvmtiEnv *env, jint max_frame_count) {
501     _env = env;
502     _max_frame_count = max_frame_count;
503     _frame_count_total = 0;
504     _head = NULL;
505     _result = JVMTI_ERROR_NONE;
506   }
507   VMOp_Type type() const             { return VMOp_GetMultipleStackTraces; }
508   jvmtiStackInfo *stack_info()       { return _stack_info; }
509   jvmtiError result()                { return _result; }
510 };
511 
512 
513 // VM operation to get stack trace at safepoint.
514 class VM_GetAllStackTraces : public VM_GetMultipleStackTraces {
515 private:
516   JavaThread *_calling_thread;
517   jint _final_thread_count;
518 
519 public:
520   VM_GetAllStackTraces(JvmtiEnv *env, JavaThread *calling_thread,
521                        jint max_frame_count)
522       : VM_GetMultipleStackTraces(env, max_frame_count) {
523     _calling_thread = calling_thread;
524   }
525   VMOp_Type type() const          { return VMOp_GetAllStackTraces; }
526   void doit();
527   jint final_thread_count()       { return _final_thread_count; }
528 };
529 
530 // VM operation to get stack trace at safepoint.
531 class VM_GetThreadListStackTraces : public VM_GetMultipleStackTraces {
532 private:
533   jint _thread_count;
534   const jthread* _thread_list;
535 
536 public:
537   VM_GetThreadListStackTraces(JvmtiEnv *env, jint thread_count, const jthread* thread_list, jint max_frame_count)
538       : VM_GetMultipleStackTraces(env, max_frame_count) {
539     _thread_count = thread_count;
540     _thread_list = thread_list;
541   }
542   VMOp_Type type() const { return VMOp_GetThreadListStackTraces; }
543   void doit();
544 };
545 
546 
547 // VM operation to count stack frames at safepoint.
548 class VM_GetFrameCount : public VM_Operation {
549 private:
550   JvmtiEnv *_env;
551   JvmtiThreadState *_state;
552   jint *_count_ptr;
553   jvmtiError _result;
554 
555 public:
556   VM_GetFrameCount(JvmtiEnv *env, JvmtiThreadState *state, jint *count_ptr) {
557     _env = env;
558     _state = state;
559     _count_ptr = count_ptr;
560   }
561   VMOp_Type type() const { return VMOp_GetFrameCount; }
562   jvmtiError result()    { return _result; }
563   void doit();
564 };
565 
566 // VM operation to frame location at safepoint.
567 class VM_GetFrameLocation : public VM_Operation {
568 private:
569   JvmtiEnv *_env;
570   JavaThread* _java_thread;
571   jint _depth;
572   jmethodID* _method_ptr;
573   jlocation* _location_ptr;
574   jvmtiError _result;
575 
576 public:
577   VM_GetFrameLocation(JvmtiEnv *env, JavaThread* java_thread, jint depth,
578                       jmethodID* method_ptr, jlocation* location_ptr) {
579     _env = env;
580     _java_thread = java_thread;
581     _depth = depth;
582     _method_ptr = method_ptr;
583     _location_ptr = location_ptr;
584   }
585   VMOp_Type type() const { return VMOp_GetFrameLocation; }
586   jvmtiError result()    { return _result; }
587   void doit();
588 };
589 
590 
591 // ResourceTracker
592 //
593 // ResourceTracker works a little like a ResourceMark. All allocates
594 // using the resource tracker are recorded. If an allocate using the
595 // resource tracker fails the destructor will free any resources
596 // that were allocated using the tracker.
597 // The motive for this class is to avoid messy error recovery code
598 // in situations where multiple allocations are done in sequence. If
599 // the second or subsequent allocation fails it avoids any code to
600 // release memory allocated in the previous calls.
601 //
602 // Usage :-
603 //   ResourceTracker rt(env);
604 //   :
605 //   err = rt.allocate(1024, &amp;ptr);
606 
607 class ResourceTracker : public StackObj {
608  private:
609   JvmtiEnv* _env;
610   GrowableArray&lt;unsigned char*&gt; *_allocations;
611   bool _failed;
612  public:
613   ResourceTracker(JvmtiEnv* env);
614   ~ResourceTracker();
615   jvmtiError allocate(jlong size, unsigned char** mem_ptr);
616   unsigned char* allocate(jlong size);
617   char* strdup(const char* str);
618 };
619 
620 
621 // Jvmti monitor closure to collect off stack monitors.
622 class JvmtiMonitorClosure: public MonitorClosure {
623  private:
624   JavaThread *_java_thread;
625   JavaThread *_calling_thread;
626   GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *_owned_monitors_list;
627   jvmtiError _error;
628   JvmtiEnvBase *_env;
629 
630  public:
631   JvmtiMonitorClosure(JavaThread* thread, JavaThread *calling_thread,
632                       GrowableArray&lt;jvmtiMonitorStackDepthInfo*&gt; *owned_monitors,
633                       JvmtiEnvBase *env) {
634     _java_thread = thread;
635     _calling_thread = calling_thread;
636     _owned_monitors_list = owned_monitors;
637     _error = JVMTI_ERROR_NONE;
638     _env = env;
639   }
640   void do_monitor(ObjectMonitor* mon);
641   jvmtiError error() { return _error;}
642 };
643 
644 
645 // Jvmti module closure to collect all modules loaded to the system.
646 class JvmtiModuleClosure : public StackObj {
647 private:
648   static GrowableArray&lt;OopHandle&gt; *_tbl; // Protected with Module_lock
649 
650   static void do_module(ModuleEntry* entry);
651 public:
652   jvmtiError get_all_modules(JvmtiEnv* env, jint* module_count_ptr, jobject** modules_ptr);
653 };
654 
655 #endif // SHARE_PRIMS_JVMTIENVBASE_HPP
    </pre>
  </body>
</html>