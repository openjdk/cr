<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/ifnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciTypeFlow.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/cfgnode.hpp&quot;
  32 #include &quot;opto/connode.hpp&quot;
  33 #include &quot;opto/loopnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/runtime.hpp&quot;
  36 #include &quot;opto/rootnode.hpp&quot;
  37 #include &quot;opto/subnode.hpp&quot;
  38 
  39 // Portions of code courtesy of Clifford Click
  40 
  41 // Optimization - Graph Style
  42 
  43 
  44 #ifndef PRODUCT
  45 extern int explicit_null_checks_elided;
  46 #endif
  47 
  48 //=============================================================================
  49 //------------------------------Value------------------------------------------
  50 // Return a tuple for whichever arm of the IF is reachable
  51 const Type* IfNode::Value(PhaseGVN* phase) const {
  52   if( !in(0) ) return Type::TOP;
  53   if( phase-&gt;type(in(0)) == Type::TOP )
  54     return Type::TOP;
  55   const Type *t = phase-&gt;type(in(1));
  56   if( t == Type::TOP )          // data is undefined
  57     return TypeTuple::IFNEITHER; // unreachable altogether
  58   if( t == TypeInt::ZERO )      // zero, or false
  59     return TypeTuple::IFFALSE;  // only false branch is reachable
  60   if( t == TypeInt::ONE )       // 1, or true
  61     return TypeTuple::IFTRUE;   // only true branch is reachable
  62   assert( t == TypeInt::BOOL, &quot;expected boolean type&quot; );
  63 
  64   return TypeTuple::IFBOTH;     // No progress
  65 }
  66 
  67 const RegMask &amp;IfNode::out_RegMask() const {
  68   return RegMask::Empty;
  69 }
  70 
  71 //------------------------------split_if---------------------------------------
  72 // Look for places where we merge constants, then test on the merged value.
  73 // If the IF test will be constant folded on the path with the constant, we
  74 // win by splitting the IF to before the merge point.
  75 static Node* split_if(IfNode *iff, PhaseIterGVN *igvn) {
  76   // I could be a lot more general here, but I&#39;m trying to squeeze this
  77   // in before the Christmas &#39;98 break so I&#39;m gonna be kinda restrictive
  78   // on the patterns I accept.  CNC
  79 
  80   // Look for a compare of a constant and a merged value
  81   Node *i1 = iff-&gt;in(1);
  82   if( !i1-&gt;is_Bool() ) return NULL;
  83   BoolNode *b = i1-&gt;as_Bool();
  84   Node *cmp = b-&gt;in(1);
  85   if( !cmp-&gt;is_Cmp() ) return NULL;
  86   i1 = cmp-&gt;in(1);
  87   if( i1 == NULL || !i1-&gt;is_Phi() ) return NULL;
  88   PhiNode *phi = i1-&gt;as_Phi();
  89   if( phi-&gt;is_copy() ) return NULL;
  90   Node *con2 = cmp-&gt;in(2);
  91   if( !con2-&gt;is_Con() ) return NULL;
  92   // See that the merge point contains some constants
  93   Node *con1=NULL;
  94   uint i4;
  95   for( i4 = 1; i4 &lt; phi-&gt;req(); i4++ ) {
  96     con1 = phi-&gt;in(i4);
  97     if( !con1 ) return NULL;    // Do not optimize partially collapsed merges
  98     if( con1-&gt;is_Con() ) break; // Found a constant
  99     // Also allow null-vs-not-null checks
 100     const TypePtr *tp = igvn-&gt;type(con1)-&gt;isa_ptr();
 101     if( tp &amp;&amp; tp-&gt;_ptr == TypePtr::NotNull )
 102       break;
 103   }
 104   if( i4 &gt;= phi-&gt;req() ) return NULL; // Found no constants
 105 
 106   igvn-&gt;C-&gt;set_has_split_ifs(true); // Has chance for split-if
 107 
 108   // Make sure that the compare can be constant folded away
 109   Node *cmp2 = cmp-&gt;clone();
 110   cmp2-&gt;set_req(1,con1);
 111   cmp2-&gt;set_req(2,con2);
 112   const Type *t = cmp2-&gt;Value(igvn);
 113   // This compare is dead, so whack it!
 114   igvn-&gt;remove_dead_node(cmp2);
 115   if( !t-&gt;singleton() ) return NULL;
 116 
 117   // No intervening control, like a simple Call
 118   Node *r = iff-&gt;in(0);
 119   if( !r-&gt;is_Region() ) return NULL;
 120   if (r-&gt;is_Loop()) return NULL;
 121   if( phi-&gt;region() != r ) return NULL;
 122   // No other users of the cmp/bool
 123   if (b-&gt;outcnt() != 1 || cmp-&gt;outcnt() != 1) {
 124     //tty-&gt;print_cr(&quot;many users of cmp/bool&quot;);
 125     return NULL;
 126   }
 127 
 128   // Make sure we can determine where all the uses of merged values go
 129   for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 130     Node* u = r-&gt;fast_out(j);
 131     if( u == r ) continue;
 132     if( u == iff ) continue;
 133     if( u-&gt;outcnt() == 0 ) continue; // use is dead &amp; ignorable
 134     if( !u-&gt;is_Phi() ) {
 135       /*
 136       if( u-&gt;is_Start() ) {
 137         tty-&gt;print_cr(&quot;Region has inlined start use&quot;);
 138       } else {
 139         tty-&gt;print_cr(&quot;Region has odd use&quot;);
 140         u-&gt;dump(2);
 141       }*/
 142       return NULL;
 143     }
 144     if( u != phi ) {
 145       // CNC - do not allow any other merged value
 146       //tty-&gt;print_cr(&quot;Merging another value&quot;);
 147       //u-&gt;dump(2);
 148       return NULL;
 149     }
 150     // Make sure we can account for all Phi uses
 151     for (DUIterator_Fast kmax, k = u-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 152       Node* v = u-&gt;fast_out(k); // User of the phi
 153       // CNC - Allow only really simple patterns.
 154       // In particular I disallow AddP of the Phi, a fairly common pattern
 155       if (v == cmp) continue;  // The compare is OK
 156       if (v-&gt;is_ConstraintCast()) {
 157         // If the cast is derived from data flow edges, it may not have a control edge.
 158         // If so, it should be safe to split. But follow-up code can not deal with
 159         // this (l. 359). So skip.
 160         if (v-&gt;in(0) == NULL) {
 161           return NULL;
 162         }
 163         if (v-&gt;in(0)-&gt;in(0) == iff) {
 164           continue;               // CastPP/II of the IfNode is OK
 165         }
 166       }
 167       // Disabled following code because I cannot tell if exactly one
 168       // path dominates without a real dominator check. CNC 9/9/1999
 169       //uint vop = v-&gt;Opcode();
 170       //if( vop == Op_Phi ) {     // Phi from another merge point might be OK
 171       //  Node *r = v-&gt;in(0);     // Get controlling point
 172       //  if( !r ) return NULL;   // Degraded to a copy
 173       //  // Find exactly one path in (either True or False doms, but not IFF)
 174       //  int cnt = 0;
 175       //  for( uint i = 1; i &lt; r-&gt;req(); i++ )
 176       //    if( r-&gt;in(i) &amp;&amp; r-&gt;in(i)-&gt;in(0) == iff )
 177       //      cnt++;
 178       //  if( cnt == 1 ) continue; // Exactly one of True or False guards Phi
 179       //}
 180       if( !v-&gt;is_Call() ) {
 181         /*
 182         if( v-&gt;Opcode() == Op_AddP ) {
 183           tty-&gt;print_cr(&quot;Phi has AddP use&quot;);
 184         } else if( v-&gt;Opcode() == Op_CastPP ) {
 185           tty-&gt;print_cr(&quot;Phi has CastPP use&quot;);
 186         } else if( v-&gt;Opcode() == Op_CastII ) {
 187           tty-&gt;print_cr(&quot;Phi has CastII use&quot;);
 188         } else {
 189           tty-&gt;print_cr(&quot;Phi has use I cant be bothered with&quot;);
 190         }
 191         */
 192       }
 193       return NULL;
 194 
 195       /* CNC - Cut out all the fancy acceptance tests
 196       // Can we clone this use when doing the transformation?
 197       // If all uses are from Phis at this merge or constants, then YES.
 198       if( !v-&gt;in(0) &amp;&amp; v != cmp ) {
 199         tty-&gt;print_cr(&quot;Phi has free-floating use&quot;);
 200         v-&gt;dump(2);
 201         return NULL;
 202       }
 203       for( uint l = 1; l &lt; v-&gt;req(); l++ ) {
 204         if( (!v-&gt;in(l)-&gt;is_Phi() || v-&gt;in(l)-&gt;in(0) != r) &amp;&amp;
 205             !v-&gt;in(l)-&gt;is_Con() ) {
 206           tty-&gt;print_cr(&quot;Phi has use&quot;);
 207           v-&gt;dump(2);
 208           return NULL;
 209         } // End of if Phi-use input is neither Phi nor Constant
 210       } // End of for all inputs to Phi-use
 211       */
 212     } // End of for all uses of Phi
 213   } // End of for all uses of Region
 214 
 215   // Only do this if the IF node is in a sane state
 216   if (iff-&gt;outcnt() != 2)
 217     return NULL;
 218 
 219   // Got a hit!  Do the Mondo Hack!
 220   //
 221   //ABC  a1c   def   ghi            B     1     e     h   A C   a c   d f   g i
 222   // R - Phi - Phi - Phi            Rc - Phi - Phi - Phi   Rx - Phi - Phi - Phi
 223   //     cmp - 2                         cmp - 2               cmp - 2
 224   //       bool                            bool_c                bool_x
 225   //       if                               if_c                  if_x
 226   //      T  F                              T  F                  T  F
 227   // ..s..    ..t ..                   ..s..    ..t..        ..s..    ..t..
 228   //
 229   // Split the paths coming into the merge point into 2 separate groups of
 230   // merges.  On the left will be all the paths feeding constants into the
 231   // Cmp&#39;s Phi.  On the right will be the remaining paths.  The Cmp&#39;s Phi
 232   // will fold up into a constant; this will let the Cmp fold up as well as
 233   // all the control flow.  Below the original IF we have 2 control
 234   // dependent regions, &#39;s&#39; and &#39;t&#39;.  Now we will merge the two paths
 235   // just prior to &#39;s&#39; and &#39;t&#39; from the two IFs.  At least 1 path (and quite
 236   // likely 2 or more) will promptly constant fold away.
 237   PhaseGVN *phase = igvn;
 238 
 239   // Make a region merging constants and a region merging the rest
 240   uint req_c = 0;
 241   for (uint ii = 1; ii &lt; r-&gt;req(); ii++) {
 242     if (phi-&gt;in(ii) == con1) {
 243       req_c++;
 244     }
 245     Node* proj = PhaseIdealLoop::find_predicate(r-&gt;in(ii));
 246     if (proj != NULL) {
 247       return NULL;
 248     }
 249   }
 250 
 251   // If all the defs of the phi are the same constant, we already have the desired end state.
 252   // Skip the split that would create empty phi and region nodes.
 253   if((r-&gt;req() - req_c) == 1) {
 254     return NULL;
 255   }
 256 
 257   Node *region_c = new RegionNode(req_c + 1);
 258   Node *phi_c    = con1;
 259   uint  len      = r-&gt;req();
 260   Node *region_x = new RegionNode(len - req_c);
 261   Node *phi_x    = PhiNode::make_blank(region_x, phi);
 262   for (uint i = 1, i_c = 1, i_x = 1; i &lt; len; i++) {
 263     if (phi-&gt;in(i) == con1) {
 264       region_c-&gt;init_req( i_c++, r  -&gt;in(i) );
 265     } else {
 266       region_x-&gt;init_req( i_x,   r  -&gt;in(i) );
 267       phi_x   -&gt;init_req( i_x++, phi-&gt;in(i) );
 268     }
 269   }
 270 
 271   // Register the new RegionNodes but do not transform them.  Cannot
 272   // transform until the entire Region/Phi conglomerate has been hacked
 273   // as a single huge transform.
 274   igvn-&gt;register_new_node_with_optimizer( region_c );
 275   igvn-&gt;register_new_node_with_optimizer( region_x );
 276   // Prevent the untimely death of phi_x.  Currently he has no uses.  He is
 277   // about to get one.  If this only use goes away, then phi_x will look dead.
 278   // However, he will be picking up some more uses down below.
 279   Node *hook = new Node(4);
 280   hook-&gt;init_req(0, phi_x);
 281   hook-&gt;init_req(1, phi_c);
 282   phi_x = phase-&gt;transform( phi_x );
 283 
 284   // Make the compare
 285   Node *cmp_c = phase-&gt;makecon(t);
 286   Node *cmp_x = cmp-&gt;clone();
 287   cmp_x-&gt;set_req(1,phi_x);
 288   cmp_x-&gt;set_req(2,con2);
 289   cmp_x = phase-&gt;transform(cmp_x);
 290   // Make the bool
 291   Node *b_c = phase-&gt;transform(new BoolNode(cmp_c,b-&gt;_test._test));
 292   Node *b_x = phase-&gt;transform(new BoolNode(cmp_x,b-&gt;_test._test));
 293   // Make the IfNode
 294   IfNode* iff_c = iff-&gt;clone()-&gt;as_If();
 295   iff_c-&gt;set_req(0, region_c);
 296   iff_c-&gt;set_req(1, b_c);
 297   igvn-&gt;set_type_bottom(iff_c);
 298   igvn-&gt;_worklist.push(iff_c);
 299   hook-&gt;init_req(2, iff_c);
 300 
 301   IfNode* iff_x = iff-&gt;clone()-&gt;as_If();
 302   iff_x-&gt;set_req(0, region_x);
 303   iff_x-&gt;set_req(1, b_x);
 304   igvn-&gt;set_type_bottom(iff_x);
 305   igvn-&gt;_worklist.push(iff_x);
 306   hook-&gt;init_req(3, iff_x);
 307 
 308   // Make the true/false arms
 309   Node *iff_c_t = phase-&gt;transform(new IfTrueNode (iff_c));
 310   Node *iff_c_f = phase-&gt;transform(new IfFalseNode(iff_c));
 311   Node *iff_x_t = phase-&gt;transform(new IfTrueNode (iff_x));
 312   Node *iff_x_f = phase-&gt;transform(new IfFalseNode(iff_x));
 313 
 314   // Merge the TRUE paths
 315   Node *region_s = new RegionNode(3);
 316   igvn-&gt;_worklist.push(region_s);
 317   region_s-&gt;init_req(1, iff_c_t);
 318   region_s-&gt;init_req(2, iff_x_t);
 319   igvn-&gt;register_new_node_with_optimizer( region_s );
 320 
 321   // Merge the FALSE paths
 322   Node *region_f = new RegionNode(3);
 323   igvn-&gt;_worklist.push(region_f);
 324   region_f-&gt;init_req(1, iff_c_f);
 325   region_f-&gt;init_req(2, iff_x_f);
 326   igvn-&gt;register_new_node_with_optimizer( region_f );
 327 
 328   igvn-&gt;hash_delete(cmp);// Remove soon-to-be-dead node from hash table.
 329   cmp-&gt;set_req(1,NULL);  // Whack the inputs to cmp because it will be dead
 330   cmp-&gt;set_req(2,NULL);
 331   // Check for all uses of the Phi and give them a new home.
 332   // The &#39;cmp&#39; got cloned, but CastPP/IIs need to be moved.
 333   Node *phi_s = NULL;     // do not construct unless needed
 334   Node *phi_f = NULL;     // do not construct unless needed
 335   for (DUIterator_Last i2min, i2 = phi-&gt;last_outs(i2min); i2 &gt;= i2min; --i2) {
 336     Node* v = phi-&gt;last_out(i2);// User of the phi
 337     igvn-&gt;rehash_node_delayed(v); // Have to fixup other Phi users
 338     uint vop = v-&gt;Opcode();
 339     Node *proj = NULL;
 340     if( vop == Op_Phi ) {       // Remote merge point
 341       Node *r = v-&gt;in(0);
 342       for (uint i3 = 1; i3 &lt; r-&gt;req(); i3++)
 343         if (r-&gt;in(i3) &amp;&amp; r-&gt;in(i3)-&gt;in(0) == iff) {
 344           proj = r-&gt;in(i3);
 345           break;
 346         }
 347     } else if( v-&gt;is_ConstraintCast() ) {
 348       proj = v-&gt;in(0);          // Controlling projection
 349     } else {
 350       assert( 0, &quot;do not know how to handle this guy&quot; );
 351     }
 352     guarantee(proj != NULL, &quot;sanity&quot;);
 353 
 354     Node *proj_path_data, *proj_path_ctrl;
 355     if( proj-&gt;Opcode() == Op_IfTrue ) {
 356       if( phi_s == NULL ) {
 357         // Only construct phi_s if needed, otherwise provides
 358         // interfering use.
 359         phi_s = PhiNode::make_blank(region_s,phi);
 360         phi_s-&gt;init_req( 1, phi_c );
 361         phi_s-&gt;init_req( 2, phi_x );
 362         hook-&gt;add_req(phi_s);
 363         phi_s = phase-&gt;transform(phi_s);
 364       }
 365       proj_path_data = phi_s;
 366       proj_path_ctrl = region_s;
 367     } else {
 368       if( phi_f == NULL ) {
 369         // Only construct phi_f if needed, otherwise provides
 370         // interfering use.
 371         phi_f = PhiNode::make_blank(region_f,phi);
 372         phi_f-&gt;init_req( 1, phi_c );
 373         phi_f-&gt;init_req( 2, phi_x );
 374         hook-&gt;add_req(phi_f);
 375         phi_f = phase-&gt;transform(phi_f);
 376       }
 377       proj_path_data = phi_f;
 378       proj_path_ctrl = region_f;
 379     }
 380 
 381     // Fixup &#39;v&#39; for for the split
 382     if( vop == Op_Phi ) {       // Remote merge point
 383       uint i;
 384       for( i = 1; i &lt; v-&gt;req(); i++ )
 385         if( v-&gt;in(i) == phi )
 386           break;
 387       v-&gt;set_req(i, proj_path_data );
 388     } else if( v-&gt;is_ConstraintCast() ) {
 389       v-&gt;set_req(0, proj_path_ctrl );
 390       v-&gt;set_req(1, proj_path_data );
 391     } else
 392       ShouldNotReachHere();
 393   }
 394 
 395   // Now replace the original iff&#39;s True/False with region_s/region_t.
 396   // This makes the original iff go dead.
 397   for (DUIterator_Last i3min, i3 = iff-&gt;last_outs(i3min); i3 &gt;= i3min; --i3) {
 398     Node* p = iff-&gt;last_out(i3);
 399     assert( p-&gt;Opcode() == Op_IfTrue || p-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
 400     Node *u = (p-&gt;Opcode() == Op_IfTrue) ? region_s : region_f;
 401     // Replace p with u
 402     igvn-&gt;add_users_to_worklist(p);
 403     for (DUIterator_Last lmin, l = p-&gt;last_outs(lmin); l &gt;= lmin;) {
 404       Node* x = p-&gt;last_out(l);
 405       igvn-&gt;hash_delete(x);
 406       uint uses_found = 0;
 407       for( uint j = 0; j &lt; x-&gt;req(); j++ ) {
 408         if( x-&gt;in(j) == p ) {
 409           x-&gt;set_req(j, u);
 410           uses_found++;
 411         }
 412       }
 413       l -= uses_found;    // we deleted 1 or more copies of this edge
 414     }
 415     igvn-&gt;remove_dead_node(p);
 416   }
 417 
 418   // Force the original merge dead
 419   igvn-&gt;hash_delete(r);
 420   // First, remove region&#39;s dead users.
 421   for (DUIterator_Last lmin, l = r-&gt;last_outs(lmin); l &gt;= lmin;) {
 422     Node* u = r-&gt;last_out(l);
 423     if( u == r ) {
 424       r-&gt;set_req(0, NULL);
 425     } else {
 426       assert(u-&gt;outcnt() == 0, &quot;only dead users&quot;);
 427       igvn-&gt;remove_dead_node(u);
 428     }
 429     l -= 1;
 430   }
 431   igvn-&gt;remove_dead_node(r);
 432 
 433   // Now remove the bogus extra edges used to keep things alive
 434   igvn-&gt;remove_dead_node( hook );
 435 
 436   // Must return either the original node (now dead) or a new node
 437   // (Do not return a top here, since that would break the uniqueness of top.)
 438   return new ConINode(TypeInt::ZERO);
 439 }
 440 
 441 // if this IfNode follows a range check pattern return the projection
 442 // for the failed path
 443 ProjNode* IfNode::range_check_trap_proj(int&amp; flip_test, Node*&amp; l, Node*&amp; r) {
 444   if (outcnt() != 2) {
 445     return NULL;
 446   }
 447   Node* b = in(1);
 448   if (b == NULL || !b-&gt;is_Bool())  return NULL;
 449   BoolNode* bn = b-&gt;as_Bool();
 450   Node* cmp = bn-&gt;in(1);
 451   if (cmp == NULL)  return NULL;
 452   if (cmp-&gt;Opcode() != Op_CmpU)  return NULL;
 453 
 454   l = cmp-&gt;in(1);
 455   r = cmp-&gt;in(2);
 456   flip_test = 1;
 457   if (bn-&gt;_test._test == BoolTest::le) {
 458     l = cmp-&gt;in(2);
 459     r = cmp-&gt;in(1);
 460     flip_test = 2;
 461   } else if (bn-&gt;_test._test != BoolTest::lt) {
 462     return NULL;
 463   }
 464   if (l-&gt;is_top())  return NULL;   // Top input means dead test
 465   if (r-&gt;Opcode() != Op_LoadRange &amp;&amp; !is_RangeCheck())  return NULL;
 466 
 467   // We have recognized one of these forms:
 468   //  Flip 1:  If (Bool[&lt;] CmpU(l, LoadRange)) ...
 469   //  Flip 2:  If (Bool[&lt;=] CmpU(LoadRange, l)) ...
 470 
 471   ProjNode* iftrap = proj_out_or_null(flip_test == 2 ? true : false);
 472   return iftrap;
 473 }
 474 
 475 
 476 //------------------------------is_range_check---------------------------------
 477 // Return 0 if not a range check.  Return 1 if a range check and set index and
 478 // offset.  Return 2 if we had to negate the test.  Index is NULL if the check
 479 // is versus a constant.
 480 int RangeCheckNode::is_range_check(Node* &amp;range, Node* &amp;index, jint &amp;offset) {
 481   int flip_test = 0;
 482   Node* l = NULL;
 483   Node* r = NULL;
 484   ProjNode* iftrap = range_check_trap_proj(flip_test, l, r);
 485 
 486   if (iftrap == NULL) {
 487     return 0;
 488   }
 489 
 490   // Make sure it&#39;s a real range check by requiring an uncommon trap
 491   // along the OOB path.  Otherwise, it&#39;s possible that the user wrote
 492   // something which optimized to look like a range check but behaves
 493   // in some other way.
 494   if (iftrap-&gt;is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {
 495     return 0;
 496   }
 497 
 498   // Look for index+offset form
 499   Node* ind = l;
 500   jint  off = 0;
 501   if (l-&gt;is_top()) {
 502     return 0;
 503   } else if (l-&gt;Opcode() == Op_AddI) {
 504     if ((off = l-&gt;in(1)-&gt;find_int_con(0)) != 0) {
 505       ind = l-&gt;in(2)-&gt;uncast();
 506     } else if ((off = l-&gt;in(2)-&gt;find_int_con(0)) != 0) {
 507       ind = l-&gt;in(1)-&gt;uncast();
 508     }
 509   } else if ((off = l-&gt;find_int_con(-1)) &gt;= 0) {
 510     // constant offset with no variable index
 511     ind = NULL;
 512   } else {
 513     // variable index with no constant offset (or dead negative index)
 514     off = 0;
 515   }
 516 
 517   // Return all the values:
 518   index  = ind;
 519   offset = off;
 520   range  = r;
 521   return flip_test;
 522 }
 523 
 524 //------------------------------adjust_check-----------------------------------
 525 // Adjust (widen) a prior range check
 526 static void adjust_check(Node* proj, Node* range, Node* index,
 527                          int flip, jint off_lo, PhaseIterGVN* igvn) {
 528   PhaseGVN *gvn = igvn;
 529   // Break apart the old check
 530   Node *iff = proj-&gt;in(0);
 531   Node *bol = iff-&gt;in(1);
 532   if( bol-&gt;is_top() ) return;   // In case a partially dead range check appears
 533   // bail (or bomb[ASSERT/DEBUG]) if NOT projection--&gt;IfNode--&gt;BoolNode
 534   DEBUG_ONLY( if( !bol-&gt;is_Bool() ) { proj-&gt;dump(3); fatal(&quot;Expect projection--&gt;IfNode--&gt;BoolNode&quot;); } )
 535   if( !bol-&gt;is_Bool() ) return;
 536 
 537   Node *cmp = bol-&gt;in(1);
 538   // Compute a new check
 539   Node *new_add = gvn-&gt;intcon(off_lo);
 540   if( index ) {
 541     new_add = off_lo ? gvn-&gt;transform(new AddINode( index, new_add )) : index;
 542   }
 543   Node *new_cmp = (flip == 1)
 544     ? new CmpUNode( new_add, range )
 545     : new CmpUNode( range, new_add );
 546   new_cmp = gvn-&gt;transform(new_cmp);
 547   // See if no need to adjust the existing check
 548   if( new_cmp == cmp ) return;
 549   // Else, adjust existing check
 550   Node *new_bol = gvn-&gt;transform( new BoolNode( new_cmp, bol-&gt;as_Bool()-&gt;_test._test ) );
 551   igvn-&gt;rehash_node_delayed( iff );
 552   iff-&gt;set_req_X( 1, new_bol, igvn );
 553 }
 554 
 555 //------------------------------up_one_dom-------------------------------------
 556 // Walk up the dominator tree one step.  Return NULL at root or true
 557 // complex merges.  Skips through small diamonds.
 558 Node* IfNode::up_one_dom(Node *curr, bool linear_only) {
 559   Node *dom = curr-&gt;in(0);
 560   if( !dom )                    // Found a Region degraded to a copy?
 561     return curr-&gt;nonnull_req(); // Skip thru it
 562 
 563   if( curr != dom )             // Normal walk up one step?
 564     return dom;
 565 
 566   // Use linear_only if we are still parsing, since we cannot
 567   // trust the regions to be fully filled in.
 568   if (linear_only)
 569     return NULL;
 570 
 571   if( dom-&gt;is_Root() )
 572     return NULL;
 573 
 574   // Else hit a Region.  Check for a loop header
 575   if( dom-&gt;is_Loop() )
 576     return dom-&gt;in(1);          // Skip up thru loops
 577 
 578   // Check for small diamonds
 579   Node *din1, *din2, *din3, *din4;
 580   if( dom-&gt;req() == 3 &amp;&amp;        // 2-path merge point
 581       (din1 = dom -&gt;in(1)) &amp;&amp;   // Left  path exists
 582       (din2 = dom -&gt;in(2)) &amp;&amp;   // Right path exists
 583       (din3 = din1-&gt;in(0)) &amp;&amp;   // Left  path up one
 584       (din4 = din2-&gt;in(0)) ) {  // Right path up one
 585     if( din3-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 586         (din3 = din3-&gt;in(0)) )
 587       din3 = din3-&gt;in(0);
 588     if( din4-&gt;is_Call() &amp;&amp;      // Handle a slow-path call on either arm
 589         (din4 = din4-&gt;in(0)) )
 590       din4 = din4-&gt;in(0);
 591     if (din3 != NULL &amp;&amp; din3 == din4 &amp;&amp; din3-&gt;is_If()) // Regions not degraded to a copy
 592       return din3;              // Skip around diamonds
 593   }
 594 
 595   // Give up the search at true merges
 596   return NULL;                  // Dead loop?  Or hit root?
 597 }
 598 
 599 
 600 //------------------------------filtered_int_type--------------------------------
 601 // Return a possibly more restrictive type for val based on condition control flow for an if
 602 const TypeInt* IfNode::filtered_int_type(PhaseGVN* gvn, Node* val, Node* if_proj) {
 603   assert(if_proj &amp;&amp;
 604          (if_proj-&gt;Opcode() == Op_IfTrue || if_proj-&gt;Opcode() == Op_IfFalse), &quot;expecting an if projection&quot;);
 605   if (if_proj-&gt;in(0) &amp;&amp; if_proj-&gt;in(0)-&gt;is_If()) {
 606     IfNode* iff = if_proj-&gt;in(0)-&gt;as_If();
 607     if (iff-&gt;in(1) &amp;&amp; iff-&gt;in(1)-&gt;is_Bool()) {
 608       BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
 609       if (bol-&gt;in(1) &amp;&amp; bol-&gt;in(1)-&gt;is_Cmp()) {
 610         const CmpNode* cmp  = bol-&gt;in(1)-&gt;as_Cmp();
 611         if (cmp-&gt;in(1) == val) {
 612           const TypeInt* cmp2_t = gvn-&gt;type(cmp-&gt;in(2))-&gt;isa_int();
 613           if (cmp2_t != NULL) {
 614             jint lo = cmp2_t-&gt;_lo;
 615             jint hi = cmp2_t-&gt;_hi;
 616             BoolTest::mask msk = if_proj-&gt;Opcode() == Op_IfTrue ? bol-&gt;_test._test : bol-&gt;_test.negate();
 617             switch (msk) {
 618             case BoolTest::ne: {
 619               // If val is compared to its lower or upper bound, we can narrow the type
 620               const TypeInt* val_t = gvn-&gt;type(val)-&gt;isa_int();
 621               if (val_t != NULL &amp;&amp; !val_t-&gt;singleton() &amp;&amp; cmp2_t-&gt;is_con()) {
 622                 if (val_t-&gt;_lo == lo) {
 623                   return TypeInt::make(val_t-&gt;_lo + 1, val_t-&gt;_hi, val_t-&gt;_widen);
 624                 } else if (val_t-&gt;_hi == hi) {
 625                   return TypeInt::make(val_t-&gt;_lo, val_t-&gt;_hi - 1, val_t-&gt;_widen);
 626                 }
 627               }
 628               // Can&#39;t refine type
 629               return NULL;
 630             }
 631             case BoolTest::eq:
 632               return cmp2_t;
 633             case BoolTest::lt:
 634               lo = TypeInt::INT-&gt;_lo;
 635               if (hi - 1 &lt; hi) {
 636                 hi = hi - 1;
 637               }
 638               break;
 639             case BoolTest::le:
 640               lo = TypeInt::INT-&gt;_lo;
 641               break;
 642             case BoolTest::gt:
 643               if (lo + 1 &gt; lo) {
 644                 lo = lo + 1;
 645               }
 646               hi = TypeInt::INT-&gt;_hi;
 647               break;
 648             case BoolTest::ge:
 649               // lo unchanged
 650               hi = TypeInt::INT-&gt;_hi;
 651               break;
 652             default:
 653               break;
 654             }
 655             const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t-&gt;_widen);
 656             return rtn_t;
 657           }
 658         }
 659       }
 660     }
 661   }
 662   return NULL;
 663 }
 664 
 665 //------------------------------fold_compares----------------------------
 666 // See if a pair of CmpIs can be converted into a CmpU.  In some cases
 667 // the direction of this if is determined by the preceding if so it
 668 // can be eliminate entirely.
 669 //
 670 // Given an if testing (CmpI n v) check for an immediately control
 671 // dependent if that is testing (CmpI n v2) and has one projection
 672 // leading to this if and the other projection leading to a region
 673 // that merges one of this ifs control projections.
 674 //
 675 //                   If
 676 //                  / |
 677 //                 /  |
 678 //                /   |
 679 //              If    |
 680 //              /\    |
 681 //             /  \   |
 682 //            /    \  |
 683 //           /    Region
 684 //
 685 // Or given an if testing (CmpI n v) check for a dominating if that is
 686 // testing (CmpI n v2), both having one projection leading to an
 687 // uncommon trap. Allow Another independent guard in between to cover
 688 // an explicit range check:
 689 // if (index &lt; 0 || index &gt;= array.length) {
 690 // which may need a null check to guard the LoadRange
 691 //
 692 //                   If
 693 //                  / \
 694 //                 /   \
 695 //                /     \
 696 //              If      unc
 697 //              /\
 698 //             /  \
 699 //            /    \
 700 //           /      unc
 701 //
 702 
 703 // Is the comparison for this If suitable for folding?
 704 bool IfNode::cmpi_folds(PhaseIterGVN* igvn, bool fold_ne) {
 705   return in(1) != NULL &amp;&amp;
 706     in(1)-&gt;is_Bool() &amp;&amp;
 707     in(1)-&gt;in(1) != NULL &amp;&amp;
 708     in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
 709     in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
 710     in(1)-&gt;in(1)-&gt;in(2) != igvn-&gt;C-&gt;top() &amp;&amp;
 711     (in(1)-&gt;as_Bool()-&gt;_test.is_less() ||
 712      in(1)-&gt;as_Bool()-&gt;_test.is_greater() ||
 713      (fold_ne &amp;&amp; in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne));
 714 }
 715 
 716 // Is a dominating control suitable for folding with this if?
 717 bool IfNode::is_ctrl_folds(Node* ctrl, PhaseIterGVN* igvn) {
 718   return ctrl != NULL &amp;&amp;
 719     ctrl-&gt;is_Proj() &amp;&amp;
 720     ctrl-&gt;in(0) != NULL &amp;&amp;
 721     ctrl-&gt;in(0)-&gt;Opcode() == Op_If &amp;&amp;
 722     ctrl-&gt;in(0)-&gt;outcnt() == 2 &amp;&amp;
 723     ctrl-&gt;in(0)-&gt;as_If()-&gt;cmpi_folds(igvn, true) &amp;&amp;
 724     // Must compare same value
 725     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
 726     ctrl-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == in(1)-&gt;in(1)-&gt;in(1);
 727 }
 728 
 729 // Do this If and the dominating If share a region?
 730 bool IfNode::has_shared_region(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail) {
 731   ProjNode* otherproj = proj-&gt;other_if_proj();
 732   Node* otherproj_ctrl_use = otherproj-&gt;unique_ctrl_out();
 733   RegionNode* region = (otherproj_ctrl_use != NULL &amp;&amp; otherproj_ctrl_use-&gt;is_Region()) ? otherproj_ctrl_use-&gt;as_Region() : NULL;
 734   success = NULL;
 735   fail = NULL;
 736 
 737   if (otherproj-&gt;outcnt() == 1 &amp;&amp; region != NULL &amp;&amp; !region-&gt;has_phi()) {
 738     for (int i = 0; i &lt; 2; i++) {
 739       ProjNode* proj = proj_out(i);
 740       if (success == NULL &amp;&amp; proj-&gt;outcnt() == 1 &amp;&amp; proj-&gt;unique_out() == region) {
 741         success = proj;
 742       } else if (fail == NULL) {
 743         fail = proj;
 744       } else {
 745         success = fail = NULL;
 746       }
 747     }
 748   }
 749   return success != NULL &amp;&amp; fail != NULL;
 750 }
 751 
 752 bool IfNode::is_dominator_unc(CallStaticJavaNode* dom_unc, CallStaticJavaNode* unc) {
 753   // Different methods and methods containing jsrs are not supported.
 754   ciMethod* method = unc-&gt;jvms()-&gt;method();
 755   ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 756   if (method != dom_method || method-&gt;has_jsrs()) {
 757     return false;
 758   }
 759   // Check that both traps are in the same activation of the method (instead
 760   // of two activations being inlined through different call sites) by verifying
 761   // that the call stacks are equal for both JVMStates.
 762   JVMState* dom_caller = dom_unc-&gt;jvms()-&gt;caller();
 763   JVMState* caller = unc-&gt;jvms()-&gt;caller();
 764   if ((dom_caller == NULL) != (caller == NULL)) {
 765     // The current method must either be inlined into both dom_caller and
 766     // caller or must not be inlined at all (top method). Bail out otherwise.
 767     return false;
 768   } else if (dom_caller != NULL &amp;&amp; !dom_caller-&gt;same_calls_as(caller)) {
 769     return false;
 770   }
 771   // Check that the bci of the dominating uncommon trap dominates the bci
 772   // of the dominated uncommon trap. Otherwise we may not re-execute
 773   // the dominated check after deoptimization from the merged uncommon trap.
 774   ciTypeFlow* flow = dom_method-&gt;get_flow_analysis();
 775   int bci = unc-&gt;jvms()-&gt;bci();
 776   int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 777   if (!flow-&gt;is_dominated_by(bci, dom_bci)) {
 778     return false;
 779   }
 780 
 781   return true;
 782 }
 783 
 784 // Return projection that leads to an uncommon trap if any
 785 ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*&amp; call) const {
 786   for (int i = 0; i &lt; 2; i++) {
 787     call = proj_out(i)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 788     if (call != NULL) {
 789       return proj_out(i);
 790     }
 791   }
 792   return NULL;
 793 }
 794 
 795 // Do this If and the dominating If both branch out to an uncommon trap
 796 bool IfNode::has_only_uncommon_traps(ProjNode* proj, ProjNode*&amp; success, ProjNode*&amp; fail, PhaseIterGVN* igvn) {
 797   ProjNode* otherproj = proj-&gt;other_if_proj();
 798   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
 799 
 800   if (otherproj-&gt;outcnt() == 1 &amp;&amp; dom_unc != NULL) {
 801     // We need to re-execute the folded Ifs after deoptimization from the merged traps
 802     if (!dom_unc-&gt;jvms()-&gt;should_reexecute()) {
 803       return false;
 804     }
 805 
 806     CallStaticJavaNode* unc = NULL;
 807     ProjNode* unc_proj = uncommon_trap_proj(unc);
 808     if (unc_proj != NULL &amp;&amp; unc_proj-&gt;outcnt() == 1) {
 809       if (dom_unc == unc) {
 810         // Allow the uncommon trap to be shared through a region
 811         RegionNode* r = unc-&gt;in(0)-&gt;as_Region();
 812         if (r-&gt;outcnt() != 2 || r-&gt;req() != 3 || r-&gt;find_edge(otherproj) == -1 || r-&gt;find_edge(unc_proj) == -1) {
 813           return false;
 814         }
 815         assert(r-&gt;has_phi() == NULL, &quot;simple region shouldn&#39;t have a phi&quot;);
 816       } else if (dom_unc-&gt;in(0) != otherproj || unc-&gt;in(0) != unc_proj) {
 817         return false;
 818       }
 819 
 820       if (!is_dominator_unc(dom_unc, unc)) {
 821         return false;
 822       }
 823 
 824       // See merge_uncommon_traps: the reason of the uncommon trap
 825       // will be changed and the state of the dominating If will be
 826       // used. Checked that we didn&#39;t apply this transformation in a
 827       // previous compilation and it didn&#39;t cause too many traps
 828       ciMethod* dom_method = dom_unc-&gt;jvms()-&gt;method();
 829       int dom_bci = dom_unc-&gt;jvms()-&gt;bci();
 830       if (!igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_unstable_fused_if) &amp;&amp;
 831           !igvn-&gt;C-&gt;too_many_traps(dom_method, dom_bci, Deoptimization::Reason_range_check)) {
 832         success = unc_proj;
 833         fail = unc_proj-&gt;other_if_proj();
 834         return true;
 835       }
 836     }
 837   }
 838   return false;
 839 }
 840 
 841 // Check that the 2 CmpI can be folded into as single CmpU and proceed with the folding
 842 bool IfNode::fold_compares_helper(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
 843   Node* this_cmp = in(1)-&gt;in(1);
 844   BoolNode* this_bool = in(1)-&gt;as_Bool();
 845   IfNode* dom_iff = proj-&gt;in(0)-&gt;as_If();
 846   BoolNode* dom_bool = dom_iff-&gt;in(1)-&gt;as_Bool();
 847   Node* lo = dom_iff-&gt;in(1)-&gt;in(1)-&gt;in(2);
 848   Node* hi = this_cmp-&gt;in(2);
 849   Node* n = this_cmp-&gt;in(1);
 850   ProjNode* otherproj = proj-&gt;other_if_proj();
 851 
 852   const TypeInt* lo_type = IfNode::filtered_int_type(igvn, n, otherproj);
 853   const TypeInt* hi_type = IfNode::filtered_int_type(igvn, n, success);
 854 
 855   BoolTest::mask lo_test = dom_bool-&gt;_test._test;
 856   BoolTest::mask hi_test = this_bool-&gt;_test._test;
 857   BoolTest::mask cond = hi_test;
 858 
 859   // convert:
 860   //
 861   //          dom_bool = x {&lt;,&lt;=,&gt;,&gt;=} a
 862   //                           / \
 863   //     proj = {True,False}  /   \ otherproj = {False,True}
 864   //                         /
 865   //        this_bool = x {&lt;,&lt;=} b
 866   //                       / \
 867   //  fail = {True,False} /   \ success = {False,True}
 868   //                     /
 869   //
 870   // (Second test guaranteed canonicalized, first one may not have
 871   // been canonicalized yet)
 872   //
 873   // into:
 874   //
 875   // cond = (x - lo) {&lt;u,&lt;=u,&gt;u,&gt;=u} adjusted_lim
 876   //                       / \
 877   //                 fail /   \ success
 878   //                     /
 879   //
 880 
 881   // Figure out which of the two tests sets the upper bound and which
 882   // sets the lower bound if any.
 883   Node* adjusted_lim = NULL;
 884   if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; hi_type-&gt;_lo &gt; lo_type-&gt;_hi &amp;&amp;
 885       hi_type-&gt;_hi == max_jint &amp;&amp; lo_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 886     assert((dom_bool-&gt;_test.is_less() &amp;&amp; !proj-&gt;_con) ||
 887            (dom_bool-&gt;_test.is_greater() &amp;&amp; proj-&gt;_con), &quot;incorrect test&quot;);
 888     // this test was canonicalized
 889     assert(this_bool-&gt;_test.is_less() &amp;&amp; fail-&gt;_con, &quot;incorrect test&quot;);
 890 
 891     // this_bool = &lt;
 892     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 893     //     x in [a, b[ on the fail (= True) projection, b &gt; a-1 (because of hi_type-&gt;_lo &gt; lo_type-&gt;_hi test above):
 894     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;u
 895     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 896     //     x in ]a, b[ on the fail (= True) projection, b &gt; a:
 897     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;u
 898     // this_bool = &lt;=
 899     //   dom_bool = &gt;= (proj = True) or dom_bool = &lt; (proj = False)
 900     //     x in [a, b] on the fail (= True) projection, b+1 &gt; a-1:
 901     //     lo = a, hi = b, adjusted_lim = b-a+1, cond = &lt;u
 902     //     lo = a, hi = b, adjusted_lim = b-a, cond = &lt;=u doesn&#39;t work because b = a - 1 is possible, then b-a = -1
 903     //   dom_bool = &gt; (proj = True) or dom_bool = &lt;= (proj = False)
 904     //     x in ]a, b] on the fail (= True) projection b+1 &gt; a:
 905     //     lo = a+1, hi = b, adjusted_lim = b-a, cond = &lt;u
 906     //     lo = a+1, hi = b, adjusted_lim = b-a-1, cond = &lt;=u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 907 
 908     if (hi_test == BoolTest::lt) {
 909       if (lo_test == BoolTest::gt || lo_test == BoolTest::le) {
 910         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 911       }
 912     } else {
 913       assert(hi_test == BoolTest::le, &quot;bad test&quot;);
 914       if (lo_test == BoolTest::ge || lo_test == BoolTest::lt) {
 915         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 916         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 917         cond = BoolTest::lt;
 918       } else {
 919         assert(lo_test == BoolTest::gt || lo_test == BoolTest::le, &quot;bad test&quot;);
 920         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 921         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 922         cond = BoolTest::lt;
 923       }
 924     }
 925   } else if (lo_type != NULL &amp;&amp; hi_type != NULL &amp;&amp; lo_type-&gt;_lo &gt; hi_type-&gt;_hi &amp;&amp;
 926              lo_type-&gt;_hi == max_jint &amp;&amp; hi_type-&gt;_lo == min_jint &amp;&amp; lo_test != BoolTest::ne) {
 927 
 928     // this_bool = &lt;
 929     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 930     //     x in [b, a[ on the fail (= False) projection, a &gt; b-1 (because of lo_type-&gt;_lo &gt; hi_type-&gt;_hi above):
 931     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;=u
 932     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 933     //     x in [b, a] on the fail (= False) projection, a+1 &gt; b-1:
 934     //     lo = b, hi = a, adjusted_lim = a-b+1, cond = &gt;=u
 935     //     lo = b, hi = a, adjusted_lim = a-b, cond = &gt;u doesn&#39;t work because a = b - 1 is possible, then b-a = -1
 936     // this_bool = &lt;=
 937     //   dom_bool = &lt; (proj = True) or dom_bool = &gt;= (proj = False)
 938     //     x in ]b, a[ on the fail (= False) projection, a &gt; b:
 939     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;=u
 940     //   dom_bool = &lt;= (proj = True) or dom_bool = &gt; (proj = False)
 941     //     x in ]b, a] on the fail (= False) projection, a+1 &gt; b:
 942     //     lo = b+1, hi = a, adjusted_lim = a-b, cond = &gt;=u
 943     //     lo = b+1, hi = a, adjusted_lim = a-b-1, cond = &gt;u doesn&#39;t work because a = b is possible, then b-a-1 = -1
 944 
 945     swap(lo, hi);
 946     swap(lo_type, hi_type);
 947     swap(lo_test, hi_test);
 948 
 949     assert((dom_bool-&gt;_test.is_less() &amp;&amp; proj-&gt;_con) ||
 950            (dom_bool-&gt;_test.is_greater() &amp;&amp; !proj-&gt;_con), &quot;incorrect test&quot;);
 951     // this test was canonicalized
 952     assert(this_bool-&gt;_test.is_less() &amp;&amp; !fail-&gt;_con, &quot;incorrect test&quot;);
 953 
 954     cond = (hi_test == BoolTest::le || hi_test == BoolTest::gt) ? BoolTest::gt : BoolTest::ge;
 955 
 956     if (lo_test == BoolTest::lt) {
 957       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 958         cond = BoolTest::ge;
 959       } else {
 960         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 961         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 962         adjusted_lim = igvn-&gt;transform(new AddINode(adjusted_lim, igvn-&gt;intcon(1)));
 963         cond = BoolTest::ge;
 964       }
 965     } else if (lo_test == BoolTest::le) {
 966       if (hi_test == BoolTest::lt || hi_test == BoolTest::ge) {
 967         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 968         cond = BoolTest::ge;
 969       } else {
 970         assert(hi_test == BoolTest::le || hi_test == BoolTest::gt, &quot;bad test&quot;);
 971         adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
 972         lo = igvn-&gt;transform(new AddINode(lo, igvn-&gt;intcon(1)));
 973         cond = BoolTest::ge;
 974       }
 975     }
 976   } else {
 977     const TypeInt* failtype = filtered_int_type(igvn, n, proj);
 978     if (failtype != NULL) {
 979       const TypeInt* type2 = filtered_int_type(igvn, n, fail);
 980       if (type2 != NULL) {
 981         failtype = failtype-&gt;join(type2)-&gt;is_int();
 982         if (failtype-&gt;_lo &gt; failtype-&gt;_hi) {
 983           // previous if determines the result of this if so
 984           // replace Bool with constant
 985           igvn-&gt;_worklist.push(in(1));
 986           igvn-&gt;replace_input_of(this, 1, igvn-&gt;intcon(success-&gt;_con));
 987           return true;
 988         }
 989       }
 990     }
 991     lo = NULL;
 992     hi = NULL;
 993   }
 994 
 995   if (lo &amp;&amp; hi) {
 996     // Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))
 997     Node* adjusted_val = igvn-&gt;transform(new SubINode(n,  lo));
 998     if (adjusted_lim == NULL) {
 999       adjusted_lim = igvn-&gt;transform(new SubINode(hi, lo));
1000     }
1001     Node* newcmp = igvn-&gt;transform(new CmpUNode(adjusted_val, adjusted_lim));
1002     Node* newbool = igvn-&gt;transform(new BoolNode(newcmp, cond));
1003 
1004     igvn-&gt;replace_input_of(dom_iff, 1, igvn-&gt;intcon(proj-&gt;_con));
1005     igvn-&gt;_worklist.push(in(1));
1006     igvn-&gt;replace_input_of(this, 1, newbool);
1007 
1008     return true;
1009   }
1010   return false;
1011 }
1012 
1013 // Merge the branches that trap for this If and the dominating If into
1014 // a single region that branches to the uncommon trap for the
1015 // dominating If
1016 Node* IfNode::merge_uncommon_traps(ProjNode* proj, ProjNode* success, ProjNode* fail, PhaseIterGVN* igvn) {
1017   Node* res = this;
1018   assert(success-&gt;in(0) == this, &quot;bad projection&quot;);
1019 
1020   ProjNode* otherproj = proj-&gt;other_if_proj();
1021 
1022   CallStaticJavaNode* unc = success-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1023   CallStaticJavaNode* dom_unc = otherproj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none);
1024 
1025   if (unc != dom_unc) {
1026     Node* r = new RegionNode(3);
1027 
1028     r-&gt;set_req(1, otherproj);
1029     r-&gt;set_req(2, success);
1030     r = igvn-&gt;transform(r);
1031     assert(r-&gt;is_Region(), &quot;can&#39;t go away&quot;);
1032 
1033     // Make both If trap at the state of the first If: once the CmpI
1034     // nodes are merged, if we trap we don&#39;t know which of the CmpI
1035     // nodes would have caused the trap so we have to restart
1036     // execution at the first one
1037     igvn-&gt;replace_input_of(dom_unc, 0, r);
1038     igvn-&gt;replace_input_of(unc, 0, igvn-&gt;C-&gt;top());
1039   }
1040   int trap_request = dom_unc-&gt;uncommon_trap_request();
1041   Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1042   Deoptimization::DeoptAction action = Deoptimization::trap_request_action(trap_request);
1043 
1044   int flip_test = 0;
1045   Node* l = NULL;
1046   Node* r = NULL;
1047 
1048   if (success-&gt;in(0)-&gt;as_If()-&gt;range_check_trap_proj(flip_test, l, r) != NULL) {
1049     // If this looks like a range check, change the trap to
1050     // Reason_range_check so the compiler recognizes it as a range
1051     // check and applies the corresponding optimizations
1052     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_range_check, action);
1053 
1054     improve_address_types(l, r, fail, igvn);
1055 
1056     res = igvn-&gt;transform(new RangeCheckNode(in(0), in(1), _prob, _fcnt));
1057   } else if (unc != dom_unc) {
1058     // If we trap we won&#39;t know what CmpI would have caused the trap
1059     // so use a special trap reason to mark this pair of CmpI nodes as
1060     // bad candidate for folding. On recompilation we won&#39;t fold them
1061     // and we may trap again but this time we&#39;ll know what branch
1062     // traps
1063     trap_request = Deoptimization::make_trap_request(Deoptimization::Reason_unstable_fused_if, action);
1064   }
1065   igvn-&gt;replace_input_of(dom_unc, TypeFunc::Parms, igvn-&gt;intcon(trap_request));
1066   return res;
1067 }
1068 
1069 // If we are turning 2 CmpI nodes into a CmpU that follows the pattern
1070 // of a rangecheck on index i, on 64 bit the compares may be followed
1071 // by memory accesses using i as index. In that case, the CmpU tells
1072 // us something about the values taken by i that can help the compiler
1073 // (see Compile::conv_I2X_index())
1074 void IfNode::improve_address_types(Node* l, Node* r, ProjNode* fail, PhaseIterGVN* igvn) {
1075 #ifdef _LP64
1076   ResourceMark rm;
1077   Node_Stack stack(2);
1078 
1079   assert(r-&gt;Opcode() == Op_LoadRange, &quot;unexpected range check&quot;);
1080   const TypeInt* array_size = igvn-&gt;type(r)-&gt;is_int();
1081 
1082   stack.push(l, 0);
1083 
1084   while(stack.size() &gt; 0) {
1085     Node* n = stack.node();
1086     uint start = stack.index();
1087 
1088     uint i = start;
1089     for (; i &lt; n-&gt;outcnt(); i++) {
1090       Node* use = n-&gt;raw_out(i);
1091       if (stack.size() == 1) {
1092         if (use-&gt;Opcode() == Op_ConvI2L) {
1093           const TypeLong* bounds = use-&gt;as_Type()-&gt;type()-&gt;is_long();
1094           if (bounds-&gt;_lo &lt;= array_size-&gt;_lo &amp;&amp; bounds-&gt;_hi &gt;= array_size-&gt;_hi &amp;&amp;
1095               (bounds-&gt;_lo != array_size-&gt;_lo || bounds-&gt;_hi != array_size-&gt;_hi)) {
1096             stack.set_index(i+1);
1097             stack.push(use, 0);
1098             break;
1099           }
1100         }
1101       } else if (use-&gt;is_Mem()) {
1102         Node* ctrl = use-&gt;in(0);
1103         for (int i = 0; i &lt; 10 &amp;&amp; ctrl != NULL &amp;&amp; ctrl != fail; i++) {
1104           ctrl = up_one_dom(ctrl);
1105         }
1106         if (ctrl == fail) {
1107           Node* init_n = stack.node_at(1);
1108           assert(init_n-&gt;Opcode() == Op_ConvI2L, &quot;unexpected first node&quot;);
1109           // Create a new narrow ConvI2L node that is dependent on the range check
1110           Node* new_n = igvn-&gt;C-&gt;conv_I2X_index(igvn, l, array_size, fail);
1111 
1112           // The type of the ConvI2L may be widen and so the new
1113           // ConvI2L may not be better than an existing ConvI2L
1114           if (new_n != init_n) {
1115             for (uint j = 2; j &lt; stack.size(); j++) {
1116               Node* n = stack.node_at(j);
1117               Node* clone = n-&gt;clone();
1118               int rep = clone-&gt;replace_edge(init_n, new_n);
1119               assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1120               clone = igvn-&gt;transform(clone);
1121               init_n = n;
1122               new_n = clone;
1123             }
1124             igvn-&gt;hash_delete(use);
1125             int rep = use-&gt;replace_edge(init_n, new_n);
1126             assert(rep &gt; 0, &quot;can&#39;t find expected node?&quot;);
1127             igvn-&gt;transform(use);
1128             if (init_n-&gt;outcnt() == 0) {
1129               igvn-&gt;_worklist.push(init_n);
1130             }
1131           }
1132         }
1133       } else if (use-&gt;in(0) == NULL &amp;&amp; (igvn-&gt;type(use)-&gt;isa_long() ||
1134                                         igvn-&gt;type(use)-&gt;isa_ptr())) {
1135         stack.set_index(i+1);
1136         stack.push(use, 0);
1137         break;
1138       }
1139     }
1140     if (i == n-&gt;outcnt()) {
1141       stack.pop();
1142     }
1143   }
1144 #endif
1145 }
1146 
1147 bool IfNode::is_cmp_with_loadrange(ProjNode* proj) {
1148   if (in(1) != NULL &amp;&amp;
1149       in(1)-&gt;in(1) != NULL &amp;&amp;
1150       in(1)-&gt;in(1)-&gt;in(2) != NULL) {
1151     Node* other = in(1)-&gt;in(1)-&gt;in(2);
1152     if (other-&gt;Opcode() == Op_LoadRange &amp;&amp;
1153         ((other-&gt;in(0) != NULL &amp;&amp; other-&gt;in(0) == proj) ||
1154          (other-&gt;in(0) == NULL &amp;&amp;
1155           other-&gt;in(2) != NULL &amp;&amp;
1156           other-&gt;in(2)-&gt;is_AddP() &amp;&amp;
1157           other-&gt;in(2)-&gt;in(1) != NULL &amp;&amp;
1158           other-&gt;in(2)-&gt;in(1)-&gt;Opcode() == Op_CastPP &amp;&amp;
1159           other-&gt;in(2)-&gt;in(1)-&gt;in(0) == proj))) {
1160       return true;
1161     }
1162   }
1163   return false;
1164 }
1165 
1166 bool IfNode::is_null_check(ProjNode* proj, PhaseIterGVN* igvn) {
1167   Node* other = in(1)-&gt;in(1)-&gt;in(2);
1168   if (other-&gt;in(MemNode::Address) != NULL &amp;&amp;
1169       proj-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1170       proj-&gt;in(0)-&gt;in(1)-&gt;is_Bool() &amp;&amp;
1171       proj-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;
1172       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1173       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;
1174       proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == other-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;uncast() &amp;&amp;
1175       igvn-&gt;type(proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)) == TypePtr::NULL_PTR) {
1176     return true;
1177   }
1178   return false;
1179 }
1180 
1181 // Check that the If that is in between the 2 integer comparisons has
1182 // no side effect
1183 bool IfNode::is_side_effect_free_test(ProjNode* proj, PhaseIterGVN* igvn) {
1184   if (proj == NULL) {
1185     return false;
1186   }
1187   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1188   if (unc != NULL &amp;&amp; proj-&gt;outcnt() &lt;= 2) {
1189     if (proj-&gt;outcnt() == 1 ||
1190         // Allow simple null check from LoadRange
1191         (is_cmp_with_loadrange(proj) &amp;&amp; is_null_check(proj, igvn))) {
1192       CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1193       CallStaticJavaNode* dom_unc = proj-&gt;in(0)-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1194       assert(dom_unc != NULL, &quot;is_uncommon_trap_if_pattern returned NULL&quot;);
1195 
1196       // reroute_side_effect_free_unc changes the state of this
1197       // uncommon trap to restart execution at the previous
1198       // CmpI. Check that this change in a previous compilation didn&#39;t
1199       // cause too many traps.
1200       int trap_request = unc-&gt;uncommon_trap_request();
1201       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(trap_request);
1202 
1203       if (igvn-&gt;C-&gt;too_many_traps(dom_unc-&gt;jvms()-&gt;method(), dom_unc-&gt;jvms()-&gt;bci(), reason)) {
1204         return false;
1205       }
1206 
1207       if (!is_dominator_unc(dom_unc, unc)) {
1208         return false;
1209       }
1210 
1211       return true;
1212     }
1213   }
1214   return false;
1215 }
1216 
1217 // Make the If between the 2 integer comparisons trap at the state of
1218 // the first If: the last CmpI is the one replaced by a CmpU and the
1219 // first CmpI is eliminated, so the test between the 2 CmpI nodes
1220 // won&#39;t be guarded by the first CmpI anymore. It can trap in cases
1221 // where the first CmpI would have prevented it from executing: on a
1222 // trap, we need to restart execution at the state of the first CmpI
1223 void IfNode::reroute_side_effect_free_unc(ProjNode* proj, ProjNode* dom_proj, PhaseIterGVN* igvn) {
1224   CallStaticJavaNode* dom_unc = dom_proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1225   ProjNode* otherproj = proj-&gt;other_if_proj();
1226   CallStaticJavaNode* unc = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1227   Node* call_proj = dom_unc-&gt;unique_ctrl_out();
1228   Node* halt = call_proj-&gt;unique_ctrl_out();
1229 
1230   Node* new_unc = dom_unc-&gt;clone();
1231   call_proj = call_proj-&gt;clone();
1232   halt = halt-&gt;clone();
1233   Node* c = otherproj-&gt;clone();
1234 
1235   c = igvn-&gt;transform(c);
1236   new_unc-&gt;set_req(TypeFunc::Parms, unc-&gt;in(TypeFunc::Parms));
1237   new_unc-&gt;set_req(0, c);
1238   new_unc = igvn-&gt;transform(new_unc);
1239   call_proj-&gt;set_req(0, new_unc);
1240   call_proj = igvn-&gt;transform(call_proj);
1241   halt-&gt;set_req(0, call_proj);
1242   halt = igvn-&gt;transform(halt);
1243 
1244   igvn-&gt;replace_node(otherproj, igvn-&gt;C-&gt;top());
1245   igvn-&gt;C-&gt;root()-&gt;add_req(halt);
1246 }
1247 
1248 Node* IfNode::fold_compares(PhaseIterGVN* igvn) {
1249   if (Opcode() != Op_If) return NULL;
1250 
1251   if (cmpi_folds(igvn)) {
1252     Node* ctrl = in(0);
1253     if (is_ctrl_folds(ctrl, igvn) &amp;&amp; ctrl-&gt;outcnt() == 1) {
1254       // A integer comparison immediately dominated by another integer
1255       // comparison
1256       ProjNode* success = NULL;
1257       ProjNode* fail = NULL;
1258       ProjNode* dom_cmp = ctrl-&gt;as_Proj();
1259       if (has_shared_region(dom_cmp, success, fail) &amp;&amp;
1260           // Next call modifies graph so must be last
1261           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1262         return this;
1263       }
1264       if (has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1265           // Next call modifies graph so must be last
1266           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1267         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1268       }
1269       return NULL;
1270     } else if (ctrl-&gt;in(0) != NULL &amp;&amp;
1271                ctrl-&gt;in(0)-&gt;in(0) != NULL) {
1272       ProjNode* success = NULL;
1273       ProjNode* fail = NULL;
1274       Node* dom = ctrl-&gt;in(0)-&gt;in(0);
1275       ProjNode* dom_cmp = dom-&gt;isa_Proj();
1276       ProjNode* other_cmp = ctrl-&gt;isa_Proj();
1277 
1278       // Check if it&#39;s an integer comparison dominated by another
1279       // integer comparison with another test in between
1280       if (is_ctrl_folds(dom, igvn) &amp;&amp;
1281           has_only_uncommon_traps(dom_cmp, success, fail, igvn) &amp;&amp;
1282           is_side_effect_free_test(other_cmp, igvn) &amp;&amp;
1283           // Next call modifies graph so must be last
1284           fold_compares_helper(dom_cmp, success, fail, igvn)) {
1285         reroute_side_effect_free_unc(other_cmp, dom_cmp, igvn);
1286         return merge_uncommon_traps(dom_cmp, success, fail, igvn);
1287       }
1288     }
1289   }
1290   return NULL;
1291 }
1292 
1293 //------------------------------remove_useless_bool----------------------------
1294 // Check for people making a useless boolean: things like
1295 // if( (x &lt; y ? true : false) ) { ... }
1296 // Replace with if( x &lt; y ) { ... }
1297 static Node *remove_useless_bool(IfNode *iff, PhaseGVN *phase) {
1298   Node *i1 = iff-&gt;in(1);
1299   if( !i1-&gt;is_Bool() ) return NULL;
1300   BoolNode *bol = i1-&gt;as_Bool();
1301 
1302   Node *cmp = bol-&gt;in(1);
1303   if( cmp-&gt;Opcode() != Op_CmpI ) return NULL;
1304 
1305   // Must be comparing against a bool
1306   const Type *cmp2_t = phase-&gt;type( cmp-&gt;in(2) );
1307   if( cmp2_t != TypeInt::ZERO &amp;&amp;
1308       cmp2_t != TypeInt::ONE )
1309     return NULL;
1310 
1311   // Find a prior merge point merging the boolean
1312   i1 = cmp-&gt;in(1);
1313   if( !i1-&gt;is_Phi() ) return NULL;
1314   PhiNode *phi = i1-&gt;as_Phi();
1315   if( phase-&gt;type( phi ) != TypeInt::BOOL )
1316     return NULL;
1317 
1318   // Check for diamond pattern
1319   int true_path = phi-&gt;is_diamond_phi();
1320   if( true_path == 0 ) return NULL;
1321 
1322   // Make sure that iff and the control of the phi are different. This
1323   // should really only happen for dead control flow since it requires
1324   // an illegal cycle.
1325   if (phi-&gt;in(0)-&gt;in(1)-&gt;in(0) == iff) return NULL;
1326 
1327   // phi-&gt;region-&gt;if_proj-&gt;ifnode-&gt;bool-&gt;cmp
1328   BoolNode *bol2 = phi-&gt;in(0)-&gt;in(1)-&gt;in(0)-&gt;in(1)-&gt;as_Bool();
1329 
1330   // Now get the &#39;sense&#39; of the test correct so we can plug in
1331   // either iff2-&gt;in(1) or its complement.
1332   int flip = 0;
1333   if( bol-&gt;_test._test == BoolTest::ne ) flip = 1-flip;
1334   else if( bol-&gt;_test._test != BoolTest::eq ) return NULL;
1335   if( cmp2_t == TypeInt::ZERO ) flip = 1-flip;
1336 
1337   const Type *phi1_t = phase-&gt;type( phi-&gt;in(1) );
1338   const Type *phi2_t = phase-&gt;type( phi-&gt;in(2) );
1339   // Check for Phi(0,1) and flip
1340   if( phi1_t == TypeInt::ZERO ) {
1341     if( phi2_t != TypeInt::ONE ) return NULL;
1342     flip = 1-flip;
1343   } else {
1344     // Check for Phi(1,0)
1345     if( phi1_t != TypeInt::ONE  ) return NULL;
1346     if( phi2_t != TypeInt::ZERO ) return NULL;
1347   }
1348   if( true_path == 2 ) {
1349     flip = 1-flip;
1350   }
1351 
1352   Node* new_bol = (flip ? phase-&gt;transform( bol2-&gt;negate(phase) ) : bol2);
1353   assert(new_bol != iff-&gt;in(1), &quot;must make progress&quot;);
1354   iff-&gt;set_req(1, new_bol);
1355   // Intervening diamond probably goes dead
1356   phase-&gt;C-&gt;set_major_progress();
1357   return iff;
1358 }
1359 
1360 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff);
1361 
1362 struct RangeCheck {
1363   Node* ctl;
1364   jint off;
1365 };
1366 
1367 Node* IfNode::Ideal_common(PhaseGVN *phase, bool can_reshape) {
1368   if (remove_dead_region(phase, can_reshape))  return this;
1369   // No Def-Use info?
1370   if (!can_reshape)  return NULL;
1371 
1372   // Don&#39;t bother trying to transform a dead if
1373   if (in(0)-&gt;is_top())  return NULL;
1374   // Don&#39;t bother trying to transform an if with a dead test
1375   if (in(1)-&gt;is_top())  return NULL;
1376   // Another variation of a dead test
1377   if (in(1)-&gt;is_Con())  return NULL;
1378   // Another variation of a dead if
1379   if (outcnt() &lt; 2)  return NULL;
1380 
1381   // Canonicalize the test.
1382   Node* idt_if = idealize_test(phase, this);
1383   if (idt_if != NULL)  return idt_if;
1384 
1385   // Try to split the IF
1386   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1387   Node *s = split_if(this, igvn);
1388   if (s != NULL)  return s;
1389 
1390   return NodeSentinel;
1391 }
1392 
1393 //------------------------------Ideal------------------------------------------
1394 // Return a node which is more &quot;ideal&quot; than the current node.  Strip out
1395 // control copies
1396 Node* IfNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1397   Node* res = Ideal_common(phase, can_reshape);
1398   if (res != NodeSentinel) {
1399     return res;
1400   }
1401 
1402   // Check for people making a useless boolean: things like
1403   // if( (x &lt; y ? true : false) ) { ... }
1404   // Replace with if( x &lt; y ) { ... }
1405   Node* bol2 = remove_useless_bool(this, phase);
1406   if (bol2) return bol2;
1407 
1408   if (in(0) == NULL) return NULL;     // Dead loop?
1409 
1410   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1411   Node* result = fold_compares(igvn);
1412   if (result != NULL) {
1413     return result;
1414   }
1415 
1416   // Scan for an equivalent test
1417   int dist = 4;               // Cutoff limit for search
1418   if (is_If() &amp;&amp; in(1)-&gt;is_Bool()) {
1419     Node* cmp = in(1)-&gt;in(1);
1420     if (cmp-&gt;Opcode() == Op_CmpP &amp;&amp;
1421         cmp-&gt;in(2) != NULL &amp;&amp; // make sure cmp is not already dead
1422         cmp-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1423       dist = 64;              // Limit for null-pointer scans
1424     }
1425   }
1426 
1427   Node* prev_dom = search_identical(dist);
1428 
1429   if (prev_dom != NULL) {
1430     // Replace dominated IfNode
1431     return dominated_by(prev_dom, igvn);
1432   }
1433 
1434   return simple_subsuming(igvn);
1435 }
1436 
1437 //------------------------------dominated_by-----------------------------------
1438 Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {
1439 #ifndef PRODUCT
1440   if (TraceIterativeGVN) {
1441     tty-&gt;print(&quot;   Removing IfNode: &quot;); this-&gt;dump();
1442   }
1443 #endif
1444 
1445   igvn-&gt;hash_delete(this);      // Remove self to prevent spurious V-N
1446   Node *idom = in(0);
1447   // Need opcode to decide which way &#39;this&#39; test goes
1448   int prev_op = prev_dom-&gt;Opcode();
1449   Node *top = igvn-&gt;C-&gt;top(); // Shortcut to top
1450 
1451   // Loop predicates may have depending checks which should not
1452   // be skipped. For example, range check predicate has two checks
1453   // for lower and upper bounds.
1454   ProjNode* unc_proj = proj_out(1 - prev_dom-&gt;as_Proj()-&gt;_con)-&gt;as_Proj();
1455   if (unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||
1456       unc_proj-&gt;is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {
1457     prev_dom = idom;
1458   }
1459 
1460   // Now walk the current IfNode&#39;s projections.
1461   // Loop ends when &#39;this&#39; has no more uses.
1462   for (DUIterator_Last imin, i = last_outs(imin); i &gt;= imin; --i) {
1463     Node *ifp = last_out(i);     // Get IfTrue/IfFalse
1464     igvn-&gt;add_users_to_worklist(ifp);
1465     // Check which projection it is and set target.
1466     // Data-target is either the dominating projection of the same type
1467     // or TOP if the dominating projection is of opposite type.
1468     // Data-target will be used as the new control edge for the non-CFG
1469     // nodes like Casts and Loads.
1470     Node *data_target = (ifp-&gt;Opcode() == prev_op) ? prev_dom : top;
1471     // Control-target is just the If&#39;s immediate dominator or TOP.
1472     Node *ctrl_target = (ifp-&gt;Opcode() == prev_op) ?     idom : top;
1473 
1474     // For each child of an IfTrue/IfFalse projection, reroute.
1475     // Loop ends when projection has no more uses.
1476     for (DUIterator_Last jmin, j = ifp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
1477       Node* s = ifp-&gt;last_out(j);   // Get child of IfTrue/IfFalse
1478       if( !s-&gt;depends_only_on_test() ) {
1479         // Find the control input matching this def-use edge.
1480         // For Regions it may not be in slot 0.
1481         uint l;
1482         for( l = 0; s-&gt;in(l) != ifp; l++ ) { }
1483         igvn-&gt;replace_input_of(s, l, ctrl_target);
1484       } else {                      // Else, for control producers,
1485         igvn-&gt;replace_input_of(s, 0, data_target); // Move child to data-target
1486       }
1487     } // End for each child of a projection
1488 
1489     igvn-&gt;remove_dead_node(ifp);
1490   } // End for each IfTrue/IfFalse child of If
1491 
1492   // Kill the IfNode
1493   igvn-&gt;remove_dead_node(this);
1494 
1495   // Must return either the original node (now dead) or a new node
1496   // (Do not return a top here, since that would break the uniqueness of top.)
1497   return new ConINode(TypeInt::ZERO);
1498 }
1499 
1500 Node* IfNode::search_identical(int dist) {
1501   // Setup to scan up the CFG looking for a dominating test
1502   Node* dom = in(0);
1503   Node* prev_dom = this;
1504   int op = Opcode();
1505   // Search up the dominator tree for an If with an identical test
1506   while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1507          dom-&gt;in(1)    != in(1) ||  // Not same input 1?
1508          prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1509     if (dist &lt; 0) return NULL;
1510 
1511     dist--;
1512     prev_dom = dom;
1513     dom = up_one_dom(dom);
1514     if (!dom) return NULL;
1515   }
1516 
1517   // Check that we did not follow a loop back to ourselves
1518   if (this == dom) {
1519     return NULL;
1520   }
1521 
1522 #ifndef PRODUCT
1523   if (dist &gt; 2) { // Add to count of NULL checks elided
1524     explicit_null_checks_elided++;
1525   }
1526 #endif
1527 
1528   return prev_dom;
1529 }
1530 
1531 
1532 static int subsuming_bool_test_encode(Node*);
1533 
1534 // Check if dominating test is subsuming &#39;this&#39; one.
1535 //
1536 //              cmp
1537 //              / \
1538 //     (r1)  bool  \
1539 //            /    bool (r2)
1540 //    (dom) if       \
1541 //            \       )
1542 //    (pre)  if[TF]  /
1543 //               \  /
1544 //                if (this)
1545 //   \r1
1546 //  r2\  eqT  eqF  neT  neF  ltT  ltF  leT  leF  gtT  gtF  geT  geF
1547 //  eq    t    f    f    t    f    -    -    f    f    -    -    f
1548 //  ne    f    t    t    f    t    -    -    t    t    -    -    t
1549 //  lt    f    -    -    f    t    f    -    f    f    -    f    t
1550 //  le    t    -    -    t    t    -    t    f    f    t    -    t
1551 //  gt    f    -    -    f    f    -    f    t    t    f    -    f
1552 //  ge    t    -    -    t    f    t    -    t    t    -    t    f
1553 //
1554 Node* IfNode::simple_subsuming(PhaseIterGVN* igvn) {
1555   // Table encoding: N/A (na), True-branch (tb), False-branch (fb).
1556   static enum { na, tb, fb } s_short_circuit_map[6][12] = {
1557   /*rel: eq+T eq+F ne+T ne+F lt+T lt+F le+T le+F gt+T gt+F ge+T ge+F*/
1558   /*eq*/{ tb,  fb,  fb,  tb,  fb,  na,  na,  fb,  fb,  na,  na,  fb },
1559   /*ne*/{ fb,  tb,  tb,  fb,  tb,  na,  na,  tb,  tb,  na,  na,  tb },
1560   /*lt*/{ fb,  na,  na,  fb,  tb,  fb,  na,  fb,  fb,  na,  fb,  tb },
1561   /*le*/{ tb,  na,  na,  tb,  tb,  na,  tb,  fb,  fb,  tb,  na,  tb },
1562   /*gt*/{ fb,  na,  na,  fb,  fb,  na,  fb,  tb,  tb,  fb,  na,  fb },
1563   /*ge*/{ tb,  na,  na,  tb,  fb,  tb,  na,  tb,  tb,  na,  tb,  fb }};
1564 
1565   Node* pre = in(0);
1566   if (!pre-&gt;is_IfTrue() &amp;&amp; !pre-&gt;is_IfFalse()) {
1567     return NULL;
1568   }
1569   Node* dom = pre-&gt;in(0);
1570   if (!dom-&gt;is_If()) {
1571     return NULL;
1572   }
1573   Node* bol = in(1);
1574   if (!bol-&gt;is_Bool()) {
1575     return NULL;
1576   }
1577   Node* cmp = in(1)-&gt;in(1);
1578   if (!cmp-&gt;is_Cmp()) {
1579     return NULL;
1580   }
1581 
1582   if (!dom-&gt;in(1)-&gt;is_Bool()) {
1583     return NULL;
1584   }
1585   if (dom-&gt;in(1)-&gt;in(1) != cmp) {  // Not same cond?
1586     return NULL;
1587   }
1588 
1589   int drel = subsuming_bool_test_encode(dom-&gt;in(1));
1590   int trel = subsuming_bool_test_encode(bol);
1591   int bout = pre-&gt;is_IfFalse() ? 1 : 0;
1592 
1593   if (drel &lt; 0 || trel &lt; 0) {
1594     return NULL;
1595   }
1596   int br = s_short_circuit_map[trel][2*drel+bout];
1597   if (br == na) {
1598     return NULL;
1599   }
1600 #ifndef PRODUCT
1601   if (TraceIterativeGVN) {
1602     tty-&gt;print(&quot;   Subsumed IfNode: &quot;); dump();
1603   }
1604 #endif
1605   // Replace condition with constant True(1)/False(0).
1606   set_req(1, igvn-&gt;intcon(br == tb ? 1 : 0));
1607 
1608   if (bol-&gt;outcnt() == 0) {
1609     igvn-&gt;remove_dead_node(bol);    // Kill the BoolNode.
1610   }
1611   return this;
1612 }
1613 
1614 // Map BoolTest to local table encoding. The BoolTest (e)numerals
1615 //   { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1 }
1616 // are mapped to table indices, while the remaining (e)numerals in BoolTest
1617 //   { overflow = 2, no_overflow = 6, never = 8, illegal = 9 }
1618 // are ignored (these are not modeled in the table).
1619 //
1620 static int subsuming_bool_test_encode(Node* node) {
1621   precond(node-&gt;is_Bool());
1622   BoolTest::mask x = node-&gt;as_Bool()-&gt;_test._test;
1623   switch (x) {
1624     case BoolTest::eq: return 0;
1625     case BoolTest::ne: return 1;
1626     case BoolTest::lt: return 2;
1627     case BoolTest::le: return 3;
1628     case BoolTest::gt: return 4;
1629     case BoolTest::ge: return 5;
1630     case BoolTest::overflow:
1631     case BoolTest::no_overflow:
1632     case BoolTest::never:
1633     case BoolTest::illegal:
1634     default:
1635       return -1;
1636   }
1637 }
1638 
1639 //------------------------------Identity---------------------------------------
1640 // If the test is constant &amp; we match, then we are the input Control
1641 Node* IfProjNode::Identity(PhaseGVN* phase) {
1642   // Can only optimize if cannot go the other way
1643   const TypeTuple *t = phase-&gt;type(in(0))-&gt;is_tuple();
1644   if (t == TypeTuple::IFNEITHER || (always_taken(t) &amp;&amp;
1645        // During parsing (GVN) we don&#39;t remove dead code aggressively.
1646        // Cut off dead branch and let PhaseRemoveUseless take care of it.
1647       (!phase-&gt;is_IterGVN() ||
1648        // During IGVN, first wait for the dead branch to be killed.
1649        // Otherwise, the IfNode&#39;s control will have two control uses (the IfNode
1650        // that doesn&#39;t go away because it still has uses and this branch of the
1651        // If) which breaks other optimizations. Node::has_special_unique_user()
1652        // will cause this node to be reprocessed once the dead branch is killed.
1653        in(0)-&gt;outcnt() == 1))) {
1654     // IfNode control
1655     return in(0)-&gt;in(0);
1656   }
1657   // no progress
1658   return this;
1659 }
1660 
1661 #ifndef PRODUCT
1662 //-------------------------------related---------------------------------------
1663 // An IfProjNode&#39;s related node set consists of its input (an IfNode) including
1664 // the IfNode&#39;s condition, plus all of its outputs at level 1. In compact mode,
1665 // the restrictions for IfNode apply (see IfNode::rel).
1666 void IfProjNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1667   Node* ifNode = this-&gt;in(0);
1668   in_rel-&gt;append(ifNode);
1669   if (compact) {
1670     ifNode-&gt;collect_nodes(in_rel, 3, false, true);
1671   } else {
1672     ifNode-&gt;collect_nodes_in_all_data(in_rel, false);
1673   }
1674   this-&gt;collect_nodes(out_rel, -1, false, false);
1675 }
1676 
1677 //------------------------------dump_spec--------------------------------------
1678 void IfNode::dump_spec(outputStream *st) const {
1679   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob,_fcnt);
1680 }
1681 
1682 //-------------------------------related---------------------------------------
1683 // For an IfNode, the set of related output nodes is just the output nodes till
1684 // depth 2, i.e, the IfTrue/IfFalse projection nodes plus the nodes they refer.
1685 // The related input nodes contain no control nodes, but all data nodes
1686 // pertaining to the condition. In compact mode, the input nodes are collected
1687 // up to a depth of 3.
1688 void IfNode::related(GrowableArray &lt;Node *&gt; *in_rel, GrowableArray &lt;Node *&gt; *out_rel, bool compact) const {
1689   if (compact) {
1690     this-&gt;collect_nodes(in_rel, 3, false, true);
1691   } else {
1692     this-&gt;collect_nodes_in_all_data(in_rel, false);
1693   }
1694   this-&gt;collect_nodes(out_rel, -2, false, false);
1695 }
1696 #endif
1697 
1698 //------------------------------idealize_test----------------------------------
1699 // Try to canonicalize tests better.  Peek at the Cmp/Bool/If sequence and
1700 // come up with a canonical sequence.  Bools getting &#39;eq&#39;, &#39;gt&#39; and &#39;ge&#39; forms
1701 // converted to &#39;ne&#39;, &#39;le&#39; and &#39;lt&#39; forms.  IfTrue/IfFalse get swapped as
1702 // needed.
1703 static IfNode* idealize_test(PhaseGVN* phase, IfNode* iff) {
1704   assert(iff-&gt;in(0) != NULL, &quot;If must be live&quot;);
1705 
1706   if (iff-&gt;outcnt() != 2)  return NULL; // Malformed projections.
1707   Node* old_if_f = iff-&gt;proj_out(false);
1708   Node* old_if_t = iff-&gt;proj_out(true);
1709 
1710   // CountedLoopEnds want the back-control test to be TRUE, irregardless of
1711   // whether they are testing a &#39;gt&#39; or &#39;lt&#39; condition.  The &#39;gt&#39; condition
1712   // happens in count-down loops
1713   if (iff-&gt;is_CountedLoopEnd())  return NULL;
1714   if (!iff-&gt;in(1)-&gt;is_Bool())  return NULL; // Happens for partially optimized IF tests
1715   BoolNode *b = iff-&gt;in(1)-&gt;as_Bool();
1716   BoolTest bt = b-&gt;_test;
1717   // Test already in good order?
1718   if( bt.is_canonical() )
1719     return NULL;
1720 
1721   // Flip test to be canonical.  Requires flipping the IfFalse/IfTrue and
1722   // cloning the IfNode.
1723   Node* new_b = phase-&gt;transform( new BoolNode(b-&gt;in(1), bt.negate()) );
1724   if( !new_b-&gt;is_Bool() ) return NULL;
1725   b = new_b-&gt;as_Bool();
1726 
1727   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1728   assert( igvn, &quot;Test is not canonical in parser?&quot; );
1729 
1730   // The IF node never really changes, but it needs to be cloned
1731   iff = iff-&gt;clone()-&gt;as_If();
1732   iff-&gt;set_req(1, b);
1733   iff-&gt;_prob = 1.0-iff-&gt;_prob;
1734 
1735   Node *prior = igvn-&gt;hash_find_insert(iff);
1736   if( prior ) {
1737     igvn-&gt;remove_dead_node(iff);
1738     iff = (IfNode*)prior;
1739   } else {
1740     // Cannot call transform on it just yet
1741     igvn-&gt;set_type_bottom(iff);
1742   }
1743   igvn-&gt;_worklist.push(iff);
1744 
1745   // Now handle projections.  Cloning not required.
1746   Node* new_if_f = (Node*)(new IfFalseNode( iff ));
1747   Node* new_if_t = (Node*)(new IfTrueNode ( iff ));
1748 
1749   igvn-&gt;register_new_node_with_optimizer(new_if_f);
1750   igvn-&gt;register_new_node_with_optimizer(new_if_t);
1751   // Flip test, so flip trailing control
1752   igvn-&gt;replace_node(old_if_f, new_if_t);
1753   igvn-&gt;replace_node(old_if_t, new_if_f);
1754 
1755   // Progress
1756   return iff;
1757 }
1758 
1759 Node* RangeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1760   Node* res = Ideal_common(phase, can_reshape);
1761   if (res != NodeSentinel) {
1762     return res;
1763   }
1764 
1765   PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1766   // Setup to scan up the CFG looking for a dominating test
1767   Node* prev_dom = this;
1768 
1769   // Check for range-check vs other kinds of tests
1770   Node* index1;
1771   Node* range1;
1772   jint offset1;
1773   int flip1 = is_range_check(range1, index1, offset1);
1774   if (flip1) {
1775     Node* dom = in(0);
1776     // Try to remove extra range checks.  All &#39;up_one_dom&#39; gives up at merges
1777     // so all checks we inspect post-dominate the top-most check we find.
1778     // If we are going to fail the current check and we reach the top check
1779     // then we are guaranteed to fail, so just start interpreting there.
1780     // We &#39;expand&#39; the top 3 range checks to include all post-dominating
1781     // checks.
1782 
1783     // The top 3 range checks seen
1784     const int NRC = 3;
1785     RangeCheck prev_checks[NRC];
1786     int nb_checks = 0;
1787 
1788     // Low and high offsets seen so far
1789     jint off_lo = offset1;
1790     jint off_hi = offset1;
1791 
1792     bool found_immediate_dominator = false;
1793 
1794     // Scan for the top checks and collect range of offsets
1795     for (int dist = 0; dist &lt; 999; dist++) { // Range-Check scan limit
1796       if (dom-&gt;Opcode() == Op_RangeCheck &amp;&amp;  // Not same opcode?
1797           prev_dom-&gt;in(0) == dom) { // One path of test does dominate?
1798         if (dom == this) return NULL; // dead loop
1799         // See if this is a range check
1800         Node* index2;
1801         Node* range2;
1802         jint offset2;
1803         int flip2 = dom-&gt;as_RangeCheck()-&gt;is_range_check(range2, index2, offset2);
1804         // See if this is a _matching_ range check, checking against
1805         // the same array bounds.
1806         if (flip2 == flip1 &amp;&amp; range2 == range1 &amp;&amp; index2 == index1 &amp;&amp;
1807             dom-&gt;outcnt() == 2) {
1808           if (nb_checks == 0 &amp;&amp; dom-&gt;in(1) == in(1)) {
1809             // Found an immediately dominating test at the same offset.
1810             // This kind of back-to-back test can be eliminated locally,
1811             // and there is no need to search further for dominating tests.
1812             assert(offset2 == offset1, &quot;Same test but different offsets&quot;);
1813             found_immediate_dominator = true;
1814             break;
1815           }
1816           // Gather expanded bounds
1817           off_lo = MIN2(off_lo,offset2);
1818           off_hi = MAX2(off_hi,offset2);
1819           // Record top NRC range checks
1820           prev_checks[nb_checks%NRC].ctl = prev_dom;
1821           prev_checks[nb_checks%NRC].off = offset2;
1822           nb_checks++;
1823         }
1824       }
1825       prev_dom = dom;
1826       dom = up_one_dom(dom);
1827       if (!dom) break;
1828     }
1829 
1830     if (!found_immediate_dominator) {
1831       // Attempt to widen the dominating range check to cover some later
1832       // ones.  Since range checks &quot;fail&quot; by uncommon-trapping to the
1833       // interpreter, widening a check can make us speculatively enter
1834       // the interpreter.  If we see range-check deopt&#39;s, do not widen!
1835       if (!phase-&gt;C-&gt;allow_range_check_smearing())  return NULL;
1836 
1837       // Didn&#39;t find prior covering check, so cannot remove anything.
1838       if (nb_checks == 0) {
1839         return NULL;
1840       }
1841       // Constant indices only need to check the upper bound.
1842       // Non-constant indices must check both low and high.
1843       int chk0 = (nb_checks - 1) % NRC;
1844       if (index1) {
1845         if (nb_checks == 1) {
1846           return NULL;
1847         } else {
1848           // If the top range check&#39;s constant is the min or max of
1849           // all constants we widen the next one to cover the whole
1850           // range of constants.
1851           RangeCheck rc0 = prev_checks[chk0];
1852           int chk1 = (nb_checks - 2) % NRC;
1853           RangeCheck rc1 = prev_checks[chk1];
1854           if (rc0.off == off_lo) {
1855             adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1856             prev_dom = rc1.ctl;
1857           } else if (rc0.off == off_hi) {
1858             adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1859             prev_dom = rc1.ctl;
1860           } else {
1861             // If the top test&#39;s constant is not the min or max of all
1862             // constants, we need 3 range checks. We must leave the
1863             // top test unchanged because widening it would allow the
1864             // accesses it protects to successfully read/write out of
1865             // bounds.
1866             if (nb_checks == 2) {
1867               return NULL;
1868             }
1869             int chk2 = (nb_checks - 3) % NRC;
1870             RangeCheck rc2 = prev_checks[chk2];
1871             // The top range check a+i covers interval: -a &lt;= i &lt; length-a
1872             // The second range check b+i covers interval: -b &lt;= i &lt; length-b
1873             if (rc1.off &lt;= rc0.off) {
1874               // if b &lt;= a, we change the second range check to:
1875               // -min_of_all_constants &lt;= i &lt; length-min_of_all_constants
1876               // Together top and second range checks now cover:
1877               // -min_of_all_constants &lt;= i &lt; length-a
1878               // which is more restrictive than -b &lt;= i &lt; length-b:
1879               // -b &lt;= -min_of_all_constants &lt;= i &lt; length-a &lt;= length-b
1880               // The third check is then changed to:
1881               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1882               // so 2nd and 3rd checks restrict allowed values of i to:
1883               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1884               adjust_check(rc1.ctl, range1, index1, flip1, off_lo, igvn);
1885               adjust_check(rc2.ctl, range1, index1, flip1, off_hi, igvn);
1886             } else {
1887               // if b &gt; a, we change the second range check to:
1888               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1889               // Together top and second range checks now cover:
1890               // -a &lt;= i &lt; length-max_of_all_constants
1891               // which is more restrictive than -b &lt;= i &lt; length-b:
1892               // -b &lt; -a &lt;= i &lt; length-max_of_all_constants &lt;= length-b
1893               // The third check is then changed to:
1894               // -max_of_all_constants &lt;= i &lt; length-max_of_all_constants
1895               // so 2nd and 3rd checks restrict allowed values of i to:
1896               // -min_of_all_constants &lt;= i &lt; length-max_of_all_constants
1897               adjust_check(rc1.ctl, range1, index1, flip1, off_hi, igvn);
1898               adjust_check(rc2.ctl, range1, index1, flip1, off_lo, igvn);
1899             }
1900             prev_dom = rc2.ctl;
1901           }
1902         }
1903       } else {
1904         RangeCheck rc0 = prev_checks[chk0];
1905         // &#39;Widen&#39; the offset of the 1st and only covering check
1906         adjust_check(rc0.ctl, range1, index1, flip1, off_hi, igvn);
1907         // Test is now covered by prior checks, dominate it out
1908         prev_dom = rc0.ctl;
1909       }
1910     }
1911   } else {
1912     prev_dom = search_identical(4);
1913 
1914     if (prev_dom == NULL) {
1915       return NULL;
1916     }
1917   }
1918 
1919   // Replace dominated IfNode
1920   return dominated_by(prev_dom, igvn);
1921 }
    </pre>
  </body>
</html>