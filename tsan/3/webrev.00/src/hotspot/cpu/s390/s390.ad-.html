<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2017, SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 
   25 // z/Architecture Architecture Description File
   26 
   27 // Major contributions by AS, JL, LS.
   28 
   29 //
   30 // Following information is derived from private mail communication
   31 // (Oct. 2011).
   32 //
   33 // General branch target alignment considerations
   34 //
   35 // z/Architecture does not imply a general branch target alignment requirement.
   36 // There are side effects and side considerations, though, which may
   37 // provide some performance benefit. These are:
   38 //  - Align branch target on octoword (32-byte) boundary
   39 //    On more recent models (from z9 on), I-fetch is done on a Octoword
   40 //    (32 bytes at a time) basis. To avoid I-fetching unnecessary
   41 //    instructions, branch targets should be 32-byte aligend. If this
   42 //    exact alingment cannot be achieved, having the branch target in
   43 //    the first doubleword still provides some benefit.
   44 //  - Avoid branch targets at the end of cache lines (&gt; 64 bytes distance).
   45 //    Sequential instruction prefetching after the branch target starts
   46 //    immediately after having fetched the octoword containing the
   47 //    branch target. When I-fetching crosses a cache line, there may be
   48 //    a small stall. The worst case: the branch target (at the end of
   49 //    a cache line) is a L1 I-cache miss and the next line as well.
   50 //    Then, the entire target line must be filled first (to contine at the
   51 //    branch target). Only then can the next sequential line be filled.
   52 //  - Avoid multiple poorly predicted branches in a row.
   53 //
   54 
   55 //----------REGISTER DEFINITION BLOCK------------------------------------------
   56 // This information is used by the matcher and the register allocator to
   57 // describe individual registers and classes of registers within the target
   58 // architecture.
   59 
   60 register %{
   61 
   62 //----------Architecture Description Register Definitions----------------------
   63 // General Registers
   64 // &quot;reg_def&quot; name (register save type, C convention save type,
   65 //                   ideal register type, encoding);
   66 //
   67 // Register Save Types:
   68 //
   69 //   NS  = No-Save:     The register allocator assumes that these registers
   70 //                      can be used without saving upon entry to the method, &amp;
   71 //                      that they do not need to be saved at call sites.
   72 //
   73 //   SOC = Save-On-Call: The register allocator assumes that these registers
   74 //                      can be used without saving upon entry to the method,
   75 //                      but that they must be saved at call sites.
   76 //
   77 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   78 //                      must be saved before using them upon entry to the
   79 //                      method, but they do not need to be saved at call sites.
   80 //
   81 //   AS  = Always-Save: The register allocator assumes that these registers
   82 //                      must be saved before using them upon entry to the
   83 //                      method, &amp; that they must be saved at call sites.
   84 //
   85 // Ideal Register Type is used to determine how to save &amp; restore a
   86 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   87 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   88 //
   89 // The encoding number is the actual bit-pattern placed into the opcodes.
   90 
   91 // z/Architecture register definitions, based on the z/Architecture Principles
   92 // of Operation, 5th Edition, September 2005, and z/Linux Elf ABI Supplement,
   93 // 5th Edition, March 2001.
   94 //
   95 // For each 64-bit register we must define two registers: the register
   96 // itself, e.g. Z_R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   97 // e.g. Z_R3_H, which is needed by the allocator, but is not used
   98 // for stores, loads, etc.
   99 
  100   // Integer/Long Registers
  101   // ----------------------------
  102 
  103   // z/Architecture has 16 64-bit integer registers.
  104 
  105   // types: v = volatile, nv = non-volatile, s = system
  106   reg_def Z_R0   (SOC, SOC, Op_RegI,  0, Z_R0-&gt;as_VMReg());   // v   scratch1
  107   reg_def Z_R0_H (SOC, SOC, Op_RegI, 99, Z_R0-&gt;as_VMReg()-&gt;next());
  108   reg_def Z_R1   (SOC, SOC, Op_RegI,  1, Z_R1-&gt;as_VMReg());   // v   scratch2
  109   reg_def Z_R1_H (SOC, SOC, Op_RegI, 99, Z_R1-&gt;as_VMReg()-&gt;next());
  110   reg_def Z_R2   (SOC, SOC, Op_RegI,  2, Z_R2-&gt;as_VMReg());   // v   iarg1 &amp; iret
  111   reg_def Z_R2_H (SOC, SOC, Op_RegI, 99, Z_R2-&gt;as_VMReg()-&gt;next());
  112   reg_def Z_R3   (SOC, SOC, Op_RegI,  3, Z_R3-&gt;as_VMReg());   // v   iarg2
  113   reg_def Z_R3_H (SOC, SOC, Op_RegI, 99, Z_R3-&gt;as_VMReg()-&gt;next());
  114   reg_def Z_R4   (SOC, SOC, Op_RegI,  4, Z_R4-&gt;as_VMReg());   // v   iarg3
  115   reg_def Z_R4_H (SOC, SOC, Op_RegI, 99, Z_R4-&gt;as_VMReg()-&gt;next());
  116   reg_def Z_R5   (SOC, SOC, Op_RegI,  5, Z_R5-&gt;as_VMReg());   // v   iarg4
  117   reg_def Z_R5_H (SOC, SOC, Op_RegI, 99, Z_R5-&gt;as_VMReg()-&gt;next());
  118   reg_def Z_R6   (SOC, SOE, Op_RegI,  6, Z_R6-&gt;as_VMReg());   // v   iarg5
  119   reg_def Z_R6_H (SOC, SOE, Op_RegI, 99, Z_R6-&gt;as_VMReg()-&gt;next());
  120   reg_def Z_R7   (SOC, SOE, Op_RegI,  7, Z_R7-&gt;as_VMReg());
  121   reg_def Z_R7_H (SOC, SOE, Op_RegI, 99, Z_R7-&gt;as_VMReg()-&gt;next());
  122   reg_def Z_R8   (SOC, SOE, Op_RegI,  8, Z_R8-&gt;as_VMReg());
  123   reg_def Z_R8_H (SOC, SOE, Op_RegI, 99, Z_R8-&gt;as_VMReg()-&gt;next());
  124   reg_def Z_R9   (SOC, SOE, Op_RegI,  9, Z_R9-&gt;as_VMReg());
  125   reg_def Z_R9_H (SOC, SOE, Op_RegI, 99, Z_R9-&gt;as_VMReg()-&gt;next());
  126   reg_def Z_R10  (SOC, SOE, Op_RegI, 10, Z_R10-&gt;as_VMReg());
  127   reg_def Z_R10_H(SOC, SOE, Op_RegI, 99, Z_R10-&gt;as_VMReg()-&gt;next());
  128   reg_def Z_R11  (SOC, SOE, Op_RegI, 11, Z_R11-&gt;as_VMReg());
  129   reg_def Z_R11_H(SOC, SOE, Op_RegI, 99, Z_R11-&gt;as_VMReg()-&gt;next());
  130   reg_def Z_R12  (SOC, SOE, Op_RegI, 12, Z_R12-&gt;as_VMReg());
  131   reg_def Z_R12_H(SOC, SOE, Op_RegI, 99, Z_R12-&gt;as_VMReg()-&gt;next());
  132   reg_def Z_R13  (SOC, SOE, Op_RegI, 13, Z_R13-&gt;as_VMReg());
  133   reg_def Z_R13_H(SOC, SOE, Op_RegI, 99, Z_R13-&gt;as_VMReg()-&gt;next());
  134   reg_def Z_R14  (NS,  NS,  Op_RegI, 14, Z_R14-&gt;as_VMReg());   // s  return_pc
  135   reg_def Z_R14_H(NS,  NS,  Op_RegI, 99, Z_R14-&gt;as_VMReg()-&gt;next());
  136   reg_def Z_R15  (NS,  NS,  Op_RegI, 15, Z_R15-&gt;as_VMReg());   // s  SP
  137   reg_def Z_R15_H(NS,  NS,  Op_RegI, 99, Z_R15-&gt;as_VMReg()-&gt;next());
  138 
  139   // Float/Double Registers
  140 
  141   // The rules of ADL require that double registers be defined in pairs.
  142   // Each pair must be two 32-bit values, but not necessarily a pair of
  143   // single float registers. In each pair, ADLC-assigned register numbers
  144   // must be adjacent, with the lower number even. Finally, when the
  145   // CPU stores such a register pair to memory, the word associated with
  146   // the lower ADLC-assigned number must be stored to the lower address.
  147 
  148   // z/Architecture has 16 64-bit floating-point registers. Each can store a single
  149   // or double precision floating-point value.
  150 
  151   // types: v = volatile, nv = non-volatile, s = system
  152   reg_def Z_F0   (SOC, SOC, Op_RegF,  0, Z_F0-&gt;as_VMReg());   // v   farg1 &amp; fret
  153   reg_def Z_F0_H (SOC, SOC, Op_RegF, 99, Z_F0-&gt;as_VMReg()-&gt;next());
  154   reg_def Z_F1   (SOC, SOC, Op_RegF,  1, Z_F1-&gt;as_VMReg());
  155   reg_def Z_F1_H (SOC, SOC, Op_RegF, 99, Z_F1-&gt;as_VMReg()-&gt;next());
  156   reg_def Z_F2   (SOC, SOC, Op_RegF,  2, Z_F2-&gt;as_VMReg());   // v   farg2
  157   reg_def Z_F2_H (SOC, SOC, Op_RegF, 99, Z_F2-&gt;as_VMReg()-&gt;next());
  158   reg_def Z_F3   (SOC, SOC, Op_RegF,  3, Z_F3-&gt;as_VMReg());
  159   reg_def Z_F3_H (SOC, SOC, Op_RegF, 99, Z_F3-&gt;as_VMReg()-&gt;next());
  160   reg_def Z_F4   (SOC, SOC, Op_RegF,  4, Z_F4-&gt;as_VMReg());   // v   farg3
  161   reg_def Z_F4_H (SOC, SOC, Op_RegF, 99, Z_F4-&gt;as_VMReg()-&gt;next());
  162   reg_def Z_F5   (SOC, SOC, Op_RegF,  5, Z_F5-&gt;as_VMReg());
  163   reg_def Z_F5_H (SOC, SOC, Op_RegF, 99, Z_F5-&gt;as_VMReg()-&gt;next());
  164   reg_def Z_F6   (SOC, SOC, Op_RegF,  6, Z_F6-&gt;as_VMReg());
  165   reg_def Z_F6_H (SOC, SOC, Op_RegF, 99, Z_F6-&gt;as_VMReg()-&gt;next());
  166   reg_def Z_F7   (SOC, SOC, Op_RegF,  7, Z_F7-&gt;as_VMReg());
  167   reg_def Z_F7_H (SOC, SOC, Op_RegF, 99, Z_F7-&gt;as_VMReg()-&gt;next());
  168   reg_def Z_F8   (SOC, SOE, Op_RegF,  8, Z_F8-&gt;as_VMReg());
  169   reg_def Z_F8_H (SOC, SOE, Op_RegF, 99, Z_F8-&gt;as_VMReg()-&gt;next());
  170   reg_def Z_F9   (SOC, SOE, Op_RegF,  9, Z_F9-&gt;as_VMReg());
  171   reg_def Z_F9_H (SOC, SOE, Op_RegF, 99, Z_F9-&gt;as_VMReg()-&gt;next());
  172   reg_def Z_F10  (SOC, SOE, Op_RegF, 10, Z_F10-&gt;as_VMReg());
  173   reg_def Z_F10_H(SOC, SOE, Op_RegF, 99, Z_F10-&gt;as_VMReg()-&gt;next());
  174   reg_def Z_F11  (SOC, SOE, Op_RegF, 11, Z_F11-&gt;as_VMReg());
  175   reg_def Z_F11_H(SOC, SOE, Op_RegF, 99, Z_F11-&gt;as_VMReg()-&gt;next());
  176   reg_def Z_F12  (SOC, SOE, Op_RegF, 12, Z_F12-&gt;as_VMReg());
  177   reg_def Z_F12_H(SOC, SOE, Op_RegF, 99, Z_F12-&gt;as_VMReg()-&gt;next());
  178   reg_def Z_F13  (SOC, SOE, Op_RegF, 13, Z_F13-&gt;as_VMReg());
  179   reg_def Z_F13_H(SOC, SOE, Op_RegF, 99, Z_F13-&gt;as_VMReg()-&gt;next());
  180   reg_def Z_F14  (SOC, SOE, Op_RegF, 14, Z_F14-&gt;as_VMReg());
  181   reg_def Z_F14_H(SOC, SOE, Op_RegF, 99, Z_F14-&gt;as_VMReg()-&gt;next());
  182   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15-&gt;as_VMReg());
  183   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15-&gt;as_VMReg()-&gt;next());
  184 
  185 
  186   // Special Registers
  187 
  188   // Condition Codes Flag Registers
  189 
  190   // z/Architecture has the PSW (program status word) that contains
  191   // (among other information) the condition code. We treat this
  192   // part of the PSW as a condition register CR. It consists of 4
  193   // bits. Floating point instructions influence the same condition register CR.
  194 
  195   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR-&gt;as_VMReg());   // volatile
  196 
  197 
  198 // Specify priority of register selection within phases of register
  199 // allocation. Highest priority is first. A useful heuristic is to
  200 // give registers a low priority when they are required by machine
  201 // instructions, and choose no-save registers before save-on-call, and
  202 // save-on-call before save-on-entry. Registers which participate in
  203 // fix calling sequences should come last. Registers which are used
  204 // as pairs must fall on an even boundary.
  205 
  206 // It&#39;s worth about 1% on SPEC geomean to get this right.
  207 
  208 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  209 // in adGlobals_s390.hpp which defines the &lt;register&gt;_num values, e.g.
  210 // Z_R3_num. Therefore, Z_R3_num may not be (and in reality is not)
  211 // the same as Z_R3-&gt;encoding()! Furthermore, we cannot make any
  212 // assumptions on ordering, e.g. Z_R3_num may be less than Z_R2_num.
  213 // Additionally, the function
  214 //   static enum RC rc_class(OptoReg::Name reg)
  215 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  216 // and its current implementation relies on chunk0 and chunk1 having a
  217 // size of 64 each.
  218 
  219 alloc_class chunk0(
  220   // chunk0 contains *all* 32 integer registers halves.
  221 
  222   // potential SOE regs
  223   Z_R13,Z_R13_H,
  224   Z_R12,Z_R12_H,
  225   Z_R11,Z_R11_H,
  226   Z_R10,Z_R10_H,
  227 
  228   Z_R9,Z_R9_H,
  229   Z_R8,Z_R8_H,
  230   Z_R7,Z_R7_H,
  231 
  232   Z_R1,Z_R1_H,
  233   Z_R0,Z_R0_H,
  234 
  235   // argument registers
  236   Z_R6,Z_R6_H,
  237   Z_R5,Z_R5_H,
  238   Z_R4,Z_R4_H,
  239   Z_R3,Z_R3_H,
  240   Z_R2,Z_R2_H,
  241 
  242   // special registers
  243   Z_R14,Z_R14_H,
  244   Z_R15,Z_R15_H
  245 );
  246 
  247 alloc_class chunk1(
  248   // Chunk1 contains *all* 64 floating-point registers halves.
  249 
  250   Z_F15,Z_F15_H,
  251   Z_F14,Z_F14_H,
  252   Z_F13,Z_F13_H,
  253   Z_F12,Z_F12_H,
  254   Z_F11,Z_F11_H,
  255   Z_F10,Z_F10_H,
  256   Z_F9,Z_F9_H,
  257   Z_F8,Z_F8_H,
  258   // scratch register
  259   Z_F7,Z_F7_H,
  260   Z_F5,Z_F5_H,
  261   Z_F3,Z_F3_H,
  262   Z_F1,Z_F1_H,
  263   // argument registers
  264   Z_F6,Z_F6_H,
  265   Z_F4,Z_F4_H,
  266   Z_F2,Z_F2_H,
  267   Z_F0,Z_F0_H
  268 );
  269 
  270 alloc_class chunk2(
  271   Z_CR
  272 );
  273 
  274 
  275 //-------Architecture Description Register Classes-----------------------
  276 
  277 // Several register classes are automatically defined based upon
  278 // information in this architecture description.
  279 
  280 // 1) reg_class inline_cache_reg           (as defined in frame section)
  281 // 2) reg_class compiler_method_oop_reg    (as defined in frame section)
  282 // 2) reg_class interpreter_method_oop_reg (as defined in frame section)
  283 // 3) reg_class stack_slots(/* one chunk of stack-based &quot;registers&quot; */)
  284 
  285 // Integer Register Classes
  286 reg_class z_int_reg(
  287 /*Z_R0*/              // R0
  288 /*Z_R1*/
  289   Z_R2,
  290   Z_R3,
  291   Z_R4,
  292   Z_R5,
  293   Z_R6,
  294   Z_R7,
  295 /*Z_R8,*/             // Z_thread
  296   Z_R9,
  297   Z_R10,
  298   Z_R11,
  299   Z_R12,
  300   Z_R13
  301 /*Z_R14*/             // return_pc
  302 /*Z_R15*/             // SP
  303 );
  304 
  305 reg_class z_no_odd_int_reg(
  306 /*Z_R0*/              // R0
  307 /*Z_R1*/
  308   Z_R2,
  309   Z_R3,
  310   Z_R4,
  311 /*Z_R5,*/             // odd part of fix register pair
  312   Z_R6,
  313   Z_R7,
  314 /*Z_R8,*/             // Z_thread
  315   Z_R9,
  316   Z_R10,
  317   Z_R11,
  318   Z_R12,
  319   Z_R13
  320 /*Z_R14*/             // return_pc
  321 /*Z_R15*/             // SP
  322 );
  323 
  324 reg_class z_no_arg_int_reg(
  325 /*Z_R0*/              // R0
  326 /*Z_R1*/              // scratch
  327 /*Z_R2*/
  328 /*Z_R3*/
  329 /*Z_R4*/
  330 /*Z_R5*/
  331 /*Z_R6*/
  332   Z_R7,
  333 /*Z_R8*/              // Z_thread
  334   Z_R9,
  335   Z_R10,
  336   Z_R11,
  337   Z_R12,
  338   Z_R13
  339 /*Z_R14*/             // return_pc
  340 /*Z_R15*/             // SP
  341 );
  342 
  343 reg_class z_rarg1_int_reg(Z_R2);
  344 reg_class z_rarg2_int_reg(Z_R3);
  345 reg_class z_rarg3_int_reg(Z_R4);
  346 reg_class z_rarg4_int_reg(Z_R5);
  347 reg_class z_rarg5_int_reg(Z_R6);
  348 
  349 // Pointer Register Classes
  350 
  351 // 64-bit build means 64-bit pointers means hi/lo pairs.
  352 
  353 reg_class z_rarg5_ptrN_reg(Z_R6);
  354 
  355 reg_class z_rarg1_ptr_reg(Z_R2_H,Z_R2);
  356 reg_class z_rarg2_ptr_reg(Z_R3_H,Z_R3);
  357 reg_class z_rarg3_ptr_reg(Z_R4_H,Z_R4);
  358 reg_class z_rarg4_ptr_reg(Z_R5_H,Z_R5);
  359 reg_class z_rarg5_ptr_reg(Z_R6_H,Z_R6);
  360 reg_class z_thread_ptr_reg(Z_R8_H,Z_R8);
  361 
  362 reg_class z_ptr_reg(
  363 /*Z_R0_H,Z_R0*/     // R0
  364 /*Z_R1_H,Z_R1*/
  365   Z_R2_H,Z_R2,
  366   Z_R3_H,Z_R3,
  367   Z_R4_H,Z_R4,
  368   Z_R5_H,Z_R5,
  369   Z_R6_H,Z_R6,
  370   Z_R7_H,Z_R7,
  371 /*Z_R8_H,Z_R8,*/    // Z_thread
  372   Z_R9_H,Z_R9,
  373   Z_R10_H,Z_R10,
  374   Z_R11_H,Z_R11,
  375   Z_R12_H,Z_R12,
  376   Z_R13_H,Z_R13
  377 /*Z_R14_H,Z_R14*/   // return_pc
  378 /*Z_R15_H,Z_R15*/   // SP
  379 );
  380 
  381 reg_class z_lock_ptr_reg(
  382 /*Z_R0_H,Z_R0*/     // R0
  383 /*Z_R1_H,Z_R1*/
  384   Z_R2_H,Z_R2,
  385   Z_R3_H,Z_R3,
  386   Z_R4_H,Z_R4,
  387 /*Z_R5_H,Z_R5,*/
  388 /*Z_R6_H,Z_R6,*/
  389   Z_R7_H,Z_R7,
  390 /*Z_R8_H,Z_R8,*/    // Z_thread
  391   Z_R9_H,Z_R9,
  392   Z_R10_H,Z_R10,
  393   Z_R11_H,Z_R11,
  394   Z_R12_H,Z_R12,
  395   Z_R13_H,Z_R13
  396 /*Z_R14_H,Z_R14*/   // return_pc
  397 /*Z_R15_H,Z_R15*/   // SP
  398 );
  399 
  400 reg_class z_no_arg_ptr_reg(
  401 /*Z_R0_H,Z_R0*/        // R0
  402 /*Z_R1_H,Z_R1*/        // scratch
  403 /*Z_R2_H,Z_R2*/
  404 /*Z_R3_H,Z_R3*/
  405 /*Z_R4_H,Z_R4*/
  406 /*Z_R5_H,Z_R5*/
  407 /*Z_R6_H,Z_R6*/
  408   Z_R7_H, Z_R7,
  409 /*Z_R8_H,Z_R8*/        // Z_thread
  410   Z_R9_H,Z_R9,
  411   Z_R10_H,Z_R10,
  412   Z_R11_H,Z_R11,
  413   Z_R12_H,Z_R12,
  414   Z_R13_H,Z_R13
  415 /*Z_R14_H,Z_R14*/      // return_pc
  416 /*Z_R15_H,Z_R15*/      // SP
  417 );
  418 
  419 // Special class for storeP instructions, which can store SP or RPC to
  420 // TLS. (Note: Do not generalize this to &quot;any_reg&quot;. If you add
  421 // another register, such as FP, to this mask, the allocator may try
  422 // to put a temp in it.)
  423 // Register class for memory access base registers,
  424 // This class is a superset of z_ptr_reg including Z_thread.
  425 reg_class z_memory_ptr_reg(
  426 /*Z_R0_H,Z_R0*/     // R0
  427 /*Z_R1_H,Z_R1*/
  428   Z_R2_H,Z_R2,
  429   Z_R3_H,Z_R3,
  430   Z_R4_H,Z_R4,
  431   Z_R5_H,Z_R5,
  432   Z_R6_H,Z_R6,
  433   Z_R7_H,Z_R7,
  434   Z_R8_H,Z_R8,      // Z_thread
  435   Z_R9_H,Z_R9,
  436   Z_R10_H,Z_R10,
  437   Z_R11_H,Z_R11,
  438   Z_R12_H,Z_R12,
  439   Z_R13_H,Z_R13
  440 /*Z_R14_H,Z_R14*/   // return_pc
  441 /*Z_R15_H,Z_R15*/   // SP
  442 );
  443 
  444 // Other special pointer regs.
  445 reg_class z_r1_regP(Z_R1_H,Z_R1);
  446 reg_class z_r9_regP(Z_R9_H,Z_R9);
  447 
  448 
  449 // Long Register Classes
  450 
  451 reg_class z_rarg1_long_reg(Z_R2_H,Z_R2);
  452 reg_class z_rarg2_long_reg(Z_R3_H,Z_R3);
  453 reg_class z_rarg3_long_reg(Z_R4_H,Z_R4);
  454 reg_class z_rarg4_long_reg(Z_R5_H,Z_R5);
  455 reg_class z_rarg5_long_reg(Z_R6_H,Z_R6);
  456 
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
  477 
  478 // Special Class for Condition Code Flags Register
  479 
  480 reg_class z_condition_reg(
  481   Z_CR
  482 );
  483 
  484 // Scratch register for late profiling. Callee saved.
  485 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  486 
  487 
  488 // Float Register Classes
  489 
  490 reg_class z_flt_reg(
  491   Z_F0,
  492 /*Z_F1,*/ // scratch
  493   Z_F2,
  494   Z_F3,
  495   Z_F4,
  496   Z_F5,
  497   Z_F6,
  498   Z_F7,
  499   Z_F8,
  500   Z_F9,
  501   Z_F10,
  502   Z_F11,
  503   Z_F12,
  504   Z_F13,
  505   Z_F14,
  506   Z_F15
  507 );
  508 reg_class z_rscratch1_flt_reg(Z_F1);
  509 
  510 // Double precision float registers have virtual `high halves&#39; that
  511 // are needed by the allocator.
  512 reg_class z_dbl_reg(
  513   Z_F0,Z_F0_H,
  514 /*Z_F1,Z_F1_H,*/ // scratch
  515   Z_F2,Z_F2_H,
  516   Z_F3,Z_F3_H,
  517   Z_F4,Z_F4_H,
  518   Z_F5,Z_F5_H,
  519   Z_F6,Z_F6_H,
  520   Z_F7,Z_F7_H,
  521   Z_F8,Z_F8_H,
  522   Z_F9,Z_F9_H,
  523   Z_F10,Z_F10_H,
  524   Z_F11,Z_F11_H,
  525   Z_F12,Z_F12_H,
  526   Z_F13,Z_F13_H,
  527   Z_F14,Z_F14_H,
  528   Z_F15,Z_F15_H
  529 );
  530 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
  531 
  532 %}
  533 
  534 //----------DEFINITION BLOCK---------------------------------------------------
  535 // Define &#39;name --&gt; value&#39; mappings to inform the ADLC of an integer valued name.
  536 // Current support includes integer values in the range [0, 0x7FFFFFFF].
  537 // Format:
  538 //        int_def  &lt;name&gt;         (&lt;int_value&gt;, &lt;expression&gt;);
  539 // Generated Code in ad_&lt;arch&gt;.hpp
  540 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  541 //        // value == &lt;int_value&gt;
  542 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  543 //        assert(&lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  544 //
  545 definitions %{
  546   // The default cost (of an ALU instruction).
  547   int_def DEFAULT_COST      (   100,     100);
  548   int_def DEFAULT_COST_LOW  (    80,      80);
  549   int_def DEFAULT_COST_HIGH (   120,     120);
  550   int_def HUGE_COST         (1000000, 1000000);
  551 
  552   // Put an advantage on REG_MEM vs. MEM+REG_REG operations.
  553   int_def ALU_REG_COST      (   100, DEFAULT_COST);
  554   int_def ALU_MEMORY_COST   (   150,          150);
  555 
  556   // Memory refs are twice as expensive as run-of-the-mill.
  557   int_def MEMORY_REF_COST_HI (   220, 2 * DEFAULT_COST+20);
  558   int_def MEMORY_REF_COST    (   200, 2 * DEFAULT_COST);
  559   int_def MEMORY_REF_COST_LO (   180, 2 * DEFAULT_COST-20);
  560 
  561   // Branches are even more expensive.
  562   int_def BRANCH_COST       (   300, DEFAULT_COST * 3);
  563   int_def CALL_COST         (   300, DEFAULT_COST * 3);
  564 %}
  565 
  566 source %{
  567 
  568 #ifdef PRODUCT
  569 #define BLOCK_COMMENT(str)
  570 #define BIND(label)        __ bind(label)
  571 #else
  572 #define BLOCK_COMMENT(str) __ block_comment(str)
  573 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  574 #endif
  575 
  576 #define __ _masm.
  577 
  578 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  579 #define Z_DISP3_SIZE 6
  580 
  581 // Tertiary op of a LoadP or StoreP encoding.
  582 #define REGP_OP true
  583 
  584 // Given a register encoding, produce an Integer Register object.
  585 static Register reg_to_register_object(int register_encoding);
  586 
  587 // ****************************************************************************
  588 
  589 // REQUIRED FUNCTIONALITY
  590 
  591 // !!!!! Special hack to get all type of calls to specify the byte offset
  592 //       from the start of the call to the point where the return address
  593 //       will point.
  594 
  595 int MachCallStaticJavaNode::ret_addr_offset() {
  596   if (_method) {
  597     return 8;
  598   } else {
  599     return MacroAssembler::call_far_patchable_ret_addr_offset();
  600   }
  601 }
  602 
  603 int MachCallDynamicJavaNode::ret_addr_offset() {
  604   // Consider size of receiver type profiling (C2 tiers).
  605   int profile_receiver_type_size = 0;
  606 
  607   int vtable_index = this-&gt;_vtable_index;
  608   if (vtable_index == -4) {
  609     return 14 + profile_receiver_type_size;
  610   } else {
  611     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  612     return 36 + profile_receiver_type_size;
  613   }
  614 }
  615 
  616 int MachCallRuntimeNode::ret_addr_offset() {
  617   return 12 + MacroAssembler::call_far_patchable_ret_addr_offset();
  618 }
  619 
  620 // Compute padding required for nodes which need alignment
  621 //
  622 // The addresses of the call instructions needs to be 4-byte aligned to
  623 // ensure that they don&#39;t span a cache line so that they are atomically patchable.
  624 // The actual calls get emitted at different offsets within the node emitters.
  625 // ins_alignment needs to be set to 2 which means that up to 1 nop may get inserted.
  626 
  627 int CallStaticJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  628   return (0 - current_offset) &amp; 2;
  629 }
  630 
  631 int CallDynamicJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  632   return (6 - current_offset) &amp; 2;
  633 }
  634 
  635 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  636   return (12 - current_offset) &amp; 2;
  637 }
  638 
  639 int CallLeafDirectNode::compute_padding(int current_offset) const {
  640   return (12 - current_offset) &amp; 2;
  641 }
  642 
  643 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  644   return (12 - current_offset) &amp; 2;
  645 }
  646 
  647 // Indicate if the safepoint node needs the polling page as an input.
  648 // Since z/Architecture does not have absolute addressing, it does.
  649 bool SafePointNode::needs_polling_address_input() {
  650   return true;
  651 }
  652 
  653 void emit_nop(CodeBuffer &amp;cbuf) {
  654   MacroAssembler _masm(&amp;cbuf);
  655   __ z_nop();
  656 }
  657 
  658 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  659 void emit_break(CodeBuffer &amp;cbuf) {
  660   MacroAssembler _masm(&amp;cbuf);
  661   __ z_illtrap();
  662 }
  663 
  664 #if !defined(PRODUCT)
  665 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  666   os-&gt;print(&quot;TA&quot;);
  667 }
  668 #endif
  669 
  670 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  671   emit_break(cbuf);
  672 }
  673 
  674 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  675   return MachNode::size(ra_);
  676 }
  677 
  678 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  679   // 32bit instructions may become sign extended.
  680   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  681   assert(value &lt; (1L &lt;&lt; 16), &quot;instruction too large&quot;);
  682   *((unsigned short*)(cbuf.insts_end())) = (unsigned short)value;
  683   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned short));
  684 }
  685 
  686 static inline void z_emit32(CodeBuffer &amp;cbuf, long value) {
  687   // 32bit instructions may become sign extended.
  688   assert(value &lt; (1L &lt;&lt; 32), &quot;instruction too large&quot;);
  689   *((unsigned int*)(cbuf.insts_end())) = (unsigned int)value;
  690   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned int));
  691 }
  692 
  693 static inline void z_emit48(CodeBuffer &amp;cbuf, long value) {
  694   // 32bit instructions may become sign extended.
  695   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  696   assert(value &lt; (1L &lt;&lt; 48), &quot;instruction too large&quot;);
  697   value = value&lt;&lt;16;
  698   memcpy(cbuf.insts_end(), (unsigned char*)&amp;value, 6);
  699   cbuf.set_insts_end(cbuf.insts_end() + 6);
  700 }
  701 
  702 static inline unsigned int z_emit_inst(CodeBuffer &amp;cbuf, long value) {
  703   if (value &lt; 0) {
  704     // There obviously has been an unintended sign extension (int-&gt;long). Revert it.
  705     value = (long)((unsigned long)((unsigned int)value));
  706   }
  707 
  708   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  709     z_emit16(cbuf, value);
  710     return 2;
  711   }
  712 
  713   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  714     z_emit32(cbuf, value);
  715     return 4;
  716   }
  717 
  718   // 6-byte instruction, probably unaligned store.
  719   z_emit48(cbuf, value);
  720   return 6;
  721 }
  722 
  723 // Check effective address (at runtime) for required alignment.
  724 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
  725   MacroAssembler _masm(&amp;cbuf);
  726 
  727   __ z_lay(Z_R0, disp, index, base);
  728   __ z_nill(Z_R0, alignment-1);
  729   __ z_brc(Assembler::bcondEqual, +3);
  730   __ z_illtrap();
  731 }
  732 
  733 int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,
  734                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  735   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  736   address old_mark = __ inst_mark();
  737   unsigned int start_off = __ offset();
  738 
  739   if (is_native_call) {
  740     ShouldNotReachHere();
  741   }
  742 
  743   if (rtype == relocInfo::runtime_call_w_cp_type) {
  744     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  745     address call_addr = __ call_c_opt((address)entry_point);
  746     if (call_addr == NULL) {
  747       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  748       return -1;
  749     }
  750   } else {
  751     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  752            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  753     __ relocate(rtype);
  754     // BRASL must be prepended with a nop to identify it in the instruction stream.
  755     __ z_nop();
  756     __ z_brasl(Z_R14, (address)entry_point);
  757   }
  758 
  759   unsigned int ret_off = __ offset();
  760 
  761   return (ret_off - start_off);
  762 }
  763 
  764 static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {
  765   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  766   address old_mark = __ inst_mark();
  767   unsigned int start_off = __ offset();
  768 
  769   relocInfo::relocType rtype = rspec.type();
  770   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  771          &quot;unexpected rtype&quot;);
  772 
  773   __ relocate(rspec);
  774   __ z_nop();
  775   __ z_brasl(Z_R14, (address)entry_point);
  776 
  777   unsigned int ret_off = __ offset();
  778 
  779   return (ret_off - start_off);
  780 }
  781 
  782 //=============================================================================
  783 
  784 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
  785 int Compile::ConstantTable::calculate_table_base_offset() const {
  786   return 0;  // absolute addressing, no offset
  787 }
  788 
  789 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  790 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  791   ShouldNotReachHere();
  792 }
  793 
  794 // Even with PC-relative TOC addressing, we still need this node.
  795 // Float loads/stores do not support PC-relative addresses.
  796 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  797   MacroAssembler _masm(&amp;cbuf);
  798   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  799   __ load_toc(Rtoc);
  800 }
  801 
  802 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  803   // PCrelative TOC access.
  804   return 6;   // sizeof(LARL)
  805 }
  806 
  807 #if !defined(PRODUCT)
  808 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  809   Register r = as_Register(ra_-&gt;get_encode(this));
  810   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  811 }
  812 #endif
  813 
  814 //=============================================================================
  815 
  816 #if !defined(PRODUCT)
  817 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  818   Compile* C = ra_-&gt;C;
  819   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  820   st-&gt;print(&quot;\t&quot;);
  821   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  822     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  823   }
  824 
  825   if (VerifyThread) {
  826     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  827     st-&gt;print(&quot;\t&quot;);
  828   }
  829 
  830   long framesize = C-&gt;frame_size_in_bytes();
  831   int bangsize   = C-&gt;bang_size_in_bytes();
  832 
  833   // Calls to C2R adapters often do not accept exceptional returns.
  834   // We require that their callers must bang for them. But be
  835   // careful, because some VM calls (such as call site linkage) can
  836   // use several kilobytes of stack. But the stack safety zone should
  837   // account for that. See bugs 4446381, 4468289, 4497237.
  838   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  839     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  840   }
  841   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  842   st-&gt;print(&quot;\t&quot;);
  843 }
  844 #endif
  845 
  846 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  847   Compile* C = ra_-&gt;C;
  848   MacroAssembler _masm(&amp;cbuf);
  849 
  850   __ verify_thread();
  851 
  852   size_t framesize = C-&gt;frame_size_in_bytes();
  853   size_t bangsize  = C-&gt;bang_size_in_bytes();
  854 
  855   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  856 
  857   // Calls to C2R adapters often do not accept exceptional returns.
  858   // We require that their callers must bang for them. But be
  859   // careful, because some VM calls (such as call site linkage) can
  860   // use several kilobytes of stack. But the stack safety zone should
  861   // account for that. See bugs 4446381, 4468289, 4497237.
  862   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  863     __ generate_stack_overflow_check(bangsize);
  864   }
  865 
  866   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  867   __ save_return_pc();
  868 
  869   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  870   // &#39;out_preserve_stack_slots&#39; declaration.
  871   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  872 
  873   if (C-&gt;has_mach_constant_base_node()) {
  874     // NOTE: We set the table base offset here because users might be
  875     // emitted before MachConstantBaseNode.
  876     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  877     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  878   }
  879 }
  880 
  881 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  882   // Variable size. Determine dynamically.
  883   return MachNode::size(ra_);
  884 }
  885 
  886 int MachPrologNode::reloc() const {
  887   // Return number of relocatable values contained in this instruction.
  888   return 1; // One reloc entry for load_const(toc).
  889 }
  890 
  891 //=============================================================================
  892 
  893 #if !defined(PRODUCT)
  894 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  895   os-&gt;print_cr(&quot;epilog&quot;);
  896   os-&gt;print(&quot;\t&quot;);
  897   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  898     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  899     os-&gt;print(&quot;\t&quot;);
  900   }
  901 }
  902 #endif
  903 
  904 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  905   MacroAssembler _masm(&amp;cbuf);
  906   Compile* C = ra_-&gt;C;
  907   __ verify_thread();
  908 
  909   // If this does safepoint polling, then do it here.
  910   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  911 
  912   // Pop frame, restore return_pc, and all stuff needed by interpreter.
  913   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);
  914   __ pop_frame_restore_retPC(frame_size_in_bytes);
  915 
  916   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  917     __ reserved_stack_check(Z_R14);
  918   }
  919 
  920   // Touch the polling page.
  921   if (need_polling) {
  922     if (SafepointMechanism::uses_thread_local_poll()) {
  923       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  924     } else {
  925       AddressLiteral pp(os::get_polling_page());
  926       __ load_const_optimized(Z_R1_scratch, pp);
  927     }
  928     // We need to mark the code position where the load from the safepoint
  929     // polling page was emitted as relocInfo::poll_return_type here.
  930     __ relocate(relocInfo::poll_return_type);
  931     __ load_from_polling_page(Z_R1_scratch);
  932   }
  933 }
  934 
  935 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  936   // Variable size. determine dynamically.
  937   return MachNode::size(ra_);
  938 }
  939 
  940 int MachEpilogNode::reloc() const {
  941   // Return number of relocatable values contained in this instruction.
  942   return 1; // One for load_from_polling_page.
  943 }
  944 
  945 const Pipeline * MachEpilogNode::pipeline() const {
  946   return MachNode::pipeline_class();
  947 }
  948 
  949 int MachEpilogNode::safepoint_offset() const {
  950   assert(do_polling(), &quot;no return for this epilog node&quot;);
  951   return 0;
  952 }
  953 
  954 //=============================================================================
  955 
  956 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  957 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  958 
  959 static enum RC rc_class(OptoReg::Name reg) {
  960   // Return the register class for the given register. The given register
  961   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  962   // enumeration in adGlobals_s390.hpp.
  963 
  964   if (reg == OptoReg::Bad) {
  965     return rc_bad;
  966   }
  967 
  968   // We have 32 integer register halves, starting at index 0.
  969   if (reg &lt; 32) {
  970     return rc_int;
  971   }
  972 
  973   // We have 32 floating-point register halves, starting at index 32.
  974   if (reg &lt; 32+32) {
  975     return rc_float;
  976   }
  977 
  978   // Between float regs &amp; stack are the flags regs.
  979   assert(reg &gt;= OptoReg::stack0(), &quot;blow up if spilling flags&quot;);
  980   return rc_stack;
  981 }
  982 
  983 // Returns size as obtained from z_emit_instr.
  984 static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,
  985                                    int reg, int offset, bool do_print, outputStream *os) {
  986 
  987   if (cbuf) {
  988     if (opcode &gt; (1L&lt;&lt;32)) {
  989       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
  990                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
  991     } else {
  992       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
  993                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
  994     }
  995   }
  996 
  997 #if !defined(PRODUCT)
  998   if (do_print) {
  999     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1000   }
 1001 #endif
 1002   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1003 }
 1004 
 1005 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1006   if (cbuf) {
 1007     MacroAssembler _masm(cbuf);
 1008     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1009   }
 1010 
 1011 #if !defined(PRODUCT)
 1012   else if (do_print) {
 1013     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1014   }
 1015 #endif
 1016 
 1017   return 6;
 1018 }
 1019 
 1020 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1021   // Get registers to move.
 1022   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1023   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1024   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1025   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1026 
 1027   enum RC src_hi_rc = rc_class(src_hi);
 1028   enum RC src_lo_rc = rc_class(src_lo);
 1029   enum RC dst_hi_rc = rc_class(dst_hi);
 1030   enum RC dst_lo_rc = rc_class(dst_lo);
 1031 
 1032   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1033   bool is64 = (src_hi_rc != rc_bad);
 1034   assert(!is64 ||
 1035          ((src_lo&amp;1) == 0 &amp;&amp; src_lo+1 == src_hi &amp;&amp; (dst_lo&amp;1) == 0 &amp;&amp; dst_lo+1 == dst_hi),
 1036          &quot;expected aligned-adjacent pairs&quot;);
 1037 
 1038   // Generate spill code!
 1039 
 1040   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi) {
 1041     return 0;            // Self copy, no move.
 1042   }
 1043 
 1044   int  src_offset = ra_-&gt;reg2offset(src_lo);
 1045   int  dst_offset = ra_-&gt;reg2offset(dst_lo);
 1046   bool print = !do_size;
 1047   bool src12 = Immediate::is_uimm12(src_offset);
 1048   bool dst12 = Immediate::is_uimm12(dst_offset);
 1049 
 1050   const char   *mnemo = NULL;
 1051   unsigned long opc = 0;
 1052 
 1053   // Memory-&gt;Memory Spill. Use Z_R0 to hold the value.
 1054   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1055 
 1056     assert(!is64 || (src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack),
 1057            &quot;expected same type of move for high parts&quot;);
 1058 
 1059     if (src12 &amp;&amp; dst12) {
 1060       return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);
 1061     }
 1062 
 1063     int r0 = Z_R0_num;
 1064     if (is64) {
 1065       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1066              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1067     }
 1068 
 1069     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1070            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1071   }
 1072 
 1073   // Check for float-&gt;int copy. Requires a trip through memory.
 1074   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1075     Unimplemented();  // Unsafe, do not remove!
 1076   }
 1077 
 1078   // Check for integer reg-reg copy.
 1079   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1080     if (cbuf) {
 1081       MacroAssembler _masm(cbuf);
 1082       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1083       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1084       __ z_lgr(Rdst, Rsrc);
 1085       return 4;
 1086     }
 1087 #if !defined(PRODUCT)
 1088     // else
 1089     if (print) {
 1090       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1091     }
 1092 #endif
 1093     return 4;
 1094   }
 1095 
 1096   // Check for integer store.
 1097   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1098     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1099            &quot;expected same type of move for high parts&quot;);
 1100 
 1101     if (is64) {
 1102       return z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, src_lo, dst_offset, print, os);
 1103     }
 1104 
 1105     // else
 1106     mnemo = dst12 ? &quot;ST  &quot; : &quot;STY &quot;;
 1107     opc = dst12 ? ST_ZOPC : STY_ZOPC;
 1108 
 1109     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1110   }
 1111 
 1112   // Check for integer load
 1113   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1114   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1115 
 1116     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1117            &quot;expected same type of move for high parts&quot;);
 1118 
 1119     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1120     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1121 
 1122     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1123   }
 1124 
 1125   // Check for float reg-reg copy.
 1126   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1127     if (cbuf) {
 1128       MacroAssembler _masm(cbuf);
 1129       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1130       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1131       __ z_ldr(Rdst, Rsrc);
 1132       return 2;
 1133     }
 1134 #if !defined(PRODUCT)
 1135     // else
 1136     if (print) {
 1137       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1138     }
 1139 #endif
 1140     return 2;
 1141   }
 1142 
 1143   // Check for float store.
 1144   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1145     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1146            &quot;expected same type of move for high parts&quot;);
 1147 
 1148     if (is64) {
 1149       mnemo = dst12 ? &quot;STD  &quot; : &quot;STDY &quot;;
 1150       opc = dst12 ? STD_ZOPC : STDY_ZOPC;
 1151       return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1152     }
 1153     // else
 1154 
 1155     mnemo = dst12 ? &quot;STE  &quot; : &quot;STEY &quot;;
 1156     opc = dst12 ? STE_ZOPC : STEY_ZOPC;
 1157     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1158   }
 1159 
 1160   // Check for float load.
 1161   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1162     assert(!is64 || (dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack),
 1163            &quot;expected same type of move for high parts&quot;);
 1164 
 1165     if (is64) {
 1166       mnemo = src12 ? &quot;LD   &quot; : &quot;LDY  &quot;;
 1167       opc = src12 ? LD_ZOPC : LDY_ZOPC;
 1168       return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1169     }
 1170     // else
 1171 
 1172     mnemo = src12 ? &quot;LE   &quot; : &quot;LEY  &quot;;
 1173     opc = src12 ? LE_ZOPC : LEY_ZOPC;
 1174     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1175   }
 1176 
 1177   // --------------------------------------------------------------------
 1178   // Check for hi bits still needing moving. Only happens for misaligned
 1179   // arguments to native calls.
 1180   if (src_hi == dst_hi) {
 1181     return 0;               // Self copy, no move.
 1182   }
 1183 
 1184   assert(is64 &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1185   Unimplemented();  // Unsafe, do not remove!
 1186 
 1187   return 0; // never reached, but make the compiler shut up!
 1188 }
 1189 
 1190 #if !defined(PRODUCT)
 1191 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1192   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1193     implementation(NULL, ra_, false, os);
 1194   } else {
 1195     if (req() == 2 &amp;&amp; in(1)) {
 1196       os-&gt;print(&quot;N%d = N%d\n&quot;, _idx, in(1)-&gt;_idx);
 1197     } else {
 1198       const char *c = &quot;(&quot;;
 1199       os-&gt;print(&quot;N%d = &quot;, _idx);
 1200       for (uint i = 1; i &lt; req(); ++i) {
 1201         os-&gt;print(&quot;%sN%d&quot;, c, in(i)-&gt;_idx);
 1202         c = &quot;, &quot;;
 1203       }
 1204       os-&gt;print(&quot;)&quot;);
 1205     }
 1206   }
 1207 }
 1208 #endif
 1209 
 1210 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1211   implementation(&amp;cbuf, ra_, false, NULL);
 1212 }
 1213 
 1214 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1215   return implementation(NULL, ra_, true, NULL);
 1216 }
 1217 
 1218 //=============================================================================
 1219 
 1220 #if !defined(PRODUCT)
 1221 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1222   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1223 }
 1224 #endif
 1225 
 1226 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
 1227   MacroAssembler _masm(&amp;cbuf);
 1228 
 1229   int rem_space = 0;
 1230   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {
 1231     rem_space = cbuf.insts()-&gt;remaining();
 1232     if (rem_space &lt;= _count*2 + 8) {
 1233       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1234     }
 1235   }
 1236 
 1237   for (int i = 0; i &lt; _count; i++) {
 1238     __ z_nop();
 1239   }
 1240 
 1241   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {
 1242     if (rem_space &lt;= _count*2 + 8) {
 1243       int rem_space2 = cbuf.insts()-&gt;remaining();
 1244       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1245     }
 1246   }
 1247 }
 1248 
 1249 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1250    return 2 * _count;
 1251 }
 1252 
 1253 #if !defined(PRODUCT)
 1254 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1255   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1256   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1257     int reg = ra_-&gt;get_reg_first(this);
 1258     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1259   } else {
 1260     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1261   }
 1262 }
 1263 #endif
 1264 
 1265 // Take care of the size function, if you make changes here!
 1266 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1267   MacroAssembler _masm(&amp;cbuf);
 1268 
 1269   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1270   int reg = ra_-&gt;get_encode(this);
 1271   __ z_lay(as_Register(reg), offset, Z_SP);
 1272 }
 1273 
 1274 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1275   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1276   return 6;
 1277 }
 1278 
 1279  %} // end source section
 1280 
 1281 //----------SOURCE BLOCK-------------------------------------------------------
 1282 // This is a block of C++ code which provides values, functions, and
 1283 // definitions necessary in the rest of the architecture description
 1284 
 1285 source_hpp %{
 1286 
 1287 // Header information of the source block.
 1288 // Method declarations/definitions which are used outside
 1289 // the ad-scope can conveniently be defined here.
 1290 //
 1291 // To keep related declarations/definitions/uses close together,
 1292 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 1293 
 1294 //--------------------------------------------------------------
 1295 // Used for optimization in Compile::Shorten_branches
 1296 //--------------------------------------------------------------
 1297 
 1298 class CallStubImpl {
 1299  public:
 1300 
 1301   // call trampolines
 1302   // Size of call trampoline stub. For add&#39;l comments, see size_java_to_interp().
 1303   static uint size_call_trampoline() {
 1304     return 0; // no call trampolines on this platform
 1305   }
 1306 
 1307   // call trampolines
 1308   // Number of relocations needed by a call trampoline stub.
 1309   static uint reloc_call_trampoline() {
 1310     return 0; // No call trampolines on this platform.
 1311   }
 1312 };
 1313 
 1314 %} // end source_hpp section
 1315 
 1316 source %{
 1317 
 1318 #if !defined(PRODUCT)
 1319 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1320   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1321   os-&gt;print_cr(&quot;\tTA&quot;);
 1322   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1323   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1324   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1325   os-&gt;print_cr(&quot;\t...&quot;);
 1326   os-&gt;print_cr(&quot;\tTA&quot;);
 1327   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1328   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1329 }
 1330 #endif
 1331 
 1332 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1333   MacroAssembler _masm(&amp;cbuf);
 1334   const int ic_miss_offset = 2;
 1335 
 1336   // Inline_cache contains a klass.
 1337   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1338   // ARG1 is the receiver oop.
 1339   Register R2_receiver = Z_ARG1;
 1340   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1341   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1342   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1343 
 1344   // Null check of receiver.
 1345   // This is the null check of the receiver that actually should be
 1346   // done in the caller. It&#39;s here because in case of implicit null
 1347   // checks we get it for free.
 1348   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1349          &quot;second word in oop should not require explicit null check.&quot;);
 1350   if (!ImplicitNullChecks) {
 1351     Label valid;
 1352     if (VM_Version::has_CompareBranch()) {
 1353       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
 1354     } else {
 1355       __ z_ltgr(R2_receiver, R2_receiver);
 1356       __ z_bre(valid);
 1357     }
 1358     // The ic_miss_stub will handle the null pointer exception.
 1359     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1360     __ z_br(R1_ic_miss_stub_addr);
 1361     __ bind(valid);
 1362   }
 1363 
 1364   // Check whether this method is the proper implementation for the class of
 1365   // the receiver (ic miss check).
 1366   {
 1367     Label valid;
 1368     // Compare cached class against klass from receiver.
 1369     // This also does an implicit null check!
 1370     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1371     __ z_bre(valid);
 1372     // The inline cache points to the wrong method. Call the
 1373     // ic_miss_stub to find the proper method.
 1374     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1375     __ z_br(R1_ic_miss_stub_addr);
 1376     __ bind(valid);
 1377   }
 1378 
 1379 }
 1380 
 1381 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1382   // Determine size dynamically.
 1383   return MachNode::size(ra_);
 1384 }
 1385 
 1386 //=============================================================================
 1387 
 1388 %} // interrupt source section
 1389 
 1390 source_hpp %{ // Header information of the source block.
 1391 
 1392 class HandlerImpl {
 1393  public:
 1394 
 1395   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1396   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1397 
 1398   static uint size_exception_handler() {
 1399     return NativeJump::max_instruction_size();
 1400   }
 1401 
 1402   static uint size_deopt_handler() {
 1403     return NativeCall::max_instruction_size();
 1404   }
 1405 };
 1406 
 1407 %} // end source_hpp section
 1408 
 1409 source %{
 1410 
 1411 // This exception handler code snippet is placed after the method&#39;s
 1412 // code. It is the return point if an exception occurred. it jumps to
 1413 // the exception blob.
 1414 //
 1415 // If the method gets deoptimized, the method and this code snippet
 1416 // get patched.
 1417 //
 1418 // 1) Trampoline code gets patched into the end of this exception
 1419 //   handler. the trampoline code jumps to the deoptimization blob.
 1420 //
 1421 // 2) The return address in the method&#39;s code will get patched such
 1422 //   that it jumps to the trampoline.
 1423 //
 1424 // 3) The handler will get patched such that it does not jump to the
 1425 //   exception blob, but to an entry in the deoptimization blob being
 1426 //   aware of the exception.
 1427 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1428   Register temp_reg = Z_R1;
 1429   MacroAssembler _masm(&amp;cbuf);
 1430 
 1431   address base = __ start_a_stub(size_exception_handler());
 1432   if (base == NULL) {
 1433     return 0;          // CodeBuffer::expand failed
 1434   }
 1435 
 1436   int offset = __ offset();
 1437   // Use unconditional pc-relative jump with 32-bit range here.
 1438   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1439   __ z_br(temp_reg);
 1440 
 1441   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1442 
 1443   __ end_a_stub();
 1444 
 1445   return offset;
 1446 }
 1447 
 1448 // Emit deopt handler code.
 1449 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1450   MacroAssembler _masm(&amp;cbuf);
 1451   address        base = __ start_a_stub(size_deopt_handler());
 1452 
 1453   if (base == NULL) {
 1454     return 0;  // CodeBuffer::expand failed
 1455   }
 1456 
 1457   int offset = __ offset();
 1458 
 1459   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1460   // we do not use load_const_opt here.
 1461   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1462   __ call(Z_R1);
 1463   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1464 
 1465   __ end_a_stub();
 1466   return offset;
 1467 }
 1468 
 1469 //=============================================================================
 1470 
 1471 
 1472 // Given a register encoding, produce an Integer Register object.
 1473 static Register reg_to_register_object(int register_encoding) {
 1474   assert(Z_R12-&gt;encoding() == Z_R12_enc, &quot;wrong coding&quot;);
 1475   return as_Register(register_encoding);
 1476 }
 1477 
 1478 const bool Matcher::match_rule_supported(int opcode) {
 1479   if (!has_match_rule(opcode)) return false;
 1480 
 1481   switch (opcode) {
 1482     case Op_CountLeadingZerosI:
 1483     case Op_CountLeadingZerosL:
 1484     case Op_CountTrailingZerosI:
 1485     case Op_CountTrailingZerosL:
 1486       // Implementation requires FLOGR instruction, which is available since z9.
 1487       return true;
 1488 
 1489     case Op_ReverseBytesI:
 1490     case Op_ReverseBytesL:
 1491       return UseByteReverseInstruction;
 1492 
 1493     // PopCount supported by H/W from z/Architecture G5 (z196) on.
 1494     case Op_PopCountI:
 1495     case Op_PopCountL:
 1496       return UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount();
 1497 
 1498     case Op_StrComp:
 1499       return SpecialStringCompareTo;
 1500     case Op_StrEquals:
 1501       return SpecialStringEquals;
 1502     case Op_StrIndexOf:
 1503     case Op_StrIndexOfChar:
 1504       return SpecialStringIndexOf;
 1505 
 1506     case Op_GetAndAddI:
 1507     case Op_GetAndAddL:
 1508       return true;
 1509       // return VM_Version::has_AtomicMemWithImmALUOps();
 1510     case Op_GetAndSetI:
 1511     case Op_GetAndSetL:
 1512     case Op_GetAndSetP:
 1513     case Op_GetAndSetN:
 1514       return true;  // General CAS implementation, always available.
 1515 
 1516     default:
 1517       return true;  // Per default match rules are supported.
 1518                     // BUT: make sure match rule is not disabled by a false predicate!
 1519   }
 1520 
 1521   return true;  // Per default match rules are supported.
 1522                 // BUT: make sure match rule is not disabled by a false predicate!
 1523 }
 1524 
 1525 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {
 1526   // TODO
 1527   // Identify extra cases that we might want to provide match rules for
 1528   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1529   bool ret_value = match_rule_supported(opcode);
 1530   // Add rules here.
 1531 
 1532   return ret_value;  // Per default match rules are supported.
 1533 }
 1534 
 1535 int Matcher::regnum_to_fpu_offset(int regnum) {
 1536   ShouldNotReachHere();
 1537   return regnum - 32; // The FP registers are in the second chunk.
 1538 }
 1539 
 1540 const bool Matcher::has_predicated_vectors(void) {
 1541   return false;
 1542 }
 1543 
 1544 const int Matcher::float_pressure(int default_pressure_threshold) {
 1545   return default_pressure_threshold;
 1546 }
 1547 
 1548 const bool Matcher::convL2FSupported(void) {
 1549   return true; // False means that conversion is done by runtime call.
 1550 }
 1551 
 1552 //----------SUPERWORD HELPERS----------------------------------------
 1553 
 1554 // Vector width in bytes.
 1555 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1556   assert(MaxVectorSize == 8, &quot;&quot;);
 1557   return 8;
 1558 }
 1559 
 1560 // Vector ideal reg.
 1561 const uint Matcher::vector_ideal_reg(int size) {
 1562   assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 1563   return Op_RegL;
 1564 }
 1565 
 1566 // Limits on vector size (number of elements) loaded into vector.
 1567 const int Matcher::max_vector_size(const BasicType bt) {
 1568   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1569   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1570 }
 1571 
 1572 const int Matcher::min_vector_size(const BasicType bt) {
 1573   return max_vector_size(bt); // Same as max.
 1574 }
 1575 
 1576 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1577   fatal(&quot;vector shift is not supported&quot;);
 1578   return Node::NotAMachineReg;
 1579 }
 1580 
 1581 // z/Architecture does support misaligned store/load at minimal extra cost.
 1582 const bool Matcher::misaligned_vectors_ok() {
 1583   return true;
 1584 }
 1585 
 1586 // Not yet ported to z/Architecture.
 1587 const bool Matcher::pass_original_key_for_aes() {
 1588   return false;
 1589 }
 1590 
 1591 // RETURNS: whether this branch offset is short enough that a short
 1592 // branch can be used.
 1593 //
 1594 // If the platform does not provide any short branch variants, then
 1595 // this method should return `false&#39; for offset 0.
 1596 //
 1597 // `Compile::Fill_buffer&#39; will decide on basis of this information
 1598 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 1599 //
 1600 // And `Compile::Shorten_branches&#39; will decide on basis of this
 1601 // information whether to replace particular branch sites by short
 1602 // ones.
 1603 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1604   // On zarch short branches use a 16 bit signed immediate that
 1605   // is the pc-relative offset in halfword (= 2 bytes) units.
 1606   return Assembler::is_within_range_of_RelAddr16((address)((long)offset), (address)0);
 1607 }
 1608 
 1609 const bool Matcher::isSimpleConstant64(jlong value) {
 1610   // Probably always true, even if a temp register is required.
 1611   return true;
 1612 }
 1613 
 1614 // Should correspond to setting above
 1615 const bool Matcher::init_array_count_is_in_bytes = false;
 1616 
 1617 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1618 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1619 
 1620 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1621 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1622 
 1623 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1624 const bool Matcher::require_postalloc_expand = false;
 1625 
 1626 // Do we need to mask the count passed to shift instructions or does
 1627 // the cpu only look at the lower 5/6 bits anyway?
 1628 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1629 // Constant shift counts are handled in Ideal phase.
 1630 const bool Matcher::need_masked_shift_count = false;
 1631 
 1632 // Set this as clone_shift_expressions.
 1633 bool Matcher::narrow_oop_use_complex_address() {
 1634   if (Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0) return true;
 1635   return false;
 1636 }
 1637 
 1638 bool Matcher::narrow_klass_use_complex_address() {
 1639   NOT_LP64(ShouldNotCallThis());
 1640   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1641   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1642   return false;
 1643 }
 1644 
 1645 bool Matcher::const_oop_prefer_decode() {
 1646   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1647   return Universe::narrow_oop_base() == NULL;
 1648 }
 1649 
 1650 bool Matcher::const_klass_prefer_decode() {
 1651   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1652   return Universe::narrow_klass_base() == NULL;
 1653 }
 1654 
 1655 // Is it better to copy float constants, or load them directly from memory?
 1656 // Most RISCs will have to materialize an address into a
 1657 // register first, so they would do better to copy the constant from stack.
 1658 const bool Matcher::rematerialize_float_constants = false;
 1659 
 1660 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1661 // needed. Else we split the double into 2 integer pieces and move it
 1662 // piece-by-piece. Only happens when passing doubles into C code as the
 1663 // Java calling convention forces doubles to be aligned.
 1664 const bool Matcher::misaligned_doubles_ok = true;
 1665 
 1666 // Advertise here if the CPU requires explicit rounding operations
 1667 // to implement the UseStrictFP mode.
 1668 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1669 
 1670 // Do floats take an entire double register or just half?
 1671 //
 1672 // A float in resides in a zarch double register. When storing it by
 1673 // z_std, it cannot be restored in C-code by reloading it as a double
 1674 // and casting it into a float afterwards.
 1675 bool Matcher::float_in_double() { return false; }
 1676 
 1677 // Do ints take an entire long register or just half?
 1678 // The relevant question is how the int is callee-saved:
 1679 // the whole long is written but de-opt&#39;ing will have to extract
 1680 // the relevant 32 bits.
 1681 const bool Matcher::int_in_long = true;
 1682 
 1683 // Constants for c2c and c calling conventions.
 1684 
 1685 const MachRegisterNumbers z_iarg_reg[5] = {
 1686   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1687 };
 1688 
 1689 const MachRegisterNumbers z_farg_reg[4] = {
 1690   Z_F0_num, Z_F2_num, Z_F4_num, Z_F6_num
 1691 };
 1692 
 1693 const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 1694 
 1695 const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 1696 
 1697 // Return whether or not this register is ever used as an argument. This
 1698 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1699 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1700 // arguments in those registers not be available to the callee.
 1701 bool Matcher::can_be_java_arg(int reg) {
 1702   // We return true for all registers contained in z_iarg_reg[] and
 1703   // z_farg_reg[] and their virtual halves.
 1704   // We must include the virtual halves in order to get STDs and LDs
 1705   // instead of STWs and LWs in the trampoline stubs.
 1706 
 1707   if (reg == Z_R2_num || reg == Z_R2_H_num ||
 1708       reg == Z_R3_num || reg == Z_R3_H_num ||
 1709       reg == Z_R4_num || reg == Z_R4_H_num ||
 1710       reg == Z_R5_num || reg == Z_R5_H_num ||
 1711       reg == Z_R6_num || reg == Z_R6_H_num) {
 1712     return true;
 1713   }
 1714 
 1715   if (reg == Z_F0_num || reg == Z_F0_H_num ||
 1716       reg == Z_F2_num || reg == Z_F2_H_num ||
 1717       reg == Z_F4_num || reg == Z_F4_H_num ||
 1718       reg == Z_F6_num || reg == Z_F6_H_num) {
 1719     return true;
 1720   }
 1721 
 1722   return false;
 1723 }
 1724 
 1725 bool Matcher::is_spillable_arg(int reg) {
 1726   return can_be_java_arg(reg);
 1727 }
 1728 
 1729 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 1730   return false;
 1731 }
 1732 
 1733 // Register for DIVI projection of divmodI
 1734 RegMask Matcher::divI_proj_mask() {
 1735   return _Z_RARG4_INT_REG_mask;
 1736 }
 1737 
 1738 // Register for MODI projection of divmodI
 1739 RegMask Matcher::modI_proj_mask() {
 1740   return _Z_RARG3_INT_REG_mask;
 1741 }
 1742 
 1743 // Register for DIVL projection of divmodL
 1744 RegMask Matcher::divL_proj_mask() {
 1745   return _Z_RARG4_LONG_REG_mask;
 1746 }
 1747 
 1748 // Register for MODL projection of divmodL
 1749 RegMask Matcher::modL_proj_mask() {
 1750   return _Z_RARG3_LONG_REG_mask;
 1751 }
 1752 
 1753 // Copied from sparc.
 1754 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1755   return RegMask();
 1756 }
 1757 
 1758 const bool Matcher::convi2l_type_required = true;
 1759 
 1760 // Should the Matcher clone shifts on addressing modes, expecting them
 1761 // to be subsumed into complex addressing expressions or compute them
 1762 // into registers?
 1763 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1764   return clone_base_plus_offset_address(m, mstack, address_visited);
 1765 }
 1766 
 1767 void Compile::reshape_address(AddPNode* addp) {
 1768 }
 1769 
 1770 %} // source
 1771 
 1772 //----------ENCODING BLOCK-----------------------------------------------------
 1773 // This block specifies the encoding classes used by the compiler to output
 1774 // byte streams. Encoding classes are parameterized macros used by
 1775 // Machine Instruction Nodes in order to generate the bit encoding of the
 1776 // instruction. Operands specify their base encoding interface with the
 1777 // interface keyword. There are currently supported four interfaces,
 1778 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1779 // operand to generate a function which returns its register number when
 1780 // queried. CONST_INTER causes an operand to generate a function which
 1781 // returns the value of the constant when queried. MEMORY_INTER causes an
 1782 // operand to generate four functions which return the Base Register, the
 1783 // Index Register, the Scale Value, and the Offset Value of the operand when
 1784 // queried. COND_INTER causes an operand to generate six functions which
 1785 // return the encoding code (ie - encoding bits for the instruction)
 1786 // associated with each basic boolean condition for a conditional instruction.
 1787 //
 1788 // Instructions specify two basic values for encoding. Again, a function
 1789 // is available to check if the constant displacement is an oop. They use the
 1790 // ins_encode keyword to specify their encoding classes (which must be
 1791 // a sequence of enc_class names, and their parameters, specified in
 1792 // the encoding block), and they use the
 1793 // opcode keyword to specify, in order, their primary, secondary, and
 1794 // tertiary opcode. Only the opcode sections which a particular instruction
 1795 // needs for encoding need to be specified.
 1796 encode %{
 1797   enc_class enc_unimplemented %{
 1798     MacroAssembler _masm(&amp;cbuf);
 1799     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1800   %}
 1801 
 1802   enc_class enc_untested %{
 1803 #ifdef ASSERT
 1804     MacroAssembler _masm(&amp;cbuf);
 1805     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1806 #endif
 1807   %}
 1808 
 1809   enc_class z_rrform(iRegI dst, iRegI src) %{
 1810     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1811     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1812     z_emit16(cbuf, $primary |
 1813              Assembler::reg($dst$$reg,8,16) |
 1814              Assembler::reg($src$$reg,12,16));
 1815   %}
 1816 
 1817   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1818     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1819     z_emit32(cbuf, $primary |
 1820              Assembler::reg($dst1$$reg,24,32) |
 1821              Assembler::reg($src2$$reg,28,32));
 1822   %}
 1823 
 1824   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
 1825     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1826     z_emit32(cbuf, $primary |
 1827              Assembler::reg($dst1$$reg,24,32) |
 1828              Assembler::reg($src2$$reg,28,32) |
 1829              Assembler::reg($src3$$reg,16,32));
 1830   %}
 1831 
 1832   enc_class z_riform_signed(iRegI dst, immI16 src) %{
 1833     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1834     z_emit32(cbuf, $primary |
 1835              Assembler::reg($dst$$reg,8,32) |
 1836              Assembler::simm16($src$$constant,16,32));
 1837   %}
 1838 
 1839   enc_class z_riform_unsigned(iRegI dst, uimmI16 src) %{
 1840     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1841     z_emit32(cbuf, $primary |
 1842              Assembler::reg($dst$$reg,8,32) |
 1843              Assembler::uimm16($src$$constant,16,32));
 1844   %}
 1845 
 1846   enc_class z_rieform_d(iRegI dst1, iRegI src3, immI src2) %{
 1847     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1848     z_emit48(cbuf, $primary |
 1849              Assembler::reg($dst1$$reg,8,48) |
 1850              Assembler::reg($src3$$reg,12,48) |
 1851              Assembler::simm16($src2$$constant,16,48));
 1852   %}
 1853 
 1854   enc_class z_rilform_signed(iRegI dst, immL32 src) %{
 1855     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1856     z_emit48(cbuf, $primary |
 1857              Assembler::reg($dst$$reg,8,48) |
 1858              Assembler::simm32($src$$constant,16,48));
 1859   %}
 1860 
 1861   enc_class z_rilform_unsigned(iRegI dst, uimmL32 src) %{
 1862     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1863     z_emit48(cbuf, $primary |
 1864              Assembler::reg($dst$$reg,8,48) |
 1865              Assembler::uimm32($src$$constant,16,48));
 1866   %}
 1867 
 1868   enc_class z_rsyform_const(iRegI dst, iRegI src1, immI src2) %{
 1869     z_emit48(cbuf, $primary |
 1870              Assembler::reg($dst$$reg,8,48) |
 1871              Assembler::reg($src1$$reg,12,48) |
 1872              Assembler::simm20($src2$$constant));
 1873   %}
 1874 
 1875   enc_class z_rsyform_reg_reg(iRegI dst, iRegI src, iRegI shft) %{
 1876     z_emit48(cbuf, $primary |
 1877              Assembler::reg($dst$$reg,8,48) |
 1878              Assembler::reg($src$$reg,12,48) |
 1879              Assembler::reg($shft$$reg,16,48) |
 1880              Assembler::simm20(0));
 1881   %}
 1882 
 1883   enc_class z_rxform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1884     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1885     z_emit32(cbuf, $primary |
 1886              Assembler::reg($dst$$reg,8,32) |
 1887              Assembler::reg($src1$$reg,12,32) |
 1888              Assembler::reg($src2$$reg,16,32) |
 1889              Assembler::uimm12($con$$constant,20,32));
 1890   %}
 1891 
 1892   enc_class z_rxform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1893     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1894     z_emit32(cbuf, $primary |
 1895              Assembler::reg($dst$$reg,8,32) |
 1896              Assembler::reg($src$$reg,16,32) |
 1897              Assembler::uimm12($con$$constant,20,32));
 1898   %}
 1899 
 1900   enc_class z_rxyform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1901     z_emit48(cbuf, $primary |
 1902              Assembler::reg($dst$$reg,8,48) |
 1903              Assembler::reg($src1$$reg,12,48) |
 1904              Assembler::reg($src2$$reg,16,48) |
 1905              Assembler::simm20($con$$constant));
 1906   %}
 1907 
 1908   enc_class z_rxyform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1909     z_emit48(cbuf, $primary |
 1910              Assembler::reg($dst$$reg,8,48) |
 1911              Assembler::reg($src$$reg,16,48) |
 1912              Assembler::simm20($con$$constant));
 1913   %}
 1914 
 1915   // Direct memory arithmetic.
 1916   enc_class z_siyform(memoryRSY mem, immI8 src) %{
 1917     int      disp = $mem$$disp;
 1918     Register base = reg_to_register_object($mem$$base);
 1919     int      con  = $src$$constant;
 1920 
 1921     assert(VM_Version::has_MemWithImmALUOps(), &quot;unsupported CPU&quot;);
 1922     z_emit_inst(cbuf, $primary |
 1923                 Assembler::regz(base,16,48) |
 1924                 Assembler::simm20(disp) |
 1925                 Assembler::simm8(con,8,48));
 1926   %}
 1927 
 1928   enc_class z_silform(memoryRS mem, immI16 src) %{
 1929     z_emit_inst(cbuf, $primary |
 1930                 Assembler::regz(reg_to_register_object($mem$$base),16,48) |
 1931                 Assembler::uimm12($mem$$disp,20,48) |
 1932                 Assembler::simm16($src$$constant,32,48));
 1933   %}
 1934 
 1935   // Encoder for FP ALU reg/mem instructions (support only short displacements).
 1936   enc_class z_form_rt_memFP(RegF dst, memoryRX mem) %{
 1937     Register Ridx = $mem$$index$$Register;
 1938     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1939     if ($primary &gt; (1L &lt;&lt; 32)) {
 1940       z_emit_inst(cbuf, $primary |
 1941                   Assembler::reg($dst$$reg, 8, 48) |
 1942                   Assembler::uimm12($mem$$disp, 20, 48) |
 1943                   Assembler::reg(Ridx, 12, 48) |
 1944                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1945     } else {
 1946       z_emit_inst(cbuf, $primary |
 1947                   Assembler::reg($dst$$reg, 8, 32) |
 1948                   Assembler::uimm12($mem$$disp, 20, 32) |
 1949                   Assembler::reg(Ridx, 12, 32) |
 1950                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 1951     }
 1952   %}
 1953 
 1954   enc_class z_form_rt_mem(iRegI dst, memory mem) %{
 1955     Register Ridx = $mem$$index$$Register;
 1956     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1957     if ($primary &gt; (1L&lt;&lt;32)) {
 1958       z_emit_inst(cbuf, $primary |
 1959                   Assembler::reg($dst$$reg, 8, 48) |
 1960                   Assembler::simm20($mem$$disp) |
 1961                   Assembler::reg(Ridx, 12, 48) |
 1962                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1963     } else {
 1964       z_emit_inst(cbuf, $primary |
 1965                   Assembler::reg($dst$$reg, 8, 32) |
 1966                   Assembler::uimm12($mem$$disp, 20, 32) |
 1967                   Assembler::reg(Ridx, 12, 32) |
 1968                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 1969     }
 1970   %}
 1971 
 1972   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 1973     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 1974     Register Ridx = $mem$$index$$Register;
 1975     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1976 
 1977     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 1978       z_emit_inst(cbuf, $secondary |
 1979                   Assembler::reg($dst$$reg, 8, isize) |
 1980                   Assembler::uimm12($mem$$disp, 20, isize) |
 1981                   Assembler::reg(Ridx, 12, isize) |
 1982                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 1983     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 1984       z_emit_inst(cbuf, $primary |
 1985                   Assembler::reg($dst$$reg, 8, 48) |
 1986                   Assembler::simm20($mem$$disp) |
 1987                   Assembler::reg(Ridx, 12, 48) |
 1988                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1989     } else {
 1990         MacroAssembler _masm(&amp;cbuf);
 1991         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 1992         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 1993         z_emit_inst(cbuf, $secondary |
 1994                     Assembler::reg($dst$$reg, 8, isize) |
 1995                     Assembler::uimm12(0, 20, isize) |
 1996                     Assembler::reg(Z_R1_scratch, 12, isize) |
 1997                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 1998     }
 1999   %}
 2000 
 2001   enc_class z_enc_brul(Label lbl) %{
 2002     MacroAssembler _masm(&amp;cbuf);
 2003     Label* p = $lbl$$label;
 2004 
 2005     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2006     // determine the size of the encoded instruction.
 2007     // Use a bound dummy label in that case.
 2008     Label d;
 2009     __ bind(d);
 2010     Label&amp; l = (NULL == p) ? d : *(p);
 2011     __ z_brul(l);
 2012   %}
 2013 
 2014   enc_class z_enc_bru(Label lbl) %{
 2015     MacroAssembler _masm(&amp;cbuf);
 2016     Label* p = $lbl$$label;
 2017 
 2018     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2019     // determine the size of the encoded instruction.
 2020     // Use a bound dummy label in that case.
 2021     Label d;
 2022     __ bind(d);
 2023     Label&amp; l = (NULL == p) ? d : *(p);
 2024     __ z_bru(l);
 2025   %}
 2026 
 2027   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
 2028     MacroAssembler _masm(&amp;cbuf);
 2029     Label* p = $lbl$$label;
 2030 
 2031     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2032     // determine the size of the encoded instruction.
 2033     // Use a bound dummy label in that case.
 2034     Label d;
 2035     __ bind(d);
 2036     Label&amp; l = (NULL == p) ? d : *(p);
 2037     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2038   %}
 2039 
 2040   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
 2041     MacroAssembler _masm(&amp;cbuf);
 2042     Label* p = $lbl$$label;
 2043 
 2044     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2045     // determine the size of the encoded instruction.
 2046     // Use a bound dummy label in that case.
 2047     Label d;
 2048     __ bind(d);
 2049     Label&amp; l = (NULL == p) ? d : *(p);
 2050     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2051   %}
 2052 
 2053   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2054     MacroAssembler _masm(&amp;cbuf);
 2055     Label* p = $lbl$$label;
 2056 
 2057     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2058     // determine the size of the encoded instruction.
 2059     // Use a bound dummy label in that case.
 2060     Label d;
 2061     __ bind(d);
 2062     Label&amp; l = (NULL == p) ? d : *(p);
 2063     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2064     unsigned long instr = $primary;
 2065     if (instr == CRJ_ZOPC) {
 2066       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2067     } else if (instr == CLRJ_ZOPC) {
 2068       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2069     } else if (instr == CGRJ_ZOPC) {
 2070       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2071     } else {
 2072       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2073       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2074     }
 2075   %}
 2076 
 2077   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2078     MacroAssembler _masm(&amp;cbuf);
 2079     Label* p = $lbl$$label;
 2080 
 2081     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2082     // determine the size of the encoded instruction.
 2083     // Use a bound dummy label in that case.
 2084     Label d;
 2085     __ bind(d);
 2086     Label&amp; l = (NULL == p) ? d : *(p);
 2087 
 2088     unsigned long instr = $primary;
 2089     if (instr == CR_ZOPC) {
 2090       __ z_cr($src1$$Register, $src2$$Register);
 2091     } else if (instr == CLR_ZOPC) {
 2092       __ z_clr($src1$$Register, $src2$$Register);
 2093     } else if (instr == CGR_ZOPC) {
 2094       __ z_cgr($src1$$Register, $src2$$Register);
 2095     } else {
 2096       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2097       __ z_clgr($src1$$Register, $src2$$Register);
 2098     }
 2099 
 2100     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2101   %}
 2102 
 2103   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2104     MacroAssembler _masm(&amp;cbuf);
 2105     Label* p = $lbl$$label;
 2106 
 2107     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2108     // determine the size of the encoded instruction.
 2109     // Use a bound dummy label in that case.
 2110     Label d;
 2111     __ bind(d);
 2112     Label&amp; l = (NULL == p) ? d : *(p);
 2113 
 2114     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2115     unsigned long instr = $primary;
 2116     if (instr == CIJ_ZOPC) {
 2117       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2118     } else if (instr == CLIJ_ZOPC) {
 2119       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2120     } else if (instr == CGIJ_ZOPC) {
 2121       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2122     } else {
 2123       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2124       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2125     }
 2126   %}
 2127 
 2128   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2129     MacroAssembler _masm(&amp;cbuf);
 2130     Label* p = $lbl$$label;
 2131 
 2132     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2133     // determine the size of the encoded instruction.
 2134     // Use a bound dummy label in that case.
 2135     Label d;
 2136     __ bind(d);
 2137     Label&amp; l = (NULL == p) ? d : *(p);
 2138 
 2139     unsigned long instr = $primary;
 2140     if (instr == CHI_ZOPC) {
 2141       __ z_chi($src1$$Register, $src2$$constant);
 2142     } else if (instr == CLFI_ZOPC) {
 2143       __ z_clfi($src1$$Register, $src2$$constant);
 2144     } else if (instr == CGHI_ZOPC) {
 2145       __ z_cghi($src1$$Register, $src2$$constant);
 2146     } else {
 2147       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2148       __ z_clgfi($src1$$Register, $src2$$constant);
 2149     }
 2150 
 2151     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2152   %}
 2153 
 2154   // Call from Java to runtime.
 2155   enc_class z_enc_java_to_runtime_call(method meth) %{
 2156     MacroAssembler _masm(&amp;cbuf);
 2157 
 2158     // Save return pc before call to the place where we need it, since
 2159     // callee doesn&#39;t.
 2160     unsigned int start_off = __ offset();
 2161     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2162     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2163     __ get_PC(Z_R14, size_of_code);
 2164     __ save_return_pc();
 2165     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2166 
 2167     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2168     address call_addr = __ call_c_opt((address)$meth$$method);
 2169     if (call_addr == NULL) {
 2170       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2171       return;
 2172     }
 2173 
 2174 #ifdef ASSERT
 2175     // Plausibility check for size_of_code assumptions.
 2176     unsigned int actual_ret_off = __ offset();
 2177     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2178 #endif
 2179   %}
 2180 
 2181   enc_class z_enc_java_static_call(method meth) %{
 2182     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2183     // whom we intended to call.
 2184     MacroAssembler _masm(&amp;cbuf);
 2185     int ret_offset = 0;
 2186 
 2187     if (!_method) {
 2188       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2189                                    relocInfo::runtime_call_w_cp_type, ra_);
 2190     } else {
 2191       int method_index = resolved_method_index(cbuf);
 2192       if (_optimized_virtual) {
 2193         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2194                                      opt_virtual_call_Relocation::spec(method_index));
 2195       } else {
 2196         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2197                                      static_call_Relocation::spec(method_index));
 2198       }
 2199     }
 2200     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2201 
 2202     if (_method) { // Emit stub for static call.
 2203       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2204       if (stub == NULL) {
 2205         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2206         return;
 2207       }
 2208     }
 2209   %}
 2210 
 2211   // Java dynamic call
 2212   enc_class z_enc_java_dynamic_call(method meth) %{
 2213     MacroAssembler _masm(&amp;cbuf);
 2214     unsigned int start_off = __ offset();
 2215 
 2216     int vtable_index = this-&gt;_vtable_index;
 2217     if (vtable_index == -4) {
 2218       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2219       address virtual_call_oop_addr = NULL;
 2220 
 2221       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2222       virtual_call_oop_addr = __ pc();
 2223       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2224       if (!success) {
 2225         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2226         return;
 2227       }
 2228 
 2229       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2230       // to determine who we intended to call.
 2231       int method_index = resolved_method_index(cbuf);
 2232       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2233       unsigned int ret_off = __ offset();
 2234       assert(__ offset() - start_off == 6, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2235       ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);
 2236       assert(_method, &quot;lazy_constant may be wrong when _method==null&quot;);
 2237     } else {
 2238       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2239       // Go through the vtable. Get receiver klass. Receiver already
 2240       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 2241       // interpreter expects method in Z_method.
 2242       // Use Z_method to temporarily hold the klass oop.
 2243       // Z_R1_scratch is destroyed.
 2244       __ load_klass(Z_method, Z_R2);
 2245 
 2246       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index * vtableEntry::size_in_bytes();
 2247       int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 2248 
 2249       if (Displacement::is_validDisp(v_off) ) {
 2250         // Can use load instruction with large offset.
 2251         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2252       } else {
 2253         // Worse case, must load offset into register.
 2254         __ load_const(Z_R1_scratch, v_off);
 2255         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2256       }
 2257       // NOTE: for vtable dispatches, the vtable entry will never be
 2258       // null. However it may very well end up in handle_wrong_method
 2259       // if the method is abstract for the particular class.
 2260       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2261       // Call target. Either compiled code or C2I adapter.
 2262       __ z_basr(Z_R14, Z_R1_scratch);
 2263       unsigned int ret_off = __ offset();
 2264     }
 2265   %}
 2266 
 2267   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
 2268     MacroAssembler _masm(&amp;cbuf);
 2269     Register Rdst = reg_to_register_object($dst$$reg);
 2270     Register Rsrc = reg_to_register_object($src$$reg);
 2271 
 2272     // Don&#39;t emit code if operands are identical (same register).
 2273     if (Rsrc != Rdst) {
 2274       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2275 
 2276       if (VM_Version::has_LoadStoreConditional()) {
 2277         __ z_locgr(Rdst, Rsrc, cc);
 2278       } else {
 2279         // Branch if not (cmp cr).
 2280         Label done;
 2281         __ z_brc(Assembler::inverse_condition(cc), done);
 2282         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2283         __ bind(done);
 2284       }
 2285     }
 2286   %}
 2287 
 2288   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
 2289     MacroAssembler _masm(&amp;cbuf);
 2290     Register Rdst = reg_to_register_object($dst$$reg);
 2291     int      Csrc = $src$$constant;
 2292     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2293     Label done;
 2294     // Branch if not (cmp cr).
 2295     __ z_brc(Assembler::inverse_condition(cc), done);
 2296     if (Csrc == 0) {
 2297       // Don&#39;t set CC.
 2298       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2299     } else {
 2300       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2301     }
 2302     __ bind(done);
 2303   %}
 2304 
 2305   enc_class z_enc_cctobool(iRegI res) %{
 2306     MacroAssembler _masm(&amp;cbuf);
 2307     Register Rres = reg_to_register_object($res$$reg);
 2308 
 2309     if (VM_Version::has_LoadStoreConditional()) {
 2310       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2311       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2312       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2313     } else {
 2314       Label done;
 2315       __ load_const_optimized(Rres, 0L); // false (failed)
 2316       __ z_brne(done);                   // Assume true to be the common case.
 2317       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2318       __ bind(done);
 2319     }
 2320   %}
 2321 
 2322   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
 2323     MacroAssembler _masm(&amp;cbuf);
 2324     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2325     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2326     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2327 
 2328     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2329   %}
 2330 
 2331   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
 2332     MacroAssembler _masm(&amp;cbuf);
 2333     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2334     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2335     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2336 
 2337     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2338   %}
 2339 
 2340   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
 2341     MacroAssembler _masm(&amp;cbuf);
 2342     Register Rdst = reg_to_register_object($dst$$reg);
 2343     Register Rtmp = reg_to_register_object($tmp$$reg);
 2344     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2345     Label    retry;
 2346 
 2347     // Iterate until swap succeeds.
 2348     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2349     __ bind(retry);
 2350       // Calculate incremented value.
 2351       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2352       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2353     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2354   %}
 2355 
 2356   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
 2357     MacroAssembler _masm(&amp;cbuf);
 2358     Register Rdst = reg_to_register_object($dst$$reg);
 2359     Register Rtmp = reg_to_register_object($tmp$$reg);
 2360     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2361     Label    retry;
 2362 
 2363     // Iterate until swap succeeds.
 2364     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2365     __ bind(retry);
 2366       // Calculate incremented value.
 2367       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2368       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2369     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2370   %}
 2371 
 2372 %} // encode
 2373 
 2374 source %{
 2375 
 2376   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2377   // 32 bits after encoding.
 2378   static bool all_outs_are_Stores(const Node *n) {
 2379     for (DUIterator_Fast imax, k = n-&gt;fast_outs(imax); k &lt; imax; k++) {
 2380       Node *out = n-&gt;fast_out(k);
 2381       if (!out-&gt;is_Mach() || out-&gt;as_Mach()-&gt;ideal_Opcode() != Op_StoreN) {
 2382         // Most other outs are SpillCopy, but there are various other.
 2383         // jvm98 has arond 9% Encodes where we return false.
 2384         return false;
 2385       }
 2386     }
 2387     return true;
 2388   }
 2389 
 2390 %} // source
 2391 
 2392 
 2393 //----------FRAME--------------------------------------------------------------
 2394 // Definition of frame structure and management information.
 2395 
 2396 frame %{
 2397   // What direction does stack grow in (assumed to be same for native &amp; Java).
 2398   stack_direction(TOWARDS_LOW);
 2399 
 2400   // These two registers define part of the calling convention between
 2401   // compiled code and the interpreter.
 2402 
 2403   // Inline Cache Register
 2404   inline_cache_reg(Z_R9); // Z_inline_cache
 2405 
 2406   // Argument pointer for I2C adapters
 2407   //
 2408   // Tos is loaded in run_compiled_code to Z_ARG5=Z_R6.
 2409   // interpreter_arg_ptr_reg(Z_R6);
 2410 
 2411   // Temporary in compiled entry-points
 2412   // compiler_method_oop_reg(Z_R1);//Z_R1_scratch
 2413 
 2414   // Method Oop Register when calling interpreter
 2415   interpreter_method_oop_reg(Z_R9);//Z_method
 2416 
 2417   // Optional: name the operand used by cisc-spilling to access
 2418   // [stack_pointer + offset].
 2419   cisc_spilling_operand_name(indOffset12);
 2420 
 2421   // Number of stack slots consumed by a Monitor enter.
 2422   sync_stack_slots(frame::jit_monitor_size_in_4_byte_units);
 2423 
 2424   // Compiled code&#39;s Frame Pointer
 2425   //
 2426   // z/Architecture stack pointer
 2427   frame_pointer(Z_R15); // Z_SP
 2428 
 2429   // Interpreter stores its frame pointer in a register which is
 2430   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 2431   // interpreted java to compiled java.
 2432   //
 2433   // Z_state holds pointer to caller&#39;s cInterpreter.
 2434   interpreter_frame_pointer(Z_R7); // Z_state
 2435 
 2436   // Use alignment_in_bytes instead of log_2_of_alignment_in_bits.
 2437   stack_alignment(frame::alignment_in_bytes);
 2438 
 2439   in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);
 2440 
 2441   // A `slot&#39; is assumed 4 bytes here!
 2442   // out_preserve_stack_slots(frame::jit_out_preserve_size_in_4_byte_units);
 2443 
 2444   // Number of outgoing stack slots killed above the
 2445   // out_preserve_stack_slots for calls to C. Supports the var-args
 2446   // backing area for register parms.
 2447   varargs_C_out_slots_killed(((frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 2448 
 2449   // The after-PROLOG location of the return address. Location of
 2450   // return address specifies a type (REG or STACK) and a number
 2451   // representing the register number (i.e. - use a register name) or
 2452   // stack slot.
 2453   return_addr(REG Z_R14);
 2454 
 2455   // This is the body of the function
 2456   //
 2457   // void Matcher::calling_convention(OptoRegPair* sig /* array of ideal regs */,
 2458   //                                  uint length      /* length of array */,
 2459   //                                  bool is_outgoing)
 2460   //
 2461   // The `sig&#39; array is to be updated. Sig[j] represents the location
 2462   // of the j-th argument, either a register or a stack slot.
 2463 
 2464   // Body of function which returns an integer array locating
 2465   // arguments either in registers or in stack slots. Passed an array
 2466   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2467   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2468   // arguments for a CALLEE. Incoming stack arguments are
 2469   // automatically biased by the preserve_stack_slots field above.
 2470   calling_convention %{
 2471     // No difference between ingoing/outgoing just pass false.
 2472     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2473   %}
 2474 
 2475   // Body of function which returns an integer array locating
 2476   // arguments either in registers or in stack slots. Passed an array
 2477   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2478   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2479   // arguments for a CALLEE. Incoming stack arguments are
 2480   // automatically biased by the preserve_stack_slots field above.
 2481   c_calling_convention %{
 2482     // This is obviously always outgoing.
 2483     // C argument must be in register AND stack slot.
 2484     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2485   %}
 2486 
 2487   // Location of native (C/C++) and interpreter return values. This
 2488   // is specified to be the same as Java. In the 32-bit VM, long
 2489   // values are actually returned from native calls in O0:O1 and
 2490   // returned to the interpreter in I0:I1. The copying to and from
 2491   // the register pairs is done by the appropriate call and epilog
 2492   // opcodes. This simplifies the register allocator.
 2493   //
 2494   // Use register pair for c return value.
 2495   c_return_value %{
 2496     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2497     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2498     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2499     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2500   %}
 2501 
 2502   // Use register pair for return value.
 2503   // Location of compiled Java return values. Same as C
 2504   return_value %{
 2505     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2506     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2507     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2508     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2509   %}
 2510 %}
 2511 
 2512 
 2513 //----------ATTRIBUTES---------------------------------------------------------
 2514 
 2515 //----------Operand Attributes-------------------------------------------------
 2516 op_attrib op_cost(1);          // Required cost attribute
 2517 
 2518 //----------Instruction Attributes---------------------------------------------
 2519 
 2520 // Cost attribute. required.
 2521 ins_attrib ins_cost(DEFAULT_COST);
 2522 
 2523 // Is this instruction a non-matching short branch variant of some
 2524 // long branch? Not required.
 2525 ins_attrib ins_short_branch(0);
 2526 
 2527 // Indicates this is a trap based check node and final control-flow fixup
 2528 // must generate a proper fall through.
 2529 ins_attrib ins_is_TrapBasedCheckNode(true);
 2530 
 2531 // Attribute of instruction to tell how many constants the instruction will generate.
 2532 // (optional attribute). Default: 0.
 2533 ins_attrib ins_num_consts(0);
 2534 
 2535 // Required alignment attribute (must be a power of 2)
 2536 // specifies the alignment that some part of the instruction (not
 2537 // necessarily the start) requires. If &gt; 1, a compute_padding()
 2538 // function must be provided for the instruction.
 2539 //
 2540 // WARNING: Don&#39;t use size(FIXED_SIZE) or size(VARIABLE_SIZE) in
 2541 // instructions which depend on the proper alignment, because the
 2542 // desired alignment isn&#39;t guaranteed for the call to &quot;emit()&quot; during
 2543 // the size computation.
 2544 ins_attrib ins_alignment(1);
 2545 
 2546 // Enforce/prohibit rematerializations.
 2547 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 2548 //   then rematerialization of that instruction is prohibited and the
 2549 //   instruction&#39;s value will be spilled if necessary.
 2550 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 2551 //   then rematerialization is enforced and the instruction&#39;s value will
 2552 //   never get spilled. a copy of the instruction will be inserted if
 2553 //   necessary.
 2554 //   Note: this may result in rematerializations in front of every use.
 2555 // (optional attribute)
 2556 ins_attrib ins_cannot_rematerialize(false);
 2557 ins_attrib ins_should_rematerialize(false);
 2558 
 2559 //----------OPERANDS-----------------------------------------------------------
 2560 // Operand definitions must precede instruction definitions for correct
 2561 // parsing in the ADLC because operands constitute user defined types
 2562 // which are used in instruction definitions.
 2563 
 2564 //----------Simple Operands----------------------------------------------------
 2565 // Immediate Operands
 2566 // Please note:
 2567 // Formats are generated automatically for constants and base registers.
 2568 
 2569 //----------------------------------------------
 2570 // SIGNED (shorter than INT) immediate operands
 2571 //----------------------------------------------
 2572 
 2573 // Byte Immediate: constant &#39;int -1&#39;
 2574 operand immB_minus1() %{
 2575   //         sign-ext constant      zero-ext constant
 2576   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x000000ff) == 0x000000ff));
 2577   match(ConI);
 2578   op_cost(1);
 2579   format %{ %}
 2580   interface(CONST_INTER);
 2581 %}
 2582 
 2583 // Byte Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2584 operand immB_n0m1() %{
 2585   //                             sign-ext constant     zero-ext constant
 2586   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x000000ff) != 0x000000ff);
 2587   match(ConI);
 2588   op_cost(1);
 2589   format %{ %}
 2590   interface(CONST_INTER);
 2591 %}
 2592 
 2593 // Short Immediate: constant &#39;int -1&#39;
 2594 operand immS_minus1() %{
 2595   //         sign-ext constant      zero-ext constant
 2596   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x0000ffff) == 0x0000ffff));
 2597   match(ConI);
 2598   op_cost(1);
 2599   format %{ %}
 2600   interface(CONST_INTER);
 2601 %}
 2602 
 2603 // Short Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2604 operand immS_n0m1() %{
 2605   //                             sign-ext constant     zero-ext constant
 2606   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x0000ffff) != 0x0000ffff);
 2607   match(ConI);
 2608   op_cost(1);
 2609   format %{ %}
 2610   interface(CONST_INTER);
 2611 %}
 2612 
 2613 //-----------------------------------------
 2614 //  SIGNED INT immediate operands
 2615 //-----------------------------------------
 2616 
 2617 // Integer Immediate: 32-bit
 2618 operand immI() %{
 2619   match(ConI);
 2620   op_cost(1);
 2621   format %{ %}
 2622   interface(CONST_INTER);
 2623 %}
 2624 
 2625 // Int Immediate: 20-bit
 2626 operand immI20() %{
 2627   predicate(Immediate::is_simm20(n-&gt;get_int()));
 2628   match(ConI);
 2629   op_cost(1);
 2630   format %{ %}
 2631   interface(CONST_INTER);
 2632 %}
 2633 
 2634 // Integer Immediate: 16-bit
 2635 operand immI16() %{
 2636   predicate(Immediate::is_simm16(n-&gt;get_int()));
 2637   match(ConI);
 2638   op_cost(1);
 2639   format %{ %}
 2640   interface(CONST_INTER);
 2641 %}
 2642 
 2643 // Integer Immediate: 8-bit
 2644 operand immI8() %{
 2645   predicate(Immediate::is_simm8(n-&gt;get_int()));
 2646   match(ConI);
 2647   op_cost(1);
 2648   format %{ %}
 2649   interface(CONST_INTER);
 2650 %}
 2651 
 2652 // Integer Immediate: constant &#39;int 0&#39;
 2653 operand immI_0() %{
 2654   predicate(n-&gt;get_int() == 0);
 2655   match(ConI);
 2656   op_cost(1);
 2657   format %{ %}
 2658   interface(CONST_INTER);
 2659 %}
 2660 
 2661 // Integer Immediate: constant &#39;int -1&#39;
 2662 operand immI_minus1() %{
 2663   predicate(n-&gt;get_int() == -1);
 2664   match(ConI);
 2665   op_cost(1);
 2666   format %{ %}
 2667   interface(CONST_INTER);
 2668 %}
 2669 
 2670 // Integer Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2671 operand immI_n0m1() %{
 2672   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1);
 2673   match(ConI);
 2674   op_cost(1);
 2675   format %{ %}
 2676   interface(CONST_INTER);
 2677 %}
 2678 
 2679 //-------------------------------------------
 2680 // UNSIGNED INT immediate operands
 2681 //-------------------------------------------
 2682 
 2683 // Unsigned Integer Immediate: 32-bit
 2684 operand uimmI() %{
 2685   match(ConI);
 2686   op_cost(1);
 2687   format %{ %}
 2688   interface(CONST_INTER);
 2689 %}
 2690 
 2691 // Unsigned Integer Immediate: 16-bit
 2692 operand uimmI16() %{
 2693   predicate(Immediate::is_uimm16(n-&gt;get_int()));
 2694   match(ConI);
 2695   op_cost(1);
 2696   format %{ %}
 2697   interface(CONST_INTER);
 2698 %}
 2699 
 2700 // Unsigned Integer Immediate: 12-bit
 2701 operand uimmI12() %{
 2702   predicate(Immediate::is_uimm12(n-&gt;get_int()));
 2703   match(ConI);
 2704   op_cost(1);
 2705   format %{ %}
 2706   interface(CONST_INTER);
 2707 %}
 2708 
 2709 // Unsigned Integer Immediate: 12-bit
 2710 operand uimmI8() %{
 2711   predicate(Immediate::is_uimm8(n-&gt;get_int()));
 2712   match(ConI);
 2713   op_cost(1);
 2714   format %{ %}
 2715   interface(CONST_INTER);
 2716 %}
 2717 
 2718 // Integer Immediate: 6-bit
 2719 operand uimmI6() %{
 2720   predicate(Immediate::is_uimm(n-&gt;get_int(), 6));
 2721   match(ConI);
 2722   op_cost(1);
 2723   format %{ %}
 2724   interface(CONST_INTER);
 2725 %}
 2726 
 2727 // Integer Immediate: 5-bit
 2728 operand uimmI5() %{
 2729   predicate(Immediate::is_uimm(n-&gt;get_int(), 5));
 2730   match(ConI);
 2731   op_cost(1);
 2732   format %{ %}
 2733   interface(CONST_INTER);
 2734 %}
 2735 
 2736 // Length for SS instructions, given in DWs,
 2737 //   possible range [1..512], i.e. [8..4096] Bytes
 2738 //   used     range [1..256], i.e. [8..2048] Bytes
 2739 //   operand type int
 2740 // Unsigned Integer Immediate: 9-bit
 2741 operand SSlenDW() %{
 2742   predicate(Immediate::is_uimm8(n-&gt;get_long()-1));
 2743   match(ConL);
 2744   op_cost(1);
 2745   format %{ %}
 2746   interface(CONST_INTER);
 2747 %}
 2748 
 2749 //------------------------------------------
 2750 // (UN)SIGNED INT specific values
 2751 //------------------------------------------
 2752 
 2753 // Integer Immediate: the value 1
 2754 operand immI_1() %{
 2755   predicate(n-&gt;get_int() == 1);
 2756   match(ConI);
 2757   op_cost(1);
 2758   format %{ %}
 2759   interface(CONST_INTER);
 2760 %}
 2761 
 2762 // Integer Immediate: the value 16.
 2763 operand immI_16() %{
 2764   predicate(n-&gt;get_int() == 16);
 2765   match(ConI);
 2766   op_cost(1);
 2767   format %{ %}
 2768   interface(CONST_INTER);
 2769 %}
 2770 
 2771 // Integer Immediate: the value 24.
 2772 operand immI_24() %{
 2773   predicate(n-&gt;get_int() == 24);
 2774   match(ConI);
 2775   op_cost(1);
 2776   format %{ %}
 2777   interface(CONST_INTER);
 2778 %}
 2779 
 2780 // Integer Immediate: the value 255
 2781 operand immI_255() %{
 2782   predicate(n-&gt;get_int() == 255);
 2783   match(ConI);
 2784   op_cost(1);
 2785   format %{ %}
 2786   interface(CONST_INTER);
 2787 %}
 2788 
 2789 // Integer Immediate: the values 32-63
 2790 operand immI_32_63() %{
 2791   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 2792   match(ConI);
 2793   op_cost(1);
 2794   format %{ %}
 2795   interface(CONST_INTER);
 2796 %}
 2797 
 2798 // Unsigned Integer Immediate: LL-part, extended by 1s.
 2799 operand uimmI_LL1() %{
 2800   predicate((n-&gt;get_int() &amp; 0xFFFF0000) == 0xFFFF0000);
 2801   match(ConI);
 2802   op_cost(1);
 2803   format %{ %}
 2804   interface(CONST_INTER);
 2805 %}
 2806 
 2807 // Unsigned Integer Immediate: LH-part, extended by 1s.
 2808 operand uimmI_LH1() %{
 2809   predicate((n-&gt;get_int() &amp; 0xFFFF) == 0xFFFF);
 2810   match(ConI);
 2811   op_cost(1);
 2812   format %{ %}
 2813   interface(CONST_INTER);
 2814 %}
 2815 
 2816 //------------------------------------------
 2817 // SIGNED LONG immediate operands
 2818 //------------------------------------------
 2819 
 2820 operand immL() %{
 2821   match(ConL);
 2822   op_cost(1);
 2823   format %{ %}
 2824   interface(CONST_INTER);
 2825 %}
 2826 
 2827 // Long Immediate: 32-bit
 2828 operand immL32() %{
 2829   predicate(Immediate::is_simm32(n-&gt;get_long()));
 2830   match(ConL);
 2831   op_cost(1);
 2832   format %{ %}
 2833   interface(CONST_INTER);
 2834 %}
 2835 
 2836 // Long Immediate: 20-bit
 2837 operand immL20() %{
 2838   predicate(Immediate::is_simm20(n-&gt;get_long()));
 2839   match(ConL);
 2840   op_cost(1);
 2841   format %{ %}
 2842   interface(CONST_INTER);
 2843 %}
 2844 
 2845 // Long Immediate: 16-bit
 2846 operand immL16() %{
 2847   predicate(Immediate::is_simm16(n-&gt;get_long()));
 2848   match(ConL);
 2849   op_cost(1);
 2850   format %{ %}
 2851   interface(CONST_INTER);
 2852 %}
 2853 
 2854 // Long Immediate: 8-bit
 2855 operand immL8() %{
 2856   predicate(Immediate::is_simm8(n-&gt;get_long()));
 2857   match(ConL);
 2858   op_cost(1);
 2859   format %{ %}
 2860   interface(CONST_INTER);
 2861 %}
 2862 
 2863 //--------------------------------------------
 2864 // UNSIGNED LONG immediate operands
 2865 //--------------------------------------------
 2866 
 2867 operand uimmL32() %{
 2868   predicate(Immediate::is_uimm32(n-&gt;get_long()));
 2869   match(ConL);
 2870   op_cost(1);
 2871   format %{ %}
 2872   interface(CONST_INTER);
 2873 %}
 2874 
 2875 // Unsigned Long Immediate: 16-bit
 2876 operand uimmL16() %{
 2877   predicate(Immediate::is_uimm16(n-&gt;get_long()));
 2878   match(ConL);
 2879   op_cost(1);
 2880   format %{ %}
 2881   interface(CONST_INTER);
 2882 %}
 2883 
 2884 // Unsigned Long Immediate: 12-bit
 2885 operand uimmL12() %{
 2886   predicate(Immediate::is_uimm12(n-&gt;get_long()));
 2887   match(ConL);
 2888   op_cost(1);
 2889   format %{ %}
 2890   interface(CONST_INTER);
 2891 %}
 2892 
 2893 // Unsigned Long Immediate: 8-bit
 2894 operand uimmL8() %{
 2895   predicate(Immediate::is_uimm8(n-&gt;get_long()));
 2896   match(ConL);
 2897   op_cost(1);
 2898   format %{ %}
 2899   interface(CONST_INTER);
 2900 %}
 2901 
 2902 //-------------------------------------------
 2903 // (UN)SIGNED LONG specific values
 2904 //-------------------------------------------
 2905 
 2906 // Long Immediate: the value FF
 2907 operand immL_FF() %{
 2908   predicate(n-&gt;get_long() == 0xFFL);
 2909   match(ConL);
 2910   op_cost(1);
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 // Long Immediate: the value FFFF
 2916 operand immL_FFFF() %{
 2917   predicate(n-&gt;get_long() == 0xFFFFL);
 2918   match(ConL);
 2919   op_cost(1);
 2920   format %{ %}
 2921   interface(CONST_INTER);
 2922 %}
 2923 
 2924 // Long Immediate: the value FFFFFFFF
 2925 operand immL_FFFFFFFF() %{
 2926   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2927   match(ConL);
 2928   op_cost(1);
 2929   format %{ %}
 2930   interface(CONST_INTER);
 2931 %}
 2932 
 2933 operand immL_0() %{
 2934   predicate(n-&gt;get_long() == 0L);
 2935   match(ConL);
 2936   op_cost(1);
 2937   format %{ %}
 2938   interface(CONST_INTER);
 2939 %}
 2940 
 2941 // Unsigned Long Immediate: LL-part, extended by 1s.
 2942 operand uimmL_LL1() %{
 2943   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFF0000L) == 0xFFFFFFFFFFFF0000L);
 2944   match(ConL);
 2945   op_cost(1);
 2946   format %{ %}
 2947   interface(CONST_INTER);
 2948 %}
 2949 
 2950 // Unsigned Long Immediate: LH-part, extended by 1s.
 2951 operand uimmL_LH1() %{
 2952   predicate((n-&gt;get_long() &amp; 0xFFFFFFFF0000FFFFL) == 0xFFFFFFFF0000FFFFL);
 2953   match(ConL);
 2954   op_cost(1);
 2955   format %{ %}
 2956   interface(CONST_INTER);
 2957 %}
 2958 
 2959 // Unsigned Long Immediate: HL-part, extended by 1s.
 2960 operand uimmL_HL1() %{
 2961   predicate((n-&gt;get_long() &amp; 0xFFFF0000FFFFFFFFL) == 0xFFFF0000FFFFFFFFL);
 2962   match(ConL);
 2963   op_cost(1);
 2964   format %{ %}
 2965   interface(CONST_INTER);
 2966 %}
 2967 
 2968 // Unsigned Long Immediate: HH-part, extended by 1s.
 2969 operand uimmL_HH1() %{
 2970   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFFL) == 0xFFFFFFFFFFFFL);
 2971   match(ConL);
 2972   op_cost(1);
 2973   format %{ %}
 2974   interface(CONST_INTER);
 2975 %}
 2976 
 2977 // Long Immediate: low 32-bit mask
 2978 operand immL_32bits() %{
 2979   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2980   match(ConL);
 2981   op_cost(1);
 2982   format %{ %}
 2983   interface(CONST_INTER);
 2984 %}
 2985 
 2986 //--------------------------------------
 2987 //  POINTER immediate operands
 2988 //--------------------------------------
 2989 
 2990 // Pointer Immediate: 64-bit
 2991 operand immP() %{
 2992   match(ConP);
 2993   op_cost(1);
 2994   format %{ %}
 2995   interface(CONST_INTER);
 2996 %}
 2997 
 2998 // Pointer Immediate: 32-bit
 2999 operand immP32() %{
 3000   predicate(Immediate::is_uimm32(n-&gt;get_ptr()));
 3001   match(ConP);
 3002   op_cost(1);
 3003   format %{ %}
 3004   interface(CONST_INTER);
 3005 %}
 3006 
 3007 // Pointer Immediate: 16-bit
 3008 operand immP16() %{
 3009   predicate(Immediate::is_uimm16(n-&gt;get_ptr()));
 3010   match(ConP);
 3011   op_cost(1);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 // Pointer Immediate: 8-bit
 3017 operand immP8() %{
 3018   predicate(Immediate::is_uimm8(n-&gt;get_ptr()));
 3019   match(ConP);
 3020   op_cost(1);
 3021   format %{ %}
 3022   interface(CONST_INTER);
 3023 %}
 3024 
 3025 //-----------------------------------
 3026 // POINTER specific values
 3027 //-----------------------------------
 3028 
 3029 // Pointer Immediate: NULL
 3030 operand immP0() %{
 3031   predicate(n-&gt;get_ptr() == 0);
 3032   match(ConP);
 3033   op_cost(1);
 3034   format %{ %}
 3035   interface(CONST_INTER);
 3036 %}
 3037 
 3038 //---------------------------------------------
 3039 // NARROW POINTER immediate operands
 3040 //---------------------------------------------
 3041 
 3042 // Narrow Pointer Immediate
 3043 operand immN() %{
 3044   match(ConN);
 3045   op_cost(1);
 3046   format %{ %}
 3047   interface(CONST_INTER);
 3048 %}
 3049 
 3050 operand immNKlass() %{
 3051   match(ConNKlass);
 3052   op_cost(1);
 3053   format %{ %}
 3054   interface(CONST_INTER);
 3055 %}
 3056 
 3057 // Narrow Pointer Immediate
 3058 operand immN8() %{
 3059   predicate(Immediate::is_uimm8(n-&gt;get_narrowcon()));
 3060   match(ConN);
 3061   op_cost(1);
 3062   format %{ %}
 3063   interface(CONST_INTER);
 3064 %}
 3065 
 3066 // Narrow NULL Pointer Immediate
 3067 operand immN0() %{
 3068   predicate(n-&gt;get_narrowcon() == 0);
 3069   match(ConN);
 3070   op_cost(1);
 3071   format %{ %}
 3072   interface(CONST_INTER);
 3073 %}
 3074 
 3075 // FLOAT and DOUBLE immediate operands
 3076 
 3077 // Double Immediate
 3078 operand immD() %{
 3079   match(ConD);
 3080   op_cost(1);
 3081   format %{ %}
 3082   interface(CONST_INTER);
 3083 %}
 3084 
 3085 // Double Immediate: +-0
 3086 operand immDpm0() %{
 3087   predicate(n-&gt;getd() == 0);
 3088   match(ConD);
 3089   op_cost(1);
 3090   format %{ %}
 3091   interface(CONST_INTER);
 3092 %}
 3093 
 3094 // Double Immediate: +0
 3095 operand immDp0() %{
 3096   predicate(jlong_cast(n-&gt;getd()) == 0);
 3097   match(ConD);
 3098   op_cost(1);
 3099   format %{ %}
 3100   interface(CONST_INTER);
 3101 %}
 3102 
 3103 // Float Immediate
 3104 operand immF() %{
 3105   match(ConF);
 3106   op_cost(1);
 3107   format %{ %}
 3108   interface(CONST_INTER);
 3109 %}
 3110 
 3111 // Float Immediate: +-0
 3112 operand immFpm0() %{
 3113   predicate(n-&gt;getf() == 0);
 3114   match(ConF);
 3115   op_cost(1);
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Float Immediate: +0
 3121 operand immFp0() %{
 3122   predicate(jint_cast(n-&gt;getf()) == 0);
 3123   match(ConF);
 3124   op_cost(1);
 3125   format %{ %}
 3126   interface(CONST_INTER);
 3127 %}
 3128 
 3129 // End of Immediate Operands
 3130 
 3131 // Integer Register Operands
 3132 // Integer Register
 3133 operand iRegI() %{
 3134   constraint(ALLOC_IN_RC(z_int_reg));
 3135   match(RegI);
 3136   match(noArg_iRegI);
 3137   match(rarg1RegI);
 3138   match(rarg2RegI);
 3139   match(rarg3RegI);
 3140   match(rarg4RegI);
 3141   match(rarg5RegI);
 3142   match(noOdd_iRegI);
 3143   match(revenRegI);
 3144   match(roddRegI);
 3145   format %{ %}
 3146   interface(REG_INTER);
 3147 %}
 3148 
 3149 operand noArg_iRegI() %{
 3150   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3151   match(RegI);
 3152   format %{ %}
 3153   interface(REG_INTER);
 3154 %}
 3155 
 3156 // revenRegI and roddRegI constitute and even-odd-pair.
 3157 operand revenRegI() %{
 3158   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3159   match(iRegI);
 3160   format %{ %}
 3161   interface(REG_INTER);
 3162 %}
 3163 
 3164 // revenRegI and roddRegI constitute and even-odd-pair.
 3165 operand roddRegI() %{
 3166   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3167   match(iRegI);
 3168   format %{ %}
 3169   interface(REG_INTER);
 3170 %}
 3171 
 3172 operand rarg1RegI() %{
 3173   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3174   match(iRegI);
 3175   format %{ %}
 3176   interface(REG_INTER);
 3177 %}
 3178 
 3179 operand rarg2RegI() %{
 3180   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3181   match(iRegI);
 3182   format %{ %}
 3183   interface(REG_INTER);
 3184 %}
 3185 
 3186 operand rarg3RegI() %{
 3187   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3188   match(iRegI);
 3189   format %{ %}
 3190   interface(REG_INTER);
 3191 %}
 3192 
 3193 operand rarg4RegI() %{
 3194   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3195   match(iRegI);
 3196   format %{ %}
 3197   interface(REG_INTER);
 3198 %}
 3199 
 3200 operand rarg5RegI() %{
 3201   constraint(ALLOC_IN_RC(z_rarg5_int_reg));
 3202   match(iRegI);
 3203   format %{ %}
 3204   interface(REG_INTER);
 3205 %}
 3206 
 3207 operand noOdd_iRegI() %{
 3208   constraint(ALLOC_IN_RC(z_no_odd_int_reg));
 3209   match(RegI);
 3210   match(revenRegI);
 3211   format %{ %}
 3212   interface(REG_INTER);
 3213 %}
 3214 
 3215 // Pointer Register
 3216 operand iRegP() %{
 3217   constraint(ALLOC_IN_RC(z_ptr_reg));
 3218   match(RegP);
 3219   match(noArg_iRegP);
 3220   match(rarg1RegP);
 3221   match(rarg2RegP);
 3222   match(rarg3RegP);
 3223   match(rarg4RegP);
 3224   match(rarg5RegP);
 3225   match(revenRegP);
 3226   match(roddRegP);
 3227   format %{ %}
 3228   interface(REG_INTER);
 3229 %}
 3230 
 3231 // thread operand
 3232 operand threadRegP() %{
 3233   constraint(ALLOC_IN_RC(z_thread_ptr_reg));
 3234   match(RegP);
 3235   format %{ &quot;Z_THREAD&quot; %}
 3236   interface(REG_INTER);
 3237 %}
 3238 
 3239 operand noArg_iRegP() %{
 3240   constraint(ALLOC_IN_RC(z_no_arg_ptr_reg));
 3241   match(iRegP);
 3242   format %{ %}
 3243   interface(REG_INTER);
 3244 %}
 3245 
 3246 operand rarg1RegP() %{
 3247   constraint(ALLOC_IN_RC(z_rarg1_ptr_reg));
 3248   match(iRegP);
 3249   format %{ %}
 3250   interface(REG_INTER);
 3251 %}
 3252 
 3253 operand rarg2RegP() %{
 3254   constraint(ALLOC_IN_RC(z_rarg2_ptr_reg));
 3255   match(iRegP);
 3256   format %{ %}
 3257   interface(REG_INTER);
 3258 %}
 3259 
 3260 operand rarg3RegP() %{
 3261   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3262   match(iRegP);
 3263   format %{ %}
 3264   interface(REG_INTER);
 3265 %}
 3266 
 3267 operand rarg4RegP() %{
 3268   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3269   match(iRegP);
 3270   format %{ %}
 3271   interface(REG_INTER);
 3272 %}
 3273 
 3274 operand rarg5RegP() %{
 3275   constraint(ALLOC_IN_RC(z_rarg5_ptr_reg));
 3276   match(iRegP);
 3277   format %{ %}
 3278   interface(REG_INTER);
 3279 %}
 3280 
 3281 operand memoryRegP() %{
 3282   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3283   match(RegP);
 3284   match(iRegP);
 3285   match(threadRegP);
 3286   format %{ %}
 3287   interface(REG_INTER);
 3288 %}
 3289 
 3290 // revenRegP and roddRegP constitute and even-odd-pair.
 3291 operand revenRegP() %{
 3292   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3293   match(iRegP);
 3294   format %{ %}
 3295   interface(REG_INTER);
 3296 %}
 3297 
 3298 // revenRegP and roddRegP constitute and even-odd-pair.
 3299 operand roddRegP() %{
 3300   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3301   match(iRegP);
 3302   format %{ %}
 3303   interface(REG_INTER);
 3304 %}
 3305 
 3306 operand lock_ptr_RegP() %{
 3307   constraint(ALLOC_IN_RC(z_lock_ptr_reg));
 3308   match(RegP);
 3309   format %{ %}
 3310   interface(REG_INTER);
 3311 %}
 3312 
 3313 operand rscratch2RegP() %{
 3314   constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));
 3315   match(RegP);
 3316   format %{ %}
 3317   interface(REG_INTER);
 3318 %}
 3319 
 3320 operand iRegN() %{
 3321   constraint(ALLOC_IN_RC(z_int_reg));
 3322   match(RegN);
 3323   match(noArg_iRegN);
 3324   match(rarg1RegN);
 3325   match(rarg2RegN);
 3326   match(rarg3RegN);
 3327   match(rarg4RegN);
 3328   match(rarg5RegN);
 3329   format %{ %}
 3330   interface(REG_INTER);
 3331 %}
 3332 
 3333 operand noArg_iRegN() %{
 3334   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3335   match(iRegN);
 3336   format %{ %}
 3337   interface(REG_INTER);
 3338 %}
 3339 
 3340 operand rarg1RegN() %{
 3341   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3342   match(iRegN);
 3343   format %{ %}
 3344   interface(REG_INTER);
 3345 %}
 3346 
 3347 operand rarg2RegN() %{
 3348   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3349   match(iRegN);
 3350   format %{ %}
 3351   interface(REG_INTER);
 3352 %}
 3353 
 3354 operand rarg3RegN() %{
 3355   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3356   match(iRegN);
 3357   format %{ %}
 3358   interface(REG_INTER);
 3359 %}
 3360 
 3361 operand rarg4RegN() %{
 3362   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3363   match(iRegN);
 3364   format %{ %}
 3365   interface(REG_INTER);
 3366 %}
 3367 
 3368 operand rarg5RegN() %{
 3369   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3370   match(iRegN);
 3371   format %{ %}
 3372   interface(REG_INTER);
 3373 %}
 3374 
 3375 // Long Register
 3376 operand iRegL() %{
 3377   constraint(ALLOC_IN_RC(z_long_reg));
 3378   match(RegL);
 3379   match(revenRegL);
 3380   match(roddRegL);
 3381   match(rarg1RegL);
 3382   match(rarg5RegL);
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 // revenRegL and roddRegL constitute and even-odd-pair.
 3388 operand revenRegL() %{
 3389   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3390   match(iRegL);
 3391   format %{ %}
 3392   interface(REG_INTER);
 3393 %}
 3394 
 3395 // revenRegL and roddRegL constitute and even-odd-pair.
 3396 operand roddRegL() %{
 3397   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3398   match(iRegL);
 3399   format %{ %}
 3400   interface(REG_INTER);
 3401 %}
 3402 
 3403 operand rarg1RegL() %{
 3404   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3405   match(iRegL);
 3406   format %{ %}
 3407   interface(REG_INTER);
 3408 %}
 3409 
 3410 operand rarg5RegL() %{
 3411   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3412   match(iRegL);
 3413   format %{ %}
 3414   interface(REG_INTER);
 3415 %}
 3416 
 3417 // Condition Code Flag Registers
 3418 operand flagsReg() %{
 3419   constraint(ALLOC_IN_RC(z_condition_reg));
 3420   match(RegFlags);
 3421   format %{ &quot;CR&quot; %}
 3422   interface(REG_INTER);
 3423 %}
 3424 
 3425 // Condition Code Flag Registers for rules with result tuples
 3426 operand TD_flagsReg() %{
 3427   constraint(ALLOC_IN_RC(z_condition_reg));
 3428   match(RegFlags);
 3429   format %{ &quot;CR&quot; %}
 3430   interface(REG_TUPLE_DEST_INTER);
 3431 %}
 3432 
 3433 operand regD() %{
 3434   constraint(ALLOC_IN_RC(z_dbl_reg));
 3435   match(RegD);
 3436   format %{ %}
 3437   interface(REG_INTER);
 3438 %}
 3439 
 3440 operand rscratchRegD() %{
 3441   constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));
 3442   match(RegD);
 3443   format %{ %}
 3444   interface(REG_INTER);
 3445 %}
 3446 
 3447 operand regF() %{
 3448   constraint(ALLOC_IN_RC(z_flt_reg));
 3449   match(RegF);
 3450   format %{ %}
 3451   interface(REG_INTER);
 3452 %}
 3453 
 3454 operand rscratchRegF() %{
 3455   constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));
 3456   match(RegF);
 3457   format %{ %}
 3458   interface(REG_INTER);
 3459 %}
 3460 
 3461 // Special Registers
 3462 
 3463 // Method Register
 3464 operand inline_cache_regP(iRegP reg) %{
 3465   constraint(ALLOC_IN_RC(z_r9_regP)); // inline_cache_reg
 3466   match(reg);
 3467   format %{ %}
 3468   interface(REG_INTER);
 3469 %}
 3470 
 3471 operand compiler_method_oop_regP(iRegP reg) %{
 3472   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3473   match(reg);
 3474   format %{ %}
 3475   interface(REG_INTER);
 3476 %}
 3477 
 3478 operand interpreter_method_oop_regP(iRegP reg) %{
 3479   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3480   match(reg);
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 // Operands to remove register moves in unscaled mode.
 3486 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3487 operand iRegP2N(iRegP reg) %{
 3488   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);
 3489   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3490   match(EncodeP reg);
 3491   format %{ &quot;$reg&quot; %}
 3492   interface(REG_INTER)
 3493 %}
 3494 
 3495 operand iRegN2P(iRegN reg) %{
 3496   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0 &amp;&amp;
 3497             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3498   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3499   match(DecodeN reg);
 3500   format %{ &quot;$reg&quot; %}
 3501   interface(REG_INTER)
 3502 %}
 3503 
 3504 
 3505 //----------Complex Operands---------------------------------------------------
 3506 
 3507 // Indirect Memory Reference
 3508 operand indirect(memoryRegP base) %{
 3509   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3510   match(base);
 3511   op_cost(1);
 3512   format %{ &quot;#0[,$base]&quot; %}
 3513   interface(MEMORY_INTER) %{
 3514     base($base);
 3515     index(0xffffFFFF); // noreg
 3516     scale(0x0);
 3517     disp(0x0);
 3518   %}
 3519 %}
 3520 
 3521 // Indirect with Offset (long)
 3522 operand indOffset20(memoryRegP base, immL20 offset) %{
 3523   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3524   match(AddP base offset);
 3525   op_cost(1);
 3526   format %{ &quot;$offset[,$base]&quot; %}
 3527   interface(MEMORY_INTER) %{
 3528     base($base);
 3529     index(0xffffFFFF); // noreg
 3530     scale(0x0);
 3531     disp($offset);
 3532   %}
 3533 %}
 3534 
 3535 operand indOffset20Narrow(iRegN base, immL20 offset) %{
 3536   predicate(Matcher::narrow_oop_use_complex_address());
 3537   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3538   match(AddP (DecodeN base) offset);
 3539   op_cost(1);
 3540   format %{ &quot;$offset[,$base]&quot; %}
 3541   interface(MEMORY_INTER) %{
 3542     base($base);
 3543     index(0xffffFFFF); // noreg
 3544     scale(0x0);
 3545     disp($offset);
 3546   %}
 3547 %}
 3548 
 3549 // Indirect with Offset (short)
 3550 operand indOffset12(memoryRegP base, uimmL12 offset) %{
 3551   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3552   match(AddP base offset);
 3553   op_cost(1);
 3554   format %{ &quot;$offset[[,$base]]&quot; %}
 3555   interface(MEMORY_INTER) %{
 3556     base($base);
 3557     index(0xffffFFFF); // noreg
 3558     scale(0x0);
 3559     disp($offset);
 3560   %}
 3561 %}
 3562 
 3563 operand indOffset12Narrow(iRegN base, uimmL12 offset) %{
 3564   predicate(Matcher::narrow_oop_use_complex_address());
 3565   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3566   match(AddP (DecodeN base) offset);
 3567   op_cost(1);
 3568   format %{ &quot;$offset[[,$base]]&quot; %}
 3569   interface(MEMORY_INTER) %{
 3570     base($base);
 3571     index(0xffffFFFF); // noreg
 3572     scale(0x0);
 3573     disp($offset);
 3574   %}
 3575 %}
 3576 
 3577 // Indirect with Register Index
 3578 operand indIndex(memoryRegP base, iRegL index) %{
 3579   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3580   match(AddP base index);
 3581   op_cost(1);
 3582   format %{ &quot;#0[($index,$base)]&quot; %}
 3583   interface(MEMORY_INTER) %{
 3584     base($base);
 3585     index($index);
 3586     scale(0x0);
 3587     disp(0x0);
 3588   %}
 3589 %}
 3590 
 3591 // Indirect with Offset (long) and index
 3592 operand indOffset20index(memoryRegP base, immL20 offset, iRegL index) %{
 3593   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3594   match(AddP (AddP base index) offset);
 3595   op_cost(1);
 3596   format %{ &quot;$offset[($index,$base)]&quot; %}
 3597   interface(MEMORY_INTER) %{
 3598     base($base);
 3599     index($index);
 3600     scale(0x0);
 3601     disp($offset);
 3602   %}
 3603 %}
 3604 
 3605 operand indOffset20indexNarrow(iRegN base, immL20 offset, iRegL index) %{
 3606   predicate(Matcher::narrow_oop_use_complex_address());
 3607   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3608   match(AddP (AddP (DecodeN base) index) offset);
 3609   op_cost(1);
 3610   format %{ &quot;$offset[($index,$base)]&quot; %}
 3611   interface(MEMORY_INTER) %{
 3612     base($base);
 3613     index($index);
 3614     scale(0x0);
 3615     disp($offset);
 3616   %}
 3617 %}
 3618 
 3619 // Indirect with Offset (short) and index
 3620 operand indOffset12index(memoryRegP base, uimmL12 offset, iRegL index) %{
 3621   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3622   match(AddP (AddP base index) offset);
 3623   op_cost(1);
 3624   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3625   interface(MEMORY_INTER) %{
 3626     base($base);
 3627     index($index);
 3628     scale(0x0);
 3629     disp($offset);
 3630   %}
 3631 %}
 3632 
 3633 operand indOffset12indexNarrow(iRegN base, uimmL12 offset, iRegL index) %{
 3634   predicate(Matcher::narrow_oop_use_complex_address());
 3635   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3636   match(AddP (AddP (DecodeN base) index) offset);
 3637   op_cost(1);
 3638   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3639   interface(MEMORY_INTER) %{
 3640     base($base);
 3641     index($index);
 3642     scale(0x0);
 3643     disp($offset);
 3644   %}
 3645 %}
 3646 
 3647 //----------Special Memory Operands--------------------------------------------
 3648 
 3649 // Stack Slot Operand
 3650 // This operand is used for loading and storing temporary values on
 3651 // the stack where a match requires a value to flow through memory.
 3652 operand stackSlotI(sRegI reg) %{
 3653   constraint(ALLOC_IN_RC(stack_slots));
 3654   op_cost(1);
 3655   format %{ &quot;[$reg(stackSlotI)]&quot; %}
 3656   interface(MEMORY_INTER) %{
 3657     base(0xf);   // Z_SP
 3658     index(0xffffFFFF); // noreg
 3659     scale(0x0);
 3660     disp($reg);  // stack offset
 3661   %}
 3662 %}
 3663 
 3664 operand stackSlotP(sRegP reg) %{
 3665   constraint(ALLOC_IN_RC(stack_slots));
 3666   op_cost(1);
 3667   format %{ &quot;[$reg(stackSlotP)]&quot; %}
 3668   interface(MEMORY_INTER) %{
 3669     base(0xf);   // Z_SP
 3670     index(0xffffFFFF); // noreg
 3671     scale(0x0);
 3672     disp($reg);  // Stack Offset
 3673   %}
 3674 %}
 3675 
 3676 operand stackSlotF(sRegF reg) %{
 3677   constraint(ALLOC_IN_RC(stack_slots));
 3678   op_cost(1);
 3679   format %{ &quot;[$reg(stackSlotF)]&quot; %}
 3680   interface(MEMORY_INTER) %{
 3681     base(0xf);   // Z_SP
 3682     index(0xffffFFFF); // noreg
 3683     scale(0x0);
 3684     disp($reg);  // Stack Offset
 3685   %}
 3686 %}
 3687 
 3688 operand stackSlotD(sRegD reg) %{
 3689   constraint(ALLOC_IN_RC(stack_slots));
 3690   op_cost(1);
 3691   //match(RegD);
 3692   format %{ &quot;[$reg(stackSlotD)]&quot; %}
 3693   interface(MEMORY_INTER) %{
 3694     base(0xf);   // Z_SP
 3695     index(0xffffFFFF); // noreg
 3696     scale(0x0);
 3697     disp($reg);  // Stack Offset
 3698   %}
 3699 %}
 3700 
 3701 operand stackSlotL(sRegL reg) %{
 3702   constraint(ALLOC_IN_RC(stack_slots));
 3703   op_cost(1);  //match(RegL);
 3704   format %{ &quot;[$reg(stackSlotL)]&quot; %}
 3705   interface(MEMORY_INTER) %{
 3706     base(0xf);   // Z_SP
 3707     index(0xffffFFFF); // noreg
 3708     scale(0x0);
 3709     disp($reg);  // Stack Offset
 3710   %}
 3711 %}
 3712 
 3713 // Operands for expressing Control Flow
 3714 // NOTE: Label is a predefined operand which should not be redefined in
 3715 // the AD file. It is generically handled within the ADLC.
 3716 
 3717 //----------Conditional Branch Operands----------------------------------------
 3718 // Comparison Op  - This is the operation of the comparison, and is limited to
 3719 //                  the following set of codes:
 3720 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 3721 //
 3722 // Other attributes of the comparison, such as unsignedness, are specified
 3723 // by the comparison instruction that sets a condition code flags register.
 3724 // That result is represented by a flags operand whose subtype is appropriate
 3725 // to the unsignedness (etc.) of the comparison.
 3726 //
 3727 // Later, the instruction which matches both the Comparison Op (a Bool) and
 3728 // the flags (produced by the Cmp) specifies the coding of the comparison op
 3729 // by matching a specific subtype of Bool operand below.
 3730 
 3731 // INT cmpOps for CompareAndBranch and CompareAndTrap instructions should not
 3732 // have mask bit #3 set.
 3733 operand cmpOpT() %{
 3734   match(Bool);
 3735   format %{ &quot;&quot; %}
 3736   interface(COND_INTER) %{
 3737     equal(0x8);         // Assembler::bcondEqual
 3738     not_equal(0x6);     // Assembler::bcondNotEqual
 3739     less(0x4);          // Assembler::bcondLow
 3740     greater_equal(0xa); // Assembler::bcondNotLow
 3741     less_equal(0xc);    // Assembler::bcondNotHigh
 3742     greater(0x2);       // Assembler::bcondHigh
 3743     overflow(0x1);      // Assembler::bcondOverflow
 3744     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3745   %}
 3746 %}
 3747 
 3748 // When used for floating point comparisons: unordered is treated as less.
 3749 operand cmpOpF() %{
 3750   match(Bool);
 3751   format %{ &quot;&quot; %}
 3752   interface(COND_INTER) %{
 3753     equal(0x8);
 3754     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3755     less(0x5);          // Includes &#39;unordered&#39;.
 3756     greater_equal(0xa);
 3757     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3758     greater(0x2);
 3759     overflow(0x0);      // Not meaningful on z/Architecture.
 3760     no_overflow(0x0);   // leave unchanged (zero) therefore
 3761   %}
 3762 %}
 3763 
 3764 // &quot;Regular&quot; cmpOp for int comparisons, includes bit #3 (overflow).
 3765 operand cmpOp() %{
 3766   match(Bool);
 3767   format %{ &quot;&quot; %}
 3768   interface(COND_INTER) %{
 3769     equal(0x8);
 3770     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3771     less(0x5);          // Includes &#39;unordered&#39;.
 3772     greater_equal(0xa);
 3773     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3774     greater(0x2);
 3775     overflow(0x1);      // Assembler::bcondOverflow
 3776     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3777   %}
 3778 %}
 3779 
 3780 //----------OPERAND CLASSES----------------------------------------------------
 3781 // Operand Classes are groups of operands that are used to simplify
 3782 // instruction definitions by not requiring the AD writer to specify
 3783 // seperate instructions for every form of operand when the
 3784 // instruction accepts multiple operand types with the same basic
 3785 // encoding and format.  The classic case of this is memory operands.
 3786 // Indirect is not included since its use is limited to Compare &amp; Swap
 3787 
 3788 // Most general memory operand, allows base, index, and long displacement.
 3789 opclass memory(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3790 opclass memoryRXY(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3791 
 3792 // General memory operand, allows base, index, and short displacement.
 3793 opclass memoryRX(indirect, indIndex, indOffset12, indOffset12Narrow, indOffset12index, indOffset12indexNarrow);
 3794 
 3795 // Memory operand, allows only base and long displacement.
 3796 opclass memoryRSY(indirect, indOffset20, indOffset20Narrow);
 3797 
 3798 // Memory operand, allows only base and short displacement.
 3799 opclass memoryRS(indirect, indOffset12, indOffset12Narrow);
 3800 
 3801 // Operand classes to match encode and decode.
 3802 opclass iRegN_P2N(iRegN);
 3803 opclass iRegP_N2P(iRegP);
 3804 
 3805 
 3806 //----------PIPELINE-----------------------------------------------------------
 3807 pipeline %{
 3808 
 3809 //----------ATTRIBUTES---------------------------------------------------------
 3810 attributes %{
 3811   // z/Architecture instructions are of length 2, 4, or 6 bytes.
 3812   variable_size_instructions;
 3813   instruction_unit_size = 2;
 3814 
 3815   // Meaningless on z/Architecture.
 3816   max_instructions_per_bundle = 1;
 3817 
 3818   // The z/Architecture processor fetches 64 bytes...
 3819   instruction_fetch_unit_size = 64;
 3820 
 3821   // ...in one line.
 3822   instruction_fetch_units = 1
 3823 %}
 3824 
 3825 //----------RESOURCES----------------------------------------------------------
 3826 // Resources are the functional units available to the machine.
 3827 resources(
 3828    Z_BR,     // branch unit
 3829    Z_CR,     // condition unit
 3830    Z_FX1,    // integer arithmetic unit 1
 3831    Z_FX2,    // integer arithmetic unit 2
 3832    Z_LDST1,  // load/store unit 1
 3833    Z_LDST2,  // load/store unit 2
 3834    Z_FP1,    // float arithmetic unit 1
 3835    Z_FP2,    // float arithmetic unit 2
 3836    Z_LDST = Z_LDST1 | Z_LDST2,
 3837    Z_FX   = Z_FX1 | Z_FX2,
 3838    Z_FP   = Z_FP1 | Z_FP2
 3839   );
 3840 
 3841 //----------PIPELINE DESCRIPTION-----------------------------------------------
 3842 // Pipeline Description specifies the stages in the machine&#39;s pipeline.
 3843 pipe_desc(
 3844    // TODO: adapt
 3845    Z_IF,  // instruction fetch
 3846    Z_IC,
 3847    Z_D0,  // decode
 3848    Z_D1,  // decode
 3849    Z_D2,  // decode
 3850    Z_D3,  // decode
 3851    Z_Xfer1,
 3852    Z_GD,  // group definition
 3853    Z_MP,  // map
 3854    Z_ISS, // issue
 3855    Z_RF,  // resource fetch
 3856    Z_EX1, // execute (all units)
 3857    Z_EX2, // execute (FP, LDST)
 3858    Z_EX3, // execute (FP, LDST)
 3859    Z_EX4, // execute (FP)
 3860    Z_EX5, // execute (FP)
 3861    Z_EX6, // execute (FP)
 3862    Z_WB,  // write back
 3863    Z_Xfer2,
 3864    Z_CP
 3865   );
 3866 
 3867 //----------PIPELINE CLASSES---------------------------------------------------
 3868 // Pipeline Classes describe the stages in which input and output are
 3869 // referenced by the hardware pipeline.
 3870 
 3871 // Providing the `ins_pipe&#39; declarations in the instruction
 3872 // specifications seems to be of little use. So we use
 3873 // `pipe_class_dummy&#39; for all our instructions at present.
 3874 pipe_class pipe_class_dummy() %{
 3875   single_instruction;
 3876   fixed_latency(4);
 3877 %}
 3878 
 3879 // SIGTRAP based implicit range checks in compiled code.
 3880 // Currently, no pipe classes are used on z/Architecture.
 3881 pipe_class pipe_class_trap() %{
 3882   single_instruction;
 3883 %}
 3884 
 3885 pipe_class pipe_class_fx_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3886   single_instruction;
 3887   dst  : Z_EX1(write);
 3888   src1 : Z_RF(read);
 3889   src2 : Z_RF(read);
 3890   Z_FX : Z_RF;
 3891 %}
 3892 
 3893 pipe_class pipe_class_ldst(iRegP dst, memory mem) %{
 3894   single_instruction;
 3895   mem : Z_RF(read);
 3896   dst : Z_WB(write);
 3897   Z_LDST : Z_RF;
 3898 %}
 3899 
 3900 define %{
 3901   MachNop = pipe_class_dummy;
 3902 %}
 3903 
 3904 %}
 3905 
 3906 //----------INSTRUCTIONS-------------------------------------------------------
 3907 
 3908 //---------- Chain stack slots between similar types --------
 3909 
 3910 // Load integer from stack slot.
 3911 instruct stkI_to_regI(iRegI dst, stackSlotI src) %{
 3912   match(Set dst src);
 3913   ins_cost(MEMORY_REF_COST);
 3914   // TODO: s390 port size(FIXED_SIZE);
 3915   format %{ &quot;L       $dst,$src\t # stk reload int&quot; %}
 3916   opcode(L_ZOPC);
 3917   ins_encode(z_form_rt_mem(dst, src));
 3918   ins_pipe(pipe_class_dummy);
 3919 %}
 3920 
 3921 // Store integer to stack slot.
 3922 instruct regI_to_stkI(stackSlotI dst, iRegI src) %{
 3923   match(Set dst src);
 3924   ins_cost(MEMORY_REF_COST);
 3925   // TODO: s390 port size(FIXED_SIZE);
 3926   format %{ &quot;ST      $src,$dst\t # stk spill int&quot; %}
 3927   opcode(ST_ZOPC);
 3928   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3929   ins_pipe(pipe_class_dummy);
 3930 %}
 3931 
 3932 // Load long from stack slot.
 3933 instruct stkL_to_regL(iRegL dst, stackSlotL src) %{
 3934   match(Set dst src);
 3935   ins_cost(MEMORY_REF_COST);
 3936   // TODO: s390 port size(FIXED_SIZE);
 3937   format %{ &quot;LG      $dst,$src\t # stk reload long&quot; %}
 3938   opcode(LG_ZOPC);
 3939   ins_encode(z_form_rt_mem(dst, src));
 3940   ins_pipe(pipe_class_dummy);
 3941 %}
 3942 
 3943 // Store long to stack slot.
 3944 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 3945   match(Set dst src);
 3946   ins_cost(MEMORY_REF_COST);
 3947   size(6);
 3948   format %{ &quot;STG     $src,$dst\t # stk spill long&quot; %}
 3949   opcode(STG_ZOPC);
 3950   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3951   ins_pipe(pipe_class_dummy);
 3952 %}
 3953 
 3954 // Load pointer from stack slot, 64-bit encoding.
 3955 instruct stkP_to_regP(iRegP dst, stackSlotP src) %{
 3956   match(Set dst src);
 3957   ins_cost(MEMORY_REF_COST);
 3958   // TODO: s390 port size(FIXED_SIZE);
 3959   format %{ &quot;LG      $dst,$src\t # stk reload ptr&quot; %}
 3960   opcode(LG_ZOPC);
 3961   ins_encode(z_form_rt_mem(dst, src));
 3962   ins_pipe(pipe_class_dummy);
 3963 %}
 3964 
 3965 // Store pointer to stack slot.
 3966 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 3967   match(Set dst src);
 3968   ins_cost(MEMORY_REF_COST);
 3969   // TODO: s390 port size(FIXED_SIZE);
 3970   format %{ &quot;STG     $src,$dst\t # stk spill ptr&quot; %}
 3971   opcode(STG_ZOPC);
 3972   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3973   ins_pipe(pipe_class_dummy);
 3974 %}
 3975 
 3976 //  Float types
 3977 
 3978 // Load float value from stack slot.
 3979 instruct stkF_to_regF(regF dst, stackSlotF src) %{
 3980   match(Set dst src);
 3981   ins_cost(MEMORY_REF_COST);
 3982   size(4);
 3983   format %{ &quot;LE(Y)   $dst,$src\t # stk reload float&quot; %}
 3984   opcode(LE_ZOPC);
 3985   ins_encode(z_form_rt_mem(dst, src));
 3986   ins_pipe(pipe_class_dummy);
 3987 %}
 3988 
 3989 // Store float value to stack slot.
 3990 instruct regF_to_stkF(stackSlotF dst, regF src) %{
 3991   match(Set dst src);
 3992   ins_cost(MEMORY_REF_COST);
 3993   size(4);
 3994   format %{ &quot;STE(Y)  $src,$dst\t # stk spill float&quot; %}
 3995   opcode(STE_ZOPC);
 3996   ins_encode(z_form_rt_mem(src, dst));
 3997   ins_pipe(pipe_class_dummy);
 3998 %}
 3999 
 4000 // Load double value from stack slot.
 4001 instruct stkD_to_regD(regD dst, stackSlotD src) %{
 4002   match(Set dst src);
 4003   ins_cost(MEMORY_REF_COST);
 4004   // TODO: s390 port size(FIXED_SIZE);
 4005   format %{ &quot;LD(Y)   $dst,$src\t # stk reload double&quot; %}
 4006   opcode(LD_ZOPC);
 4007   ins_encode(z_form_rt_mem(dst, src));
 4008   ins_pipe(pipe_class_dummy);
 4009 %}
 4010 
 4011 // Store double value to stack slot.
 4012 instruct regD_to_stkD(stackSlotD dst, regD src) %{
 4013   match(Set dst src);
 4014   ins_cost(MEMORY_REF_COST);
 4015   size(4);
 4016   format %{ &quot;STD(Y)  $src,$dst\t # stk spill double&quot; %}
 4017   opcode(STD_ZOPC);
 4018   ins_encode(z_form_rt_mem(src, dst));
 4019   ins_pipe(pipe_class_dummy);
 4020 %}
 4021 
 4022 //----------Load/Store/Move Instructions---------------------------------------
 4023 
 4024 //----------Load Instructions--------------------------------------------------
 4025 
 4026 //------------------
 4027 //  MEMORY
 4028 //------------------
 4029 
 4030 //  BYTE
 4031 // Load Byte (8bit signed)
 4032 instruct loadB(iRegI dst, memory mem) %{
 4033   match(Set dst (LoadB mem));
 4034   ins_cost(MEMORY_REF_COST);
 4035   size(Z_DISP3_SIZE);
 4036   format %{ &quot;LB      $dst, $mem\t # sign-extend byte to int&quot; %}
 4037   opcode(LB_ZOPC, LB_ZOPC);
 4038   ins_encode(z_form_rt_mem_opt(dst, mem));
 4039   ins_pipe(pipe_class_dummy);
 4040 %}
 4041 
 4042 // Load Byte (8bit signed)
 4043 instruct loadB2L(iRegL dst, memory mem) %{
 4044   match(Set dst (ConvI2L (LoadB mem)));
 4045   ins_cost(MEMORY_REF_COST);
 4046   size(Z_DISP3_SIZE);
 4047   format %{ &quot;LGB     $dst, $mem\t # sign-extend byte to long&quot; %}
 4048   opcode(LGB_ZOPC, LGB_ZOPC);
 4049   ins_encode(z_form_rt_mem_opt(dst, mem));
 4050   ins_pipe(pipe_class_dummy);
 4051 %}
 4052 
 4053 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 4054 instruct loadUB(iRegI dst, memory mem) %{
 4055   match(Set dst (LoadUB mem));
 4056   ins_cost(MEMORY_REF_COST);
 4057   size(Z_DISP3_SIZE);
 4058   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to int&quot; %}
 4059   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4060   ins_encode(z_form_rt_mem_opt(dst, mem));
 4061   ins_pipe(pipe_class_dummy);
 4062 %}
 4063 
 4064 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 4065 instruct loadUB2L(iRegL dst, memory mem) %{
 4066   match(Set dst (ConvI2L (LoadUB mem)));
 4067   ins_cost(MEMORY_REF_COST);
 4068   size(Z_DISP3_SIZE);
 4069   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to long&quot; %}
 4070   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4071   ins_encode(z_form_rt_mem_opt(dst, mem));
 4072   ins_pipe(pipe_class_dummy);
 4073 %}
 4074 
 4075 // CHAR/SHORT
 4076 
 4077 // Load Short (16bit signed)
 4078 instruct loadS(iRegI dst, memory mem) %{
 4079   match(Set dst (LoadS mem));
 4080   ins_cost(MEMORY_REF_COST);
 4081   size(Z_DISP_SIZE);
 4082   format %{ &quot;LH(Y)   $dst,$mem\t # sign-extend short to int&quot; %}
 4083   opcode(LHY_ZOPC, LH_ZOPC);
 4084   ins_encode(z_form_rt_mem_opt(dst, mem));
 4085   ins_pipe(pipe_class_dummy);
 4086 %}
 4087 
 4088 // Load Short (16bit signed)
 4089 instruct loadS2L(iRegL dst, memory mem) %{
 4090   match(Set dst (ConvI2L (LoadS mem)));
 4091   ins_cost(MEMORY_REF_COST);
 4092   size(Z_DISP3_SIZE);
 4093   format %{ &quot;LGH     $dst,$mem\t # sign-extend short to long&quot; %}
 4094   opcode(LGH_ZOPC, LGH_ZOPC);
 4095   ins_encode(z_form_rt_mem_opt(dst, mem));
 4096   ins_pipe(pipe_class_dummy);
 4097 %}
 4098 
 4099 // Load Char (16bit Unsigned)
 4100 instruct loadUS(iRegI dst, memory mem) %{
 4101   match(Set dst (LoadUS mem));
 4102   ins_cost(MEMORY_REF_COST);
 4103   size(Z_DISP3_SIZE);
 4104   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to int&quot; %}
 4105   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4106   ins_encode(z_form_rt_mem_opt(dst, mem));
 4107   ins_pipe(pipe_class_dummy);
 4108 %}
 4109 
 4110 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 4111 instruct loadUS2L(iRegL dst, memory mem) %{
 4112   match(Set dst (ConvI2L (LoadUS mem)));
 4113   ins_cost(MEMORY_REF_COST);
 4114   size(Z_DISP3_SIZE);
 4115   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to long&quot; %}
 4116   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4117   ins_encode(z_form_rt_mem_opt(dst, mem));
 4118   ins_pipe(pipe_class_dummy);
 4119 %}
 4120 
 4121 // INT
 4122 
 4123 // Load Integer
 4124 instruct loadI(iRegI dst, memory mem) %{
 4125   match(Set dst (LoadI mem));
 4126   ins_cost(MEMORY_REF_COST);
 4127   size(Z_DISP_SIZE);
 4128   format %{ &quot;L(Y)    $dst,$mem\t #&quot; %}
 4129   opcode(LY_ZOPC, L_ZOPC);
 4130   ins_encode(z_form_rt_mem_opt(dst, mem));
 4131   ins_pipe(pipe_class_dummy);
 4132 %}
 4133 
 4134 // Load and convert to long.
 4135 instruct loadI2L(iRegL dst, memory mem) %{
 4136   match(Set dst (ConvI2L (LoadI mem)));
 4137   ins_cost(MEMORY_REF_COST);
 4138   size(Z_DISP3_SIZE);
 4139   format %{ &quot;LGF     $dst,$mem\t #&quot; %}
 4140   opcode(LGF_ZOPC, LGF_ZOPC);
 4141   ins_encode(z_form_rt_mem_opt(dst, mem));
 4142   ins_pipe(pipe_class_dummy);
 4143 %}
 4144 
 4145 // Load Unsigned Integer into a Long Register
 4146 instruct loadUI2L(iRegL dst, memory mem, immL_FFFFFFFF mask) %{
 4147   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 4148   ins_cost(MEMORY_REF_COST);
 4149   size(Z_DISP3_SIZE);
 4150   format %{ &quot;LLGF    $dst,$mem\t # zero-extend int to long&quot; %}
 4151   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4152   ins_encode(z_form_rt_mem_opt(dst, mem));
 4153   ins_pipe(pipe_class_dummy);
 4154 %}
 4155 
 4156 // range = array length (=jint)
 4157 // Load Range
 4158 instruct loadRange(iRegI dst, memory mem) %{
 4159   match(Set dst (LoadRange mem));
 4160   ins_cost(MEMORY_REF_COST);
 4161   size(Z_DISP_SIZE);
 4162   format %{ &quot;L(Y)    $dst,$mem\t # range&quot; %}
 4163   opcode(LY_ZOPC, L_ZOPC);
 4164   ins_encode(z_form_rt_mem_opt(dst, mem));
 4165   ins_pipe(pipe_class_dummy);
 4166 %}
 4167 
 4168 // LONG
 4169 
 4170 // Load Long - aligned
 4171 instruct loadL(iRegL dst, memory mem) %{
 4172   match(Set dst (LoadL mem));
 4173   ins_cost(MEMORY_REF_COST);
 4174   size(Z_DISP3_SIZE);
 4175   format %{ &quot;LG      $dst,$mem\t # long&quot; %}
 4176   opcode(LG_ZOPC, LG_ZOPC);
 4177   ins_encode(z_form_rt_mem_opt(dst, mem));
 4178   ins_pipe(pipe_class_dummy);
 4179 %}
 4180 
 4181 // Load Long - UNaligned
 4182 instruct loadL_unaligned(iRegL dst, memory mem) %{
 4183   match(Set dst (LoadL_unaligned mem));
 4184   ins_cost(MEMORY_REF_COST);
 4185   size(Z_DISP3_SIZE);
 4186   format %{ &quot;LG      $dst,$mem\t # unaligned long&quot; %}
 4187   opcode(LG_ZOPC, LG_ZOPC);
 4188   ins_encode(z_form_rt_mem_opt(dst, mem));
 4189   ins_pipe(pipe_class_dummy);
 4190 %}
 4191 
 4192 
 4193 // PTR
 4194 
 4195 // Load Pointer
 4196 instruct loadP(iRegP dst, memory mem) %{
 4197   match(Set dst (LoadP mem));
 4198   ins_cost(MEMORY_REF_COST);
 4199   size(Z_DISP3_SIZE);
 4200   format %{ &quot;LG      $dst,$mem\t # ptr&quot; %}
 4201   opcode(LG_ZOPC, LG_ZOPC);
 4202   ins_encode(z_form_rt_mem_opt(dst, mem));
 4203   ins_pipe(pipe_class_dummy);
 4204 %}
 4205 
 4206 // LoadP + CastP2L
 4207 instruct castP2X_loadP(iRegL dst, memory mem) %{
 4208   match(Set dst (CastP2X (LoadP mem)));
 4209   ins_cost(MEMORY_REF_COST);
 4210   size(Z_DISP3_SIZE);
 4211   format %{ &quot;LG      $dst,$mem\t # ptr + p2x&quot; %}
 4212   opcode(LG_ZOPC, LG_ZOPC);
 4213   ins_encode(z_form_rt_mem_opt(dst, mem));
 4214   ins_pipe(pipe_class_dummy);
 4215 %}
 4216 
 4217 // Load Klass Pointer
 4218 instruct loadKlass(iRegP dst, memory mem) %{
 4219   match(Set dst (LoadKlass mem));
 4220   ins_cost(MEMORY_REF_COST);
 4221   size(Z_DISP3_SIZE);
 4222   format %{ &quot;LG      $dst,$mem\t # klass ptr&quot; %}
 4223   opcode(LG_ZOPC, LG_ZOPC);
 4224   ins_encode(z_form_rt_mem_opt(dst, mem));
 4225   ins_pipe(pipe_class_dummy);
 4226 %}
 4227 
 4228 instruct loadTOC(iRegL dst) %{
 4229   effect(DEF dst);
 4230   ins_cost(DEFAULT_COST);
 4231   // TODO: s390 port size(FIXED_SIZE);
 4232   // TODO: check why this attribute causes many unnecessary rematerializations.
 4233   //
 4234   // The graphs I saw just had high register pressure. Further the
 4235   // register TOC is loaded to is overwritten by the constant short
 4236   // after. Here something as round robin register allocation might
 4237   // help. But rematerializing seems not to hurt, jack even seems to
 4238   // improve slightly.
 4239   //
 4240   // Without this flag we get spill-split recycle sanity check
 4241   // failures in
 4242   // spec.benchmarks._228_jack.NfaState::GenerateCode. This happens in
 4243   // a block with three loadConP_dynTOC nodes and a tlsLoadP. The
 4244   // tlsLoadP has a huge amount of outs and forces the TOC down to the
 4245   // stack. Later tlsLoadP is rematerialized, leaving the register
 4246   // allocator with TOC on the stack and a badly placed reload.
 4247   ins_should_rematerialize(true);
 4248   format %{ &quot;LARL    $dst, &amp;constant_pool\t; load dynTOC&quot; %}
 4249   ins_encode %{ __ load_toc($dst$$Register); %}
 4250   ins_pipe(pipe_class_dummy);
 4251 %}
 4252 
 4253 // FLOAT
 4254 
 4255 // Load Float
 4256 instruct loadF(regF dst, memory mem) %{
 4257   match(Set dst (LoadF mem));
 4258   ins_cost(MEMORY_REF_COST);
 4259   size(Z_DISP_SIZE);
 4260   format %{ &quot;LE(Y)    $dst,$mem&quot; %}
 4261   opcode(LEY_ZOPC, LE_ZOPC);
 4262   ins_encode(z_form_rt_mem_opt(dst, mem));
 4263   ins_pipe(pipe_class_dummy);
 4264 %}
 4265 
 4266 // DOUBLE
 4267 
 4268 // Load Double
 4269 instruct loadD(regD dst, memory mem) %{
 4270   match(Set dst (LoadD mem));
 4271   ins_cost(MEMORY_REF_COST);
 4272   size(Z_DISP_SIZE);
 4273   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4274   opcode(LDY_ZOPC, LD_ZOPC);
 4275   ins_encode(z_form_rt_mem_opt(dst, mem));
 4276   ins_pipe(pipe_class_dummy);
 4277 %}
 4278 
 4279 // Load Double - UNaligned
 4280 instruct loadD_unaligned(regD dst, memory mem) %{
 4281   match(Set dst (LoadD_unaligned mem));
 4282   ins_cost(MEMORY_REF_COST);
 4283   size(Z_DISP_SIZE);
 4284   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4285   opcode(LDY_ZOPC, LD_ZOPC);
 4286   ins_encode(z_form_rt_mem_opt(dst, mem));
 4287   ins_pipe(pipe_class_dummy);
 4288 %}
 4289 
 4290 
 4291 //----------------------
 4292 //  IMMEDIATES
 4293 //----------------------
 4294 
 4295 instruct loadConI(iRegI dst, immI src) %{
 4296   match(Set dst src);
 4297   ins_cost(DEFAULT_COST);
 4298   size(6);
 4299   format %{ &quot;LGFI     $dst,$src\t # (int)&quot; %}
 4300   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4301   ins_pipe(pipe_class_dummy);
 4302 %}
 4303 
 4304 instruct loadConI16(iRegI dst, immI16 src) %{
 4305   match(Set dst src);
 4306   ins_cost(DEFAULT_COST_LOW);
 4307   size(4);
 4308   format %{ &quot;LGHI     $dst,$src\t # (int)&quot; %}
 4309   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4310   ins_pipe(pipe_class_dummy);
 4311 %}
 4312 
 4313 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4314   match(Set dst src);
 4315   effect(KILL cr);
 4316   ins_cost(DEFAULT_COST_LOW);
 4317   size(4);
 4318   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4319   opcode(XGR_ZOPC);
 4320   ins_encode(z_rreform(dst, dst));
 4321   ins_pipe(pipe_class_dummy);
 4322 %}
 4323 
 4324 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4325   match(Set dst src);
 4326   // TODO: s390 port size(FIXED_SIZE);
 4327   format %{ &quot;LLILL    $dst,$src&quot; %}
 4328   opcode(LLILL_ZOPC);
 4329   ins_encode(z_riform_unsigned(dst, src) );
 4330   ins_pipe(pipe_class_dummy);
 4331 %}
 4332 
 4333 // Load long constant from TOC with pcrelative address.
 4334 instruct loadConL_pcrelTOC(iRegL dst, immL src) %{
 4335   match(Set dst src);
 4336   ins_cost(MEMORY_REF_COST_LO);
 4337   size(6);
 4338   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load long $src from table&quot; %}
 4339   ins_encode %{
 4340     address long_address = __ long_constant($src$$constant);
 4341     if (long_address == NULL) {
 4342       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4343       return;
 4344     }
 4345     __ load_long_pcrelative($dst$$Register, long_address);
 4346   %}
 4347   ins_pipe(pipe_class_dummy);
 4348 %}
 4349 
 4350 instruct loadConL32(iRegL dst, immL32 src) %{
 4351   match(Set dst src);
 4352   ins_cost(DEFAULT_COST);
 4353   size(6);
 4354   format %{ &quot;LGFI     $dst,$src\t # (long)&quot; %}
 4355   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4356   ins_pipe(pipe_class_dummy);
 4357 %}
 4358 
 4359 instruct loadConL16(iRegL dst, immL16 src) %{
 4360   match(Set dst src);
 4361   ins_cost(DEFAULT_COST_LOW);
 4362   size(4);
 4363   format %{ &quot;LGHI     $dst,$src\t # (long)&quot; %}
 4364   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4365   ins_pipe(pipe_class_dummy);
 4366 %}
 4367 
 4368 instruct loadConL_0(iRegL dst, immL_0 src, flagsReg cr) %{
 4369   match(Set dst src);
 4370   effect(KILL cr);
 4371   ins_cost(DEFAULT_COST_LOW);
 4372   format %{ &quot;LoadConL    $dst,$src\t # (long) XGR because ZERO is loaded&quot; %}
 4373   opcode(XGR_ZOPC);
 4374   ins_encode(z_rreform(dst, dst));
 4375   ins_pipe(pipe_class_dummy);
 4376 %}
 4377 
 4378 // Load ptr constant from TOC with pc relative address.
 4379 // Special handling for oop constants required.
 4380 instruct loadConP_pcrelTOC(iRegP dst, immP src) %{
 4381   match(Set dst src);
 4382   ins_cost(MEMORY_REF_COST_LO);
 4383   size(6);
 4384   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load ptr $src from table&quot; %}
 4385   ins_encode %{
 4386     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();
 4387     if (constant_reloc == relocInfo::oop_type) {
 4388       AddressLiteral a = __ allocate_oop_address((jobject)$src$$constant);
 4389       bool success = __ load_oop_from_toc($dst$$Register, a);
 4390       if (!success) {
 4391         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4392         return;
 4393       }
 4394     } else if (constant_reloc == relocInfo::metadata_type) {
 4395       AddressLiteral a = __ constant_metadata_address((Metadata *)$src$$constant);
 4396       address const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 4397       if (const_toc_addr == NULL) {
 4398         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4399         return;
 4400       }
 4401       __ load_long_pcrelative($dst$$Register, const_toc_addr);
 4402     } else {          // Non-oop pointers, e.g. card mark base, heap top.
 4403       address long_address = __ long_constant((jlong)$src$$constant);
 4404       if (long_address == NULL) {
 4405         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4406         return;
 4407       }
 4408       __ load_long_pcrelative($dst$$Register, long_address);
 4409     }
 4410   %}
 4411   ins_pipe(pipe_class_dummy);
 4412 %}
 4413 
 4414 // We don&#39;t use immP16 to avoid problems with oops.
 4415 instruct loadConP0(iRegP dst, immP0 src, flagsReg cr) %{
 4416   match(Set dst src);
 4417   effect(KILL cr);
 4418   size(4);
 4419   format %{ &quot;XGR     $dst,$dst\t # NULL ptr&quot; %}
 4420   opcode(XGR_ZOPC);
 4421   ins_encode(z_rreform(dst, dst));
 4422   ins_pipe(pipe_class_dummy);
 4423 %}
 4424 
 4425 //----------Load Float Constant Instructions-------------------------------------------------
 4426 
 4427 // We may not specify this instruction via an `expand&#39; rule. If we do,
 4428 // code selection will forget that this instruction needs a floating
 4429 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4430 // will fail.
 4431 instruct loadConF_dynTOC(regF dst, immF src, flagsReg cr) %{
 4432   match(Set dst src);
 4433   effect(KILL cr);
 4434   ins_cost(MEMORY_REF_COST);
 4435   size(6);
 4436   // If this instruction rematerializes, it prolongs the live range
 4437   // of the toc node, causing illegal graphs.
 4438   ins_cannot_rematerialize(true);
 4439   format %{ &quot;LE(Y)    $dst,$constantoffset[,$constanttablebase]\t # load FLOAT $src from table&quot; %}
 4440   ins_encode %{
 4441     __ load_float_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4442   %}
 4443   ins_pipe(pipe_class_dummy);
 4444 %}
 4445 
 4446 // E may not specify this instruction via an `expand&#39; rule. If we do,
 4447 // code selection will forget that this instruction needs a floating
 4448 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4449 // will fail.
 4450 instruct loadConD_dynTOC(regD dst, immD src, flagsReg cr) %{
 4451   match(Set dst src);
 4452   effect(KILL cr);
 4453   ins_cost(MEMORY_REF_COST);
 4454   size(6);
 4455   // If this instruction rematerializes, it prolongs the live range
 4456   // of the toc node, causing illegal graphs.
 4457   ins_cannot_rematerialize(true);
 4458   format %{ &quot;LD(Y)    $dst,$constantoffset[,$constanttablebase]\t # load DOUBLE $src from table&quot; %}
 4459   ins_encode %{
 4460     __ load_double_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4461   %}
 4462   ins_pipe(pipe_class_dummy);
 4463 %}
 4464 
 4465 // Special case: Load Const 0.0F
 4466 
 4467 // There&#39;s a special instr to clear a FP register.
 4468 instruct loadConF0(regF dst, immFp0 src) %{
 4469   match(Set dst src);
 4470   ins_cost(DEFAULT_COST_LOW);
 4471   size(4);
 4472   format %{ &quot;LZER     $dst,$src\t # clear to zero&quot; %}
 4473   opcode(LZER_ZOPC);
 4474   ins_encode(z_rreform(dst, Z_F0));
 4475   ins_pipe(pipe_class_dummy);
 4476 %}
 4477 
 4478 // There&#39;s a special instr to clear a FP register.
 4479 instruct loadConD0(regD dst, immDp0 src) %{
 4480   match(Set dst src);
 4481   ins_cost(DEFAULT_COST_LOW);
 4482   size(4);
 4483   format %{ &quot;LZDR     $dst,$src\t # clear to zero&quot; %}
 4484   opcode(LZDR_ZOPC);
 4485   ins_encode(z_rreform(dst, Z_F0));
 4486   ins_pipe(pipe_class_dummy);
 4487 %}
 4488 
 4489 
 4490 //----------Store Instructions-------------------------------------------------
 4491 
 4492 // BYTE
 4493 
 4494 // Store Byte
 4495 instruct storeB(memory mem, iRegI src) %{
 4496   match(Set mem (StoreB mem src));
 4497   ins_cost(MEMORY_REF_COST);
 4498   size(Z_DISP_SIZE);
 4499   format %{ &quot;STC(Y)  $src,$mem\t # byte&quot; %}
 4500   opcode(STCY_ZOPC, STC_ZOPC);
 4501   ins_encode(z_form_rt_mem_opt(src, mem));
 4502   ins_pipe(pipe_class_dummy);
 4503 %}
 4504 
 4505 instruct storeCM(memory mem, immI_0 src) %{
 4506   match(Set mem (StoreCM mem src));
 4507   ins_cost(MEMORY_REF_COST);
 4508   // TODO: s390 port size(VARIABLE_SIZE);
 4509   format %{ &quot;STC(Y)  $src,$mem\t # CMS card-mark byte (must be 0!)&quot; %}
 4510   ins_encode %{
 4511     guarantee($mem$$index$$Register != Z_R0, &quot;content will not be used.&quot;);
 4512     if ($mem$$index$$Register != noreg) {
 4513       // Can&#39;t use clear_mem --&gt; load const zero and store character.
 4514       __ load_const_optimized(Z_R0_scratch, (long)0);
 4515       if (Immediate::is_uimm12($mem$$disp)) {
 4516         __ z_stc(Z_R0_scratch, $mem$$Address);
 4517       } else {
 4518         __ z_stcy(Z_R0_scratch, $mem$$Address);
 4519       }
 4520     } else {
 4521       __ clear_mem(Address($mem$$Address), 1);
 4522     }
 4523   %}
 4524   ins_pipe(pipe_class_dummy);
 4525 %}
 4526 
 4527 // CHAR/SHORT
 4528 
 4529 // Store Char/Short
 4530 instruct storeC(memory mem, iRegI src) %{
 4531   match(Set mem (StoreC mem src));
 4532   ins_cost(MEMORY_REF_COST);
 4533   size(Z_DISP_SIZE);
 4534   format %{ &quot;STH(Y)  $src,$mem\t # short&quot; %}
 4535   opcode(STHY_ZOPC, STH_ZOPC);
 4536   ins_encode(z_form_rt_mem_opt(src, mem));
 4537   ins_pipe(pipe_class_dummy);
 4538 %}
 4539 
 4540 // INT
 4541 
 4542 // Store Integer
 4543 instruct storeI(memory mem, iRegI src) %{
 4544   match(Set mem (StoreI mem src));
 4545   ins_cost(MEMORY_REF_COST);
 4546   size(Z_DISP_SIZE);
 4547   format %{ &quot;ST(Y)   $src,$mem\t # int&quot; %}
 4548   opcode(STY_ZOPC, ST_ZOPC);
 4549   ins_encode(z_form_rt_mem_opt(src, mem));
 4550   ins_pipe(pipe_class_dummy);
 4551 %}
 4552 
 4553 // LONG
 4554 
 4555 // Store Long
 4556 instruct storeL(memory mem, iRegL src) %{
 4557   match(Set mem (StoreL mem src));
 4558   ins_cost(MEMORY_REF_COST);
 4559   size(Z_DISP3_SIZE);
 4560   format %{ &quot;STG     $src,$mem\t # long&quot; %}
 4561   opcode(STG_ZOPC, STG_ZOPC);
 4562   ins_encode(z_form_rt_mem_opt(src, mem));
 4563   ins_pipe(pipe_class_dummy);
 4564 %}
 4565 
 4566 // PTR
 4567 
 4568 // Store Pointer
 4569 instruct storeP(memory dst, memoryRegP src) %{
 4570   match(Set dst (StoreP dst src));
 4571   ins_cost(MEMORY_REF_COST);
 4572   size(Z_DISP3_SIZE);
 4573   format %{ &quot;STG     $src,$dst\t # ptr&quot; %}
 4574   opcode(STG_ZOPC, STG_ZOPC);
 4575   ins_encode(z_form_rt_mem_opt(src, dst));
 4576   ins_pipe(pipe_class_dummy);
 4577 %}
 4578 
 4579 // FLOAT
 4580 
 4581 // Store Float
 4582 instruct storeF(memory mem, regF src) %{
 4583   match(Set mem (StoreF mem src));
 4584   ins_cost(MEMORY_REF_COST);
 4585   size(Z_DISP_SIZE);
 4586   format %{ &quot;STE(Y)   $src,$mem\t # float&quot; %}
 4587   opcode(STEY_ZOPC, STE_ZOPC);
 4588   ins_encode(z_form_rt_mem_opt(src, mem));
 4589   ins_pipe(pipe_class_dummy);
 4590 %}
 4591 
 4592 // DOUBLE
 4593 
 4594 // Store Double
 4595 instruct storeD(memory mem, regD src) %{
 4596   match(Set mem (StoreD mem src));
 4597   ins_cost(MEMORY_REF_COST);
 4598   size(Z_DISP_SIZE);
 4599   format %{ &quot;STD(Y)   $src,$mem\t # double&quot; %}
 4600   opcode(STDY_ZOPC, STD_ZOPC);
 4601   ins_encode(z_form_rt_mem_opt(src, mem));
 4602   ins_pipe(pipe_class_dummy);
 4603 %}
 4604 
 4605 // Prefetch instructions. Must be safe to execute with invalid address (cannot fault).
 4606 
 4607 // Should support match rule for PrefetchAllocation.
 4608 // Still needed after 8068977 for PrefetchAllocate.
 4609 instruct prefetchAlloc(memory mem) %{
 4610   match(PrefetchAllocation mem);
 4611   predicate(VM_Version::has_Prefetch());
 4612   ins_cost(DEFAULT_COST);
 4613   format %{ &quot;PREFETCH 2, $mem\t # Prefetch allocation, z10 only&quot; %}
 4614   ins_encode %{ __ z_pfd(0x02, $mem$$Address); %}
 4615   ins_pipe(pipe_class_dummy);
 4616 %}
 4617 
 4618 //----------Memory init instructions------------------------------------------
 4619 
 4620 // Move Immediate to 1-byte memory.
 4621 instruct memInitB(memoryRSY mem, immI8 src) %{
 4622   match(Set mem (StoreB mem src));
 4623   ins_cost(MEMORY_REF_COST);
 4624   // TODO: s390 port size(VARIABLE_SIZE);
 4625   format %{ &quot;MVI     $mem,$src\t # direct mem init 1&quot; %}
 4626   ins_encode %{
 4627     if (Immediate::is_uimm12((long)$mem$$disp)) {
 4628       __ z_mvi($mem$$Address, $src$$constant);
 4629     } else {
 4630       __ z_mviy($mem$$Address, $src$$constant);
 4631     }
 4632   %}
 4633   ins_pipe(pipe_class_dummy);
 4634 %}
 4635 
 4636 // Move Immediate to 2-byte memory.
 4637 instruct memInitC(memoryRS mem, immI16 src) %{
 4638   match(Set mem (StoreC mem src));
 4639   ins_cost(MEMORY_REF_COST);
 4640   size(6);
 4641   format %{ &quot;MVHHI   $mem,$src\t # direct mem init 2&quot; %}
 4642   opcode(MVHHI_ZOPC);
 4643   ins_encode(z_silform(mem, src));
 4644   ins_pipe(pipe_class_dummy);
 4645 %}
 4646 
 4647 // Move Immediate to 4-byte memory.
 4648 instruct memInitI(memoryRS mem, immI16 src) %{
 4649   match(Set mem (StoreI mem src));
 4650   ins_cost(MEMORY_REF_COST);
 4651   size(6);
 4652   format %{ &quot;MVHI    $mem,$src\t # direct mem init 4&quot; %}
 4653   opcode(MVHI_ZOPC);
 4654   ins_encode(z_silform(mem, src));
 4655   ins_pipe(pipe_class_dummy);
 4656 %}
 4657 
 4658 
 4659 // Move Immediate to 8-byte memory.
 4660 instruct memInitL(memoryRS mem, immL16 src) %{
 4661   match(Set mem (StoreL mem src));
 4662   ins_cost(MEMORY_REF_COST);
 4663   size(6);
 4664   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4665   opcode(MVGHI_ZOPC);
 4666   ins_encode(z_silform(mem, src));
 4667   ins_pipe(pipe_class_dummy);
 4668 %}
 4669 
 4670 // Move Immediate to 8-byte memory.
 4671 instruct memInitP(memoryRS mem, immP16 src) %{
 4672   match(Set mem (StoreP mem src));
 4673   ins_cost(MEMORY_REF_COST);
 4674   size(6);
 4675   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4676   opcode(MVGHI_ZOPC);
 4677   ins_encode(z_silform(mem, src));
 4678   ins_pipe(pipe_class_dummy);
 4679 %}
 4680 
 4681 
 4682 //----------Instructions for compressed pointers (cOop and NKlass)-------------
 4683 
 4684 // See cOop encoding classes for elaborate comment.
 4685 
 4686 // Moved here because it is needed in expand rules for encode.
 4687 // Long negation.
 4688 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4689   match(Set dst (SubL zero src));
 4690   effect(KILL cr);
 4691   size(4);
 4692   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4693   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4694   ins_pipe(pipe_class_dummy);
 4695 %}
 4696 
 4697 // Load Compressed Pointer
 4698 
 4699 // Load narrow oop
 4700 instruct loadN(iRegN dst, memory mem) %{
 4701   match(Set dst (LoadN mem));
 4702   ins_cost(MEMORY_REF_COST);
 4703   size(Z_DISP3_SIZE);
 4704   format %{ &quot;LoadN  $dst,$mem\t# (cOop)&quot; %}
 4705   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4706   ins_encode(z_form_rt_mem_opt(dst, mem));
 4707   ins_pipe(pipe_class_dummy);
 4708 %}
 4709 
 4710 // Load narrow Klass Pointer
 4711 instruct loadNKlass(iRegN dst, memory mem) %{
 4712   match(Set dst (LoadNKlass mem));
 4713   ins_cost(MEMORY_REF_COST);
 4714   size(Z_DISP3_SIZE);
 4715   format %{ &quot;LoadNKlass $dst,$mem\t# (klass cOop)&quot; %}
 4716   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4717   ins_encode(z_form_rt_mem_opt(dst, mem));
 4718   ins_pipe(pipe_class_dummy);
 4719 %}
 4720 
 4721 // Load constant Compressed Pointer
 4722 
 4723 instruct loadConN(iRegN dst, immN src) %{
 4724   match(Set dst src);
 4725   ins_cost(DEFAULT_COST);
 4726   size(6);
 4727   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4728   ins_encode %{
 4729     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4730     __ relocate(cOop.rspec(), 1);
 4731     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4732   %}
 4733   ins_pipe(pipe_class_dummy);
 4734 %}
 4735 
 4736 instruct loadConN0(iRegN dst, immN0 src, flagsReg cr) %{
 4737   match(Set dst src);
 4738   effect(KILL cr);
 4739   ins_cost(DEFAULT_COST_LOW);
 4740   size(4);
 4741   format %{ &quot;loadConN    $dst,$src\t # (cOop) XGR because ZERO is loaded&quot; %}
 4742   opcode(XGR_ZOPC);
 4743   ins_encode(z_rreform(dst, dst));
 4744   ins_pipe(pipe_class_dummy);
 4745 %}
 4746 
 4747 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4748   match(Set dst src);
 4749   ins_cost(DEFAULT_COST);
 4750   size(6);
 4751   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4752   ins_encode %{
 4753     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4754     __ relocate(NKlass.rspec(), 1);
 4755     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4756   %}
 4757   ins_pipe(pipe_class_dummy);
 4758 %}
 4759 
 4760 // Load and Decode Compressed Pointer
 4761 // optimized variants for Unscaled cOops
 4762 
 4763 instruct decodeLoadN(iRegP dst, memory mem) %{
 4764   match(Set dst (DecodeN (LoadN mem)));
 4765   predicate(false &amp;&amp; (Universe::narrow_oop_base()==NULL)&amp;&amp;(Universe::narrow_oop_shift()==0));
 4766   ins_cost(MEMORY_REF_COST);
 4767   size(Z_DISP3_SIZE);
 4768   format %{ &quot;DecodeLoadN  $dst,$mem\t# (cOop Load+Decode)&quot; %}
 4769   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4770   ins_encode(z_form_rt_mem_opt(dst, mem));
 4771   ins_pipe(pipe_class_dummy);
 4772 %}
 4773 
 4774 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4775   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 4776   predicate(false &amp;&amp; (Universe::narrow_klass_base()==NULL)&amp;&amp;(Universe::narrow_klass_shift()==0));
 4777   ins_cost(MEMORY_REF_COST);
 4778   size(Z_DISP3_SIZE);
 4779   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t# (load/decode NKlass)&quot; %}
 4780   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4781   ins_encode(z_form_rt_mem_opt(dst, mem));
 4782   ins_pipe(pipe_class_dummy);
 4783 %}
 4784 
 4785 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4786   match(Set dst (DecodeNKlass src));
 4787   ins_cost(3 * DEFAULT_COST);
 4788   size(12);
 4789   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4790   ins_encode %{
 4791     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4792     __ relocate(NKlass.rspec(), 1);
 4793     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4794   %}
 4795   ins_pipe(pipe_class_dummy);
 4796 %}
 4797 
 4798 // Decode Compressed Pointer
 4799 
 4800 // General decoder
 4801 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4802   match(Set dst (DecodeN src));
 4803   effect(KILL cr);
 4804   predicate(Universe::narrow_oop_base() == NULL || !ExpandLoadingBaseDecode);
 4805   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4806   // TODO: s390 port size(VARIABLE_SIZE);
 4807   format %{ &quot;decodeN  $dst,$src\t# (decode cOop)&quot; %}
 4808   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4809   ins_pipe(pipe_class_dummy);
 4810 %}
 4811 
 4812 // General Klass decoder
 4813 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4814   match(Set dst (DecodeNKlass src));
 4815   effect(KILL cr);
 4816   ins_cost(3 * DEFAULT_COST);
 4817   format %{ &quot;decode_klass $dst,$src&quot; %}
 4818   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4819   ins_pipe(pipe_class_dummy);
 4820 %}
 4821 
 4822 // General decoder
 4823 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4824   match(Set dst (DecodeN src));
 4825   effect(KILL cr);
 4826   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4827              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4828             (Universe::narrow_oop_base()== NULL || !ExpandLoadingBaseDecode_NN));
 4829   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4830   // TODO: s390 port size(VARIABLE_SIZE);
 4831   format %{ &quot;decodeN  $dst,$src\t# (decode cOop NN)&quot; %}
 4832   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4833   ins_pipe(pipe_class_dummy);
 4834 %}
 4835 
 4836   instruct loadBase(iRegL dst, immL baseImm) %{
 4837     effect(DEF dst, USE baseImm);
 4838     predicate(false);
 4839     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4840     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4841     ins_pipe(pipe_class_dummy);
 4842   %}
 4843 
 4844   // Decoder for heapbased mode peeling off loading the base.
 4845   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4846     match(Set dst (DecodeN src base));
 4847     // Note: Effect TEMP dst was used with the intention to get
 4848     // different regs for dst and base, but this has caused ADLC to
 4849     // generate wrong code. Oop_decoder generates additional lgr when
 4850     // dst==base.
 4851     effect(KILL cr);
 4852     predicate(false);
 4853     // TODO: s390 port size(VARIABLE_SIZE);
 4854     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}
 4855     ins_encode %{
 4856       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
 4857                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));
 4858     %}
 4859     ins_pipe(pipe_class_dummy);
 4860   %}
 4861 
 4862   // Decoder for heapbased mode peeling off loading the base.
 4863   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4864     match(Set dst (DecodeN src base));
 4865     effect(KILL cr);
 4866     predicate(false);
 4867     // TODO: s390 port size(VARIABLE_SIZE);
 4868     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}
 4869     ins_encode %{
 4870       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
 4871                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));
 4872     %}
 4873     ins_pipe(pipe_class_dummy);
 4874   %}
 4875 
 4876 // Decoder for heapbased mode peeling off loading the base.
 4877 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4878   match(Set dst (DecodeN src));
 4879   predicate(Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode);
 4880   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4881   // TODO: s390 port size(VARIABLE_SIZE);
 4882   expand %{
 4883     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}
 4884     iRegL base;
 4885     loadBase(base, baseImm);
 4886     decodeN_base(dst, src, base, cr);
 4887   %}
 4888 %}
 4889 
 4890 // Decoder for heapbased mode peeling off loading the base.
 4891 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4892   match(Set dst (DecodeN src));
 4893   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4894              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4895             Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);
 4896   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4897   // TODO: s390 port size(VARIABLE_SIZE);
 4898   expand %{
 4899     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}
 4900     iRegL base;
 4901     loadBase(base, baseImm);
 4902     decodeN_NN_base(dst, src, base, cr);
 4903   %}
 4904 %}
 4905 
 4906 //  Encode Compressed Pointer
 4907 
 4908 // General encoder
 4909 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4910   match(Set dst (EncodeP src));
 4911   effect(KILL cr);
 4912   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4913             (Universe::narrow_oop_base() == 0 ||
 4914              Universe::narrow_oop_base_disjoint() ||
 4915              !ExpandLoadingBaseEncode));
 4916   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4917   // TODO: s390 port size(VARIABLE_SIZE);
 4918   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}
 4919   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4920   ins_pipe(pipe_class_dummy);
 4921 %}
 4922 
 4923 // General class encoder
 4924 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4925   match(Set dst (EncodePKlass src));
 4926   effect(KILL cr);
 4927   format %{ &quot;encode_klass $dst,$src&quot; %}
 4928   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4929   ins_pipe(pipe_class_dummy);
 4930 %}
 4931 
 4932 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4933   match(Set dst (EncodeP src));
 4934   effect(KILL cr);
 4935   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 4936             (Universe::narrow_oop_base() == 0 ||
 4937              Universe::narrow_oop_base_disjoint() ||
 4938              !ExpandLoadingBaseEncode_NN));
 4939   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4940   // TODO: s390 port size(VARIABLE_SIZE);
 4941   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}
 4942   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4943   ins_pipe(pipe_class_dummy);
 4944 %}
 4945 
 4946   // Encoder for heapbased mode peeling off loading the base.
 4947   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 4948     match(Set dst (EncodeP src (Binary base dst)));
 4949     effect(TEMP_DEF dst);
 4950     predicate(false);
 4951     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4952     // TODO: s390 port size(VARIABLE_SIZE);
 4953     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t# (encode cOop)&quot; %}
 4954     ins_encode %{
 4955       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
 4956         (((uint64_t)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift());
 4957       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 4958     %}
 4959     ins_pipe(pipe_class_dummy);
 4960   %}
 4961 
 4962   // Encoder for heapbased mode peeling off loading the base.
 4963   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 4964     match(Set dst (EncodeP src base));
 4965     effect(USE pow2_offset);
 4966     predicate(false);
 4967     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4968     // TODO: s390 port size(VARIABLE_SIZE);
 4969     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t# (encode cOop)&quot; %}
 4970     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 4971     ins_pipe(pipe_class_dummy);
 4972   %}
 4973 
 4974 // Encoder for heapbased mode peeling off loading the base.
 4975 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 4976   match(Set dst (EncodeP src));
 4977   effect(KILL cr);
 4978   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4979             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));
 4980   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4981   // TODO: s390 port size(VARIABLE_SIZE);
 4982   expand %{
 4983     immL baseImm %{ ((jlong)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift() %}
 4984     immL_0 zero %{ (0) %}
 4985     flagsReg ccr;
 4986     iRegL base;
 4987     iRegL negBase;
 4988     loadBase(base, baseImm);
 4989     negL_reg_reg(negBase, zero, base, ccr);
 4990     encodeP_base(dst, src, negBase);
 4991   %}
 4992 %}
 4993 
 4994 // Encoder for heapbased mode peeling off loading the base.
 4995 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 4996   match(Set dst (EncodeP src));
 4997   effect(KILL cr);
 4998   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 4999             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));
 5000   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5001   // TODO: s390 port size(VARIABLE_SIZE);
 5002   expand %{
 5003     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}
 5004     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)Universe::narrow_oop_base())) %}
 5005     immL_0 zero %{ 0 %}
 5006     flagsReg ccr;
 5007     iRegL base;
 5008     iRegL negBase;
 5009     loadBase(base, baseImm);
 5010     negL_reg_reg(negBase, zero, base, ccr);
 5011     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5012   %}
 5013 %}
 5014 
 5015 //  Store Compressed Pointer
 5016 
 5017 // Store Compressed Pointer
 5018 instruct storeN(memory mem, iRegN_P2N src) %{
 5019   match(Set mem (StoreN mem src));
 5020   ins_cost(MEMORY_REF_COST);
 5021   size(Z_DISP_SIZE);
 5022   format %{ &quot;ST      $src,$mem\t# (cOop)&quot; %}
 5023   opcode(STY_ZOPC, ST_ZOPC);
 5024   ins_encode(z_form_rt_mem_opt(src, mem));
 5025   ins_pipe(pipe_class_dummy);
 5026 %}
 5027 
 5028 // Store Compressed Klass pointer
 5029 instruct storeNKlass(memory mem, iRegN src) %{
 5030   match(Set mem (StoreNKlass mem src));
 5031   ins_cost(MEMORY_REF_COST);
 5032   size(Z_DISP_SIZE);
 5033   format %{ &quot;ST      $src,$mem\t# (cKlass)&quot; %}
 5034   opcode(STY_ZOPC, ST_ZOPC);
 5035   ins_encode(z_form_rt_mem_opt(src, mem));
 5036   ins_pipe(pipe_class_dummy);
 5037 %}
 5038 
 5039 // Compare Compressed Pointers
 5040 
 5041 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5042   match(Set cr (CmpN src1 src2));
 5043   ins_cost(DEFAULT_COST);
 5044   size(2);
 5045   format %{ &quot;CLR     $src1,$src2\t# (cOop)&quot; %}
 5046   opcode(CLR_ZOPC);
 5047   ins_encode(z_rrform(src1, src2));
 5048   ins_pipe(pipe_class_dummy);
 5049 %}
 5050 
 5051 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5052   match(Set cr (CmpN src1 src2));
 5053   ins_cost(DEFAULT_COST);
 5054   size(6);
 5055   format %{ &quot;CLFI    $src1,$src2\t# (cOop) compare immediate narrow&quot; %}
 5056   ins_encode %{
 5057     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5058     __ relocate(cOop.rspec(), 1);
 5059     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5060   %}
 5061   ins_pipe(pipe_class_dummy);
 5062 %}
 5063 
 5064 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5065   match(Set cr (CmpN src1 src2));
 5066   ins_cost(DEFAULT_COST);
 5067   size(6);
 5068   format %{ &quot;CLFI    $src1,$src2\t# (NKlass) compare immediate narrow&quot; %}
 5069   ins_encode %{
 5070     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5071     __ relocate(NKlass.rspec(), 1);
 5072     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5073   %}
 5074   ins_pipe(pipe_class_dummy);
 5075 %}
 5076 
 5077 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5078   match(Set cr (CmpN src1 src2));
 5079   ins_cost(DEFAULT_COST);
 5080   size(2);
 5081   format %{ &quot;LTR     $src1,$src2\t# (cOop) LTR because comparing against zero&quot; %}
 5082   opcode(LTR_ZOPC);
 5083   ins_encode(z_rrform(src1, src1));
 5084   ins_pipe(pipe_class_dummy);
 5085 %}
 5086 
 5087 
 5088 //----------MemBar Instructions-----------------------------------------------
 5089 
 5090 // Memory barrier flavors
 5091 
 5092 instruct membar_acquire() %{
 5093   match(MemBarAcquire);
 5094   match(LoadFence);
 5095   ins_cost(4*MEMORY_REF_COST);
 5096   size(0);
 5097   format %{ &quot;MEMBAR-acquire&quot; %}
 5098   ins_encode %{ __ z_acquire(); %}
 5099   ins_pipe(pipe_class_dummy);
 5100 %}
 5101 
 5102 instruct membar_acquire_lock() %{
 5103   match(MemBarAcquireLock);
 5104   ins_cost(0);
 5105   size(0);
 5106   format %{ &quot;MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 5107   ins_encode(/*empty*/);
 5108   ins_pipe(pipe_class_dummy);
 5109 %}
 5110 
 5111 instruct membar_release() %{
 5112   match(MemBarRelease);
 5113   match(StoreFence);
 5114   ins_cost(4 * MEMORY_REF_COST);
 5115   size(0);
 5116   format %{ &quot;MEMBAR-release&quot; %}
 5117   ins_encode %{ __ z_release(); %}
 5118   ins_pipe(pipe_class_dummy);
 5119 %}
 5120 
 5121 instruct membar_release_lock() %{
 5122   match(MemBarReleaseLock);
 5123   ins_cost(0);
 5124   size(0);
 5125   format %{ &quot;MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 5126   ins_encode(/*empty*/);
 5127   ins_pipe(pipe_class_dummy);
 5128 %}
 5129 
 5130 instruct membar_volatile() %{
 5131   match(MemBarVolatile);
 5132   ins_cost(4 * MEMORY_REF_COST);
 5133   size(2);
 5134   format %{ &quot;MEMBAR-volatile&quot; %}
 5135   ins_encode %{ __ z_fence(); %}
 5136   ins_pipe(pipe_class_dummy);
 5137 %}
 5138 
 5139 instruct unnecessary_membar_volatile() %{
 5140   match(MemBarVolatile);
 5141   predicate(Matcher::post_store_load_barrier(n));
 5142   ins_cost(0);
 5143   size(0);
 5144   format %{ &quot;# MEMBAR-volatile (empty)&quot; %}
 5145   ins_encode(/*empty*/);
 5146   ins_pipe(pipe_class_dummy);
 5147 %}
 5148 
 5149 instruct membar_CPUOrder() %{
 5150   match(MemBarCPUOrder);
 5151   ins_cost(0);
 5152   // TODO: s390 port size(FIXED_SIZE);
 5153   format %{ &quot;MEMBAR-CPUOrder (empty)&quot; %}
 5154   ins_encode(/*empty*/);
 5155   ins_pipe(pipe_class_dummy);
 5156 %}
 5157 
 5158 instruct membar_storestore() %{
 5159   match(MemBarStoreStore);
 5160   ins_cost(0);
 5161   size(0);
 5162   format %{ &quot;MEMBAR-storestore (empty)&quot; %}
 5163   ins_encode();
 5164   ins_pipe(pipe_class_dummy);
 5165 %}
 5166 
 5167 
 5168 //----------Register Move Instructions-----------------------------------------
 5169 instruct roundDouble_nop(regD dst) %{
 5170   match(Set dst (RoundDouble dst));
 5171   ins_cost(0);
 5172   // TODO: s390 port size(FIXED_SIZE);
 5173   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5174   ins_encode();
 5175   ins_pipe(pipe_class_dummy);
 5176 %}
 5177 
 5178 instruct roundFloat_nop(regF dst) %{
 5179   match(Set dst (RoundFloat dst));
 5180   ins_cost(0);
 5181   // TODO: s390 port size(FIXED_SIZE);
 5182   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5183   ins_encode();
 5184   ins_pipe(pipe_class_dummy);
 5185 %}
 5186 
 5187 // Cast Long to Pointer for unsafe natives.
 5188 instruct castX2P(iRegP dst, iRegL src) %{
 5189   match(Set dst (CastX2P src));
 5190   // TODO: s390 port size(VARIABLE_SIZE);
 5191   format %{ &quot;LGR     $dst,$src\t # CastX2P&quot; %}
 5192   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5193   ins_pipe(pipe_class_dummy);
 5194 %}
 5195 
 5196 // Cast Pointer to Long for unsafe natives.
 5197 instruct castP2X(iRegL dst, iRegP_N2P src) %{
 5198   match(Set dst (CastP2X src));
 5199   // TODO: s390 port size(VARIABLE_SIZE);
 5200   format %{ &quot;LGR     $dst,$src\t # CastP2X&quot; %}
 5201   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5202   ins_pipe(pipe_class_dummy);
 5203 %}
 5204 
 5205 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 5206   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5207   match(Set stkSlot src);   // chain rule
 5208   ins_cost(MEMORY_REF_COST);
 5209   // TODO: s390 port size(FIXED_SIZE);
 5210   format %{ &quot; STD   $src,$stkSlot\t # stk&quot; %}
 5211   opcode(STD_ZOPC);
 5212   ins_encode(z_form_rt_mem(src, stkSlot));
 5213   ins_pipe(pipe_class_dummy);
 5214 %}
 5215 
 5216 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 5217   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5218   match(Set stkSlot src);   // chain rule
 5219   ins_cost(MEMORY_REF_COST);
 5220   // TODO: s390 port size(FIXED_SIZE);
 5221   format %{ &quot;STE   $src,$stkSlot\t # stk&quot; %}
 5222   opcode(STE_ZOPC);
 5223   ins_encode(z_form_rt_mem(src, stkSlot));
 5224   ins_pipe(pipe_class_dummy);
 5225 %}
 5226 
 5227 //----------Conditional Move---------------------------------------------------
 5228 
 5229 instruct cmovN_reg(cmpOp cmp, flagsReg cr, iRegN dst, iRegN_P2N src) %{
 5230   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5231   ins_cost(DEFAULT_COST + BRANCH_COST);
 5232   // TODO: s390 port size(VARIABLE_SIZE);
 5233   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5234   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5235   ins_pipe(pipe_class_dummy);
 5236 %}
 5237 
 5238 instruct cmovN_imm(cmpOp cmp, flagsReg cr, iRegN dst, immN0 src) %{
 5239   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5240   ins_cost(DEFAULT_COST + BRANCH_COST);
 5241   // TODO: s390 port size(VARIABLE_SIZE);
 5242   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5243   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5244   ins_pipe(pipe_class_dummy);
 5245 %}
 5246 
 5247 instruct cmovI_reg(cmpOp cmp, flagsReg cr, iRegI dst, iRegI src) %{
 5248   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5249   ins_cost(DEFAULT_COST + BRANCH_COST);
 5250   // TODO: s390 port size(VARIABLE_SIZE);
 5251   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5252   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5253   ins_pipe(pipe_class_dummy);
 5254 %}
 5255 
 5256 instruct cmovI_imm(cmpOp cmp, flagsReg cr, iRegI dst, immI16 src) %{
 5257   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5258   ins_cost(DEFAULT_COST + BRANCH_COST);
 5259   // TODO: s390 port size(VARIABLE_SIZE);
 5260   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5261   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5262   ins_pipe(pipe_class_dummy);
 5263 %}
 5264 
 5265 instruct cmovP_reg(cmpOp cmp, flagsReg cr, iRegP dst, iRegP_N2P src) %{
 5266   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5267   ins_cost(DEFAULT_COST + BRANCH_COST);
 5268   // TODO: s390 port size(VARIABLE_SIZE);
 5269   format %{ &quot;CMoveP,$cmp    $dst,$src&quot; %}
 5270   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5271   ins_pipe(pipe_class_dummy);
 5272 %}
 5273 
 5274 instruct cmovP_imm(cmpOp cmp, flagsReg cr, iRegP dst, immP0 src) %{
 5275   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5276   ins_cost(DEFAULT_COST + BRANCH_COST);
 5277   // TODO: s390 port size(VARIABLE_SIZE);
 5278   format %{ &quot;CMoveP,$cmp  $dst,$src&quot; %}
 5279   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5280   ins_pipe(pipe_class_dummy);
 5281 %}
 5282 
 5283 instruct cmovF_reg(cmpOpF cmp, flagsReg cr, regF dst, regF src) %{
 5284   match(Set dst (CMoveF (Binary cmp cr) (Binary dst src)));
 5285   ins_cost(DEFAULT_COST + BRANCH_COST);
 5286   // TODO: s390 port size(VARIABLE_SIZE);
 5287   format %{ &quot;CMoveF,$cmp   $dst,$src&quot; %}
 5288   ins_encode %{
 5289     // Don&#39;t emit code if operands are identical (same register).
 5290     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5291       Label done;
 5292       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5293       __ z_ler($dst$$FloatRegister, $src$$FloatRegister);
 5294       __ bind(done);
 5295     }
 5296   %}
 5297   ins_pipe(pipe_class_dummy);
 5298 %}
 5299 
 5300 instruct cmovD_reg(cmpOpF cmp, flagsReg cr, regD dst, regD src) %{
 5301   match(Set dst (CMoveD (Binary cmp cr) (Binary dst src)));
 5302   ins_cost(DEFAULT_COST + BRANCH_COST);
 5303   // TODO: s390 port size(VARIABLE_SIZE);
 5304   format %{ &quot;CMoveD,$cmp   $dst,$src&quot; %}
 5305   ins_encode %{
 5306     // Don&#39;t emit code if operands are identical (same register).
 5307     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5308       Label done;
 5309       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5310       __ z_ldr($dst$$FloatRegister, $src$$FloatRegister);
 5311       __ bind(done);
 5312     }
 5313   %}
 5314   ins_pipe(pipe_class_dummy);
 5315 %}
 5316 
 5317 instruct cmovL_reg(cmpOp cmp, flagsReg cr, iRegL dst, iRegL src) %{
 5318   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5319   ins_cost(DEFAULT_COST + BRANCH_COST);
 5320   // TODO: s390 port size(VARIABLE_SIZE);
 5321   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5322   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5323   ins_pipe(pipe_class_dummy);
 5324 %}
 5325 
 5326 instruct cmovL_imm(cmpOp cmp, flagsReg cr, iRegL dst, immL16 src) %{
 5327   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5328   ins_cost(DEFAULT_COST + BRANCH_COST);
 5329   // TODO: s390 port size(VARIABLE_SIZE);
 5330   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5331   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5332   ins_pipe(pipe_class_dummy);
 5333 %}
 5334 
 5335 //----------OS and Locking Instructions----------------------------------------
 5336 
 5337 // This name is KNOWN by the ADLC and cannot be changed.
 5338 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5339 // for this guy.
 5340 instruct tlsLoadP(threadRegP dst) %{
 5341   match(Set dst (ThreadLocal));
 5342   ins_cost(0);
 5343   size(0);
 5344   ins_should_rematerialize(true);
 5345   format %{ &quot;# $dst=ThreadLocal&quot; %}
 5346   ins_encode(/* empty */);
 5347   ins_pipe(pipe_class_dummy);
 5348 %}
 5349 
 5350 instruct checkCastPP(iRegP dst) %{
 5351   match(Set dst (CheckCastPP dst));
 5352   size(0);
 5353   format %{ &quot;# checkcastPP of $dst&quot; %}
 5354   ins_encode(/*empty*/);
 5355   ins_pipe(pipe_class_dummy);
 5356 %}
 5357 
 5358 instruct castPP(iRegP dst) %{
 5359   match(Set dst (CastPP dst));
 5360   size(0);
 5361   format %{ &quot;# castPP of $dst&quot; %}
 5362   ins_encode(/*empty*/);
 5363   ins_pipe(pipe_class_dummy);
 5364 %}
 5365 
 5366 instruct castII(iRegI dst) %{
 5367   match(Set dst (CastII dst));
 5368   size(0);
 5369   format %{ &quot;# castII of $dst&quot; %}
 5370   ins_encode(/*empty*/);
 5371   ins_pipe(pipe_class_dummy);
 5372 %}
 5373 
 5374 
 5375 //----------Conditional_store--------------------------------------------------
 5376 // Conditional-store of the updated heap-top.
 5377 // Used during allocation of the shared heap.
 5378 // Sets flags (EQ) on success.
 5379 
 5380 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5381 // by storePConditional.
 5382 // Don&#39;t know whether this is ever used.
 5383 instruct loadPLocked(iRegP dst, memory mem) %{
 5384   match(Set dst (LoadPLocked mem));
 5385   ins_cost(MEMORY_REF_COST);
 5386   size(Z_DISP3_SIZE);
 5387   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5388   opcode(LG_ZOPC, LG_ZOPC);
 5389   ins_encode(z_form_rt_mem_opt(dst, mem));
 5390   ins_pipe(pipe_class_dummy);
 5391 %}
 5392 
 5393 // As compareAndSwapP, but return flag register instead of boolean value in
 5394 // int register.
 5395 // This instruction is matched if UseTLAB is off. Needed to pass
 5396 // option tests.  Mem_ptr must be a memory operand, else this node
 5397 // does not get Flag_needs_anti_dependence_check set by adlc. If this
 5398 // is not set this node can be rematerialized which leads to errors.
 5399 instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{
 5400   match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));
 5401   effect(KILL oldval);
 5402   // TODO: s390 port size(FIXED_SIZE);
 5403   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5404   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5405   ins_pipe(pipe_class_dummy);
 5406 %}
 5407 
 5408 // As compareAndSwapL, but return flag register instead of boolean value in
 5409 // int register.
 5410 // Used by sun/misc/AtomicLongCSImpl.java. Mem_ptr must be a memory
 5411 // operand, else this node does not get
 5412 // Flag_needs_anti_dependence_check set by adlc. If this is not set
 5413 // this node can be rematerialized which leads to errors.
 5414 instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{
 5415   match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));
 5416   effect(KILL oldval);
 5417   // TODO: s390 port size(FIXED_SIZE);
 5418   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5419   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5420   ins_pipe(pipe_class_dummy);
 5421 %}
 5422 
 5423 // No flag versions for CompareAndSwap{P,I,L,N} because matcher can&#39;t match them.
 5424 
 5425 instruct compareAndSwapI_bool(iRegP mem_ptr, rarg5RegI oldval, iRegI newval, iRegI res, flagsReg cr) %{
 5426   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 5427   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5428   size(16);
 5429   format %{ &quot;$res = CompareAndSwapI $oldval,$newval,$mem_ptr&quot; %}
 5430   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5431              z_enc_cctobool(res));
 5432   ins_pipe(pipe_class_dummy);
 5433 %}
 5434 
 5435 instruct compareAndSwapL_bool(iRegP mem_ptr, rarg5RegL oldval, iRegL newval, iRegI res, flagsReg cr) %{
 5436   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 5437   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5438   size(18);
 5439   format %{ &quot;$res = CompareAndSwapL $oldval,$newval,$mem_ptr&quot; %}
 5440   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5441              z_enc_cctobool(res));
 5442   ins_pipe(pipe_class_dummy);
 5443 %}
 5444 
 5445 instruct compareAndSwapP_bool(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, flagsReg cr) %{
 5446   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 5447   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5448   size(18);
 5449   format %{ &quot;$res = CompareAndSwapP $oldval,$newval,$mem_ptr&quot; %}
 5450   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5451              z_enc_cctobool(res));
 5452   ins_pipe(pipe_class_dummy);
 5453 %}
 5454 
 5455 instruct compareAndSwapN_bool(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, flagsReg cr) %{
 5456   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 5457   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5458   size(16);
 5459   format %{ &quot;$res = CompareAndSwapN $oldval,$newval,$mem_ptr&quot; %}
 5460   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5461              z_enc_cctobool(res));
 5462   ins_pipe(pipe_class_dummy);
 5463 %}
 5464 
 5465 //----------Atomic operations on memory (GetAndSet*, GetAndAdd*)---------------
 5466 
 5467 // Exploit: direct memory arithmetic
 5468 // Prereqs: - instructions available
 5469 //          - instructions guarantee atomicity
 5470 //          - immediate operand to be added
 5471 //          - immediate operand is small enough (8-bit signed).
 5472 //          - result of instruction is not used
 5473 instruct addI_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immI8 src, flagsReg cr) %{
 5474   match(Set dummy (GetAndAddI mem src));
 5475   effect(KILL cr);
 5476   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5477   ins_cost(MEMORY_REF_COST);
 5478   size(6);
 5479   format %{ &quot;ASI     [$mem],$src\t # GetAndAddI (atomic)&quot; %}
 5480   opcode(ASI_ZOPC);
 5481   ins_encode(z_siyform(mem, src));
 5482   ins_pipe(pipe_class_dummy);
 5483 %}
 5484 
 5485 // Fallback: direct memory arithmetic not available
 5486 // Disadvantages: - CS-Loop required, very expensive.
 5487 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5488 instruct addI_mem_imm16_atomic(memoryRSY mem, iRegI dst, immI16 src, iRegI tmp, flagsReg cr) %{
 5489   match(Set dst (GetAndAddI mem src));
 5490   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5491   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5492   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5493             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5494             &quot;  AHIK    $tmp,$dst,$src\n\t&quot;
 5495             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5496             &quot;  retry if failed\n\t&quot;
 5497             &quot;} END ATOMIC&quot;
 5498          %}
 5499   ins_encode %{
 5500     Register Rdst = $dst$$Register;
 5501     Register Rtmp = $tmp$$Register;
 5502     int      Isrc = $src$$constant;
 5503     Label    retry;
 5504 
 5505     // Iterate until update with incremented value succeeds.
 5506     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5507     __ bind(retry);
 5508       // Calculate incremented value.
 5509       if (VM_Version::has_DistinctOpnds()) {
 5510         __ z_ahik(Rtmp, Rdst, Isrc);
 5511       } else {
 5512         __ z_lr(Rtmp, Rdst);
 5513         __ z_ahi(Rtmp, Isrc);
 5514       }
 5515       // Swap into memory location.
 5516       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5517     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5518   %}
 5519   ins_pipe(pipe_class_dummy);
 5520 %}
 5521 
 5522 instruct addI_mem_imm32_atomic(memoryRSY mem, iRegI dst, immI src, iRegI tmp, flagsReg cr) %{
 5523   match(Set dst (GetAndAddI mem src));
 5524   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5525   ins_cost(MEMORY_REF_COST+200*DEFAULT_COST);
 5526   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5527             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5528             &quot;  LGR     $tmp,$dst\n\t&quot;
 5529             &quot;  AFI     $tmp,$src\n\t&quot;
 5530             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5531             &quot;  retry if failed\n\t&quot;
 5532             &quot;} END ATOMIC&quot;
 5533          %}
 5534   ins_encode %{
 5535     Register Rdst = $dst$$Register;
 5536     Register Rtmp = $tmp$$Register;
 5537     int      Isrc = $src$$constant;
 5538     Label    retry;
 5539 
 5540     // Iterate until update with incremented value succeeds.
 5541     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5542     __ bind(retry);
 5543       // Calculate incremented value.
 5544       __ z_lr(Rtmp, Rdst);
 5545       __ z_afi(Rtmp, Isrc);
 5546       // Swap into memory location.
 5547       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5548     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5549   %}
 5550   ins_pipe(pipe_class_dummy);
 5551 %}
 5552 
 5553 instruct addI_mem_reg_atomic(memoryRSY mem, iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
 5554   match(Set dst (GetAndAddI mem src));
 5555   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5556   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5557   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5558             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5559             &quot;  ARK     $tmp,$dst,$src\n\t&quot;
 5560             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5561             &quot;  retry if failed\n\t&quot;
 5562             &quot;} END ATOMIC&quot;
 5563          %}
 5564   ins_encode %{
 5565     Register Rsrc = $src$$Register;
 5566     Register Rdst = $dst$$Register;
 5567     Register Rtmp = $tmp$$Register;
 5568     Label    retry;
 5569 
 5570     // Iterate until update with incremented value succeeds.
 5571     __ z_lgf(Rdst, $mem$$Address);  // current contents
 5572     __ bind(retry);
 5573       // Calculate incremented value.
 5574       if (VM_Version::has_DistinctOpnds()) {
 5575         __ z_ark(Rtmp, Rdst, Rsrc);
 5576       } else {
 5577         __ z_lr(Rtmp, Rdst);
 5578         __ z_ar(Rtmp, Rsrc);
 5579       }
 5580       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5581     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5582   %}
 5583   ins_pipe(pipe_class_dummy);
 5584 %}
 5585 
 5586 
 5587 // Exploit: direct memory arithmetic
 5588 // Prereqs: - instructions available
 5589 //          - instructions guarantee atomicity
 5590 //          - immediate operand to be added
 5591 //          - immediate operand is small enough (8-bit signed).
 5592 //          - result of instruction is not used
 5593 instruct addL_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immL8 src, flagsReg cr) %{
 5594   match(Set dummy (GetAndAddL mem src));
 5595   effect(KILL cr);
 5596   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5597   ins_cost(MEMORY_REF_COST);
 5598   size(6);
 5599   format %{ &quot;AGSI    [$mem],$src\t # GetAndAddL (atomic)&quot; %}
 5600   opcode(AGSI_ZOPC);
 5601   ins_encode(z_siyform(mem, src));
 5602   ins_pipe(pipe_class_dummy);
 5603 %}
 5604 
 5605 // Fallback: direct memory arithmetic not available
 5606 // Disadvantages: - CS-Loop required, very expensive.
 5607 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5608 instruct addL_mem_imm16_atomic(memoryRSY mem, iRegL dst, immL16 src, iRegL tmp, flagsReg cr) %{
 5609   match(Set dst (GetAndAddL mem src));
 5610   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5611   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5612   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5613             &quot;  LG      $dst,[$mem]\n\t&quot;
 5614             &quot;  AGHIK   $tmp,$dst,$src\n\t&quot;
 5615             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5616             &quot;  retry if failed\n\t&quot;
 5617             &quot;} END ATOMIC&quot;
 5618          %}
 5619   ins_encode %{
 5620     Register Rdst = $dst$$Register;
 5621     Register Rtmp = $tmp$$Register;
 5622     int      Isrc = $src$$constant;
 5623     Label    retry;
 5624 
 5625     // Iterate until update with incremented value succeeds.
 5626     __ z_lg(Rdst, $mem$$Address);  // current contents
 5627     __ bind(retry);
 5628       // Calculate incremented value.
 5629       if (VM_Version::has_DistinctOpnds()) {
 5630         __ z_aghik(Rtmp, Rdst, Isrc);
 5631       } else {
 5632         __ z_lgr(Rtmp, Rdst);
 5633         __ z_aghi(Rtmp, Isrc);
 5634       }
 5635       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5636     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5637   %}
 5638   ins_pipe(pipe_class_dummy);
 5639 %}
 5640 
 5641 instruct addL_mem_imm32_atomic(memoryRSY mem, iRegL dst, immL32 src, iRegL tmp, flagsReg cr) %{
 5642   match(Set dst (GetAndAddL mem src));
 5643   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5644   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5645   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5646             &quot;  LG      $dst,[$mem]\n\t&quot;
 5647             &quot;  LGR     $tmp,$dst\n\t&quot;
 5648             &quot;  AGFI    $tmp,$src\n\t&quot;
 5649             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5650             &quot;  retry if failed\n\t&quot;
 5651             &quot;} END ATOMIC&quot;
 5652          %}
 5653   ins_encode %{
 5654     Register Rdst = $dst$$Register;
 5655     Register Rtmp = $tmp$$Register;
 5656     int      Isrc = $src$$constant;
 5657     Label    retry;
 5658 
 5659     // Iterate until update with incremented value succeeds.
 5660     __ z_lg(Rdst, $mem$$Address);  // current contents
 5661     __ bind(retry);
 5662       // Calculate incremented value.
 5663       __ z_lgr(Rtmp, Rdst);
 5664       __ z_agfi(Rtmp, Isrc);
 5665       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5666     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5667   %}
 5668   ins_pipe(pipe_class_dummy);
 5669 %}
 5670 
 5671 instruct addL_mem_reg_atomic(memoryRSY mem, iRegL dst, iRegL src, iRegL tmp, flagsReg cr) %{
 5672   match(Set dst (GetAndAddL mem src));
 5673   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5674   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5675   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5676             &quot;  LG      $dst,[$mem]\n\t&quot;
 5677             &quot;  AGRK    $tmp,$dst,$src\n\t&quot;
 5678             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5679             &quot;  retry if failed\n\t&quot;
 5680             &quot;} END ATOMIC&quot;
 5681          %}
 5682   ins_encode %{
 5683     Register Rsrc = $src$$Register;
 5684     Register Rdst = $dst$$Register;
 5685     Register Rtmp = $tmp$$Register;
 5686     Label    retry;
 5687 
 5688     // Iterate until update with incremented value succeeds.
 5689     __ z_lg(Rdst, $mem$$Address);  // current contents
 5690     __ bind(retry);
 5691       // Calculate incremented value.
 5692       if (VM_Version::has_DistinctOpnds()) {
 5693         __ z_agrk(Rtmp, Rdst, Rsrc);
 5694       } else {
 5695         __ z_lgr(Rtmp, Rdst);
 5696         __ z_agr(Rtmp, Rsrc);
 5697       }
 5698       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5699     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5700   %}
 5701   ins_pipe(pipe_class_dummy);
 5702 %}
 5703 
 5704 // Increment value in memory, save old value in dst.
 5705 instruct addI_mem_reg_atomic_z196(memoryRSY mem, iRegI dst, iRegI src) %{
 5706   match(Set dst (GetAndAddI mem src));
 5707   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5708   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5709   size(6);
 5710   format %{ &quot;LAA     $dst,$src,[$mem]&quot; %}
 5711   ins_encode %{ __ z_laa($dst$$Register, $src$$Register, $mem$$Address); %}
 5712   ins_pipe(pipe_class_dummy);
 5713 %}
 5714 
 5715 // Increment value in memory, save old value in dst.
 5716 instruct addL_mem_reg_atomic_z196(memoryRSY mem, iRegL dst, iRegL src) %{
 5717   match(Set dst (GetAndAddL mem src));
 5718   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5719   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5720   size(6);
 5721   format %{ &quot;LAAG    $dst,$src,[$mem]&quot; %}
 5722   ins_encode %{ __ z_laag($dst$$Register, $src$$Register, $mem$$Address); %}
 5723   ins_pipe(pipe_class_dummy);
 5724 %}
 5725 
 5726 
 5727 instruct xchgI_reg_mem(memoryRSY mem, iRegI dst, iRegI tmp, flagsReg cr) %{
 5728   match(Set dst (GetAndSetI mem dst));
 5729   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5730   format %{ &quot;XCHGI   $dst,[$mem]\t # EXCHANGE (int, atomic), temp $tmp&quot; %}
 5731   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5732   ins_pipe(pipe_class_dummy);
 5733 %}
 5734 
 5735 instruct xchgL_reg_mem(memoryRSY mem, iRegL dst, iRegL tmp, flagsReg cr) %{
 5736   match(Set dst (GetAndSetL mem dst));
 5737   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5738   format %{ &quot;XCHGL   $dst,[$mem]\t # EXCHANGE (long, atomic), temp $tmp&quot; %}
 5739   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5740   ins_pipe(pipe_class_dummy);
 5741 %}
 5742 
 5743 instruct xchgN_reg_mem(memoryRSY mem, iRegN dst, iRegI tmp, flagsReg cr) %{
 5744   match(Set dst (GetAndSetN mem dst));
 5745   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5746   format %{ &quot;XCHGN   $dst,[$mem]\t # EXCHANGE (coop, atomic), temp $tmp&quot; %}
 5747   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5748   ins_pipe(pipe_class_dummy);
 5749 %}
 5750 
 5751 instruct xchgP_reg_mem(memoryRSY mem, iRegP dst, iRegL tmp, flagsReg cr) %{
 5752   match(Set dst (GetAndSetP mem dst));
 5753   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5754   format %{ &quot;XCHGP   $dst,[$mem]\t # EXCHANGE (oop, atomic), temp $tmp&quot; %}
 5755   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5756   ins_pipe(pipe_class_dummy);
 5757 %}
 5758 
 5759 
 5760 //----------Arithmetic Instructions--------------------------------------------
 5761 
 5762 // The rules are sorted by right operand type and operand length. Please keep
 5763 // it that way.
 5764 // Left operand type is always reg. Left operand len is I, L, P
 5765 // Right operand type is reg, imm, mem. Right operand len is S, I, L, P
 5766 // Special instruction formats, e.g. multi-operand, are inserted at the end.
 5767 
 5768 // ADD
 5769 
 5770 // REG = REG + REG
 5771 
 5772 // Register Addition
 5773 instruct addI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 5774   match(Set dst (AddI dst src));
 5775   effect(KILL cr);
 5776   // TODO: s390 port size(FIXED_SIZE);
 5777   format %{ &quot;AR      $dst,$src\t # int  CISC ALU&quot; %}
 5778   opcode(AR_ZOPC);
 5779   ins_encode(z_rrform(dst, src));
 5780   ins_pipe(pipe_class_dummy);
 5781 %}
 5782 
 5783 // Avoid use of LA(Y) for general ALU operation.
 5784 instruct addI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 5785   match(Set dst (AddI src1 src2));
 5786   effect(KILL cr);
 5787   predicate(VM_Version::has_DistinctOpnds());
 5788   ins_cost(DEFAULT_COST);
 5789   size(4);
 5790   format %{ &quot;ARK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 5791   opcode(ARK_ZOPC);
 5792   ins_encode(z_rrfform(dst, src1, src2));
 5793   ins_pipe(pipe_class_dummy);
 5794 %}
 5795 
 5796 // REG = REG + IMM
 5797 
 5798 // Avoid use of LA(Y) for general ALU operation.
 5799 // Immediate Addition
 5800 instruct addI_reg_imm16_CISC(iRegI dst, immI16 con, flagsReg cr) %{
 5801   match(Set dst (AddI dst con));
 5802   effect(KILL cr);
 5803   ins_cost(DEFAULT_COST);
 5804   // TODO: s390 port size(FIXED_SIZE);
 5805   format %{ &quot;AHI     $dst,$con\t # int  CISC ALU&quot; %}
 5806   opcode(AHI_ZOPC);
 5807   ins_encode(z_riform_signed(dst, con));
 5808   ins_pipe(pipe_class_dummy);
 5809 %}
 5810 
 5811 // Avoid use of LA(Y) for general ALU operation.
 5812 // Immediate Addition
 5813 instruct addI_reg_imm16_RISC(iRegI dst, iRegI src, immI16 con, flagsReg cr) %{
 5814   match(Set dst (AddI src con));
 5815   effect(KILL cr);
 5816   predicate( VM_Version::has_DistinctOpnds());
 5817   ins_cost(DEFAULT_COST);
 5818   // TODO: s390 port size(FIXED_SIZE);
 5819   format %{ &quot;AHIK    $dst,$src,$con\t # int  RISC ALU&quot; %}
 5820   opcode(AHIK_ZOPC);
 5821   ins_encode(z_rieform_d(dst, src, con));
 5822   ins_pipe(pipe_class_dummy);
 5823 %}
 5824 
 5825 // Immediate Addition
 5826 instruct addI_reg_imm32(iRegI dst, immI src, flagsReg cr) %{
 5827   match(Set dst (AddI dst src));
 5828   effect(KILL cr);
 5829   ins_cost(DEFAULT_COST_HIGH);
 5830   size(6);
 5831   format %{ &quot;AFI     $dst,$src&quot; %}
 5832   opcode(AFI_ZOPC);
 5833   ins_encode(z_rilform_signed(dst, src));
 5834   ins_pipe(pipe_class_dummy);
 5835 %}
 5836 
 5837 // Immediate Addition
 5838 instruct addI_reg_imm12(iRegI dst, iRegI src, uimmI12 con) %{
 5839   match(Set dst (AddI src con));
 5840   predicate(PreferLAoverADD);
 5841   ins_cost(DEFAULT_COST_LOW);
 5842   size(4);
 5843   format %{ &quot;LA      $dst,$con(,$src)\t # int d12(,b)&quot; %}
 5844   opcode(LA_ZOPC);
 5845   ins_encode(z_rxform_imm_reg(dst, con, src));
 5846   ins_pipe(pipe_class_dummy);
 5847 %}
 5848 
 5849 // Immediate Addition
 5850 instruct addI_reg_imm20(iRegI dst, iRegI src, immI20 con) %{
 5851   match(Set dst (AddI src con));
 5852   predicate(PreferLAoverADD);
 5853   ins_cost(DEFAULT_COST);
 5854   size(6);
 5855   format %{ &quot;LAY     $dst,$con(,$src)\t # int d20(,b)&quot; %}
 5856   opcode(LAY_ZOPC);
 5857   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5858   ins_pipe(pipe_class_dummy);
 5859 %}
 5860 
 5861 instruct addI_reg_reg_imm12(iRegI dst, iRegI src1, iRegI src2, uimmI12 con) %{
 5862   match(Set dst (AddI (AddI src1 src2) con));
 5863   predicate( PreferLAoverADD);
 5864   ins_cost(DEFAULT_COST_LOW);
 5865   size(4);
 5866   format %{ &quot;LA      $dst,$con($src1,$src2)\t # int d12(x,b)&quot; %}
 5867   opcode(LA_ZOPC);
 5868   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 5869   ins_pipe(pipe_class_dummy);
 5870 %}
 5871 
 5872 instruct addI_reg_reg_imm20(iRegI dst, iRegI src1, iRegI src2, immI20 con) %{
 5873   match(Set dst (AddI (AddI src1 src2) con));
 5874   predicate(PreferLAoverADD);
 5875   ins_cost(DEFAULT_COST);
 5876   size(6);
 5877   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # int d20(x,b)&quot; %}
 5878   opcode(LAY_ZOPC);
 5879   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 5880   ins_pipe(pipe_class_dummy);
 5881 %}
 5882 
 5883 // REG = REG + MEM
 5884 
 5885 instruct addI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 5886   match(Set dst (AddI dst (LoadI src)));
 5887   effect(KILL cr);
 5888   ins_cost(MEMORY_REF_COST);
 5889   // TODO: s390 port size(VARIABLE_SIZE);
 5890   format %{ &quot;A(Y)    $dst, $src\t # int&quot; %}
 5891   opcode(AY_ZOPC, A_ZOPC);
 5892   ins_encode(z_form_rt_mem_opt(dst, src));
 5893   ins_pipe(pipe_class_dummy);
 5894 %}
 5895 
 5896 // MEM = MEM + IMM
 5897 
 5898 // Add Immediate to 4-byte memory operand and result
 5899 instruct addI_mem_imm(memoryRSY mem, immI8 src, flagsReg cr) %{
 5900   match(Set mem (StoreI mem (AddI (LoadI mem) src)));
 5901   effect(KILL cr);
 5902   predicate(VM_Version::has_MemWithImmALUOps());
 5903   ins_cost(MEMORY_REF_COST);
 5904   size(6);
 5905   format %{ &quot;ASI     $mem,$src\t # direct mem add 4&quot; %}
 5906   opcode(ASI_ZOPC);
 5907   ins_encode(z_siyform(mem, src));
 5908   ins_pipe(pipe_class_dummy);
 5909 %}
 5910 
 5911 
 5912 //
 5913 
 5914 // REG = REG + REG
 5915 
 5916 instruct addL_reg_regI(iRegL dst, iRegI src, flagsReg cr) %{
 5917   match(Set dst (AddL dst (ConvI2L src)));
 5918   effect(KILL cr);
 5919   size(4);
 5920   format %{ &quot;AGFR    $dst,$src\t # long&lt;-int CISC ALU&quot; %}
 5921   opcode(AGFR_ZOPC);
 5922   ins_encode(z_rreform(dst, src));
 5923   ins_pipe(pipe_class_dummy);
 5924 %}
 5925 
 5926 instruct addL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 5927   match(Set dst (AddL dst src));
 5928   effect(KILL cr);
 5929   // TODO: s390 port size(FIXED_SIZE);
 5930   format %{ &quot;AGR     $dst, $src\t # long CISC ALU&quot; %}
 5931   opcode(AGR_ZOPC);
 5932   ins_encode(z_rreform(dst, src));
 5933   ins_pipe(pipe_class_dummy);
 5934 %}
 5935 
 5936 // Avoid use of LA(Y) for general ALU operation.
 5937 instruct addL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 5938   match(Set dst (AddL src1 src2));
 5939   effect(KILL cr);
 5940   predicate(VM_Version::has_DistinctOpnds());
 5941   ins_cost(DEFAULT_COST);
 5942   size(4);
 5943   format %{ &quot;AGRK    $dst,$src1,$src2\t # long RISC ALU&quot; %}
 5944   opcode(AGRK_ZOPC);
 5945   ins_encode(z_rrfform(dst, src1, src2));
 5946   ins_pipe(pipe_class_dummy);
 5947 %}
 5948 
 5949 // REG = REG + IMM
 5950 
 5951 instruct addL_reg_imm12(iRegL dst, iRegL src, uimmL12 con) %{
 5952   match(Set dst (AddL src con));
 5953   predicate( PreferLAoverADD);
 5954   ins_cost(DEFAULT_COST_LOW);
 5955   size(4);
 5956   format %{ &quot;LA      $dst,$con(,$src)\t # long d12(,b)&quot; %}
 5957   opcode(LA_ZOPC);
 5958   ins_encode(z_rxform_imm_reg(dst, con, src));
 5959   ins_pipe(pipe_class_dummy);
 5960 %}
 5961 
 5962 instruct addL_reg_imm20(iRegL dst, iRegL src, immL20 con) %{
 5963   match(Set dst (AddL src con));
 5964   predicate(PreferLAoverADD);
 5965   ins_cost(DEFAULT_COST);
 5966   size(6);
 5967   format %{ &quot;LAY     $dst,$con(,$src)\t # long d20(,b)&quot; %}
 5968   opcode(LAY_ZOPC);
 5969   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5970   ins_pipe(pipe_class_dummy);
 5971 %}
 5972 
 5973 instruct addL_reg_imm32(iRegL dst, immL32 con, flagsReg cr) %{
 5974   match(Set dst (AddL dst con));
 5975   effect(KILL cr);
 5976   ins_cost(DEFAULT_COST_HIGH);
 5977   size(6);
 5978   format %{ &quot;AGFI    $dst,$con\t # long CISC ALU&quot; %}
 5979   opcode(AGFI_ZOPC);
 5980   ins_encode(z_rilform_signed(dst, con));
 5981   ins_pipe(pipe_class_dummy);
 5982 %}
 5983 
 5984 // Avoid use of LA(Y) for general ALU operation.
 5985 instruct addL_reg_imm16_CISC(iRegL dst, immL16 con, flagsReg cr) %{
 5986   match(Set dst (AddL dst con));
 5987   effect(KILL cr);
 5988   ins_cost(DEFAULT_COST);
 5989   // TODO: s390 port size(FIXED_SIZE);
 5990   format %{ &quot;AGHI    $dst,$con\t # long CISC ALU&quot; %}
 5991   opcode(AGHI_ZOPC);
 5992   ins_encode(z_riform_signed(dst, con));
 5993   ins_pipe(pipe_class_dummy);
 5994 %}
 5995 
 5996 // Avoid use of LA(Y) for general ALU operation.
 5997 instruct addL_reg_imm16_RISC(iRegL dst, iRegL src, immL16 con, flagsReg cr) %{
 5998   match(Set dst (AddL src con));
 5999   effect(KILL cr);
 6000   predicate( VM_Version::has_DistinctOpnds());
 6001   ins_cost(DEFAULT_COST);
 6002   size(6);
 6003   format %{ &quot;AGHIK   $dst,$src,$con\t # long RISC ALU&quot; %}
 6004   opcode(AGHIK_ZOPC);
 6005   ins_encode(z_rieform_d(dst, src, con));
 6006   ins_pipe(pipe_class_dummy);
 6007 %}
 6008 
 6009 // REG = REG + MEM
 6010 
 6011 instruct addL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6012   match(Set dst (AddL dst (ConvI2L (LoadI src))));
 6013   effect(KILL cr);
 6014   ins_cost(MEMORY_REF_COST);
 6015   size(Z_DISP3_SIZE);
 6016   format %{ &quot;AGF     $dst, $src\t # long/int&quot; %}
 6017   opcode(AGF_ZOPC, AGF_ZOPC);
 6018   ins_encode(z_form_rt_mem_opt(dst, src));
 6019   ins_pipe(pipe_class_dummy);
 6020 %}
 6021 
 6022 instruct addL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6023   match(Set dst (AddL dst (LoadL src)));
 6024   effect(KILL cr);
 6025   ins_cost(MEMORY_REF_COST);
 6026   size(Z_DISP3_SIZE);
 6027   format %{ &quot;AG      $dst, $src\t # long&quot; %}
 6028   opcode(AG_ZOPC, AG_ZOPC);
 6029   ins_encode(z_form_rt_mem_opt(dst, src));
 6030   ins_pipe(pipe_class_dummy);
 6031 %}
 6032 
 6033 instruct addL_reg_reg_imm12(iRegL dst, iRegL src1, iRegL src2, uimmL12 con) %{
 6034   match(Set dst (AddL (AddL src1 src2) con));
 6035   predicate( PreferLAoverADD);
 6036   ins_cost(DEFAULT_COST_LOW);
 6037   size(4);
 6038   format %{ &quot;LA     $dst,$con($src1,$src2)\t # long d12(x,b)&quot; %}
 6039   opcode(LA_ZOPC);
 6040   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6041   ins_pipe(pipe_class_dummy);
 6042 %}
 6043 
 6044 instruct addL_reg_reg_imm20(iRegL dst, iRegL src1, iRegL src2, immL20 con) %{
 6045   match(Set dst (AddL (AddL src1 src2) con));
 6046   predicate(PreferLAoverADD);
 6047   ins_cost(DEFAULT_COST);
 6048   size(6);
 6049   format %{ &quot;LAY    $dst,$con($src1,$src2)\t # long d20(x,b)&quot; %}
 6050   opcode(LAY_ZOPC);
 6051   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6052   ins_pipe(pipe_class_dummy);
 6053 %}
 6054 
 6055 // MEM = MEM + IMM
 6056 
 6057 // Add Immediate to 8-byte memory operand and result.
 6058 instruct addL_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6059   match(Set mem (StoreL mem (AddL (LoadL mem) src)));
 6060   effect(KILL cr);
 6061   predicate(VM_Version::has_MemWithImmALUOps());
 6062   ins_cost(MEMORY_REF_COST);
 6063   size(6);
 6064   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8&quot; %}
 6065   opcode(AGSI_ZOPC);
 6066   ins_encode(z_siyform(mem, src));
 6067   ins_pipe(pipe_class_dummy);
 6068 %}
 6069 
 6070 
 6071 // REG = REG + REG
 6072 
 6073 // Ptr Addition
 6074 instruct addP_reg_reg_LA(iRegP dst, iRegP_N2P src1, iRegL src2) %{
 6075   match(Set dst (AddP src1 src2));
 6076   predicate( PreferLAoverADD);
 6077   ins_cost(DEFAULT_COST);
 6078   size(4);
 6079   format %{ &quot;LA      $dst,#0($src1,$src2)\t # ptr 0(x,b)&quot; %}
 6080   opcode(LA_ZOPC);
 6081   ins_encode(z_rxform_imm_reg_reg(dst, 0x0, src1, src2));
 6082   ins_pipe(pipe_class_dummy);
 6083 %}
 6084 
 6085 // Ptr Addition
 6086 // Avoid use of LA(Y) for general ALU operation.
 6087 instruct addP_reg_reg_CISC(iRegP dst, iRegL src, flagsReg cr) %{
 6088   match(Set dst (AddP dst src));
 6089   effect(KILL cr);
 6090   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6091   ins_cost(DEFAULT_COST);
 6092   // TODO: s390 port size(FIXED_SIZE);
 6093   format %{ &quot;ALGR    $dst,$src\t # ptr CICS ALU&quot; %}
 6094   opcode(ALGR_ZOPC);
 6095   ins_encode(z_rreform(dst, src));
 6096   ins_pipe(pipe_class_dummy);
 6097 %}
 6098 
 6099 // Ptr Addition
 6100 // Avoid use of LA(Y) for general ALU operation.
 6101 instruct addP_reg_reg_RISC(iRegP dst, iRegP_N2P src1, iRegL src2, flagsReg cr) %{
 6102   match(Set dst (AddP src1 src2));
 6103   effect(KILL cr);
 6104   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6105   ins_cost(DEFAULT_COST);
 6106   // TODO: s390 port size(FIXED_SIZE);
 6107   format %{ &quot;ALGRK   $dst,$src1,$src2\t # ptr RISC ALU&quot; %}
 6108   opcode(ALGRK_ZOPC);
 6109   ins_encode(z_rrfform(dst, src1, src2));
 6110   ins_pipe(pipe_class_dummy);
 6111 %}
 6112 
 6113 // REG = REG + IMM
 6114 
 6115 instruct addP_reg_imm12(iRegP dst, iRegP_N2P src, uimmL12 con) %{
 6116   match(Set dst (AddP src con));
 6117   predicate( PreferLAoverADD);
 6118   ins_cost(DEFAULT_COST_LOW);
 6119   size(4);
 6120   format %{ &quot;LA      $dst,$con(,$src)\t # ptr d12(,b)&quot; %}
 6121   opcode(LA_ZOPC);
 6122   ins_encode(z_rxform_imm_reg(dst, con, src));
 6123   ins_pipe(pipe_class_dummy);
 6124 %}
 6125 
 6126 // Avoid use of LA(Y) for general ALU operation.
 6127 instruct addP_reg_imm16_CISC(iRegP dst, immL16 src, flagsReg cr) %{
 6128   match(Set dst (AddP dst src));
 6129   effect(KILL cr);
 6130   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6131   ins_cost(DEFAULT_COST);
 6132   // TODO: s390 port size(FIXED_SIZE);
 6133   format %{ &quot;AGHI    $dst,$src\t # ptr CISC ALU&quot; %}
 6134   opcode(AGHI_ZOPC);
 6135   ins_encode(z_riform_signed(dst, src));
 6136   ins_pipe(pipe_class_dummy);
 6137 %}
 6138 
 6139 // Avoid use of LA(Y) for general ALU operation.
 6140 instruct addP_reg_imm16_RISC(iRegP dst, iRegP_N2P src, immL16 con, flagsReg cr) %{
 6141   match(Set dst (AddP src con));
 6142   effect(KILL cr);
 6143   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6144   ins_cost(DEFAULT_COST);
 6145   // TODO: s390 port size(FIXED_SIZE);
 6146   format %{ &quot;ALGHSIK $dst,$src,$con\t # ptr RISC ALU&quot; %}
 6147   opcode(ALGHSIK_ZOPC);
 6148   ins_encode(z_rieform_d(dst, src, con));
 6149   ins_pipe(pipe_class_dummy);
 6150 %}
 6151 
 6152 instruct addP_reg_imm20(iRegP dst, memoryRegP src, immL20 con) %{
 6153   match(Set dst (AddP src con));
 6154   predicate(PreferLAoverADD);
 6155   ins_cost(DEFAULT_COST);
 6156   size(6);
 6157   format %{ &quot;LAY     $dst,$con(,$src)\t # ptr d20(,b)&quot; %}
 6158   opcode(LAY_ZOPC);
 6159   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6160   ins_pipe(pipe_class_dummy);
 6161 %}
 6162 
 6163 // Pointer Immediate Addition
 6164 instruct addP_reg_imm32(iRegP dst, immL32 src, flagsReg cr) %{
 6165   match(Set dst (AddP dst src));
 6166   effect(KILL cr);
 6167   ins_cost(DEFAULT_COST_HIGH);
 6168   // TODO: s390 port size(FIXED_SIZE);
 6169   format %{ &quot;AGFI    $dst,$src\t # ptr&quot; %}
 6170   opcode(AGFI_ZOPC);
 6171   ins_encode(z_rilform_signed(dst, src));
 6172   ins_pipe(pipe_class_dummy);
 6173 %}
 6174 
 6175 // REG = REG1 + REG2 + IMM
 6176 
 6177 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6178   match(Set dst (AddP (AddP src1 src2) con));
 6179   predicate( PreferLAoverADD);
 6180   ins_cost(DEFAULT_COST_LOW);
 6181   size(4);
 6182   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6183   opcode(LA_ZOPC);
 6184   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6185   ins_pipe(pipe_class_dummy);
 6186 %}
 6187 
 6188 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6189   match(Set dst (AddP (AddP src1 src2) con));
 6190   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);
 6191   ins_cost(DEFAULT_COST_LOW);
 6192   size(4);
 6193   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6194   opcode(LA_ZOPC);
 6195   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6196   ins_pipe(pipe_class_dummy);
 6197 %}
 6198 
 6199 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6200   match(Set dst (AddP (AddP src1 src2) con));
 6201   predicate(PreferLAoverADD);
 6202   ins_cost(DEFAULT_COST);
 6203   // TODO: s390 port size(FIXED_SIZE);
 6204   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6205   opcode(LAY_ZOPC);
 6206   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6207   ins_pipe(pipe_class_dummy);
 6208 %}
 6209 
 6210 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6211   match(Set dst (AddP (AddP src1 src2) con));
 6212   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);
 6213   ins_cost(DEFAULT_COST);
 6214   // TODO: s390 port size(FIXED_SIZE);
 6215   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6216   opcode(LAY_ZOPC);
 6217   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6218   ins_pipe(pipe_class_dummy);
 6219 %}
 6220 
 6221 // MEM = MEM + IMM
 6222 
 6223 // Add Immediate to 8-byte memory operand and result
 6224 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6225   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6226   effect(KILL cr);
 6227   predicate(VM_Version::has_MemWithImmALUOps());
 6228   ins_cost(MEMORY_REF_COST);
 6229   size(6);
 6230   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6231   opcode(AGSI_ZOPC);
 6232   ins_encode(z_siyform(mem, src));
 6233   ins_pipe(pipe_class_dummy);
 6234 %}
 6235 
 6236 // SUB
 6237 
 6238 // Register Subtraction
 6239 instruct subI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 6240   match(Set dst (SubI dst src));
 6241   effect(KILL cr);
 6242   // TODO: s390 port size(FIXED_SIZE);
 6243   format %{ &quot;SR      $dst,$src\t # int  CISC ALU&quot; %}
 6244   opcode(SR_ZOPC);
 6245   ins_encode(z_rrform(dst, src));
 6246   ins_pipe(pipe_class_dummy);
 6247 %}
 6248 
 6249 instruct subI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 6250   match(Set dst (SubI src1 src2));
 6251   effect(KILL cr);
 6252   predicate(VM_Version::has_DistinctOpnds());
 6253   ins_cost(DEFAULT_COST);
 6254   size(4);
 6255   format %{ &quot;SRK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6256   opcode(SRK_ZOPC);
 6257   ins_encode(z_rrfform(dst, src1, src2));
 6258   ins_pipe(pipe_class_dummy);
 6259 %}
 6260 
 6261 instruct subI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 6262   match(Set dst (SubI dst (LoadI src)));
 6263   effect(KILL cr);
 6264   ins_cost(MEMORY_REF_COST);
 6265   // TODO: s390 port size(VARIABLE_SIZE);
 6266   format %{ &quot;S(Y)    $dst, $src\t # int&quot; %}
 6267   opcode(SY_ZOPC, S_ZOPC);
 6268   ins_encode(z_form_rt_mem_opt(dst, src));
 6269   ins_pipe(pipe_class_dummy);
 6270 %}
 6271 
 6272 instruct subI_zero_reg(iRegI dst, immI_0 zero, iRegI src, flagsReg cr) %{
 6273   match(Set dst (SubI zero src));
 6274   effect(KILL cr);
 6275   size(2);
 6276   format %{ &quot;NEG     $dst, $src&quot; %}
 6277   ins_encode %{ __ z_lcr($dst$$Register, $src$$Register); %}
 6278   ins_pipe(pipe_class_dummy);
 6279 %}
 6280 
 6281 //
 6282 
 6283 // Long subtraction
 6284 instruct subL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6285   match(Set dst (SubL dst src));
 6286   effect(KILL cr);
 6287   // TODO: s390 port size(FIXED_SIZE);
 6288   format %{ &quot;SGR     $dst,$src\t # int  CISC ALU&quot; %}
 6289   opcode(SGR_ZOPC);
 6290   ins_encode(z_rreform(dst, src));
 6291   ins_pipe(pipe_class_dummy);
 6292 %}
 6293 
 6294 // Avoid use of LA(Y) for general ALU operation.
 6295 instruct subL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6296   match(Set dst (SubL src1 src2));
 6297   effect(KILL cr);
 6298   predicate(VM_Version::has_DistinctOpnds());
 6299   ins_cost(DEFAULT_COST);
 6300   size(4);
 6301   format %{ &quot;SGRK    $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6302   opcode(SGRK_ZOPC);
 6303   ins_encode(z_rrfform(dst, src1, src2));
 6304   ins_pipe(pipe_class_dummy);
 6305 %}
 6306 
 6307 instruct subL_reg_regI_CISC(iRegL dst, iRegI src, flagsReg cr) %{
 6308   match(Set dst (SubL dst (ConvI2L src)));
 6309   effect(KILL cr);
 6310   size(4);
 6311   format %{ &quot;SGFR    $dst, $src\t # int  CISC ALU&quot; %}
 6312   opcode(SGFR_ZOPC);
 6313   ins_encode(z_rreform(dst, src));
 6314   ins_pipe(pipe_class_dummy);
 6315 %}
 6316 
 6317 instruct subL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6318   match(Set dst (SubL dst (ConvI2L (LoadI src))));
 6319   effect(KILL cr);
 6320   ins_cost(MEMORY_REF_COST);
 6321   size(Z_DISP3_SIZE);
 6322   format %{ &quot;SGF     $dst, $src\t # long/int&quot; %}
 6323   opcode(SGF_ZOPC, SGF_ZOPC);
 6324   ins_encode(z_form_rt_mem_opt(dst, src));
 6325   ins_pipe(pipe_class_dummy);
 6326 %}
 6327 
 6328 instruct subL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6329   match(Set dst (SubL dst (LoadL src)));
 6330   effect(KILL cr);
 6331   ins_cost(MEMORY_REF_COST);
 6332   size(Z_DISP3_SIZE);
 6333   format %{ &quot;SG      $dst, $src\t # long&quot; %}
 6334   opcode(SG_ZOPC, SG_ZOPC);
 6335   ins_encode(z_form_rt_mem_opt(dst, src));
 6336   ins_pipe(pipe_class_dummy);
 6337 %}
 6338 
 6339 // Moved declaration of negL_reg_reg before encode nodes, where it is used.
 6340 
 6341 //  MUL
 6342 
 6343 // Register Multiplication
 6344 instruct mulI_reg_reg(iRegI dst, iRegI src) %{
 6345   match(Set dst (MulI dst src));
 6346   ins_cost(DEFAULT_COST);
 6347   size(4);
 6348   format %{ &quot;MSR     $dst, $src&quot; %}
 6349   opcode(MSR_ZOPC);
 6350   ins_encode(z_rreform(dst, src));
 6351   ins_pipe(pipe_class_dummy);
 6352 %}
 6353 
 6354 // Immediate Multiplication
 6355 instruct mulI_reg_imm16(iRegI dst, immI16 con) %{
 6356   match(Set dst (MulI dst con));
 6357   ins_cost(DEFAULT_COST);
 6358   // TODO: s390 port size(FIXED_SIZE);
 6359   format %{ &quot;MHI     $dst,$con&quot; %}
 6360   opcode(MHI_ZOPC);
 6361   ins_encode(z_riform_signed(dst,con));
 6362   ins_pipe(pipe_class_dummy);
 6363 %}
 6364 
 6365 // Immediate (32bit) Multiplication
 6366 instruct mulI_reg_imm32(iRegI dst, immI con) %{
 6367   match(Set dst (MulI dst con));
 6368   ins_cost(DEFAULT_COST);
 6369   size(6);
 6370   format %{ &quot;MSFI    $dst,$con&quot; %}
 6371   opcode(MSFI_ZOPC);
 6372   ins_encode(z_rilform_signed(dst,con));
 6373   ins_pipe(pipe_class_dummy);
 6374 %}
 6375 
 6376 instruct mulI_Reg_mem(iRegI dst, memory src)%{
 6377   match(Set dst (MulI dst (LoadI src)));
 6378   ins_cost(MEMORY_REF_COST);
 6379   // TODO: s390 port size(VARIABLE_SIZE);
 6380   format %{ &quot;MS(Y)   $dst, $src\t # int&quot; %}
 6381   opcode(MSY_ZOPC, MS_ZOPC);
 6382   ins_encode(z_form_rt_mem_opt(dst, src));
 6383   ins_pipe(pipe_class_dummy);
 6384 %}
 6385 
 6386 //
 6387 
 6388 instruct mulL_reg_regI(iRegL dst, iRegI src) %{
 6389   match(Set dst (MulL dst (ConvI2L src)));
 6390   ins_cost(DEFAULT_COST);
 6391   // TODO: s390 port size(FIXED_SIZE);
 6392   format %{ &quot;MSGFR   $dst $src\t # long/int&quot; %}
 6393   opcode(MSGFR_ZOPC);
 6394   ins_encode(z_rreform(dst, src));
 6395   ins_pipe(pipe_class_dummy);
 6396 %}
 6397 
 6398 instruct mulL_reg_reg(iRegL dst, iRegL src) %{
 6399   match(Set dst (MulL dst src));
 6400   ins_cost(DEFAULT_COST);
 6401   size(4);
 6402   format %{ &quot;MSGR    $dst $src\t # long&quot; %}
 6403   opcode(MSGR_ZOPC);
 6404   ins_encode(z_rreform(dst, src));
 6405   ins_pipe(pipe_class_dummy);
 6406 %}
 6407 
 6408 // Immediate Multiplication
 6409 instruct mulL_reg_imm16(iRegL dst, immL16 src) %{
 6410   match(Set dst (MulL dst src));
 6411   ins_cost(DEFAULT_COST);
 6412   // TODO: s390 port size(FIXED_SIZE);
 6413   format %{ &quot;MGHI    $dst,$src\t # long&quot; %}
 6414   opcode(MGHI_ZOPC);
 6415   ins_encode(z_riform_signed(dst, src));
 6416   ins_pipe(pipe_class_dummy);
 6417 %}
 6418 
 6419 // Immediate (32bit) Multiplication
 6420 instruct mulL_reg_imm32(iRegL dst, immL32 con) %{
 6421   match(Set dst (MulL dst con));
 6422   ins_cost(DEFAULT_COST);
 6423   size(6);
 6424   format %{ &quot;MSGFI   $dst,$con&quot; %}
 6425   opcode(MSGFI_ZOPC);
 6426   ins_encode(z_rilform_signed(dst,con));
 6427   ins_pipe(pipe_class_dummy);
 6428 %}
 6429 
 6430 instruct mulL_Reg_memI(iRegL dst, memory src)%{
 6431   match(Set dst (MulL dst (ConvI2L (LoadI src))));
 6432   ins_cost(MEMORY_REF_COST);
 6433   size(Z_DISP3_SIZE);
 6434   format %{ &quot;MSGF    $dst, $src\t # long&quot; %}
 6435   opcode(MSGF_ZOPC, MSGF_ZOPC);
 6436   ins_encode(z_form_rt_mem_opt(dst, src));
 6437   ins_pipe(pipe_class_dummy);
 6438 %}
 6439 
 6440 instruct mulL_Reg_mem(iRegL dst, memory src)%{
 6441   match(Set dst (MulL dst (LoadL src)));
 6442   ins_cost(MEMORY_REF_COST);
 6443   size(Z_DISP3_SIZE);
 6444   format %{ &quot;MSG     $dst, $src\t # long&quot; %}
 6445   opcode(MSG_ZOPC, MSG_ZOPC);
 6446   ins_encode(z_form_rt_mem_opt(dst, src));
 6447   ins_pipe(pipe_class_dummy);
 6448 %}
 6449 
 6450 instruct mulHiL_reg_reg(revenRegL Rdst, roddRegL Rsrc1, iRegL Rsrc2, iRegL Rtmp1, flagsReg cr)%{
 6451   match(Set Rdst (MulHiL Rsrc1 Rsrc2));
 6452   effect(TEMP_DEF Rdst, USE_KILL Rsrc1, TEMP Rtmp1, KILL cr);
 6453   ins_cost(7*DEFAULT_COST);
 6454   // TODO: s390 port size(VARIABLE_SIZE);
 6455   format %{ &quot;MulHiL  $Rdst, $Rsrc1, $Rsrc2\t # Multiply High Long&quot; %}
 6456   ins_encode%{
 6457     Register dst  = $Rdst$$Register;
 6458     Register src1 = $Rsrc1$$Register;
 6459     Register src2 = $Rsrc2$$Register;
 6460     Register tmp1 = $Rtmp1$$Register;
 6461     Register tmp2 = $Rdst$$Register;
 6462     // z/Architecture has only unsigned multiply (64 * 64 -&gt; 128).
 6463     // implementing mulhs(a,b) = mulhu(a,b)  (a &amp; (b&gt;&gt;63))  (b &amp; (a&gt;&gt;63))
 6464     __ z_srag(tmp2, src1, 63);  // a&gt;&gt;63
 6465     __ z_srag(tmp1, src2, 63);  // b&gt;&gt;63
 6466     __ z_ngr(tmp2, src2);       // b &amp; (a&gt;&gt;63)
 6467     __ z_ngr(tmp1, src1);       // a &amp; (b&gt;&gt;63)
 6468     __ z_agr(tmp1, tmp2);       // ((a &amp; (b&gt;&gt;63)) + (b &amp; (a&gt;&gt;63)))
 6469     __ z_mlgr(dst, src2);       // tricky: 128-bit product is written to even/odd pair (dst,src1),
 6470                                 //         multiplicand is taken from oddReg (src1), multiplier in src2.
 6471     __ z_sgr(dst, tmp1);
 6472   %}
 6473   ins_pipe(pipe_class_dummy);
 6474 %}
 6475 
 6476 //  DIV
 6477 
 6478 // Integer DIVMOD with Register, both quotient and mod results
 6479 instruct divModI_reg_divmod(roddRegI dst1src1, revenRegI dst2, noOdd_iRegI src2, flagsReg cr) %{
 6480   match(DivModI dst1src1 src2);
 6481   effect(KILL cr);
 6482   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6483   size((VM_Version::has_CompareBranch() ? 24 : 26));
 6484   format %{ &quot;DIVMODI ($dst1src1, $dst2) $src2&quot; %}
 6485   ins_encode %{
 6486     Register d1s1 = $dst1src1$$Register;
 6487     Register d2   = $dst2$$Register;
 6488     Register s2   = $src2$$Register;
 6489 
 6490     assert_different_registers(d1s1, s2);
 6491 
 6492     Label do_div, done_div;
 6493     if (VM_Version::has_CompareBranch()) {
 6494       __ z_cij(s2, -1, Assembler::bcondNotEqual, do_div);
 6495     } else {
 6496       __ z_chi(s2, -1);
 6497       __ z_brne(do_div);
 6498     }
 6499     __ z_lcr(d1s1, d1s1);
 6500     __ clear_reg(d2, false, false);
 6501     __ z_bru(done_div);
 6502     __ bind(do_div);
 6503     __ z_lgfr(d1s1, d1s1);
 6504     __ z_dsgfr(d2, s2);
 6505     __ bind(done_div);
 6506   %}
 6507   ins_pipe(pipe_class_dummy);
 6508 %}
 6509 
 6510 
 6511 // Register Division
 6512 instruct divI_reg_reg(roddRegI dst, iRegI src1, noOdd_iRegI src2, revenRegI tmp, flagsReg cr) %{
 6513   match(Set dst (DivI src1 src2));
 6514   effect(KILL tmp, KILL cr);
 6515   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6516   size((VM_Version::has_CompareBranch() ? 20 : 22));
 6517   format %{ &quot;DIV_checked $dst, $src1,$src2\t # treats special case 0x80../-1&quot; %}
 6518   ins_encode %{
 6519     Register a = $src1$$Register;
 6520     Register b = $src2$$Register;
 6521     Register t = $dst$$Register;
 6522 
 6523     assert_different_registers(t, b);
 6524 
 6525     Label do_div, done_div;
 6526     if (VM_Version::has_CompareBranch()) {
 6527       __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6528     } else {
 6529       __ z_chi(b, -1);
 6530       __ z_brne(do_div);
 6531     }
 6532     __ z_lcr(t, a);
 6533     __ z_bru(done_div);
 6534     __ bind(do_div);
 6535     __ z_lgfr(t, a);
 6536     __ z_dsgfr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6537     __ bind(done_div);
 6538   %}
 6539   ins_pipe(pipe_class_dummy);
 6540 %}
 6541 
 6542 // Immediate Division
 6543 instruct divI_reg_imm16(roddRegI dst, iRegI src1, immI16 src2, revenRegI tmp, flagsReg cr) %{
 6544   match(Set dst (DivI src1 src2));
 6545   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6546   ins_cost(2 * DEFAULT_COST);
 6547   // TODO: s390 port size(VARIABLE_SIZE);
 6548   format %{ &quot;DIV_const  $dst,$src1,$src2&quot; %}
 6549   ins_encode %{
 6550     // No sign extension of Rdividend needed here.
 6551     if ($src2$$constant != -1) {
 6552       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6553       __ z_lgfr($dst$$Register, $src1$$Register);
 6554       __ z_dsgfr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6555     } else {
 6556       __ z_lcr($dst$$Register, $src1$$Register);
 6557     }
 6558   %}
 6559   ins_pipe(pipe_class_dummy);
 6560 %}
 6561 
 6562 // Long DIVMOD with Register, both quotient and mod results
 6563 instruct divModL_reg_divmod(roddRegL dst1src1, revenRegL dst2, iRegL src2, flagsReg cr) %{
 6564   match(DivModL dst1src1 src2);
 6565   effect(KILL cr);
 6566   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6567   size((VM_Version::has_CompareBranch() ? 22 : 24));
 6568   format %{ &quot;DIVMODL ($dst1src1, $dst2) $src2&quot; %}
 6569   ins_encode %{
 6570     Register d1s1 = $dst1src1$$Register;
 6571     Register d2   = $dst2$$Register;
 6572     Register s2   = $src2$$Register;
 6573 
 6574     Label do_div, done_div;
 6575     if (VM_Version::has_CompareBranch()) {
 6576       __ z_cgij(s2, -1, Assembler::bcondNotEqual, do_div);
 6577     } else {
 6578       __ z_cghi(s2, -1);
 6579       __ z_brne(do_div);
 6580     }
 6581     __ z_lcgr(d1s1, d1s1);
 6582     // indicate unused result
 6583     (void) __ clear_reg(d2, true, false);
 6584     __ z_bru(done_div);
 6585     __ bind(do_div);
 6586     __ z_dsgr(d2, s2);
 6587     __ bind(done_div);
 6588   %}
 6589   ins_pipe(pipe_class_dummy);
 6590 %}
 6591 
 6592 // Register Long Division
 6593 instruct divL_reg_reg(roddRegL dst, iRegL src, revenRegL tmp, flagsReg cr) %{
 6594   match(Set dst (DivL dst src));
 6595   effect(KILL tmp, KILL cr);
 6596   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6597   size((VM_Version::has_CompareBranch() ? 18 : 20));
 6598   format %{ &quot;DIVG_checked  $dst, $src\t # long, treats special case 0x80../-1&quot; %}
 6599   ins_encode %{
 6600     Register b = $src$$Register;
 6601     Register t = $dst$$Register;
 6602 
 6603     Label done_div;
 6604     __ z_lcgr(t, t);    // Does no harm. divisor is in other register.
 6605     if (VM_Version::has_CompareBranch()) {
 6606       __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6607     } else {
 6608       __ z_cghi(b, -1);
 6609       __ z_bre(done_div);
 6610     }
 6611     __ z_lcgr(t, t);    // Restore sign.
 6612     __ z_dsgr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6613     __ bind(done_div);
 6614   %}
 6615   ins_pipe(pipe_class_dummy);
 6616 %}
 6617 
 6618 // Immediate Long Division
 6619 instruct divL_reg_imm16(roddRegL dst, iRegL src1, immL16 src2, revenRegL tmp, flagsReg cr) %{
 6620   match(Set dst (DivL src1 src2));
 6621   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6622   ins_cost(2 * DEFAULT_COST);
 6623   // TODO: s390 port size(VARIABLE_SIZE);
 6624   format %{ &quot;DIVG_const  $dst,$src1,$src2\t # long&quot; %}
 6625   ins_encode %{
 6626     if ($src2$$constant != -1) {
 6627       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6628       __ lgr_if_needed($dst$$Register, $src1$$Register);
 6629       __ z_dsgr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6630     } else {
 6631       __ z_lcgr($dst$$Register, $src1$$Register);
 6632     }
 6633   %}
 6634   ins_pipe(pipe_class_dummy);
 6635 %}
 6636 
 6637 // REM
 6638 
 6639 // Integer Remainder
 6640 // Register Remainder
 6641 instruct modI_reg_reg(revenRegI dst, iRegI src1, noOdd_iRegI src2, roddRegI tmp, flagsReg cr) %{
 6642   match(Set dst (ModI src1 src2));
 6643   effect(KILL tmp, KILL cr);
 6644   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6645   // TODO: s390 port size(VARIABLE_SIZE);
 6646   format %{ &quot;MOD_checked   $dst,$src1,$src2&quot; %}
 6647   ins_encode %{
 6648     Register a = $src1$$Register;
 6649     Register b = $src2$$Register;
 6650     Register t = $dst$$Register;
 6651     assert_different_registers(t-&gt;successor(), b);
 6652 
 6653     Label do_div, done_div;
 6654 
 6655     if ((t-&gt;encoding() != b-&gt;encoding()) &amp;&amp; (t-&gt;encoding() != a-&gt;encoding())) {
 6656       (void) __ clear_reg(t, true, false);  // Does no harm. Operands are in other regs.
 6657       if (VM_Version::has_CompareBranch()) {
 6658         __ z_cij(b, -1, Assembler::bcondEqual, done_div);
 6659       } else {
 6660         __ z_chi(b, -1);
 6661         __ z_bre(done_div);
 6662       }
 6663       __ z_lgfr(t-&gt;successor(), a);
 6664       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6665     } else {
 6666       if (VM_Version::has_CompareBranch()) {
 6667         __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6668       } else {
 6669         __ z_chi(b, -1);
 6670         __ z_brne(do_div);
 6671       }
 6672       __ clear_reg(t, true, false);
 6673       __ z_bru(done_div);
 6674       __ bind(do_div);
 6675       __ z_lgfr(t-&gt;successor(), a);
 6676       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6677     }
 6678     __ bind(done_div);
 6679   %}
 6680   ins_pipe(pipe_class_dummy);
 6681 %}
 6682 
 6683 // Immediate Remainder
 6684 instruct modI_reg_imm16(revenRegI dst, iRegI src1, immI16 src2, roddRegI tmp, flagsReg cr) %{
 6685   match(Set dst (ModI src1 src2));
 6686   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6687   ins_cost(3 * DEFAULT_COST);
 6688   // TODO: s390 port size(VARIABLE_SIZE);
 6689   format %{ &quot;MOD_const  $dst,src1,$src2&quot; %}
 6690   ins_encode %{
 6691     assert_different_registers($dst$$Register, $src1$$Register);
 6692     assert_different_registers($dst$$Register-&gt;successor(), $src1$$Register);
 6693     int divisor = $src2$$constant;
 6694 
 6695     if (divisor != -1) {
 6696       __ z_lghi(Z_R0_scratch, divisor);
 6697       __ z_lgfr($dst$$Register-&gt;successor(), $src1$$Register);
 6698       __ z_dsgfr($dst$$Register/* Dst is even part of a register pair. */, Z_R0_scratch); // Instruction kills tmp.
 6699     } else {
 6700       __ clear_reg($dst$$Register, true, false);
 6701     }
 6702   %}
 6703   ins_pipe(pipe_class_dummy);
 6704 %}
 6705 
 6706 // Register Long Remainder
 6707 instruct modL_reg_reg(revenRegL dst, roddRegL src1, iRegL src2, flagsReg cr) %{
 6708   match(Set dst (ModL src1 src2));
 6709   effect(KILL src1, KILL cr); // R0 is killed, too.
 6710   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6711   // TODO: s390 port size(VARIABLE_SIZE);
 6712   format %{ &quot;MODG_checked   $dst,$src1,$src2&quot; %}
 6713   ins_encode %{
 6714     Register a = $src1$$Register;
 6715     Register b = $src2$$Register;
 6716     Register t = $dst$$Register;
 6717     assert(t-&gt;successor() == a, &quot;(t,a) is an even-odd pair&quot; );
 6718 
 6719     Label do_div, done_div;
 6720     if (t-&gt;encoding() != b-&gt;encoding()) {
 6721       (void) __ clear_reg(t, true, false); // Does no harm. Dividend is in successor.
 6722       if (VM_Version::has_CompareBranch()) {
 6723         __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6724       } else {
 6725         __ z_cghi(b, -1);
 6726         __ z_bre(done_div);
 6727       }
 6728       __ z_dsgr(t, b);
 6729     } else {
 6730       if (VM_Version::has_CompareBranch()) {
 6731         __ z_cgij(b, -1, Assembler::bcondNotEqual, do_div);
 6732       } else {
 6733         __ z_cghi(b, -1);
 6734         __ z_brne(do_div);
 6735       }
 6736       __ clear_reg(t, true, false);
 6737       __ z_bru(done_div);
 6738       __ bind(do_div);
 6739       __ z_dsgr(t, b);
 6740     }
 6741     __ bind(done_div);
 6742   %}
 6743   ins_pipe(pipe_class_dummy);
 6744 %}
 6745 
 6746 // Register Long Remainder
 6747 instruct modL_reg_imm16(revenRegL dst, iRegL src1, immL16 src2, roddRegL tmp, flagsReg cr) %{
 6748   match(Set dst (ModL src1 src2));
 6749   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6750   ins_cost(3 * DEFAULT_COST);
 6751   // TODO: s390 port size(VARIABLE_SIZE);
 6752   format %{ &quot;MODG_const  $dst,src1,$src2\t # long&quot; %}
 6753   ins_encode %{
 6754     int divisor = $src2$$constant;
 6755     if (divisor != -1) {
 6756       __ z_lghi(Z_R0_scratch, divisor);
 6757       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6758       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6759     } else {
 6760       __ clear_reg($dst$$Register, true, false);
 6761     }
 6762   %}
 6763   ins_pipe(pipe_class_dummy);
 6764 %}
 6765 
 6766 // SHIFT
 6767 
 6768 // Shift left logical
 6769 
 6770 // Register Shift Left variable
 6771 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6772   match(Set dst (LShiftI src nbits));
 6773   effect(KILL cr); // R1 is killed, too.
 6774   ins_cost(3 * DEFAULT_COST);
 6775   size(14);
 6776   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t# use RISC-like SLLG also for int&quot; %}
 6777   ins_encode %{
 6778     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6779     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6780     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6781   %}
 6782   ins_pipe(pipe_class_dummy);
 6783 %}
 6784 
 6785 // Register Shift Left Immediate
 6786 // Constant shift count is masked in ideal graph already.
 6787 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6788   match(Set dst (LShiftI src nbits));
 6789   size(6);
 6790   format %{ &quot;SLL     $dst,$src,$nbits\t# use RISC-like SLLG also for int&quot; %}
 6791   ins_encode %{
 6792     int Nbit = $nbits$$constant;
 6793     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6794     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6795   %}
 6796   ins_pipe(pipe_class_dummy);
 6797 %}
 6798 
 6799 // Register Shift Left Immediate by 1bit
 6800 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6801   match(Set dst (LShiftI src nbits));
 6802   predicate(PreferLAoverADD);
 6803   ins_cost(DEFAULT_COST_LOW);
 6804   size(4);
 6805   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6806   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6807   ins_pipe(pipe_class_dummy);
 6808 %}
 6809 
 6810 // Register Shift Left Long
 6811 instruct sllL_reg_reg(iRegL dst, iRegL src1, iRegI nbits) %{
 6812   match(Set dst (LShiftL src1 nbits));
 6813   size(6);
 6814   format %{ &quot;SLLG    $dst,$src1,[$nbits]&quot; %}
 6815   opcode(SLLG_ZOPC);
 6816   ins_encode(z_rsyform_reg_reg(dst, src1, nbits));
 6817   ins_pipe(pipe_class_dummy);
 6818 %}
 6819 
 6820 // Register Shift Left Long Immediate
 6821 instruct sllL_reg_imm(iRegL dst, iRegL src1, immI nbits) %{
 6822   match(Set dst (LShiftL src1 nbits));
 6823   size(6);
 6824   format %{ &quot;SLLG    $dst,$src1,$nbits&quot; %}
 6825   opcode(SLLG_ZOPC);
 6826   ins_encode(z_rsyform_const(dst, src1, nbits));
 6827   ins_pipe(pipe_class_dummy);
 6828 %}
 6829 
 6830 // Register Shift Left Long Immediate by 1bit
 6831 instruct sllL_reg_imm_1(iRegL dst, iRegL src1, immI_1 nbits) %{
 6832   match(Set dst (LShiftL src1 nbits));
 6833   predicate(PreferLAoverADD);
 6834   ins_cost(DEFAULT_COST_LOW);
 6835   size(4);
 6836   format %{ &quot;LA      $dst,#0($src1,$src1)\t # SLLG by 1 (long)&quot; %}
 6837   ins_encode %{ __ z_la($dst$$Register, 0, $src1$$Register, $src1$$Register); %}
 6838   ins_pipe(pipe_class_dummy);
 6839 %}
 6840 
 6841 // Shift right arithmetic
 6842 
 6843 // Register Arithmetic Shift Right
 6844 instruct sraI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6845   match(Set dst (RShiftI dst src));
 6846   effect(KILL cr); // R1 is killed, too.
 6847   ins_cost(3 * DEFAULT_COST);
 6848   size(12);
 6849   format %{ &quot;SRA     $dst,[$src] &amp; 31&quot; %}
 6850   ins_encode %{
 6851     __ z_lgr(Z_R1_scratch, $src$$Register);
 6852     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6853     __ z_sra($dst$$Register, 0, Z_R1_scratch);
 6854   %}
 6855   ins_pipe(pipe_class_dummy);
 6856 %}
 6857 
 6858 // Register Arithmetic Shift Right Immediate
 6859 // Constant shift count is masked in ideal graph already.
 6860 instruct sraI_reg_imm(iRegI dst, immI src, flagsReg cr) %{
 6861   match(Set dst (RShiftI dst src));
 6862   effect(KILL cr);
 6863   size(4);
 6864   format %{ &quot;SRA     $dst,$src&quot; %}
 6865   ins_encode %{
 6866     int Nbit = $src$$constant;
 6867     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6868     __ z_sra($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6869   %}
 6870   ins_pipe(pipe_class_dummy);
 6871 %}
 6872 
 6873 // Register Arithmetic Shift Right Long
 6874 instruct sraL_reg_reg(iRegL dst, iRegL src1, iRegI src2, flagsReg cr) %{
 6875   match(Set dst (RShiftL src1 src2));
 6876   effect(KILL cr);
 6877   size(6);
 6878   format %{ &quot;SRAG    $dst,$src1,[$src2]&quot; %}
 6879   opcode(SRAG_ZOPC);
 6880   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6881   ins_pipe(pipe_class_dummy);
 6882 %}
 6883 
 6884 // Register Arithmetic Shift Right Long Immediate
 6885 instruct sraL_reg_imm(iRegL dst, iRegL src1, immI src2, flagsReg cr) %{
 6886   match(Set dst (RShiftL src1 src2));
 6887   effect(KILL cr);
 6888   size(6);
 6889   format %{ &quot;SRAG    $dst,$src1,$src2&quot; %}
 6890   opcode(SRAG_ZOPC);
 6891   ins_encode(z_rsyform_const(dst, src1, src2));
 6892   ins_pipe(pipe_class_dummy);
 6893 %}
 6894 
 6895 //  Shift right logical
 6896 
 6897 // Register Shift Right
 6898 instruct srlI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6899   match(Set dst (URShiftI dst src));
 6900   effect(KILL cr); // R1 is killed, too.
 6901   ins_cost(3 * DEFAULT_COST);
 6902   size(12);
 6903   format %{ &quot;SRL     $dst,[$src] &amp; 31&quot; %}
 6904   ins_encode %{
 6905     __ z_lgr(Z_R1_scratch, $src$$Register);
 6906     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6907     __ z_srl($dst$$Register, 0, Z_R1_scratch);
 6908   %}
 6909   ins_pipe(pipe_class_dummy);
 6910 %}
 6911 
 6912 // Register Shift Right Immediate
 6913 // Constant shift count is masked in ideal graph already.
 6914 instruct srlI_reg_imm(iRegI dst, immI src) %{
 6915   match(Set dst (URShiftI dst src));
 6916   size(4);
 6917   format %{ &quot;SRL     $dst,$src&quot; %}
 6918   ins_encode %{
 6919     int Nbit = $src$$constant;
 6920     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6921     __ z_srl($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6922   %}
 6923   ins_pipe(pipe_class_dummy);
 6924 %}
 6925 
 6926 // Register Shift Right Long
 6927 instruct srlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6928   match(Set dst (URShiftL src1 src2));
 6929   size(6);
 6930   format %{ &quot;SRLG    $dst,$src1,[$src2]&quot; %}
 6931   opcode(SRLG_ZOPC);
 6932   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6933   ins_pipe(pipe_class_dummy);
 6934 %}
 6935 
 6936 // Register Shift Right Long Immediate
 6937 instruct srlL_reg_imm(iRegL dst, iRegL src1, immI src2) %{
 6938   match(Set dst (URShiftL src1 src2));
 6939   size(6);
 6940   format %{ &quot;SRLG    $dst,$src1,$src2&quot; %}
 6941   opcode(SRLG_ZOPC);
 6942   ins_encode(z_rsyform_const(dst, src1, src2));
 6943   ins_pipe(pipe_class_dummy);
 6944 %}
 6945 
 6946 // Register Shift Right Immediate with a CastP2X
 6947 instruct srlP_reg_imm(iRegL dst, iRegP_N2P src1, immI src2) %{
 6948   match(Set dst (URShiftL (CastP2X src1) src2));
 6949   size(6);
 6950   format %{ &quot;SRLG    $dst,$src1,$src2\t # Cast ptr $src1 to long and shift&quot; %}
 6951   opcode(SRLG_ZOPC);
 6952   ins_encode(z_rsyform_const(dst, src1, src2));
 6953   ins_pipe(pipe_class_dummy);
 6954 %}
 6955 
 6956 //----------Rotate Instructions------------------------------------------------
 6957 
 6958 // Rotate left 32bit.
 6959 instruct rotlI_reg_immI8(iRegI dst, iRegI src, immI8 lshift, immI8 rshift) %{
 6960   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 6961   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 6962   size(6);
 6963   format %{ &quot;RLL     $dst,$src,$lshift\t # ROTL32&quot; %}
 6964   opcode(RLL_ZOPC);
 6965   ins_encode(z_rsyform_const(dst, src, lshift));
 6966   ins_pipe(pipe_class_dummy);
 6967 %}
 6968 
 6969 // Rotate left 64bit.
 6970 instruct rotlL_reg_immI8(iRegL dst, iRegL src, immI8 lshift, immI8 rshift) %{
 6971   match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));
 6972   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 6973   size(6);
 6974   format %{ &quot;RLLG    $dst,$src,$lshift\t # ROTL64&quot; %}
 6975   opcode(RLLG_ZOPC);
 6976   ins_encode(z_rsyform_const(dst, src, lshift));
 6977   ins_pipe(pipe_class_dummy);
 6978 %}
 6979 
 6980 // Rotate right 32bit.
 6981 instruct rotrI_reg_immI8(iRegI dst, iRegI src, immI8 rshift, immI8 lshift) %{
 6982   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 6983   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 6984   // TODO: s390 port size(FIXED_SIZE);
 6985   format %{ &quot;RLL     $dst,$src,$rshift\t # ROTR32&quot; %}
 6986   opcode(RLL_ZOPC);
 6987   ins_encode(z_rsyform_const(dst, src, rshift));
 6988   ins_pipe(pipe_class_dummy);
 6989 %}
 6990 
 6991 // Rotate right 64bit.
 6992 instruct rotrL_reg_immI8(iRegL dst, iRegL src, immI8 rshift, immI8 lshift) %{
 6993   match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));
 6994   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 6995   // TODO: s390 port size(FIXED_SIZE);
 6996   format %{ &quot;RLLG    $dst,$src,$rshift\t # ROTR64&quot; %}
 6997   opcode(RLLG_ZOPC);
 6998   ins_encode(z_rsyform_const(dst, src, rshift));
 6999   ins_pipe(pipe_class_dummy);
 7000 %}
 7001 
 7002 
 7003 //----------Overflow Math Instructions-----------------------------------------
 7004 
 7005 instruct overflowAddI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7006   match(Set cr (OverflowAddI op1 op2));
 7007   effect(DEF cr, USE op1, USE op2);
 7008   // TODO: s390 port size(FIXED_SIZE);
 7009   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7010   ins_encode %{
 7011     __ z_lr(Z_R0_scratch, $op1$$Register);
 7012     __ z_ar(Z_R0_scratch, $op2$$Register);
 7013   %}
 7014   ins_pipe(pipe_class_dummy);
 7015 %}
 7016 
 7017 instruct overflowAddI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7018   match(Set cr (OverflowAddI op1 op2));
 7019   effect(DEF cr, USE op1, USE op2);
 7020   // TODO: s390 port size(VARIABLE_SIZE);
 7021   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7022   ins_encode %{
 7023     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7024     __ z_ar(Z_R0_scratch, $op1$$Register);
 7025   %}
 7026   ins_pipe(pipe_class_dummy);
 7027 %}
 7028 
 7029 instruct overflowAddL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7030   match(Set cr (OverflowAddL op1 op2));
 7031   effect(DEF cr, USE op1, USE op2);
 7032   // TODO: s390 port size(FIXED_SIZE);
 7033   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7034   ins_encode %{
 7035     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7036     __ z_agr(Z_R0_scratch, $op2$$Register);
 7037   %}
 7038   ins_pipe(pipe_class_dummy);
 7039 %}
 7040 
 7041 instruct overflowAddL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7042   match(Set cr (OverflowAddL op1 op2));
 7043   effect(DEF cr, USE op1, USE op2);
 7044   // TODO: s390 port size(VARIABLE_SIZE);
 7045   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7046   ins_encode %{
 7047     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7048     __ z_agr(Z_R0_scratch, $op1$$Register);
 7049   %}
 7050   ins_pipe(pipe_class_dummy);
 7051 %}
 7052 
 7053 instruct overflowSubI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7054   match(Set cr (OverflowSubI op1 op2));
 7055   effect(DEF cr, USE op1, USE op2);
 7056   // TODO: s390 port size(FIXED_SIZE);
 7057   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7058   ins_encode %{
 7059     __ z_lr(Z_R0_scratch, $op1$$Register);
 7060     __ z_sr(Z_R0_scratch, $op2$$Register);
 7061   %}
 7062   ins_pipe(pipe_class_dummy);
 7063 %}
 7064 
 7065 instruct overflowSubI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7066   match(Set cr (OverflowSubI op1 op2));
 7067   effect(DEF cr, USE op1, USE op2);
 7068   // TODO: s390 port size(VARIABLE_SIZE);
 7069   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7070   ins_encode %{
 7071     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7072     __ z_lr(Z_R0_scratch, $op1$$Register);
 7073     __ z_sr(Z_R0_scratch, Z_R1_scratch);
 7074   %}
 7075   ins_pipe(pipe_class_dummy);
 7076 %}
 7077 
 7078 instruct overflowSubL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7079   match(Set cr (OverflowSubL op1 op2));
 7080   effect(DEF cr, USE op1, USE op2);
 7081   // TODO: s390 port size(FIXED_SIZE);
 7082   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7083   ins_encode %{
 7084     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7085     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7086   %}
 7087   ins_pipe(pipe_class_dummy);
 7088 %}
 7089 
 7090 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7091   match(Set cr (OverflowSubL op1 op2));
 7092   effect(DEF cr, USE op1, USE op2);
 7093   // TODO: s390 port size(VARIABLE_SIZE);
 7094   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7095   ins_encode %{
 7096     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7097     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7098     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7099   %}
 7100   ins_pipe(pipe_class_dummy);
 7101 %}
 7102 
 7103 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7104   match(Set cr (OverflowSubI zero op2));
 7105   effect(DEF cr, USE op2);
 7106   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 7107   ins_encode %{
 7108     __ clear_reg(Z_R0_scratch, false, false);
 7109     __ z_sr(Z_R0_scratch, $op2$$Register);
 7110   %}
 7111   ins_pipe(pipe_class_dummy);
 7112 %}
 7113 
 7114 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7115   match(Set cr (OverflowSubL zero op2));
 7116   effect(DEF cr, USE op2);
 7117   format %{ &quot;NEGG    $op2\t# overflow check long&quot; %}
 7118   ins_encode %{
 7119     __ clear_reg(Z_R0_scratch, true, false);
 7120     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7121   %}
 7122   ins_pipe(pipe_class_dummy);
 7123 %}
 7124 
 7125 // No intrinsics for multiplication, since there is no easy way
 7126 // to check for overflow.
 7127 
 7128 
 7129 //----------Floating Point Arithmetic Instructions-----------------------------
 7130 
 7131 //  ADD
 7132 
 7133 //  Add float single precision
 7134 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7135   match(Set dst (AddF dst src));
 7136   effect(KILL cr);
 7137   ins_cost(ALU_REG_COST);
 7138   size(4);
 7139   format %{ &quot;AEBR     $dst,$src&quot; %}
 7140   opcode(AEBR_ZOPC);
 7141   ins_encode(z_rreform(dst, src));
 7142   ins_pipe(pipe_class_dummy);
 7143 %}
 7144 
 7145 instruct addF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7146   match(Set dst (AddF dst (LoadF src)));
 7147   effect(KILL cr);
 7148   ins_cost(ALU_MEMORY_COST);
 7149   size(6);
 7150   format %{ &quot;AEB      $dst,$src\t # floatMemory&quot; %}
 7151   opcode(AEB_ZOPC);
 7152   ins_encode(z_form_rt_memFP(dst, src));
 7153   ins_pipe(pipe_class_dummy);
 7154 %}
 7155 
 7156 // Add float double precision
 7157 instruct addD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7158   match(Set dst (AddD dst src));
 7159   effect(KILL cr);
 7160   ins_cost(ALU_REG_COST);
 7161   size(4);
 7162   format %{ &quot;ADBR     $dst,$src&quot; %}
 7163   opcode(ADBR_ZOPC);
 7164   ins_encode(z_rreform(dst, src));
 7165   ins_pipe(pipe_class_dummy);
 7166 %}
 7167 
 7168 instruct addD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7169   match(Set dst (AddD dst (LoadD src)));
 7170   effect(KILL cr);
 7171   ins_cost(ALU_MEMORY_COST);
 7172   size(6);
 7173   format %{ &quot;ADB      $dst,$src\t # doubleMemory&quot; %}
 7174   opcode(ADB_ZOPC);
 7175   ins_encode(z_form_rt_memFP(dst, src));
 7176   ins_pipe(pipe_class_dummy);
 7177 %}
 7178 
 7179 // SUB
 7180 
 7181 // Sub float single precision
 7182 instruct subF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7183   match(Set dst (SubF dst src));
 7184   effect(KILL cr);
 7185   ins_cost(ALU_REG_COST);
 7186   size(4);
 7187   format %{ &quot;SEBR     $dst,$src&quot; %}
 7188   opcode(SEBR_ZOPC);
 7189   ins_encode(z_rreform(dst, src));
 7190   ins_pipe(pipe_class_dummy);
 7191 %}
 7192 
 7193 instruct subF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7194   match(Set dst (SubF dst (LoadF src)));
 7195   effect(KILL cr);
 7196   ins_cost(ALU_MEMORY_COST);
 7197   size(6);
 7198   format %{ &quot;SEB      $dst,$src\t # floatMemory&quot; %}
 7199   opcode(SEB_ZOPC);
 7200   ins_encode(z_form_rt_memFP(dst, src));
 7201   ins_pipe(pipe_class_dummy);
 7202 %}
 7203 
 7204 //  Sub float double precision
 7205 instruct subD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7206   match(Set dst (SubD dst src));
 7207   effect(KILL cr);
 7208   ins_cost(ALU_REG_COST);
 7209   size(4);
 7210   format %{ &quot;SDBR     $dst,$src&quot; %}
 7211   opcode(SDBR_ZOPC);
 7212   ins_encode(z_rreform(dst, src));
 7213   ins_pipe(pipe_class_dummy);
 7214 %}
 7215 
 7216 instruct subD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7217   match(Set dst (SubD dst (LoadD src)));
 7218   effect(KILL cr);
 7219   ins_cost(ALU_MEMORY_COST);
 7220   size(6);
 7221   format %{ &quot;SDB      $dst,$src\t # doubleMemory&quot; %}
 7222   opcode(SDB_ZOPC);
 7223   ins_encode(z_form_rt_memFP(dst, src));
 7224   ins_pipe(pipe_class_dummy);
 7225 %}
 7226 
 7227 // MUL
 7228 
 7229 // Mul float single precision
 7230 instruct mulF_reg_reg(regF dst, regF src) %{
 7231   match(Set dst (MulF dst src));
 7232   // CC unchanged by MUL.
 7233   ins_cost(ALU_REG_COST);
 7234   size(4);
 7235   format %{ &quot;MEEBR    $dst,$src&quot; %}
 7236   opcode(MEEBR_ZOPC);
 7237   ins_encode(z_rreform(dst, src));
 7238   ins_pipe(pipe_class_dummy);
 7239 %}
 7240 
 7241 instruct mulF_reg_mem(regF dst, memoryRX src)%{
 7242   match(Set dst (MulF dst (LoadF src)));
 7243   // CC unchanged by MUL.
 7244   ins_cost(ALU_MEMORY_COST);
 7245   size(6);
 7246   format %{ &quot;MEEB     $dst,$src\t # floatMemory&quot; %}
 7247   opcode(MEEB_ZOPC);
 7248   ins_encode(z_form_rt_memFP(dst, src));
 7249   ins_pipe(pipe_class_dummy);
 7250 %}
 7251 
 7252 //  Mul float double precision
 7253 instruct mulD_reg_reg(regD dst, regD src) %{
 7254   match(Set dst (MulD dst src));
 7255   // CC unchanged by MUL.
 7256   ins_cost(ALU_REG_COST);
 7257   size(4);
 7258   format %{ &quot;MDBR     $dst,$src&quot; %}
 7259   opcode(MDBR_ZOPC);
 7260   ins_encode(z_rreform(dst, src));
 7261   ins_pipe(pipe_class_dummy);
 7262 %}
 7263 
 7264 instruct mulD_reg_mem(regD dst, memoryRX src)%{
 7265   match(Set dst (MulD dst (LoadD src)));
 7266   // CC unchanged by MUL.
 7267   ins_cost(ALU_MEMORY_COST);
 7268   size(6);
 7269   format %{ &quot;MDB      $dst,$src\t # doubleMemory&quot; %}
 7270   opcode(MDB_ZOPC);
 7271   ins_encode(z_form_rt_memFP(dst, src));
 7272   ins_pipe(pipe_class_dummy);
 7273 %}
 7274 
 7275 // Multiply-Accumulate
 7276 // src1 * src2 + dst
 7277 instruct maddF_reg_reg(regF dst, regF src1, regF src2) %{
 7278   match(Set dst (FmaF dst (Binary src1 src2)));
 7279   // CC unchanged by MUL-ADD.
 7280   ins_cost(ALU_REG_COST);
 7281   size(4);
 7282   format %{ &quot;MAEBR    $dst, $src1, $src2&quot; %}
 7283   ins_encode %{
 7284     __ z_maebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7285   %}
 7286   ins_pipe(pipe_class_dummy);
 7287 %}
 7288 
 7289 // src1 * src2 + dst
 7290 instruct maddD_reg_reg(regD dst, regD src1, regD src2) %{
 7291   match(Set dst (FmaD dst (Binary src1 src2)));
 7292   // CC unchanged by MUL-ADD.
 7293   ins_cost(ALU_REG_COST);
 7294   size(4);
 7295   format %{ &quot;MADBR    $dst, $src1, $src2&quot; %}
 7296   ins_encode %{
 7297     __ z_madbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7298   %}
 7299   ins_pipe(pipe_class_dummy);
 7300 %}
 7301 
 7302 // src1 * src2 - dst
 7303 instruct msubF_reg_reg(regF dst, regF src1, regF src2) %{
 7304   match(Set dst (FmaF (NegF dst) (Binary src1 src2)));
 7305   // CC unchanged by MUL-SUB.
 7306   ins_cost(ALU_REG_COST);
 7307   size(4);
 7308   format %{ &quot;MSEBR    $dst, $src1, $src2&quot; %}
 7309   ins_encode %{
 7310     __ z_msebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7311   %}
 7312   ins_pipe(pipe_class_dummy);
 7313 %}
 7314 
 7315 // src1 * src2 - dst
 7316 instruct msubD_reg_reg(regD dst, regD src1, regD src2) %{
 7317   match(Set dst (FmaD (NegD dst) (Binary src1 src2)));
 7318   // CC unchanged by MUL-SUB.
 7319   ins_cost(ALU_REG_COST);
 7320   size(4);
 7321   format %{ &quot;MSDBR    $dst, $src1, $src2&quot; %}
 7322   ins_encode %{
 7323     __ z_msdbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7324   %}
 7325   ins_pipe(pipe_class_dummy);
 7326 %}
 7327 
 7328 // src1 * src2 + dst
 7329 instruct maddF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7330   match(Set dst (FmaF dst (Binary src1 (LoadF src2))));
 7331   // CC unchanged by MUL-ADD.
 7332   ins_cost(ALU_MEMORY_COST);
 7333   size(6);
 7334   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7335   ins_encode %{
 7336     __ z_maeb($dst$$FloatRegister, $src1$$FloatRegister,
 7337               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7338   %}
 7339   ins_pipe(pipe_class_dummy);
 7340 %}
 7341 
 7342 // src1 * src2 + dst
 7343 instruct maddD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7344   match(Set dst (FmaD dst (Binary src1 (LoadD src2))));
 7345   // CC unchanged by MUL-ADD.
 7346   ins_cost(ALU_MEMORY_COST);
 7347   size(6);
 7348   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7349   ins_encode %{
 7350     __ z_madb($dst$$FloatRegister, $src1$$FloatRegister,
 7351               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7352   %}
 7353   ins_pipe(pipe_class_dummy);
 7354 %}
 7355 
 7356 // src1 * src2 - dst
 7357 instruct msubF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7358   match(Set dst (FmaF (NegF dst) (Binary src1 (LoadF src2))));
 7359   // CC unchanged by MUL-SUB.
 7360   ins_cost(ALU_MEMORY_COST);
 7361   size(6);
 7362   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7363   ins_encode %{
 7364     __ z_mseb($dst$$FloatRegister, $src1$$FloatRegister,
 7365               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7366   %}
 7367   ins_pipe(pipe_class_dummy);
 7368 %}
 7369 
 7370 // src1 * src2 - dst
 7371 instruct msubD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7372   match(Set dst (FmaD (NegD dst) (Binary src1 (LoadD src2))));
 7373   // CC unchanged by MUL-SUB.
 7374   ins_cost(ALU_MEMORY_COST);
 7375   size(6);
 7376   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7377   ins_encode %{
 7378     __ z_msdb($dst$$FloatRegister, $src1$$FloatRegister,
 7379               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7380   %}
 7381   ins_pipe(pipe_class_dummy);
 7382 %}
 7383 
 7384 // src1 * src2 + dst
 7385 instruct maddF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7386   match(Set dst (FmaF dst (Binary (LoadF src1) src2)));
 7387   // CC unchanged by MUL-ADD.
 7388   ins_cost(ALU_MEMORY_COST);
 7389   size(6);
 7390   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7391   ins_encode %{
 7392     __ z_maeb($dst$$FloatRegister, $src2$$FloatRegister,
 7393               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7394   %}
 7395   ins_pipe(pipe_class_dummy);
 7396 %}
 7397 
 7398 // src1 * src2 + dst
 7399 instruct maddD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7400   match(Set dst (FmaD dst (Binary (LoadD src1) src2)));
 7401   // CC unchanged by MUL-ADD.
 7402   ins_cost(ALU_MEMORY_COST);
 7403   size(6);
 7404   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7405   ins_encode %{
 7406     __ z_madb($dst$$FloatRegister, $src2$$FloatRegister,
 7407               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7408   %}
 7409   ins_pipe(pipe_class_dummy);
 7410 %}
 7411 
 7412 // src1 * src2 - dst
 7413 instruct msubF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7414   match(Set dst (FmaF (NegF dst) (Binary (LoadF src1) src2)));
 7415   // CC unchanged by MUL-SUB.
 7416   ins_cost(ALU_MEMORY_COST);
 7417   size(6);
 7418   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7419   ins_encode %{
 7420     __ z_mseb($dst$$FloatRegister, $src2$$FloatRegister,
 7421               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7422   %}
 7423   ins_pipe(pipe_class_dummy);
 7424 %}
 7425 
 7426 // src1 * src2 - dst
 7427 instruct msubD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7428   match(Set dst (FmaD (NegD dst) (Binary (LoadD src1) src2)));
 7429   // CC unchanged by MUL-SUB.
 7430   ins_cost(ALU_MEMORY_COST);
 7431   size(6);
 7432   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7433   ins_encode %{
 7434     __ z_msdb($dst$$FloatRegister, $src2$$FloatRegister,
 7435               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7436   %}
 7437   ins_pipe(pipe_class_dummy);
 7438 %}
 7439 
 7440 //  DIV
 7441 
 7442 //  Div float single precision
 7443 instruct divF_reg_reg(regF dst, regF src) %{
 7444   match(Set dst (DivF dst src));
 7445   // CC unchanged by DIV.
 7446   ins_cost(ALU_REG_COST);
 7447   size(4);
 7448   format %{ &quot;DEBR     $dst,$src&quot; %}
 7449   opcode(DEBR_ZOPC);
 7450   ins_encode(z_rreform(dst, src));
 7451   ins_pipe(pipe_class_dummy);
 7452 %}
 7453 
 7454 instruct divF_reg_mem(regF dst, memoryRX src)%{
 7455   match(Set dst (DivF dst (LoadF src)));
 7456   // CC unchanged by DIV.
 7457   ins_cost(ALU_MEMORY_COST);
 7458   size(6);
 7459   format %{ &quot;DEB      $dst,$src\t # floatMemory&quot; %}
 7460   opcode(DEB_ZOPC);
 7461   ins_encode(z_form_rt_memFP(dst, src));
 7462   ins_pipe(pipe_class_dummy);
 7463 %}
 7464 
 7465 //  Div float double precision
 7466 instruct divD_reg_reg(regD dst, regD src) %{
 7467   match(Set dst (DivD dst src));
 7468   // CC unchanged by DIV.
 7469   ins_cost(ALU_REG_COST);
 7470   size(4);
 7471   format %{ &quot;DDBR     $dst,$src&quot; %}
 7472   opcode(DDBR_ZOPC);
 7473   ins_encode(z_rreform(dst, src));
 7474   ins_pipe(pipe_class_dummy);
 7475 %}
 7476 
 7477 instruct divD_reg_mem(regD dst, memoryRX src)%{
 7478   match(Set dst (DivD dst (LoadD src)));
 7479   // CC unchanged by DIV.
 7480   ins_cost(ALU_MEMORY_COST);
 7481   size(6);
 7482   format %{ &quot;DDB      $dst,$src\t # doubleMemory&quot; %}
 7483   opcode(DDB_ZOPC);
 7484   ins_encode(z_form_rt_memFP(dst, src));
 7485   ins_pipe(pipe_class_dummy);
 7486 %}
 7487 
 7488 // ABS
 7489 
 7490 // Absolute float single precision
 7491 instruct absF_reg(regF dst, regF src, flagsReg cr) %{
 7492   match(Set dst (AbsF src));
 7493   effect(KILL cr);
 7494   size(4);
 7495   format %{ &quot;LPEBR    $dst,$src\t float&quot; %}
 7496   opcode(LPEBR_ZOPC);
 7497   ins_encode(z_rreform(dst, src));
 7498   ins_pipe(pipe_class_dummy);
 7499 %}
 7500 
 7501 // Absolute float double precision
 7502 instruct absD_reg(regD dst, regD src, flagsReg cr) %{
 7503   match(Set dst (AbsD src));
 7504   effect(KILL cr);
 7505   size(4);
 7506   format %{ &quot;LPDBR    $dst,$src\t double&quot; %}
 7507   opcode(LPDBR_ZOPC);
 7508   ins_encode(z_rreform(dst, src));
 7509   ins_pipe(pipe_class_dummy);
 7510 %}
 7511 
 7512 //  NEG(ABS)
 7513 
 7514 // Negative absolute float single precision
 7515 instruct nabsF_reg(regF dst, regF src, flagsReg cr) %{
 7516   match(Set dst (NegF (AbsF src)));
 7517   effect(KILL cr);
 7518   size(4);
 7519   format %{ &quot;LNEBR    $dst,$src\t float&quot; %}
 7520   opcode(LNEBR_ZOPC);
 7521   ins_encode(z_rreform(dst, src));
 7522   ins_pipe(pipe_class_dummy);
 7523 %}
 7524 
 7525 // Negative absolute float double precision
 7526 instruct nabsD_reg(regD dst, regD src, flagsReg cr) %{
 7527   match(Set dst (NegD (AbsD src)));
 7528   effect(KILL cr);
 7529   size(4);
 7530   format %{ &quot;LNDBR    $dst,$src\t double&quot; %}
 7531   opcode(LNDBR_ZOPC);
 7532   ins_encode(z_rreform(dst, src));
 7533   ins_pipe(pipe_class_dummy);
 7534 %}
 7535 
 7536 // NEG
 7537 
 7538 instruct negF_reg(regF dst, regF src, flagsReg cr) %{
 7539   match(Set dst (NegF src));
 7540   effect(KILL cr);
 7541   size(4);
 7542   format %{ &quot;NegF     $dst,$src\t float&quot; %}
 7543   ins_encode %{ __ z_lcebr($dst$$FloatRegister, $src$$FloatRegister); %}
 7544   ins_pipe(pipe_class_dummy);
 7545 %}
 7546 
 7547 instruct negD_reg(regD dst, regD src, flagsReg cr) %{
 7548   match(Set dst (NegD src));
 7549   effect(KILL cr);
 7550   size(4);
 7551   format %{ &quot;NegD     $dst,$src\t double&quot; %}
 7552   ins_encode %{ __ z_lcdbr($dst$$FloatRegister, $src$$FloatRegister); %}
 7553   ins_pipe(pipe_class_dummy);
 7554 %}
 7555 
 7556 // SQRT
 7557 
 7558 // Sqrt float precision
 7559 instruct sqrtF_reg(regF dst, regF src) %{
 7560   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7561   // CC remains unchanged.
 7562   ins_cost(ALU_REG_COST);
 7563   size(4);
 7564   format %{ &quot;SQEBR    $dst,$src&quot; %}
 7565   opcode(SQEBR_ZOPC);
 7566   ins_encode(z_rreform(dst, src));
 7567   ins_pipe(pipe_class_dummy);
 7568 %}
 7569 
 7570 // Sqrt double precision
 7571 instruct sqrtD_reg(regD dst, regD src) %{
 7572   match(Set dst (SqrtD src));
 7573   // CC remains unchanged.
 7574   ins_cost(ALU_REG_COST);
 7575   size(4);
 7576   format %{ &quot;SQDBR    $dst,$src&quot; %}
 7577   opcode(SQDBR_ZOPC);
 7578   ins_encode(z_rreform(dst, src));
 7579   ins_pipe(pipe_class_dummy);
 7580 %}
 7581 
 7582 instruct sqrtF_mem(regF dst, memoryRX src) %{
 7583   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7584   // CC remains unchanged.
 7585   ins_cost(ALU_MEMORY_COST);
 7586   size(6);
 7587   format %{ &quot;SQEB     $dst,$src\t # floatMemory&quot; %}
 7588   opcode(SQEB_ZOPC);
 7589   ins_encode(z_form_rt_memFP(dst, src));
 7590   ins_pipe(pipe_class_dummy);
 7591 %}
 7592 
 7593 instruct sqrtD_mem(regD dst, memoryRX src) %{
 7594   match(Set dst (SqrtD src));
 7595   // CC remains unchanged.
 7596   ins_cost(ALU_MEMORY_COST);
 7597   // TODO: s390 port size(FIXED_SIZE);
 7598   format %{ &quot;SQDB     $dst,$src\t # doubleMemory&quot; %}
 7599   opcode(SQDB_ZOPC);
 7600   ins_encode(z_form_rt_memFP(dst, src));
 7601   ins_pipe(pipe_class_dummy);
 7602 %}
 7603 
 7604 //----------Logical Instructions-----------------------------------------------
 7605 
 7606 // Register And
 7607 instruct andI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7608   match(Set dst (AndI dst src));
 7609   effect(KILL cr);
 7610   ins_cost(DEFAULT_COST_LOW);
 7611   size(2);
 7612   format %{ &quot;NR      $dst,$src\t # int&quot; %}
 7613   opcode(NR_ZOPC);
 7614   ins_encode(z_rrform(dst, src));
 7615   ins_pipe(pipe_class_dummy);
 7616 %}
 7617 
 7618 instruct andI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7619   match(Set dst (AndI dst (LoadI src)));
 7620   effect(KILL cr);
 7621   ins_cost(MEMORY_REF_COST);
 7622   // TODO: s390 port size(VARIABLE_SIZE);
 7623   format %{ &quot;N(Y)    $dst, $src\t # int&quot; %}
 7624   opcode(NY_ZOPC, N_ZOPC);
 7625   ins_encode(z_form_rt_mem_opt(dst, src));
 7626   ins_pipe(pipe_class_dummy);
 7627 %}
 7628 
 7629 // Immediate And
 7630 instruct andI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7631   match(Set dst (AndI dst src));
 7632   effect(KILL cr);
 7633   ins_cost(DEFAULT_COST_HIGH);
 7634   size(6);
 7635   format %{ &quot;NILF    $dst,$src&quot; %}
 7636   opcode(NILF_ZOPC);
 7637   ins_encode(z_rilform_unsigned(dst, src));
 7638   ins_pipe(pipe_class_dummy);
 7639 %}
 7640 
 7641 instruct andI_reg_uimmI_LH1(iRegI dst, uimmI_LH1 src, flagsReg cr) %{
 7642   match(Set dst (AndI dst src));
 7643   effect(KILL cr);
 7644   ins_cost(DEFAULT_COST);
 7645   size(4);
 7646   format %{ &quot;NILH    $dst,$src&quot; %}
 7647   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7648   ins_pipe(pipe_class_dummy);
 7649 %}
 7650 
 7651 instruct andI_reg_uimmI_LL1(iRegI dst, uimmI_LL1 src, flagsReg cr) %{
 7652   match(Set dst (AndI dst src));
 7653   effect(KILL cr);
 7654   ins_cost(DEFAULT_COST);
 7655   size(4);
 7656   format %{ &quot;NILL    $dst,$src&quot; %}
 7657   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7658   ins_pipe(pipe_class_dummy);
 7659 %}
 7660 
 7661 // Register And Long
 7662 instruct andL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7663   match(Set dst (AndL dst src));
 7664   effect(KILL cr);
 7665   ins_cost(DEFAULT_COST);
 7666   size(4);
 7667   format %{ &quot;NGR     $dst,$src\t # long&quot; %}
 7668   opcode(NGR_ZOPC);
 7669   ins_encode(z_rreform(dst, src));
 7670   ins_pipe(pipe_class_dummy);
 7671 %}
 7672 
 7673 instruct andL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7674   match(Set dst (AndL dst (LoadL src)));
 7675   effect(KILL cr);
 7676   ins_cost(MEMORY_REF_COST);
 7677   size(Z_DISP3_SIZE);
 7678   format %{ &quot;NG      $dst, $src\t # long&quot; %}
 7679   opcode(NG_ZOPC, NG_ZOPC);
 7680   ins_encode(z_form_rt_mem_opt(dst, src));
 7681   ins_pipe(pipe_class_dummy);
 7682 %}
 7683 
 7684 instruct andL_reg_uimmL_LL1(iRegL dst, uimmL_LL1 src, flagsReg cr) %{
 7685   match(Set dst (AndL dst src));
 7686   effect(KILL cr);
 7687   ins_cost(DEFAULT_COST);
 7688   size(4);
 7689   format %{ &quot;NILL    $dst,$src\t # long&quot; %}
 7690   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7691   ins_pipe(pipe_class_dummy);
 7692 %}
 7693 
 7694 instruct andL_reg_uimmL_LH1(iRegL dst, uimmL_LH1 src, flagsReg cr) %{
 7695   match(Set dst (AndL dst src));
 7696   effect(KILL cr);
 7697   ins_cost(DEFAULT_COST);
 7698   size(4);
 7699   format %{ &quot;NILH    $dst,$src\t # long&quot; %}
 7700   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7701   ins_pipe(pipe_class_dummy);
 7702 %}
 7703 
 7704 instruct andL_reg_uimmL_HL1(iRegL dst, uimmL_HL1 src, flagsReg cr) %{
 7705   match(Set dst (AndL dst src));
 7706   effect(KILL cr);
 7707   ins_cost(DEFAULT_COST);
 7708   size(4);
 7709   format %{ &quot;NIHL    $dst,$src\t # long&quot; %}
 7710   ins_encode %{ __ z_nihl($dst$$Register, ($src$$constant &gt;&gt; 32) &amp; 0xFFFF); %}
 7711   ins_pipe(pipe_class_dummy);
 7712 %}
 7713 
 7714 instruct andL_reg_uimmL_HH1(iRegL dst, uimmL_HH1 src, flagsReg cr) %{
 7715   match(Set dst (AndL dst src));
 7716   effect(KILL cr);
 7717   ins_cost(DEFAULT_COST);
 7718   size(4);
 7719   format %{ &quot;NIHH    $dst,$src\t # long&quot; %}
 7720   ins_encode %{ __ z_nihh($dst$$Register, ($src$$constant &gt;&gt; 48) &amp; 0xFFFF); %}
 7721   ins_pipe(pipe_class_dummy);
 7722 %}
 7723 
 7724 //  OR
 7725 
 7726 // Or Instructions
 7727 // Register Or
 7728 instruct orI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7729   match(Set dst (OrI dst src));
 7730   effect(KILL cr);
 7731   size(2);
 7732   format %{ &quot;OR      $dst,$src&quot; %}
 7733   opcode(OR_ZOPC);
 7734   ins_encode(z_rrform(dst, src));
 7735   ins_pipe(pipe_class_dummy);
 7736 %}
 7737 
 7738 instruct orI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7739   match(Set dst (OrI dst (LoadI src)));
 7740   effect(KILL cr);
 7741   ins_cost(MEMORY_REF_COST);
 7742   // TODO: s390 port size(VARIABLE_SIZE);
 7743   format %{ &quot;O(Y)    $dst, $src\t # int&quot; %}
 7744   opcode(OY_ZOPC, O_ZOPC);
 7745   ins_encode(z_form_rt_mem_opt(dst, src));
 7746   ins_pipe(pipe_class_dummy);
 7747 %}
 7748 
 7749 // Immediate Or
 7750 instruct orI_reg_uimm16(iRegI dst, uimmI16 con, flagsReg cr) %{
 7751   match(Set dst (OrI dst con));
 7752   effect(KILL cr);
 7753   size(4);
 7754   format %{ &quot;OILL    $dst,$con&quot; %}
 7755   opcode(OILL_ZOPC);
 7756   ins_encode(z_riform_unsigned(dst,con));
 7757   ins_pipe(pipe_class_dummy);
 7758 %}
 7759 
 7760 instruct orI_reg_uimm32(iRegI dst, uimmI con, flagsReg cr) %{
 7761   match(Set dst (OrI dst con));
 7762   effect(KILL cr);
 7763   ins_cost(DEFAULT_COST_HIGH);
 7764   size(6);
 7765   format %{ &quot;OILF    $dst,$con&quot; %}
 7766   opcode(OILF_ZOPC);
 7767   ins_encode(z_rilform_unsigned(dst,con));
 7768   ins_pipe(pipe_class_dummy);
 7769 %}
 7770 
 7771 // Register Or Long
 7772 instruct orL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7773   match(Set dst (OrL dst src));
 7774   effect(KILL cr);
 7775   ins_cost(DEFAULT_COST);
 7776   size(4);
 7777   format %{ &quot;OGR      $dst,$src\t # long&quot; %}
 7778   opcode(OGR_ZOPC);
 7779   ins_encode(z_rreform(dst, src));
 7780   ins_pipe(pipe_class_dummy);
 7781 %}
 7782 
 7783 instruct orL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7784   match(Set dst (OrL dst (LoadL src)));
 7785   effect(KILL cr);
 7786   ins_cost(MEMORY_REF_COST);
 7787   size(Z_DISP3_SIZE);
 7788   format %{ &quot;OG      $dst, $src\t # long&quot; %}
 7789   opcode(OG_ZOPC, OG_ZOPC);
 7790   ins_encode(z_form_rt_mem_opt(dst, src));
 7791   ins_pipe(pipe_class_dummy);
 7792 %}
 7793 
 7794 // Immediate Or long
 7795 instruct orL_reg_uimm16(iRegL dst, uimmL16 con, flagsReg cr) %{
 7796   match(Set dst (OrL dst con));
 7797   effect(KILL cr);
 7798   ins_cost(DEFAULT_COST);
 7799   size(4);
 7800   format %{ &quot;OILL    $dst,$con\t # long&quot; %}
 7801   opcode(OILL_ZOPC);
 7802   ins_encode(z_riform_unsigned(dst,con));
 7803   ins_pipe(pipe_class_dummy);
 7804 %}
 7805 
 7806 instruct orL_reg_uimm32(iRegI dst, uimmL32 con, flagsReg cr) %{
 7807   match(Set dst (OrI dst con));
 7808   effect(KILL cr);
 7809   ins_cost(DEFAULT_COST_HIGH);
 7810   // TODO: s390 port size(FIXED_SIZE);
 7811   format %{ &quot;OILF    $dst,$con\t # long&quot; %}
 7812   opcode(OILF_ZOPC);
 7813   ins_encode(z_rilform_unsigned(dst,con));
 7814   ins_pipe(pipe_class_dummy);
 7815 %}
 7816 
 7817 // XOR
 7818 
 7819 // Register Xor
 7820 instruct xorI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7821   match(Set dst (XorI dst src));
 7822   effect(KILL cr);
 7823   size(2);
 7824   format %{ &quot;XR      $dst,$src&quot; %}
 7825   opcode(XR_ZOPC);
 7826   ins_encode(z_rrform(dst, src));
 7827   ins_pipe(pipe_class_dummy);
 7828 %}
 7829 
 7830 instruct xorI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7831   match(Set dst (XorI dst (LoadI src)));
 7832   effect(KILL cr);
 7833   ins_cost(MEMORY_REF_COST);
 7834   // TODO: s390 port size(VARIABLE_SIZE);
 7835   format %{ &quot;X(Y)    $dst, $src\t # int&quot; %}
 7836   opcode(XY_ZOPC, X_ZOPC);
 7837   ins_encode(z_form_rt_mem_opt(dst, src));
 7838   ins_pipe(pipe_class_dummy);
 7839 %}
 7840 
 7841 // Immediate Xor
 7842 instruct xorI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7843   match(Set dst (XorI dst src));
 7844   effect(KILL cr);
 7845   ins_cost(DEFAULT_COST_HIGH);
 7846   size(6);
 7847   format %{ &quot;XILF    $dst,$src&quot; %}
 7848   opcode(XILF_ZOPC);
 7849   ins_encode(z_rilform_unsigned(dst, src));
 7850   ins_pipe(pipe_class_dummy);
 7851 %}
 7852 
 7853 // Register Xor Long
 7854 instruct xorL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7855   match(Set dst (XorL dst src));
 7856   effect(KILL cr);
 7857   ins_cost(DEFAULT_COST);
 7858   size(4);
 7859   format %{ &quot;XGR     $dst,$src\t # long&quot; %}
 7860   opcode(XGR_ZOPC);
 7861   ins_encode(z_rreform(dst, src));
 7862   ins_pipe(pipe_class_dummy);
 7863 %}
 7864 
 7865 instruct xorL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7866   match(Set dst (XorL dst (LoadL src)));
 7867   effect(KILL cr);
 7868   ins_cost(MEMORY_REF_COST);
 7869   size(Z_DISP3_SIZE);
 7870   format %{ &quot;XG      $dst, $src\t # long&quot; %}
 7871   opcode(XG_ZOPC, XG_ZOPC);
 7872   ins_encode(z_form_rt_mem_opt(dst, src));
 7873   ins_pipe(pipe_class_dummy);
 7874 %}
 7875 
 7876 // Immediate Xor Long
 7877 instruct xorL_reg_uimm32(iRegL dst, uimmL32 con, flagsReg cr) %{
 7878   match(Set dst (XorL dst con));
 7879   effect(KILL cr);
 7880   ins_cost(DEFAULT_COST_HIGH);
 7881   size(6);
 7882   format %{ &quot;XILF    $dst,$con\t # long&quot; %}
 7883   opcode(XILF_ZOPC);
 7884   ins_encode(z_rilform_unsigned(dst,con));
 7885   ins_pipe(pipe_class_dummy);
 7886 %}
 7887 
 7888 //----------Convert to Boolean-------------------------------------------------
 7889 
 7890 // Convert integer to boolean.
 7891 instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{
 7892   match(Set dst (Conv2B src));
 7893   effect(KILL cr);
 7894   ins_cost(3 * DEFAULT_COST);
 7895   size(6);
 7896   format %{ &quot;convI2B $dst,$src&quot; %}
 7897   ins_encode %{
 7898     __ z_lnr($dst$$Register, $src$$Register);  // Rdst := -|Rsrc|, i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7899     __ z_srl($dst$$Register, 31);              // Rdst := sign(Rdest)
 7900   %}
 7901   ins_pipe(pipe_class_dummy);
 7902 %}
 7903 
 7904 instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{
 7905   match(Set dst (Conv2B src));
 7906   effect(KILL cr);
 7907   ins_cost(3 * DEFAULT_COST);
 7908   size(10);
 7909   format %{ &quot;convP2B $dst,$src&quot; %}
 7910   ins_encode %{
 7911     __ z_lngr($dst$$Register, $src$$Register);     // Rdst := -|Rsrc| i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7912     __ z_srlg($dst$$Register, $dst$$Register, 63); // Rdst := sign(Rdest)
 7913   %}
 7914   ins_pipe(pipe_class_dummy);
 7915 %}
 7916 
 7917 instruct cmpLTMask_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7918   match(Set dst (CmpLTMask dst src));
 7919   effect(KILL cr);
 7920   ins_cost(2 * DEFAULT_COST);
 7921   size(18);
 7922   format %{ &quot;Set $dst CmpLTMask $dst,$src&quot; %}
 7923   ins_encode %{
 7924     // Avoid signed 32 bit overflow: Do sign extend and sub 64 bit.
 7925     __ z_lgfr(Z_R0_scratch, $src$$Register);
 7926     __ z_lgfr($dst$$Register, $dst$$Register);
 7927     __ z_sgr($dst$$Register, Z_R0_scratch);
 7928     __ z_srag($dst$$Register, $dst$$Register, 63);
 7929   %}
 7930   ins_pipe(pipe_class_dummy);
 7931 %}
 7932 
 7933 instruct cmpLTMask_reg_zero(iRegI dst, immI_0 zero, flagsReg cr) %{
 7934   match(Set dst (CmpLTMask dst zero));
 7935   effect(KILL cr);
 7936   ins_cost(DEFAULT_COST);
 7937   size(4);
 7938   format %{ &quot;Set $dst CmpLTMask $dst,$zero&quot; %}
 7939   ins_encode %{ __ z_sra($dst$$Register, 31); %}
 7940   ins_pipe(pipe_class_dummy);
 7941 %}
 7942 
 7943 
 7944 //----------Arithmetic Conversion Instructions---------------------------------
 7945 // The conversions operations are all Alpha sorted. Please keep it that way!
 7946 
 7947 instruct convD2F_reg(regF dst, regD src) %{
 7948   match(Set dst (ConvD2F src));
 7949   // CC remains unchanged.
 7950   size(4);
 7951   format %{ &quot;LEDBR   $dst,$src&quot; %}
 7952   opcode(LEDBR_ZOPC);
 7953   ins_encode(z_rreform(dst, src));
 7954   ins_pipe(pipe_class_dummy);
 7955 %}
 7956 
 7957 instruct convF2I_reg(iRegI dst, regF src, flagsReg cr) %{
 7958   match(Set dst (ConvF2I src));
 7959   effect(KILL cr);
 7960   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 7961   size(16);
 7962   format %{ &quot;convF2I  $dst,$src&quot; %}
 7963   ins_encode %{
 7964     Label done;
 7965     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 7966     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 7967     __ z_brno(done);                             // Result is zero if unordered argument.
 7968     __ z_cfebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 7969     __ bind(done);
 7970   %}
 7971   ins_pipe(pipe_class_dummy);
 7972 %}
 7973 
 7974 instruct convD2I_reg(iRegI dst, regD src, flagsReg cr) %{
 7975   match(Set dst (ConvD2I src));
 7976   effect(KILL cr);
 7977   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 7978   size(16);
 7979   format %{ &quot;convD2I  $dst,$src&quot; %}
 7980   ins_encode %{
 7981     Label done;
 7982     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 7983     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 7984     __ z_brno(done);                             // Result is zero if unordered argument.
 7985     __ z_cfdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 7986     __ bind(done);
 7987   %}
 7988   ins_pipe(pipe_class_dummy);
 7989 %}
 7990 
 7991 instruct convF2L_reg(iRegL dst, regF src, flagsReg cr) %{
 7992   match(Set dst (ConvF2L src));
 7993   effect(KILL cr);
 7994   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 7995   size(16);
 7996   format %{ &quot;convF2L  $dst,$src&quot; %}
 7997   ins_encode %{
 7998     Label done;
 7999     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8000     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8001     __ z_brno(done);                             // Result is zero if unordered argument.
 8002     __ z_cgebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8003     __ bind(done);
 8004   %}
 8005   ins_pipe(pipe_class_dummy);
 8006 %}
 8007 
 8008 instruct convD2L_reg(iRegL dst, regD src, flagsReg cr) %{
 8009   match(Set dst (ConvD2L src));
 8010   effect(KILL cr);
 8011   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8012   size(16);
 8013   format %{ &quot;convD2L  $dst,$src&quot; %}
 8014   ins_encode %{
 8015     Label done;
 8016     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8017     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8018     __ z_brno(done);                             // Result is zero if unordered argument.
 8019     __ z_cgdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8020     __ bind(done);
 8021   %}
 8022   ins_pipe(pipe_class_dummy);
 8023 %}
 8024 
 8025 instruct convF2D_reg(regD dst, regF src) %{
 8026   match(Set dst (ConvF2D src));
 8027   // CC remains unchanged.
 8028   size(4);
 8029   format %{ &quot;LDEBR   $dst,$src&quot; %}
 8030   opcode(LDEBR_ZOPC);
 8031   ins_encode(z_rreform(dst, src));
 8032   ins_pipe(pipe_class_dummy);
 8033 %}
 8034 
 8035 instruct convF2D_mem(regD dst, memoryRX src) %{
 8036   match(Set dst (ConvF2D src));
 8037   // CC remains unchanged.
 8038   size(6);
 8039   format %{ &quot;LDEB    $dst,$src&quot; %}
 8040   opcode(LDEB_ZOPC);
 8041   ins_encode(z_form_rt_memFP(dst, src));
 8042   ins_pipe(pipe_class_dummy);
 8043 %}
 8044 
 8045 instruct convI2D_reg(regD dst, iRegI src) %{
 8046   match(Set dst (ConvI2D src));
 8047   // CC remains unchanged.
 8048   ins_cost(DEFAULT_COST);
 8049   size(4);
 8050   format %{ &quot;CDFBR   $dst,$src&quot; %}
 8051   opcode(CDFBR_ZOPC);
 8052   ins_encode(z_rreform(dst, src));
 8053   ins_pipe(pipe_class_dummy);
 8054 %}
 8055 
 8056 // Optimization that saves up to two memory operations for each conversion.
 8057 instruct convI2F_ireg(regF dst, iRegI src) %{
 8058   match(Set dst (ConvI2F src));
 8059   // CC remains unchanged.
 8060   ins_cost(DEFAULT_COST);
 8061   size(4);
 8062   format %{ &quot;CEFBR   $dst,$src\t # convert int to float&quot; %}
 8063   opcode(CEFBR_ZOPC);
 8064   ins_encode(z_rreform(dst, src));
 8065   ins_pipe(pipe_class_dummy);
 8066 %}
 8067 
 8068 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8069   match(Set dst (ConvI2L src));
 8070   size(4);
 8071   format %{ &quot;LGFR    $dst,$src\t # int-&gt;long&quot; %}
 8072   opcode(LGFR_ZOPC);
 8073   ins_encode(z_rreform(dst, src));
 8074   ins_pipe(pipe_class_dummy);
 8075 %}
 8076 
 8077 // Zero-extend convert int to long.
 8078 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask) %{
 8079   match(Set dst (AndL (ConvI2L src) mask));
 8080   size(4);
 8081   format %{ &quot;LLGFR   $dst, $src \t # zero-extend int to long&quot; %}
 8082   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8083   ins_pipe(pipe_class_dummy);
 8084 %}
 8085 
 8086 // Zero-extend convert int to long.
 8087 instruct convI2L_mem_zex(iRegL dst, memory src, immL_32bits mask) %{
 8088   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
 8089   // Uses load_const_optmized, so size can vary.
 8090   // TODO: s390 port size(VARIABLE_SIZE);
 8091   format %{ &quot;LLGF    $dst, $src \t # zero-extend int to long&quot; %}
 8092   opcode(LLGF_ZOPC, LLGF_ZOPC);
 8093   ins_encode(z_form_rt_mem_opt(dst, src));
 8094   ins_pipe(pipe_class_dummy);
 8095 %}
 8096 
 8097 // Zero-extend long
 8098 instruct zeroExtend_long(iRegL dst, iRegL src, immL_32bits mask) %{
 8099   match(Set dst (AndL src mask));
 8100   size(4);
 8101   format %{ &quot;LLGFR   $dst, $src \t # zero-extend long to long&quot; %}
 8102   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8103   ins_pipe(pipe_class_dummy);
 8104 %}
 8105 
 8106 instruct rShiftI16_lShiftI16_reg(iRegI dst, iRegI src, immI_16 amount) %{
 8107   match(Set dst (RShiftI (LShiftI src amount) amount));
 8108   size(4);
 8109   format %{ &quot;LHR     $dst,$src\t short-&gt;int&quot; %}
 8110   opcode(LHR_ZOPC);
 8111   ins_encode(z_rreform(dst, src));
 8112   ins_pipe(pipe_class_dummy);
 8113 %}
 8114 
 8115 instruct rShiftI24_lShiftI24_reg(iRegI dst, iRegI src, immI_24 amount) %{
 8116   match(Set dst (RShiftI (LShiftI src amount) amount));
 8117   size(4);
 8118   format %{ &quot;LBR     $dst,$src\t byte-&gt;int&quot; %}
 8119   opcode(LBR_ZOPC);
 8120   ins_encode(z_rreform(dst, src));
 8121   ins_pipe(pipe_class_dummy);
 8122 %}
 8123 
 8124 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8125   match(Set dst (MoveF2I src));
 8126   ins_cost(MEMORY_REF_COST);
 8127   size(4);
 8128   format %{ &quot;L       $dst,$src\t # MoveF2I&quot; %}
 8129   opcode(L_ZOPC);
 8130   ins_encode(z_form_rt_mem(dst, src));
 8131   ins_pipe(pipe_class_dummy);
 8132 %}
 8133 
 8134 // javax.imageio.stream.ImageInputStreamImpl.toFloats([B[FII)
 8135 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8136   match(Set dst (MoveI2F src));
 8137   ins_cost(MEMORY_REF_COST);
 8138   // TODO: s390 port size(FIXED_SIZE);
 8139   format %{ &quot;LE      $dst,$src\t # MoveI2F&quot; %}
 8140   opcode(LE_ZOPC);
 8141   ins_encode(z_form_rt_mem(dst, src));
 8142   ins_pipe(pipe_class_dummy);
 8143 %}
 8144 
 8145 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8146   match(Set dst (MoveD2L src));
 8147   ins_cost(MEMORY_REF_COST);
 8148   size(6);
 8149   format %{ &quot;LG      $src,$dst\t # MoveD2L&quot; %}
 8150   opcode(LG_ZOPC);
 8151   ins_encode(z_form_rt_mem(dst, src));
 8152   ins_pipe(pipe_class_dummy);
 8153 %}
 8154 
 8155 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8156   match(Set dst (MoveL2D src));
 8157   ins_cost(MEMORY_REF_COST);
 8158   size(4);
 8159   format %{ &quot;LD      $dst,$src\t # MoveL2D&quot; %}
 8160   opcode(LD_ZOPC);
 8161   ins_encode(z_form_rt_mem(dst, src));
 8162   ins_pipe(pipe_class_dummy);
 8163 %}
 8164 
 8165 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8166   match(Set dst (MoveI2F src));
 8167   ins_cost(MEMORY_REF_COST);
 8168   size(4);
 8169   format %{ &quot;ST      $src,$dst\t # MoveI2F&quot; %}
 8170   opcode(ST_ZOPC);
 8171   ins_encode(z_form_rt_mem(src, dst));
 8172   ins_pipe(pipe_class_dummy);
 8173 %}
 8174 
 8175 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8176   match(Set dst (MoveD2L src));
 8177   effect(DEF dst, USE src);
 8178   ins_cost(MEMORY_REF_COST);
 8179   size(4);
 8180   format %{ &quot;STD     $src,$dst\t # MoveD2L&quot; %}
 8181   opcode(STD_ZOPC);
 8182   ins_encode(z_form_rt_mem(src,dst));
 8183   ins_pipe(pipe_class_dummy);
 8184 %}
 8185 
 8186 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8187   match(Set dst (MoveL2D src));
 8188   ins_cost(MEMORY_REF_COST);
 8189   size(6);
 8190   format %{ &quot;STG     $src,$dst\t # MoveL2D&quot; %}
 8191   opcode(STG_ZOPC);
 8192   ins_encode(z_form_rt_mem(src,dst));
 8193   ins_pipe(pipe_class_dummy);
 8194 %}
 8195 
 8196 instruct convL2F_reg(regF dst, iRegL src) %{
 8197   match(Set dst (ConvL2F src));
 8198   // CC remains unchanged.
 8199   ins_cost(DEFAULT_COST);
 8200   size(4);
 8201   format %{ &quot;CEGBR   $dst,$src&quot; %}
 8202   opcode(CEGBR_ZOPC);
 8203   ins_encode(z_rreform(dst, src));
 8204   ins_pipe(pipe_class_dummy);
 8205 %}
 8206 
 8207 instruct convL2D_reg(regD dst, iRegL src) %{
 8208   match(Set dst (ConvL2D src));
 8209   // CC remains unchanged.
 8210   ins_cost(DEFAULT_COST);
 8211   size(4);
 8212   format %{ &quot;CDGBR   $dst,$src&quot; %}
 8213   opcode(CDGBR_ZOPC);
 8214   ins_encode(z_rreform(dst, src));
 8215   ins_pipe(pipe_class_dummy);
 8216 %}
 8217 
 8218 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8219   match(Set dst (ConvL2I src));
 8220   // TODO: s390 port size(VARIABLE_SIZE);
 8221   format %{ &quot;LR      $dst,$src\t # long-&gt;int (if needed)&quot; %}
 8222   ins_encode %{ __ lr_if_needed($dst$$Register, $src$$Register); %}
 8223   ins_pipe(pipe_class_dummy);
 8224 %}
 8225 
 8226 // Register Shift Right Immediate
 8227 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt, flagsReg cr) %{
 8228   match(Set dst (ConvL2I (RShiftL src cnt)));
 8229   effect(KILL cr);
 8230   size(6);
 8231   format %{ &quot;SRAG    $dst,$src,$cnt&quot; %}
 8232   opcode(SRAG_ZOPC);
 8233   ins_encode(z_rsyform_const(dst, src, cnt));
 8234   ins_pipe(pipe_class_dummy);
 8235 %}
 8236 
 8237 //----------TRAP based zero checks and range checks----------------------------
 8238 
 8239 // SIGTRAP based implicit range checks in compiled code.
 8240 // A range check in the ideal world has one of the following shapes:
 8241 //   - (If le (CmpU length index)), (IfTrue  throw exception)
 8242 //   - (If lt (CmpU index length)), (IfFalse throw exception)
 8243 //
 8244 // Match range check &#39;If le (CmpU length index)&#39;
 8245 instruct rangeCheck_iReg_uimmI16(cmpOpT cmp, iRegI length, uimmI16 index, label labl) %{
 8246   match(If cmp (CmpU length index));
 8247   effect(USE labl);
 8248   predicate(TrapBasedRangeChecks &amp;&amp;
 8249             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
 8250             PROB_UNLIKELY(_leaf-&gt;as_If ()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
 8251             Matcher::branches_to_uncommon_trap(_leaf));
 8252   ins_cost(1);
 8253   // TODO: s390 port size(FIXED_SIZE);
 8254 
 8255   ins_is_TrapBasedCheckNode(true);
 8256 
 8257   format %{ &quot;RangeCheck len=$length cmp=$cmp idx=$index =&gt; trap $labl&quot; %}
 8258   ins_encode %{ __ z_clfit($length$$Register, $index$$constant, $cmp$$cmpcode); %}
 8259   ins_pipe(pipe_class_trap);
 8260 %}
 8261 
 8262 // Match range check &#39;If lt (CmpU index length)&#39;
 8263 instruct rangeCheck_iReg_iReg(cmpOpT cmp, iRegI index, iRegI length, label labl, flagsReg cr) %{
 8264   match(If cmp (CmpU index length));
 8265   effect(USE labl, KILL cr);
 8266   predicate(TrapBasedRangeChecks &amp;&amp;
 8267             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8268             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8269             Matcher::branches_to_uncommon_trap(_leaf));
 8270   ins_cost(1);
 8271   // TODO: s390 port size(FIXED_SIZE);
 8272 
 8273   ins_is_TrapBasedCheckNode(true);
 8274 
 8275   format %{ &quot;RangeCheck idx=$index cmp=$cmp len=$length =&gt; trap $labl&quot; %}
 8276   ins_encode %{ __ z_clrt($index$$Register, $length$$Register, $cmp$$cmpcode); %}
 8277   ins_pipe(pipe_class_trap);
 8278 %}
 8279 
 8280 // Match range check &#39;If lt (CmpU index length)&#39;
 8281 instruct rangeCheck_uimmI16_iReg(cmpOpT cmp, iRegI index, uimmI16 length, label labl) %{
 8282   match(If cmp (CmpU index length));
 8283   effect(USE labl);
 8284   predicate(TrapBasedRangeChecks &amp;&amp;
 8285             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8286             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8287             Matcher::branches_to_uncommon_trap(_leaf));
 8288   ins_cost(1);
 8289   // TODO: s390 port size(FIXED_SIZE);
 8290 
 8291   ins_is_TrapBasedCheckNode(true);
 8292 
 8293   format %{ &quot;RangeCheck idx=$index cmp=$cmp len= $length =&gt; trap $labl&quot; %}
 8294   ins_encode %{ __ z_clfit($index$$Register, $length$$constant, $cmp$$cmpcode); %}
 8295   ins_pipe(pipe_class_trap);
 8296 %}
 8297 
 8298 // Implicit zero checks (more implicit null checks).
 8299 instruct zeroCheckP_iReg_imm0(cmpOpT cmp, iRegP_N2P value, immP0 zero, label labl) %{
 8300   match(If cmp (CmpP value zero));
 8301   effect(USE labl);
 8302   predicate(TrapBasedNullChecks &amp;&amp;
 8303             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8304             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8305             Matcher::branches_to_uncommon_trap(_leaf));
 8306   size(6);
 8307 
 8308   ins_is_TrapBasedCheckNode(true);
 8309 
 8310   format %{ &quot;ZeroCheckP value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8311   ins_encode %{ __ z_cgit($value$$Register, 0, $cmp$$cmpcode); %}
 8312   ins_pipe(pipe_class_trap);
 8313 %}
 8314 
 8315 // Implicit zero checks (more implicit null checks).
 8316 instruct zeroCheckN_iReg_imm0(cmpOpT cmp, iRegN_P2N value, immN0 zero, label labl) %{
 8317   match(If cmp (CmpN value zero));
 8318   effect(USE labl);
 8319   predicate(TrapBasedNullChecks &amp;&amp;
 8320             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8321             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8322             Matcher::branches_to_uncommon_trap(_leaf));
 8323   size(6);
 8324 
 8325   ins_is_TrapBasedCheckNode(true);
 8326 
 8327   format %{ &quot;ZeroCheckN value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8328   ins_encode %{ __ z_cit($value$$Register, 0, $cmp$$cmpcode); %}
 8329   ins_pipe(pipe_class_trap);
 8330 %}
 8331 
 8332 //----------Compare instructions-----------------------------------------------
 8333 
 8334 // INT signed
 8335 
 8336 // Compare Integers
 8337 instruct compI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8338   match(Set cr (CmpI op1 op2));
 8339   size(2);
 8340   format %{ &quot;CR      $op1,$op2&quot; %}
 8341   opcode(CR_ZOPC);
 8342   ins_encode(z_rrform(op1, op2));
 8343   ins_pipe(pipe_class_dummy);
 8344 %}
 8345 
 8346 instruct compI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 8347   match(Set cr (CmpI op1 op2));
 8348   size(6);
 8349   format %{ &quot;CFI     $op1,$op2&quot; %}
 8350   opcode(CFI_ZOPC);
 8351   ins_encode(z_rilform_signed(op1, op2));
 8352   ins_pipe(pipe_class_dummy);
 8353 %}
 8354 
 8355 instruct compI_reg_imm16(flagsReg cr, iRegI op1, immI16 op2) %{
 8356   match(Set cr (CmpI op1 op2));
 8357   size(4);
 8358   format %{ &quot;CHI     $op1,$op2&quot; %}
 8359   opcode(CHI_ZOPC);
 8360   ins_encode(z_riform_signed(op1, op2));
 8361   ins_pipe(pipe_class_dummy);
 8362 %}
 8363 
 8364 instruct compI_reg_imm0(flagsReg cr, iRegI op1, immI_0 zero) %{
 8365   match(Set cr (CmpI op1 zero));
 8366   ins_cost(DEFAULT_COST_LOW);
 8367   size(2);
 8368   format %{ &quot;LTR     $op1,$op1&quot; %}
 8369   opcode(LTR_ZOPC);
 8370   ins_encode(z_rrform(op1, op1));
 8371   ins_pipe(pipe_class_dummy);
 8372 %}
 8373 
 8374 instruct compI_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8375   match(Set cr (CmpI op1 (LoadI op2)));
 8376   ins_cost(MEMORY_REF_COST);
 8377   // TODO: s390 port size(VARIABLE_SIZE);
 8378   format %{ &quot;C(Y)    $op1, $op2\t # int&quot; %}
 8379   opcode(CY_ZOPC, C_ZOPC);
 8380   ins_encode(z_form_rt_mem_opt(op1, op2));
 8381   ins_pipe(pipe_class_dummy);
 8382 %}
 8383 
 8384 // INT unsigned
 8385 
 8386 instruct compU_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8387   match(Set cr (CmpU op1 op2));
 8388   size(2);
 8389   format %{ &quot;CLR     $op1,$op2\t # unsigned&quot; %}
 8390   opcode(CLR_ZOPC);
 8391   ins_encode(z_rrform(op1, op2));
 8392   ins_pipe(pipe_class_dummy);
 8393 %}
 8394 
 8395 instruct compU_reg_uimm(flagsReg cr, iRegI op1, uimmI op2) %{
 8396   match(Set cr (CmpU op1 op2));
 8397   size(6);
 8398   format %{ &quot;CLFI    $op1,$op2\t # unsigned&quot; %}
 8399   opcode(CLFI_ZOPC);
 8400   ins_encode(z_rilform_unsigned(op1, op2));
 8401   ins_pipe(pipe_class_dummy);
 8402 %}
 8403 
 8404 instruct compU_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8405   match(Set cr (CmpU op1 (LoadI op2)));
 8406   ins_cost(MEMORY_REF_COST);
 8407   // TODO: s390 port size(VARIABLE_SIZE);
 8408   format %{ &quot;CL(Y)   $op1, $op2\t # unsigned&quot; %}
 8409   opcode(CLY_ZOPC, CL_ZOPC);
 8410   ins_encode(z_form_rt_mem_opt(op1, op2));
 8411   ins_pipe(pipe_class_dummy);
 8412 %}
 8413 
 8414 // LONG signed
 8415 
 8416 instruct compL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8417   match(Set cr (CmpL op1 op2));
 8418   size(4);
 8419   format %{ &quot;CGR     $op1,$op2\t # long&quot; %}
 8420   opcode(CGR_ZOPC);
 8421   ins_encode(z_rreform(op1, op2));
 8422   ins_pipe(pipe_class_dummy);
 8423 %}
 8424 
 8425 instruct compL_reg_regI(flagsReg cr, iRegL op1, iRegI op2) %{
 8426   match(Set cr (CmpL op1 (ConvI2L op2)));
 8427   size(4);
 8428   format %{ &quot;CGFR    $op1,$op2\t # long/int&quot; %}
 8429   opcode(CGFR_ZOPC);
 8430   ins_encode(z_rreform(op1, op2));
 8431   ins_pipe(pipe_class_dummy);
 8432 %}
 8433 
 8434 instruct compL_reg_imm32(flagsReg cr, iRegL op1, immL32 con) %{
 8435   match(Set cr (CmpL op1 con));
 8436   size(6);
 8437   format %{ &quot;CGFI    $op1,$con&quot; %}
 8438   opcode(CGFI_ZOPC);
 8439   ins_encode(z_rilform_signed(op1, con));
 8440   ins_pipe(pipe_class_dummy);
 8441 %}
 8442 
 8443 instruct compL_reg_imm16(flagsReg cr, iRegL op1, immL16 con) %{
 8444   match(Set cr (CmpL op1 con));
 8445   size(4);
 8446   format %{ &quot;CGHI    $op1,$con&quot; %}
 8447   opcode(CGHI_ZOPC);
 8448   ins_encode(z_riform_signed(op1, con));
 8449   ins_pipe(pipe_class_dummy);
 8450 %}
 8451 
 8452 instruct compL_reg_imm0(flagsReg cr, iRegL op1, immL_0 con) %{
 8453   match(Set cr (CmpL op1 con));
 8454   ins_cost(DEFAULT_COST_LOW);
 8455   size(4);
 8456   format %{ &quot;LTGR    $op1,$op1&quot; %}
 8457   opcode(LTGR_ZOPC);
 8458   ins_encode(z_rreform(op1, op1));
 8459   ins_pipe(pipe_class_dummy);
 8460 %}
 8461 
 8462 instruct compL_conv_reg_imm0(flagsReg cr, iRegI op1, immL_0 con) %{
 8463   match(Set cr (CmpL (ConvI2L op1) con));
 8464   ins_cost(DEFAULT_COST_LOW);
 8465   size(4);
 8466   format %{ &quot;LTGFR    $op1,$op1&quot; %}
 8467   opcode(LTGFR_ZOPC);
 8468   ins_encode(z_rreform(op1, op1));
 8469   ins_pipe(pipe_class_dummy);
 8470 %}
 8471 
 8472 instruct compL_reg_mem(iRegL dst, memory src, flagsReg cr)%{
 8473   match(Set cr (CmpL dst (LoadL src)));
 8474   ins_cost(MEMORY_REF_COST);
 8475   size(Z_DISP3_SIZE);
 8476   format %{ &quot;CG      $dst, $src\t # long&quot; %}
 8477   opcode(CG_ZOPC, CG_ZOPC);
 8478   ins_encode(z_form_rt_mem_opt(dst, src));
 8479   ins_pipe(pipe_class_dummy);
 8480 %}
 8481 
 8482 instruct compL_reg_memI(iRegL dst, memory src, flagsReg cr)%{
 8483   match(Set cr (CmpL dst (ConvI2L (LoadI src))));
 8484   ins_cost(MEMORY_REF_COST);
 8485   size(Z_DISP3_SIZE);
 8486   format %{ &quot;CGF     $dst, $src\t # long/int&quot; %}
 8487   opcode(CGF_ZOPC, CGF_ZOPC);
 8488   ins_encode(z_form_rt_mem_opt(dst, src));
 8489   ins_pipe(pipe_class_dummy);
 8490 %}
 8491 
 8492 //  LONG unsigned
 8493 // Added CmpUL for LoopPredicate.
 8494 instruct compUL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8495   match(Set cr (CmpUL op1 op2));
 8496   size(4);
 8497   format %{ &quot;CLGR    $op1,$op2\t # long&quot; %}
 8498   opcode(CLGR_ZOPC);
 8499   ins_encode(z_rreform(op1, op2));
 8500   ins_pipe(pipe_class_dummy);
 8501 %}
 8502 
 8503 instruct compUL_reg_imm32(flagsReg cr, iRegL op1, uimmL32 con) %{
 8504   match(Set cr (CmpUL op1 con));
 8505   size(6);
 8506   format %{ &quot;CLGFI   $op1,$con&quot; %}
 8507   opcode(CLGFI_ZOPC);
 8508   ins_encode(z_rilform_unsigned(op1, con));
 8509   ins_pipe(pipe_class_dummy);
 8510 %}
 8511 
 8512 //  PTR unsigned
 8513 
 8514 instruct compP_reg_reg(flagsReg cr, iRegP_N2P op1, iRegP_N2P op2) %{
 8515   match(Set cr (CmpP op1 op2));
 8516   size(4);
 8517   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8518   opcode(CLGR_ZOPC);
 8519   ins_encode(z_rreform(op1, op2));
 8520   ins_pipe(pipe_class_dummy);
 8521 %}
 8522 
 8523 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8524   match(Set cr (CmpP op1 op2));
 8525   ins_cost(DEFAULT_COST_LOW);
 8526   size(4);
 8527   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8528   opcode(LTGR_ZOPC);
 8529   ins_encode(z_rreform(op1, op1));
 8530   ins_pipe(pipe_class_dummy);
 8531 %}
 8532 
 8533 // Don&#39;t use LTGFR which performs sign extend.
 8534 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8535   match(Set cr (CmpP (DecodeN op1) op2));
 8536   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);
 8537   ins_cost(DEFAULT_COST_LOW);
 8538   size(2);
 8539   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8540   opcode(LTR_ZOPC);
 8541   ins_encode(z_rrform(op1, op1));
 8542   ins_pipe(pipe_class_dummy);
 8543 %}
 8544 
 8545 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8546   match(Set cr (CmpP dst (LoadP src)));
 8547   ins_cost(MEMORY_REF_COST);
 8548   size(Z_DISP3_SIZE);
 8549   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8550   opcode(CLG_ZOPC, CLG_ZOPC);
 8551   ins_encode(z_form_rt_mem_opt(dst, src));
 8552   ins_pipe(pipe_class_dummy);
 8553 %}
 8554 
 8555 //----------Max and Min--------------------------------------------------------
 8556 
 8557 // Max Register with Register
 8558 instruct z196_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8559   match(Set dst (MinI src1 src2));
 8560   effect(KILL cr);
 8561   predicate(VM_Version::has_LoadStoreConditional());
 8562   ins_cost(3 * DEFAULT_COST);
 8563   // TODO: s390 port size(VARIABLE_SIZE);
 8564   format %{ &quot;MinI $dst $src1,$src2\t MinI (z196 only)&quot; %}
 8565   ins_encode %{
 8566     Register Rdst = $dst$$Register;
 8567     Register Rsrc1 = $src1$$Register;
 8568     Register Rsrc2 = $src2$$Register;
 8569 
 8570     if (Rsrc1 == Rsrc2) {
 8571       if (Rdst != Rsrc1) {
 8572         __ z_lgfr(Rdst, Rsrc1);
 8573       }
 8574     } else if (Rdst == Rsrc1) {   // Rdst preset with src1.
 8575       __ z_cr(Rsrc1, Rsrc2);      // Move src2 only if src1 is NotLow.
 8576       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8577     } else if (Rdst == Rsrc2) {   // Rdst preset with src2.
 8578       __ z_cr(Rsrc2, Rsrc1);      // Move src1 only if src2 is NotLow.
 8579       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotLow);
 8580     } else {
 8581       // Rdst is disjoint from operands, move in either case.
 8582       __ z_cr(Rsrc1, Rsrc2);
 8583       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8584       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8585     }
 8586   %}
 8587   ins_pipe(pipe_class_dummy);
 8588 %}
 8589 
 8590 // Min Register with Register.
 8591 instruct z10_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8592   match(Set dst (MinI src1 src2));
 8593   effect(KILL cr);
 8594   predicate(VM_Version::has_CompareBranch());
 8595   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8596   // TODO: s390 port size(VARIABLE_SIZE);
 8597   format %{ &quot;MinI $dst $src1,$src2\t MinI (z10 only)&quot; %}
 8598   ins_encode %{
 8599     Register Rdst = $dst$$Register;
 8600     Register Rsrc1 = $src1$$Register;
 8601     Register Rsrc2 = $src2$$Register;
 8602     Label done;
 8603 
 8604     if (Rsrc1 == Rsrc2) {
 8605       if (Rdst != Rsrc1) {
 8606         __ z_lgfr(Rdst, Rsrc1);
 8607       }
 8608     } else if (Rdst == Rsrc1) {
 8609       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8610       __ z_lgfr(Rdst, Rsrc2);
 8611     } else if (Rdst == Rsrc2) {
 8612       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondLow, done);
 8613       __ z_lgfr(Rdst, Rsrc1);
 8614     } else {
 8615       __ z_lgfr(Rdst, Rsrc1);
 8616       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8617       __ z_lgfr(Rdst, Rsrc2);
 8618     }
 8619     __ bind(done);
 8620   %}
 8621   ins_pipe(pipe_class_dummy);
 8622 %}
 8623 
 8624 instruct minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8625   match(Set dst (MinI src1 src2));
 8626   effect(KILL cr);
 8627   predicate(!VM_Version::has_CompareBranch());
 8628   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8629   // TODO: s390 port size(VARIABLE_SIZE);
 8630   format %{ &quot;MinI $dst $src1,$src2\t MinI&quot; %}
 8631   ins_encode %{
 8632     Register Rdst = $dst$$Register;
 8633     Register Rsrc1 = $src1$$Register;
 8634     Register Rsrc2 = $src2$$Register;
 8635     Label done;
 8636 
 8637     if (Rsrc1 == Rsrc2) {
 8638       if (Rdst != Rsrc1) {
 8639         __ z_lgfr(Rdst, Rsrc1);
 8640       }
 8641     } else if (Rdst == Rsrc1) {
 8642       __ z_cr(Rsrc1, Rsrc2);
 8643       __ z_brl(done);
 8644       __ z_lgfr(Rdst, Rsrc2);
 8645     } else if (Rdst == Rsrc2) {
 8646       __ z_cr(Rsrc2, Rsrc1);
 8647       __ z_brl(done);
 8648       __ z_lgfr(Rdst, Rsrc1);
 8649     } else {
 8650       __ z_lgfr(Rdst, Rsrc1);
 8651       __ z_cr(Rsrc1, Rsrc2);
 8652       __ z_brl(done);
 8653       __ z_lgfr(Rdst, Rsrc2);
 8654     }
 8655     __ bind(done);
 8656   %}
 8657   ins_pipe(pipe_class_dummy);
 8658 %}
 8659 
 8660 instruct z196_minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8661   match(Set dst (MinI src1 src2));
 8662   effect(KILL cr);
 8663   predicate(VM_Version::has_LoadStoreConditional());
 8664   ins_cost(3 * DEFAULT_COST);
 8665   // TODO: s390 port size(VARIABLE_SIZE);
 8666   format %{ &quot;MinI $dst $src1,$src2\t MinI const32 (z196 only)&quot; %}
 8667   ins_encode %{
 8668     Register Rdst = $dst$$Register;
 8669     Register Rsrc1 = $src1$$Register;
 8670     int      Isrc2 = $src2$$constant;
 8671 
 8672     if (Rdst == Rsrc1) {
 8673       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8674       __ z_cfi(Rsrc1, Isrc2);
 8675       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8676     } else {
 8677       __ load_const_optimized(Rdst, Isrc2);
 8678       __ z_cfi(Rsrc1, Isrc2);
 8679       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8680     }
 8681   %}
 8682   ins_pipe(pipe_class_dummy);
 8683 %}
 8684 
 8685 instruct minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8686   match(Set dst (MinI src1 src2));
 8687   effect(KILL cr);
 8688   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8689   // TODO: s390 port size(VARIABLE_SIZE);
 8690   format %{ &quot;MinI $dst $src1,$src2\t MinI const32&quot; %}
 8691   ins_encode %{
 8692     Label done;
 8693     if ($dst$$Register != $src1$$Register) {
 8694       __ z_lgfr($dst$$Register, $src1$$Register);
 8695     }
 8696     __ z_cfi($src1$$Register, $src2$$constant);
 8697     __ z_brl(done);
 8698     __ z_lgfi($dst$$Register, $src2$$constant);
 8699     __ bind(done);
 8700   %}
 8701   ins_pipe(pipe_class_dummy);
 8702 %}
 8703 
 8704 instruct z196_minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8705   match(Set dst (MinI src1 src2));
 8706   effect(KILL cr);
 8707   predicate(VM_Version::has_LoadStoreConditional());
 8708   ins_cost(3 * DEFAULT_COST);
 8709   // TODO: s390 port size(VARIABLE_SIZE);
 8710   format %{ &quot;MinI $dst $src1,$src2\t MinI const16 (z196 only)&quot; %}
 8711   ins_encode %{
 8712     Register Rdst = $dst$$Register;
 8713     Register Rsrc1 = $src1$$Register;
 8714     int      Isrc2 = $src2$$constant;
 8715 
 8716     if (Rdst == Rsrc1) {
 8717       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8718       __ z_chi(Rsrc1, Isrc2);
 8719       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8720     } else {
 8721       __ load_const_optimized(Rdst, Isrc2);
 8722       __ z_chi(Rsrc1, Isrc2);
 8723       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8724     }
 8725   %}
 8726   ins_pipe(pipe_class_dummy);
 8727 %}
 8728 
 8729 instruct minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8730   match(Set dst (MinI src1 src2));
 8731   effect(KILL cr);
 8732   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8733   // TODO: s390 port size(VARIABLE_SIZE);
 8734   format %{ &quot;MinI $dst $src1,$src2\t MinI const16&quot; %}
 8735   ins_encode %{
 8736     Label done;
 8737     if ($dst$$Register != $src1$$Register) {
 8738       __ z_lgfr($dst$$Register, $src1$$Register);
 8739     }
 8740     __ z_chi($src1$$Register, $src2$$constant);
 8741     __ z_brl(done);
 8742     __ z_lghi($dst$$Register, $src2$$constant);
 8743     __ bind(done);
 8744   %}
 8745   ins_pipe(pipe_class_dummy);
 8746 %}
 8747 
 8748 instruct z10_minI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8749   match(Set dst (MinI src1 src2));
 8750   effect(KILL cr);
 8751   predicate(VM_Version::has_CompareBranch());
 8752   ins_cost(DEFAULT_COST + BRANCH_COST);
 8753   // TODO: s390 port size(VARIABLE_SIZE);
 8754   format %{ &quot;MinI $dst $src1,$src2\t MinI const8 (z10 only)&quot; %}
 8755   ins_encode %{
 8756     Label done;
 8757     if ($dst$$Register != $src1$$Register) {
 8758       __ z_lgfr($dst$$Register, $src1$$Register);
 8759     }
 8760     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondLow, done);
 8761     __ z_lghi($dst$$Register, $src2$$constant);
 8762     __ bind(done);
 8763   %}
 8764   ins_pipe(pipe_class_dummy);
 8765 %}
 8766 
 8767 // Max Register with Register
 8768 instruct z196_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8769   match(Set dst (MaxI src1 src2));
 8770   effect(KILL cr);
 8771   predicate(VM_Version::has_LoadStoreConditional());
 8772   ins_cost(3 * DEFAULT_COST);
 8773   // TODO: s390 port size(VARIABLE_SIZE);
 8774   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z196 only)&quot; %}
 8775   ins_encode %{
 8776     Register Rdst = $dst$$Register;
 8777     Register Rsrc1 = $src1$$Register;
 8778     Register Rsrc2 = $src2$$Register;
 8779 
 8780     if (Rsrc1 == Rsrc2) {
 8781       if (Rdst != Rsrc1) {
 8782         __ z_lgfr(Rdst, Rsrc1);
 8783       }
 8784     } else if (Rdst == Rsrc1) { // Rdst preset with src1.
 8785       __ z_cr(Rsrc1, Rsrc2);    // Move src2 only if src1 is NotHigh.
 8786       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8787     } else if (Rdst == Rsrc2) { // Rdst preset with src2.
 8788       __ z_cr(Rsrc2, Rsrc1);    // Move src1 only if src2 is NotHigh.
 8789       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotHigh);
 8790     } else {                    // Rdst is disjoint from operands, move in either case.
 8791       __ z_cr(Rsrc1, Rsrc2);
 8792       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8793       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8794     }
 8795   %}
 8796   ins_pipe(pipe_class_dummy);
 8797 %}
 8798 
 8799 // Max Register with Register
 8800 instruct z10_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8801   match(Set dst (MaxI src1 src2));
 8802   effect(KILL cr);
 8803   predicate(VM_Version::has_CompareBranch());
 8804   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8805   // TODO: s390 port size(VARIABLE_SIZE);
 8806   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z10 only)&quot; %}
 8807   ins_encode %{
 8808     Register Rdst = $dst$$Register;
 8809     Register Rsrc1 = $src1$$Register;
 8810     Register Rsrc2 = $src2$$Register;
 8811     Label done;
 8812 
 8813     if (Rsrc1 == Rsrc2) {
 8814       if (Rdst != Rsrc1) {
 8815         __ z_lgfr(Rdst, Rsrc1);
 8816       }
 8817     } else if (Rdst == Rsrc1) {
 8818       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8819       __ z_lgfr(Rdst, Rsrc2);
 8820     } else if (Rdst == Rsrc2) {
 8821       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondHigh, done);
 8822       __ z_lgfr(Rdst, Rsrc1);
 8823     } else {
 8824       __ z_lgfr(Rdst, Rsrc1);
 8825       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8826       __ z_lgfr(Rdst, Rsrc2);
 8827     }
 8828     __ bind(done);
 8829   %}
 8830   ins_pipe(pipe_class_dummy);
 8831 %}
 8832 
 8833 instruct maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8834   match(Set dst (MaxI src1 src2));
 8835   effect(KILL cr);
 8836   predicate(!VM_Version::has_CompareBranch());
 8837   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8838   // TODO: s390 port size(VARIABLE_SIZE);
 8839   format %{ &quot;MaxI $dst $src1,$src2\t MaxI&quot; %}
 8840   ins_encode %{
 8841     Register Rdst = $dst$$Register;
 8842     Register Rsrc1 = $src1$$Register;
 8843     Register Rsrc2 = $src2$$Register;
 8844     Label done;
 8845 
 8846     if (Rsrc1 == Rsrc2) {
 8847       if (Rdst != Rsrc1) {
 8848         __ z_lgfr(Rdst, Rsrc1);
 8849       }
 8850     } else if (Rdst == Rsrc1) {
 8851       __ z_cr(Rsrc1, Rsrc2);
 8852       __ z_brh(done);
 8853       __ z_lgfr(Rdst, Rsrc2);
 8854     } else if (Rdst == Rsrc2) {
 8855       __ z_cr(Rsrc2, Rsrc1);
 8856       __ z_brh(done);
 8857       __ z_lgfr(Rdst, Rsrc1);
 8858     } else {
 8859       __ z_lgfr(Rdst, Rsrc1);
 8860       __ z_cr(Rsrc1, Rsrc2);
 8861       __ z_brh(done);
 8862       __ z_lgfr(Rdst, Rsrc2);
 8863     }
 8864 
 8865     __ bind(done);
 8866   %}
 8867 
 8868   ins_pipe(pipe_class_dummy);
 8869 %}
 8870 
 8871 instruct z196_maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8872   match(Set dst (MaxI src1 src2));
 8873   effect(KILL cr);
 8874   predicate(VM_Version::has_LoadStoreConditional());
 8875   ins_cost(3 * DEFAULT_COST);
 8876   // TODO: s390 port size(VARIABLE_SIZE);
 8877   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32 (z196 only)&quot; %}
 8878   ins_encode %{
 8879     Register Rdst = $dst$$Register;
 8880     Register Rsrc1 = $src1$$Register;
 8881     int      Isrc2 = $src2$$constant;
 8882 
 8883     if (Rdst == Rsrc1) {
 8884       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8885       __ z_cfi(Rsrc1, Isrc2);
 8886       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8887     } else {
 8888       __ load_const_optimized(Rdst, Isrc2);
 8889       __ z_cfi(Rsrc1, Isrc2);
 8890       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8891     }
 8892   %}
 8893   ins_pipe(pipe_class_dummy);
 8894 %}
 8895 
 8896 instruct maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8897   match(Set dst (MaxI src1 src2));
 8898   effect(KILL cr);
 8899   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8900   // TODO: s390 port size(VARIABLE_SIZE);
 8901   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32&quot; %}
 8902   ins_encode %{
 8903     Label done;
 8904     if ($dst$$Register != $src1$$Register) {
 8905       __ z_lgfr($dst$$Register, $src1$$Register);
 8906     }
 8907     __ z_cfi($src1$$Register, $src2$$constant);
 8908     __ z_brh(done);
 8909     __ z_lgfi($dst$$Register, $src2$$constant);
 8910     __ bind(done);
 8911   %}
 8912   ins_pipe(pipe_class_dummy);
 8913 %}
 8914 
 8915 instruct z196_maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8916   match(Set dst (MaxI src1 src2));
 8917   effect(KILL cr);
 8918   predicate(VM_Version::has_LoadStoreConditional());
 8919   ins_cost(3 * DEFAULT_COST);
 8920   // TODO: s390 port size(VARIABLE_SIZE);
 8921   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16 (z196 only)&quot; %}
 8922   ins_encode %{
 8923     Register Rdst = $dst$$Register;
 8924     Register Rsrc1 = $src1$$Register;
 8925     int      Isrc2 = $src2$$constant;
 8926     if (Rdst == Rsrc1) {
 8927       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8928       __ z_chi(Rsrc1, Isrc2);
 8929       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8930     } else {
 8931       __ load_const_optimized(Rdst, Isrc2);
 8932       __ z_chi(Rsrc1, Isrc2);
 8933       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8934     }
 8935   %}
 8936   ins_pipe(pipe_class_dummy);
 8937 %}
 8938 
 8939 instruct maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8940   match(Set dst (MaxI src1 src2));
 8941   effect(KILL cr);
 8942   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8943   // TODO: s390 port size(VARIABLE_SIZE);
 8944   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16&quot; %}
 8945   ins_encode %{
 8946     Label done;
 8947     if ($dst$$Register != $src1$$Register) {
 8948       __ z_lgfr($dst$$Register, $src1$$Register);
 8949     }
 8950     __ z_chi($src1$$Register, $src2$$constant);
 8951     __ z_brh(done);
 8952     __ z_lghi($dst$$Register, $src2$$constant);
 8953     __ bind(done);
 8954   %}
 8955   ins_pipe(pipe_class_dummy);
 8956 %}
 8957 
 8958 instruct z10_maxI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8959   match(Set dst (MaxI src1 src2));
 8960   effect(KILL cr);
 8961   predicate(VM_Version::has_CompareBranch());
 8962   ins_cost(DEFAULT_COST + BRANCH_COST);
 8963   // TODO: s390 port size(VARIABLE_SIZE);
 8964   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const8&quot; %}
 8965   ins_encode %{
 8966     Label done;
 8967     if ($dst$$Register != $src1$$Register) {
 8968       __ z_lgfr($dst$$Register, $src1$$Register);
 8969     }
 8970     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondHigh, done);
 8971     __ z_lghi($dst$$Register, $src2$$constant);
 8972     __ bind(done);
 8973   %}
 8974   ins_pipe(pipe_class_dummy);
 8975 %}
 8976 
 8977 //----------Abs---------------------------------------------------------------
 8978 
 8979 instruct absI_reg(iRegI dst, iRegI src, flagsReg cr) %{
 8980   match(Set dst (AbsI src));
 8981   effect(KILL cr);
 8982   ins_cost(DEFAULT_COST_LOW);
 8983   // TODO: s390 port size(FIXED_SIZE);
 8984   format %{ &quot;LPR     $dst, $src&quot; %}
 8985   opcode(LPR_ZOPC);
 8986   ins_encode(z_rrform(dst, src));
 8987   ins_pipe(pipe_class_dummy);
 8988 %}
 8989 
 8990 instruct negabsI_reg(iRegI dst, iRegI src, immI_0 zero, flagsReg cr) %{
 8991   match(Set dst (SubI zero (AbsI src)));
 8992   effect(KILL cr);
 8993   ins_cost(DEFAULT_COST_LOW);
 8994   // TODO: s390 port size(FIXED_SIZE);
 8995   format %{ &quot;LNR     $dst, $src&quot; %}
 8996   opcode(LNR_ZOPC);
 8997   ins_encode(z_rrform(dst, src));
 8998   ins_pipe(pipe_class_dummy);
 8999 %}
 9000 
 9001 //----------Float Compares----------------------------------------------------
 9002 
 9003 // Compare floating, generate condition code.
 9004 instruct cmpF_cc(flagsReg cr, regF src1, regF src2) %{
 9005   match(Set cr (CmpF src1 src2));
 9006   ins_cost(ALU_REG_COST);
 9007   size(4);
 9008   format %{ &quot;FCMPcc   $src1,$src2\t # float&quot; %}
 9009   ins_encode %{ __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9010   ins_pipe(pipe_class_dummy);
 9011 %}
 9012 
 9013 instruct cmpD_cc(flagsReg cr, regD src1, regD src2) %{
 9014   match(Set cr (CmpD src1 src2));
 9015   ins_cost(ALU_REG_COST);
 9016   size(4);
 9017   format %{ &quot;FCMPcc   $src1,$src2 \t # double&quot; %}
 9018   ins_encode %{ __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9019   ins_pipe(pipe_class_dummy);
 9020 %}
 9021 
 9022 instruct cmpF_cc_mem(flagsReg cr, regF src1, memoryRX src2) %{
 9023   match(Set cr (CmpF src1 (LoadF src2)));
 9024   ins_cost(ALU_MEMORY_COST);
 9025   size(6);
 9026   format %{ &quot;FCMPcc_mem $src1,$src2\t # floatMemory&quot; %}
 9027   opcode(CEB_ZOPC);
 9028   ins_encode(z_form_rt_memFP(src1, src2));
 9029   ins_pipe(pipe_class_dummy);
 9030 %}
 9031 
 9032 instruct cmpD_cc_mem(flagsReg cr, regD src1, memoryRX src2) %{
 9033   match(Set cr (CmpD src1 (LoadD src2)));
 9034   ins_cost(ALU_MEMORY_COST);
 9035   size(6);
 9036   format %{ &quot;DCMPcc_mem $src1,$src2\t # doubleMemory&quot; %}
 9037   opcode(CDB_ZOPC);
 9038   ins_encode(z_form_rt_memFP(src1, src2));
 9039   ins_pipe(pipe_class_dummy);
 9040 %}
 9041 
 9042 // Compare floating, generate condition code
 9043 instruct cmpF0_cc(flagsReg cr, regF src1, immFpm0 src2) %{
 9044   match(Set cr (CmpF src1 src2));
 9045   ins_cost(DEFAULT_COST);
 9046   size(4);
 9047   format %{ &quot;LTEBR    $src1,$src1\t # float&quot; %}
 9048   opcode(LTEBR_ZOPC);
 9049   ins_encode(z_rreform(src1, src1));
 9050   ins_pipe(pipe_class_dummy);
 9051 %}
 9052 
 9053 instruct cmpD0_cc(flagsReg cr, regD src1, immDpm0 src2) %{
 9054   match(Set cr (CmpD src1 src2));
 9055   ins_cost(DEFAULT_COST);
 9056   size(4);
 9057   format %{ &quot;LTDBR    $src1,$src1 \t # double&quot; %}
 9058   opcode(LTDBR_ZOPC);
 9059   ins_encode(z_rreform(src1, src1));
 9060   ins_pipe(pipe_class_dummy);
 9061 %}
 9062 
 9063 // Compare floating, generate -1,0,1
 9064 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsReg cr) %{
 9065   match(Set dst (CmpF3 src1 src2));
 9066   effect(KILL cr);
 9067   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9068   size(24);
 9069   format %{ &quot;CmpF3    $dst,$src1,$src2&quot; %}
 9070   ins_encode %{
 9071     // compare registers
 9072     __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister);
 9073     // Convert condition code into -1,0,1, where
 9074     // -1 means unordered or less
 9075     //  0 means equal
 9076     //  1 means greater.
 9077     if (VM_Version::has_LoadStoreConditional()) {
 9078       Register one       = Z_R0_scratch;
 9079       Register minus_one = Z_R1_scratch;
 9080       __ z_lghi(minus_one, -1);
 9081       __ z_lghi(one, 1);
 9082       __ z_lghi( $dst$$Register, 0);
 9083       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9084       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9085     } else {
 9086       Label done;
 9087       __ clear_reg($dst$$Register, true, false);
 9088       __ z_bre(done);
 9089       __ z_lhi($dst$$Register, 1);
 9090       __ z_brh(done);
 9091       __ z_lhi($dst$$Register, -1);
 9092       __ bind(done);
 9093     }
 9094   %}
 9095   ins_pipe(pipe_class_dummy);
 9096 %}
 9097 
 9098 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsReg cr) %{
 9099   match(Set dst (CmpD3 src1 src2));
 9100   effect(KILL cr);
 9101   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9102   size(24);
 9103   format %{ &quot;CmpD3    $dst,$src1,$src2&quot; %}
 9104   ins_encode %{
 9105     // compare registers
 9106     __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister);
 9107     // Convert condition code into -1,0,1, where
 9108     // -1 means unordered or less
 9109     //  0 means equal
 9110     //  1 means greater.
 9111     if (VM_Version::has_LoadStoreConditional()) {
 9112       Register one       = Z_R0_scratch;
 9113       Register minus_one = Z_R1_scratch;
 9114       __ z_lghi(minus_one, -1);
 9115       __ z_lghi(one, 1);
 9116       __ z_lghi( $dst$$Register, 0);
 9117       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9118       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9119     } else {
 9120       Label done;
 9121       // indicate unused result
 9122       (void) __ clear_reg($dst$$Register, true, false);
 9123       __ z_bre(done);
 9124       __ z_lhi($dst$$Register, 1);
 9125       __ z_brh(done);
 9126       __ z_lhi($dst$$Register, -1);
 9127       __ bind(done);
 9128     }
 9129   %}
 9130   ins_pipe(pipe_class_dummy);
 9131 %}
 9132 
 9133 //----------Branches---------------------------------------------------------
 9134 // Jump
 9135 
 9136 // Direct Branch.
 9137 instruct branch(label labl) %{
 9138   match(Goto);
 9139   effect(USE labl);
 9140   ins_cost(BRANCH_COST);
 9141   size(4);
 9142   format %{ &quot;BRU     $labl&quot; %}
 9143   ins_encode(z_enc_bru(labl));
 9144   ins_pipe(pipe_class_dummy);
 9145   // If set to 1 this indicates that the current instruction is a
 9146   // short variant of a long branch. This avoids using this
 9147   // instruction in first-pass matching. It will then only be used in
 9148   // the `Shorten_branches&#39; pass.
 9149   ins_short_branch(1);
 9150 %}
 9151 
 9152 // Direct Branch.
 9153 instruct branchFar(label labl) %{
 9154   match(Goto);
 9155   effect(USE labl);
 9156   ins_cost(BRANCH_COST);
 9157   size(6);
 9158   format %{ &quot;BRUL   $labl&quot; %}
 9159   ins_encode(z_enc_brul(labl));
 9160   ins_pipe(pipe_class_dummy);
 9161   // This is not a short variant of a branch, but the long variant.
 9162   ins_short_branch(0);
 9163 %}
 9164 
 9165 // Conditional Near Branch
 9166 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9167   // Same match rule as `branchConFar&#39;.
 9168   match(If cmp cr);
 9169   effect(USE lbl);
 9170   ins_cost(BRANCH_COST);
 9171   size(4);
 9172   format %{ &quot;branch_con_short,$cmp   $cr, $lbl&quot; %}
 9173   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9174   ins_pipe(pipe_class_dummy);
 9175   // If set to 1 this indicates that the current instruction is a
 9176   // short variant of a long branch. This avoids using this
 9177   // instruction in first-pass matching. It will then only be used in
 9178   // the `Shorten_branches&#39; pass.
 9179   ins_short_branch(1);
 9180 %}
 9181 
 9182 // This is for cases when the z/Architecture conditional branch instruction
 9183 // does not reach far enough. So we emit a far branch here, which is
 9184 // more expensive.
 9185 //
 9186 // Conditional Far Branch
 9187 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9188   // Same match rule as `branchCon&#39;.
 9189   match(If cmp cr);
 9190   effect(USE cr, USE lbl);
 9191   // Make more expensive to prefer compare_and_branch over separate instructions.
 9192   ins_cost(2 * BRANCH_COST);
 9193   size(6);
 9194   format %{ &quot;branch_con_far,$cmp   $cr, $lbl&quot; %}
 9195   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9196   ins_pipe(pipe_class_dummy);
 9197   // This is not a short variant of a branch, but the long variant..
 9198   ins_short_branch(0);
 9199 %}
 9200 
 9201 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9202   match(CountedLoopEnd cmp cr);
 9203   effect(USE labl);
 9204   ins_cost(BRANCH_COST);
 9205   size(4);
 9206   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9207   ins_encode(z_enc_branch_con_short(cmp, labl));
 9208   ins_pipe(pipe_class_dummy);
 9209   // If set to 1 this indicates that the current instruction is a
 9210   // short variant of a long branch. This avoids using this
 9211   // instruction in first-pass matching. It will then only be used in
 9212   // the `Shorten_branches&#39; pass.
 9213   ins_short_branch(1);
 9214 %}
 9215 
 9216 instruct branchLoopEndFar(cmpOp cmp, flagsReg cr, label labl) %{
 9217   match(CountedLoopEnd cmp cr);
 9218   effect(USE labl);
 9219   ins_cost(BRANCH_COST);
 9220   size(6);
 9221   format %{ &quot;branch_con_far,$cmp   $labl\t # counted loop end&quot; %}
 9222   ins_encode(z_enc_branch_con_far(cmp, labl));
 9223   ins_pipe(pipe_class_dummy);
 9224   // This is not a short variant of a branch, but the long variant.
 9225   ins_short_branch(0);
 9226 %}
 9227 
 9228 //----------Compare and Branch (short distance)------------------------------
 9229 
 9230 // INT REG operands for loop counter processing.
 9231 instruct testAndBranchLoopEnd_Reg(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9232   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9233   effect(USE labl, KILL cr);
 9234   predicate(VM_Version::has_CompareBranch());
 9235   ins_cost(BRANCH_COST);
 9236   // TODO: s390 port size(FIXED_SIZE);
 9237   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9238   opcode(CRJ_ZOPC);
 9239   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9240   ins_pipe(pipe_class_dummy);
 9241   ins_short_branch(1);
 9242 %}
 9243 
 9244 // INT REG operands.
 9245 instruct cmpb_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9246   match(If boolnode (CmpI src1 src2));
 9247   effect(USE labl, KILL cr);
 9248   predicate(VM_Version::has_CompareBranch());
 9249   ins_cost(BRANCH_COST);
 9250   // TODO: s390 port size(FIXED_SIZE);
 9251   format %{ &quot;CRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9252   opcode(CRJ_ZOPC);
 9253   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9254   ins_pipe(pipe_class_dummy);
 9255   ins_short_branch(1);
 9256 %}
 9257 
 9258 // Unsigned INT REG operands
 9259 instruct cmpbU_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9260   match(If boolnode (CmpU src1 src2));
 9261   effect(USE labl, KILL cr);
 9262   predicate(VM_Version::has_CompareBranch());
 9263   ins_cost(BRANCH_COST);
 9264   // TODO: s390 port size(FIXED_SIZE);
 9265   format %{ &quot;CLRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9266   opcode(CLRJ_ZOPC);
 9267   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9268   ins_pipe(pipe_class_dummy);
 9269   ins_short_branch(1);
 9270 %}
 9271 
 9272 // LONG REG operands
 9273 instruct cmpb_RegL(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9274   match(If boolnode (CmpL src1 src2));
 9275   effect(USE labl, KILL cr);
 9276   predicate(VM_Version::has_CompareBranch());
 9277   ins_cost(BRANCH_COST);
 9278   // TODO: s390 port size(FIXED_SIZE);
 9279   format %{ &quot;CGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9280   opcode(CGRJ_ZOPC);
 9281   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9282   ins_pipe(pipe_class_dummy);
 9283   ins_short_branch(1);
 9284 %}
 9285 
 9286 //  PTR REG operands
 9287 
 9288 // Separate rules for regular and narrow oops.  ADLC can&#39;t recognize
 9289 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9290 // will not shorten.
 9291 
 9292 instruct cmpb_RegPP(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9293   match(If boolnode (CmpP src1 src2));
 9294   effect(USE labl, KILL cr);
 9295   predicate(VM_Version::has_CompareBranch());
 9296   ins_cost(BRANCH_COST);
 9297   // TODO: s390 port size(FIXED_SIZE);
 9298   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9299   opcode(CLGRJ_ZOPC);
 9300   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9301   ins_pipe(pipe_class_dummy);
 9302   ins_short_branch(1);
 9303 %}
 9304 
 9305 instruct cmpb_RegNN(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9306   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9307   effect(USE labl, KILL cr);
 9308   predicate(VM_Version::has_CompareBranch());
 9309   ins_cost(BRANCH_COST);
 9310   // TODO: s390 port size(FIXED_SIZE);
 9311   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9312   opcode(CLGRJ_ZOPC);
 9313   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9314   ins_pipe(pipe_class_dummy);
 9315   ins_short_branch(1);
 9316 %}
 9317 
 9318 // INT REG/IMM operands for loop counter processing
 9319 instruct testAndBranchLoopEnd_Imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9320   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9321   effect(USE labl, KILL cr);
 9322   predicate(VM_Version::has_CompareBranch());
 9323   ins_cost(BRANCH_COST);
 9324   // TODO: s390 port size(FIXED_SIZE);
 9325   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9326   opcode(CIJ_ZOPC);
 9327   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9328   ins_pipe(pipe_class_dummy);
 9329   ins_short_branch(1);
 9330 %}
 9331 
 9332 // INT REG/IMM operands
 9333 instruct cmpb_RegI_imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9334   match(If boolnode (CmpI src1 src2));
 9335   effect(USE labl, KILL cr);
 9336   predicate(VM_Version::has_CompareBranch());
 9337   ins_cost(BRANCH_COST);
 9338   // TODO: s390 port size(FIXED_SIZE);
 9339   format %{ &quot;CIJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9340   opcode(CIJ_ZOPC);
 9341   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9342   ins_pipe(pipe_class_dummy);
 9343   ins_short_branch(1);
 9344 %}
 9345 
 9346 // INT REG/IMM operands
 9347 instruct cmpbU_RegI_imm(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9348   match(If boolnode (CmpU src1 src2));
 9349   effect(USE labl, KILL cr);
 9350   predicate(VM_Version::has_CompareBranch());
 9351   ins_cost(BRANCH_COST);
 9352   // TODO: s390 port size(FIXED_SIZE);
 9353   format %{ &quot;CLIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9354   opcode(CLIJ_ZOPC);
 9355   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9356   ins_pipe(pipe_class_dummy);
 9357   ins_short_branch(1);
 9358 %}
 9359 
 9360 // LONG REG/IMM operands
 9361 instruct cmpb_RegL_imm(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9362   match(If boolnode (CmpL src1 src2));
 9363   effect(USE labl, KILL cr);
 9364   predicate(VM_Version::has_CompareBranch());
 9365   ins_cost(BRANCH_COST);
 9366   // TODO: s390 port size(FIXED_SIZE);
 9367   format %{ &quot;CGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9368   opcode(CGIJ_ZOPC);
 9369   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9370   ins_pipe(pipe_class_dummy);
 9371   ins_short_branch(1);
 9372 %}
 9373 
 9374 // PTR REG-imm operands
 9375 
 9376 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9377 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9378 // will not shorten.
 9379 
 9380 instruct cmpb_RegP_immP(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9381   match(If boolnode (CmpP src1 src2));
 9382   effect(USE labl, KILL cr);
 9383   predicate(VM_Version::has_CompareBranch());
 9384   ins_cost(BRANCH_COST);
 9385   // TODO: s390 port size(FIXED_SIZE);
 9386   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9387   opcode(CLGIJ_ZOPC);
 9388   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9389   ins_pipe(pipe_class_dummy);
 9390   ins_short_branch(1);
 9391 %}
 9392 
 9393 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9394 instruct cmpb_RegN_immP0(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9395   match(If boolnode (CmpP (DecodeN src1) src2));
 9396   effect(USE labl, KILL cr);
 9397   predicate(VM_Version::has_CompareBranch());
 9398   ins_cost(BRANCH_COST);
 9399   // TODO: s390 port size(FIXED_SIZE);
 9400   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9401   opcode(CLGIJ_ZOPC);
 9402   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9403   ins_pipe(pipe_class_dummy);
 9404   ins_short_branch(1);
 9405 %}
 9406 
 9407 instruct cmpb_RegN_imm(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9408   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9409   effect(USE labl, KILL cr);
 9410   predicate(VM_Version::has_CompareBranch());
 9411   ins_cost(BRANCH_COST);
 9412   // TODO: s390 port size(FIXED_SIZE);
 9413   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9414   opcode(CLGIJ_ZOPC);
 9415   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9416   ins_pipe(pipe_class_dummy);
 9417   ins_short_branch(1);
 9418 %}
 9419 
 9420 
 9421 //----------Compare and Branch (far distance)------------------------------
 9422 
 9423 // INT REG operands for loop counter processing
 9424 instruct testAndBranchLoopEnd_RegFar(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9425   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9426   effect(USE labl, KILL cr);
 9427   predicate(VM_Version::has_CompareBranch());
 9428   ins_cost(BRANCH_COST+DEFAULT_COST);
 9429   // TODO: s390 port size(FIXED_SIZE);
 9430   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9431   opcode(CR_ZOPC, BRCL_ZOPC);
 9432   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9433   ins_pipe(pipe_class_dummy);
 9434   ins_short_branch(0);
 9435 %}
 9436 
 9437 // INT REG operands
 9438 instruct cmpb_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9439   match(If boolnode (CmpI src1 src2));
 9440   effect(USE labl, KILL cr);
 9441   predicate(VM_Version::has_CompareBranch());
 9442   ins_cost(BRANCH_COST+DEFAULT_COST);
 9443   // TODO: s390 port size(FIXED_SIZE);
 9444   format %{ &quot;CRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9445   opcode(CR_ZOPC, BRCL_ZOPC);
 9446   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9447   ins_pipe(pipe_class_dummy);
 9448   ins_short_branch(0);
 9449 %}
 9450 
 9451 // INT REG operands
 9452 instruct cmpbU_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9453   match(If boolnode (CmpU src1 src2));
 9454   effect(USE labl, KILL cr);
 9455   predicate(VM_Version::has_CompareBranch());
 9456   ins_cost(BRANCH_COST+DEFAULT_COST);
 9457   // TODO: s390 port size(FIXED_SIZE);
 9458   format %{ &quot;CLRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9459   opcode(CLR_ZOPC, BRCL_ZOPC);
 9460   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9461   ins_pipe(pipe_class_dummy);
 9462   ins_short_branch(0);
 9463 %}
 9464 
 9465 // LONG REG operands
 9466 instruct cmpb_RegL_Far(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9467   match(If boolnode (CmpL src1 src2));
 9468   effect(USE labl, KILL cr);
 9469   predicate(VM_Version::has_CompareBranch());
 9470   ins_cost(BRANCH_COST+DEFAULT_COST);
 9471   // TODO: s390 port size(FIXED_SIZE);
 9472   format %{ &quot;CGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9473   opcode(CGR_ZOPC, BRCL_ZOPC);
 9474   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9475   ins_pipe(pipe_class_dummy);
 9476   ins_short_branch(0);
 9477 %}
 9478 
 9479 // PTR REG operands
 9480 
 9481 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9482 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9483 // will not shorten.
 9484 
 9485 instruct cmpb_RegPP_Far(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9486   match(If boolnode (CmpP src1 src2));
 9487   effect(USE labl, KILL cr);
 9488   predicate(VM_Version::has_CompareBranch());
 9489   ins_cost(BRANCH_COST+DEFAULT_COST);
 9490   // TODO: s390 port size(FIXED_SIZE);
 9491   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9492   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9493   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9494   ins_pipe(pipe_class_dummy);
 9495   ins_short_branch(0);
 9496 %}
 9497 
 9498 instruct cmpb_RegNN_Far(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9499   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9500   effect(USE labl, KILL cr);
 9501   predicate(VM_Version::has_CompareBranch());
 9502   ins_cost(BRANCH_COST+DEFAULT_COST);
 9503   // TODO: s390 port size(FIXED_SIZE);
 9504   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9505   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9506   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9507   ins_pipe(pipe_class_dummy);
 9508   ins_short_branch(0);
 9509 %}
 9510 
 9511 // INT REG/IMM operands for loop counter processing
 9512 instruct testAndBranchLoopEnd_ImmFar(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9513   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9514   effect(USE labl, KILL cr);
 9515   predicate(VM_Version::has_CompareBranch());
 9516   ins_cost(BRANCH_COST+DEFAULT_COST);
 9517   // TODO: s390 port size(FIXED_SIZE);
 9518   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9519   opcode(CHI_ZOPC, BRCL_ZOPC);
 9520   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9521   ins_pipe(pipe_class_dummy);
 9522   ins_short_branch(0);
 9523 %}
 9524 
 9525 // INT REG/IMM operands
 9526 instruct cmpb_RegI_imm_Far(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9527   match(If boolnode (CmpI src1 src2));
 9528   effect(USE labl, KILL cr);
 9529   predicate(VM_Version::has_CompareBranch());
 9530   ins_cost(BRANCH_COST+DEFAULT_COST);
 9531   // TODO: s390 port size(FIXED_SIZE);
 9532   format %{ &quot;CIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9533   opcode(CHI_ZOPC, BRCL_ZOPC);
 9534   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9535   ins_pipe(pipe_class_dummy);
 9536   ins_short_branch(0);
 9537 %}
 9538 
 9539 // INT REG/IMM operands
 9540 instruct cmpbU_RegI_imm_Far(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9541   match(If boolnode (CmpU src1 src2));
 9542   effect(USE labl, KILL cr);
 9543   predicate(VM_Version::has_CompareBranch());
 9544   ins_cost(BRANCH_COST+DEFAULT_COST);
 9545   // TODO: s390 port size(FIXED_SIZE);
 9546   format %{ &quot;CLIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9547   opcode(CLFI_ZOPC, BRCL_ZOPC);
 9548   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9549   ins_pipe(pipe_class_dummy);
 9550   ins_short_branch(0);
 9551 %}
 9552 
 9553 // LONG REG/IMM operands
 9554 instruct cmpb_RegL_imm_Far(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9555   match(If boolnode (CmpL src1 src2));
 9556   effect(USE labl, KILL cr);
 9557   predicate(VM_Version::has_CompareBranch());
 9558   ins_cost(BRANCH_COST+DEFAULT_COST);
 9559   // TODO: s390 port size(FIXED_SIZE);
 9560   format %{ &quot;CGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9561   opcode(CGHI_ZOPC, BRCL_ZOPC);
 9562   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9563   ins_pipe(pipe_class_dummy);
 9564   ins_short_branch(0);
 9565 %}
 9566 
 9567 // PTR REG-imm operands
 9568 
 9569 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9570 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9571 // will not shorten.
 9572 
 9573 instruct cmpb_RegP_immP_Far(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9574   match(If boolnode (CmpP src1 src2));
 9575   effect(USE labl, KILL cr);
 9576   predicate(VM_Version::has_CompareBranch());
 9577   ins_cost(BRANCH_COST+DEFAULT_COST);
 9578   // TODO: s390 port size(FIXED_SIZE);
 9579   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9580   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9581   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9582   ins_pipe(pipe_class_dummy);
 9583   ins_short_branch(0);
 9584 %}
 9585 
 9586 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9587 instruct cmpb_RegN_immP0_Far(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9588   match(If boolnode (CmpP (DecodeN src1) src2));
 9589   effect(USE labl, KILL cr);
 9590   predicate(VM_Version::has_CompareBranch());
 9591   ins_cost(BRANCH_COST+DEFAULT_COST);
 9592   // TODO: s390 port size(FIXED_SIZE);
 9593   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9594   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9595   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9596   ins_pipe(pipe_class_dummy);
 9597   ins_short_branch(0);
 9598 %}
 9599 
 9600 instruct cmpb_RegN_immN_Far(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9601   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9602   effect(USE labl, KILL cr);
 9603   predicate(VM_Version::has_CompareBranch());
 9604   ins_cost(BRANCH_COST+DEFAULT_COST);
 9605   // TODO: s390 port size(FIXED_SIZE);
 9606   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9607   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9608   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9609   ins_pipe(pipe_class_dummy);
 9610   ins_short_branch(0);
 9611 %}
 9612 
 9613 // ============================================================================
 9614 // Long Compare
 9615 
 9616 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9617 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)). Note the
 9618 // difference between &#39;Y&#39; and &#39;0L&#39;. The tree-matches for the CmpI sections
 9619 // are collapsed internally in the ADLC&#39;s dfa-gen code. The match for
 9620 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9621 // foo match ends up with the wrong leaf. One fix is to not match both
 9622 // reg-reg and reg-zero forms of long-compare. This is unfortunate because
 9623 // both forms beat the trinary form of long-compare and both are very useful
 9624 // on platforms which have few registers.
 9625 
 9626 // Manifest a CmpL3 result in an integer register. Very painful.
 9627 // This is the test to avoid.
 9628 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr) %{
 9629   match(Set dst (CmpL3 src1 src2));
 9630   effect(KILL cr);
 9631   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9632   size(24);
 9633   format %{ &quot;CmpL3 $dst,$src1,$src2&quot; %}
 9634   ins_encode %{
 9635     Label done;
 9636     // compare registers
 9637     __ z_cgr($src1$$Register, $src2$$Register);
 9638     // Convert condition code into -1,0,1, where
 9639     // -1 means less
 9640     //  0 means equal
 9641     //  1 means greater.
 9642     if (VM_Version::has_LoadStoreConditional()) {
 9643       Register one       = Z_R0_scratch;
 9644       Register minus_one = Z_R1_scratch;
 9645       __ z_lghi(minus_one, -1);
 9646       __ z_lghi(one, 1);
 9647       __ z_lghi( $dst$$Register, 0);
 9648       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9649       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLow);
 9650     } else {
 9651       __ clear_reg($dst$$Register, true, false);
 9652       __ z_bre(done);
 9653       __ z_lhi($dst$$Register, 1);
 9654       __ z_brh(done);
 9655       __ z_lhi($dst$$Register, -1);
 9656     }
 9657     __ bind(done);
 9658   %}
 9659   ins_pipe(pipe_class_dummy);
 9660 %}
 9661 
 9662 // ============================================================================
 9663 // Safepoint Instruction
 9664 
 9665 instruct safePoint() %{
 9666   match(SafePoint);
 9667   predicate(false);
 9668   // TODO: s390 port size(FIXED_SIZE);
 9669   format %{ &quot;UNIMPLEMENTED Safepoint_ &quot; %}
 9670   ins_encode(enc_unimplemented());
 9671   ins_pipe(pipe_class_dummy);
 9672 %}
 9673 
 9674 instruct safePoint_poll(iRegP poll, flagsReg cr) %{
 9675   match(SafePoint poll);
 9676   effect(USE poll, KILL cr); // R0 is killed, too.
 9677   // TODO: s390 port size(FIXED_SIZE);
 9678   format %{ &quot;TM      #0[,$poll],#111\t # Safepoint: poll for GC&quot; %}
 9679   ins_encode %{
 9680     // Mark the code position where the load from the safepoint
 9681     // polling page was emitted as relocInfo::poll_type.
 9682     __ relocate(relocInfo::poll_type);
 9683     __ load_from_polling_page($poll$$Register);
 9684   %}
 9685   ins_pipe(pipe_class_dummy);
 9686 %}
 9687 
 9688 // ============================================================================
 9689 
 9690 // Call Instructions
 9691 
 9692 // Call Java Static Instruction
 9693 instruct CallStaticJavaDirect_dynTOC(method meth) %{
 9694   match(CallStaticJava);
 9695   effect(USE meth);
 9696   ins_cost(CALL_COST);
 9697   // TODO: s390 port size(VARIABLE_SIZE);
 9698   format %{ &quot;CALL,static dynTOC $meth; ==&gt; &quot; %}
 9699   ins_encode( z_enc_java_static_call(meth) );
 9700   ins_pipe(pipe_class_dummy);
 9701   ins_alignment(2);
 9702 %}
 9703 
 9704 // Call Java Dynamic Instruction
 9705 instruct CallDynamicJavaDirect_dynTOC(method meth) %{
 9706   match(CallDynamicJava);
 9707   effect(USE meth);
 9708   ins_cost(CALL_COST);
 9709   // TODO: s390 port size(VARIABLE_SIZE);
 9710   format %{ &quot;CALL,dynamic dynTOC $meth; ==&gt; &quot; %}
 9711   ins_encode(z_enc_java_dynamic_call(meth));
 9712   ins_pipe(pipe_class_dummy);
 9713   ins_alignment(2);
 9714 %}
 9715 
 9716 // Call Runtime Instruction
 9717 instruct CallRuntimeDirect(method meth) %{
 9718   match(CallRuntime);
 9719   effect(USE meth);
 9720   ins_cost(CALL_COST);
 9721   // TODO: s390 port size(VARIABLE_SIZE);
 9722   ins_num_consts(1);
 9723   ins_alignment(2);
 9724   format %{ &quot;CALL,runtime&quot; %}
 9725   ins_encode( z_enc_java_to_runtime_call(meth) );
 9726   ins_pipe(pipe_class_dummy);
 9727 %}
 9728 
 9729 // Call runtime without safepoint - same as CallRuntime
 9730 instruct CallLeafDirect(method meth) %{
 9731   match(CallLeaf);
 9732   effect(USE meth);
 9733   ins_cost(CALL_COST);
 9734   // TODO: s390 port size(VARIABLE_SIZE);
 9735   ins_num_consts(1);
 9736   ins_alignment(2);
 9737   format %{ &quot;CALL,runtime leaf $meth&quot; %}
 9738   ins_encode( z_enc_java_to_runtime_call(meth) );
 9739   ins_pipe(pipe_class_dummy);
 9740 %}
 9741 
 9742 // Call runtime without safepoint - same as CallLeaf
 9743 instruct CallLeafNoFPDirect(method meth) %{
 9744   match(CallLeafNoFP);
 9745   effect(USE meth);
 9746   ins_cost(CALL_COST);
 9747   // TODO: s390 port size(VARIABLE_SIZE);
 9748   ins_num_consts(1);
 9749   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9750   ins_encode( z_enc_java_to_runtime_call(meth) );
 9751   ins_pipe(pipe_class_dummy);
 9752   ins_alignment(2);
 9753 %}
 9754 
 9755 // Tail Call; Jump from runtime stub to Java code.
 9756 // Also known as an &#39;interprocedural jump&#39;.
 9757 // Target of jump will eventually return to caller.
 9758 // TailJump below removes the return address.
 9759 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9760   match(TailCall jump_target method_oop);
 9761   ins_cost(CALL_COST);
 9762   size(2);
 9763   format %{ &quot;Jmp     $jump_target\t# $method_oop holds method oop&quot; %}
 9764   ins_encode %{ __ z_br($jump_target$$Register); %}
 9765   ins_pipe(pipe_class_dummy);
 9766 %}
 9767 
 9768 // Return Instruction
 9769 instruct Ret() %{
 9770   match(Return);
 9771   size(2);
 9772   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9773   ins_encode %{ __ z_br(Z_R14); %}
 9774   ins_pipe(pipe_class_dummy);
 9775 %}
 9776 
 9777 // Tail Jump; remove the return address; jump to target.
 9778 // TailCall above leaves the return address around.
 9779 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9780 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9781 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9782 // in %i0.
 9783 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
 9784   match(TailJump jump_target ex_oop);
 9785   ins_cost(CALL_COST);
 9786   size(8);
 9787   format %{ &quot;TailJump $jump_target&quot; %}
 9788   ins_encode %{
 9789     __ z_lg(Z_ARG2/* issuing pc */, _z_abi(return_pc), Z_SP);
 9790     __ z_br($jump_target$$Register);
 9791   %}
 9792   ins_pipe(pipe_class_dummy);
 9793 %}
 9794 
 9795 // Create exception oop: created by stack-crawling runtime code.
 9796 // Created exception is now available to this handler, and is setup
 9797 // just prior to jumping to this handler. No code emitted.
 9798 instruct CreateException(rarg1RegP ex_oop) %{
 9799   match(Set ex_oop (CreateEx));
 9800   ins_cost(0);
 9801   size(0);
 9802   format %{ &quot;# exception oop; no code emitted&quot; %}
 9803   ins_encode(/*empty*/);
 9804   ins_pipe(pipe_class_dummy);
 9805 %}
 9806 
 9807 // Rethrow exception: The exception oop will come in the first
 9808 // argument position. Then JUMP (not call) to the rethrow stub code.
 9809 instruct RethrowException() %{
 9810   match(Rethrow);
 9811   ins_cost(CALL_COST);
 9812   // TODO: s390 port size(VARIABLE_SIZE);
 9813   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9814   ins_encode %{
 9815     cbuf.set_insts_mark();
 9816     __ load_const_optimized(Z_R1_scratch, (address)OptoRuntime::rethrow_stub());
 9817     __ z_br(Z_R1_scratch);
 9818   %}
 9819   ins_pipe(pipe_class_dummy);
 9820 %}
 9821 
 9822 // Die now.
 9823 instruct ShouldNotReachHere() %{
 9824   match(Halt);
 9825   ins_cost(CALL_COST);
 9826   size(2);
 9827   format %{ &quot;ILLTRAP; ShouldNotReachHere&quot; %}
 9828   ins_encode %{ __ z_illtrap(); %}
 9829   ins_pipe(pipe_class_dummy);
 9830 %}
 9831 
 9832 // ============================================================================
 9833 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
 9834 // array for an instance of the superklass. Set a hidden internal cache on a
 9835 // hit (cache is checked with exposed code in gen_subtype_check()). Return
 9836 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
 9837 instruct partialSubtypeCheck(rarg1RegP index, rarg2RegP sub, rarg3RegP super, flagsReg pcc,
 9838                              rarg4RegP scratch1, rarg5RegP scratch2) %{
 9839   match(Set index (PartialSubtypeCheck sub super));
 9840   effect(KILL pcc, KILL scratch1, KILL scratch2);
 9841   ins_cost(10 * DEFAULT_COST);
 9842   // TODO: s390 port size(FIXED_SIZE);
 9843   format %{ &quot;  CALL   PartialSubtypeCheck\n&quot; %}
 9844   ins_encode %{
 9845     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9846     __ load_const_optimized(Z_ARG4, stub_address);
 9847     __ z_basr(Z_R14, Z_ARG4);
 9848   %}
 9849   ins_pipe(pipe_class_dummy);
 9850 %}
 9851 
 9852 instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,
 9853                                      rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{
 9854   match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));
 9855   effect(KILL scratch1, KILL scratch2, KILL index);
 9856   ins_cost(10 * DEFAULT_COST);
 9857   // TODO: s390 port size(FIXED_SIZE);
 9858   format %{ &quot;CALL   PartialSubtypeCheck_vs_zero\n&quot; %}
 9859   ins_encode %{
 9860     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9861     __ load_const_optimized(Z_ARG4, stub_address);
 9862     __ z_basr(Z_R14, Z_ARG4);
 9863   %}
 9864   ins_pipe(pipe_class_dummy);
 9865 %}
 9866 
 9867 // ============================================================================
 9868 // inlined locking and unlocking
 9869 
 9870 instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9871   match(Set pcc (FastLock oop box));
 9872   effect(TEMP tmp1, TEMP tmp2);
 9873   ins_cost(100);
 9874   // TODO: s390 port size(VARIABLE_SIZE); // Uses load_const_optimized.
 9875   format %{ &quot;FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9876   ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9877                                              UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9878   ins_pipe(pipe_class_dummy);
 9879 %}
 9880 
 9881 instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9882   match(Set pcc (FastUnlock oop box));
 9883   effect(TEMP tmp1, TEMP tmp2);
 9884   ins_cost(100);
 9885   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9886   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9887   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9888                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9889   ins_pipe(pipe_class_dummy);
 9890 %}
 9891 
 9892 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9893   match(Set dummy (ClearArray cnt base));
 9894   effect(KILL cr);
 9895   ins_cost(100);
 9896   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9897   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9898   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9899   ins_pipe(pipe_class_dummy);
 9900 %}
 9901 
 9902 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{
 9903   match(Set dummy (ClearArray cnt base));
 9904   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.
 9905   ins_cost(200);
 9906   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9907   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
 9908   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $srcA$$Register, $srcL$$Register); %}
 9909   ins_pipe(pipe_class_dummy);
 9910 %}
 9911 
 9912 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{
 9913   match(Set dummy (ClearArray cnt base));
 9914   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.
 9915   ins_cost(300);
 9916   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9917   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
 9918   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $srcA$$Register, $srcL$$Register); %}
 9919   ins_pipe(pipe_class_dummy);
 9920 %}
 9921 
 9922 // ============================================================================
 9923 // CompactStrings
 9924 
 9925 // String equals
 9926 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9927   match(Set result (StrEquals (Binary str1 str2) cnt));
 9928   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9929   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
 9930   ins_cost(300);
 9931   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9932   ins_encode %{
 9933     __ array_equals(false, $str1$$Register, $str2$$Register,
 9934                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9935                     $result$$Register, true /* byte */);
 9936   %}
 9937   ins_pipe(pipe_class_dummy);
 9938 %}
 9939 
 9940 instruct string_equalsU(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9941   match(Set result (StrEquals (Binary str1 str2) cnt));
 9942   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9943   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
 9944   ins_cost(300);
 9945   format %{ &quot;String Equals char[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9946   ins_encode %{
 9947     __ array_equals(false, $str1$$Register, $str2$$Register,
 9948                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9949                     $result$$Register, false /* byte */);
 9950   %}
 9951   ins_pipe(pipe_class_dummy);
 9952 %}
 9953 
 9954 instruct string_equals_imm(iRegP str1, iRegP str2, uimmI8 cnt, iRegI result, flagsReg cr) %{
 9955   match(Set result (StrEquals (Binary str1 str2) cnt));
 9956   effect(KILL cr); // R0 is killed, too.
 9957   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
 9958   ins_cost(100);
 9959   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9960   ins_encode %{
 9961     const int cnt_imm = $cnt$$constant;
 9962     if (cnt_imm) { __ z_clc(0, cnt_imm - 1, $str1$$Register, 0, $str2$$Register); }
 9963     __ z_lhi($result$$Register, 1);
 9964     if (cnt_imm) {
 9965       if (VM_Version::has_LoadStoreConditional()) {
 9966         __ z_lhi(Z_R0_scratch, 0);
 9967         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
 9968       } else {
 9969         Label Lskip;
 9970         __ z_bre(Lskip);
 9971         __ clear_reg($result$$Register);
 9972         __ bind(Lskip);
 9973       }
 9974     }
 9975   %}
 9976   ins_pipe(pipe_class_dummy);
 9977 %}
 9978 
 9979 instruct string_equalsC_imm(iRegP str1, iRegP str2, immI8 cnt, iRegI result, flagsReg cr) %{
 9980   match(Set result (StrEquals (Binary str1 str2) cnt));
 9981   effect(KILL cr); // R0 is killed, too.
 9982   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
 9983   ins_cost(100);
 9984   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result&quot; %}
 9985   ins_encode %{
 9986     const int cnt_imm = $cnt$$constant; // positive immI8 (7 bits used)
 9987     if (cnt_imm) { __ z_clc(0, (cnt_imm &lt;&lt; 1) - 1, $str1$$Register, 0, $str2$$Register); }
 9988     __ z_lhi($result$$Register, 1);
 9989     if (cnt_imm) {
 9990       if (VM_Version::has_LoadStoreConditional()) {
 9991         __ z_lhi(Z_R0_scratch, 0);
 9992         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
 9993       } else {
 9994         Label Lskip;
 9995         __ z_bre(Lskip);
 9996         __ clear_reg($result$$Register);
 9997         __ bind(Lskip);
 9998       }
 9999     }
10000   %}
10001   ins_pipe(pipe_class_dummy);
10002 %}
10003 
10004 // Array equals
10005 instruct array_equalsB(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10006   match(Set result (AryEq ary1 ary2));
10007   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10008   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10009   ins_cost(300);
10010   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10011   ins_encode %{
10012     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10013                     noreg, $oddReg$$Register, $evenReg$$Register,
10014                     $result$$Register, true /* byte */);
10015   %}
10016   ins_pipe(pipe_class_dummy);
10017 %}
10018 
10019 instruct array_equalsC(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10020   match(Set result (AryEq ary1 ary2));
10021   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10022   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10023   ins_cost(300);
10024   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10025   ins_encode %{
10026     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10027                     noreg, $oddReg$$Register, $evenReg$$Register,
10028                     $result$$Register, false /* byte */);
10029   %}
10030   ins_pipe(pipe_class_dummy);
10031 %}
10032 
10033 // String CompareTo
10034 instruct string_compareL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10035   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10036   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10037   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10038   ins_cost(300);
10039   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10040   ins_encode %{
10041     __ string_compare($str1$$Register, $str2$$Register,
10042                       $cnt1$$Register, $cnt2$$Register,
10043                       $oddReg$$Register, $evenReg$$Register,
10044                       $result$$Register, StrIntrinsicNode::LL);
10045   %}
10046   ins_pipe(pipe_class_dummy);
10047 %}
10048 
10049 instruct string_compareU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10050   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10051   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10052   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10053   ins_cost(300);
10054   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10055   ins_encode %{
10056     __ string_compare($str1$$Register, $str2$$Register,
10057                       $cnt1$$Register, $cnt2$$Register,
10058                       $oddReg$$Register, $evenReg$$Register,
10059                       $result$$Register, StrIntrinsicNode::UU);
10060   %}
10061   ins_pipe(pipe_class_dummy);
10062 %}
10063 
10064 instruct string_compareLU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10065   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10066   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10067   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10068   ins_cost(300);
10069   format %{ &quot;String Compare byte[],char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10070   ins_encode %{
10071     __ string_compare($str1$$Register, $str2$$Register,
10072                       $cnt1$$Register, $cnt2$$Register,
10073                       $oddReg$$Register, $evenReg$$Register,
10074                       $result$$Register, StrIntrinsicNode::LU);
10075   %}
10076   ins_pipe(pipe_class_dummy);
10077 %}
10078 
10079 instruct string_compareUL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10080   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10081   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10082   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10083   ins_cost(300);
10084   format %{ &quot;String Compare char[],byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10085   ins_encode %{
10086     __ string_compare($str2$$Register, $str1$$Register,
10087                       $cnt2$$Register, $cnt1$$Register,
10088                       $oddReg$$Register, $evenReg$$Register,
10089                       $result$$Register, StrIntrinsicNode::UL);
10090   %}
10091   ins_pipe(pipe_class_dummy);
10092 %}
10093 
10094 // String IndexOfChar
10095 instruct indexOfChar_U(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10096   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
10097   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10098   ins_cost(200);
10099   format %{ &quot;String IndexOfChar [0..$haycnt]($haystack), $ch -&gt; $result&quot; %}
10100   ins_encode %{
10101     __ string_indexof_char($result$$Register,
10102                            $haystack$$Register, $haycnt$$Register,
10103                            $ch$$Register, 0 /* unused, ch is in register */,
10104                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10105   %}
10106   ins_pipe(pipe_class_dummy);
10107 %}
10108 
10109 instruct indexOf_imm1_U(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10110   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10111   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10112   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10113   ins_cost(200);
10114   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10115   ins_encode %{
10116     immPOper *needleOper = (immPOper *)$needle;
10117     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10118     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10119     jchar chr;
10120 #ifdef VM_LITTLE_ENDIAN
10121     Unimplemented();
10122 #else
10123     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
10124            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
10125 #endif
10126     __ string_indexof_char($result$$Register,
10127                            $haystack$$Register, $haycnt$$Register,
10128                            noreg, chr,
10129                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10130   %}
10131   ins_pipe(pipe_class_dummy);
10132 %}
10133 
10134 instruct indexOf_imm1_L(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10135   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10136   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10137   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10138   ins_cost(200);
10139   format %{ &quot;String IndexOf L [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10140   ins_encode %{
10141     immPOper *needleOper = (immPOper *)$needle;
10142     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10143     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10144     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10145     __ string_indexof_char($result$$Register,
10146                            $haystack$$Register, $haycnt$$Register,
10147                            noreg, chr,
10148                            $oddReg$$Register, $evenReg$$Register, true /*is_byte*/);
10149   %}
10150   ins_pipe(pipe_class_dummy);
10151 %}
10152 
10153 instruct indexOf_imm1_UL(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10154   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10155   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10156   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10157   ins_cost(200);
10158   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10159   ins_encode %{
10160     immPOper *needleOper = (immPOper *)$needle;
10161     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10162     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10163     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10164     __ string_indexof_char($result$$Register,
10165                            $haystack$$Register, $haycnt$$Register,
10166                            noreg, chr,
10167                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10168   %}
10169   ins_pipe(pipe_class_dummy);
10170 %}
10171 
10172 // String IndexOf
10173 instruct indexOf_imm_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10174   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10175   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10176   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10177   ins_cost(250);
10178   format %{ &quot;String IndexOf U [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10179   ins_encode %{
10180     __ string_indexof($result$$Register,
10181                       $haystack$$Register, $haycnt$$Register,
10182                       $needle$$Register, noreg, $needlecntImm$$constant,
10183                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10184   %}
10185   ins_pipe(pipe_class_dummy);
10186 %}
10187 
10188 instruct indexOf_imm_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10189   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10190   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10191   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10192   ins_cost(250);
10193   format %{ &quot;String IndexOf L [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10194   ins_encode %{
10195     __ string_indexof($result$$Register,
10196                       $haystack$$Register, $haycnt$$Register,
10197                       $needle$$Register, noreg, $needlecntImm$$constant,
10198                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10199   %}
10200   ins_pipe(pipe_class_dummy);
10201 %}
10202 
10203 instruct indexOf_imm_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10204   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10205   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10206   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10207   ins_cost(250);
10208   format %{ &quot;String IndexOf UL [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10209   ins_encode %{
10210     __ string_indexof($result$$Register,
10211                       $haystack$$Register, $haycnt$$Register,
10212                       $needle$$Register, noreg, $needlecntImm$$constant,
10213                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10214   %}
10215   ins_pipe(pipe_class_dummy);
10216 %}
10217 
10218 instruct indexOf_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10219   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10220   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10221   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10222   ins_cost(300);
10223   format %{ &quot;String IndexOf U [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10224   ins_encode %{
10225     __ string_indexof($result$$Register,
10226                       $haystack$$Register, $haycnt$$Register,
10227                       $needle$$Register, $needlecnt$$Register, 0,
10228                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10229   %}
10230   ins_pipe(pipe_class_dummy);
10231 %}
10232 
10233 instruct indexOf_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10234   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10235   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10236   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10237   ins_cost(300);
10238   format %{ &quot;String IndexOf L [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10239   ins_encode %{
10240     __ string_indexof($result$$Register,
10241                       $haystack$$Register, $haycnt$$Register,
10242                       $needle$$Register, $needlecnt$$Register, 0,
10243                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10244   %}
10245   ins_pipe(pipe_class_dummy);
10246 %}
10247 
10248 instruct indexOf_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10249   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10250   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10251   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10252   ins_cost(300);
10253   format %{ &quot;String IndexOf UL [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10254   ins_encode %{
10255     __ string_indexof($result$$Register,
10256                       $haystack$$Register, $haycnt$$Register,
10257                       $needle$$Register, $needlecnt$$Register, 0,
10258                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10259   %}
10260   ins_pipe(pipe_class_dummy);
10261 %}
10262 
10263 // char[] to byte[] compression
10264 instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10265   match(Set result (StrCompressedCopy src (Binary dst len)));
10266   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10267   ins_cost(300);
10268   format %{ &quot;String Compress $src-&gt;$dst($len) -&gt; $result&quot; %}
10269   ins_encode %{
10270     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10271                        $tmp$$Register, false);
10272   %}
10273   ins_pipe(pipe_class_dummy);
10274 %}
10275 
10276 // byte[] to char[] inflation. trot implementation is shorter, but slower than the unrolled icm(h) loop.
10277 //instruct string_inflate_trot(Universe dummy, iRegP src, revenRegP dst, roddRegI len, iRegI tmp, flagsReg cr) %{
10278 //  match(Set dummy (StrInflatedCopy src (Binary dst len)));
10279 //  effect(USE_KILL dst, USE_KILL len, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10280 //  predicate(VM_Version::has_ETF2Enhancements());
10281 //  ins_cost(300);
10282 //  format %{ &quot;String Inflate (trot) $dst,$src($len)&quot; %}
10283 //  ins_encode %{
10284 //    __ string_inflate_trot($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10285 //  %}
10286 //  ins_pipe(pipe_class_dummy);
10287 //%}
10288 
10289 // byte[] to char[] inflation
10290 instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{
10291   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10292   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10293   ins_cost(300);
10294   format %{ &quot;String Inflate $src-&gt;$dst($len)&quot; %}
10295   ins_encode %{
10296     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10297   %}
10298   ins_pipe(pipe_class_dummy);
10299 %}
10300 
10301 // byte[] to char[] inflation
10302 instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{
10303   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10304   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10305   ins_cost(300);
10306   format %{ &quot;String Inflate (constLen) $src-&gt;$dst($len)&quot; %}
10307   ins_encode %{
10308     __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);
10309   %}
10310   ins_pipe(pipe_class_dummy);
10311 %}
10312 
10313 // StringCoding.java intrinsics
10314 instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{
10315   match(Set result (HasNegatives ary1 len));
10316   effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10317   ins_cost(300);
10318   format %{ &quot;has negatives byte[] $ary1($len) -&gt; $result&quot; %}
10319   ins_encode %{
10320     __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,
10321                      $oddReg$$Register, $evenReg$$Register, $tmp$$Register);
10322   %}
10323   ins_pipe(pipe_class_dummy);
10324 %}
10325 
10326 // encode char[] to byte[] in ISO_8859_1
10327 instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10328   match(Set result (EncodeISOArray src (Binary dst len)));
10329   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10330   ins_cost(300);
10331   format %{ &quot;Encode array $src-&gt;$dst($len) -&gt; $result&quot; %}
10332   ins_encode %{
10333     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10334                        $tmp$$Register, true);
10335   %}
10336   ins_pipe(pipe_class_dummy);
10337 %}
10338 
10339 
10340 //----------PEEPHOLE RULES-----------------------------------------------------
10341 // These must follow all instruction definitions as they use the names
10342 // defined in the instructions definitions.
10343 //
10344 // peepmatch (root_instr_name [preceeding_instruction]*);
10345 //
10346 // peepconstraint %{
10347 // (instruction_number.operand_name relational_op instruction_number.operand_name
10348 //  [, ...]);
10349 // // instruction numbers are zero-based using left to right order in peepmatch
10350 //
10351 // peepreplace (instr_name([instruction_number.operand_name]*));
10352 // // provide an instruction_number.operand_name for each operand that appears
10353 // // in the replacement instruction&#39;s match rule
10354 //
10355 // ---------VM FLAGS---------------------------------------------------------
10356 //
10357 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10358 //
10359 // Each peephole rule is given an identifying number starting with zero and
10360 // increasing by one in the order seen by the parser. An individual peephole
10361 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10362 // on the command-line.
10363 //
10364 // ---------CURRENT LIMITATIONS----------------------------------------------
10365 //
10366 // Only match adjacent instructions in same basic block
10367 // Only equality constraints
10368 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10369 // Only one replacement instruction
10370 //
10371 // ---------EXAMPLE----------------------------------------------------------
10372 //
10373 // // pertinent parts of existing instructions in architecture description
10374 // instruct movI(eRegI dst, eRegI src) %{
10375 //   match(Set dst (CopyI src));
10376 // %}
10377 //
10378 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10379 //   match(Set dst (AddI dst src));
10380 //   effect(KILL cr);
10381 // %}
10382 //
10383 // // Change (inc mov) to lea
10384 // peephole %{
10385 //   // increment preceeded by register-register move
10386 //   peepmatch (incI_eReg movI);
10387 //   // require that the destination register of the increment
10388 //   // match the destination register of the move
10389 //   peepconstraint (0.dst == 1.dst);
10390 //   // construct a replacement instruction that sets
10391 //   // the destination to (move&#39;s source register + one)
10392 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10393 // %}
10394 //
10395 // Implementation no longer uses movX instructions since
10396 // machine-independent system no longer uses CopyX nodes.
10397 //
10398 // peephole %{
10399 //   peepmatch (incI_eReg movI);
10400 //   peepconstraint (0.dst == 1.dst);
10401 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10402 // %}
10403 //
10404 // peephole %{
10405 //   peepmatch (decI_eReg movI);
10406 //   peepconstraint (0.dst == 1.dst);
10407 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10408 // %}
10409 //
10410 // peephole %{
10411 //   peepmatch (addI_eReg_imm movI);
10412 //   peepconstraint (0.dst == 1.dst);
10413 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10414 // %}
10415 //
10416 // peephole %{
10417 //   peepmatch (addP_eReg_imm movP);
10418 //   peepconstraint (0.dst == 1.dst);
10419 //   peepreplace (leaP_eReg_immI(0.dst 1.src 0.src));
10420 // %}
10421 
10422 
10423 //  This peephole rule does not work, probably because ADLC can&#39;t handle two effects:
10424 //  Effect 1 is defining 0.op1 and effect 2 is setting CC
10425 // condense a load from memory and subsequent test for zero
10426 // into a single, more efficient ICM instruction.
10427 // peephole %{
10428 //   peepmatch (compI_iReg_imm0 loadI);
10429 //   peepconstraint (1.dst == 0.op1);
10430 //   peepreplace (loadtest15_iReg_mem(0.op1 0.op1 1.mem));
10431 // %}
10432 
10433 // // Change load of spilled value to only a spill
10434 // instruct storeI(memory mem, eRegI src) %{
10435 //   match(Set mem (StoreI mem src));
10436 // %}
10437 //
10438 // instruct loadI(eRegI dst, memory mem) %{
10439 //   match(Set dst (LoadI mem));
10440 // %}
10441 //
10442 peephole %{
10443   peepmatch (loadI storeI);
10444   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10445   peepreplace (storeI(1.mem 1.mem 1.src));
10446 %}
10447 
10448 peephole %{
10449   peepmatch (loadL storeL);
10450   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10451   peepreplace (storeL(1.mem 1.mem 1.src));
10452 %}
10453 
10454 peephole %{
10455   peepmatch (loadP storeP);
10456   peepconstraint (1.src == 0.dst, 1.dst == 0.mem);
10457   peepreplace (storeP(1.dst 1.dst 1.src));
10458 %}
10459 
10460 //----------SUPERWORD RULES---------------------------------------------------
10461 
10462 //  Expand rules for special cases
10463 
10464 instruct expand_storeF(stackSlotF mem, regF src) %{
10465   // No match rule, false predicate, for expand only.
10466   effect(DEF mem, USE src);
10467   predicate(false);
10468   ins_cost(MEMORY_REF_COST);
10469   // TODO: s390 port size(FIXED_SIZE);
10470   format %{ &quot;STE      $src,$mem\t # replicate(float2stack)&quot; %}
10471   opcode(STE_ZOPC, STE_ZOPC);
10472   ins_encode(z_form_rt_mem(src, mem));
10473   ins_pipe(pipe_class_dummy);
10474 %}
10475 
10476 instruct expand_LoadLogical_I2L(iRegL dst, stackSlotF mem) %{
10477   // No match rule, false predicate, for expand only.
10478   effect(DEF dst, USE mem);
10479   predicate(false);
10480   ins_cost(MEMORY_REF_COST);
10481   // TODO: s390 port size(FIXED_SIZE);
10482   format %{ &quot;LLGF     $dst,$mem\t # replicate(stack2reg(unsigned))&quot; %}
10483   opcode(LLGF_ZOPC, LLGF_ZOPC);
10484   ins_encode(z_form_rt_mem(dst, mem));
10485   ins_pipe(pipe_class_dummy);
10486 %}
10487 
10488 // Replicate scalar int to packed int values (8 Bytes)
10489 instruct expand_Repl2I_reg(iRegL dst, iRegL src) %{
10490   // Dummy match rule, false predicate, for expand only.
10491   match(Set dst (ConvI2L src));
10492   predicate(false);
10493   ins_cost(DEFAULT_COST);
10494   // TODO: s390 port size(FIXED_SIZE);
10495   format %{ &quot;REPLIC2F $dst,$src\t # replicate(pack2F)&quot; %}
10496   ins_encode %{
10497     if ($dst$$Register == $src$$Register) {
10498       __ z_sllg(Z_R0_scratch, $src$$Register, 64-32);
10499       __ z_ogr($dst$$Register, Z_R0_scratch);
10500     }  else {
10501       __ z_sllg($dst$$Register, $src$$Register, 64-32);
10502       __ z_ogr( $dst$$Register, $src$$Register);
10503     }
10504   %}
10505   ins_pipe(pipe_class_dummy);
10506 %}
10507 
10508 // Replication
10509 
10510 // Exploit rotate_then_insert, if available
10511 // Replicate scalar byte to packed byte values (8 Bytes).
10512 instruct Repl8B_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10513   match(Set dst (ReplicateB src));
10514   effect(KILL cr);
10515   predicate((n-&gt;as_Vector()-&gt;length() == 8));
10516   format %{ &quot;REPLIC8B $dst,$src\t # pack8B&quot; %}
10517   ins_encode %{
10518     if ($dst$$Register != $src$$Register) {
10519       __ z_lgr($dst$$Register, $src$$Register);
10520     }
10521     __ rotate_then_insert($dst$$Register, $dst$$Register, 48, 55,  8, false);
10522     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10523     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10524   %}
10525   ins_pipe(pipe_class_dummy);
10526 %}
10527 
10528 // Replicate scalar byte to packed byte values (8 Bytes).
10529 instruct Repl8B_imm(iRegL dst, immB_n0m1 src) %{
10530   match(Set dst (ReplicateB src));
10531   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10532   ins_should_rematerialize(true);
10533   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm&quot; %}
10534   ins_encode %{
10535     int64_t  Isrc8 = $src$$constant &amp; 0x000000ff;
10536     int64_t Isrc16 =  Isrc8 &lt;&lt;  8 |  Isrc8;
10537     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10538     assert(Isrc8 != 0x000000ff &amp;&amp; Isrc8 != 0, &quot;should be handled by other match rules.&quot;);
10539 
10540     __ z_llilf($dst$$Register, Isrc32);
10541     __ z_iihf($dst$$Register, Isrc32);
10542   %}
10543   ins_pipe(pipe_class_dummy);
10544 %}
10545 
10546 // Replicate scalar byte to packed byte values (8 Bytes).
10547 instruct Repl8B_imm0(iRegL dst, immI_0 src) %{
10548   match(Set dst (ReplicateB src));
10549   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10550   ins_should_rematerialize(true);
10551   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm0&quot; %}
10552   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10553   ins_pipe(pipe_class_dummy);
10554 %}
10555 
10556 // Replicate scalar byte to packed byte values (8 Bytes).
10557 instruct Repl8B_immm1(iRegL dst, immB_minus1 src) %{
10558   match(Set dst (ReplicateB src));
10559   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10560   ins_should_rematerialize(true);
10561   format %{ &quot;REPLIC8B $dst,$src\t # pack8B immm1&quot; %}
10562   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10563   ins_pipe(pipe_class_dummy);
10564 %}
10565 
10566 // Exploit rotate_then_insert, if available
10567 // Replicate scalar short to packed short values (8 Bytes).
10568 instruct Repl4S_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10569   match(Set dst (ReplicateS src));
10570   effect(KILL cr);
10571   predicate((n-&gt;as_Vector()-&gt;length() == 4));
10572   format %{ &quot;REPLIC4S $dst,$src\t # pack4S&quot; %}
10573   ins_encode %{
10574     if ($dst$$Register != $src$$Register) {
10575       __ z_lgr($dst$$Register, $src$$Register);
10576     }
10577     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10578     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10579   %}
10580   ins_pipe(pipe_class_dummy);
10581 %}
10582 
10583 // Replicate scalar short to packed short values (8 Bytes).
10584 instruct Repl4S_imm(iRegL dst, immS_n0m1 src) %{
10585   match(Set dst (ReplicateS src));
10586   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10587   ins_should_rematerialize(true);
10588   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm&quot; %}
10589   ins_encode %{
10590     int64_t Isrc16 = $src$$constant &amp; 0x0000ffff;
10591     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10592     assert(Isrc16 != 0x0000ffff &amp;&amp; Isrc16 != 0, &quot;Repl4S_imm: (src == &quot; INT64_FORMAT
10593            &quot;) should be handled by other match rules.&quot;, $src$$constant);
10594 
10595     __ z_llilf($dst$$Register, Isrc32);
10596     __ z_iihf($dst$$Register, Isrc32);
10597   %}
10598   ins_pipe(pipe_class_dummy);
10599 %}
10600 
10601 // Replicate scalar short to packed short values (8 Bytes).
10602 instruct Repl4S_imm0(iRegL dst, immI_0 src) %{
10603   match(Set dst (ReplicateS src));
10604   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10605   ins_should_rematerialize(true);
10606   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm0&quot; %}
10607   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10608   ins_pipe(pipe_class_dummy);
10609 %}
10610 
10611 // Replicate scalar short to packed short values (8 Bytes).
10612 instruct Repl4S_immm1(iRegL dst, immS_minus1 src) %{
10613   match(Set dst (ReplicateS src));
10614   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10615   ins_should_rematerialize(true);
10616   format %{ &quot;REPLIC4S $dst,$src\t # pack4S immm1&quot; %}
10617   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10618   ins_pipe(pipe_class_dummy);
10619 %}
10620 
10621 // Exploit rotate_then_insert, if available.
10622 // Replicate scalar int to packed int values (8 Bytes).
10623 instruct Repl2I_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10624   match(Set dst (ReplicateI src));
10625   effect(KILL cr);
10626   predicate((n-&gt;as_Vector()-&gt;length() == 2));
10627   format %{ &quot;REPLIC2I $dst,$src\t # pack2I&quot; %}
10628   ins_encode %{
10629     if ($dst$$Register != $src$$Register) {
10630       __ z_lgr($dst$$Register, $src$$Register);
10631     }
10632     __ rotate_then_insert($dst$$Register, $dst$$Register, 0, 31, 32, false);
10633   %}
10634   ins_pipe(pipe_class_dummy);
10635 %}
10636 
10637 // Replicate scalar int to packed int values (8 Bytes).
10638 instruct Repl2I_imm(iRegL dst, immI_n0m1 src) %{
10639   match(Set dst (ReplicateI src));
10640   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10641   ins_should_rematerialize(true);
10642   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm&quot; %}
10643   ins_encode %{
10644     int64_t Isrc32 = $src$$constant;
10645     assert(Isrc32 != -1 &amp;&amp; Isrc32 != 0, &quot;should be handled by other match rules.&quot;);
10646 
10647     __ z_llilf($dst$$Register, Isrc32);
10648     __ z_iihf($dst$$Register, Isrc32);
10649   %}
10650   ins_pipe(pipe_class_dummy);
10651 %}
10652 
10653 // Replicate scalar int to packed int values (8 Bytes).
10654 instruct Repl2I_imm0(iRegL dst, immI_0 src) %{
10655   match(Set dst (ReplicateI src));
10656   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10657   ins_should_rematerialize(true);
10658   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm0&quot; %}
10659   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10660   ins_pipe(pipe_class_dummy);
10661 %}
10662 
10663 // Replicate scalar int to packed int values (8 Bytes).
10664 instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
10665   match(Set dst (ReplicateI src));
10666   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10667   ins_should_rematerialize(true);
10668   format %{ &quot;REPLIC2I $dst,$src\t # pack2I immm1&quot; %}
10669   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10670   ins_pipe(pipe_class_dummy);
10671 %}
10672 
10673 //
10674 
10675 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
10676   match(Set dst (ReplicateF src));
10677   effect(KILL cr);
10678   predicate(!VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10679   format %{ &quot;REPLIC2F $dst,$src\t # pack2F indirect&quot; %}
10680   expand %{
10681     stackSlotF tmp;
10682     iRegL      tmp2;
10683     expand_storeF(tmp, src);
10684     expand_LoadLogical_I2L(tmp2, tmp);
10685     expand_Repl2I_reg(dst, tmp2);
10686   %}
10687 %}
10688 
10689 // Replicate scalar float to packed float values in GREG (8 Bytes).
10690 instruct Repl2F_reg_direct(iRegL dst, regF src, flagsReg cr) %{
10691   match(Set dst (ReplicateF src));
10692   effect(KILL cr);
10693   predicate(VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10694   format %{ &quot;REPLIC2F $dst,$src\t # pack2F direct&quot; %}
10695   ins_encode %{
10696     assert(VM_Version::has_FPSupportEnhancements(), &quot;encoder should never be called on old H/W&quot;);
10697     __ z_lgdr($dst$$Register, $src$$FloatRegister);
10698 
10699     __ z_srlg(Z_R0_scratch, $dst$$Register, 32);  // Floats are left-justified in 64bit reg.
10700     __ z_iilf($dst$$Register, 0);                 // Save a &quot;result not ready&quot; stall.
10701     __ z_ogr($dst$$Register, Z_R0_scratch);
10702   %}
10703   ins_pipe(pipe_class_dummy);
10704 %}
10705 
10706 // Replicate scalar float immediate to packed float values in GREG (8 Bytes).
10707 instruct Repl2F_imm(iRegL dst, immF src) %{
10708   match(Set dst (ReplicateF src));
10709   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10710   ins_should_rematerialize(true);
10711   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm&quot; %}
10712   ins_encode %{
10713     union {
10714       int   Isrc32;
10715       float Fsrc32;
10716     };
10717     Fsrc32 = $src$$constant;
10718     __ z_llilf($dst$$Register, Isrc32);
10719     __ z_iihf($dst$$Register, Isrc32);
10720   %}
10721   ins_pipe(pipe_class_dummy);
10722 %}
10723 
10724 // Replicate scalar float immediate zeroes to packed float values in GREG (8 Bytes).
10725 // Do this only for &#39;real&#39; zeroes, especially don&#39;t loose sign of negative zeroes.
10726 instruct Repl2F_imm0(iRegL dst, immFp0 src) %{
10727   match(Set dst (ReplicateF src));
10728   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10729   ins_should_rematerialize(true);
10730   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm0&quot; %}
10731   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10732   ins_pipe(pipe_class_dummy);
10733 %}
10734 
10735 // Store
10736 
10737 // Store Aligned Packed Byte register to memory (8 Bytes).
10738 instruct storeA8B(memory mem, iRegL src) %{
10739   match(Set mem (StoreVector mem src));
10740   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10741   ins_cost(MEMORY_REF_COST);
10742   // TODO: s390 port size(VARIABLE_SIZE);
10743   format %{ &quot;STG     $src,$mem\t # ST(packed8B)&quot; %}
10744   opcode(STG_ZOPC, STG_ZOPC);
10745   ins_encode(z_form_rt_mem_opt(src, mem));
10746   ins_pipe(pipe_class_dummy);
10747 %}
10748 
10749 // Load
10750 
10751 instruct loadV8(iRegL dst, memory mem) %{
10752   match(Set dst (LoadVector mem));
10753   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10754   ins_cost(MEMORY_REF_COST);
10755   // TODO: s390 port size(VARIABLE_SIZE);
10756   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10757   opcode(LG_ZOPC, LG_ZOPC);
10758   ins_encode(z_form_rt_mem_opt(dst, mem));
10759   ins_pipe(pipe_class_dummy);
10760 %}
10761 
10762 //----------POPULATION COUNT RULES--------------------------------------------
10763 
10764 // Byte reverse
10765 
10766 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10767   match(Set dst (ReverseBytesI src));
10768   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10769   ins_cost(DEFAULT_COST);
10770   size(4);
10771   format %{ &quot;LRVR    $dst,$src\t# byte reverse int&quot; %}
10772   opcode(LRVR_ZOPC);
10773   ins_encode(z_rreform(dst, src));
10774   ins_pipe(pipe_class_dummy);
10775 %}
10776 
10777 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10778   match(Set dst (ReverseBytesL src));
10779   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10780   ins_cost(DEFAULT_COST);
10781   // TODO: s390 port size(FIXED_SIZE);
10782   format %{ &quot;LRVGR   $dst,$src\t# byte reverse long&quot; %}
10783   opcode(LRVGR_ZOPC);
10784   ins_encode(z_rreform(dst, src));
10785   ins_pipe(pipe_class_dummy);
10786 %}
10787 
10788 // Leading zeroes
10789 
10790 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10791 // returns the bit position of the leftmost 1 in the 64bit source register.
10792 // As the bits are numbered from left to right (0..63), the returned
10793 // position index is equivalent to the number of leading zeroes.
10794 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10795 // returns position 64. That&#39;s exactly what we need.
10796 
10797 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10798   match(Set dst (CountLeadingZerosI src));
10799   effect(KILL tmp, KILL cr);
10800   ins_cost(3 * DEFAULT_COST);
10801   size(14);
10802   format %{ &quot;SLLG    $dst,$src,32\t# no need to always count 32 zeroes first\n\t&quot;
10803             &quot;IILH    $dst,0x8000 \t# insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;
10804             &quot;FLOGR   $dst,$dst&quot;
10805          %}
10806   ins_encode %{
10807     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10808     // iteration to find the leftmost &quot;1&quot; bit.
10809     //
10810     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10811     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10812     // We could gain measurable speedup in micro benchmark:
10813     //
10814     //               leading   trailing
10815     //   z10:   int     2.04       1.68
10816     //         long     1.00       1.02
10817     //   z196:  int     0.99       1.23
10818     //         long     1.00       1.11
10819     //
10820     // By shifting the argument into the high-word instead of zero-extending it.
10821     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10822     // good prediction) is well compensated for by the savings.
10823     //
10824     // We leave the previous implementation in for some time in the future when
10825     // the &quot;FLOGR&quot; instruction may become less iterative.
10826 
10827     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10828     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10829     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10830     __ z_flogr($dst$$Register, $dst$$Register);
10831   %}
10832   ins_pipe(pipe_class_dummy);
10833 %}
10834 
10835 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10836   match(Set dst (CountLeadingZerosL src));
10837   effect(KILL tmp, KILL cr);
10838   ins_cost(DEFAULT_COST);
10839   size(4);
10840   format %{ &quot;FLOGR   $dst,$src \t# count leading zeros (long)\n\t&quot; %}
10841   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10842   ins_pipe(pipe_class_dummy);
10843 %}
10844 
10845 // trailing zeroes
10846 
10847 // We transform the trailing zeroes problem to a leading zeroes problem
10848 // such that can use the FLOGR instruction to our advantage.
10849 
10850 // With
10851 //   tmp1 = src - 1
10852 // we flip all trailing zeroes to ones and the rightmost one to zero.
10853 // All other bits remain unchanged.
10854 // With the complement
10855 //   tmp2 = ~src
10856 // we get all ones in the trailing zeroes positions. Thus,
10857 //   tmp3 = tmp1 &amp; tmp2
10858 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10859 // Now we can apply FLOGR and get 64-(trailing zeroes).
10860 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10861   match(Set dst (CountTrailingZerosI src));
10862   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10863   ins_cost(8 * DEFAULT_COST);
10864   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10865   format %{ &quot;LLGFR   $dst,$src  \t# clear upper 32 bits (we are dealing with int)\n\t&quot;
10866             &quot;LCGFR   $tmp,$src  \t# load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;
10867             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;
10868             &quot;AGHI    $tmp,-1    \t# tmp2 = -src-1 = ~src\n\t&quot;
10869             &quot;NGR     $dst,$tmp  \t# tmp3 = tmp1&amp;tmp2\n\t&quot;
10870             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (int)\n\t&quot;
10871             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10872             &quot;LCR     $dst,$dst  \t# res = -tmp4&quot;
10873          %}
10874   ins_encode %{
10875     Register Rdst = $dst$$Register;
10876     Register Rsrc = $src$$Register;
10877     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10878     // match rule Rsrc = roddReg would be possible, saving one register.
10879     Register Rtmp = $tmp$$Register;
10880 
10881     assert_different_registers(Rdst, Rsrc, Rtmp);
10882 
10883     // Algorithm:
10884     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10885     //   All other bits in the result are zero.
10886     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10887     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10888 
10889     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10890     Label done;
10891     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10892     __ z_lcgfr(Rtmp, Rsrc);
10893     __ z_bre(done);                    // Taken very infrequently, good prediction, no BHT entry.
10894 
10895     __ z_nr(Rtmp, Rsrc);               // (src) &amp; (-src) leaves nothing but least significant bit.
10896     __ z_ahi(Rtmp,  -1);               // Subtract one to fill all trailing zero positions with ones.
10897                                        // Use 32bit op to prevent borrow propagation (case Rdst = 0x80000000)
10898                                        // into upper half of reg. Not relevant with sllg below.
10899     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10900     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10901                                        // Depends on CC set by ahi above.
10902                                        // Taken very infrequently, good prediction, no BHT entry.
10903                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10904                                        // after SLLG Rdst == 0(64bit)).
10905     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10906     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10907     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10908     __ bind(done);
10909   %}
10910   ins_pipe(pipe_class_dummy);
10911 %}
10912 
10913 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10914   match(Set dst (CountTrailingZerosL src));
10915   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10916   ins_cost(8 * DEFAULT_COST);
10917   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10918   format %{ &quot;LCGR    $dst,$src  \t# preserve src\n\t&quot;
10919             &quot;NGR     $dst,$src  \t#&quot;
10920             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;
10921             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (long), kill $tmp\n\t&quot;
10922             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10923             &quot;LCR     $dst,$dst  \t#&quot;
10924          %}
10925   ins_encode %{
10926     Register Rdst = $dst$$Register;
10927     Register Rsrc = $src$$Register;
10928     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
10929 
10930     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
10931     __ z_lcgr(Rdst, Rsrc);
10932     __ z_ngr(Rdst, Rsrc);
10933     __ add2reg(Rdst,   -1);
10934     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
10935     __ add2reg(Rdst,  -64);
10936     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
10937   %}
10938   ins_pipe(pipe_class_dummy);
10939 %}
10940 
10941 
10942 // bit count
10943 
10944 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
10945   match(Set dst (PopCountI src));
10946   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10947   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
10948   ins_cost(DEFAULT_COST);
10949   size(24);
10950   format %{ &quot;POPCNT  $dst,$src\t# pop count int&quot; %}
10951   ins_encode %{
10952     Register Rdst = $dst$$Register;
10953     Register Rsrc = $src$$Register;
10954     Register Rtmp = $tmp$$Register;
10955 
10956     // Prefer compile-time assertion over run-time SIGILL.
10957     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
10958     assert_different_registers(Rdst, Rtmp);
10959 
10960     // Version 2: shows 10%(z196) improvement over original.
10961     __ z_popcnt(Rdst, Rsrc);
10962     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
10963     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
10964     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
10965     __ z_alr(Rdst, Rtmp);      //   into byte7
10966     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
10967   %}
10968   ins_pipe(pipe_class_dummy);
10969 %}
10970 
10971 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
10972   match(Set dst (PopCountL src));
10973   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10974   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
10975   ins_cost(DEFAULT_COST);
10976   // TODO: s390 port size(FIXED_SIZE);
10977   format %{ &quot;POPCNT  $dst,$src\t# pop count long&quot; %}
10978   ins_encode %{
10979     Register Rdst = $dst$$Register;
10980     Register Rsrc = $src$$Register;
10981     Register Rtmp = $tmp$$Register;
10982 
10983     // Prefer compile-time assertion over run-time SIGILL.
10984     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
10985     assert_different_registers(Rdst, Rtmp);
10986 
10987     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
10988     __ z_popcnt(Rdst, Rsrc);
10989     __ z_ahhlr(Rdst, Rdst, Rdst);
10990     __ z_sllg(Rtmp, Rdst, 16);
10991     __ z_algr(Rdst, Rtmp);
10992     __ z_sllg(Rtmp, Rdst,  8);
10993     __ z_algr(Rdst, Rtmp);
10994     __ z_srlg(Rdst, Rdst, 56);
10995   %}
10996   ins_pipe(pipe_class_dummy);
10997 %}
10998 
10999 //----------SMARTSPILL RULES---------------------------------------------------
11000 // These must follow all instruction definitions as they use the names
11001 // defined in the instructions definitions.
11002 
11003 // ============================================================================
11004 // TYPE PROFILING RULES
11005 
    </pre>
  </body>
</html>