<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/c1_FrameMap_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_FrameMap.hpp&quot;
 28 #include &quot;c1/c1_LIR.hpp&quot;
 29 #include &quot;runtime/sharedRuntime.hpp&quot;
 30 #include &quot;vmreg_ppc.inline.hpp&quot;
 31 
 32 
 33 const int FrameMap::pd_c_runtime_reserved_arg_size = 7;
 34 
 35 
 36 LIR_Opr FrameMap::map_to_opr(BasicType type, VMRegPair* reg, bool outgoing) {
 37   LIR_Opr opr = LIR_OprFact::illegalOpr;
 38   VMReg r_1 = reg-&gt;first();
 39   VMReg r_2 = reg-&gt;second();
 40   if (r_1-&gt;is_stack()) {
 41     // Convert stack slot to an SP offset.
 42     // The calling convention does not count the SharedRuntime::out_preserve_stack_slots() value
 43     // so we must add it in here.
 44     int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 45     opr = LIR_OprFact::address(new LIR_Address(SP_opr, st_off + STACK_BIAS, type));
 46   } else if (r_1-&gt;is_Register()) {
 47     Register reg = r_1-&gt;as_Register();
 48     //if (outgoing) {
 49     //  assert(!reg-&gt;is_in(), &quot;should be using I regs&quot;);
 50     //} else {
 51     //  assert(!reg-&gt;is_out(), &quot;should be using O regs&quot;);
 52     //}
 53     if (r_2-&gt;is_Register() &amp;&amp; (type == T_LONG || type == T_DOUBLE)) {
 54       opr = as_long_opr(reg);
 55     } else if (type == T_OBJECT || type == T_ARRAY) {
 56       opr = as_oop_opr(reg);
 57     } else {
 58       opr = as_opr(reg);
 59     }
 60   } else if (r_1-&gt;is_FloatRegister()) {
 61     assert(type == T_DOUBLE || type == T_FLOAT, &quot;wrong type&quot;);
 62     FloatRegister f = r_1-&gt;as_FloatRegister();
 63     if (type == T_DOUBLE) {
 64       opr = as_double_opr(f);
 65     } else {
 66       opr = as_float_opr(f);
 67     }
 68   }
 69   return opr;
 70 }
 71 
 72 //               FrameMap
 73 //--------------------------------------------------------
 74 
 75 FloatRegister FrameMap::_fpu_regs [FrameMap::nof_fpu_regs];
 76 
 77 LIR_Opr  FrameMap::R0_opr;
 78 LIR_Opr  FrameMap::R1_opr;
 79 LIR_Opr  FrameMap::R2_opr;
 80 LIR_Opr  FrameMap::R3_opr;
 81 LIR_Opr  FrameMap::R4_opr;
 82 LIR_Opr  FrameMap::R5_opr;
 83 LIR_Opr  FrameMap::R6_opr;
 84 LIR_Opr  FrameMap::R7_opr;
 85 LIR_Opr  FrameMap::R8_opr;
 86 LIR_Opr  FrameMap::R9_opr;
 87 LIR_Opr FrameMap::R10_opr;
 88 LIR_Opr FrameMap::R11_opr;
 89 LIR_Opr FrameMap::R12_opr;
 90 LIR_Opr FrameMap::R13_opr;
 91 LIR_Opr FrameMap::R14_opr;
 92 LIR_Opr FrameMap::R15_opr;
 93 LIR_Opr FrameMap::R16_opr;
 94 LIR_Opr FrameMap::R17_opr;
 95 LIR_Opr FrameMap::R18_opr;
 96 LIR_Opr FrameMap::R19_opr;
 97 LIR_Opr FrameMap::R20_opr;
 98 LIR_Opr FrameMap::R21_opr;
 99 LIR_Opr FrameMap::R22_opr;
100 LIR_Opr FrameMap::R23_opr;
101 LIR_Opr FrameMap::R24_opr;
102 LIR_Opr FrameMap::R25_opr;
103 LIR_Opr FrameMap::R26_opr;
104 LIR_Opr FrameMap::R27_opr;
105 LIR_Opr FrameMap::R28_opr;
106 LIR_Opr FrameMap::R29_opr;
107 LIR_Opr FrameMap::R30_opr;
108 LIR_Opr FrameMap::R31_opr;
109 
110 LIR_Opr  FrameMap::R0_oop_opr;
111 //LIR_Opr  FrameMap::R1_oop_opr;
112 LIR_Opr  FrameMap::R2_oop_opr;
113 LIR_Opr  FrameMap::R3_oop_opr;
114 LIR_Opr  FrameMap::R4_oop_opr;
115 LIR_Opr  FrameMap::R5_oop_opr;
116 LIR_Opr  FrameMap::R6_oop_opr;
117 LIR_Opr  FrameMap::R7_oop_opr;
118 LIR_Opr  FrameMap::R8_oop_opr;
119 LIR_Opr  FrameMap::R9_oop_opr;
120 LIR_Opr FrameMap::R10_oop_opr;
121 LIR_Opr FrameMap::R11_oop_opr;
122 LIR_Opr FrameMap::R12_oop_opr;
123 //LIR_Opr FrameMap::R13_oop_opr;
124 LIR_Opr FrameMap::R14_oop_opr;
125 LIR_Opr FrameMap::R15_oop_opr;
126 //LIR_Opr FrameMap::R16_oop_opr;
127 LIR_Opr FrameMap::R17_oop_opr;
128 LIR_Opr FrameMap::R18_oop_opr;
129 LIR_Opr FrameMap::R19_oop_opr;
130 LIR_Opr FrameMap::R20_oop_opr;
131 LIR_Opr FrameMap::R21_oop_opr;
132 LIR_Opr FrameMap::R22_oop_opr;
133 LIR_Opr FrameMap::R23_oop_opr;
134 LIR_Opr FrameMap::R24_oop_opr;
135 LIR_Opr FrameMap::R25_oop_opr;
136 LIR_Opr FrameMap::R26_oop_opr;
137 LIR_Opr FrameMap::R27_oop_opr;
138 LIR_Opr FrameMap::R28_oop_opr;
139 //LIR_Opr FrameMap::R29_oop_opr;
140 LIR_Opr FrameMap::R30_oop_opr;
141 LIR_Opr FrameMap::R31_oop_opr;
142 
143 LIR_Opr  FrameMap::R0_metadata_opr;
144 //LIR_Opr  FrameMap::R1_metadata_opr;
145 LIR_Opr  FrameMap::R2_metadata_opr;
146 LIR_Opr  FrameMap::R3_metadata_opr;
147 LIR_Opr  FrameMap::R4_metadata_opr;
148 LIR_Opr  FrameMap::R5_metadata_opr;
149 LIR_Opr  FrameMap::R6_metadata_opr;
150 LIR_Opr  FrameMap::R7_metadata_opr;
151 LIR_Opr  FrameMap::R8_metadata_opr;
152 LIR_Opr  FrameMap::R9_metadata_opr;
153 LIR_Opr FrameMap::R10_metadata_opr;
154 LIR_Opr FrameMap::R11_metadata_opr;
155 LIR_Opr FrameMap::R12_metadata_opr;
156 //LIR_Opr FrameMap::R13_metadata_opr;
157 LIR_Opr FrameMap::R14_metadata_opr;
158 LIR_Opr FrameMap::R15_metadata_opr;
159 //LIR_Opr FrameMap::R16_metadata_opr;
160 LIR_Opr FrameMap::R17_metadata_opr;
161 LIR_Opr FrameMap::R18_metadata_opr;
162 LIR_Opr FrameMap::R19_metadata_opr;
163 LIR_Opr FrameMap::R20_metadata_opr;
164 LIR_Opr FrameMap::R21_metadata_opr;
165 LIR_Opr FrameMap::R22_metadata_opr;
166 LIR_Opr FrameMap::R23_metadata_opr;
167 LIR_Opr FrameMap::R24_metadata_opr;
168 LIR_Opr FrameMap::R25_metadata_opr;
169 LIR_Opr FrameMap::R26_metadata_opr;
170 LIR_Opr FrameMap::R27_metadata_opr;
171 LIR_Opr FrameMap::R28_metadata_opr;
172 //LIR_Opr FrameMap::R29_metadata_opr;
173 LIR_Opr FrameMap::R30_metadata_opr;
174 LIR_Opr FrameMap::R31_metadata_opr;
175 
176 LIR_Opr FrameMap::SP_opr;
177 
178 LIR_Opr FrameMap::R0_long_opr;
179 LIR_Opr FrameMap::R3_long_opr;
180 
181 LIR_Opr FrameMap::F1_opr;
182 LIR_Opr FrameMap::F1_double_opr;
183 
184 LIR_Opr FrameMap::_caller_save_cpu_regs[] = { 0, };
185 LIR_Opr FrameMap::_caller_save_fpu_regs[] = { 0, };
186 
187 FloatRegister FrameMap::nr2floatreg (int rnr) {
188   assert(_init_done, &quot;tables not initialized&quot;);
189   debug_only(fpu_range_check(rnr);)
190   return _fpu_regs[rnr];
191 }
192 
193 
194 // Returns true if reg could be smashed by a callee.
195 bool FrameMap::is_caller_save_register (LIR_Opr reg) {
196   if (reg-&gt;is_single_fpu() || reg-&gt;is_double_fpu()) { return true; }
197   if (reg-&gt;is_double_cpu()) {
198     return is_caller_save_register(reg-&gt;as_register_lo()) ||
199            is_caller_save_register(reg-&gt;as_register_hi());
200   }
201   return is_caller_save_register(reg-&gt;as_register());
202 }
203 
204 
205 bool FrameMap::is_caller_save_register (Register r) {
206   // not visible to allocator: R0: scratch, R1: SP
207   // r-&gt;encoding() &lt; 2 + nof_caller_save_cpu_regs();
208   return true; // Currently all regs are caller save.
209 }
210 
211 
212 void FrameMap::initialize() {
213   assert(!_init_done, &quot;once&quot;);
214 
215   int i = 0;
216 
217   // Put generally available registers at the beginning (allocated, saved for GC).
218   for (int j = 0; j &lt; nof_cpu_regs; ++j) {
219     Register rj = as_Register(j);
220     if (reg_needs_save(rj)) {
221       map_register(i++, rj);
222     }
223   }
224   assert(i == nof_cpu_regs_reg_alloc, &quot;number of allocated registers&quot;);
225 
226   // The following registers are not normally available.
227   for (int j = 0; j &lt; nof_cpu_regs; ++j) {
228     Register rj = as_Register(j);
229     if (!reg_needs_save(rj)) {
230       map_register(i++, rj);
231     }
232   }
233   assert(i == nof_cpu_regs, &quot;number of CPU registers&quot;);
234 
235   for (i = 0; i &lt; nof_fpu_regs; i++) {
236     _fpu_regs[i] = as_FloatRegister(i);
237   }
238 
239   _init_done = true;
240 
241   R0_opr  = as_opr(R0);
242   R1_opr  = as_opr(R1);
243   R2_opr  = as_opr(R2);
244   R3_opr  = as_opr(R3);
245   R4_opr  = as_opr(R4);
246   R5_opr  = as_opr(R5);
247   R6_opr  = as_opr(R6);
248   R7_opr  = as_opr(R7);
249   R8_opr  = as_opr(R8);
250   R9_opr  = as_opr(R9);
251   R10_opr = as_opr(R10);
252   R11_opr = as_opr(R11);
253   R12_opr = as_opr(R12);
254   R13_opr = as_opr(R13);
255   R14_opr = as_opr(R14);
256   R15_opr = as_opr(R15);
257   R16_opr = as_opr(R16);
258   R17_opr = as_opr(R17);
259   R18_opr = as_opr(R18);
260   R19_opr = as_opr(R19);
261   R20_opr = as_opr(R20);
262   R21_opr = as_opr(R21);
263   R22_opr = as_opr(R22);
264   R23_opr = as_opr(R23);
265   R24_opr = as_opr(R24);
266   R25_opr = as_opr(R25);
267   R26_opr = as_opr(R26);
268   R27_opr = as_opr(R27);
269   R28_opr = as_opr(R28);
270   R29_opr = as_opr(R29);
271   R30_opr = as_opr(R30);
272   R31_opr = as_opr(R31);
273 
274   R0_oop_opr  = as_oop_opr(R0);
275   //R1_oop_opr  = as_oop_opr(R1);
276   R2_oop_opr  = as_oop_opr(R2);
277   R3_oop_opr  = as_oop_opr(R3);
278   R4_oop_opr  = as_oop_opr(R4);
279   R5_oop_opr  = as_oop_opr(R5);
280   R6_oop_opr  = as_oop_opr(R6);
281   R7_oop_opr  = as_oop_opr(R7);
282   R8_oop_opr  = as_oop_opr(R8);
283   R9_oop_opr  = as_oop_opr(R9);
284   R10_oop_opr = as_oop_opr(R10);
285   R11_oop_opr = as_oop_opr(R11);
286   R12_oop_opr = as_oop_opr(R12);
287   //R13_oop_opr = as_oop_opr(R13);
288   R14_oop_opr = as_oop_opr(R14);
289   R15_oop_opr = as_oop_opr(R15);
290   //R16_oop_opr = as_oop_opr(R16);
291   R17_oop_opr = as_oop_opr(R17);
292   R18_oop_opr = as_oop_opr(R18);
293   R19_oop_opr = as_oop_opr(R19);
294   R20_oop_opr = as_oop_opr(R20);
295   R21_oop_opr = as_oop_opr(R21);
296   R22_oop_opr = as_oop_opr(R22);
297   R23_oop_opr = as_oop_opr(R23);
298   R24_oop_opr = as_oop_opr(R24);
299   R25_oop_opr = as_oop_opr(R25);
300   R26_oop_opr = as_oop_opr(R26);
301   R27_oop_opr = as_oop_opr(R27);
302   R28_oop_opr = as_oop_opr(R28);
303   //R29_oop_opr = as_oop_opr(R29);
304   R30_oop_opr = as_oop_opr(R30);
305   R31_oop_opr = as_oop_opr(R31);
306 
307   R0_metadata_opr  = as_metadata_opr(R0);
308   //R1_metadata_opr  = as_metadata_opr(R1);
309   R2_metadata_opr  = as_metadata_opr(R2);
310   R3_metadata_opr  = as_metadata_opr(R3);
311   R4_metadata_opr  = as_metadata_opr(R4);
312   R5_metadata_opr  = as_metadata_opr(R5);
313   R6_metadata_opr  = as_metadata_opr(R6);
314   R7_metadata_opr  = as_metadata_opr(R7);
315   R8_metadata_opr  = as_metadata_opr(R8);
316   R9_metadata_opr  = as_metadata_opr(R9);
317   R10_metadata_opr = as_metadata_opr(R10);
318   R11_metadata_opr = as_metadata_opr(R11);
319   R12_metadata_opr = as_metadata_opr(R12);
320   //R13_metadata_opr = as_metadata_opr(R13);
321   R14_metadata_opr = as_metadata_opr(R14);
322   R15_metadata_opr = as_metadata_opr(R15);
323   //R16_metadata_opr = as_metadata_opr(R16);
324   R17_metadata_opr = as_metadata_opr(R17);
325   R18_metadata_opr = as_metadata_opr(R18);
326   R19_metadata_opr = as_metadata_opr(R19);
327   R20_metadata_opr = as_metadata_opr(R20);
328   R21_metadata_opr = as_metadata_opr(R21);
329   R22_metadata_opr = as_metadata_opr(R22);
330   R23_metadata_opr = as_metadata_opr(R23);
331   R24_metadata_opr = as_metadata_opr(R24);
332   R25_metadata_opr = as_metadata_opr(R25);
333   R26_metadata_opr = as_metadata_opr(R26);
334   R27_metadata_opr = as_metadata_opr(R27);
335   R28_metadata_opr = as_metadata_opr(R28);
336   //R29_metadata_opr = as_metadata_opr(R29);
337   R30_metadata_opr = as_metadata_opr(R30);
338   R31_metadata_opr = as_metadata_opr(R31);
339 
340   SP_opr = as_pointer_opr(R1_SP);
341 
342   R0_long_opr = LIR_OprFact::double_cpu(cpu_reg2rnr(R0), cpu_reg2rnr(R0));
343   R3_long_opr = LIR_OprFact::double_cpu(cpu_reg2rnr(R3), cpu_reg2rnr(R3));
344 
345   F1_opr = as_float_opr(F1);
346   F1_double_opr = as_double_opr(F1);
347 
348   // All the allocated cpu regs are caller saved.
349   for (int i = 0; i &lt; max_nof_caller_save_cpu_regs; i++) {
350     _caller_save_cpu_regs[i] = LIR_OprFact::single_cpu(i);
351   }
352 
353   // All the fpu regs are caller saved.
354   for (int i = 0; i &lt; nof_caller_save_fpu_regs; i++) {
355     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
356   }
357 }
358 
359 
360 Address FrameMap::make_new_address(ByteSize sp_offset) const {
361   return Address(R1_SP, STACK_BIAS + in_bytes(sp_offset));
362 }
363 
364 
365 VMReg FrameMap::fpu_regname (int n) {
366   return as_FloatRegister(n)-&gt;as_VMReg();
367 }
368 
369 
370 LIR_Opr FrameMap::stack_pointer() {
371   return SP_opr;
372 }
373 
374 
375 // JSR 292
376 // On PPC64, there is no need to save the SP, because neither
377 // method handle intrinsics, nor compiled lambda forms modify it.
378 LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {
379   return LIR_OprFact::illegalOpr;
380 }
381 
382 
383 bool FrameMap::validate_frame() {
384   int max_offset = in_bytes(framesize_in_bytes());
385   int java_index = 0;
386   for (int i = 0; i &lt; _incoming_arguments-&gt;length(); i++) {
387     LIR_Opr opr = _incoming_arguments-&gt;at(i);
388     if (opr-&gt;is_stack()) {
389       max_offset = MAX2(_argument_locations-&gt;at(java_index), max_offset);
390     }
391     java_index += type2size[opr-&gt;type()];
392   }
393   return Assembler::is_simm16(max_offset + STACK_BIAS);
394 }
    </pre>
  </body>
</html>