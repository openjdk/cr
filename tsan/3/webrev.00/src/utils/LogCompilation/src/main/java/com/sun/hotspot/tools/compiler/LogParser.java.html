<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/utils/LogCompilation/src/main/java/com/sun/hotspot/tools/compiler/LogParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 /**
  26  * A SAX based parser of LogCompilation output from HotSpot.  It takes a complete
  27  */
  28 
  29 package com.sun.hotspot.tools.compiler;
  30 
  31 import java.io.FileReader;
  32 import java.io.PrintStream;
  33 import java.io.Reader;
  34 import java.util.ArrayDeque;
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.Deque;
  38 import java.util.HashMap;
  39 import java.util.LinkedHashMap;
  40 import java.util.regex.Pattern;
  41 
  42 import javax.xml.parsers.SAXParser;
  43 import javax.xml.parsers.SAXParserFactory;
  44 
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ErrorHandler;
  47 import org.xml.sax.InputSource;
  48 import org.xml.sax.Locator;
  49 import org.xml.sax.helpers.DefaultHandler;
  50 
  51 /**
  52  * A SAX parser for HotSpot compilation logs. The bulk of the parsing and event
  53  * maintenance work is done in the {@link #startElement(String,String,String,Attributes)}
  54  * and {@link #endElement(String,String,String)} methods.
  55  */
  56 public class LogParser extends DefaultHandler implements ErrorHandler {
  57 
  58     static final Pattern spacePattern = Pattern.compile(&quot; &quot;);
  59 
  60     /**
  61      * Map internal array type descriptors to Java names.
  62      */
  63     static final HashMap&lt;String, String&gt; type2printableMap;
  64 
  65     /**
  66      * Map Java primitive type names to internal type descriptors.
  67      */
  68     static final HashMap&lt;String, String&gt; type2vmtypeMap;
  69 
  70     static {
  71         type2printableMap = new HashMap&lt;&gt;();
  72         type2printableMap.put(&quot;[I&quot;, &quot;int[]&quot;);
  73         type2printableMap.put(&quot;[C&quot;, &quot;char[]&quot;);
  74         type2printableMap.put(&quot;[Z&quot;, &quot;boolean[]&quot;);
  75         type2printableMap.put(&quot;[L&quot;, &quot;Object[]&quot;);
  76         type2printableMap.put(&quot;[B&quot;, &quot;byte[]&quot;);
  77 
  78         type2vmtypeMap = new HashMap&lt;&gt;();
  79         type2vmtypeMap.put(&quot;void&quot;, &quot;V&quot;);
  80         type2vmtypeMap.put(&quot;boolean&quot;, &quot;Z&quot;);
  81         type2vmtypeMap.put(&quot;byte&quot;, &quot;B&quot;);
  82         type2vmtypeMap.put(&quot;char&quot;, &quot;C&quot;);
  83         type2vmtypeMap.put(&quot;short&quot;, &quot;S&quot;);
  84         type2vmtypeMap.put(&quot;int&quot;, &quot;I&quot;);
  85         type2vmtypeMap.put(&quot;long&quot;, &quot;J&quot;);
  86         type2vmtypeMap.put(&quot;float&quot;, &quot;F&quot;);
  87         type2vmtypeMap.put(&quot;double&quot;, &quot;D&quot;);
  88     }
  89 
  90     static String[] bytecodes = new String[] {
  91         &quot;nop&quot;,
  92         &quot;aconst_null&quot;,
  93         &quot;iconst_m1&quot;,
  94         &quot;iconst_0&quot;,
  95         &quot;iconst_1&quot;,
  96         &quot;iconst_2&quot;,
  97         &quot;iconst_3&quot;,
  98         &quot;iconst_4&quot;,
  99         &quot;iconst_5&quot;,
 100         &quot;lconst_0&quot;,
 101         &quot;lconst_1&quot;,
 102         &quot;fconst_0&quot;,
 103         &quot;fconst_1&quot;,
 104         &quot;fconst_2&quot;,
 105         &quot;dconst_0&quot;,
 106         &quot;dconst_1&quot;,
 107         &quot;bipush&quot;,
 108         &quot;sipush&quot;,
 109         &quot;ldc&quot;,
 110         &quot;ldc_w&quot;,
 111         &quot;ldc2_w&quot;,
 112         &quot;iload&quot;,
 113         &quot;lload&quot;,
 114         &quot;fload&quot;,
 115         &quot;dload&quot;,
 116         &quot;aload&quot;,
 117         &quot;iload_0&quot;,
 118         &quot;iload_1&quot;,
 119         &quot;iload_2&quot;,
 120         &quot;iload_3&quot;,
 121         &quot;lload_0&quot;,
 122         &quot;lload_1&quot;,
 123         &quot;lload_2&quot;,
 124         &quot;lload_3&quot;,
 125         &quot;fload_0&quot;,
 126         &quot;fload_1&quot;,
 127         &quot;fload_2&quot;,
 128         &quot;fload_3&quot;,
 129         &quot;dload_0&quot;,
 130         &quot;dload_1&quot;,
 131         &quot;dload_2&quot;,
 132         &quot;dload_3&quot;,
 133         &quot;aload_0&quot;,
 134         &quot;aload_1&quot;,
 135         &quot;aload_2&quot;,
 136         &quot;aload_3&quot;,
 137         &quot;iaload&quot;,
 138         &quot;laload&quot;,
 139         &quot;faload&quot;,
 140         &quot;daload&quot;,
 141         &quot;aaload&quot;,
 142         &quot;baload&quot;,
 143         &quot;caload&quot;,
 144         &quot;saload&quot;,
 145         &quot;istore&quot;,
 146         &quot;lstore&quot;,
 147         &quot;fstore&quot;,
 148         &quot;dstore&quot;,
 149         &quot;astore&quot;,
 150         &quot;istore_0&quot;,
 151         &quot;istore_1&quot;,
 152         &quot;istore_2&quot;,
 153         &quot;istore_3&quot;,
 154         &quot;lstore_0&quot;,
 155         &quot;lstore_1&quot;,
 156         &quot;lstore_2&quot;,
 157         &quot;lstore_3&quot;,
 158         &quot;fstore_0&quot;,
 159         &quot;fstore_1&quot;,
 160         &quot;fstore_2&quot;,
 161         &quot;fstore_3&quot;,
 162         &quot;dstore_0&quot;,
 163         &quot;dstore_1&quot;,
 164         &quot;dstore_2&quot;,
 165         &quot;dstore_3&quot;,
 166         &quot;astore_0&quot;,
 167         &quot;astore_1&quot;,
 168         &quot;astore_2&quot;,
 169         &quot;astore_3&quot;,
 170         &quot;iastore&quot;,
 171         &quot;lastore&quot;,
 172         &quot;fastore&quot;,
 173         &quot;dastore&quot;,
 174         &quot;aastore&quot;,
 175         &quot;bastore&quot;,
 176         &quot;castore&quot;,
 177         &quot;sastore&quot;,
 178         &quot;pop&quot;,
 179         &quot;pop2&quot;,
 180         &quot;dup&quot;,
 181         &quot;dup_x1&quot;,
 182         &quot;dup_x2&quot;,
 183         &quot;dup2&quot;,
 184         &quot;dup2_x1&quot;,
 185         &quot;dup2_x2&quot;,
 186         &quot;swap&quot;,
 187         &quot;iadd&quot;,
 188         &quot;ladd&quot;,
 189         &quot;fadd&quot;,
 190         &quot;dadd&quot;,
 191         &quot;isub&quot;,
 192         &quot;lsub&quot;,
 193         &quot;fsub&quot;,
 194         &quot;dsub&quot;,
 195         &quot;imul&quot;,
 196         &quot;lmul&quot;,
 197         &quot;fmul&quot;,
 198         &quot;dmul&quot;,
 199         &quot;idiv&quot;,
 200         &quot;ldiv&quot;,
 201         &quot;fdiv&quot;,
 202         &quot;ddiv&quot;,
 203         &quot;irem&quot;,
 204         &quot;lrem&quot;,
 205         &quot;frem&quot;,
 206         &quot;drem&quot;,
 207         &quot;ineg&quot;,
 208         &quot;lneg&quot;,
 209         &quot;fneg&quot;,
 210         &quot;dneg&quot;,
 211         &quot;ishl&quot;,
 212         &quot;lshl&quot;,
 213         &quot;ishr&quot;,
 214         &quot;lshr&quot;,
 215         &quot;iushr&quot;,
 216         &quot;lushr&quot;,
 217         &quot;iand&quot;,
 218         &quot;land&quot;,
 219         &quot;ior&quot;,
 220         &quot;lor&quot;,
 221         &quot;ixor&quot;,
 222         &quot;lxor&quot;,
 223         &quot;iinc&quot;,
 224         &quot;i2l&quot;,
 225         &quot;i2f&quot;,
 226         &quot;i2d&quot;,
 227         &quot;l2i&quot;,
 228         &quot;l2f&quot;,
 229         &quot;l2d&quot;,
 230         &quot;f2i&quot;,
 231         &quot;f2l&quot;,
 232         &quot;f2d&quot;,
 233         &quot;d2i&quot;,
 234         &quot;d2l&quot;,
 235         &quot;d2f&quot;,
 236         &quot;i2b&quot;,
 237         &quot;i2c&quot;,
 238         &quot;i2s&quot;,
 239         &quot;lcmp&quot;,
 240         &quot;fcmpl&quot;,
 241         &quot;fcmpg&quot;,
 242         &quot;dcmpl&quot;,
 243         &quot;dcmpg&quot;,
 244         &quot;ifeq&quot;,
 245         &quot;ifne&quot;,
 246         &quot;iflt&quot;,
 247         &quot;ifge&quot;,
 248         &quot;ifgt&quot;,
 249         &quot;ifle&quot;,
 250         &quot;if_icmpeq&quot;,
 251         &quot;if_icmpne&quot;,
 252         &quot;if_icmplt&quot;,
 253         &quot;if_icmpge&quot;,
 254         &quot;if_icmpgt&quot;,
 255         &quot;if_icmple&quot;,
 256         &quot;if_acmpeq&quot;,
 257         &quot;if_acmpne&quot;,
 258         &quot;goto&quot;,
 259         &quot;jsr&quot;,
 260         &quot;ret&quot;,
 261         &quot;tableswitch&quot;,
 262         &quot;lookupswitch&quot;,
 263         &quot;ireturn&quot;,
 264         &quot;lreturn&quot;,
 265         &quot;freturn&quot;,
 266         &quot;dreturn&quot;,
 267         &quot;areturn&quot;,
 268         &quot;return&quot;,
 269         &quot;getstatic&quot;,
 270         &quot;putstatic&quot;,
 271         &quot;getfield&quot;,
 272         &quot;putfield&quot;,
 273         &quot;invokevirtual&quot;,
 274         &quot;invokespecial&quot;,
 275         &quot;invokestatic&quot;,
 276         &quot;invokeinterface&quot;,
 277         &quot;invokedynamic&quot;,
 278         &quot;new&quot;,
 279         &quot;newarray&quot;,
 280         &quot;anewarray&quot;,
 281         &quot;arraylength&quot;,
 282         &quot;athrow&quot;,
 283         &quot;checkcast&quot;,
 284         &quot;instanceof&quot;,
 285         &quot;monitorenter&quot;,
 286         &quot;monitorexit&quot;,
 287         &quot;wide&quot;,
 288         &quot;multianewarray&quot;,
 289         &quot;ifnull&quot;,
 290         &quot;ifnonnull&quot;,
 291         &quot;goto_w&quot;,
 292         &quot;jsr_w&quot;,
 293         &quot;breakpoint&quot;
 294     };
 295 
 296     /**
 297      * Sort log events by start time.
 298      */
 299     static Comparator&lt;LogEvent&gt; sortByStart = new Comparator&lt;LogEvent&gt;() {
 300 
 301         public int compare(LogEvent a, LogEvent b) {
 302             double difference = (a.getStart() - b.getStart());
 303             if (difference &lt; 0) {
 304                 return -1;
 305             }
 306             if (difference &gt; 0) {
 307                 return 1;
 308             }
 309             return 0;
 310         }
 311 
 312         @Override
 313         public boolean equals(Object other) {
 314             return false;
 315         }
 316 
 317         @Override
 318         public int hashCode() {
 319             return 7;
 320         }
 321     };
 322 
 323     /**
 324      * Sort log events first by the name of the compiled method, then by start
 325      * time. In case one of the events has no associated compilation (or the
 326      * associated compilation has no method name), the event with a compilation
 327      * and/or name is considered the larger one.
 328      */
 329     static Comparator&lt;LogEvent&gt; sortByNameAndStart = new Comparator&lt;LogEvent&gt;() {
 330 
 331         public int compare(LogEvent a, LogEvent b) {
 332             Compilation c1 = a.getCompilation();
 333             Compilation c2 = b.getCompilation();
 334             if (c1 != null &amp;&amp; c1.getMethod() != null &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 335                 int result = c1.getMethod().toString().compareTo(c2.getMethod().toString());
 336                 if (result != 0) {
 337                     return result;
 338                 }
 339             } else if ((c1 == null || c1.getMethod() == null) &amp;&amp; c2 != null &amp;&amp; c2.getMethod() != null) {
 340                 return -1;
 341             } else if ((c2 == null || c2.getMethod() == null) &amp;&amp; c1 != null &amp;&amp; c1.getMethod() != null) {
 342                 return 1;
 343             }
 344             return Double.compare(a.getStart(), b.getStart());
 345         }
 346 
 347         public boolean equals(Object other) {
 348             return false;
 349         }
 350 
 351         @Override
 352         public int hashCode() {
 353             return 7;
 354         }
 355     };
 356 
 357     /**
 358      * Sort log events by duration.
 359      */
 360     static Comparator&lt;LogEvent&gt; sortByElapsed = new Comparator&lt;LogEvent&gt;() {
 361 
 362         public int compare(LogEvent a, LogEvent b) {
 363             double difference = (a.getElapsedTime() - b.getElapsedTime());
 364             if (difference &lt; 0) {
 365                 return -1;
 366             }
 367             if (difference &gt; 0) {
 368                 return 1;
 369             }
 370             return 0;
 371         }
 372 
 373         @Override
 374         public boolean equals(Object other) {
 375             return false;
 376         }
 377 
 378         @Override
 379         public int hashCode() {
 380             return 7;
 381         }
 382     };
 383 
 384     /**
 385      * Shrink-wrapped representation of a JVMState (tailored to meet this
 386      * tool&#39;s needs). It only records a method and bytecode instruction index.
 387      */
 388     class Jvms {
 389         Jvms(Method method, int bci) {
 390             this.method = method;
 391             this.bci = bci;
 392         }
 393         final public Method method;
 394         final public int bci;
 395         final public String toString() {
 396             return &quot;@&quot; + bci + &quot; &quot; + method;
 397         }
 398     }
 399 
 400     /**
 401      * Representation of a lock elimination. Locks, corresponding to
 402      * synchronized blocks and method calls, may be eliminated if the object in
 403      * question is guaranteed to be used thread-locally.
 404      */
 405     class LockElimination extends BasicLogEvent {
 406 
 407         /**
 408          * Track all locations from which this lock was eliminated.
 409          */
 410         ArrayList&lt;Jvms&gt; jvms = new ArrayList&lt;&gt;(1);
 411 
 412         /**
 413          * The kind of lock (coarsened, nested, non-escaping, unknown).
 414          */
 415         final String kind;
 416 
 417         /**
 418          * The lock class (unlock, lock, unknown).
 419          */
 420         final String classId;
 421 
 422         /**
 423          * The precise type of lock.
 424          */
 425         final String tagName;
 426 
 427         LockElimination(String tagName, double start, String id, String kind, String classId) {
 428             super(start, id);
 429             this.kind = kind;
 430             this.classId = classId;
 431             this.tagName = tagName;
 432         }
 433 
 434         @Override
 435         public void print(PrintStream stream, boolean printID) {
 436             if (printID) {
 437                 stream.printf(&quot;%s &quot;, getId());
 438             }
 439             stream.printf(&quot;%s %s %s  %.3f &quot;, tagName, kind, classId, getStart());
 440             stream.print(jvms.toString());
 441             stream.print(&quot;\n&quot;);
 442         }
 443 
 444         void addJVMS(Method method, int bci) {
 445             jvms.add(new Jvms(method, bci));
 446         }
 447 
 448     }
 449 
 450     /**
 451      * A list of log events. This is populated with the events found in the
 452      * compilation log file during parsing.
 453      */
 454     private ArrayList&lt;LogEvent&gt; events = new ArrayList&lt;&gt;();
 455 
 456     /**
 457      * Map compilation log IDs to type names.
 458      */
 459     private HashMap&lt;String, String&gt; types = new HashMap&lt;&gt;();
 460 
 461     /**
 462      * Map compilation log IDs to methods.
 463      */
 464     private HashMap&lt;String, Method&gt; methods = new HashMap&lt;&gt;();
 465 
 466     /**
 467      * Map compilation IDs ({@see #makeId()}) to newly created nmethods.
 468      */
 469     private LinkedHashMap&lt;String, NMethod&gt; nmethods = new LinkedHashMap&lt;&gt;();
 470 
 471     /**
 472      * Map compilation task IDs {@see #makeId()}) to {@link Compilation}
 473      * objects.
 474      */
 475     private HashMap&lt;String, Compilation&gt; compiles = new HashMap&lt;&gt;();
 476 
 477     /**
 478      * Track compilation failure reasons.
 479      */
 480     private String failureReason;
 481 
 482     /**
 483      * The current bytecode instruction index.
 484      */
 485     private int current_bci;
 486 
 487     /**
 488      * The current bytecode instruction.
 489      */
 490     private int current_bytecode;
 491 
 492     /**
 493      * A sequence of {@link CallSite}s representing a call stack. A scope
 494      * typically holds several {@link CallSite}s that represent calls
 495      * originating from that scope.
 496      *
 497      * New scopes are typically pushed when parse log events are encountered
 498      * ({@see #startElement()}) and popped when parsing of a given Java method
 499      * is done ({@see #endElement()}). Parsing events can be nested. Several
 500      * other events add information to scopes ({@see #startElement()}).
 501      */
 502     private Deque&lt;CallSite&gt; scopes = new ArrayDeque&lt;&gt;();
 503 
 504     /**
 505      * The current compilation.
 506      */
 507     private Compilation compile;
 508 
 509     /**
 510      * The {@linkplain CallSite compilation scope} currently in focus.
 511      */
 512     private CallSite site;
 513 
 514     /**
 515      * The {@linkplain CallSite method handle call site} currently under
 516      * observation.
 517      */
 518     private CallSite methodHandleSite;
 519 
 520     /**
 521      * Keep track of potentially nested compiler {@linkplain Phase phases}.
 522      */
 523     private Deque&lt;Phase&gt; phaseStack = new ArrayDeque&lt;&gt;();
 524 
 525     /**
 526      * The {@linkplain LockElimination lock elimination event} currently being
 527      * processed.
 528      */
 529     private LockElimination currentLockElimination;
 530 
 531     /**
 532      * The {@linkplain UncommonTrapEvent uncommon trap event} currently being
 533      * processed.
 534      */
 535     private UncommonTrapEvent currentTrap;
 536 
 537     /**
 538      * During the processing of a late inline event, this stack holds the
 539      * {@link CallSite}s that represent the inlining event&#39;s call stack.
 540      */
 541     private Deque&lt;CallSite&gt; lateInlineScope;
 542 
 543     /**
 544      * Denote whether a late inlining event is currently being processed.
 545      */
 546     private boolean lateInlining;
 547 
 548     /**
 549      * A document locator to provide better error messages: this allows the
 550      * tool to display in which line of the log file the problem occurred.
 551      */
 552     private Locator locator;
 553 
 554     /**
 555      * Callback for the SAX framework to set the document locator.
 556      */
 557     @Override
 558     public void setDocumentLocator(Locator locator) {
 559         this.locator = locator;
 560     }
 561 
 562     /**
 563      * Report an internal error explicitly raised, i.e., not derived from an
 564      * exception.
 565      *
 566      * @param msg The error message to report.
 567      */
 568     private void reportInternalError(String msg) {
 569         reportInternalError(msg, null);
 570     }
 571 
 572     /**
 573      * Report an internal error derived from an exception.
 574      *
 575      * @param msg The beginning of the error message to report. The message
 576      * from the exception will be appended to this.
 577      * @param e The exception that led to the internal error.
 578      */
 579     private void reportInternalError(String msg, Exception e) {
 580         if (locator != null) {
 581             msg += &quot; at &quot; + locator.getLineNumber() + &quot;:&quot; + locator.getColumnNumber();
 582             if (e != null) {
 583                 msg += &quot; - &quot; + e.getMessage();
 584             }
 585         }
 586         if (e != null) {
 587             throw new Error(msg, e);
 588         } else {
 589             throw new Error(msg);
 590         }
 591     }
 592 
 593     /**
 594      * Parse a long hexadecimal address into a {@code long} value. As Java only
 595      * supports positive {@code long} values, extra error handling and parsing
 596      * logic is provided.
 597      */
 598     long parseLong(String l) {
 599         try {
 600             return Long.decode(l).longValue();
 601         } catch (NumberFormatException nfe) {
 602             int split = l.length() - 8;
 603             String s1 = &quot;0x&quot; + l.substring(split);
 604             String s2 = l.substring(0, split);
 605             long v1 = Long.decode(s1).longValue() &amp; 0xffffffffL;
 606             long v2 = (Long.decode(s2).longValue() &amp; 0xffffffffL) &lt;&lt; 32;
 607             if (!l.equals(&quot;0x&quot; + Long.toHexString(v1 + v2))) {
 608                 System.out.println(l);
 609                 System.out.println(s1);
 610                 System.out.println(s2);
 611                 System.out.println(v1);
 612                 System.out.println(v2);
 613                 System.out.println(Long.toHexString(v1 + v2));
 614                 reportInternalError(&quot;bad conversion&quot;);
 615             }
 616             return v1 + v2;
 617         }
 618     }
 619 
 620     /**
 621      * Entry point for log file parsing with a file name.
 622      *
 623      * @param file The name of the log file to parse.
 624      * @param cleanup Whether to perform bad XML cleanup during parsing (this
 625      * is relevant for some log files generated by the 1.5 JVM).
 626      * @return a list of {@link LogEvent} instances describing the events found
 627      * in the log file.
 628      */
 629     public static ArrayList&lt;LogEvent&gt; parse(String file, boolean cleanup) throws Exception {
 630         return parse(new FileReader(file), cleanup);
 631     }
 632 
 633     /**
 634      * Entry point for log file parsing with a file reader.
 635      * {@link #parse(String,boolean)}
 636      */
 637     public static ArrayList&lt;LogEvent&gt; parse(Reader reader, boolean cleanup) throws Exception {
 638         // Create the XML input factory
 639         SAXParserFactory factory = SAXParserFactory.newInstance();
 640 
 641         // Create the XML LogEvent reader
 642         SAXParser p = factory.newSAXParser();
 643 
 644         if (cleanup) {
 645             // some versions of the log have slightly malformed XML, so clean it
 646             // up before passing it to SAX
 647             reader = new LogCleanupReader(reader);
 648         }
 649 
 650         LogParser log = new LogParser();
 651         try {
 652             p.parse(new InputSource(reader), log);
 653         } catch (Throwable th) {
 654             th.printStackTrace();
 655             // Carry on with what we&#39;ve got...
 656         }
 657 
 658         // Associate compilations with their NMethods and other kinds of events
 659         for (LogEvent e : log.events) {
 660             if (e instanceof BasicLogEvent) {
 661                 BasicLogEvent ble = (BasicLogEvent) e;
 662                 Compilation c = log.compiles.get(ble.getId());
 663                 if (c == null) {
 664                     if (!(ble instanceof NMethod)) {
 665                         throw new InternalError(&quot;only nmethods should have a null compilation, here&#39;s a &quot; + ble.getClass());
 666                     }
 667                     continue;
 668                 }
 669                 ble.setCompilation(c);
 670                 if (ble instanceof NMethod) {
 671                     c.setNMethod((NMethod) ble);
 672                 }
 673             }
 674         }
 675 
 676         return log.events;
 677     }
 678 
 679     /**
 680      * Retrieve a given attribute&#39;s value from a collection of XML tag
 681      * attributes. Report an error if the requested attribute is not found.
 682      *
 683      * @param attr A collection of XML tag attributes.
 684      * @param name The name of the attribute the value of which is to be found.
 685      * @return The value of the requested attribute, or {@code null} if it was
 686      * not found.
 687      */
 688     String search(Attributes attr, String name) {
 689         String result = attr.getValue(name);
 690         if (result != null) {
 691             return result;
 692         } else {
 693             reportInternalError(&quot;can&#39;t find &quot; + name);
 694             return null;
 695         }
 696     }
 697 
 698     /**
 699      * Retrieve a given attribute&#39;s value from a collection of XML tag
 700      * attributes. Return a default value if the requested attribute is not
 701      * found.
 702      *
 703      * @param attr A collection of XML tag attributes.
 704      * @param name The name of the attribute the value of which is to be found.
 705      * @param defaultValue The default value to return if the attribute is not
 706      * found.
 707      * @return The value of the requested attribute, or the default value if it
 708      * was not found.
 709      */
 710     String search(Attributes attr, String name, String defaultValue) {
 711         String result = attr.getValue(name);
 712         if (result != null) {
 713             return result;
 714         }
 715         return defaultValue;
 716     }
 717 
 718     /**
 719      * Map a type ID from the compilation log to an actual type name. In case
 720      * the type represents an internal array type descriptor, return a
 721      * Java-level name. If the type ID cannot be mapped to a name, raise an
 722      * error.
 723      */
 724     String type(String id) {
 725         String result = types.get(id);
 726         String remapped = type2printableMap.get(result);
 727         if (remapped != null) {
 728             return remapped;
 729         }
 730         return result;
 731     }
 732 
 733     /**
 734      * Register a mapping from log file type ID to type name.
 735      */
 736     void type(String id, String name) {
 737         assert type(id) == null;
 738         types.put(id, name);
 739     }
 740 
 741     /**
 742      * Map a log file type ID to an internal type declarator.
 743      */
 744     String sigtype(String id) {
 745         String result = types.get(id);
 746         String remapped = type2vmtypeMap.get(result);
 747         if (remapped != null) {
 748             return remapped;
 749         }
 750         if (result == null) {
 751             reportInternalError(id);
 752         }
 753         if (result.charAt(0) == &#39;[&#39;) {
 754             return result;
 755         }
 756         return &quot;L&quot; + result + &quot;;&quot;;
 757     }
 758 
 759     /**
 760      * Retrieve a method based on the log file ID it was registered under.
 761      * Raise an error if the ID does not map to a method.
 762      */
 763     Method method(String id) {
 764         Method result = methods.get(id);
 765         if (result == null) {
 766             reportInternalError(id);
 767         }
 768         return result;
 769     }
 770 
 771     /**
 772      * From a compilation ID and kind, assemble a compilation ID for inclusion
 773      * in the output.
 774      *
 775      * @param atts A collection of XML attributes from which the required
 776      * attributes are retrieved.
 777      */
 778     public String makeId(Attributes atts) {
 779         String id = atts.getValue(&quot;compile_id&quot;);
 780         String kind = atts.getValue(&quot;kind&quot;);
 781         if (kind != null &amp;&amp; kind.equals(&quot;osr&quot;)) {
 782             id += &quot;%&quot;;
 783         }
 784         return id;
 785     }
 786 
 787     /**
 788      * Process the start of a compilation log XML element.&lt;ul&gt;
 789      * &lt;li&gt;&lt;b&gt;phase:&lt;/b&gt; record the beginning of a compilation phase, pushing
 790      * it on the {@linkplain #phaseStack phase stack} and collecting
 791      * information about the compiler graph.&lt;/li&gt;
 792      * &lt;li&gt;&lt;b&gt;phase_done:&lt;/b&gt; record the end of a compilation phase, popping it
 793      * off the {@linkplain #phaseStack phase stack} and collecting information
 794      * about the compiler graph (number of nodes and live nodes).&lt;/li&gt;
 795      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; register the start of a new compilation.&lt;/li&gt;
 796      * &lt;li&gt;&lt;b&gt;type:&lt;/b&gt; register a type.&lt;/li&gt;
 797      * &lt;li&gt;&lt;b&gt;bc:&lt;/b&gt; note the current bytecode index and instruction name,
 798      * updating {@link #current_bci} and {@link #current_bytecode}.&lt;/li&gt;
 799      * &lt;li&gt;&lt;b&gt;klass:&lt;/b&gt; register a type (class).&lt;/li&gt;
 800      * &lt;li&gt;&lt;b&gt;method:&lt;/b&gt; register a Java method.&lt;/li&gt;
 801      * &lt;li&gt;&lt;b&gt;call:&lt;/b&gt; process a call, populating {@link #site} with the
 802      * appropriate data.&lt;/li&gt;
 803      * &lt;li&gt;&lt;b&gt;regalloc:&lt;/b&gt; record the register allocator&#39;s trip count in the
 804      * {@linkplain #compile current compilation}.&lt;/li&gt;
 805      * &lt;li&gt;&lt;b&gt;inline_fail:&lt;/b&gt; record the reason for a failed inline
 806      * operation.&lt;/li&gt;
 807      * &lt;li&gt;&lt;b&gt;inline_success:&lt;/b&gt; record a successful inlining operation,
 808      * noting the success reason in the {@linkplain #site call site}.&lt;/li&gt;
 809      * &lt;li&gt;&lt;b&gt;failure:&lt;/b&gt; note a compilation failure, storing the reason
 810      * description in {@link #failureReason}.&lt;/li&gt;
 811      * &lt;li&gt;&lt;b&gt;task_done:&lt;/b&gt; register the end of a compilation, recording time
 812      * stamp and success information.&lt;/li&gt;
 813      * &lt;li&gt;&lt;b&gt;make_not_entrant:&lt;/b&gt; deal with making a native method
 814      * non-callable (e.g., during an OSR compilation, if there are still
 815      * activations) or a zombie (when the method can be deleted).&lt;/li&gt;
 816      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; process an uncommon trap, setting the
 817      * {@link #currentTrap} field.&lt;/li&gt;
 818      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the start of a lock elimination,
 819      * setting the {@link #currentLockElimination} event.&lt;/li&gt;
 820      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; start processing a late inline decision:
 821      * initialize the {@linkplain #lateInlineScope inline scope stack}, create
 822      * an {@linkplain #site initial scope} with a bogus bytecode index and the
 823      * right inline ID, and push the scope with the inline ID attached. Note
 824      * that most of late inlining processing happens in
 825      * {@link #endElement(String,String,String)}.&lt;/li&gt;
 826      * &lt;li&gt;&lt;b&gt;jvms:&lt;/b&gt; record a {@linkplain Jvms JVMState}. Depending on the
 827      * context in which this event is encountered, this can mean adding
 828      * information to the currently being processed trap, lock elimination, or
 829      * inlining operation.&lt;/li&gt;
 830      * &lt;li&gt;&lt;b&gt;inline_id:&lt;/b&gt; set the inline ID in the
 831      * {@linkplain #site current call site}.&lt;/li&gt;
 832      * &lt;li&gt;&lt;b&gt;nmethod:&lt;/b&gt; record the creation of a new {@link NMethod} and
 833      * store it in the {@link #nmethods} map.&lt;/li&gt;
 834      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; begin parsing a Java method&#39;s bytecode and
 835      * transforming it into an initial compiler IR graph.&lt;/li&gt;
 836      * &lt;li&gt;&lt;b&gt;parse_done:&lt;/b&gt; finish parsing a Java method&#39;s bytecode.&lt;/li&gt;
 837      * &lt;/ul&gt;
 838      */
 839     @Override
 840     public void startElement(String uri, String localName, String qname, Attributes atts) {
 841         if (qname.equals(&quot;phase&quot;)) {
 842             Phase p = new Phase(search(atts, &quot;name&quot;),
 843                     Double.parseDouble(search(atts, &quot;stamp&quot;)),
 844                     Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)),
 845                     Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 846             phaseStack.push(p);
 847         } else if (qname.equals(&quot;phase_done&quot;)) {
 848             Phase p = phaseStack.pop();
 849             String phaseName = search(atts, &quot;name&quot;, null);
 850             if (phaseName != null &amp;&amp; !p.getId().equals(phaseName)) {
 851                 System.out.println(&quot;phase: &quot; + p.getId());
 852                 reportInternalError(&quot;phase name mismatch&quot;);
 853             }
 854             p.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 855             p.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
 856             p.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
 857             compile.getPhases().add(p);
 858         } else if (qname.equals(&quot;task&quot;)) {
 859             String id = makeId(atts);
 860 
 861             // Create the new Compilation instance and populate it with readily
 862             // available data.
 863             compile = new Compilation(Integer.parseInt(search(atts, &quot;compile_id&quot;, &quot;-1&quot;)));
 864             compile.setStart(Double.parseDouble(search(atts, &quot;stamp&quot;)));
 865             compile.setICount(search(atts, &quot;count&quot;, &quot;0&quot;));
 866             compile.setBCount(search(atts, &quot;backedge_count&quot;, &quot;0&quot;));
 867             compile.setBCI(Integer.parseInt(search(atts, &quot;osr_bci&quot;, &quot;-1&quot;)));
 868             String compiler = atts.getValue(&quot;compiler&quot;);
 869             assert compiler == null : &quot;Compiler is not specified in task&quot;;
 870             long level = parseLong(search(atts, &quot;level&quot;, &quot;0&quot;));
 871             if (level != 0) {
 872                 compile.setLevel(level);
 873             }
 874             // Extract the name of the compiled method.
 875             String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
 876             String methodName = parts[0] + &quot;::&quot; + parts[1];
 877 
 878             // Continue collecting compilation meta-data.
 879             String kind = atts.getValue(&quot;compile_kind&quot;);
 880             if (kind == null) {
 881                 kind = &quot;normal&quot;;
 882             }
 883             if (kind.equals(&quot;osr&quot;)) {
 884                 compile.setOsr(true);
 885             } else if (kind.equals(&quot;c2i&quot;)) {
 886                 compile.setSpecial(&quot;--- adapter &quot; + methodName);
 887             } else {
 888                 compile.setSpecial(compile.getId() + &quot; &quot; + methodName + &quot; (0 bytes)&quot;);
 889             }
 890 
 891             // Build a dummy method to stuff in the Compilation at the
 892             // beginning.
 893             Method m = new Method();
 894             m.setHolder(parts[0]);
 895             m.setName(parts[1]);
 896             m.setSignature(parts[2]);
 897             m.setFlags(&quot;0&quot;);
 898             m.setBytes(search(atts, &quot;bytes&quot;, &quot;unknown&quot;));
 899             m.setLevel(compile.getLevel());
 900             compile.setMethod(m);
 901             events.add(compile);
 902             compiles.put(id, compile);
 903             site = compile.getCall();
 904         } else if (qname.equals(&quot;type&quot;)) {
 905             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 906         } else if (qname.equals(&quot;bc&quot;)) {
 907             current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
 908             current_bytecode = Integer.parseInt(search(atts, &quot;code&quot;));
 909         } else if (qname.equals(&quot;klass&quot;)) {
 910             type(search(atts, &quot;id&quot;), search(atts, &quot;name&quot;));
 911         } else if (qname.equals(&quot;method&quot;)) {
 912             String id = search(atts, &quot;id&quot;);
 913             Method m = new Method();
 914             m.setHolder(type(search(atts, &quot;holder&quot;)));
 915             m.setName(search(atts, &quot;name&quot;));
 916             m.setReturnType(type(search(atts, &quot;return&quot;)));
 917             String arguments = atts.getValue(&quot;arguments&quot;);;
 918             if (arguments == null) {
 919                 m.setSignature(&quot;()&quot; + sigtype(atts.getValue(&quot;return&quot;)));
 920             } else {
 921                 String[] args = spacePattern.split(arguments);
 922                 StringBuilder sb = new StringBuilder(&quot;(&quot;);
 923                 for (int i = 0; i &lt; args.length; i++) {
 924                     sb.append(sigtype(args[i]));
 925                 }
 926                 sb.append(&quot;)&quot;);
 927                 sb.append(sigtype(atts.getValue(&quot;return&quot;)));
 928                 m.setSignature(sb.toString());
 929             }
 930 
 931             if (search(atts, &quot;unloaded&quot;, &quot;0&quot;).equals(&quot;0&quot;)) {
 932                m.setBytes(search(atts, &quot;bytes&quot;));
 933                m.setIICount(search(atts, &quot;iicount&quot;));
 934                m.setFlags(search(atts, &quot;flags&quot;));
 935             }
 936             String compiler = search(atts, &quot;compiler&quot;, &quot;&quot;);
 937             m.setCompiler(compiler);
 938             long level = parseLong(search(atts, &quot;level&quot;, &quot;0&quot;));
 939             if (level != 0) {
 940                 m.setLevel(level);
 941             }
 942             methods.put(id, m);
 943         } else if (qname.equals(&quot;call&quot;)) {
 944             if (methodHandleSite != null) {
 945                 methodHandleSite = null;
 946             }
 947             Method m = method(search(atts, &quot;method&quot;));
 948             if (lateInlining &amp;&amp; scopes.size() == 0) {
 949                 // re-attempting already seen call site (late inlining for MH invokes)
 950                 if (m != site.getMethod()) {
 951                     if (current_bci != site.getBci()) {
 952                         System.err.println(m + &quot; bci: &quot; + current_bci);
 953                         System.err.println(site.getMethod() +  &quot; bci: &quot; + site.getBci());
 954                         reportInternalError(&quot;bci mismatch after late inlining&quot;);
 955                     }
 956                     site.setMethod(m);
 957                 }
 958             } else {
 959                 // We&#39;re dealing with a new call site; the called method is
 960                 // likely to be parsed next.
 961                 site = new CallSite(current_bci, m);
 962             }
 963             site.setCount(Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
 964             String receiver = atts.getValue(&quot;receiver&quot;);
 965             if (receiver != null) {
 966                 site.setReceiver(type(receiver));
 967                 site.setReceiver_count(Integer.parseInt(search(atts, &quot;receiver_count&quot;)));
 968             }
 969             int methodHandle = Integer.parseInt(search(atts, &quot;method_handle_intrinsic&quot;, &quot;0&quot;));
 970             if (lateInlining &amp;&amp; scopes.size() == 0) {
 971                 // The call was already added before this round of late
 972                 // inlining. Ignore.
 973             } else if (methodHandle == 0) {
 974                 scopes.peek().add(site);
 975             } else {
 976                 // method handle call site can be followed by another
 977                 // call (in case it is inlined). If that happens we
 978                 // discard the method handle call site. So we keep
 979                 // track of it but don&#39;t add it to the list yet.
 980                 methodHandleSite = site;
 981             }
 982         } else if (qname.equals(&quot;intrinsic&quot;)) {
 983             String id = atts.getValue(&quot;id&quot;);
 984             assert id != null : &quot;intrinsic id is null&quot;;
 985             CallSite cs = (site != null) ? site : scopes.peek();
 986             assert cs != null : &quot;no CallSite?&quot;;
 987             cs.setIntrinsicName(id);
 988         } else if (qname.equals(&quot;regalloc&quot;)) {
 989             compile.setAttempts(Integer.parseInt(search(atts, &quot;attempts&quot;)));
 990         } else if (qname.equals(&quot;inline_fail&quot;)) {
 991             if (methodHandleSite != null) {
 992                 scopes.peek().add(methodHandleSite);
 993                 methodHandleSite = null;
 994             }
 995             if (lateInlining &amp;&amp; scopes.size() == 0) {
 996                 site.setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
 997                 lateInlining = false;
 998             } else {
 999                 scopes.peek().last().setReason(&quot;fail: &quot; + search(atts, &quot;reason&quot;));
1000             }
1001         } else if (qname.equals(&quot;inline_success&quot;)) {
1002             if (methodHandleSite != null) {
1003                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1004             }
1005             site.setReason(&quot;succeed: &quot; + search(atts, &quot;reason&quot;));
1006         } else if (qname.equals(&quot;failure&quot;)) {
1007             failureReason = search(atts, &quot;reason&quot;);
1008         } else if (qname.equals(&quot;task_done&quot;)) {
1009             compile.setEnd(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1010             if (Integer.parseInt(search(atts, &quot;success&quot;)) == 0) {
1011                 compile.setFailureReason(failureReason);
1012                 failureReason = null;
1013             }
1014         } else if (qname.equals(&quot;make_not_entrant&quot;)) {
1015             String id = makeId(atts);
1016             NMethod nm = nmethods.get(id);
1017             if (nm == null) reportInternalError(&quot;nm == null&quot;);
1018             LogEvent e = new MakeNotEntrantEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)), id,
1019                                                  atts.getValue(&quot;zombie&quot;) != null, nm);
1020             events.add(e);
1021         } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1022             String id = atts.getValue(&quot;compile_id&quot;);
1023             if (id != null) {
1024                 id = makeId(atts);
1025                 currentTrap = new UncommonTrapEvent(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1026                         id,
1027                         atts.getValue(&quot;reason&quot;),
1028                         atts.getValue(&quot;action&quot;),
1029                         Integer.parseInt(search(atts, &quot;count&quot;, &quot;0&quot;)));
1030                 events.add(currentTrap);
1031             } else {
1032                 if (atts.getValue(&quot;method&quot;) != null) {
1033                     // These are messages from ciTypeFlow that don&#39;t
1034                     // actually correspond to generated code.
1035                     return;
1036                 }
1037                 try {
1038                     UncommonTrap unc = new UncommonTrap(Integer.parseInt(search(atts, &quot;bci&quot;)),
1039                             search(atts, &quot;reason&quot;),
1040                             search(atts, &quot;action&quot;),
1041                             bytecodes[current_bytecode]);
1042                     if (scopes.size() == 0) {
1043                         // There may be a dangling site not yet in scopes after a late_inline
1044                         if (site != null) {
1045                             site.add(unc);
1046                         } else {
1047                             reportInternalError(&quot;scope underflow&quot;);
1048                         }
1049                     } else {
1050                         scopes.peek().add(unc);
1051                     }
1052                 } catch (Error e) {
1053                     e.printStackTrace();
1054                 }
1055             }
1056         } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1057             String id = atts.getValue(&quot;compile_id&quot;);
1058             if (id != null) {
1059                 id = makeId(atts);
1060                 String kind = atts.getValue(&quot;kind&quot;);
1061                 String classId = atts.getValue(&quot;class_id&quot;);
1062                 currentLockElimination = new LockElimination(qname, Double.parseDouble(search(atts, &quot;stamp&quot;)), id, kind, classId);
1063                 events.add(currentLockElimination);
1064             }
1065         } else if (qname.equals(&quot;late_inline&quot;)) {
1066             long inlineId = 0;
1067             try {
1068                 inlineId = Long.parseLong(search(atts, &quot;inline_id&quot;));
1069             } catch (InternalError ex) {
1070                 // Log files from older hotspots may lack inline_id,
1071                 // and zero is an acceptable substitute that allows processing to continue.
1072             }
1073             lateInlineScope = new ArrayDeque&lt;&gt;();
1074             Method m = method(search(atts, &quot;method&quot;));
1075             site = new CallSite(-999, m);
1076             site.setInlineId(inlineId);
1077             lateInlineScope.push(site);
1078         } else if (qname.equals(&quot;jvms&quot;)) {
1079             // &lt;jvms bci=&#39;4&#39; method=&#39;java/io/DataInputStream readChar ()C&#39; bytes=&#39;40&#39; count=&#39;5815&#39; iicount=&#39;20815&#39;/&gt;
1080             if (currentTrap != null) {
1081                 String[] parts = spacePattern.split(atts.getValue(&quot;method&quot;));
1082                 currentTrap.addMethodAndBCI(parts[0].replace(&#39;/&#39;, &#39;.&#39;) + &#39;.&#39; + parts[1] + parts[2], Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1083             } else if (currentLockElimination != null) {
1084                   currentLockElimination.addJVMS(method(atts.getValue(&quot;method&quot;)), Integer.parseInt(atts.getValue(&quot;bci&quot;)));
1085             } else if (lateInlineScope != null) {
1086                 current_bci = Integer.parseInt(search(atts, &quot;bci&quot;));
1087                 Method m = method(search(atts, &quot;method&quot;));
1088                 site = new CallSite(current_bci, m);
1089                 lateInlineScope.push(site);
1090             } else {
1091                 // Ignore &lt;eliminate_allocation type=&#39;667&#39;&gt;,
1092                 //        &lt;replace_string_concat arguments=&#39;2&#39; string_alloc=&#39;0&#39; multiple=&#39;0&#39;&gt;
1093             }
1094         } else if (qname.equals(&quot;inline_id&quot;)) {
1095             if (methodHandleSite != null) {
1096                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1097             }
1098             long id = Long.parseLong(search(atts, &quot;id&quot;));
1099             site.setInlineId(id);
1100         } else if (qname.equals(&quot;nmethod&quot;)) {
1101             String id = makeId(atts);
1102             NMethod nm = new NMethod(Double.parseDouble(search(atts, &quot;stamp&quot;)),
1103                     id,
1104                     parseLong(atts.getValue(&quot;address&quot;)),
1105                     parseLong(atts.getValue(&quot;size&quot;)));
1106             String level = atts.getValue(&quot;level&quot;);
1107             if (level != null) {
1108                 nm.setLevel(parseLong(level));
1109             }
1110             String compiler = search(atts, &quot;compiler&quot;, &quot;&quot;);
1111             nm.setCompiler(compiler);
1112             nmethods.put(id, nm);
1113             events.add(nm);
1114         } else if (qname.equals(&quot;parse&quot;)) {
1115             if (failureReason != null &amp;&amp; scopes.size() == 0 &amp;&amp; !lateInlining) {
1116                 // A compilation just failed, and we&#39;re back at a top
1117                 // compilation scope.
1118                 failureReason = null;
1119                 compile.reset();
1120                 site = compile.getCall();
1121             }
1122 
1123             // Error checking.
1124             if (methodHandleSite != null) {
1125                 reportInternalError(&quot;method handle site should have been replaced&quot;);
1126             }
1127             Method m = method(search(atts, &quot;method&quot;)); // this is the method being parsed
1128             if (lateInlining &amp;&amp; scopes.size() == 0) {
1129                 if (site.getMethod() != m) {
1130                     reportInternalError(&quot;Unexpected method mismatch during late inlining (method at call site: &quot; +
1131                         site.getMethod() + &quot;, method being parsed: &quot; + m + &quot;)&quot;);
1132                 }
1133             }
1134 
1135             if (scopes.size() == 0 &amp;&amp; !lateInlining) {
1136                 // The method being parsed is actually the method being
1137                 // compiled; i.e., we&#39;re dealing with a compilation top scope,
1138                 // which we must consequently push to the scopes stack.
1139                 compile.setMethod(m);
1140                 scopes.push(site);
1141             } else {
1142                 // The method being parsed is *not* the current compilation&#39;s
1143                 // top scope; i.e., we&#39;re dealing with an actual call site
1144                 // in the top scope or somewhere further down a call stack.
1145                 if (site.getMethod() == m) {
1146                     // We&#39;re dealing with monomorphic inlining that didn&#39;t have
1147                     // to be narrowed down, because the receiver was known
1148                     // beforehand.
1149                     scopes.push(site);
1150                 } else if (scopes.peek().getCalls().size() &gt; 2 &amp;&amp; m == scopes.peek().lastButOne().getMethod()) {
1151                     // We&#39;re dealing with an at least bimorphic call site, and
1152                     // the compiler has now decided to parse the last-but-one
1153                     // method. The last one may already have been parsed for
1154                     // inlining.
1155                     scopes.push(scopes.peek().lastButOne());
1156                 } else {
1157                     // The method has been narrowed down to the one we&#39;re now
1158                     // going to parse, which is inlined here. It&#39;s monomorphic
1159                     // inlining, but was not immediately clear as such.
1160                     //
1161                     // C1 prints multiple method tags during inlining when it
1162                     // narrows the method being inlined. Example:
1163                     //   ...
1164                     //   &lt;method id=&quot;813&quot; holder=&quot;694&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;36&quot; iicount=&quot;1&quot;/&gt;
1165                     //   &lt;call method=&quot;813&quot; instr=&quot;invokevirtual&quot;/&gt;
1166                     //   &lt;inline_success reason=&quot;receiver is statically known&quot;/&gt;
1167                     //   &lt;method id=&quot;814&quot; holder=&quot;792&quot; name=&quot;toString&quot; return=&quot;695&quot; flags=&quot;1&quot; bytes=&quot;5&quot; iicount=&quot;3&quot;/&gt;
1168                     //   &lt;parse method=&quot;814&quot;&gt;
1169                     //   ...
1170                     site.setMethod(m);
1171                     scopes.push(site);
1172                 }
1173             }
1174         } else if (qname.equals(&quot;parse_done&quot;)) {
1175             // Attach collected information about IR nodes to the current
1176             // parsing scope before it&#39;s popped off the stack in endElement()
1177             // (see where the parse tag is handled).
1178             CallSite call = scopes.peek();
1179             call.setEndNodes(Integer.parseInt(search(atts, &quot;nodes&quot;, &quot;0&quot;)));
1180             call.setEndLiveNodes(Integer.parseInt(search(atts, &quot;live&quot;, &quot;0&quot;)));
1181             call.setTimeStamp(Double.parseDouble(search(atts, &quot;stamp&quot;)));
1182         }
1183     }
1184 
1185     /**
1186      * Process the end of a compilation log XML element.&lt;ul&gt;
1187      * &lt;li&gt;&lt;b&gt;parse:&lt;/b&gt; finish transforming a Java method&#39;s bytecode
1188      * instructions to an initial compiler IR graph.&lt;/li&gt;
1189      * &lt;li&gt;&lt;b&gt;uncommon_trap:&lt;/b&gt; record the end of processing an uncommon trap,
1190      * resetting {@link #currentTrap}.&lt;/li&gt;
1191      * &lt;li&gt;&lt;b&gt;eliminate_lock:&lt;/b&gt; record the end of a lock elimination,
1192      * resetting {@link #currentLockElimination}.&lt;/li&gt;
1193      * &lt;li&gt;&lt;b&gt;late_inline:&lt;/b&gt; the closing tag for late_inline does not denote
1194      * the end of a late inlining operation, but the end of the descriptive log
1195      * data given at its beginning. That is, we&#39;re now in the position to
1196      * assemble details about the inlining chain (bytecode instruction index in
1197      * caller, called method). The {@link #lateInlining} flag is set to
1198      * {@code true} here. (It will be reset when parsing the inlined methods is
1199      * done; this happens for the successful case in this method as well, when
1200      * {@code parse} elements are processed; and for inlining failures, in
1201      * {@link #startElement(String,String,String,Attributes)}, when {@code inline_fail} elements are
1202      * processed.)&lt;/li&gt;
1203      * &lt;li&gt;&lt;b&gt;task:&lt;/b&gt; perform cleanup at the end of a compilation. Note that
1204      * the explicit {@code task_done} event is handled in
1205      * {@link #startElement(String,String,String,Attributes)}.&lt;/li&gt;
1206      * &lt;/ul&gt;
1207      */
1208     @Override
1209     public void endElement(String uri, String localName, String qname) {
1210         try {
1211             if (qname.equals(&quot;parse&quot;)) {
1212                 // Finish dealing with the current call scope. If no more are
1213                 // left, no late inlining can be going on.
1214                 scopes.pop();
1215                 if (scopes.size() == 0) {
1216                     lateInlining = false;
1217                 }
1218             } else if (qname.equals(&quot;uncommon_trap&quot;)) {
1219                 currentTrap = null;
1220             } else if (qname.startsWith(&quot;eliminate_lock&quot;)) {
1221                 currentLockElimination = null;
1222             } else if (qname.equals(&quot;late_inline&quot;)) {
1223                 // Populate late inlining info.
1224                 if (scopes.size() != 0) {
1225                     reportInternalError(&quot;scopes should be empty for late inline&quot;);
1226                 }
1227                 // late inline scopes are specified in reverse order:
1228                 // compiled method should be on top of stack.
1229                 CallSite caller = lateInlineScope.pop();
1230                 Method m = compile.getMethod();
1231                 if (!m.equals(caller.getMethod())) {
1232                     reportInternalError(String.format(&quot;call site and late_inline info don&#39;t match:\n  method %s\n  caller method %s, bci %d&quot;, m, caller.getMethod(), current_bci));
1233                 }
1234 
1235                 // Walk down the inlining chain and assemble bci+callee info.
1236                 // This needs to be converted from caller+bci info contained in
1237                 // the late_inline data.
1238                 CallSite lateInlineSite = compile.getLateInlineCall();
1239                 ArrayDeque&lt;CallSite&gt; thisCallScopes = new ArrayDeque&lt;&gt;();
1240                 do {
1241                     current_bci = caller.getBci();
1242                     // Next inlined call.
1243                     caller = lateInlineScope.pop();
1244                     CallSite callee = new CallSite(current_bci, caller.getMethod());
1245                     callee.setInlineId(caller.getInlineId());
1246                     thisCallScopes.addLast(callee);
1247                     lateInlineSite.add(callee);
1248                     lateInlineSite = callee;
1249                 } while (!lateInlineScope.isEmpty());
1250 
1251                 site = compile.getCall().findCallSite(thisCallScopes);
1252                 if (site == null) {
1253                     // Call site could not be found - report the problem in detail.
1254                     System.err.println(&quot;call scopes:&quot;);
1255                     for (CallSite c : thisCallScopes) {
1256                         System.err.println(c.getMethod() + &quot; &quot; + c.getBci() + &quot; &quot; + c.getInlineId());
1257                     }
1258                     CallSite c = thisCallScopes.getLast();
1259                     if (c.getInlineId() != 0) {
1260                         System.err.println(&quot;Looking for call site in entire tree:&quot;);
1261                         ArrayDeque&lt;CallSite&gt; stack = compile.getCall().findCallSite2(c);
1262                         for (CallSite c2 : stack) {
1263                             System.err.println(c2.getMethod() + &quot; &quot; + c2.getBci() + &quot; &quot; + c2.getInlineId());
1264                         }
1265                     }
1266                     System.err.println(caller.getMethod() + &quot; bci: &quot; + current_bci);
1267                     reportInternalError(&quot;couldn&#39;t find call site&quot;);
1268                 }
1269                 lateInlining = true;
1270 
1271                 if (caller.getBci() != -999) {
1272                     System.out.println(caller.getMethod());
1273                     reportInternalError(&quot;broken late_inline info&quot;);
1274                 }
1275                 if (site.getMethod() != caller.getMethod()) {
1276                     if (site.getInlineId() == caller.getInlineId()) {
1277                         site.setMethod(caller.getMethod());
1278                     } else {
1279                         System.out.println(site.getMethod());
1280                         System.out.println(caller.getMethod());
1281                         reportInternalError(&quot;call site and late_inline info don&#39;t match&quot;);
1282                     }
1283                 }
1284                 // late_inline is followed by parse with scopes.size() == 0,
1285                 // &#39;site&#39; will be pushed to scopes.
1286                 lateInlineScope = null;
1287             } else if (qname.equals(&quot;task&quot;)) {
1288                 types.clear();
1289                 methods.clear();
1290                 site = null;
1291                 lateInlining = false;
1292             }
1293         } catch (Exception e) {
1294             reportInternalError(&quot;exception while processing end element&quot;, e);
1295         }
1296     }
1297 
1298     //
1299     // Handlers for problems that occur in XML parsing itself.
1300     //
1301 
1302     @Override
1303     public void warning(org.xml.sax.SAXParseException e) {
1304         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1305         e.printStackTrace();
1306     }
1307 
1308     @Override
1309     public void error(org.xml.sax.SAXParseException e) {
1310         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1311         e.printStackTrace();
1312     }
1313 
1314     @Override
1315     public void fatalError(org.xml.sax.SAXParseException e) {
1316         System.err.println(e.getMessage() + &quot; at line &quot; + e.getLineNumber() + &quot;, column &quot; + e.getColumnNumber());
1317         e.printStackTrace();
1318     }
1319 }
    </pre>
  </body>
</html>