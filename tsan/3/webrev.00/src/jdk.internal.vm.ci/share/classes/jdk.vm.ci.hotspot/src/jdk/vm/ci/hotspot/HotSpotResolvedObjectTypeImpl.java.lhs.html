<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot;
 24 
 25 import static java.util.Objects.requireNonNull;
 26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
 27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
 28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
 30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
 31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
 32 
 33 import java.lang.annotation.Annotation;
<a name="2" id="anc2"></a><span class="line-removed"> 34 import java.lang.reflect.Array;</span>
<span class="line-removed"> 35 import java.lang.reflect.Constructor;</span>
 36 import java.lang.reflect.Field;
<a name="3" id="anc3"></a><span class="line-removed"> 37 import java.lang.reflect.Method;</span>
 38 import java.lang.reflect.Modifier;
 39 import java.nio.ByteOrder;
<a name="4" id="anc4"></a>

 40 import java.util.HashMap;
 41 
 42 import jdk.vm.ci.common.JVMCIError;
 43 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 44 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
 45 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
 46 import jdk.vm.ci.meta.Assumptions.LeafType;
 47 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
 48 import jdk.vm.ci.meta.Constant;
 49 import jdk.vm.ci.meta.JavaConstant;
 50 import jdk.vm.ci.meta.JavaKind;
 51 import jdk.vm.ci.meta.JavaType;
 52 import jdk.vm.ci.meta.ResolvedJavaField;
 53 import jdk.vm.ci.meta.ResolvedJavaMethod;
 54 import jdk.vm.ci.meta.ResolvedJavaType;
 55 import jdk.vm.ci.meta.UnresolvedJavaField;
 56 import jdk.vm.ci.meta.UnresolvedJavaType;
 57 
 58 /**
<a name="5" id="anc5"></a><span class="line-modified"> 59  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes.</span>


 60  */
<a name="6" id="anc6"></a><span class="line-modified"> 61 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceWrapperObject {</span>
 62 
 63     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
 64     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
<a name="7" id="anc7"></a>
 65 
 66     /**
 67      * The Java class this type represents.
 68      */
<a name="8" id="anc8"></a><span class="line-modified"> 69     private final Class&lt;?&gt; javaClass;</span>

 70     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
 71     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
<a name="9" id="anc9"></a><span class="line-modified"> 72     private HotSpotResolvedJavaField[] instanceFields;</span>
<span class="line-modified"> 73     private HotSpotResolvedObjectTypeImpl[] interfaces;</span>
 74     private HotSpotConstantPool constantPool;
<a name="10" id="anc10"></a><span class="line-modified"> 75     final HotSpotJVMCIMetaAccessContext context;</span>
<span class="line-modified"> 76     private HotSpotResolvedObjectType arrayOfType;</span>
 77 
 78     /**
<a name="11" id="anc11"></a><span class="line-modified"> 79      * Managed exclusively by {@link HotSpotResolvedJavaFieldImpl#toJava}.</span>
 80      */
 81     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
 82 
<a name="12" id="anc12"></a><span class="line-modified"> 83     /**</span>
<span class="line-modified"> 84      * Gets the JVMCI mirror for a {@link Class} object.</span>
<span class="line-removed"> 85      *</span>
<span class="line-removed"> 86      * @return the {@link HotSpotResolvedJavaType} corresponding to {@code javaClass}</span>
<span class="line-removed"> 87      */</span>
<span class="line-removed"> 88     static HotSpotResolvedObjectTypeImpl fromObjectClass(Class&lt;?&gt; javaClass) {</span>
<span class="line-removed"> 89         return (HotSpotResolvedObjectTypeImpl) runtime().fromClass(javaClass);</span>
 90     }
 91 
 92     /**
<a name="13" id="anc13"></a><span class="line-modified"> 93      * Gets the JVMCI mirror from a HotSpot type. Since {@link Class} is already a proxy for the</span>
<span class="line-removed"> 94      * underlying Klass*, it is used instead of the raw Klass*.</span>
 95      *
 96      * Called from the VM.
 97      *
<a name="14" id="anc14"></a><span class="line-modified"> 98      * @param javaClass a {@link Class} object</span>
 99      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
100      */
101     @SuppressWarnings(&quot;unused&quot;)
<a name="15" id="anc15"></a><span class="line-modified">102     private static HotSpotResolvedObjectTypeImpl fromMetaspace(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified">103         return fromObjectClass(javaClass);</span>

104     }
105 
106     /**
107      * Creates the JVMCI mirror for a {@link Class} object.
108      *
<a name="16" id="anc16"></a><span class="line-removed">109      * &lt;p&gt;</span>
110      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
<a name="17" id="anc17"></a><span class="line-modified">111      * {@link Class} type. Use {@link #fromObjectClass(Class)} or {@link #fromMetaspace(Class)}</span>
<span class="line-removed">112      * instead.</span>
113      * &lt;/p&gt;
114      *
<a name="18" id="anc18"></a><span class="line-modified">115      * @param javaClass the Class to create the mirror for</span>
<span class="line-removed">116      * @param context</span>
117      */
<a name="19" id="anc19"></a><span class="line-modified">118     HotSpotResolvedObjectTypeImpl(Class&lt;?&gt; javaClass, HotSpotJVMCIMetaAccessContext context) {</span>
<span class="line-modified">119         super(getSignatureName(javaClass));</span>
<span class="line-modified">120         this.javaClass = javaClass;</span>
<span class="line-modified">121         this.context = context;</span>
<span class="line-modified">122         assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();</span>
<span class="line-removed">123     }</span>
124 
<a name="20" id="anc20"></a><span class="line-modified">125     /**</span>
<span class="line-modified">126      * Returns the name of this type as it would appear in a signature.</span>
<span class="line-modified">127      */</span>
<span class="line-modified">128     private static String getSignatureName(Class&lt;?&gt; javaClass) {</span>
<span class="line-modified">129         if (javaClass.isArray()) {</span>
<span class="line-modified">130             return javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
131         }
<a name="21" id="anc21"></a><span class="line-removed">132         return &quot;L&quot; + javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
133     }
134 
135     /**
136      * Gets the metaspace Klass for this type.
137      */
138     long getMetaspaceKlass() {
<a name="22" id="anc22"></a><span class="line-modified">139         if (HotSpotJVMCIRuntime.getHostWordKind() == JavaKind.Long) {</span>
<span class="line-modified">140             return UNSAFE.getLong(javaClass, config().klassOffset);</span>

141         }
<a name="23" id="anc23"></a><span class="line-modified">142         return UNSAFE.getInt(javaClass, config().klassOffset) &amp; 0xFFFFFFFFL;</span>
143     }
144 
145     @Override
146     public long getMetaspacePointer() {
<a name="24" id="anc24"></a><span class="line-modified">147         return getMetaspaceKlass();</span>
<span class="line-removed">148     }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150     /**</span>
<span class="line-removed">151      * The Klass* for this object is kept alive by the direct reference to {@link #javaClass} so no</span>
<span class="line-removed">152      * extra work is required.</span>
<span class="line-removed">153      */</span>
<span class="line-removed">154     @Override</span>
<span class="line-removed">155     public boolean isRegistered() {</span>
<span class="line-removed">156         return true;</span>
157     }
158 
159     @Override
160     public int getModifiers() {
161         if (isArray()) {
162             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
163         } else {
164             return getAccessFlags() &amp; jvmClassModifiers();
165         }
166     }
167 
168     public int getAccessFlags() {
169         HotSpotVMConfig config = config();
170         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
171     }
172 
<a name="25" id="anc25"></a><span class="line-removed">173     @Override</span>
<span class="line-removed">174     public HotSpotResolvedObjectType getArrayClass() {</span>
<span class="line-removed">175         if (arrayOfType == null) {</span>
<span class="line-removed">176             arrayOfType = fromObjectClass(Array.newInstance(mirror(), 0).getClass());</span>
<span class="line-removed">177         }</span>
<span class="line-removed">178         return arrayOfType;</span>
<span class="line-removed">179     }</span>
<span class="line-removed">180 </span>
181     @Override
182     public ResolvedJavaType getComponentType() {
<a name="26" id="anc26"></a><span class="line-modified">183         Class&lt;?&gt; javaComponentType = mirror().getComponentType();</span>
<span class="line-removed">184         return javaComponentType == null ? null : runtime().fromClass(javaComponentType);</span>
185     }
186 
187     @Override
188     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
189         if (isLeaf()) {
190             // No assumptions are required.
191             return new AssumptionResult&lt;&gt;(this);
192         }
193         HotSpotVMConfig config = config();
194         if (isArray()) {
195             ResolvedJavaType elementalType = getElementalType();
196             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
197             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
198                 /*
199                  * If the elementType is leaf then the array is leaf under the same assumptions but
200                  * only if the element type is exactly the leaf type. The element type can be
201                  * abstract even if there is only one implementor of the abstract type.
202                  */
203                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
204                 result.add(elementType);
205                 return result;
206             }
207             return null;
208         } else if (isInterface()) {
209             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
210             /*
211              * If the implementor field contains itself that indicates that the interface has more
212              * than one implementors (see: InstanceKlass::add_implementor).
213              */
214             if (implementor == null || implementor.equals(this)) {
215                 return null;
216             }
217 
218             assert !implementor.isInterface();
219             if (implementor.isAbstract() || !implementor.isLeafClass()) {
220                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
221                 if (leafConcreteSubtype != null) {
222                     assert !leafConcreteSubtype.getResult().equals(implementor);
223                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
224                     // Accumulate leaf assumptions and return the combined result.
225                     newResult.add(leafConcreteSubtype);
226                     return newResult;
227                 }
228                 return null;
229             }
230             return concreteSubtype(implementor);
231         } else {
232             HotSpotResolvedObjectTypeImpl type = this;
233             while (type.isAbstract()) {
234                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
235                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
236                     return null;
237                 }
238                 type = subklass;
239             }
240             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
241                 return null;
242             }
243             if (this.isAbstract()) {
244                 return concreteSubtype(type);
245             } else {
246                 assert this.equals(type);
247                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
248             }
249         }
250     }
251 
252     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
253         if (type.isLeaf()) {
254             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
255         } else {
256             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
257         }
258     }
259 
260     /**
261      * Returns if type {@code type} is a leaf class. This is the case if the
262      * {@code Klass::_subklass} field of the underlying class is zero.
263      *
264      * @return true if the type is a leaf class
265      */
266     private boolean isLeafClass() {
267         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
268     }
269 
270     /**
271      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
272      * type {@code type}.
273      *
274      * @return value of the subklass field as metaspace klass pointer
275      */
276     private HotSpotResolvedObjectTypeImpl getSubklass() {
277         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
278     }
279 
280     @Override
281     public HotSpotResolvedObjectTypeImpl getSuperclass() {
<a name="27" id="anc27"></a><span class="line-modified">282         Class&lt;?&gt; javaSuperclass = mirror().getSuperclass();</span>
<span class="line-modified">283         return javaSuperclass == null ? null : fromObjectClass(javaSuperclass);</span>














284     }
285 
286     @Override
287     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
288         if (interfaces == null) {
<a name="28" id="anc28"></a><span class="line-modified">289             Class&lt;?&gt;[] javaInterfaces = mirror().getInterfaces();</span>
<span class="line-modified">290             HotSpotResolvedObjectTypeImpl[] result = new HotSpotResolvedObjectTypeImpl[javaInterfaces.length];</span>
<span class="line-modified">291             for (int i = 0; i &lt; javaInterfaces.length; i++) {</span>
<span class="line-modified">292                 result[i] = fromObjectClass(javaInterfaces[i]);</span>



293             }
<a name="29" id="anc29"></a><span class="line-removed">294             interfaces = result;</span>
295         }
296         return interfaces;
297     }
298 
299     @Override
300     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
301         if (!isInterface()) {
302             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
303         }
304         return compilerToVM().getImplementor(this);
305     }
306 
307     @Override
308     public HotSpotResolvedObjectTypeImpl getSupertype() {
309         if (isArray()) {
310             ResolvedJavaType componentType = getComponentType();
<a name="30" id="anc30"></a><span class="line-modified">311             if (mirror() == Object[].class || componentType.isPrimitive()) {</span>
<span class="line-modified">312                 return fromObjectClass(Object.class);</span>
313             }
<a name="31" id="anc31"></a><span class="line-modified">314             return (HotSpotResolvedObjectTypeImpl) ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype().getArrayClass();</span>

315         }
316         if (isInterface()) {
<a name="32" id="anc32"></a><span class="line-modified">317             return fromObjectClass(Object.class);</span>
318         }
319         return getSuperclass();
320     }
321 
322     @Override
323     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
324         if (otherType.isPrimitive()) {
325             return null;
326         } else {
327             HotSpotResolvedObjectTypeImpl t1 = this;
328             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
329             while (true) {
330                 if (t1.isAssignableFrom(t2)) {
331                     return t1;
332                 }
333                 if (t2.isAssignableFrom(t1)) {
334                     return t2;
335                 }
336                 t1 = t1.getSupertype();
337                 t2 = t2.getSupertype();
338             }
339         }
340     }
341 
342     @Override
343     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
344         assert !isArray();
345         if (!compilerToVM().hasFinalizableSubclass(this)) {
346             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
347         }
348         return new AssumptionResult&lt;&gt;(true);
349     }
350 
351     @Override
352     public boolean hasFinalizer() {
353         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
354     }
355 
<a name="33" id="anc33"></a><span class="line-removed">356     @Override</span>
<span class="line-removed">357     public boolean isPrimitive() {</span>
<span class="line-removed">358         return false;</span>
<span class="line-removed">359     }</span>
<span class="line-removed">360 </span>
361     @Override
362     public boolean isArray() {
<a name="34" id="anc34"></a><span class="line-modified">363         return mirror().isArray();</span>
364     }
365 
366     @Override
367     public boolean isEnum() {
<a name="35" id="anc35"></a><span class="line-modified">368         return mirror().isEnum();</span>

369     }
370 
371     @Override
372     public boolean isInitialized() {
373         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
374     }
375 
<a name="36" id="anc36"></a>




376     @Override
377     public boolean isLinked() {
378         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
379     }
380 
381     /**
382      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
383      * klass.
384      *
385      * @return state field value of this type
386      */
387     private int getInitState() {
388         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
389         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
390     }
391 
392     @Override
393     public void initialize() {
394         if (!isInitialized()) {
<a name="37" id="anc37"></a><span class="line-modified">395             UNSAFE.ensureClassInitialized(mirror());</span>
<span class="line-modified">396             assert isInitialized();</span>
397         }
398     }
399 
400     @Override
401     public boolean isInstance(JavaConstant obj) {
402         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
<a name="38" id="anc38"></a><span class="line-modified">403             return mirror().isInstance(((HotSpotObjectConstantImpl) obj).object());</span>
404         }
405         return false;
406     }
407 
408     @Override
409     public boolean isInstanceClass() {
410         return !isArray() &amp;&amp; !isInterface();
411     }
412 
413     @Override
414     public boolean isInterface() {
<a name="39" id="anc39"></a><span class="line-modified">415         return mirror().isInterface();</span>
416     }
417 
418     @Override
419     public boolean isAssignableFrom(ResolvedJavaType other) {
420         assert other != null;
421         if (other instanceof HotSpotResolvedObjectTypeImpl) {
422             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
<a name="40" id="anc40"></a><span class="line-modified">423             return mirror().isAssignableFrom(otherType.mirror());</span>
424         }
425         return false;
426     }
427 
428     @Override
429     public ResolvedJavaType getHostClass() {
430         if (isArray()) {
431             return null;
432         }
433         return compilerToVM().getHostClass(this);
434     }
435 
436     @Override
437     public boolean isJavaLangObject() {
<a name="41" id="anc41"></a><span class="line-modified">438         return javaClass.equals(Object.class);</span>
439     }
440 
441     @Override
442     public JavaKind getJavaKind() {
443         return JavaKind.Object;
444     }
445 
446     @Override
447     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
448         assert !callerType.isArray();
449         if (isInterface()) {
450             // Methods can only be resolved against concrete types
451             return null;
452         }
453         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
454             return method;
455         }
456         if (!method.getDeclaringClass().isAssignableFrom(this)) {
457             return null;
458         }
459         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
460         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
461         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
462     }
463 
464     @Override
465     public HotSpotConstantPool getConstantPool() {
466         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
467             /*
468              * If the pointer to the ConstantPool has changed since this was last read refresh the
469              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
470              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
471              * use the shared copy instead of creating their own instance.
472              */
473             constantPool = compilerToVM().getConstantPool(this);
474         }
475         return constantPool;
476     }
477 
478     /**
479      * Gets the instance size of this type. If an instance of this type cannot be fast path
480      * allocated, then the returned value is negative (its absolute value gives the size). Must not
481      * be called if this is an array or interface type.
482      */
483     @Override
484     public int instanceSize() {
485         assert !isArray();
486         assert !isInterface();
487 
488         HotSpotVMConfig config = config();
489         final int layoutHelper = layoutHelper();
490         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
491 
492         // See: Klass::layout_helper_size_in_bytes
493         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
494 
495         // See: Klass::layout_helper_needs_slow_path
496         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
497 
498         return needsSlowPath ? -size : size;
499     }
500 
501     @Override
502     public int layoutHelper() {
503         HotSpotVMConfig config = config();
<a name="42" id="anc42"></a>
504         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
505     }
506 
507     @Override
508     public long getFingerprint() {
509         return compilerToVM().getFingerprint(getMetaspaceKlass());
510     }
511 
<a name="43" id="anc43"></a><span class="line-modified">512     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceMethod) {</span>

513         // Maintain cache as array.
514         if (methodCacheArray == null) {
515             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
516         }
517 
518         int i = 0;
519         for (; i &lt; methodCacheArray.length; ++i) {
520             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
521             if (curMethod == null) {
<a name="44" id="anc44"></a><span class="line-modified">522                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
523                 methodCacheArray[i] = newMethod;
<a name="45" id="anc45"></a><span class="line-removed">524                 context.add(newMethod);</span>
525                 return newMethod;
<a name="46" id="anc46"></a><span class="line-modified">526             } else if (curMethod.getMetaspacePointer() == metaspaceMethod) {</span>
527                 return curMethod;
528             }
529         }
530 
531         // Fall-back to hash table.
532         if (methodCacheHashMap == null) {
533             methodCacheHashMap = new HashMap&lt;&gt;();
534         }
535 
536         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
537         if (lookupResult == null) {
<a name="47" id="anc47"></a><span class="line-modified">538             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceMethod);</span>
539             methodCacheHashMap.put(metaspaceMethod, newMethod);
<a name="48" id="anc48"></a><span class="line-removed">540             context.add(lookupResult);</span>
541             return newMethod;
542         } else {
543             return lookupResult;
544         }
545     }
546 
547     @Override
548     public int getVtableLength() {
549         HotSpotVMConfig config = config();
550         if (isInterface() || isArray()) {
551             /* Everything has the core vtable of java.lang.Object */
552             return config.baseVtableLength();
553         }
554         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
555         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
556         return result;
557     }
558 
559     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
560         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
561     }
562 
563     @Override
564     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
565         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
566         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
567         /*
568          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
569          * holder, usually because of phis, so make sure that the type is related to the declared
570          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
571          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
572          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
573          */
574         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
<a name="49" id="anc49"></a>



575             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
576             if (result != null) {
577                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
578             }
579             return null;
580         }
581         /*
582          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
583          * the correct method for the subtype.
584          */
585         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
586         if (resolvedMethod == null) {
587             // The type isn&#39;t known to implement the method.
588             return null;
589         }
<a name="50" id="anc50"></a>



590 
591         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
592         if (result != null) {
593             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
594         }
595         return null;
596     }
597 
598     FieldInfo createFieldInfo(int index) {
599         return new FieldInfo(index);
600     }
601 
<a name="51" id="anc51"></a>




















602     /**
603      * This class represents the field information for one field contained in the fields array of an
604      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
605      */
606     class FieldInfo {
607         /**
608          * Native pointer into the array of Java shorts.
609          */
610         private final long metaspaceData;
611 
612         /**
613          * Creates a field info for the field in the fields array at index {@code index}.
614          *
615          * @param index index to the fields array
616          */
617         FieldInfo(int index) {
618             HotSpotVMConfig config = config();
619             // Get Klass::_fields
620             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
621             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
622             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
623             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
624         }
625 
626         private int getAccessFlags() {
627             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
628         }
629 
630         private int getNameIndex() {
631             return readFieldSlot(config().fieldInfoNameIndexOffset);
632         }
633 
634         private int getSignatureIndex() {
635             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
636         }
637 
638         public int getOffset() {
639             HotSpotVMConfig config = config();
640             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
641             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
642             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
643             return offset;
644         }
645 
646         /**
647          * Helper method to read an entry (slot) from the field array. Currently field info is laid
648          * on top an array of Java shorts.
649          */
650         private int readFieldSlot(int index) {
651             int offset = Short.BYTES * index;
652             return UNSAFE.getChar(metaspaceData + offset);
653         }
654 
655         /**
656          * Returns the name of this field as a {@link String}. If the field is an internal field the
657          * name index is pointing into the vmSymbols table.
658          */
659         public String getName() {
660             final int nameIndex = getNameIndex();
661             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
662         }
663 
664         /**
665          * Returns the signature of this field as {@link String}. If the field is an internal field
666          * the signature index is pointing into the vmSymbols table.
667          */
668         public String getSignature() {
669             final int signatureIndex = getSignatureIndex();
670             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
671         }
672 
673         public JavaType getType() {
674             String signature = getSignature();
675             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
676         }
677 
678         private boolean isInternal() {
679             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
680         }
681 
682         public boolean isStatic() {
683             return Modifier.isStatic(getAccessFlags());
684         }
685 
686         public boolean hasGenericSignature() {
687             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
688         }
689     }
690 
<a name="52" id="anc52"></a>





691     @Override
692     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
693         if (instanceFields == null) {
694             if (isArray() || isInterface()) {
695                 instanceFields = NO_FIELDS;
696             } else {
697                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
698                 if (getSuperclass() != null) {
699                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
700                 }
701                 instanceFields = getFields(false, prepend);
702             }
703         }
704         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
705             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
706             if (superClassFieldCount == instanceFields.length) {
707                 // This class does not have any instance fields of its own.
708                 return NO_FIELDS;
709             } else if (superClassFieldCount != 0) {
<a name="53" id="anc53"></a>


710                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
<a name="54" id="anc54"></a><span class="line-modified">711                 System.arraycopy(instanceFields, superClassFieldCount, result, 0, result.length);</span>






712                 return result;
713             } else {
714                 // The super classes of this class do not have any instance fields.
715             }
716         }
717         return instanceFields;
718     }
719 
720     @Override
721     public ResolvedJavaField[] getStaticFields() {
722         if (isArray()) {
723             return new HotSpotResolvedJavaField[0];
724         } else {
725             return getFields(true, NO_FIELDS);
726         }
727     }
728 
729     /**
730      * Gets the instance or static fields of this class.
731      *
732      * @param retrieveStaticFields specifies whether to return instance or static fields
733      * @param prepend an array to be prepended to the returned result
734      */
735     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
736         HotSpotVMConfig config = config();
737         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
738         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
739         int resultCount = 0;
740         int index = 0;
741         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
742             FieldInfo field = new FieldInfo(index);
743             if (field.hasGenericSignature()) {
744                 metaspaceFieldsLength--;
745             }
746 
747             if (field.isStatic() == retrieveStaticFields) {
748                 resultCount++;
749             }
750         }
751 
752         if (resultCount == 0) {
753             return prepend;
754         }
755 
756         int prependLength = prepend.length;
757         resultCount += prependLength;
758 
759         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
760         if (prependLength != 0) {
761             System.arraycopy(prepend, 0, result, 0, prependLength);
762         }
763 
<a name="55" id="anc55"></a>


764         int resultIndex = prependLength;
765         for (int i = 0; i &lt; index; ++i) {
766             FieldInfo field = new FieldInfo(i);
767             if (field.isStatic() == retrieveStaticFields) {
768                 int offset = field.getOffset();
769                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
<a name="56" id="anc56"></a><span class="line-modified">770 </span>
<span class="line-removed">771                 // Make sure the result is sorted by offset.</span>
<span class="line-removed">772                 int j;</span>
<span class="line-removed">773                 for (j = resultIndex - 1; j &gt;= prependLength &amp;&amp; result[j].getOffset() &gt; offset; j--) {</span>
<span class="line-removed">774                     result[j + 1] = result[j];</span>
<span class="line-removed">775                 }</span>
<span class="line-removed">776                 result[j + 1] = resolvedJavaField;</span>
<span class="line-removed">777                 resultIndex++;</span>
778             }
779         }
<a name="57" id="anc57"></a><span class="line-modified">780 </span>
781         return result;
782     }
783 
<a name="58" id="anc58"></a><span class="line-removed">784     @Override</span>
<span class="line-removed">785     public Class&lt;?&gt; mirror() {</span>
<span class="line-removed">786         return javaClass;</span>
<span class="line-removed">787     }</span>
<span class="line-removed">788 </span>
789     @Override
790     public String getSourceFileName() {
791         HotSpotVMConfig config = config();
792         final int sourceFileNameIndex = UNSAFE.getChar(getMetaspaceKlass() + config.instanceKlassSourceFileNameIndexOffset);
793         if (sourceFileNameIndex == 0) {
794             return null;
795         }
796         return getConstantPool().lookupUtf8(sourceFileNameIndex);
797     }
798 
799     @Override
800     public Annotation[] getAnnotations() {
<a name="59" id="anc59"></a><span class="line-modified">801         return mirror().getAnnotations();</span>
802     }
803 
804     @Override
805     public Annotation[] getDeclaredAnnotations() {
<a name="60" id="anc60"></a><span class="line-modified">806         return mirror().getDeclaredAnnotations();</span>
807     }
808 
809     @Override
810     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<a name="61" id="anc61"></a><span class="line-modified">811         return mirror().getAnnotation(annotationClass);</span>
812     }
813 
814     /**
815      * Performs a fast-path check that this type is resolved in the context of a given accessing
816      * class. A negative result does not mean this type is not resolved with respect to
817      * {@code accessingClass}. That can only be determined by
818      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
819      * re-resolving} the type.
820      */
821     @Override
822     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
823         assert accessingClass != null;
824         ResolvedJavaType elementType = getElementalType();
825         if (elementType.isPrimitive()) {
826             // Primitive type resolution is context free.
827             return true;
828         }
<a name="62" id="anc62"></a><span class="line-modified">829         if (elementType.getName().startsWith(&quot;Ljava/&quot;)) {</span>
<span class="line-modified">830             // Classes in a java.* package can only be defined by the</span>
<span class="line-removed">831             // boot or platform class loader.</span>
832             return true;
833         }
<a name="63" id="anc63"></a><span class="line-modified">834         ClassLoader thisCl = mirror().getClassLoader();</span>
<span class="line-modified">835         ClassLoader accessingClassCl = ((HotSpotResolvedObjectTypeImpl) accessingClass).mirror().getClassLoader();</span>
<span class="line-modified">836         return thisCl == accessingClassCl;</span>




837     }
838 
839     @Override
840     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
841         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
842             return this;
843         }
844         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
845         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
846     }
847 
848     /**
849      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
850      */
851     @Override
852     public Constant klass() {
853         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
854     }
855 
856     @Override
857     public boolean isPrimaryType() {
858         return config().secondarySuperCacheOffset != superCheckOffset();
859     }
860 
861     @Override
862     public int superCheckOffset() {
863         HotSpotVMConfig config = config();
864         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
865     }
866 
867     @Override
868     public long prototypeMarkWord() {
869         HotSpotVMConfig config = config();
870         if (isArray()) {
871             return config.arrayPrototypeMarkWord();
872         } else {
873             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
874         }
875     }
876 
877     @Override
878     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
879         ResolvedJavaField[] declaredFields = getInstanceFields(true);
880         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
881     }
882 
883     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
884         ResolvedJavaField[] declaredFields = getStaticFields();
885         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
886     }
887 
888     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
889         for (ResolvedJavaField field : declaredFields) {
<a name="64" id="anc64"></a><span class="line-modified">890             HotSpotResolvedJavaField resolvedField = (HotSpotResolvedJavaField) field;</span>
<span class="line-removed">891             long resolvedFieldOffset = resolvedField.getOffset();</span>
892             // @formatter:off
<a name="65" id="anc65"></a><span class="line-modified">893             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN  &amp;&amp;</span>
<span class="line-modified">894                             expectedEntryKind.isPrimitive() &amp;&amp;</span>
<span class="line-modified">895                             !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;</span>
<span class="line-modified">896                             resolvedField.getJavaKind().isPrimitive()) {</span>
897                 resolvedFieldOffset +=
<a name="66" id="anc66"></a><span class="line-modified">898                                 resolvedField.getJavaKind().getByteCount() -</span>
<span class="line-modified">899                                 Math.min(resolvedField.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());</span>
900             }
901             if (resolvedFieldOffset == offset) {
902                 return field;
903             }
904             // @formatter:on
905         }
906         return null;
907     }
908 
909     @Override
910     public boolean isLocal() {
<a name="67" id="anc67"></a><span class="line-modified">911         return mirror().isLocalClass();</span>
912     }
913 
914     @Override
915     public boolean isMember() {
<a name="68" id="anc68"></a><span class="line-modified">916         return mirror().isMemberClass();</span>
917     }
918 
919     @Override
<a name="69" id="anc69"></a><span class="line-modified">920     public HotSpotResolvedObjectTypeImpl getEnclosingType() {</span>
<span class="line-modified">921         final Class&lt;?&gt; encl = mirror().getEnclosingClass();</span>
<span class="line-removed">922         return encl == null ? null : fromObjectClass(encl);</span>
923     }
924 
925     @Override
926     public ResolvedJavaMethod[] getDeclaredConstructors() {
<a name="70" id="anc70"></a><span class="line-modified">927         Constructor&lt;?&gt;[] constructors = mirror().getDeclaredConstructors();</span>
<span class="line-removed">928         ResolvedJavaMethod[] result = new ResolvedJavaMethod[constructors.length];</span>
<span class="line-removed">929         for (int i = 0; i &lt; constructors.length; i++) {</span>
<span class="line-removed">930             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(constructors[i]);</span>
<span class="line-removed">931             assert result[i].isConstructor();</span>
<span class="line-removed">932         }</span>
<span class="line-removed">933         return result;</span>
934     }
935 
936     @Override
937     public ResolvedJavaMethod[] getDeclaredMethods() {
<a name="71" id="anc71"></a><span class="line-modified">938         Method[] methods = mirror().getDeclaredMethods();</span>
<span class="line-removed">939         ResolvedJavaMethod[] result = new ResolvedJavaMethod[methods.length];</span>
<span class="line-removed">940         for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="line-removed">941             result[i] = runtime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(methods[i]);</span>
<span class="line-removed">942             assert !result[i].isConstructor();</span>
<span class="line-removed">943         }</span>
<span class="line-removed">944         return result;</span>
945     }
946 
947     @Override
948     public ResolvedJavaMethod getClassInitializer() {
949         if (!isArray()) {
950             return compilerToVM().getClassInitializer(this);
951         }
952         return null;
953     }
954 
955     @Override
956     public String toString() {
957         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
958     }
959 
960     @Override
961     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
962         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
963         if (javaType instanceof ResolvedJavaType) {
964             return (ResolvedJavaType) javaType;
965         }
966         return null;
967     }
968 
969     @Override
970     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
971         for (ResolvedJavaField field : getInstanceFields(false)) {
972             if (field.getName().equals(unresolvedJavaField.getName())) {
973                 return field;
974             }
975         }
976         for (ResolvedJavaField field : getStaticFields()) {
977             if (field.getName().equals(unresolvedJavaField.getName())) {
978                 return field;
979             }
980         }
981         throw new InternalError(unresolvedJavaField.toString());
982     }
983 
984     @Override
985     public boolean isCloneableWithAllocation() {
986         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
987     }
988 
<a name="72" id="anc72"></a>



989     private int getMiscFlags() {
990         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
991     }
992 
993     @Override
994     public boolean isUnsafeAnonymous() {
995         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
996     }
997 
998 }
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>