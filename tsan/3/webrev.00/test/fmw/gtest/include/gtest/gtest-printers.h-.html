<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/gtest-printers.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2007, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Author: wan@google.com (Zhanyong Wan)
 31 
 32 // Google Test - The Google C++ Testing Framework
 33 //
 34 // This file implements a universal value printer that can print a
 35 // value of any type T:
 36 //
 37 //   void ::testing::internal::UniversalPrinter&lt;T&gt;::Print(value, ostream_ptr);
 38 //
 39 // A user can teach this function how to print a class type T by
 40 // defining either operator&lt;&lt;() or PrintTo() in the namespace that
 41 // defines T.  More specifically, the FIRST defined function in the
 42 // following list will be used (assuming T is defined in namespace
 43 // foo):
 44 //
 45 //   1. foo::PrintTo(const T&amp;, ostream*)
 46 //   2. operator&lt;&lt;(ostream&amp;, const T&amp;) defined in either foo or the
 47 //      global namespace.
 48 //
 49 // If none of the above is defined, it will print the debug string of
 50 // the value if it is a protocol buffer, or print the raw bytes in the
 51 // value otherwise.
 52 //
 53 // To aid debugging: when T is a reference type, the address of the
 54 // value is also printed; when T is a (const) char pointer, both the
 55 // pointer value and the NUL-terminated string it points to are
 56 // printed.
 57 //
 58 // We also provide some convenient wrappers:
 59 //
 60 //   // Prints a value to a string.  For a (const or not) char
 61 //   // pointer, the NUL-terminated string (but not the pointer) is
 62 //   // printed.
 63 //   std::string ::testing::PrintToString(const T&amp; value);
 64 //
 65 //   // Prints a value tersely: for a reference type, the referenced
 66 //   // value (but not the address) is printed; for a (const or not) char
 67 //   // pointer, the NUL-terminated string (but not the pointer) is
 68 //   // printed.
 69 //   void ::testing::internal::UniversalTersePrint(const T&amp; value, ostream*);
 70 //
 71 //   // Prints value using the type inferred by the compiler.  The difference
 72 //   // from UniversalTersePrint() is that this function prints both the
 73 //   // pointer and the NUL-terminated string for a (const or not) char pointer.
 74 //   void ::testing::internal::UniversalPrint(const T&amp; value, ostream*);
 75 //
 76 //   // Prints the fields of a tuple tersely to a string vector, one
 77 //   // element for each field. Tuple support must be enabled in
 78 //   // gtest-port.h.
 79 //   std::vector&lt;string&gt; UniversalTersePrintTupleFieldsToStrings(
 80 //       const Tuple&amp; value);
 81 //
 82 // Known limitation:
 83 //
 84 // The print primitives print the elements of an STL-style container
 85 // using the compiler-inferred type of *iter where iter is a
 86 // const_iterator of the container.  When const_iterator is an input
 87 // iterator but not a forward iterator, this inferred type may not
 88 // match value_type, and the print output may be incorrect.  In
 89 // practice, this is rarely a problem as for most containers
 90 // const_iterator is a forward iterator.  We&#39;ll fix this if there&#39;s an
 91 // actual need for it.  Note that this fix cannot rely on value_type
 92 // being defined as many user-defined container types don&#39;t have
 93 // value_type.
 94 
 95 #ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
 96 #define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
 97 
 98 #include &lt;ostream&gt;  // NOLINT
 99 #include &lt;sstream&gt;
100 #include &lt;string&gt;
101 #include &lt;utility&gt;
102 #include &lt;vector&gt;
103 #include &quot;gtest/internal/gtest-port.h&quot;
104 #include &quot;gtest/internal/gtest-internal.h&quot;
105 
106 namespace testing {
107 
108 // Definitions in the &#39;internal&#39; and &#39;internal2&#39; name spaces are
109 // subject to change without notice.  DO NOT USE THEM IN USER CODE!
110 namespace internal2 {
111 
112 // Prints the given number of bytes in the given object to the given
113 // ostream.
114 GTEST_API_ void PrintBytesInObjectTo(const unsigned char* obj_bytes,
115                                      size_t count,
116                                      ::std::ostream* os);
117 
118 // For selecting which printer to use when a given type has neither &lt;&lt;
119 // nor PrintTo().
120 enum TypeKind {
121   kProtobuf,              // a protobuf type
122   kConvertibleToInteger,  // a type implicitly convertible to BiggestInt
123                           // (e.g. a named or unnamed enum type)
124   kOtherType              // anything else
125 };
126 
127 // TypeWithoutFormatter&lt;T, kTypeKind&gt;::PrintValue(value, os) is called
128 // by the universal printer to print a value of type T when neither
129 // operator&lt;&lt; nor PrintTo() is defined for T, where kTypeKind is the
130 // &quot;kind&quot; of T as defined by enum TypeKind.
131 template &lt;typename T, TypeKind kTypeKind&gt;
132 class TypeWithoutFormatter {
133  public:
134   // This default version is called when kTypeKind is kOtherType.
135   static void PrintValue(const T&amp; value, ::std::ostream* os) {
136     PrintBytesInObjectTo(reinterpret_cast&lt;const unsigned char*&gt;(&amp;value),
137                          sizeof(value), os);
138   }
139 };
140 
141 // We print a protobuf using its ShortDebugString() when the string
142 // doesn&#39;t exceed this many characters; otherwise we print it using
143 // DebugString() for better readability.
144 const size_t kProtobufOneLinerMaxLength = 50;
145 
146 template &lt;typename T&gt;
147 class TypeWithoutFormatter&lt;T, kProtobuf&gt; {
148  public:
149   static void PrintValue(const T&amp; value, ::std::ostream* os) {
150     const ::testing::internal::string short_str = value.ShortDebugString();
151     const ::testing::internal::string pretty_str =
152         short_str.length() &lt;= kProtobufOneLinerMaxLength ?
153         short_str : (&quot;\n&quot; + value.DebugString());
154     *os &lt;&lt; (&quot;&lt;&quot; + pretty_str + &quot;&gt;&quot;);
155   }
156 };
157 
158 template &lt;typename T&gt;
159 class TypeWithoutFormatter&lt;T, kConvertibleToInteger&gt; {
160  public:
161   // Since T has no &lt;&lt; operator or PrintTo() but can be implicitly
162   // converted to BiggestInt, we print it as a BiggestInt.
163   //
164   // Most likely T is an enum type (either named or unnamed), in which
165   // case printing it as an integer is the desired behavior.  In case
166   // T is not an enum, printing it as an integer is the best we can do
167   // given that it has no user-defined printer.
168   static void PrintValue(const T&amp; value, ::std::ostream* os) {
169     const internal::BiggestInt kBigInt = value;
170     *os &lt;&lt; kBigInt;
171   }
172 };
173 
174 // Prints the given value to the given ostream.  If the value is a
175 // protocol message, its debug string is printed; if it&#39;s an enum or
176 // of a type implicitly convertible to BiggestInt, it&#39;s printed as an
177 // integer; otherwise the bytes in the value are printed.  This is
178 // what UniversalPrinter&lt;T&gt;::Print() does when it knows nothing about
179 // type T and T has neither &lt;&lt; operator nor PrintTo().
180 //
181 // A user can override this behavior for a class type Foo by defining
182 // a &lt;&lt; operator in the namespace where Foo is defined.
183 //
184 // We put this operator in namespace &#39;internal2&#39; instead of &#39;internal&#39;
185 // to simplify the implementation, as much code in &#39;internal&#39; needs to
186 // use &lt;&lt; in STL, which would conflict with our own &lt;&lt; were it defined
187 // in &#39;internal&#39;.
188 //
189 // Note that this operator&lt;&lt; takes a generic std::basic_ostream&lt;Char,
190 // CharTraits&gt; type instead of the more restricted std::ostream.  If
191 // we define it to take an std::ostream instead, we&#39;ll get an
192 // &quot;ambiguous overloads&quot; compiler error when trying to print a type
193 // Foo that supports streaming to std::basic_ostream&lt;Char,
194 // CharTraits&gt;, as the compiler cannot tell whether
195 // operator&lt;&lt;(std::ostream&amp;, const T&amp;) or
196 // operator&lt;&lt;(std::basic_stream&lt;Char, CharTraits&gt;, const Foo&amp;) is more
197 // specific.
198 template &lt;typename Char, typename CharTraits, typename T&gt;
199 ::std::basic_ostream&lt;Char, CharTraits&gt;&amp; operator&lt;&lt;(
200     ::std::basic_ostream&lt;Char, CharTraits&gt;&amp; os, const T&amp; x) {
201   TypeWithoutFormatter&lt;T,
202       (internal::IsAProtocolMessage&lt;T&gt;::value ? kProtobuf :
203        internal::ImplicitlyConvertible&lt;const T&amp;, internal::BiggestInt&gt;::value ?
204        kConvertibleToInteger : kOtherType)&gt;::PrintValue(x, &amp;os);
205   return os;
206 }
207 
208 }  // namespace internal2
209 }  // namespace testing
210 
211 // This namespace MUST NOT BE NESTED IN ::testing, or the name look-up
212 // magic needed for implementing UniversalPrinter won&#39;t work.
213 namespace testing_internal {
214 
215 // Used to print a value that is not an STL-style container when the
216 // user doesn&#39;t define PrintTo() for it.
217 template &lt;typename T&gt;
218 void DefaultPrintNonContainerTo(const T&amp; value, ::std::ostream* os) {
219   // With the following statement, during unqualified name lookup,
220   // testing::internal2::operator&lt;&lt; appears as if it was declared in
221   // the nearest enclosing namespace that contains both
222   // ::testing_internal and ::testing::internal2, i.e. the global
223   // namespace.  For more details, refer to the C++ Standard section
224   // 7.3.4-1 [namespace.udir].  This allows us to fall back onto
225   // testing::internal2::operator&lt;&lt; in case T doesn&#39;t come with a &lt;&lt;
226   // operator.
227   //
228   // We cannot write &#39;using ::testing::internal2::operator&lt;&lt;;&#39;, which
229   // gcc 3.3 fails to compile due to a compiler bug.
230   using namespace ::testing::internal2;  // NOLINT
231 
232   // Assuming T is defined in namespace foo, in the next statement,
233   // the compiler will consider all of:
234   //
235   //   1. foo::operator&lt;&lt; (thanks to Koenig look-up),
236   //   2. ::operator&lt;&lt; (as the current namespace is enclosed in ::),
237   //   3. testing::internal2::operator&lt;&lt; (thanks to the using statement above).
238   //
239   // The operator&lt;&lt; whose type matches T best will be picked.
240   //
241   // We deliberately allow #2 to be a candidate, as sometimes it&#39;s
242   // impossible to define #1 (e.g. when foo is ::std, defining
243   // anything in it is undefined behavior unless you are a compiler
244   // vendor.).
245   *os &lt;&lt; value;
246 }
247 
248 }  // namespace testing_internal
249 
250 namespace testing {
251 namespace internal {
252 
253 // UniversalPrinter&lt;T&gt;::Print(value, ostream_ptr) prints the given
254 // value to the given ostream.  The caller must ensure that
255 // &#39;ostream_ptr&#39; is not NULL, or the behavior is undefined.
256 //
257 // We define UniversalPrinter as a class template (as opposed to a
258 // function template), as we need to partially specialize it for
259 // reference types, which cannot be done with function templates.
260 template &lt;typename T&gt;
261 class UniversalPrinter;
262 
263 template &lt;typename T&gt;
264 void UniversalPrint(const T&amp; value, ::std::ostream* os);
265 
266 // Used to print an STL-style container when the user doesn&#39;t define
267 // a PrintTo() for it.
268 template &lt;typename C&gt;
269 void DefaultPrintTo(IsContainer /* dummy */,
270                     false_type /* is not a pointer */,
271                     const C&amp; container, ::std::ostream* os) {
272   const size_t kMaxCount = 32;  // The maximum number of elements to print.
273   *os &lt;&lt; &#39;{&#39;;
274   size_t count = 0;
275   for (typename C::const_iterator it = container.begin();
276        it != container.end(); ++it, ++count) {
277     if (count &gt; 0) {
278       *os &lt;&lt; &#39;,&#39;;
279       if (count == kMaxCount) {  // Enough has been printed.
280         *os &lt;&lt; &quot; ...&quot;;
281         break;
282       }
283     }
284     *os &lt;&lt; &#39; &#39;;
285     // We cannot call PrintTo(*it, os) here as PrintTo() doesn&#39;t
286     // handle *it being a native array.
287     internal::UniversalPrint(*it, os);
288   }
289 
290   if (count &gt; 0) {
291     *os &lt;&lt; &#39; &#39;;
292   }
293   *os &lt;&lt; &#39;}&#39;;
294 }
295 
296 // Used to print a pointer that is neither a char pointer nor a member
297 // pointer, when the user doesn&#39;t define PrintTo() for it.  (A member
298 // variable pointer or member function pointer doesn&#39;t really point to
299 // a location in the address space.  Their representation is
300 // implementation-defined.  Therefore they will be printed as raw
301 // bytes.)
302 template &lt;typename T&gt;
303 void DefaultPrintTo(IsNotContainer /* dummy */,
304                     true_type /* is a pointer */,
305                     T* p, ::std::ostream* os) {
306   if (p == NULL) {
307     *os &lt;&lt; &quot;NULL&quot;;
308   } else {
309     // C++ doesn&#39;t allow casting from a function pointer to any object
310     // pointer.
311     //
312     // IsTrue() silences warnings: &quot;Condition is always true&quot;,
313     // &quot;unreachable code&quot;.
314     if (IsTrue(ImplicitlyConvertible&lt;T*, const void*&gt;::value)) {
315       // T is not a function type.  We just call &lt;&lt; to print p,
316       // relying on ADL to pick up user-defined &lt;&lt; for their pointer
317       // types, if any.
318       *os &lt;&lt; p;
319     } else {
320       // T is a function type, so &#39;*os &lt;&lt; p&#39; doesn&#39;t do what we want
321       // (it just prints p as bool).  We want to print p as a const
322       // void*.  However, we cannot cast it to const void* directly,
323       // even using reinterpret_cast, as earlier versions of gcc
324       // (e.g. 3.4.5) cannot compile the cast when p is a function
325       // pointer.  Casting to UInt64 first solves the problem.
326       *os &lt;&lt; reinterpret_cast&lt;const void*&gt;(
327           reinterpret_cast&lt;internal::UInt64&gt;(p));
328     }
329   }
330 }
331 
332 // Used to print a non-container, non-pointer value when the user
333 // doesn&#39;t define PrintTo() for it.
334 template &lt;typename T&gt;
335 void DefaultPrintTo(IsNotContainer /* dummy */,
336                     false_type /* is not a pointer */,
337                     const T&amp; value, ::std::ostream* os) {
338   ::testing_internal::DefaultPrintNonContainerTo(value, os);
339 }
340 
341 // Prints the given value using the &lt;&lt; operator if it has one;
342 // otherwise prints the bytes in it.  This is what
343 // UniversalPrinter&lt;T&gt;::Print() does when PrintTo() is not specialized
344 // or overloaded for type T.
345 //
346 // A user can override this behavior for a class type Foo by defining
347 // an overload of PrintTo() in the namespace where Foo is defined.  We
348 // give the user this option as sometimes defining a &lt;&lt; operator for
349 // Foo is not desirable (e.g. the coding style may prevent doing it,
350 // or there is already a &lt;&lt; operator but it doesn&#39;t do what the user
351 // wants).
352 template &lt;typename T&gt;
353 void PrintTo(const T&amp; value, ::std::ostream* os) {
354   // DefaultPrintTo() is overloaded.  The type of its first two
355   // arguments determine which version will be picked.  If T is an
356   // STL-style container, the version for container will be called; if
357   // T is a pointer, the pointer version will be called; otherwise the
358   // generic version will be called.
359   //
360   // Note that we check for container types here, prior to we check
361   // for protocol message types in our operator&lt;&lt;.  The rationale is:
362   //
363   // For protocol messages, we want to give people a chance to
364   // override Google Mock&#39;s format by defining a PrintTo() or
365   // operator&lt;&lt;.  For STL containers, other formats can be
366   // incompatible with Google Mock&#39;s format for the container
367   // elements; therefore we check for container types here to ensure
368   // that our format is used.
369   //
370   // The second argument of DefaultPrintTo() is needed to bypass a bug
371   // in Symbian&#39;s C++ compiler that prevents it from picking the right
372   // overload between:
373   //
374   //   PrintTo(const T&amp; x, ...);
375   //   PrintTo(T* x, ...);
376   DefaultPrintTo(IsContainerTest&lt;T&gt;(0), is_pointer&lt;T&gt;(), value, os);
377 }
378 
379 // The following list of PrintTo() overloads tells
380 // UniversalPrinter&lt;T&gt;::Print() how to print standard types (built-in
381 // types, strings, plain arrays, and pointers).
382 
383 // Overloads for various char types.
384 GTEST_API_ void PrintTo(unsigned char c, ::std::ostream* os);
385 GTEST_API_ void PrintTo(signed char c, ::std::ostream* os);
386 inline void PrintTo(char c, ::std::ostream* os) {
387   // When printing a plain char, we always treat it as unsigned.  This
388   // way, the output won&#39;t be affected by whether the compiler thinks
389   // char is signed or not.
390   PrintTo(static_cast&lt;unsigned char&gt;(c), os);
391 }
392 
393 // Overloads for other simple built-in types.
394 inline void PrintTo(bool x, ::std::ostream* os) {
395   *os &lt;&lt; (x ? &quot;true&quot; : &quot;false&quot;);
396 }
397 
398 // Overload for wchar_t type.
399 // Prints a wchar_t as a symbol if it is printable or as its internal
400 // code otherwise and also as its decimal code (except for L&#39;\0&#39;).
401 // The L&#39;\0&#39; char is printed as &quot;L&#39;\\0&#39;&quot;. The decimal code is printed
402 // as signed integer when wchar_t is implemented by the compiler
403 // as a signed type and is printed as an unsigned integer when wchar_t
404 // is implemented as an unsigned type.
405 GTEST_API_ void PrintTo(wchar_t wc, ::std::ostream* os);
406 
407 // Overloads for C strings.
408 GTEST_API_ void PrintTo(const char* s, ::std::ostream* os);
409 inline void PrintTo(char* s, ::std::ostream* os) {
410   PrintTo(ImplicitCast_&lt;const char*&gt;(s), os);
411 }
412 
413 // signed/unsigned char is often used for representing binary data, so
414 // we print pointers to it as void* to be safe.
415 inline void PrintTo(const signed char* s, ::std::ostream* os) {
416   PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);
417 }
418 inline void PrintTo(signed char* s, ::std::ostream* os) {
419   PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);
420 }
421 inline void PrintTo(const unsigned char* s, ::std::ostream* os) {
422   PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);
423 }
424 inline void PrintTo(unsigned char* s, ::std::ostream* os) {
425   PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);
426 }
427 
428 // MSVC can be configured to define wchar_t as a typedef of unsigned
429 // short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native
430 // type.  When wchar_t is a typedef, defining an overload for const
431 // wchar_t* would cause unsigned short* be printed as a wide string,
432 // possibly causing invalid memory accesses.
433 #if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
434 // Overloads for wide C strings
435 GTEST_API_ void PrintTo(const wchar_t* s, ::std::ostream* os);
436 inline void PrintTo(wchar_t* s, ::std::ostream* os) {
437   PrintTo(ImplicitCast_&lt;const wchar_t*&gt;(s), os);
438 }
439 #endif
440 
441 // Overload for C arrays.  Multi-dimensional arrays are printed
442 // properly.
443 
444 // Prints the given number of elements in an array, without printing
445 // the curly braces.
446 template &lt;typename T&gt;
447 void PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {
448   UniversalPrint(a[0], os);
449   for (size_t i = 1; i != count; i++) {
450     *os &lt;&lt; &quot;, &quot;;
451     UniversalPrint(a[i], os);
452   }
453 }
454 
455 // Overloads for ::string and ::std::string.
456 #if GTEST_HAS_GLOBAL_STRING
457 GTEST_API_ void PrintStringTo(const ::string&amp;s, ::std::ostream* os);
458 inline void PrintTo(const ::string&amp; s, ::std::ostream* os) {
459   PrintStringTo(s, os);
460 }
461 #endif  // GTEST_HAS_GLOBAL_STRING
462 
463 GTEST_API_ void PrintStringTo(const ::std::string&amp;s, ::std::ostream* os);
464 inline void PrintTo(const ::std::string&amp; s, ::std::ostream* os) {
465   PrintStringTo(s, os);
466 }
467 
468 // Overloads for ::wstring and ::std::wstring.
469 #if GTEST_HAS_GLOBAL_WSTRING
470 GTEST_API_ void PrintWideStringTo(const ::wstring&amp;s, ::std::ostream* os);
471 inline void PrintTo(const ::wstring&amp; s, ::std::ostream* os) {
472   PrintWideStringTo(s, os);
473 }
474 #endif  // GTEST_HAS_GLOBAL_WSTRING
475 
476 #if GTEST_HAS_STD_WSTRING
477 GTEST_API_ void PrintWideStringTo(const ::std::wstring&amp;s, ::std::ostream* os);
478 inline void PrintTo(const ::std::wstring&amp; s, ::std::ostream* os) {
479   PrintWideStringTo(s, os);
480 }
481 #endif  // GTEST_HAS_STD_WSTRING
482 
483 #if GTEST_HAS_TR1_TUPLE
484 // Overload for ::std::tr1::tuple.  Needed for printing function arguments,
485 // which are packed as tuples.
486 
487 // Helper function for printing a tuple.  T must be instantiated with
488 // a tuple type.
489 template &lt;typename T&gt;
490 void PrintTupleTo(const T&amp; t, ::std::ostream* os);
491 
492 // Overloaded PrintTo() for tuples of various arities.  We support
493 // tuples of up-to 10 fields.  The following implementation works
494 // regardless of whether tr1::tuple is implemented using the
495 // non-standard variadic template feature or not.
496 
497 inline void PrintTo(const ::std::tr1::tuple&lt;&gt;&amp; t, ::std::ostream* os) {
498   PrintTupleTo(t, os);
499 }
500 
501 template &lt;typename T1&gt;
502 void PrintTo(const ::std::tr1::tuple&lt;T1&gt;&amp; t, ::std::ostream* os) {
503   PrintTupleTo(t, os);
504 }
505 
506 template &lt;typename T1, typename T2&gt;
507 void PrintTo(const ::std::tr1::tuple&lt;T1, T2&gt;&amp; t, ::std::ostream* os) {
508   PrintTupleTo(t, os);
509 }
510 
511 template &lt;typename T1, typename T2, typename T3&gt;
512 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3&gt;&amp; t, ::std::ostream* os) {
513   PrintTupleTo(t, os);
514 }
515 
516 template &lt;typename T1, typename T2, typename T3, typename T4&gt;
517 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4&gt;&amp; t, ::std::ostream* os) {
518   PrintTupleTo(t, os);
519 }
520 
521 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
522 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5&gt;&amp; t,
523              ::std::ostream* os) {
524   PrintTupleTo(t, os);
525 }
526 
527 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
528           typename T6&gt;
529 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5, T6&gt;&amp; t,
530              ::std::ostream* os) {
531   PrintTupleTo(t, os);
532 }
533 
534 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
535           typename T6, typename T7&gt;
536 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5, T6, T7&gt;&amp; t,
537              ::std::ostream* os) {
538   PrintTupleTo(t, os);
539 }
540 
541 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
542           typename T6, typename T7, typename T8&gt;
543 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;&amp; t,
544              ::std::ostream* os) {
545   PrintTupleTo(t, os);
546 }
547 
548 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
549           typename T6, typename T7, typename T8, typename T9&gt;
550 void PrintTo(const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;&amp; t,
551              ::std::ostream* os) {
552   PrintTupleTo(t, os);
553 }
554 
555 template &lt;typename T1, typename T2, typename T3, typename T4, typename T5,
556           typename T6, typename T7, typename T8, typename T9, typename T10&gt;
557 void PrintTo(
558     const ::std::tr1::tuple&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10&gt;&amp; t,
559     ::std::ostream* os) {
560   PrintTupleTo(t, os);
561 }
562 #endif  // GTEST_HAS_TR1_TUPLE
563 
564 // Overload for std::pair.
565 template &lt;typename T1, typename T2&gt;
566 void PrintTo(const ::std::pair&lt;T1, T2&gt;&amp; value, ::std::ostream* os) {
567   *os &lt;&lt; &#39;(&#39;;
568   // We cannot use UniversalPrint(value.first, os) here, as T1 may be
569   // a reference type.  The same for printing value.second.
570   UniversalPrinter&lt;T1&gt;::Print(value.first, os);
571   *os &lt;&lt; &quot;, &quot;;
572   UniversalPrinter&lt;T2&gt;::Print(value.second, os);
573   *os &lt;&lt; &#39;)&#39;;
574 }
575 
576 // Implements printing a non-reference type T by letting the compiler
577 // pick the right overload of PrintTo() for T.
578 template &lt;typename T&gt;
579 class UniversalPrinter {
580  public:
581   // MSVC warns about adding const to a function type, so we want to
582   // disable the warning.
583 #ifdef _MSC_VER
584 # pragma warning(push)          // Saves the current warning state.
585 # pragma warning(disable:4180)  // Temporarily disables warning 4180.
586 #endif  // _MSC_VER
587 
588   // Note: we deliberately don&#39;t call this PrintTo(), as that name
589   // conflicts with ::testing::internal::PrintTo in the body of the
590   // function.
591   static void Print(const T&amp; value, ::std::ostream* os) {
592     // By default, ::testing::internal::PrintTo() is used for printing
593     // the value.
594     //
595     // Thanks to Koenig look-up, if T is a class and has its own
596     // PrintTo() function defined in its namespace, that function will
597     // be visible here.  Since it is more specific than the generic ones
598     // in ::testing::internal, it will be picked by the compiler in the
599     // following statement - exactly what we want.
600     PrintTo(value, os);
601   }
602 
603 #ifdef _MSC_VER
604 # pragma warning(pop)           // Restores the warning state.
605 #endif  // _MSC_VER
606 };
607 
608 // UniversalPrintArray(begin, len, os) prints an array of &#39;len&#39;
609 // elements, starting at address &#39;begin&#39;.
610 template &lt;typename T&gt;
611 void UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {
612   if (len == 0) {
613     *os &lt;&lt; &quot;{}&quot;;
614   } else {
615     *os &lt;&lt; &quot;{ &quot;;
616     const size_t kThreshold = 18;
617     const size_t kChunkSize = 8;
618     // If the array has more than kThreshold elements, we&#39;ll have to
619     // omit some details by printing only the first and the last
620     // kChunkSize elements.
621     // TODO(wan@google.com): let the user control the threshold using a flag.
622     if (len &lt;= kThreshold) {
623       PrintRawArrayTo(begin, len, os);
624     } else {
625       PrintRawArrayTo(begin, kChunkSize, os);
626       *os &lt;&lt; &quot;, ..., &quot;;
627       PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);
628     }
629     *os &lt;&lt; &quot; }&quot;;
630   }
631 }
632 // This overload prints a (const) char array compactly.
633 GTEST_API_ void UniversalPrintArray(
634     const char* begin, size_t len, ::std::ostream* os);
635 
636 // This overload prints a (const) wchar_t array compactly.
637 GTEST_API_ void UniversalPrintArray(
638     const wchar_t* begin, size_t len, ::std::ostream* os);
639 
640 // Implements printing an array type T[N].
641 template &lt;typename T, size_t N&gt;
642 class UniversalPrinter&lt;T[N]&gt; {
643  public:
644   // Prints the given array, omitting some elements when there are too
645   // many.
646   static void Print(const T (&amp;a)[N], ::std::ostream* os) {
647     UniversalPrintArray(a, N, os);
648   }
649 };
650 
651 // Implements printing a reference type T&amp;.
652 template &lt;typename T&gt;
653 class UniversalPrinter&lt;T&amp;&gt; {
654  public:
655   // MSVC warns about adding const to a function type, so we want to
656   // disable the warning.
657 #ifdef _MSC_VER
658 # pragma warning(push)          // Saves the current warning state.
659 # pragma warning(disable:4180)  // Temporarily disables warning 4180.
660 #endif  // _MSC_VER
661 
662   static void Print(const T&amp; value, ::std::ostream* os) {
663     // Prints the address of the value.  We use reinterpret_cast here
664     // as static_cast doesn&#39;t compile when T is a function type.
665     *os &lt;&lt; &quot;@&quot; &lt;&lt; reinterpret_cast&lt;const void*&gt;(&amp;value) &lt;&lt; &quot; &quot;;
666 
667     // Then prints the value itself.
668     UniversalPrint(value, os);
669   }
670 
671 #ifdef _MSC_VER
672 # pragma warning(pop)           // Restores the warning state.
673 #endif  // _MSC_VER
674 };
675 
676 // Prints a value tersely: for a reference type, the referenced value
677 // (but not the address) is printed; for a (const) char pointer, the
678 // NUL-terminated string (but not the pointer) is printed.
679 
680 template &lt;typename T&gt;
681 class UniversalTersePrinter {
682  public:
683   static void Print(const T&amp; value, ::std::ostream* os) {
684     UniversalPrint(value, os);
685   }
686 };
687 template &lt;typename T&gt;
688 class UniversalTersePrinter&lt;T&amp;&gt; {
689  public:
690   static void Print(const T&amp; value, ::std::ostream* os) {
691     UniversalPrint(value, os);
692   }
693 };
694 template &lt;typename T, size_t N&gt;
695 class UniversalTersePrinter&lt;T[N]&gt; {
696  public:
697   static void Print(const T (&amp;value)[N], ::std::ostream* os) {
698     UniversalPrinter&lt;T[N]&gt;::Print(value, os);
699   }
700 };
701 template &lt;&gt;
702 class UniversalTersePrinter&lt;const char*&gt; {
703  public:
704   static void Print(const char* str, ::std::ostream* os) {
705     if (str == NULL) {
706       *os &lt;&lt; &quot;NULL&quot;;
707     } else {
708       UniversalPrint(string(str), os);
709     }
710   }
711 };
712 template &lt;&gt;
713 class UniversalTersePrinter&lt;char*&gt; {
714  public:
715   static void Print(char* str, ::std::ostream* os) {
716     UniversalTersePrinter&lt;const char*&gt;::Print(str, os);
717   }
718 };
719 
720 #if GTEST_HAS_STD_WSTRING
721 template &lt;&gt;
722 class UniversalTersePrinter&lt;const wchar_t*&gt; {
723  public:
724   static void Print(const wchar_t* str, ::std::ostream* os) {
725     if (str == NULL) {
726       *os &lt;&lt; &quot;NULL&quot;;
727     } else {
728       UniversalPrint(::std::wstring(str), os);
729     }
730   }
731 };
732 #endif
733 
734 template &lt;&gt;
735 class UniversalTersePrinter&lt;wchar_t*&gt; {
736  public:
737   static void Print(wchar_t* str, ::std::ostream* os) {
738     UniversalTersePrinter&lt;const wchar_t*&gt;::Print(str, os);
739   }
740 };
741 
742 template &lt;typename T&gt;
743 void UniversalTersePrint(const T&amp; value, ::std::ostream* os) {
744   UniversalTersePrinter&lt;T&gt;::Print(value, os);
745 }
746 
747 // Prints a value using the type inferred by the compiler.  The
748 // difference between this and UniversalTersePrint() is that for a
749 // (const) char pointer, this prints both the pointer and the
750 // NUL-terminated string.
751 template &lt;typename T&gt;
752 void UniversalPrint(const T&amp; value, ::std::ostream* os) {
753   // A workarond for the bug in VC++ 7.1 that prevents us from instantiating
754   // UniversalPrinter with T directly.
755   typedef T T1;
756   UniversalPrinter&lt;T1&gt;::Print(value, os);
757 }
758 
759 #if GTEST_HAS_TR1_TUPLE
760 typedef ::std::vector&lt;string&gt; Strings;
761 
762 // This helper template allows PrintTo() for tuples and
763 // UniversalTersePrintTupleFieldsToStrings() to be defined by
764 // induction on the number of tuple fields.  The idea is that
765 // TuplePrefixPrinter&lt;N&gt;::PrintPrefixTo(t, os) prints the first N
766 // fields in tuple t, and can be defined in terms of
767 // TuplePrefixPrinter&lt;N - 1&gt;.
768 
769 // The inductive case.
770 template &lt;size_t N&gt;
771 struct TuplePrefixPrinter {
772   // Prints the first N fields of a tuple.
773   template &lt;typename Tuple&gt;
774   static void PrintPrefixTo(const Tuple&amp; t, ::std::ostream* os) {
775     TuplePrefixPrinter&lt;N - 1&gt;::PrintPrefixTo(t, os);
776     *os &lt;&lt; &quot;, &quot;;
777     UniversalPrinter&lt;typename ::std::tr1::tuple_element&lt;N - 1, Tuple&gt;::type&gt;
778         ::Print(::std::tr1::get&lt;N - 1&gt;(t), os);
779   }
780 
781   // Tersely prints the first N fields of a tuple to a string vector,
782   // one element for each field.
783   template &lt;typename Tuple&gt;
784   static void TersePrintPrefixToStrings(const Tuple&amp; t, Strings* strings) {
785     TuplePrefixPrinter&lt;N - 1&gt;::TersePrintPrefixToStrings(t, strings);
786     ::std::stringstream ss;
787     UniversalTersePrint(::std::tr1::get&lt;N - 1&gt;(t), &amp;ss);
788     strings-&gt;push_back(ss.str());
789   }
790 };
791 
792 // Base cases.
793 template &lt;&gt;
794 struct TuplePrefixPrinter&lt;0&gt; {
795   template &lt;typename Tuple&gt;
796   static void PrintPrefixTo(const Tuple&amp;, ::std::ostream*) {}
797 
798   template &lt;typename Tuple&gt;
799   static void TersePrintPrefixToStrings(const Tuple&amp;, Strings*) {}
800 };
801 // We have to specialize the entire TuplePrefixPrinter&lt;&gt; class
802 // template here, even though the definition of
803 // TersePrintPrefixToStrings() is the same as the generic version, as
804 // Embarcadero (formerly CodeGear, formerly Borland) C++ doesn&#39;t
805 // support specializing a method template of a class template.
806 template &lt;&gt;
807 struct TuplePrefixPrinter&lt;1&gt; {
808   template &lt;typename Tuple&gt;
809   static void PrintPrefixTo(const Tuple&amp; t, ::std::ostream* os) {
810     UniversalPrinter&lt;typename ::std::tr1::tuple_element&lt;0, Tuple&gt;::type&gt;::
811         Print(::std::tr1::get&lt;0&gt;(t), os);
812   }
813 
814   template &lt;typename Tuple&gt;
815   static void TersePrintPrefixToStrings(const Tuple&amp; t, Strings* strings) {
816     ::std::stringstream ss;
817     UniversalTersePrint(::std::tr1::get&lt;0&gt;(t), &amp;ss);
818     strings-&gt;push_back(ss.str());
819   }
820 };
821 
822 // Helper function for printing a tuple.  T must be instantiated with
823 // a tuple type.
824 template &lt;typename T&gt;
825 void PrintTupleTo(const T&amp; t, ::std::ostream* os) {
826   *os &lt;&lt; &quot;(&quot;;
827   TuplePrefixPrinter&lt; ::std::tr1::tuple_size&lt;T&gt;::value&gt;::
828       PrintPrefixTo(t, os);
829   *os &lt;&lt; &quot;)&quot;;
830 }
831 
832 // Prints the fields of a tuple tersely to a string vector, one
833 // element for each field.  See the comment before
834 // UniversalTersePrint() for how we define &quot;tersely&quot;.
835 template &lt;typename Tuple&gt;
836 Strings UniversalTersePrintTupleFieldsToStrings(const Tuple&amp; value) {
837   Strings result;
838   TuplePrefixPrinter&lt; ::std::tr1::tuple_size&lt;Tuple&gt;::value&gt;::
839       TersePrintPrefixToStrings(value, &amp;result);
840   return result;
841 }
842 #endif  // GTEST_HAS_TR1_TUPLE
843 
844 }  // namespace internal
845 
846 template &lt;typename T&gt;
847 ::std::string PrintToString(const T&amp; value) {
848   ::std::stringstream ss;
849   internal::UniversalTersePrinter&lt;T&gt;::Print(value, &amp;ss);
850   return ss.str();
851 }
852 
853 }  // namespace testing
854 
855 #endif  // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
    </pre>
  </body>
</html>