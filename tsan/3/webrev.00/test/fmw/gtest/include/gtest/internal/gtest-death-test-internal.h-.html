<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/include/gtest/internal/gtest-death-test-internal.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2005, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 //
 30 // Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)
 31 //
 32 // The Google C++ Testing Framework (Google Test)
 33 //
 34 // This header file defines internal utilities needed for implementing
 35 // death tests.  They are subject to change without notice.
 36 
 37 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_
 38 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_
 39 
 40 #include &quot;gtest/internal/gtest-internal.h&quot;
 41 
 42 #include &lt;stdio.h&gt;
 43 
 44 namespace testing {
 45 namespace internal {
 46 
 47 GTEST_DECLARE_string_(internal_run_death_test);
 48 
 49 // Names of the flags (needed for parsing Google Test flags).
 50 const char kDeathTestStyleFlag[] = &quot;death_test_style&quot;;
 51 const char kDeathTestUseFork[] = &quot;death_test_use_fork&quot;;
 52 const char kInternalRunDeathTestFlag[] = &quot;internal_run_death_test&quot;;
 53 
 54 #if GTEST_HAS_DEATH_TEST
 55 
 56 // DeathTest is a class that hides much of the complexity of the
 57 // GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method
 58 // returns a concrete class that depends on the prevailing death test
 59 // style, as defined by the --gtest_death_test_style and/or
 60 // --gtest_internal_run_death_test flags.
 61 
 62 // In describing the results of death tests, these terms are used with
 63 // the corresponding definitions:
 64 //
 65 // exit status:  The integer exit information in the format specified
 66 //               by wait(2)
 67 // exit code:    The integer code passed to exit(3), _exit(2), or
 68 //               returned from main()
 69 class GTEST_API_ DeathTest {
 70  public:
 71   // Create returns false if there was an error determining the
 72   // appropriate action to take for the current death test; for example,
 73   // if the gtest_death_test_style flag is set to an invalid value.
 74   // The LastMessage method will return a more detailed message in that
 75   // case.  Otherwise, the DeathTest pointer pointed to by the &quot;test&quot;
 76   // argument is set.  If the death test should be skipped, the pointer
 77   // is set to NULL; otherwise, it is set to the address of a new concrete
 78   // DeathTest object that controls the execution of the current test.
 79   static bool Create(const char* statement, const RE* regex,
 80                      const char* file, int line, DeathTest** test);
 81   DeathTest();
 82   virtual ~DeathTest() { }
 83 
 84   // A helper class that aborts a death test when it&#39;s deleted.
 85   class ReturnSentinel {
 86    public:
 87     explicit ReturnSentinel(DeathTest* test) : test_(test) { }
 88     ~ReturnSentinel() { test_-&gt;Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }
 89    private:
 90     DeathTest* const test_;
 91     GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);
 92   } GTEST_ATTRIBUTE_UNUSED_;
 93 
 94   // An enumeration of possible roles that may be taken when a death
 95   // test is encountered.  EXECUTE means that the death test logic should
 96   // be executed immediately.  OVERSEE means that the program should prepare
 97   // the appropriate environment for a child process to execute the death
 98   // test, then wait for it to complete.
 99   enum TestRole { OVERSEE_TEST, EXECUTE_TEST };
100 
101   // An enumeration of the three reasons that a test might be aborted.
102   enum AbortReason {
103     TEST_ENCOUNTERED_RETURN_STATEMENT,
104     TEST_THREW_EXCEPTION,
105     TEST_DID_NOT_DIE
106   };
107 
108   // Assumes one of the above roles.
109   virtual TestRole AssumeRole() = 0;
110 
111   // Waits for the death test to finish and returns its status.
112   virtual int Wait() = 0;
113 
114   // Returns true if the death test passed; that is, the test process
115   // exited during the test, its exit status matches a user-supplied
116   // predicate, and its stderr output matches a user-supplied regular
117   // expression.
118   // The user-supplied predicate may be a macro expression rather
119   // than a function pointer or functor, or else Wait and Passed could
120   // be combined.
121   virtual bool Passed(bool exit_status_ok) = 0;
122 
123   // Signals that the death test did not die as expected.
124   virtual void Abort(AbortReason reason) = 0;
125 
126   // Returns a human-readable outcome message regarding the outcome of
127   // the last death test.
128   static const char* LastMessage();
129 
130   static void set_last_death_test_message(const std::string&amp; message);
131 
132  private:
133   // A string containing a description of the outcome of the last death test.
134   static std::string last_death_test_message_;
135 
136   GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);
137 };
138 
139 // Factory interface for death tests.  May be mocked out for testing.
140 class DeathTestFactory {
141  public:
142   virtual ~DeathTestFactory() { }
143   virtual bool Create(const char* statement, const RE* regex,
144                       const char* file, int line, DeathTest** test) = 0;
145 };
146 
147 // A concrete DeathTestFactory implementation for normal use.
148 class DefaultDeathTestFactory : public DeathTestFactory {
149  public:
150   virtual bool Create(const char* statement, const RE* regex,
151                       const char* file, int line, DeathTest** test);
152 };
153 
154 // Returns true if exit_status describes a process that was terminated
155 // by a signal, or exited normally with a nonzero exit code.
156 GTEST_API_ bool ExitedUnsuccessfully(int exit_status);
157 
158 // Traps C++ exceptions escaping statement and reports them as test
159 // failures. Note that trapping SEH exceptions is not implemented here.
160 # if GTEST_HAS_EXCEPTIONS
161 #  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \
162   try { \
163     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
164   } catch (const ::std::exception&amp; gtest_exception) { \
165     fprintf(\
166         stderr, \
167         &quot;\n%s: Caught std::exception-derived exception escaping the &quot; \
168         &quot;death test statement. Exception message: %s\n&quot;, \
169         ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \
170         gtest_exception.what()); \
171     fflush(stderr); \
172     death_test-&gt;Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \
173   } catch (...) { \
174     death_test-&gt;Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \
175   }
176 
177 # else
178 #  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \
179   GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)
180 
181 # endif
182 
183 // This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,
184 // ASSERT_EXIT*, and EXPECT_EXIT*.
185 # define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \
186   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
187   if (::testing::internal::AlwaysTrue()) { \
188     const ::testing::internal::RE&amp; gtest_regex = (regex); \
189     ::testing::internal::DeathTest* gtest_dt; \
190     if (!::testing::internal::DeathTest::Create(#statement, &amp;gtest_regex, \
191         __FILE__, __LINE__, &amp;gtest_dt)) { \
192       goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \
193     } \
194     if (gtest_dt != NULL) { \
195       ::testing::internal::scoped_ptr&lt; ::testing::internal::DeathTest&gt; \
196           gtest_dt_ptr(gtest_dt); \
197       switch (gtest_dt-&gt;AssumeRole()) { \
198         case ::testing::internal::DeathTest::OVERSEE_TEST: \
199           if (!gtest_dt-&gt;Passed(predicate(gtest_dt-&gt;Wait()))) { \
200             goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \
201           } \
202           break; \
203         case ::testing::internal::DeathTest::EXECUTE_TEST: { \
204           ::testing::internal::DeathTest::ReturnSentinel \
205               gtest_sentinel(gtest_dt); \
206           GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); \
207           gtest_dt-&gt;Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \
208           break; \
209         } \
210         default: \
211           break; \
212       } \
213     } \
214   } else \
215     GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__): \
216       fail(::testing::internal::DeathTest::LastMessage())
217 // The symbol &quot;fail&quot; here expands to something into which a message
218 // can be streamed.
219 
220 // This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in
221 // NDEBUG mode. In this case we need the statements to be executed, the regex is
222 // ignored, and the macro must accept a streamed message even though the message
223 // is never printed.
224 # define GTEST_EXECUTE_STATEMENT_(statement, regex) \
225   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
226   if (::testing::internal::AlwaysTrue()) { \
227      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
228   } else \
229     ::testing::Message()
230 
231 // A class representing the parsed contents of the
232 // --gtest_internal_run_death_test flag, as it existed when
233 // RUN_ALL_TESTS was called.
234 class InternalRunDeathTestFlag {
235  public:
236   InternalRunDeathTestFlag(const std::string&amp; a_file,
237                            int a_line,
238                            int an_index,
239                            int a_write_fd)
240       : file_(a_file), line_(a_line), index_(an_index),
241         write_fd_(a_write_fd) {}
242 
243   ~InternalRunDeathTestFlag() {
244     if (write_fd_ &gt;= 0)
245       posix::Close(write_fd_);
246   }
247 
248   const std::string&amp; file() const { return file_; }
249   int line() const { return line_; }
250   int index() const { return index_; }
251   int write_fd() const { return write_fd_; }
252 
253  private:
254   std::string file_;
255   int line_;
256   int index_;
257   int write_fd_;
258 
259   GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);
260 };
261 
262 // Returns a newly created InternalRunDeathTestFlag object with fields
263 // initialized from the GTEST_FLAG(internal_run_death_test) flag if
264 // the flag is specified; otherwise returns NULL.
265 InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();
266 
267 #else  // GTEST_HAS_DEATH_TEST
268 
269 // This macro is used for implementing macros such as
270 // EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where
271 // death tests are not supported. Those macros must compile on such systems
272 // iff EXPECT_DEATH and ASSERT_DEATH compile with the same parameters on
273 // systems that support death tests. This allows one to write such a macro
274 // on a system that does not support death tests and be sure that it will
275 // compile on a death-test supporting system.
276 //
277 // Parameters:
278 //   statement -  A statement that a macro such as EXPECT_DEATH would test
279 //                for program termination. This macro has to make sure this
280 //                statement is compiled but not executed, to ensure that
281 //                EXPECT_DEATH_IF_SUPPORTED compiles with a certain
282 //                parameter iff EXPECT_DEATH compiles with it.
283 //   regex     -  A regex that a macro such as EXPECT_DEATH would use to test
284 //                the output of statement.  This parameter has to be
285 //                compiled but not evaluated by this macro, to ensure that
286 //                this macro only accepts expressions that a macro such as
287 //                EXPECT_DEATH would accept.
288 //   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED
289 //                and a return statement for ASSERT_DEATH_IF_SUPPORTED.
290 //                This ensures that ASSERT_DEATH_IF_SUPPORTED will not
291 //                compile inside functions where ASSERT_DEATH doesn&#39;t
292 //                compile.
293 //
294 //  The branch that has an always false condition is used to ensure that
295 //  statement and regex are compiled (and thus syntactically correct) but
296 //  never executed. The unreachable code macro protects the terminator
297 //  statement from generating an &#39;unreachable code&#39; warning in case
298 //  statement unconditionally returns or throws. The Message constructor at
299 //  the end allows the syntax of streaming additional messages into the
300 //  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.
301 # define GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, terminator) \
302     GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
303     if (::testing::internal::AlwaysTrue()) { \
304       GTEST_LOG_(WARNING) \
305           &lt;&lt; &quot;Death tests are not supported on this platform.\n&quot; \
306           &lt;&lt; &quot;Statement &#39;&quot; #statement &quot;&#39; cannot be verified.&quot;; \
307     } else if (::testing::internal::AlwaysFalse()) { \
308       ::testing::internal::RE::PartialMatch(&quot;.*&quot;, (regex)); \
309       GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
310       terminator; \
311     } else \
312       ::testing::Message()
313 
314 #endif  // GTEST_HAS_DEATH_TEST
315 
316 }  // namespace internal
317 }  // namespace testing
318 
319 #endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_
    </pre>
  </body>
</html>