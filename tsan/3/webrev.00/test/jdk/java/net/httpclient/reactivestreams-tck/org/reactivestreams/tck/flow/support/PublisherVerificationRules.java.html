<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/net/httpclient/reactivestreams-tck/org/reactivestreams/tck/flow/support/PublisherVerificationRules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package org.reactivestreams.tck.flow.support;
 25 
 26 /**
 27  * Internal TCK use only.
 28  * Add / Remove tests for PublisherVerification here to make sure that they arre added/removed in the other places.
 29  */
 30 public interface PublisherVerificationRules {
 31   /**
 32    * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()}
 33    * returns a non-negative value.
 34    */
 35   void required_validate_maxElementsFromPublisher() throws Exception;
 36   /**
 37    * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#boundedDepthOfOnNextAndRequestRecursion()}
 38    * returns a positive value.
 39    */
 40   void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception;
 41   /**
 42    * Asks for a {@code Publisher} that should emit exactly one item and complete (both within a
 43    * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()})
 44    * in response to a request(1).
 45    * &lt;p&gt;
 46    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} returns zero.
 47    * If this test fails, the following could be checked within the {@code Publisher} implementation:
 48    * &lt;ul&gt;
 49    * &lt;li&gt;the {@code Publisher.subscribe(Subscriber)} method has actual implementation,&lt;/li&gt;
 50    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
 51    * that {@code Publisher} is actually subscribed to,&lt;/li&gt;
 52    * &lt;li&gt;if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call
 53    * in response to the test subscriber or by default to their upstream,&lt;/li&gt;
 54    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called
 55    * as part of the preparation process (usually before subscribing to other {@code Publisher}s),&lt;/li&gt;
 56    * &lt;li&gt;if the {@code Publisher} implementation works for a consumer that calls {@code request(1)},&lt;/li&gt;
 57    * &lt;li&gt;if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests,&lt;/li&gt;
 58    * &lt;li&gt;that the {@code Publisher} implementation does not emit more than the allowed elements (exactly one).&lt;/li&gt;
 59    * &lt;/ul&gt;
 60    */
 61   void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable;
 62   /**
 63    * Asks for a {@code Publisher} that should emit exactly three items and complete (all within a
 64    * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()}).
 65    * &lt;p&gt;
 66    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
 67    * &lt;p&gt;
 68    * The tests requests one-by-one and verifies each single response item arrives in time.
 69    * &lt;p&gt;
 70    * If this test fails, the following could be checked within the {@code Publisher} implementation:
 71    * &lt;ul&gt;
 72    * &lt;li&gt;the {@code Publisher.subscribe(Subscriber)} method has actual implementation,&lt;/li&gt;
 73    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
 74    * that {@code Publisher} is actually subscribed to,&lt;/li&gt;
 75    * &lt;li&gt;if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call
 76    * in response to the test subscriber or by default to their upstream,&lt;/li&gt;
 77    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called
 78    * as part of the preparation process (usually before subscribing to other {@code Publisher}s),&lt;/li&gt;
 79    * &lt;li&gt;if the {@code Publisher} implementation works for a subscriber that calls {@code request(1)} after consuming an item,&lt;/li&gt;
 80    * &lt;li&gt;if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests.&lt;/li&gt;
 81    * &lt;/ul&gt;
 82    */
 83   void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable;
 84   /**
 85    * Asks for a {@code Publisher} that responds to a request pattern of 0 (not requesting upfront), 1, 1 and 2
 86    * in a timely manner.
 87    * &lt;p&gt;
 88    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.1&#39;&gt;1.1&lt;/a&gt;
 89    * &lt;p&gt;
 90    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.
 91    * &lt;p&gt;
 92    * This test ensures that the {@code Publisher} implementation correctly responds to {@code request()} calls that in
 93    * total are less than the number of elements this {@code Publisher} could emit (thus the completion event won&#39;t be emitted).
 94    * &lt;p&gt;
 95    * If this test fails, the following could be checked within the {@code Publisher} implementation:
 96    * &lt;ul&gt;
 97    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
 98    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
 99    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
100    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
101    * &lt;/ul&gt;
102    */
103   void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable;
104   /**
105    * Asks for a short {@code Publisher} and verifies that requesting once and with more than the length (but bounded) results in the
106    * correct number of items to be emitted (i.e., length 3 and request 10) followed by an {@code onComplete} signal.
107    * &lt;p&gt;
108    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.2&#39;&gt;1.2&lt;/a&gt;
109    * &lt;p&gt;
110    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
111    * &lt;p&gt;
112    * This test ensures that the {@code Publisher} implementation can deal with larger requests than the number of items it can produce.
113    * &lt;p&gt;
114    * If this test fails, the following could be checked within the {@code Publisher} implementation:
115    * &lt;ul&gt;
116    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
117    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass.&lt;/li&gt;
118    * &lt;/ul&gt;
119    */
120   void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable;
121   /**
122    * Asks for a short {@code Publisher} (i.e., length 10), repeatedly subscribes to this {@code Publisher}, requests items
123    * one by one and verifies the {@code Publisher} calls the {@code onXXX} methods non-overlappingly.
124    * &lt;p&gt;
125    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.3&#39;&gt;1.3&lt;/a&gt;
126    * &lt;p&gt;
127    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.
128    * &lt;p&gt;
129    * Note that this test is probabilistic, that is, may not capture any concurrent invocation in a {code Publisher} implementation.
130    * Note also that this test is sensitive to cases when a {@code request()} call in {@code onSubscribe()} triggers an asynchronous
131    * call to the other {@code onXXX} methods. In contrast, the test allows synchronous call chain of
132    * {@code onSubscribe -&gt; request -&gt; onNext}.
133    * &lt;p&gt;
134    * If this test fails, the following could be checked within the {@code Publisher} implementation:
135    * &lt;ul&gt;
136    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
137    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
138    * &lt;li&gt;if a {@code request()} call from {@code onSubscribe()} could trigger an asynchronous call to {@code onNext()} and if so, make sure
139    * such {@code request()} calls are deferred until the call to {@code onSubscribe()} returns normally.&lt;/li&gt;
140    * &lt;/ul&gt;
141    */
142   void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable;
143   /**
144    * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once
145    * followed by a single call to {@code onError()} without receiving any requests and otherwise
146    * not throwing any exception.
147    * &lt;p&gt;
148    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.4&#39;&gt;1.4&lt;/a&gt;
149    * &lt;p&gt;
150    * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.
151    * &lt;p&gt;
152    * If this test fails, the following could be checked within the error {@code Publisher} implementation:
153    * &lt;ul&gt;
154    * &lt;li&gt;the {@code Publisher.subscribe(Subscriber)} method has actual implementation,&lt;/li&gt;
155    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
156    * that {@code Publisher} is actually subscribed to,&lt;/li&gt;
157    * &lt;li&gt;if the {@code Publisher} implementation does signal an {@code onSubscribe} before signalling {@code onError},&lt;/li&gt;
158    * &lt;li&gt;if the {@code Publisher} implementation is able to emit an {@code onError} without requests,&lt;/li&gt;
159    * &lt;li&gt;if the {@code Publisher} is non-empty as this test requires a {@code Publisher} to signal an
160    * {@code onError} eagerly.&lt;/li&gt;
161    * &lt;/ul&gt;
162    */
163   void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable;
164   /**
165    * Asks for a short {@code Publisher} (i.e., length 3) and verifies, after requesting one by one, the sequence
166    * completes normally.
167    * &lt;p&gt;
168    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.5&#39;&gt;1.5&lt;/a&gt;
169    * &lt;p&gt;
170    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
171    * &lt;p&gt;
172    * Note that the tests requests 1 after the items have been received and before expecting an {@code onComplete} signal.
173    * &lt;p&gt;
174    * If this test fails, the following could be checked within the {@code Publisher} implementation:
175    * &lt;ul&gt;
176    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
177    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
178    * &lt;/ul&gt;
179    */
180   void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable;
181   /**
182    * Asks for an empty {@code Publisher} (i.e., length 0) and verifies it completes in a timely manner.
183    * &lt;p&gt;
184    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.5&#39;&gt;1.5&lt;/a&gt;
185    * &lt;p&gt;
186    * Note that the tests requests 1 before expecting an {@code onComplete} signal.
187    * &lt;p&gt;
188    * If this test fails, the following could be checked within the {@code Publisher} implementation:
189    * &lt;ul&gt;
190    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
191    * &lt;li&gt;if the {@code Publisher} is non-empty as this test requires a {@code Publisher} without items.&lt;/li&gt;
192    * &lt;/ul&gt;
193    */
194   void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable;
195   /**
196    * Currently, this test is skipped because it is unclear this rule can be effectively checked
197    * on a {@code Publisher} instance without looking into or hooking into the implementation of it.
198    * &lt;p&gt;
199    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.6&#39;&gt;1.6&lt;/a&gt;
200    */
201   void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable;
202   /**
203    * Asks for a single-element {@code Publisher} and checks if requesting after the terminal event doesn&#39;t
204    * lead to more items or terminal signals to be emitted.
205    * &lt;p&gt;
206    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.7&#39;&gt;1.7&lt;/a&gt;
207    * &lt;p&gt;
208    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.
209    * &lt;p&gt;
210    * The tests requests more items than the expected {@code Publisher} length upfront and some more items after its completion.
211    * &lt;p&gt;
212    * If this test fails, the following could be checked within the {@code Publisher} implementation:
213    * &lt;ul&gt;
214    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
215    * &lt;li&gt;the indication for the terminal state is properly persisted and a request call can&#39;t trigger emission of more items or another
216    * terminal signal.&lt;/li&gt;
217    * &lt;/ul&gt;
218    */
219   void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable;
220   /**
221    * Currently, this test is skipped, although it is possible to validate an error {@code Publisher} along
222    * the same lines as {@link #required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled()}.
223    * &lt;p&gt;
224    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.7&#39;&gt;1.7&lt;/a&gt;
225    */
226   void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable;
227   /**
228    * Currently, this test is skipped because there was no agreement on how to verify its &quot;eventually&quot; requirement.
229    * &lt;p&gt;
230    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.8&#39;&gt;1.8&lt;/a&gt;
231    */
232   void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable;
233   /**
234    * Asks for an empty {@code Publisher} and verifies if {@code onSubscribe} signal was emitted before
235    * any other {@code onNext}, {@code onError} or {@code onComplete} signal.
236    * &lt;p&gt;
237    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.9&#39;&gt;1.9&lt;/a&gt;
238    * &lt;p&gt;
239    * Note that this test doesn&#39;t request anything, however, an {@code onNext} is not considered as a failure.
240    * &lt;p&gt;
241    * If this test fails, the following could be checked within the {@code Publisher} implementation:
242    * &lt;ul&gt;
243    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
244    * &lt;li&gt;the {@code Publisher.subscribe(Subscriber)} method has actual implementation,&lt;/li&gt;
245    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
246    * that {@code Publisher} is actually subscribed to,&lt;/li&gt;
247    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called
248    * as part of the preparation process (usually before subscribing to other {@code Publisher}s).&lt;/li&gt;
249    * &lt;/ul&gt;
250    */
251   void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable;
252   /**
253    * Currently, this test is skipped because there is no common agreement on what is to be considered a fatal exception and
254    * besides, {@code Publisher.subscribe} is only allowed throw a {@code NullPointerException} and any other
255    * exception would require looking into or hooking into the implementation of the {@code Publisher}.
256    * &lt;p&gt;
257    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.9&#39;&gt;1.9&lt;/a&gt;
258    */
259   void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable;
260   /**
261    * Asks for an empty {@code Publisher} and calls {@code subscribe} on it with {@code null} that should result in
262    * a {@code NullPointerException} to be thrown.
263    * &lt;p&gt;
264    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.9&#39;&gt;1.9&lt;/a&gt;
265    * &lt;p&gt;
266    * If this test fails, check if the {@code subscribe()} implementation has an explicit null check (or a method dereference
267    * on the {@code Subscriber}), especially if the incoming {@code Subscriber} is wrapped or stored to be used later.
268    */
269   void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable;
270   /**
271    * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once
272    * followed by a single call to {@code onError()} without receiving any requests.
273    * &lt;p&gt;
274    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.9&#39;&gt;1.9&lt;/a&gt;
275    * &lt;p&gt;
276    * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.
277    * &lt;p&gt;
278    * The difference between this test and {@link #optional_spec104_mustSignalOnErrorWhenFails()} is that there is
279    * no explicit verification if exceptions were thrown in addition to the regular {@code onSubscribe+onError} signal pair.
280    * &lt;p&gt;
281    * If this test fails, the following could be checked within the error {@code Publisher} implementation:
282    * &lt;ul&gt;
283    * &lt;li&gt;the {@code Publisher.subscribe(Subscriber)} method has actual implementation,&lt;/li&gt;
284    * &lt;li&gt;in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},
285    * that {@code Publisher} is actually subscribed to,&lt;/li&gt;
286    * &lt;li&gt;if the {@code Publisher} implementation is able to emit an {@code onError} without requests,&lt;/li&gt;
287    * &lt;li&gt;if the {@code Publisher} is non-empty as this test expects a {@code Publisher} without items.&lt;/li&gt;
288    * &lt;/ul&gt;
289    */
290   void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable;
291   /**
292    * Currently, this test is skipped because enforcing rule ยง1.10 requires unlimited retention and reference-equal checks on
293    * all incoming {@code Subscriber} which is generally infeasible, plus reusing the same {@code Subscriber} instance is
294    * better detected (or ignored) inside {@code Subscriber.onSubscribe} when the method is called multiple times.
295    * &lt;p&gt;
296    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.10&#39;&gt;1.10&lt;/a&gt;
297    */
298   void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable;
299   /**
300    * Asks for a single-element {@code Publisher} and subscribes to it twice, without consuming with either
301    * {@code Subscriber} instance
302    * (i.e., no requests are issued).
303    * &lt;p&gt;
304    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.11&#39;&gt;1.11&lt;/a&gt;
305    * &lt;p&gt;
306    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.
307    * &lt;p&gt;
308    * Note that this test ignores what signals the {@code Publisher} emits. Any exception thrown through non-regular
309    * means will indicate a skipped test.
310    */
311   void optional_spec111_maySupportMultiSubscribe() throws Throwable;
312   /**
313    * Asks for a single-element {@code Publisher} and subscribes to it twice.
314    * Each {@code Subscriber} requests for 1 element and checks if onNext or onComplete signals was received.
315    * &lt;p&gt;
316    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.11&#39;&gt;1.11&lt;/a&gt;,
317    * and depends on valid implementation of rule &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.5&#39;&gt;1.5&lt;/a&gt;
318    * in order to verify this.
319    * &lt;p&gt;
320    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.
321    * &lt;p&gt;
322    * Any exception thrown through non-regular means will indicate a skipped test.
323    */
324   void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable;
325   /**
326    * Asks for a short {@code Publisher} (length 5), subscribes 3 {@code Subscriber}s to it, requests with different
327    * patterns and checks if all 3 received the same events in the same order.
328    * &lt;p&gt;
329    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.11&#39;&gt;1.11&lt;/a&gt;
330    * &lt;p&gt;
331    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.
332    * &lt;p&gt;
333    * The request pattern for the first {@code Subscriber} is (1, 1, 2, 1); for the second is (2, 3) and for the third is (3, 1, 1).
334    * &lt;p&gt;
335    * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of
336    * when they subscribe and how they request elements. I.e., a &quot;live&quot; {@code Publisher} emitting the current time would not pass this test.
337    * &lt;p&gt;
338    * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},
339    * see the skip message for an indication of this.
340    * &lt;p&gt;
341    * If this test fails, the following could be checked within the {@code Publisher} implementation:
342    * &lt;ul&gt;
343    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
344    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
345    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
346    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
347    * &lt;/ul&gt;
348    */
349   void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable;
350   /**
351    * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items
352    * upfront with each and verifies they all received the same items in the same order (but does not verify they all complete).
353    * &lt;p&gt;
354    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.11&#39;&gt;1.11&lt;/a&gt;
355    * &lt;p&gt;
356    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
357    * &lt;p&gt;
358    * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of
359    * when they subscribe and how they request elements. I.e., a &quot;live&quot; {@code Publisher} emitting the current time would not pass this test.
360    * &lt;p&gt;
361    * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},
362    * see the skip message for an indication of this.
363    * &lt;p&gt;
364    * If this test fails, the following could be checked within the {@code Publisher} implementation:
365    * &lt;ul&gt;
366    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
367    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
368    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
369    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
370    * &lt;/ul&gt;
371    */
372   void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable;
373   /**
374    * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items
375    * upfront with each and verifies they all received the same items in the same order followed by an {@code onComplete} signal.
376    * &lt;p&gt;
377    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#1.11&#39;&gt;1.11&lt;/a&gt;
378    * &lt;p&gt;
379    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
380    * &lt;p&gt;
381    * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of
382    * when they subscribe and how they request elements. I.e., a &quot;live&quot; {@code Publisher} emitting the current time would not pass this test.
383    * &lt;p&gt;
384    * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},
385    * see the skip message for an indication of this.
386    * &lt;p&gt;
387    * If this test fails, the following could be checked within the {@code Publisher} implementation:
388    * &lt;ul&gt;
389    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
390    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
391    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
392    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
393    * &lt;/ul&gt;
394    */
395   void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable;
396   /**
397    * Asks for a short {@code Publisher} (length 6), requests several times from within {@code onSubscribe} and then requests
398    * one-by-one from {@code onNext}.
399    * &lt;p&gt;
400    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.2&#39;&gt;3.2&lt;/a&gt;
401    * &lt;p&gt;
402    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 6.
403    * &lt;p&gt;
404    * The request pattern is 3 x 1 from within {@code onSubscribe} and one from within each {@code onNext} invocation.
405    * &lt;p&gt;
406    * The test consumes the {@code Publisher} but otherwise doesn&#39;t verify the {@code Publisher} completes (however, it checks
407    * for errors).
408    * &lt;p&gt;
409    * If this test fails, the following could be checked within the {@code Publisher} implementation:
410    * &lt;ul&gt;
411    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
412    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
413    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
414    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
415    * &lt;/ul&gt;
416    */
417   void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable;
418   /**
419    * Asks for a {@code Publisher} with length equal to the value returned by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1,
420    * calls {@code request(1)} externally and then from within {@code onNext} and checks if the stack depth did not increase beyond the
421    * amount permitted by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()}.
422    * &lt;p&gt;
423    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.3&#39;&gt;3.3&lt;/a&gt;
424    * &lt;p&gt;
425    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than
426    * {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1.
427    * &lt;p&gt;
428    * If this test fails, the following could be checked within the {@code Publisher} implementation:
429    * &lt;ul&gt;
430    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
431    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
432    * &lt;li&gt;the implementation doesn&#39;t allow unbounded recursion when {@code request()} is called from within {@code onNext}, i.e., the lack of
433    * reentrant-safe state machine around the request amount (such as a for loop with a bound on the parameter {@code n} that calls {@code onNext}).
434    * &lt;/ul&gt;
435    */
436   void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable;
437   /**
438    * Currently, this test is skipped because a {@code request} could enter into a synchronous computation via {@code onNext}
439    * legally and otherwise there is no common agreement how to detect such heavy computation reliably.
440    * &lt;p&gt;
441    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.4&#39;&gt;3.4&lt;/a&gt;
442    */
443   void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception;
444   /**
445    * Currently, this test is skipped because there is no reliable agreed upon way to detect a heavy computation.
446    * &lt;p&gt;
447    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.5&#39;&gt;3.5&lt;/a&gt;
448    */
449   void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception;
450   /**
451    * Asks for a short {@code Publisher} (length 3) and verifies that cancelling without requesting anything, then requesting
452    * items should result in no signals to be emitted.
453    * &lt;p&gt;
454    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.6&#39;&gt;3.6&lt;/a&gt;
455    * &lt;p&gt;
456    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
457    * &lt;p&gt;
458    * The post-cancellation request pattern is (1, 1, 1).
459    * &lt;p&gt;
460    * If this test fails, the following could be checked within the {@code Publisher} implementation:
461    * &lt;ul&gt;
462    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
463    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
464    * &lt;li&gt;the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.&lt;/li&gt;
465    * &lt;/ul&gt;
466    */
467   void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable;
468   /**
469    * Asks for a single-element {@code Publisher} and verifies that without requesting anything, cancelling the sequence
470    * multiple times should result in no signals to be emitted and should result in an thrown exception.
471    * &lt;p&gt;
472    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.7&#39;&gt;3.7&lt;/a&gt;
473    * &lt;p&gt;
474    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.
475    * &lt;p&gt;
476    * If this test fails, the following could be checked within the {@code Publisher} implementation:
477    * &lt;ul&gt;
478    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
479    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
480    * &lt;li&gt;the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.&lt;/li&gt;
481    * &lt;/ul&gt;
482    */
483   void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable;
484   /**
485    * Asks for a short {@code Publisher} (length 10) and issues a {@code request(0)} which should trigger an {@code onError} call
486    * with an {@code IllegalArgumentException}.
487    * &lt;p&gt;
488    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.9&#39;&gt;3.9&lt;/a&gt;
489    * &lt;p&gt;
490    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.
491    * &lt;p&gt;
492    * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by
493    * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the
494    * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).
495    * &lt;p&gt;
496    * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within
497    * the {@code Publisher}.
498    * &lt;p&gt;
499    * If this test fails, the following could be checked within the {@code Publisher} implementation:
500    * &lt;ul&gt;
501    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
502    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
503    * &lt;li&gt;the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal
504    * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}
505    * in general.
506    * &lt;/ul&gt;
507    */
508   void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable;
509   /**
510    * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should
511    * trigger an {@code onError} call with an {@code IllegalArgumentException}.
512    * &lt;p&gt;
513    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.9&#39;&gt;3.9&lt;/a&gt;
514    * &lt;p&gt;
515    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.
516    * &lt;p&gt;
517    * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by
518    * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the
519    * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).
520    * &lt;p&gt;
521    * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within
522    * the {@code Publisher}.
523    * &lt;p&gt;
524    * If this test fails, the following could be checked within the {@code Publisher} implementation:
525    * &lt;ul&gt;
526    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
527    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
528    * &lt;li&gt;the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal
529    * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}
530    * in general.
531    * &lt;/ul&gt;
532    */
533   void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable;
534   /**
535    * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should
536    * trigger an {@code onError} call with an {@code IllegalArgumentException}.
537    * &lt;p&gt;
538    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.9&#39;&gt;3.9&lt;/a&gt;
539    * &lt;p&gt;
540    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.
541    * &lt;p&gt;
542    * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by
543    * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the
544    * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).
545    * &lt;p&gt;
546    * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within
547    * the {@code Publisher}.
548    * &lt;p&gt;
549    * If this test fails, the following could be checked within the {@code Publisher} implementation:
550    * &lt;ul&gt;
551    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
552    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
553    * &lt;li&gt;the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal
554    * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}
555    * in general.
556    * &lt;/ul&gt;
557    */
558   void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable;
559   /**
560    * Asks for a short {@code Publisher} (length 20), requests some items (less than the length), consumes one item then
561    * cancels the sequence and verifies the publisher emitted at most the requested amount and stopped emitting (or terminated).
562    * &lt;p&gt;
563    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.12&#39;&gt;3.12&lt;/a&gt;
564    * &lt;p&gt;
565    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 20.
566    * &lt;p&gt;
567    * If this test fails, the following could be checked within the {@code Publisher} implementation:
568    * &lt;ul&gt;
569    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
570    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
571    * &lt;li&gt;the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.&lt;/li&gt;
572    * &lt;/ul&gt;
573    */
574   void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable;
575   /**
576    * Asks for a short {@code Publisher} (length 3) requests and consumes one element from it, cancels the {@code Subscription}
577    * , calls {@code System.gc()} and then checks if all references to the test {@code Subscriber} has been dropped (by checking
578    * the {@code WeakReference} has been emptied).
579    * &lt;p&gt;
580    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.13&#39;&gt;3.13&lt;/a&gt;
581    * &lt;p&gt;
582    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
583    * &lt;p&gt;
584    * If this test fails, the following could be checked within the {@code Publisher} implementation:
585    * &lt;ul&gt;
586    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
587    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
588    * &lt;li&gt;the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.&lt;/li&gt;
589    * &lt;li&gt;the {@code Publisher} stores the {@code Subscriber} reference somewhere which is then not cleaned up when the {@code Subscriber} is cancelled.
590    * Note that this may happen on many code paths in a {@code Publisher}, for example in an emission loop that terminates because of the
591    * {@code cancel} signal or because reaching a terminal state. Note also that eagerly nulling {@code Subscriber} references may not be necessary
592    * for this test to pass in case there is a self-contained chain of them (i.e., {@code Publisher.subscribe()} creates a chain of fresh
593    * {@code Subscriber} instances where each of them only references their downstream {@code Subscriber} thus the chain can get GC&#39;d
594    * when the reference to the final {@code Subscriber} is dropped).
595    * &lt;/ul&gt;
596    */
597   void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable;
598   /**
599    * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it, verifying that the
600    * {@code Publisher} emits all of its items and completes normally
601    * and does not keep spinning attempting to fulfill the {@code Long.MAX_VALUE} demand by some means.
602    * &lt;p&gt;
603    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.17&#39;&gt;3.17&lt;/a&gt;
604    * &lt;p&gt;
605    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
606    * &lt;p&gt;
607    * If this test fails, the following could be checked within the {@code Publisher} implementation:
608    * &lt;ul&gt;
609    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
610    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
611    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
612    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
613    * &lt;/ul&gt;
614    */
615   void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable;
616   /**
617    * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it in total (split across
618    * two {@code Long.MAX_VALUE / 2} and one {@code request(1)}), verifying that the
619    * {@code Publisher} emits all of its items and completes normally.
620    * &lt;p&gt;
621    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.17&#39;&gt;3.17&lt;/a&gt;
622    * &lt;p&gt;
623    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.
624    * &lt;p&gt;
625    * If this test fails, the following could be checked within the {@code Publisher} implementation:
626    * &lt;ul&gt;
627    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
628    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
629    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
630    * &lt;li&gt;if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)
631    * or not properly deducing the number of emitted items from the pending amount,&lt;/li&gt;
632    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
633    * &lt;/ul&gt;
634    */
635   void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable;
636   /**
637    * Asks for a very long {@code Publisher} (up to {@code Integer.MAX_VALUE}), requests {@code Long.MAX_VALUE - 1} after
638    * each received item and expects no failure due to a potential overflow in the pending emission count while consuming
639    * 10 items and cancelling the sequence.
640    * &lt;p&gt;
641    * &lt;b&gt;Verifies rule:&lt;/b&gt; &lt;a href=&#39;https://github.com/reactive-streams/reactive-streams-jvm#3.17&#39;&gt;3.17&lt;/a&gt;
642    * &lt;p&gt;
643    * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than {@code Integer.MAX_VALUE}.
644    * &lt;p&gt;
645    * The request pattern is one {@code request(1)} upfront and ten {@code request(Long.MAX_VALUE - 1)} after.
646    * &lt;p&gt;
647    * If this test fails, the following could be checked within the {@code Publisher} implementation:
648    * &lt;ul&gt;
649    * &lt;li&gt;the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,&lt;/li&gt;
650    * &lt;li&gt;make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,&lt;/li&gt;
651    * &lt;li&gt;if the {@code Publisher} implementation considers the cumulative request amount it receives,&lt;/li&gt;
652    * &lt;li&gt;if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)
653    * or not properly deducing the number of emitted items from the pending amount,&lt;/li&gt;
654    * &lt;li&gt;if the {@code Publisher} doesn&#39;t lose any {@code request()} signal and the state transition from idle -&amp;gt; emitting or emitting -&amp;gt; keep emitting works properly.&lt;/li&gt;
655    * &lt;/ul&gt;
656    */
657   void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable;
658 }
    </pre>
  </body>
</html>