<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.code.test/src/jdk/vm/ci/code/test/DataPatchTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /**
 25  * @test
 26  * @requires vm.jvmci &amp; (vm.simpleArch == &quot;x64&quot; | vm.simpleArch == &quot;sparcv9&quot;)
 27  * @library /
 28  * @modules jdk.internal.vm.ci/jdk.vm.ci.hotspot
 29  *          jdk.internal.vm.ci/jdk.vm.ci.meta
 30  *          jdk.internal.vm.ci/jdk.vm.ci.code
 31  *          jdk.internal.vm.ci/jdk.vm.ci.code.site
 32  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
 33  *          jdk.internal.vm.ci/jdk.vm.ci.amd64
 34  *          jdk.internal.vm.ci/jdk.vm.ci.sparc
 35  * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64/AMD64TestAssembler.java sparc/SPARCTestAssembler.java
 36  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.code.test.DataPatchTest
 37  */
 38 
 39 package jdk.vm.ci.code.test;
 40 
 41 import jdk.vm.ci.code.Register;
 42 import jdk.vm.ci.code.site.DataSectionReference;
 43 import jdk.vm.ci.hotspot.HotSpotConstant;
 44 import jdk.vm.ci.meta.ResolvedJavaType;
 45 import org.junit.Assume;
 46 import org.junit.Test;
 47 
 48 /**
 49  * Test code installation with data patches.
 50  */
 51 public class DataPatchTest extends CodeInstallationTest {
 52 
 53     public static Class&lt;?&gt; getConstClass() {
 54         return DataPatchTest.class;
 55     }
 56 
 57     private void test(TestCompiler compiler) {
 58         test(compiler, getMethod(&quot;getConstClass&quot;));
 59     }
 60 
 61     @Test
 62     public void testInlineObject() {
 63         test(asm -&gt; {
 64             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
 65             HotSpotConstant c = (HotSpotConstant) constantReflection.asJavaClass(type);
 66             Register ret = asm.emitLoadPointer(c);
 67             asm.emitPointerRet(ret);
 68         });
 69     }
 70 
 71     @Test
 72     public void testInlineNarrowObject() {
 73         Assume.assumeTrue(config.useCompressedOops);
 74         test(asm -&gt; {
 75             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
 76             HotSpotConstant c = (HotSpotConstant) constantReflection.asJavaClass(type);
 77             Register compressed = asm.emitLoadPointer((HotSpotConstant) c.compress());
 78             Register ret = asm.emitUncompressPointer(compressed, config.narrowOopBase, config.narrowOopShift);
 79             asm.emitPointerRet(ret);
 80         });
 81     }
 82 
 83     @Test
 84     public void testDataSectionReference() {
 85         test(asm -&gt; {
 86             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
 87             HotSpotConstant c = (HotSpotConstant) constantReflection.asJavaClass(type);
 88             DataSectionReference ref = asm.emitDataItem(c);
 89             Register ret = asm.emitLoadPointer(ref);
 90             asm.emitPointerRet(ret);
 91         });
 92     }
 93 
 94     @Test
 95     public void testNarrowDataSectionReference() {
 96         Assume.assumeTrue(config.useCompressedOops);
 97         test(asm -&gt; {
 98             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
 99             HotSpotConstant c = (HotSpotConstant) constantReflection.asJavaClass(type);
100             HotSpotConstant cCompressed = (HotSpotConstant) c.compress();
101             DataSectionReference ref = asm.emitDataItem(cCompressed);
102             Register compressed = asm.emitLoadNarrowPointer(ref);
103             Register ret = asm.emitUncompressPointer(compressed, config.narrowOopBase, config.narrowOopShift);
104             asm.emitPointerRet(ret);
105         });
106     }
107 
108     @Test
109     public void testInlineMetadata() {
110         test(asm -&gt; {
111             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
112             Register klass = asm.emitLoadPointer((HotSpotConstant) constantReflection.asObjectHub(type));
113             Register ret = asm.emitLoadPointer(asm.emitLoadPointer(klass, config.classMirrorHandleOffset), 0);
114             asm.emitPointerRet(ret);
115         });
116     }
117 
118     @Test
119     public void testInlineNarrowMetadata() {
120         Assume.assumeTrue(config.useCompressedClassPointers);
121         test(asm -&gt; {
122             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
123             HotSpotConstant hub = (HotSpotConstant) constantReflection.asObjectHub(type);
124             Register narrowKlass = asm.emitLoadPointer((HotSpotConstant) hub.compress());
125             Register klass = asm.emitUncompressPointer(narrowKlass, config.narrowKlassBase, config.narrowKlassShift);
126             Register ret = asm.emitLoadPointer(asm.emitLoadPointer(klass, config.classMirrorHandleOffset), 0);
127             asm.emitPointerRet(ret);
128         });
129     }
130 
131     @Test
132     public void testMetadataInDataSection() {
133         test(asm -&gt; {
134             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
135             HotSpotConstant hub = (HotSpotConstant) constantReflection.asObjectHub(type);
136             DataSectionReference ref = asm.emitDataItem(hub);
137             Register klass = asm.emitLoadPointer(ref);
138             Register ret = asm.emitLoadPointer(asm.emitLoadPointer(klass, config.classMirrorHandleOffset), 0);
139             asm.emitPointerRet(ret);
140         });
141     }
142 
143     @Test
144     public void testNarrowMetadataInDataSection() {
145         Assume.assumeTrue(config.useCompressedClassPointers);
146         test(asm -&gt; {
147             ResolvedJavaType type = metaAccess.lookupJavaType(getConstClass());
148             HotSpotConstant hub = (HotSpotConstant) constantReflection.asObjectHub(type);
149             HotSpotConstant narrowHub = (HotSpotConstant) hub.compress();
150             DataSectionReference ref = asm.emitDataItem(narrowHub);
151             Register narrowKlass = asm.emitLoadNarrowPointer(ref);
152             Register klass = asm.emitUncompressPointer(narrowKlass, config.narrowKlassBase, config.narrowKlassShift);
153             Register ret = asm.emitLoadPointer(asm.emitLoadPointer(klass, config.classMirrorHandleOffset), 0);
154             asm.emitPointerRet(ret);
155         });
156     }
157 }
    </pre>
  </body>
</html>