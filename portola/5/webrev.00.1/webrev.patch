diff a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -28,10 +28,21 @@
 # and fix the broken property, if needed.
 
 DIR=`dirname $0`
 OUT=`. $DIR/autoconf-config.guess`
 
+# config.guess doesn't identify systems running the musl C library, and will
+# instead return a string with a -gnu suffix. This block detects musl and
+# modifies the string to have a -musl suffix instead. 
+echo $OUT | grep -- -linux- > /dev/null 2> /dev/null
+if test $? = 0; then
+  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`
+  if [ x"${ldd_version}" = x"musl" ]; then
+    OUT=`echo $OUT | sed 's/-gnu/-musl/'`
+  fi
+fi
+
 # Test and fix cygwin on x86_64
 echo $OUT | grep 86-pc-cygwin > /dev/null 2> /dev/null
 if test $? != 0; then
   echo $OUT | grep 86-pc-mingw > /dev/null 2> /dev/null
 fi
diff a/make/autoconf/buildjdk-spec.gmk.in b/make/autoconf/buildjdk-spec.gmk.in
--- a/make/autoconf/buildjdk-spec.gmk.in
+++ b/make/autoconf/buildjdk-spec.gmk.in
@@ -52,22 +52,25 @@
 JDK_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(JDK_OUTPUTDIR))
 IMAGES_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(IMAGES_OUTPUTDIR))
 
 OPENJDK_BUILD_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
 OPENJDK_BUILD_CPU_LEGACY_LIB := @OPENJDK_BUILD_CPU_LEGACY_LIB@
+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_CPU := @OPENJDK_BUILD_CPU@
 OPENJDK_TARGET_CPU_ARCH := @OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS := @OPENJDK_BUILD_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN := @OPENJDK_BUILD_CPU_ENDIAN@
 OPENJDK_TARGET_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
+OPENJDK_TARGET_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_OS_INCLUDE_SUBDIR := @OPENJDK_BUILD_OS_INCLUDE_SUBDIR@
 
 HOTSPOT_TARGET_OS := @HOTSPOT_BUILD_OS@
 HOTSPOT_TARGET_OS_TYPE := @HOTSPOT_BUILD_OS_TYPE@
 HOTSPOT_TARGET_CPU := @HOTSPOT_BUILD_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_BUILD_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_BUILD_CPU_DEFINE@
+HOTSPOT_TARGET_LIBC := @HOTSPOT_BUILD_LIBC@
 
 CFLAGS_JDKLIB := @OPENJDK_BUILD_CFLAGS_JDKLIB@
 CXXFLAGS_JDKLIB := @OPENJDK_BUILD_CXXFLAGS_JDKLIB@
 LDFLAGS_JDKLIB := @OPENJDK_BUILD_LDFLAGS_JDKLIB@
 CFLAGS_JDKEXE := @OPENJDK_BUILD_CFLAGS_JDKEXE@
diff a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -216,10 +216,22 @@
       ;;
     *)
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+
+  case "$1" in
+    *linux*-musl)
+      VAR_LIBC=musl
+      ;;
+    *linux*-gnu)
+      VAR_LIBC=gnu
+      ;;
+    *)
+      VAR_LIBC=default
+      ;;
+  esac
 ])
 
 # Expects $host_os $host_cpu $build_os and $build_cpu
 # and $with_target_bits to have been setup!
 #
@@ -254,21 +266,28 @@
   fi
   OPENJDK_BUILD_CPU="$VAR_CPU"
   OPENJDK_BUILD_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_BUILD_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_BUILD_CPU_ENDIAN="$VAR_CPU_ENDIAN"
+  OPENJDK_BUILD_LIBC="$VAR_LIBC"
   AC_SUBST(OPENJDK_BUILD_OS)
   AC_SUBST(OPENJDK_BUILD_OS_TYPE)
   AC_SUBST(OPENJDK_BUILD_OS_ENV)
   AC_SUBST(OPENJDK_BUILD_CPU)
   AC_SUBST(OPENJDK_BUILD_CPU_ARCH)
   AC_SUBST(OPENJDK_BUILD_CPU_BITS)
   AC_SUBST(OPENJDK_BUILD_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_BUILD_LIBC)
 
   AC_MSG_CHECKING([openjdk-build os-cpu])
   AC_MSG_RESULT([$OPENJDK_BUILD_OS-$OPENJDK_BUILD_CPU])
 
+  if test "x$OPENJDK_BUILD_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-build C library])
+    AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])
+  fi
+
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
@@ -285,22 +304,29 @@
   OPENJDK_TARGET_CPU="$VAR_CPU"
   OPENJDK_TARGET_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   OPENJDK_TARGET_OS_UPPERCASE=`$ECHO $OPENJDK_TARGET_OS | $TR 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  OPENJDK_TARGET_LIBC="$VAR_LIBC"
 
   AC_SUBST(OPENJDK_TARGET_OS)
   AC_SUBST(OPENJDK_TARGET_OS_TYPE)
   AC_SUBST(OPENJDK_TARGET_OS_ENV)
   AC_SUBST(OPENJDK_TARGET_OS_UPPERCASE)
   AC_SUBST(OPENJDK_TARGET_CPU)
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
   AC_SUBST(OPENJDK_TARGET_CPU_BITS)
   AC_SUBST(OPENJDK_TARGET_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_TARGET_LIBC)
 
   AC_MSG_CHECKING([openjdk-target os-cpu])
   AC_MSG_RESULT([$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
+
+  if test "x$OPENJDK_TARGET_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-target C library])
+    AC_MSG_RESULT([$OPENJDK_TARGET_LIBC])
+  fi
 ])
 
 # Check if a reduced build (32-bit on 64-bit platforms) is requested, and modify behaviour
 # accordingly. Must be done after setting up build and target system, but before
 # doing anything else with these values.
@@ -418,11 +444,17 @@
   if test "x$OPENJDK_$1_CPU" = xx86_64; then
     OPENJDK_$1_CPU_BUNDLE="x64"
   else
     OPENJDK_$1_CPU_BUNDLE="$OPENJDK_$1_CPU"
   fi
-  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}"
+
+  OPENJDK_$1_LIBC_BUNDLE=""
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then  
+    OPENJDK_$1_LIBC_BUNDLE="-$OPENJDK_$1_LIBC"
+  fi
+
+  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}"
   AC_SUBST(OPENJDK_$1_BUNDLE_PLATFORM)
 
   if test "x$COMPILE_TYPE" = "xcross"; then
     # FIXME: ... or should this include reduced builds..?
     DEFINE_CROSS_COMPILE_ARCH="CROSS_COMPILE_ARCH:=$OPENJDK_$1_CPU_LEGACY"
@@ -491,10 +523,17 @@
   elif test "x$OPENJDK_$1_CPU" != x; then
     HOTSPOT_$1_CPU_DEFINE=$(echo $OPENJDK_$1_CPU | tr a-z A-Z)
   fi
   AC_SUBST(HOTSPOT_$1_CPU_DEFINE)
 
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
+    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC
+  else
+    HOTSPOT_$1_LIBC=""
+  fi
+  AC_SUBST(HOTSPOT_$1_LIBC)
+
   # For historical reasons, the OS include directories have odd names.
   OPENJDK_$1_OS_INCLUDE_SUBDIR="$OPENJDK_TARGET_OS"
   if test "x$OPENJDK_TARGET_OS" = "xwindows"; then
     OPENJDK_$1_OS_INCLUDE_SUBDIR="win32"
   elif test "x$OPENJDK_TARGET_OS" = "xmacosx"; then
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -78,10 +78,12 @@
 OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@
 OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS:=@OPENJDK_TARGET_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN:=@OPENJDK_TARGET_CPU_ENDIAN@
 
+OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@
+
 COMPILE_TYPE:=@COMPILE_TYPE@
 
 # Legacy support
 OPENJDK_TARGET_CPU_LEGACY:=@OPENJDK_TARGET_CPU_LEGACY@
 OPENJDK_TARGET_CPU_LEGACY_LIB:=@OPENJDK_TARGET_CPU_LEGACY_LIB@
@@ -93,10 +95,12 @@
 
 HOTSPOT_TARGET_CPU := @HOTSPOT_TARGET_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_TARGET_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_TARGET_CPU_DEFINE@
 
+HOTSPOT_TARGET_LIBC := @HOTSPOT_TARGET_LIBC@
+
 OPENJDK_TARGET_BUNDLE_PLATFORM:=@OPENJDK_TARGET_BUNDLE_PLATFORM@
 JDK_ARCH_ABI_PROP_NAME := @JDK_ARCH_ABI_PROP_NAME@
 
 # We are building on this build system.
 # When not cross-compiling, it is the same as the target.
@@ -107,10 +111,12 @@
 OPENJDK_BUILD_CPU:=@OPENJDK_BUILD_CPU@
 OPENJDK_BUILD_CPU_ARCH:=@OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_BUILD_CPU_BITS:=@OPENJDK_BUILD_CPU_BITS@
 OPENJDK_BUILD_CPU_ENDIAN:=@OPENJDK_BUILD_CPU_ENDIAN@
 
+OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@
+
 OPENJDK_BUILD_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@
 
 # Target platform value in ModuleTarget class file attribute.
 OPENJDK_MODULE_TARGET_PLATFORM:=@OPENJDK_MODULE_TARGET_PLATFORM@
 
@@ -840,10 +846,11 @@
 #
 # Misc
 #
 
 INCLUDE_SA=@INCLUDE_SA@
+INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@
 INCLUDE_GRAAL=@INCLUDE_GRAAL@
 INCLUDE_JVMCI=@INCLUDE_JVMCI@
 
 OS_VERSION_MAJOR:=@OS_VERSION_MAJOR@
 OS_VERSION_MINOR:=@OS_VERSION_MINOR@
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -56,12 +56,14 @@
  *
  * input.profile
  * input.build_id
  * input.target_os
  * input.target_cpu
+ * input.target_libc
  * input.build_os
  * input.build_cpu
+ * input.build_libc
  * input.target_platform
  * input.build_platform
  * // The build_osenv_* variables describe the unix layer on Windows systems,
  * // i.e. Cygwin, which may also be 32 or 64 bit.
  * input.build_osenv
@@ -98,17 +100,21 @@
  *     <profile-name>: {
  *       // Name of os the profile is built to run on
  *       target_os; <string>
  *       // Name of cpu the profile is built to run on
  *       target_cpu; <string>
- *       // Combination of target_os and target_cpu for convenience
+ *       // Optional libc string if non standard
+ *       target_libc; <string>
+ *       // Optional combination of target_os and target_cpu for convenience
  *       target_platform; <string>
  *       // Name of os the profile is built on
  *       build_os; <string>
  *       // Name of cpu the profile is built on
  *       build_cpu; <string>
- *       // Combination of build_os and build_cpu for convenience
+ *       // Optional libc string if non standard
+ *       build_libc; <string>
+ *       // Optional combination of build_os and build_cpu for convenience
  *       build_platform; <string>
  *
  *       // List of dependencies needed to build this profile
  *       dependencies: <Array of strings>
  *
@@ -190,11 +196,11 @@
     //     dir just like default configure_args and environment_path variables.
     data.format_version = "1.3";
 
     // Organization, product and version are used when uploading/publishing build results
     data.organization = "";
-    data.product = "jdk";
+    data.product = "jdk-portola";
     data.version = getVersion();
 
     // The base directory for the build output. JIB will assume that the
     // actual build directory will be <output_basedir>/<configuration>
     data.output_basedir = "build";
@@ -237,11 +243,11 @@
     common.build_id = getBuildId(input);
     common.build_number = input.build_number != null ? input.build_number : "0";
 
     // List of the main profile names used for iteration
     common.main_profile_names = [
-        "linux-x64", "linux-x86", "macosx-x64",
+        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64",
         "windows-x64", "windows-x86",
         "linux-aarch64", "linux-arm32", "linux-ppc64le", "linux-s390x"
     ];
 
     // These are the base setttings for all the main build profiles.
@@ -410,10 +416,18 @@
                 (isWsl(input) ? [ "--host=x86_64-unknown-linux-gnu",
                     "--build=x86_64-unknown-linux-gnu" ] : [])),
             default_make_targets: ["docs-bundles"],
         },
 
+        "linux-x64-musl": {
+            target_os: "linux",
+            target_cpu: "x64",
+            target_libc: "musl",
+            configure_args: concat(common.configure_args_64bit,
+                "--with-zlib=system"),
+        },
+
         "linux-x86": {
             target_os: "linux",
             target_cpu: "x86",
             build_cpu: "x64",
             dependencies: ["devkit", "gtest"],
@@ -637,10 +651,14 @@
     // tar.gz.
     var artifactData = {
         "linux-x64": {
             platform: "linux-x64",
         },
+        "linux-x64-musl": {
+            platform: "linux-x64-musl",
+            demo_ext: "tar.gz"
+        },
         "linux-x86": {
             platform: "linux-x86",
         },
         "macosx-x64": {
             platform: "osx-x64",
@@ -979,11 +997,12 @@
             devkit_cross_prefix = input.build_platform + "-to-";
         }
     }
 
     var boot_jdk_platform = (input.build_os == "macosx" ? "osx" : input.build_os)
-        + "-" + input.build_cpu;
+        + "-" + input.build_cpu +
+        (input.build_libc ? "-" + input.build_libc : "");
     var boot_jdk_ext = (input.build_os == "windows" ? ".zip" : ".tar.gz")
     // If running in WSL and building for Windows, it will look like Linux,
     // but we need a Windows boot JDK.
     if (isWsl(input) && input.target_os == "windows") {
         boot_jdk_platform = "windows-" + input.build_cpu;
@@ -1004,11 +1023,11 @@
             environment_path: common.boot_jdk_home + "/bin"
         }
     } else {
         boot_jdk = {
             server: "jpg",
-            product: "jdk",
+            product: input.build_libc == "musl" ? "jdk-portola" : "jdk",
             version: common.boot_jdk_version,
             build_number: common.boot_jdk_build_number,
             file: "bundles/" + boot_jdk_platform + "/jdk-" + common.boot_jdk_version + "_"
                 + boot_jdk_platform + "_bin" + boot_jdk_ext,
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
diff a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -59,17 +59,22 @@
   OPENJDK_TARGET_CPU_VM_VERSION := amd64
 else
   OPENJDK_TARGET_CPU_VM_VERSION := $(OPENJDK_TARGET_CPU)
 endif
 
+ifneq ($(HOTSPOT_TARGET_LIBC),)
+  LIBC_DEFINE := -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
+endif
+
 CFLAGS_VM_VERSION := \
     $(VERSION_CFLAGS) \
     -DHOTSPOT_VERSION_STRING='"$(VERSION_STRING)"' \
     -DDEBUG_LEVEL='"$(DEBUG_LEVEL)"' \
     -DHOTSPOT_BUILD_USER='"$(USERNAME)"' \
     -DHOTSPOT_VM_DISTRO='"$(HOTSPOT_VM_DISTRO)"' \
     -DCPU='"$(OPENJDK_TARGET_CPU_VM_VERSION)"' \
+    $(LIBC_DEFINE) \
     #
 
 ifneq ($(HOTSPOT_BUILD_TIME), )
   CFLAGS_VM_VERSION += -DHOTSPOT_BUILD_TIME='"$(HOTSPOT_BUILD_TIME)"'
 endif
diff a/make/modules/java.base/lib/CoreLibraries.gmk b/make/modules/java.base/lib/CoreLibraries.gmk
--- a/make/modules/java.base/lib/CoreLibraries.gmk
+++ b/make/modules/java.base/lib/CoreLibraries.gmk
@@ -180,10 +180,12 @@
   ifneq ($(MSVCP_DLL), )
     LIBJLI_CFLAGS += -DMSVCP_DLL_NAME='"$(notdir $(MSVCP_DLL))"'
   endif
 endif
 
+LIBJLI_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 LIBJLI_CFLAGS += $(LIBZ_CFLAGS)
 
 ifneq ($(USE_EXTERNAL_LIBZ), true)
   LIBJLI_EXTRA_FILES += \
       $(addprefix $(TOPDIR)/src/java.base/share/native/libzip/zlib/, \
diff a/make/modules/jdk.hotspot.agent/Lib.gmk b/make/modules/jdk.hotspot.agent/Lib.gmk
--- a/make/modules/jdk.hotspot.agent/Lib.gmk
+++ b/make/modules/jdk.hotspot.agent/Lib.gmk
@@ -46,10 +46,12 @@
       SA_CXXFLAGS := -RTC1
     endif
   endif
 endif
 
+SA_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 SA_TOOLCHAIN := $(TOOLCHAIN_DEFAULT)
 ifeq ($(call isTargetOs, linux), true)
   SA_TOOLCHAIN := TOOLCHAIN_LINK_CXX
 endif
 
diff a/make/modules/jdk.jdwp.agent/Lib.gmk b/make/modules/jdk.jdwp.agent/Lib.gmk
--- a/make/modules/jdk.jdwp.agent/Lib.gmk
+++ b/make/modules/jdk.jdwp.agent/Lib.gmk
@@ -29,10 +29,11 @@
 
 $(eval $(call SetupJdkLibrary, BUILD_LIBDT_SOCKET, \
     NAME := dt_socket, \
     OPTIMIZATION := LOW, \
     CFLAGS := $(CFLAGS_JDKLIB) $(LIBDT_SOCKET_CPPFLAGS), \
+    DISABLED_WARNINGS_gcc := stringop-truncation, \
     EXTRA_HEADER_DIRS := \
         include \
         libjdwp/export, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
diff a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -91,10 +91,15 @@
   # stripping during the test libraries' build.
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libFib := -g
   BUILD_JDK_JTREG_LIBRARIES_STRIP_SYMBOLS_libFib := false
 endif
 
+ifeq ($(OPENJDK_TARGET_LIBC), musl)
+  # 'strncpy' output truncated before terminating nul copying as many bytes from a string as its length
+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libInheritedChannel := -Wno-stringop-truncation -Wno-stringop-overflow
+endif
+
 # This evaluation is expensive and should only be done if this target was
 # explicitly called.
 ifneq ($(filter build-test-jdk-jtreg-native, $(MAKECMDGOALS)), )
   $(eval $(call SetupTestFilesCompilation, BUILD_JDK_JTREG_LIBRARIES, \
       TYPE := LIBRARY, \
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -101,11 +101,10 @@
 # include <poll.h>
 # include <fcntl.h>
 # include <string.h>
 # include <syscall.h>
 # include <sys/sysinfo.h>
-# include <gnu/libc-version.h>
 # include <sys/ipc.h>
 # include <sys/shm.h>
 # include <link.h>
 # include <stdint.h>
 # include <inttypes.h>
@@ -150,12 +149,12 @@
 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
-const char * os::Linux::_glibc_version = NULL;
-const char * os::Linux::_libpthread_version = NULL;
+const char * os::Linux::_glibc_version = "unknown";
+const char * os::Linux::_libpthread_version = "unknown";
 size_t os::Linux::_default_large_page_size = 0;
 
 static jlong initial_time_count=0;
 
 static int clock_tics_per_sec = 100;
@@ -604,21 +603,25 @@
 #if !defined(_CS_GNU_LIBC_VERSION) || \
     !defined(_CS_GNU_LIBPTHREAD_VERSION)
   #error "glibc too old (< 2.3.2)"
 #endif
 
-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve glibc version");
-  char *str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBC_VERSION, str, n);
-  os::Linux::set_glibc_version(str);
+  size_t n;
+
+  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBC_VERSION, str, n);
+    os::Linux::set_glibc_version(str);
+  }
 
   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve pthread version");
-  str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
-  os::Linux::set_libpthread_version(str);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+    os::Linux::set_libpthread_version(str);
+  }
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // thread stack expansion
 
@@ -3193,24 +3196,40 @@
 
 // Something to do with the numa-aware allocator needs these symbols
 extern "C" JNIEXPORT void numa_warn(int number, char *where, ...) { }
 extern "C" JNIEXPORT void numa_error(char *where) { }
 
+static void* dlvsym_if_available(void* handle, const char* name, const char* version) {
+  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);
+  static dlvsym_func_type dlvsym_func;
+  static bool initialized = false;
+
+  if (!initialized) {
+    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, "dlvsym");
+    initialized = true;
+  }
+
+  if (dlvsym_func != NULL) {
+    void *f = dlvsym_func(handle, name, version);
+    if (f != NULL) {
+      return f;
+    }
+  }
+
+  return dlsym(handle, name);
+}
+
 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
 // load symbol from base version instead.
 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
-  void *f = dlvsym(handle, name, "libnuma_1.1");
-  if (f == NULL) {
-    f = dlsym(handle, name);
-  }
-  return f;
+  return dlvsym_if_available(handle, name, "libnuma_1.1");
 }
 
 // Handle request to load libnuma symbol version 1.2 (API v2) only.
 // Return NULL if the symbol is not defined in this particular version.
 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
-  return dlvsym(handle, name, "libnuma_1.2");
+  return dlvsym_if_available(handle, name, "libnuma_1.2");
 }
 
 bool os::Linux::libnuma_init() {
   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
     void *handle = dlopen("libnuma.so.1", RTLD_LAZY);
@@ -5153,10 +5172,67 @@
 }
 
 extern void report_error(char* file_name, int line_no, char* title,
                          char* format, ...);
 
+// Some linux distributions (notably: Alpine Linux) include the
+// grsecurity in the kernel by default. Of particular interest from a
+// JVM perspective is PaX (https://pax.grsecurity.net/), which adds
+// some security features related to page attributes. Specifically,
+// the MPROTECT PaX functionality
+// (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
+// code generation by disallowing a (previously) writable page to be
+// marked as executable. This is, of course, exactly what HotSpot does
+// for both JIT compiled method, as well as for stubs, adapters, etc.
+//
+// Instead of crashing "lazily" when trying to make a page executable,
+// this code probes for the presence of PaX and reports the failure
+// eagerly.
+static void check_pax(void) {
+  // Zero doesn't generate code dynamically, so no need to perform the PaX check
+#ifndef ZERO
+  size_t size = os::Linux::page_size();
+
+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+  if (p == MAP_FAILED) {
+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "failed to allocate memory for PaX check.");
+  }
+
+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
+  if (res == -1) {
+    vm_exit_during_initialization("Failed to mark memory page as executable",
+                                  "Please check if grsecurity/PaX is enabled in your kernel.\n"
+                                  "\n"
+                                  "For example, you can do this by running (note: you may need root privileges):\n"
+                                  "\n"
+                                  "    sysctl kernel.pax.softmode\n"
+                                  "\n"
+                                  "If PaX is included in the kernel you will see something like this:\n"
+                                  "\n"
+                                  "    kernel.pax.softmode = 0\n"
+                                  "\n"
+                                  "In particular, if the value is 0 (zero), then PaX is enabled.\n"
+                                  "\n"
+                                  "PaX includes security functionality which interferes with the dynamic code\n"
+                                  "generation the JVM relies on. Specifically, the MPROTECT functionality as\n"
+                                  "described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n"
+                                  "with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n"
+                                  "You can do this on a per-executable basis using the paxctl tool, for example:\n"
+                                  "\n"
+                                  "    paxctl -cm bin/java\n"
+                                  "\n"
+                                  "Please note that this modifies the executable binary in-place, so you may want\n"
+                                  "to make a backup of it first. Also note that you have to repeat this for other\n"
+                                  "executables like javac, jar, jcmd, etc.\n"
+                                  );
+
+  }
+
+  ::munmap(p, size);
+#endif
+}
+
 // this is called _before_ most of the global arguments have been parsed
 void os::init(void) {
   char dummy;   // used to get a guess on initial stack address
 
   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
@@ -5186,10 +5262,12 @@
 
   // retrieve entry point for pthread_setname_np
   Linux::_pthread_setname_np =
     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, "pthread_setname_np");
 
+  check_pax();
+
   os::Posix::init();
 
   initial_time_count = javaTimeNanos();
 
   // Always warn if no monotonic clock available
diff a/src/hotspot/share/gc/shared/genCollectedHeap.cpp b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
--- a/src/hotspot/share/gc/shared/genCollectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
@@ -1119,11 +1119,11 @@
 // Requires "*prev_ptr" to be non-NULL.  Deletes and a block of minimal size
 // from the list headed by "*prev_ptr".
 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
   bool first = true;
   size_t min_size = 0;   // "first" makes this conceptually infinite.
-  ScratchBlock **smallest_ptr, *smallest;
+  ScratchBlock **smallest_ptr = NULL, *smallest;
   ScratchBlock  *cur = *prev_ptr;
   while (cur) {
     assert(*prev_ptr == cur, "just checking");
     if (first || cur->num_words < min_size) {
       smallest_ptr = prev_ptr;
diff a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -255,16 +255,22 @@
     #endif
   #else
     #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
   #endif
 
+  #ifdef HOTSPOT_LIBC
+    #define LIBC_STR "-" HOTSPOT_LIBC
+  #else
+    #define LIBC_STR ""
+  #endif
+
   #ifndef HOTSPOT_BUILD_TIME
     #define HOTSPOT_BUILD_TIME __DATE__ " " __TIME__
   #endif
 
   #define INTERNAL_VERSION_SUFFIX VM_RELEASE ")" \
-         " for " OS "-" CPU FLOAT_ARCH_STR \
+         " for " OS "-" CPU FLOAT_ARCH_STR LIBC_STR \
          " JRE (" VERSION_STRING "), built on " HOTSPOT_BUILD_TIME \
          " by " XSTR(HOTSPOT_BUILD_USER) " with " HOTSPOT_BUILD_COMPILER
 
   return strcmp(DEBUG_LEVEL, "release") == 0
       ? VMNAME " (" INTERNAL_VERSION_SUFFIX
diff a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
@@ -110,11 +110,11 @@
 
 // checking for nanness
 #if defined(__APPLE__)
 inline int g_isnan(double f) { return isnan(f); }
 #elif defined(LINUX) || defined(_ALLBSD_SOURCE)
-inline int g_isnan(float  f) { return isnanf(f); }
+inline int g_isnan(float  f) { return isnan(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
 #error "missing platform-specific definition here"
 #endif
 
diff a/src/java.base/unix/native/libjava/jdk_util_md.h b/src/java.base/unix/native/libjava/jdk_util_md.h
--- a/src/java.base/unix/native/libjava/jdk_util_md.h
+++ b/src/java.base/unix/native/libjava/jdk_util_md.h
@@ -31,11 +31,11 @@
 #include <math.h>
 #define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <math.h>
-#define ISNANF(f) isnanf(f)
+#define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(_AIX)
 #include <math.h>
 #define ISNANF(f) _isnanf(f)
 #define ISNAND(d) _isnan(d)
diff a/src/java.base/unix/native/libjli/java_md.c b/src/java.base/unix/native/libjli/java_md.c
--- a/src/java.base/unix/native/libjli/java_md.c
+++ b/src/java.base/unix/native/libjli/java_md.c
@@ -228,10 +228,43 @@
     char jpath[PATH_MAX + 1];
     char *llp;
     char *dmllp = NULL;
     char *p; /* a utility pointer */
 
+#ifdef __linux
+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
+    if (strcmp(LIBC, "musl") == 0) {
+      /*
+       * The musl library loader requires LD_LIBRARY_PATH to be set in
+       * order to correctly resolve the dependency libjava.so has on libjvm.so.
+       *
+       * Specifically, it differs from glibc in the sense that even if
+       * libjvm.so has already been loaded it will not be considered a
+       * candidate for resolving the dependency unless the *full* path
+       * of the already loaded library matches the dependency being loaded.
+       *
+       * libjvm.so is being loaded by the launcher using a long path to
+       * dlopen, not just the basename of the library. Typically this
+       * is something like "../lib/server/libjvm.so". However, if/when
+       * libjvm.so later tries to dlopen libjava.so (which it does in
+       * order to get access to a few functions implemented in
+       * libjava.so) the musl loader will, as part of loading
+       * dependent libraries, try to load libjvm.so using only its
+       * basename "libjvm.so". Since this does not match the longer
+       * path path it was first loaded with, the already loaded
+       * library is not considered a candidate, and the loader will
+       * instead look for libjvm.so elsewhere. If it's not in
+       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
+       * will therefore fail as well.
+       */
+      return JNI_TRUE;
+    }
+#endif
+
 #ifdef AIX
     /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */
     return JNI_TRUE;
 #endif
 
diff a/src/java.base/unix/native/libnio/ch/NativeThread.c b/src/java.base/unix/native/libnio/ch/NativeThread.c
--- a/src/java.base/unix/native/libnio/ch/NativeThread.c
+++ b/src/java.base/unix/native/libnio/ch/NativeThread.c
@@ -34,11 +34,11 @@
 #include <signal.h>
 
 #ifdef __linux__
   #include <pthread.h>
   /* Also defined in net/linux_close.c */
-  #define INTERRUPT_SIGNAL (__SIGRTMAX - 2)
+  #define INTERRUPT_SIGNAL (SIGRTMAX - 2)
 #elif defined(_AIX)
   #include <pthread.h>
   /* Also defined in net/aix_close.c */
   #define INTERRUPT_SIGNAL (SIGRTMAX - 1)
 #elif defined(_ALLBSD_SOURCE)
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
@@ -277,13 +277,14 @@
         print_debug("Thread with pid %d does not exist\n", pid);
         return ATTACH_THREAD_DEAD;
       }
     }
     char buf[200];
-    char* msg = strerror_r(errno, buf, sizeof(buf));
-    snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, msg);
-    print_error("%s\n", err_buf);
+    if (strerror_r(errno, buf, sizeof(buf) == 0)) {
+      snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, buf);
+      print_error("%s\n", err_buf);
+    }
     return ATTACH_FAIL;
   } else {
     attach_state_t wait_ret = ptrace_waitpid(pid);
     if (wait_ret == ATTACH_THREAD_DEAD) {
       print_debug("Thread with pid %d does not exist\n", pid);
diff a/src/jdk.jdwp.agent/share/native/libjdwp/util.h b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
@@ -33,19 +33,19 @@
 #include <stdarg.h>
 
 #ifdef DEBUG
     /* Just to make sure these interfaces are not used here. */
     #undef free
-    #define free(p) Do not use this interface.
+    #define free do_not_use_this_interface_free
     #undef malloc
-    #define malloc(p) Do not use this interface.
+    #define malloc do_not_use_this_interface_malloc
     #undef calloc
-    #define calloc(p) Do not use this interface.
+    #define calloc do_not_use_this_interface_calloc
     #undef realloc
-    #define realloc(p) Do not use this interface.
+    #define realloc do_not_use_this_interface_realloc
     #undef strdup
-    #define strdup(p) Do not use this interface.
+    #define strdup do_not_use_this_interface_strdup
 #endif
 
 #include "log_messages.h"
 #include "vm_interface.h"
 #include "JDWP.h"
diff a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
--- a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
+++ b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
@@ -117,16 +117,17 @@
         public static void main(String[] args) throws IOException, InterruptedException {
             ProcessBuilder pb = createJavaProcessBuilder(
                 "-Dtest.jdk=" + getProperty("test.jdk"),
                 VMShouldNotInheritFileDescriptors.class.getName(),
                 args[0],
-                "" + ProcessHandle.current().pid());
+                getPid());
             pb.inheritIO(); // in future, redirect information from third VM to first VM
             pb.start();
 
             if (!isWindows()) {
-                System.out.println("(Second VM) Open file descriptors:\n" + outputContainingFilenames().stream().collect(joining("\n")));
+                System.out.printf("(Second VM) Open file descriptors: %s%n",
+                        outputContainingFilenames().stream().collect(joining("\n")));
             }
         }
     }
 
     static class VMShouldNotInheritFileDescriptors {
@@ -169,29 +170,35 @@
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
-    static Optional<String[]> lsofCommandCache = stream(new String[][]{
-            {"/usr/bin/lsof", "-p"},
-            {"/usr/sbin/lsof", "-p"},
-            {"/bin/lsof", "-p"},
-            {"/sbin/lsof", "-p"},
-            {"/usr/local/bin/lsof", "-p"}})
-        .filter(args -> new File(args[0]).exists())
+    static Optional<Command> lsofCommandCache = stream(new Command[]{
+            new Command("/usr/bin/lsof", "-p"),
+            new Command("/usr/sbin/lsof", "-p"),
+            new Command("/bin/lsof", "-p"),
+            new Command("/sbin/lsof", "-p"),
+            new Command("/usr/local/bin/lsof", "-p"),
+        })
+        .filter(command -> command.exists())
         .findFirst();
 
-    static Optional<String[]> lsofCommand() {
+    static Optional<Command> lsofCommand() {
         return lsofCommandCache;
     }
 
-    static Collection<String> outputContainingFilenames() {
-        long pid = ProcessHandle.current().pid();
+    static Command lsofCmd() {
+        return lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
+    }
 
-        String[] command = lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
-        System.out.println("using command: " + command[0] + " " + command[1]);
-        return run(command[0], command[1], "" + pid).collect(toList());
+    static Collection<String> outputContainingFilenames() {
+        String pid = getPid();
+        Command command = lsofCmd();
+        System.out.printf("using command: %s%n", command);
+        return run(command.name, command.option, pid)
+                .filter(line -> line.contains(pid))
+                .collect(toList());
     }
 
     static boolean findOpenLogFile(Collection<String> fileNames) {
         return fileNames.stream()
             .filter(fileName -> fileName.contains(LOG_SUFFIX))
@@ -203,7 +210,30 @@
         System.out.println("waiting for pid: " + parentPid);
         ProcessHandle.of(parentPid).ifPresent(handle -> handle.onExit().join());
         System.out.println("trying to rename file to the same name: " + f);
         System.out.println(f.renameTo(f) ? RETAINS_FD : LEAKS_FD); // this parts communicates a closed file descriptor by printing "VM RESULT => RETAINS FD"
     }
+
+    private static String getPid() {
+        return Long.toString(ProcessHandle.current().pid());
+    }
+
+    private static class Command {
+        private final String name;
+        private final String option;
+
+        public Command(String name, String option) {
+            this.name = name;
+            this.option = option;
+        }
+
+        private boolean exists() {
+            return new File(name).exists();
+        }
+
+        public String toString() {
+            return String.format("[name: %s, option: %s]",
+                    name, option);
+        }
+    }
 }
 
diff a/test/jdk/TEST.ROOT b/test/jdk/TEST.ROOT
--- a/test/jdk/TEST.ROOT
+++ b/test/jdk/TEST.ROOT
@@ -50,10 +50,11 @@
     vm.gc.Shenandoah \
     vm.graal.enabled \
     vm.compiler1.enabled \
     vm.compiler2.enabled \
     vm.cds \
+    vm.musl \
     vm.debug \
     vm.hasSA \
     vm.hasJFR \
     docker.support \
     release.implementor
diff a/test/jdk/java/lang/ProcessBuilder/Basic.java b/test/jdk/java/lang/ProcessBuilder/Basic.java
--- a/test/jdk/java/lang/ProcessBuilder/Basic.java
+++ b/test/jdk/java/lang/ProcessBuilder/Basic.java
@@ -398,12 +398,12 @@
                 }
 
                 if (failed != 0) throw new Error("null PATH");
             } else if (action.equals("PATH search algorithm")) {
                 equal(System.getenv("PATH"), "dir1:dir2:");
-                check(new File("/bin/true").exists());
-                check(new File("/bin/false").exists());
+                check(new File(TrueExe.path()).exists());
+                check(new File(FalseExe.path()).exists());
                 String[] cmd = {"prog"};
                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
                 pb2.environment().put("PATH", "anyOldPathIgnoredAnyways");
@@ -440,17 +440,17 @@
                         // Report EACCES errno
                         new File("dir1/prog").mkdirs();
                         checkPermissionDenied(pb);
 
                         // continue searching if EACCES
-                        copy("/bin/true", "dir2/prog");
+                        copy(TrueExe.path(), "dir2/prog");
                         equal(run(pb).exitValue(), True.exitValue());
                         new File("dir1/prog").delete();
                         new File("dir2/prog").delete();
 
                         new File("dir2/prog").mkdirs();
-                        copy("/bin/true", "dir1/prog");
+                        copy(TrueExe.path(), "dir1/prog");
                         equal(run(pb).exitValue(), True.exitValue());
 
                         // Check empty PATH component means current directory.
                         //
                         // While we're here, let's test different kinds of
@@ -462,14 +462,14 @@
                                      new String[] {"./prog"},
                                      cmd}) {
                             pb.command(command);
                             File prog = new File("./prog");
                             // "Normal" binaries
-                            copy("/bin/true", "./prog");
+                            copy(TrueExe.path(), "./prog");
                             equal(run(pb).exitValue(),
                                   True.exitValue());
-                            copy("/bin/false", "./prog");
+                            copy(FalseExe.path(), "./prog");
                             equal(run(pb).exitValue(),
                                   False.exitValue());
                             prog.delete();
                             // Interpreter scripts with #!
                             setFileContents(prog, "#!/bin/true\n");
@@ -520,16 +520,16 @@
                         // parent's is used.
                         new File("dir1/prog").delete();
                         new File("dir2/prog").delete();
                         new File("prog").delete();
                         new File("dir3").mkdirs();
-                        copy("/bin/true", "dir1/prog");
-                        copy("/bin/false", "dir3/prog");
+                        copy(TrueExe.path(), "dir1/prog");
+                        copy(FalseExe.path(), "dir3/prog");
                         pb.environment().put("PATH","dir3");
                         equal(run(pb).exitValue(), True.exitValue());
-                        copy("/bin/true", "dir3/prog");
-                        copy("/bin/false", "dir1/prog");
+                        copy(TrueExe.path(), "dir3/prog");
+                        copy(FalseExe.path(), "dir1/prog");
                         equal(run(pb).exitValue(), False.exitValue());
 
                     } finally {
                         // cleanup
                         new File("dir1/prog").delete();
@@ -622,10 +622,17 @@
              new File("/bin/sh").exists() &&
              new File("/bin/true").exists() &&
              new File("/bin/false").exists());
     }
 
+    static class BusyBox {
+        public static boolean is() { return is; }
+        private static final boolean is =
+            (! Windows.is() &&
+             new File("/bin/busybox").exists());
+    }
+
     static class UnicodeOS {
         public static boolean is() { return is; }
         private static final String osName = System.getProperty("os.name");
         private static final boolean is =
             // MacOS X would probably also qualify
@@ -660,10 +667,49 @@
                 }
             } catch (Throwable t) { unexpected(t); return -1; }
         }
     }
 
+    // On alpine linux, /bin/true and /bin/false are just links to /bin/busybox.
+    // Some tests copy /bin/true and /bin/false to files with a different filename.
+    // However, copying the busbox executable into a file with a different name
+    // won't result in the expected return codes. As workaround, we create
+    // executable files that can be copied and produce the exepected return
+    // values. We use this workaround, if we find the busybox executable.
+
+    private static class TrueExe {
+        public static String path() { return path; }
+        private static final String path = path0();
+        private static String path0(){
+            if (!BusyBox.is()) {
+                return "/bin/true";
+            }
+            else {
+                File trueExe = new File("true");
+                setFileContents(trueExe, "#!/bin/true\n");
+                trueExe.setExecutable(true);
+                return trueExe.getAbsolutePath();
+            }
+        }
+    }
+
+    private static class FalseExe {
+        public static String path() { return path; }
+        private static final String path = path0();
+        private static String path0(){
+            if (!BusyBox.is()) {
+                return "/bin/false";
+            }
+            else {
+                File falseExe = new File("false");
+                setFileContents(falseExe, "#!/bin/false\n");
+                falseExe.setExecutable(true);
+                return falseExe.getAbsolutePath();
+            }
+        }
+    }
+
     static class EnglishUnix {
         private static final Boolean is =
             (! Windows.is() && isEnglish("LANG") && isEnglish("LC_ALL"));
 
         private static boolean isEnglish(String envvar) {
@@ -1963,11 +2009,11 @@
             //----------------------------------------------------------------
             // Parent's, not child's PATH is used
             //----------------------------------------------------------------
             try {
                 new File("suBdiR").mkdirs();
-                copy("/bin/true", "suBdiR/unliKely");
+                copy(TrueExe.path(), "suBdiR/unliKely");
                 final ProcessBuilder pb =
                     new ProcessBuilder(new String[]{"unliKely"});
                 pb.environment().put("PATH", "suBdiR");
                 THROWS(IOException.class, () -> pb.start());
             } catch (Throwable t) { unexpected(t);
diff a/test/jdk/tools/launcher/ExecutionEnvironment.java b/test/jdk/tools/launcher/ExecutionEnvironment.java
--- a/test/jdk/tools/launcher/ExecutionEnvironment.java
+++ b/test/jdk/tools/launcher/ExecutionEnvironment.java
@@ -133,20 +133,26 @@
 
         if (!tr.isNotZeroOutput()) {
             flagError(tr, "Error: No output at all. Did the test execute ?");
         }
 
+        boolean isExpandedLibPath = TestHelper.isExpandedSharedLibraryPath;
+
         for (String x : LD_PATH_STRINGS) {
             if (!tr.contains(x)) {
-                if (TestHelper.isAIX && x.startsWith(LD_LIBRARY_PATH)) {
+                if (isExpandedLibPath && x.startsWith(LD_LIBRARY_PATH)) {
                     // AIX does not support the '-rpath' linker options so the
                     // launchers have to prepend the jdk library path to 'LIBPATH'.
-                    String aixLibPath = LD_LIBRARY_PATH + "=" +
-                        System.getenv(LD_LIBRARY_PATH) +
-                        System.getProperty("path.separator") + LD_LIBRARY_PATH_VALUE;
-                    if (!tr.matches(aixLibPath)) {
-                        flagError(tr, "FAIL: did not get <" + aixLibPath + ">");
+                    // The musl library loader requires LD_LIBRARY_PATH to be set in
+                    // order to correctly resolve the dependency libjava.so has on libjvm.so.
+                    String expandedLibPath = String.format("%s=%s%c%s",
+                            LD_LIBRARY_PATH,
+                            System.getenv(LD_LIBRARY_PATH),
+                            File.pathSeparatorChar,
+                            LD_LIBRARY_PATH_VALUE);
+                    if (!tr.matches(expandedLibPath)) {
+                        flagError(tr, "FAIL: did not get <" + expandedLibPath + ">");
                     }
                 }
                 else {
                     flagError(tr, "FAIL: did not get <" + x + ">");
                 }
diff a/test/jdk/tools/launcher/Test7029048.java b/test/jdk/tools/launcher/Test7029048.java
--- a/test/jdk/tools/launcher/Test7029048.java
+++ b/test/jdk/tools/launcher/Test7029048.java
@@ -153,24 +153,24 @@
                     } else {
                         Files.deleteIfExists(dstServerLibjvm.toPath());
                     }
 
                     desc = "LD_LIBRARY_PATH should not be set (no libjvm.so)";
-                    if (TestHelper.isAIX) {
+                    if (TestHelper.isExpandedSharedLibraryPath) {
                         System.out.println("Skipping test case \"" + desc +
-                                           "\" because the Aix launcher adds the paths in any case.");
+                                           "\" because the Aix and Musl launchers add the paths in any case.");
                         continue;
                     }
                     break;
                 case NO_DIR:
                     if (dstLibDir.exists()) {
                         recursiveDelete(dstLibDir);
                     }
                     desc = "LD_LIBRARY_PATH should not be set (no directory)";
-                    if (TestHelper.isAIX) {
+                    if (TestHelper.isExpandedSharedLibraryPath) {
                         System.out.println("Skipping test case \"" + desc +
-                                           "\" because the Aix launcher adds the paths in any case.");
+                                           "\" because the Aix and Musl launchers add the paths in any case.");
                         continue;
                     }
                     break;
                 default:
                     throw new RuntimeException("unknown case");
@@ -209,16 +209,19 @@
         // create our test jar first
         ExecutionEnvironment.createTestJar();
 
         // run the tests
         test7029048();
+
+        int passesLinux = TestHelper.isMusl ? 2 : 6;
+
         if (errors > 0) {
             throw new Exception("Test7029048: FAIL: with "
                     + errors + " errors and passes " + passes);
-        } else if (isLinux && passes < 6) {
+        } else if (isLinux && passes < passesLinux) {
              throw new Exception("Test7029048: FAIL: " +
-                    "all tests did not run, expected " + 6 + " got " + passes);
+                    "all tests did not run, expected " + passesLinux + " got " + passes);
         } else {
             System.out.println("Test7029048: PASS " + passes);
         }
     }
 }
diff a/test/jdk/tools/launcher/TestHelper.java b/test/jdk/tools/launcher/TestHelper.java
--- a/test/jdk/tools/launcher/TestHelper.java
+++ b/test/jdk/tools/launcher/TestHelper.java
@@ -87,13 +87,15 @@
             System.getProperty("sun.arch.data.model").equals("32");
     static final boolean isLinux =
             System.getProperty("os.name", "unknown").startsWith("Linux");
     static final boolean isAIX =
             System.getProperty("os.name", "unknown").startsWith("AIX");
+    static final boolean isMusl = isMuslLibc();
     static final String LIBJVM = isWindows
                         ? "jvm.dll"
                         : "libjvm" + (isMacOSX ? ".dylib" : ".so");
+    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;
 
     // make a note of the golden default locale
     static final Locale DefaultLocale = Locale.getDefault();
 
     static final String JAVA_FILE_EXT   = ".java";
@@ -530,10 +532,31 @@
             "}"
         };
         createFile(new File(launcherTestDir, "Main.java"), Arrays.asList(moduleCode));
     }
 
+    /**
+     * Check if we run with musl libc.
+     *
+     * @return true if we run with musl libc.
+     */
+    private static boolean isMuslLibc() {
+        try {
+            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
+            pb.redirectErrorStream(true);
+            final Process p = pb.start();
+            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+                return br.lines()
+                        .findFirst()
+                        .filter(line -> line.contains("musl"))
+                        .isPresent();
+            }
+        } catch (Exception ignore) {
+        }
+        return false;
+    }
+
     static class ToolFilter implements FileFilter {
         final List<String> exclude = new ArrayList<>();
         protected ToolFilter(String... exclude) {
             for (String x : exclude) {
                 String str = x + ((isWindows) ? EXE_FILE_EXT : "");
