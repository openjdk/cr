<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AWTChartToolkit.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../misc/ChartCanvas.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * 
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * The contents of this file are subject to the terms of either the Universal Permissive License
   * v 1.0 as shown at http://oss.oracle.com/licenses/upl
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * 
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * The contents of this file are subject to the terms of either the Universal Permissive License
   * v 1.0 as shown at http://oss.oracle.com/licenses/upl
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,52 ***</span>
  import java.awt.geom.Point2D;
  import java.util.ArrayList;
  import java.util.HashSet;
  import java.util.List;
  import java.util.Set;
  import java.util.function.Consumer;
  
  import org.openjdk.jmc.common.IDisplayable;
  import org.openjdk.jmc.common.unit.IQuantity;
  import org.openjdk.jmc.common.unit.IRange;
  import org.openjdk.jmc.common.unit.QuantitiesToolkit;
  import org.openjdk.jmc.common.unit.QuantityRange;
  import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
  
  public class XYChart {
  	private static final String ELLIPSIS = &quot;...&quot;; //$NON-NLS-1$
  	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
  	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
<span class="line-modified">! 	private static final int Y_OFFSET = 35;</span>
<span class="line-modified">! 	private static final int RANGE_INDICATOR_HEIGHT = 4;</span>
  	private final IQuantity start;
  	private final IQuantity end;
  	private IXDataRenderer rendererRoot;
  	private IRenderedRow rendererResult;
  	private final int xOffset;
  	private final int bucketWidth;
  	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
  //	private final int ticksPerBucket = 4;
  
  	private IQuantity currentStart;
  	private IQuantity currentEnd;
  
  	private final Set&lt;Object&gt; selectedRows = new HashSet&lt;&gt;();
  	private IQuantity selectionStart;
  	private IQuantity selectionEnd;
  	private SubdividedQuantityRange xBucketRange;
  	private SubdividedQuantityRange xTickRange;
<span class="line-modified">! 	private int axisWidth;</span>
  
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot) {
  		this(range.getStart(), range.getEnd(), rendererRoot);
  	}
  
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset) {
  		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
  	}
  
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
  		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
  	}
  
  	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
<span class="line-new-header">--- 39,85 ---</span>
  import java.awt.geom.Point2D;
  import java.util.ArrayList;
  import java.util.HashSet;
  import java.util.List;
  import java.util.Set;
<span class="line-added">+ import java.util.Stack;</span>
  import java.util.function.Consumer;
  
  import org.openjdk.jmc.common.IDisplayable;
  import org.openjdk.jmc.common.unit.IQuantity;
  import org.openjdk.jmc.common.unit.IRange;
  import org.openjdk.jmc.common.unit.QuantitiesToolkit;
  import org.openjdk.jmc.common.unit.QuantityRange;
<span class="line-added">+ import org.openjdk.jmc.common.unit.UnitLookup;</span>
  import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
<span class="line-added">+ import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;</span>
<span class="line-added">+ import org.openjdk.jmc.ui.misc.TimelineCanvas;</span>
<span class="line-added">+ import org.openjdk.jmc.ui.misc.PatternFly.Palette;</span>
  
  public class XYChart {
  	private static final String ELLIPSIS = &quot;...&quot;; //$NON-NLS-1$
  	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
  	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
<span class="line-modified">! 	private static final int BASE_ZOOM_LEVEL = 100;</span>
<span class="line-modified">! 	private static final int RANGE_INDICATOR_HEIGHT = 7;</span>
  	private final IQuantity start;
  	private final IQuantity end;
<span class="line-added">+ 	private IQuantity rangeDuration;</span>
  	private IXDataRenderer rendererRoot;
  	private IRenderedRow rendererResult;
  	private final int xOffset;
<span class="line-added">+ 	private int yOffset = 35;</span>
  	private final int bucketWidth;
  	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
  //	private final int ticksPerBucket = 4;
  
  	private IQuantity currentStart;
  	private IQuantity currentEnd;
  
  	private final Set&lt;Object&gt; selectedRows = new HashSet&lt;&gt;();
<span class="line-added">+ 	private int axisWidth;</span>
<span class="line-added">+ 	private int rowColorCounter;</span>
  	private IQuantity selectionStart;
  	private IQuantity selectionEnd;
  	private SubdividedQuantityRange xBucketRange;
  	private SubdividedQuantityRange xTickRange;
<span class="line-modified">! </span>
<span class="line-added">+ 	// JFR Threads Page</span>
<span class="line-added">+ 	private static final double ZOOM_PAN_FACTOR = 0.05;</span>
<span class="line-added">+ 	private static final int ZOOM_PAN_MODIFIER = 2;</span>
<span class="line-added">+ 	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 	private double currentZoom;</span>
<span class="line-added">+ 	private int zoomSteps;</span>
<span class="line-added">+ 	private ChartDisplayControlBar displayBar;</span>
<span class="line-added">+ 	private ChartFilterControlBar filterBar;</span>
<span class="line-added">+ 	private Stack&lt;Integer&gt; modifiedSteps;</span>
<span class="line-added">+ 	private TimelineCanvas timelineCanvas;</span>
<span class="line-added">+ 	private int longestCharWidth = 0;</span>
  
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot) {
  		this(range.getStart(), range.getEnd(), rendererRoot);
  	}
  
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset) {
  		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
  	}
  
<span class="line-added">+ 	// JFR Threads Page</span>
<span class="line-added">+ 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,</span>
<span class="line-added">+ 			TimelineCanvas timelineCanvas, ChartFilterControlBar filterBar, ChartDisplayControlBar displayBar) {</span>
<span class="line-added">+ 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);</span>
<span class="line-added">+ 		this.yOffset = yOffset;</span>
<span class="line-added">+ 		this.timelineCanvas = timelineCanvas;</span>
<span class="line-added">+ 		this.filterBar = filterBar;</span>
<span class="line-added">+ 		this.displayBar = displayBar;</span>
<span class="line-added">+ 		this.rangeDuration = range.getExtent();</span>
<span class="line-added">+ 		this.currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">+ 		this.isZoomCalculated = false;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
  		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
  	}
  
  	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,21 ***</span>
  
  	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
  		this.rendererRoot = rendererRoot;
  		// Start value must always be strictly less than end
  		assert (start.compareTo(end) &lt; 0);
<span class="line-modified">! 		currentStart = start;</span>
  		this.start = start;
<span class="line-modified">! 		currentEnd = end;</span>
  		this.end = end;
  		this.xOffset = xOffset;
  		this.bucketWidth = bucketWidth;
  	}
  
  	public void setRendererRoot(IXDataRenderer rendererRoot) {
  		clearSelection();
  		this.rendererRoot = rendererRoot;
  	}
  
  	public IXDataRenderer getRendererRoot() {
  		return rendererRoot;
  	}
<span class="line-new-header">--- 130,22 ---</span>
  
  	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
  		this.rendererRoot = rendererRoot;
  		// Start value must always be strictly less than end
  		assert (start.compareTo(end) &lt; 0);
<span class="line-modified">! 		this.currentStart = start;</span>
  		this.start = start;
<span class="line-modified">! 		this.currentEnd = end;</span>
  		this.end = end;
  		this.xOffset = xOffset;
  		this.bucketWidth = bucketWidth;
  	}
  
  	public void setRendererRoot(IXDataRenderer rendererRoot) {
  		clearSelection();
  		this.rendererRoot = rendererRoot;
<span class="line-added">+ 		longestCharWidth = 0;</span>
  	}
  
  	public IXDataRenderer getRendererRoot() {
  		return rendererRoot;
  	}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,96 ***</span>
  	public IRange&lt;IQuantity&gt; getSelectionRange() {
  		return (selectionStart != null) &amp;&amp; (selectionEnd != null)
  				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
  	}
  
<span class="line-modified">! 	public void render(Graphics2D context, int width, int height) {</span>
<span class="line-modified">! 		if (width &gt; xOffset &amp;&amp; height &gt; Y_OFFSET) {</span>
  			axisWidth = width - xOffset;
  			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
  			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
  			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
  			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
  			AffineTransform oldTransform = context.getTransform();
  			context.translate(xOffset, 0);
<span class="line-modified">! 			doRender(context, height - Y_OFFSET);</span>
  			context.setTransform(oldTransform);
  		}
  	}
  
  	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
  		// FIXME: Extract the needed functionality from SubdividedQuantityRange
  		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
  		int x1 = (int) fullRangeAxis.getPixel(currentStart);
  		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
<span class="line-modified">! 		if (x1 &gt; 0 || x2 &lt; axisWidth) {</span>
  			context.setPaint(RANGE_INDICATION_COLOR);
  			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
  			context.setPaint(Color.DARK_GRAY);
  			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
  		}
  	}
  
<span class="line-modified">! 	private void doRender(Graphics2D context, int axisHeight) {</span>
  		context.setPaint(Color.LIGHT_GRAY);
  		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
  		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
  		context.setPaint(Color.BLACK);
<span class="line-modified">! 		AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);</span>
  		// ... then the graph ...
<span class="line-modified">! 		rendererResult = rendererRoot.render(context, xBucketRange, axisHeight);</span>
  		AffineTransform oldTransform = context.getTransform();
<span class="line-modified">! 		renderText(context, rendererResult);</span>
  		context.setTransform(oldTransform);
  		if (!selectedRows.isEmpty()) {
<span class="line-modified">! 			renderSelection(context, rendererResult);</span>
  			context.setTransform(oldTransform);
  		}
  		// .. and finally a semitransparent axis line again.
  		context.setPaint(new Color(0, 0, 0, 64));
  		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
  		renderRangeIndication(context, axisHeight + 25);
  	}
  
<span class="line-modified">! 	private void renderSelection(Graphics2D context, IRenderedRow row) {</span>
  		if (selectedRows.contains(row.getPayload())) {
  			renderSelection(context, xBucketRange, row.getHeight());
  		} else {
  			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
  			if (subdivision.isEmpty()) {
  				dimRect(context, 0, axisWidth, row.getHeight());
  			} else {
  				for (IRenderedRow nestedRow : row.getNestedRows()) {
<span class="line-modified">! 					renderSelection(context, nestedRow);</span>
  				}
  				return;
  			}
  		}
  		context.translate(0, row.getHeight());
  	}
  
  	private void renderText(Graphics2D context, IRenderedRow row) {
  		String text = row.getName();
  		int height = row.getHeight();
  		if (height &gt;= context.getFontMetrics().getHeight()) {
  			if (text != null) {
  				context.setColor(Color.BLACK);
<span class="line-modified">! 				int y;</span>
<span class="line-modified">! 				if (height &gt; 40) {</span>
<span class="line-removed">- 					context.drawLine(-xOffset, height - 1, -15, height - 1);</span>
<span class="line-removed">- 					y = height - context.getFontMetrics().getHeight() / 2;</span>
<span class="line-removed">- 				} else {</span>
<span class="line-removed">- 					// draw the string in the middle of the row</span>
<span class="line-removed">- 					y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();</span>
<span class="line-removed">- 				}</span>
  				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
<span class="line-modified">! 				if (charsWidth &gt; xOffset) {</span>
  					float fitRatio = ((float) xOffset) / (charsWidth
  							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
  					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
  				}
<span class="line-modified">! 				context.drawString(text, -xOffset + 2, y);</span>
  			} else {
  				List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
  				if (!subdivision.isEmpty()) {
  					for (IRenderedRow nestedRow : row.getNestedRows()) {
  						renderText(context, nestedRow);
<span class="line-new-header">--- 165,195 ---</span>
  	public IRange&lt;IQuantity&gt; getSelectionRange() {
  		return (selectionStart != null) &amp;&amp; (selectionEnd != null)
  				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
  	}
  
<span class="line-modified">! 	public void renderChart(Graphics2D context, int width, int height) {</span>
<span class="line-modified">! 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
  			axisWidth = width - xOffset;
  			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
  			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
  			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
  			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
  			AffineTransform oldTransform = context.getTransform();
  			context.translate(xOffset, 0);
<span class="line-modified">! 			doRenderChart(context, height - yOffset);</span>
  			context.setTransform(oldTransform);
  		}
  	}
  
<span class="line-added">+ 	public void renderTextCanvasText(Graphics2D context, int width, int height) {</span>
<span class="line-added">+ 		axisWidth = width;</span>
<span class="line-added">+ 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">+ 		doRenderTextCanvasText(context, height);</span>
<span class="line-added">+ 		context.setTransform(oldTransform);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	public void renderText(Graphics2D context, int width, int height) {</span>
<span class="line-added">+ 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
<span class="line-added">+ 			axisWidth = xOffset;</span>
<span class="line-added">+ 			AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">+ 			doRenderText(context);</span>
<span class="line-added">+ 			context.setTransform(oldTransform);</span>
<span class="line-added">+ 			axisWidth = width - xOffset;</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
  		// FIXME: Extract the needed functionality from SubdividedQuantityRange
  		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
  		int x1 = (int) fullRangeAxis.getPixel(currentStart);
  		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
<span class="line-modified">! </span>
<span class="line-added">+ 		if (timelineCanvas != null) {</span>
<span class="line-added">+ 			timelineCanvas.renderRangeIndicator(x1, x2);</span>
<span class="line-added">+ 			updateZoomPanIndicator();</span>
<span class="line-added">+ 		} else {</span>
  			context.setPaint(RANGE_INDICATION_COLOR);
  			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
  			context.setPaint(Color.DARK_GRAY);
  			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
  		}
  	}
  
<span class="line-modified">! 	public void updateZoomPanIndicator() {</span>
<span class="line-added">+ 		if (displayBar != null) {</span>
<span class="line-added">+ 			displayBar.updateZoomPanIndicator();</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {</span>
<span class="line-added">+ 		if (xBucketRange == null) {</span>
<span class="line-added">+ 			xBucketRange = getXBucketRange();</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		return rendererRoot.render(context, xBucketRange, axisHeight);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private SubdividedQuantityRange getXBucketRange() {</span>
<span class="line-added">+ 		return new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private void doRenderChart(Graphics2D context, int axisHeight) {</span>
<span class="line-added">+ 		rowColorCounter = 0;</span>
  		context.setPaint(Color.LIGHT_GRAY);
  		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
  		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
  		context.setPaint(Color.BLACK);
<span class="line-modified">! 		if (timelineCanvas != null) {</span>
<span class="line-added">+ 			timelineCanvas.setXTickRange(xTickRange);</span>
<span class="line-added">+ 		} else {</span>
<span class="line-added">+ 			AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);</span>
<span class="line-added">+ 		}</span>
  		// ... then the graph ...
<span class="line-modified">! 		rendererResult = getRendererResult(context, axisHeight);</span>
  		AffineTransform oldTransform = context.getTransform();
<span class="line-modified">! </span>
  		context.setTransform(oldTransform);
  		if (!selectedRows.isEmpty()) {
<span class="line-modified">! 			renderSelectionChart(context, rendererResult);</span>
  			context.setTransform(oldTransform);
  		}
  		// .. and finally a semitransparent axis line again.
  		context.setPaint(new Color(0, 0, 0, 64));
  		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
  		renderRangeIndication(context, axisHeight + 25);
  	}
  
<span class="line-modified">! 	private void doRenderText(Graphics2D context) {</span>
<span class="line-added">+ 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">+ 		rowColorCounter = -1;</span>
<span class="line-added">+ 		renderText(context, rendererResult);</span>
<span class="line-added">+ 		context.setTransform(oldTransform);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private void doRenderTextCanvasText(Graphics2D context, int height) {</span>
<span class="line-added">+ 		if (rendererResult == null) {</span>
<span class="line-added">+ 			rendererResult = getRendererResult(context, height - yOffset);</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">+ 		rowColorCounter = 0;</span>
<span class="line-added">+ 		renderText(context, rendererResult);</span>
<span class="line-added">+ 		context.setTransform(oldTransform);</span>
<span class="line-added">+ 		if (!selectedRows.isEmpty()) {</span>
<span class="line-added">+ 			renderSelectionText(context, rendererResult);</span>
<span class="line-added">+ 			context.setTransform(oldTransform);</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private void renderSelectionText(Graphics2D context, IRenderedRow row) {</span>
<span class="line-added">+ 		if (selectedRows.contains(row.getPayload())) {</span>
<span class="line-added">+ 			if (row.getHeight() != rendererResult.getHeight()) {</span>
<span class="line-added">+ 				Color highlight = new Color(0, 206, 209, 20);</span>
<span class="line-added">+ 				context.setColor(highlight);</span>
<span class="line-added">+ 				context.fillRect(0, 0, axisWidth, row.getHeight());</span>
<span class="line-added">+ 			} else {</span>
<span class="line-added">+ 				selectedRows.clear();</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 		} else {</span>
<span class="line-added">+ 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();</span>
<span class="line-added">+ 			if (subdivision.isEmpty()) {</span>
<span class="line-added">+ 				dimRect(context, 0, axisWidth, row.getHeight());</span>
<span class="line-added">+ 			} else {</span>
<span class="line-added">+ 				for (IRenderedRow nestedRow : row.getNestedRows()) {</span>
<span class="line-added">+ 					renderSelectionText(context, nestedRow);</span>
<span class="line-added">+ 				}</span>
<span class="line-added">+ 				return;</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		context.translate(0, row.getHeight());</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private void renderSelectionChart(Graphics2D context, IRenderedRow row) {</span>
  		if (selectedRows.contains(row.getPayload())) {
  			renderSelection(context, xBucketRange, row.getHeight());
  		} else {
  			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
  			if (subdivision.isEmpty()) {
  				dimRect(context, 0, axisWidth, row.getHeight());
  			} else {
  				for (IRenderedRow nestedRow : row.getNestedRows()) {
<span class="line-modified">! 					renderSelectionChart(context, nestedRow);</span>
  				}
  				return;
  			}
  		}
  		context.translate(0, row.getHeight());
  	}
  
<span class="line-added">+ 	// Paint the background of every-other row in a slightly different shade</span>
<span class="line-added">+ 	// to better differentiate the thread lanes from one another</span>
<span class="line-added">+ 	private void paintRowBackground(Graphics2D context, int height) {</span>
<span class="line-added">+ 		if (rowColorCounter &gt;= 0) {</span>
<span class="line-added">+ 			if (rowColorCounter % 2 == 0) {</span>
<span class="line-added">+ 				context.setColor(Palette.PF_BLACK_100.getAWTColor());</span>
<span class="line-added">+ 			} else {</span>
<span class="line-added">+ 				context.setColor(Palette.PF_BLACK_200.getAWTColor());</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 			context.fillRect(0, 0, axisWidth, height);</span>
<span class="line-added">+ 			rowColorCounter++;</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	private void renderText(Graphics2D context, IRenderedRow row) {
  		String text = row.getName();
  		int height = row.getHeight();
  		if (height &gt;= context.getFontMetrics().getHeight()) {
  			if (text != null) {
<span class="line-added">+ 				paintRowBackground(context, row.getHeight());</span>
  				context.setColor(Color.BLACK);
<span class="line-modified">! 				context.drawLine(0, height - 1, axisWidth - 15, height - 1);</span>
<span class="line-modified">! 				int y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();</span>
  				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
<span class="line-modified">! 				if (charsWidth &gt; longestCharWidth) {</span>
<span class="line-added">+ 					longestCharWidth = charsWidth;</span>
<span class="line-added">+ 				}</span>
<span class="line-added">+ 				if (xOffset &gt; 0 &amp;&amp; charsWidth &gt; xOffset) {</span>
  					float fitRatio = ((float) xOffset) / (charsWidth
  							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
  					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
  				}
<span class="line-modified">! 				context.drawString(text, 2, y);</span>
  			} else {
  				List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
  				if (!subdivision.isEmpty()) {
  					for (IRenderedRow nestedRow : row.getNestedRows()) {
  						renderText(context, nestedRow);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,17 ***</span>
<span class="line-new-header">--- 363,29 ---</span>
  			}
  		}
  		context.translate(0, height);
  	}
  
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Get the longest character width of a thread name to be rendered</span>
<span class="line-added">+ 	 * </span>
<span class="line-added">+ 	 * @return the character width of longest thread name</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	public int getLongestCharWidth() {</span>
<span class="line-added">+ 		return longestCharWidth;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	/**
  	 * Pan the view.
  	 *
  	 * @param rightPercent
  	 * @return true if the bounds changed. That is, if a redraw is required.
  	 */
  	public boolean pan(int rightPercent) {
<span class="line-added">+ 		if (rangeDuration != null) {</span>
<span class="line-added">+ 			return panRange(Integer.signum(rightPercent));</span>
<span class="line-added">+ 		}</span>
  		if (xBucketRange != null) {
  			IQuantity oldStart = currentStart;
  			IQuantity oldEnd = currentEnd;
  			if (rightPercent &gt; 0) {
  				currentEnd = QuantitiesToolkit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,17 ***</span>
<span class="line-new-header">--- 402,56 ---</span>
  		}
  		// Return true since a redraw forces creation of xBucketRange.
  		return true;
  	}
  
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Pan the view at a rate relative the current zoom level.</span>
<span class="line-added">+ 	 * </span>
<span class="line-added">+ 	 * @param panDirection</span>
<span class="line-added">+ 	 *            -1 to pan left, 1 to pan right</span>
<span class="line-added">+ 	 * @return true if the chart needs to be redrawn</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	public boolean panRange(int panDirection) {</span>
<span class="line-added">+ 		if (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 &amp;&amp; panDirection == -1)</span>
<span class="line-added">+ 				|| (currentEnd.compareTo(end) == 0 &amp;&amp; panDirection == 1)) {</span>
<span class="line-added">+ 			return false;</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 		IQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);</span>
<span class="line-added">+ 		IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">+ 		IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">+ </span>
<span class="line-added">+ 		// if panning would flow over the recording range start or end time,</span>
<span class="line-added">+ 		// calculate the difference and add it so the other side.</span>
<span class="line-added">+ 		if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">+ 			IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">+ 			newStart = start;</span>
<span class="line-added">+ 			newEnd = newEnd.add(diff);</span>
<span class="line-added">+ 		} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">+ 			IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">+ 			newStart = newStart.add(diff);</span>
<span class="line-added">+ 			newEnd = end;</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		currentStart = newStart;</span>
<span class="line-added">+ 		currentEnd = newEnd;</span>
<span class="line-added">+ 		filterBar.setStartTime(currentStart);</span>
<span class="line-added">+ 		filterBar.setEndTime(currentEnd);</span>
<span class="line-added">+ 		isZoomCalculated = true;</span>
<span class="line-added">+ 		return true;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	/**
  	 * Zoom the view.
  	 *
  	 * @param zoomInSteps
  	 * @return true if the bounds changed. That is, if a redraw is required.
  	 */
  	public boolean zoom(int zoomInSteps) {
<span class="line-added">+ 		if (rangeDuration != null) {</span>
<span class="line-added">+ 			return zoomRange(zoomInSteps);</span>
<span class="line-added">+ 		}</span>
  		return zoomXAxis(axisWidth / 2, zoomInSteps);
  	}
  
  	/**
  	 * Zoom the view.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,10 ***</span>
<span class="line-new-header">--- 462,11 ---</span>
  	 */
  	public boolean zoom(int x, int zoomInSteps) {
  		return zoomXAxis(x - xOffset, zoomInSteps);
  	}
  
<span class="line-added">+ 	// Default zoom mechanics</span>
  	private boolean zoomXAxis(int x, int zoomInSteps) {
  		if (xBucketRange == null) {
  			// Return true since a redraw forces creation of xBucketRange.
  			return true;
  		}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,11 ***</span>
<span class="line-new-header">--- 482,193 ---</span>
  			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
  		}
  		return false;
  	}
  
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Zoom to a specific step count</span>
<span class="line-added">+ 	 * </span>
<span class="line-added">+ 	 * @param zoomToStep</span>
<span class="line-added">+ 	 *            the desired end zoom step amount</span>
<span class="line-added">+ 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	public boolean zoomToStep(int zoomToStep) {</span>
<span class="line-added">+ 		if (zoomToStep == 0) {</span>
<span class="line-added">+ 			resetTimeline();</span>
<span class="line-added">+ 			return true;</span>
<span class="line-added">+ 		} else {</span>
<span class="line-added">+ 			return zoomRange(zoomToStep - zoomSteps);</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Zoom based on a percentage of the recording range</span>
<span class="line-added">+ 	 * </span>
<span class="line-added">+ 	 * @param zoomInSteps</span>
<span class="line-added">+ 	 *            the amount of desired steps to take</span>
<span class="line-added">+ 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	private boolean zoomRange(int steps) {</span>
<span class="line-added">+ 		if (steps == 0) {</span>
<span class="line-added">+ 			return false;</span>
<span class="line-added">+ 		} else if (steps &gt; 0) {</span>
<span class="line-added">+ 			zoomIn(steps);</span>
<span class="line-added">+ 		} else {</span>
<span class="line-added">+ 			zoomOut(steps);</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		// set displayBar text</span>
<span class="line-added">+ 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">+ 		return true;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart</span>
<span class="line-added">+ 	 * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is</span>
<span class="line-added">+ 	 * halved and the zoom will proceed. &lt;br&gt;</span>
<span class="line-added">+ 	 * Every time the zoom power is halved, the instigating step value is pushed onto the</span>
<span class="line-added">+ 	 * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart</span>
<span class="line-added">+ 	 * zooms out the same way it was zoomed in.</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	private void zoomIn(int steps) {</span>
<span class="line-added">+ 		do {</span>
<span class="line-added">+ 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">+ 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">+ 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">+ 			if (newStart.compareTo(newEnd) &gt;= 0) { // adjust the zoom factor</span>
<span class="line-added">+ 				if (modifiedSteps == null) {</span>
<span class="line-added">+ 					modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">+ 				}</span>
<span class="line-added">+ 				modifiedSteps.push(zoomSteps);</span>
<span class="line-added">+ 				zoomPanPower = zoomPanPower / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 				zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">+ 				newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">+ 				newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 			currentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">+ 			isZoomCalculated = true;</span>
<span class="line-added">+ 			zoomSteps++;</span>
<span class="line-added">+ 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">+ 			steps--;</span>
<span class="line-added">+ 		} while (steps &gt; 0);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Zoom out of the chart at a rate equal to the how the chart was zoomed in.</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	private void zoomOut(int steps) {</span>
<span class="line-added">+ 		do {</span>
<span class="line-added">+ 			if (modifiedSteps != null &amp;&amp; modifiedSteps.size() &gt; 0 &amp;&amp; modifiedSteps.peek() == zoomSteps) {</span>
<span class="line-added">+ 				modifiedSteps.pop();</span>
<span class="line-added">+ 				zoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">+ 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">+ 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">+ </span>
<span class="line-added">+ 			// if zooming out would flow over the recording range start or end time,</span>
<span class="line-added">+ 			// calculate the difference and add it to the other side.</span>
<span class="line-added">+ 			if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">+ 				IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">+ 				newStart = start;</span>
<span class="line-added">+ 				newEnd = newEnd.add(diff);</span>
<span class="line-added">+ 			} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">+ 				IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">+ 				newStart = newStart.subtract(diff);</span>
<span class="line-added">+ 				newEnd = end;</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 			currentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">+ 			if (currentZoom &lt; BASE_ZOOM_LEVEL) {</span>
<span class="line-added">+ 				currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 			isZoomCalculated = true;</span>
<span class="line-added">+ 			zoomSteps--;</span>
<span class="line-added">+ 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">+ 			steps++;</span>
<span class="line-added">+ 		} while (steps &lt; 0);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	// need to check from ChartAndPopupTableUI if not using the OG start/end position,</span>
<span class="line-added">+ 	// will have to calculate the new zoom level</span>
<span class="line-added">+ 	public void resetZoomFactor() {</span>
<span class="line-added">+ 		zoomSteps = 0;</span>
<span class="line-added">+ 		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 		currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">+ 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">+ 		modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Reset the visible range to be the recording range, and reset the zoom-related objects</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	public void resetTimeline() {</span>
<span class="line-added">+ 		resetZoomFactor();</span>
<span class="line-added">+ 		setVisibleRange(start, end);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">+ 		double percentage = calculateZoom(newStart, newEnd);</span>
<span class="line-added">+ 		zoomSteps = calculateZoomSteps(percentage);</span>
<span class="line-added">+ 		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);</span>
<span class="line-added">+ 		displayBar.setScaleValue(zoomSteps);</span>
<span class="line-added">+ 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been</span>
<span class="line-added">+ 	 * taken, and adjust zoomSteps and zoomPower accordingly</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	private double calculateZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">+ 		// calculate the new visible range, and it&#39;s percentage of the total range</span>
<span class="line-added">+ 		IQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));</span>
<span class="line-added">+ 		return 1 - (newRange.longValue() / (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	/**</span>
<span class="line-added">+ 	 * Calculate the number of steps required to achieve the passed zoom percentage</span>
<span class="line-added">+ 	 */</span>
<span class="line-added">+ 	private int calculateZoomSteps(double percentage) {</span>
<span class="line-added">+ 		int steps = (int) Math.floor(percentage / ZOOM_PAN_FACTOR);</span>
<span class="line-added">+ 		double tempPercent = steps * ZOOM_PAN_FACTOR;</span>
<span class="line-added">+ </span>
<span class="line-added">+ 		if (tempPercent &lt; percentage) {</span>
<span class="line-added">+ 			if (percentage &gt; 1 - ZOOM_PAN_FACTOR) {</span>
<span class="line-added">+ 				double factor = ZOOM_PAN_FACTOR;</span>
<span class="line-added">+ 				do {</span>
<span class="line-added">+ 					factor = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 					tempPercent = tempPercent + factor;</span>
<span class="line-added">+ 					if (modifiedSteps == null) {</span>
<span class="line-added">+ 						modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">+ 					}</span>
<span class="line-added">+ 					if (modifiedSteps.size() == 0 || modifiedSteps.peek() &lt; steps) {</span>
<span class="line-added">+ 						modifiedSteps.push(steps);</span>
<span class="line-added">+ 					}</span>
<span class="line-added">+ 					steps++;</span>
<span class="line-added">+ 				} while (tempPercent &lt;= percentage);</span>
<span class="line-added">+ 				zoomPanPower = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">+ 			} else {</span>
<span class="line-added">+ 				steps++;</span>
<span class="line-added">+ 			}</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		return steps;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private boolean isZoomCalculated;</span>
<span class="line-added">+ 	private boolean isZoomPanDrag;</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	public void setIsZoomPanDrag(boolean isZoomPanDrag) {</span>
<span class="line-added">+ 		this.isZoomPanDrag = isZoomPanDrag;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
<span class="line-added">+ 	private boolean getIsZoomPanDrag() {</span>
<span class="line-added">+ 		return isZoomPanDrag;</span>
<span class="line-added">+ 	}</span>
<span class="line-added">+ </span>
  	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {
<span class="line-added">+ 		if (rangeDuration != null &amp;&amp; !isZoomCalculated &amp;&amp; !getIsZoomPanDrag()) {</span>
<span class="line-added">+ 			selectionZoom(rangeStart, rangeEnd);</span>
<span class="line-added">+ 		}</span>
<span class="line-added">+ 		isZoomCalculated = false;</span>
  		rangeStart = QuantitiesToolkit.max(rangeStart, start);
  		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
  		if (rangeStart.compareTo(rangeEnd) &lt; 0) {
  			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
  			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,10 ***</span>
<span class="line-new-header">--- 677,14 ---</span>
  			} else {
  				// Ensures that zoom out is always allowed
  				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
  				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
  			}
<span class="line-added">+ 			if (filterBar != null) {</span>
<span class="line-added">+ 				filterBar.setStartTime(currentStart);</span>
<span class="line-added">+ 				filterBar.setEndTime(currentEnd);</span>
<span class="line-added">+ 			}</span>
  			rangeListeners.stream().forEach(l -&gt; l.accept(getVisibleRange()));
  		}
  	}
  
  	private List&lt;Consumer&lt;IRange&lt;IQuantity&gt;&gt;&gt; rangeListeners = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,34 ***</span>
  	public void clearVisibleRange() {
  		currentStart = start;
  		currentEnd = end;
  	}
  
<span class="line-modified">! 	public boolean select(int x1, int x2, int y1, int y2) {</span>
<span class="line-modified">! 		int xStart = Math.min(x1, x2) - xOffset;</span>
<span class="line-modified">! 		int xEnd = Math.max(x1, x2) - xOffset;</span>
  
<span class="line-modified">! 		if (xBucketRange != null &amp;&amp; (xEnd &gt;= 0)) {</span>
<span class="line-modified">! 			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart)), xBucketRange.getQuantityAtPixel(xEnd),</span>
<span class="line-modified">! 					y1, y2);</span>
  		} else {
<span class="line-modified">! 			return select(null, null, y1, y2);</span>
  		}
  	}
  
<span class="line-modified">! 	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2) {</span>
  		if (xStart != null &amp;&amp; xStart.compareTo(start) &lt; 0) {
  			xStart = start;
  		}
  		if (xEnd != null &amp;&amp; xEnd.compareTo(end) &gt; 0) {
  			xEnd = end;
  		}
  		Set&lt;Object&gt; oldRows = null;
  		if (QuantitiesToolkit.same(selectionStart, xStart) &amp;&amp; QuantitiesToolkit.same(selectionEnd, xEnd)) {
  			oldRows = new HashSet&lt;&gt;(selectedRows);
  		}
<span class="line-modified">! 		selectedRows.clear();</span>
  		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
  		selectionStart = xStart;
  		selectionEnd = xEnd;
  		return (oldRows == null) || !oldRows.equals(selectedRows);
  	}
<span class="line-new-header">--- 701,36 ---</span>
  	public void clearVisibleRange() {
  		currentStart = start;
  		currentEnd = end;
  	}
  
<span class="line-modified">! 	public boolean select(int x1, int x2, int y1, int y2, boolean clear) {</span>
<span class="line-modified">! 		int xStart = Math.min(x1, x2);</span>
<span class="line-modified">! 		int xEnd = Math.max(x1, x2);</span>
  
<span class="line-modified">! 		if (xBucketRange != null &amp;&amp; (xEnd != xStart) &amp;&amp; xEnd - xOffset &gt;= 0) {</span>
<span class="line-modified">! 			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),</span>
<span class="line-modified">! 					xBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);</span>
  		} else {
<span class="line-modified">! 			return select(null, null, y1, y2, clear);</span>
  		}
  	}
  
<span class="line-modified">! 	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {</span>
  		if (xStart != null &amp;&amp; xStart.compareTo(start) &lt; 0) {
  			xStart = start;
  		}
  		if (xEnd != null &amp;&amp; xEnd.compareTo(end) &gt; 0) {
  			xEnd = end;
  		}
  		Set&lt;Object&gt; oldRows = null;
  		if (QuantitiesToolkit.same(selectionStart, xStart) &amp;&amp; QuantitiesToolkit.same(selectionEnd, xEnd)) {
  			oldRows = new HashSet&lt;&gt;(selectedRows);
  		}
<span class="line-modified">! 		if (clear) {</span>
<span class="line-added">+ 			selectedRows.clear();</span>
<span class="line-added">+ 		}</span>
  		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
  		selectionStart = xStart;
  		selectionEnd = xEnd;
  		return (oldRows == null) || !oldRows.equals(selectedRows);
  	}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,11 ***</span>
  	}
  
  	private boolean addPayload(IRenderedRow row) {
  		Object payload = row.getPayload();
  		if (payload != null) {
<span class="line-modified">! 			selectedRows.add(payload);</span>
  			return true;
  		}
  		return false;
  	}
  
<span class="line-new-header">--- 764,15 ---</span>
  	}
  
  	private boolean addPayload(IRenderedRow row) {
  		Object payload = row.getPayload();
  		if (payload != null) {
<span class="line-modified">! 			if (selectedRows.contains(payload)) { // ctrl+click deselection</span>
<span class="line-added">+ 				selectedRows.remove(payload);</span>
<span class="line-added">+ 			} else {</span>
<span class="line-added">+ 				selectedRows.add(payload);</span>
<span class="line-added">+ 			}</span>
  			return true;
  		}
  		return false;
  	}
  
</pre>
<center><a href="AWTChartToolkit.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../misc/ChartCanvas.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>