diff a/application/org.openjdk.jmc.feature.joverflow.ext.treemap/.project b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/.project
--- /dev/null
+++ b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/.project
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.openjdk.jmc.feature.joverflow.ext.treemap</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.pde.FeatureBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
+		<nature>org.eclipse.pde.FeatureNature</nature>
+	</natures>
+</projectDescription>
diff a/application/org.openjdk.jmc.feature.joverflow.ext.treemap/build.properties b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/build.properties
--- /dev/null
+++ b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/build.properties
@@ -0,0 +1,34 @@
+#
+#  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2020, Red Hat Inc. All rights reserved.
+#
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  The contents of this file are subject to the terms of either the Universal Permissive License 
+#  v 1.0 as shown at http://oss.oracle.com/licenses/upl
+#   
+#  or the following license:
+#   
+#  Redistribution and use in source and binary forms, with or without modification, are permitted
+#  provided that the following conditions are met:
+#   
+#  1. Redistributions of source code must retain the above copyright notice, this list of conditions
+#  and the following disclaimer.
+#   
+#  2. Redistributions in binary form must reproduce the above copyright notice, this list of
+#  conditions and the following disclaimer in the documentation and/or other materials provided with
+#  the distribution.
+#   
+#  3. Neither the name of the copyright holder nor the names of its contributors may be used to
+#  endorse or promote products derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+bin.includes = feature.xml
diff a/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.properties b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.properties
--- /dev/null
+++ b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.properties
@@ -0,0 +1,38 @@
+#
+#  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2020, Red Hat Inc. All rights reserved.
+#
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  The contents of this file are subject to the terms of either the Universal Permissive License 
+#  v 1.0 as shown at http://oss.oracle.com/licenses/upl
+#   
+#  or the following license:
+#   
+#  Redistribution and use in source and binary forms, with or without modification, are permitted
+#  provided that the following conditions are met:
+#   
+#  1. Redistributions of source code must retain the above copyright notice, this list of conditions
+#  and the following disclaimer.
+#   
+#  2. Redistributions in binary form must reproduce the above copyright notice, this list of
+#  conditions and the following disclaimer in the documentation and/or other materials provided with
+#  the distribution.
+#   
+#  3. Neither the name of the copyright holder nor the names of its contributors may be used to
+#  endorse or promote products derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+name=JOverflow Treemap View
+provider=Oracle Corporation
+copyright=Copyright \u00A9 2020, Oracle and/or its affiliates. All rights reserved.
+description=This feature adds a treemap view to JOverflow visualizing memory usage by packages/classes.
+descriptionUrl=http://www.oracle.com/missioncontrol
diff a/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.xml b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.xml
--- /dev/null
+++ b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/feature.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--   
+   Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2020, Red Hat Inc. All rights reserved.
+   
+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   
+   The contents of this file are subject to the terms of either the Universal Permissive License 
+   v 1.0 as shown at http://oss.oracle.com/licenses/upl
+   
+   or the following license:
+   
+   Redistribution and use in source and binary forms, with or without modification, are permitted
+   provided that the following conditions are met:
+   
+   1. Redistributions of source code must retain the above copyright notice, this list of conditions
+   and the following disclaimer.
+   
+   2. Redistributions in binary form must reproduce the above copyright notice, this list of
+   conditions and the following disclaimer in the documentation and/or other materials provided with
+   the distribution.
+   
+   3. Neither the name of the copyright holder nor the names of its contributors may be used to
+   endorse or promote products derived from this software without specific prior written permission.
+   
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<feature
+      id="org.openjdk.jmc.feature.joverflow.ext.treemap"
+      label="%name"
+      version="1.0.0.qualifier"
+      provider-name="%provider"
+      license-feature="org.openjdk.jmc.feature.license"
+      license-feature-version="8.0.0.qualifier">
+
+   <description url="%descriptionUrl">
+      %description
+   </description>
+
+   <copyright>
+      %copyright
+   </copyright>
+
+   <requires>
+      <import plugin="org.openjdk.jmc.common" match="equivalent"/>
+      <import plugin="org.eclipse.ui"/>
+   </requires>
+
+	<plugin
+         id="org.openjdk.jmc.joverflow.ext.treemap"
+         download-size="0"
+         install-size="0"
+         version="0.0.0"
+         unpack="false"/>
+
+</feature>
diff a/application/org.openjdk.jmc.feature.joverflow.ext.treemap/pom.xml b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/pom.xml
--- /dev/null
+++ b/application/org.openjdk.jmc.feature.joverflow.ext.treemap/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--   
+   Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2020, Red Hat Inc. All rights reserved.
+   
+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   
+   The contents of this file are subject to the terms of either the Universal Permissive License 
+   v 1.0 as shown at http://oss.oracle.com/licenses/upl
+   
+   or the following license:
+   
+   Redistribution and use in source and binary forms, with or without modification, are permitted
+   provided that the following conditions are met:
+   
+   1. Redistributions of source code must retain the above copyright notice, this list of conditions
+   and the following disclaimer.
+   
+   2. Redistributions in binary form must reproduce the above copyright notice, this list of
+   conditions and the following disclaimer in the documentation and/or other materials provided with
+   the distribution.
+   
+   3. Neither the name of the copyright holder nor the names of its contributors may be used to
+   endorse or promote products derived from this software without specific prior written permission.
+   
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.openjdk.jmc</groupId>
+		<artifactId>missioncontrol.application</artifactId>
+		<version>8.0.0-SNAPSHOT</version>
+	</parent>
+	<artifactId>org.openjdk.jmc.feature.joverflow.ext.treemap</artifactId>
+	<version>1.0.0-SNAPSHOT</version>
+	<packaging>eclipse-feature</packaging>
+
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
+</project>
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/.classpath b/application/org.openjdk.jmc.joverflow.ext.treemap/.classpath
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src/main/java"/>
+	<classpathentry kind="src" path="src/main/resources"/>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/.project b/application/org.openjdk.jmc.joverflow.ext.treemap/.project
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.openjdk.jmc.joverflow.ext.treemap</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/META-INF/MANIFEST.MF b/application/org.openjdk.jmc.joverflow.ext.treemap/META-INF/MANIFEST.MF
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/META-INF/MANIFEST.MF
@@ -0,0 +1,14 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
+Bundle-Name: Joverflow Treemap View
+Bundle-SymbolicName: org.openjdk.jmc.joverflow.ext.treemap;singleton:=true
+Bundle-Version: 1.0.0.qualifier
+Bundle-Vendor: Oracle Corporation
+Require-Bundle: org.openjdk.jmc.ui,
+ org.openjdk.jmc.joverflow,
+ org.openjdk.jmc.joverflow.ui
+Eclipse-BuddyPolicy: app
+Bundle-ActivationPolicy: lazy
+Automatic-Module-Name: org.openjdk.jmc.joverflow.ext.treemap
+Import-Package: org.openjdk.jmc.flightrecorder.ui
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/build.properties b/application/org.openjdk.jmc.joverflow.ext.treemap/build.properties
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/build.properties
@@ -0,0 +1,39 @@
+#
+#  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2020, Red Hat Inc. All rights reserved.
+#
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  The contents of this file are subject to the terms of either the Universal Permissive License 
+#  v 1.0 as shown at http://oss.oracle.com/licenses/upl
+#   
+#  or the following license:
+#   
+#  Redistribution and use in source and binary forms, with or without modification, are permitted
+#  provided that the following conditions are met:
+#   
+#  1. Redistributions of source code must retain the above copyright notice, this list of conditions
+#  and the following disclaimer.
+#   
+#  2. Redistributions in binary form must reproduce the above copyright notice, this list of
+#  conditions and the following disclaimer in the documentation and/or other materials provided with
+#  the distribution.
+#   
+#  3. Neither the name of the copyright holder nor the names of its contributors may be used to
+#  endorse or promote products derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+source.. = src/main/java/
+output.. = target/classes/
+bin.includes = META-INF/,\
+               .,\
+               icons/,\
+               plugin.xml
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap.png b/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap.png
Binary files /dev/null and application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap.png differ
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@2x.png b/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@2x.png
Binary files /dev/null and application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@2x.png differ
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@original.png b/application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@original.png
Binary files /dev/null and application/org.openjdk.jmc.joverflow.ext.treemap/icons/treemap@original.png differ
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/plugin.xml b/application/org.openjdk.jmc.joverflow.ext.treemap/plugin.xml
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/plugin.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--   
+   Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2020, Red Hat Inc. All rights reserved.
+   
+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   
+   The contents of this file are subject to the terms of either the Universal Permissive License 
+   v 1.0 as shown at http://oss.oracle.com/licenses/upl
+   
+   or the following license:
+   
+   Redistribution and use in source and binary forms, with or without modification, are permitted
+   provided that the following conditions are met:
+   
+   1. Redistributions of source code must retain the above copyright notice, this list of conditions
+   and the following disclaimer.
+   
+   2. Redistributions in binary form must reproduce the above copyright notice, this list of
+   conditions and the following disclaimer in the documentation and/or other materials provided with
+   the distribution.
+   
+   3. Neither the name of the copyright holder nor the names of its contributors may be used to
+   endorse or promote products derived from this software without specific prior written permission.
+   
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<?eclipse version="3.4"?>
+<plugin>
+
+ 	<extension point="org.eclipse.ui.views">
+		<category name="JOverflow" id="JOverflow"/>
+		<view
+            allowMultiple="false"
+            category="JOverflow"
+            class="org.openjdk.jmc.joverflow.ext.treemap.TreemapPageBookView"
+            id="org.openjdk.jmc.joverflow.ext.treemap.TreemapPageBookView"
+            icon="icons/treemap.png"
+            name="JOverflow Treemap"
+            restorable="true">
+		</view>
+	</extension>
+</plugin>
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/pom.xml b/application/org.openjdk.jmc.joverflow.ext.treemap/pom.xml
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--   
+   Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2020, Red Hat Inc. All rights reserved.
+   
+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+   
+   The contents of this file are subject to the terms of either the Universal Permissive License 
+   v 1.0 as shown at http://oss.oracle.com/licenses/upl
+   
+   or the following license:
+   
+   Redistribution and use in source and binary forms, with or without modification, are permitted
+   provided that the following conditions are met:
+   
+   1. Redistributions of source code must retain the above copyright notice, this list of conditions
+   and the following disclaimer.
+   
+   2. Redistributions in binary form must reproduce the above copyright notice, this list of
+   conditions and the following disclaimer in the documentation and/or other materials provided with
+   the distribution.
+   
+   3. Neither the name of the copyright holder nor the names of its contributors may be used to
+   endorse or promote products derived from this software without specific prior written permission.
+   
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.openjdk.jmc</groupId>
+		<artifactId>missioncontrol.application</artifactId>
+		<version>8.0.0-SNAPSHOT</version>
+	</parent>
+	<artifactId>org.openjdk.jmc.joverflow.ext.treemap</artifactId>
+	<version>1.0.0-SNAPSHOT</version>
+	<packaging>eclipse-plugin</packaging>
+
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
+</project>
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/Messages.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/Messages.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/Messages.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap;
+
+import org.eclipse.osgi.util.NLS;
+
+public class Messages extends NLS {
+	private static final String BUNDLE_NAME = "org.openjdk.jmc.joverflow.ext.treemap.messages"; //$NON-NLS-1$
+
+	public static String TreemapAction_ZOOM_IN_DESCRIPTION;
+	public static String TreemapAction_ZOOM_OUT_DESCRIPTION;
+	public static String TreemapAction_ZOOM_OFF_DESCRIPTION;
+	public static String TreemapPageBookView_NO_JOVERFLOW_EDITOR_SELECTED;
+	public static String TreemapPage_NO_INSTANCES_SELECTED;
+
+	static {
+		// initialize resource bundle
+		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
+	}
+
+	private Messages() {
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapAction.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapAction.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapAction.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.openjdk.jmc.ui.CoreImages;
+
+/* package-private */ class TreemapAction extends Action {
+	private final TreemapActionType actionType;
+	private Runnable runnable = () -> {
+	};
+
+	TreemapAction(TreemapActionType actionType) {
+		super(actionType.message, actionType.action);
+		this.actionType = actionType;
+		setToolTipText(actionType.message);
+		setImageDescriptor(actionType.imageDescriptor);
+	}
+
+	@Override
+	public void run() {
+		runnable.run();
+	}
+
+	public void setRunnable(Runnable callback) {
+		runnable = callback;
+	}
+
+	public TreemapActionType getType() {
+		return actionType;
+	}
+
+	enum TreemapActionType {
+		ZOOM_IN(Messages.TreemapAction_ZOOM_IN_DESCRIPTION, IAction.AS_PUSH_BUTTON, CoreImages.ZOOM_IN), // 
+		ZOOM_OUT(Messages.TreemapAction_ZOOM_OUT_DESCRIPTION, IAction.AS_PUSH_BUTTON, CoreImages.ZOOM_OUT), // 
+		ZOOM_OFF(Messages.TreemapAction_ZOOM_OFF_DESCRIPTION, IAction.AS_PUSH_BUTTON, CoreImages.ZOOM_OFF);
+
+		private final String message;
+		private final int action;
+		private final ImageDescriptor imageDescriptor;
+
+		TreemapActionType(String message, int action, ImageDescriptor imageDescriptor) {
+			this.message = message;
+			this.action = action;
+			this.imageDescriptor = imageDescriptor;
+		}
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPage.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPage.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPage.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.FormAttachment;
+import org.eclipse.swt.layout.FormData;
+import org.eclipse.swt.layout.FormLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.ui.part.Page;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.Breadcrumb;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.BreadcrumbItem;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.Treemap;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.TreemapItem;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.events.TreemapListener;
+import org.openjdk.jmc.joverflow.heap.model.JavaClass;
+import org.openjdk.jmc.joverflow.heap.model.JavaHeapObject;
+import org.openjdk.jmc.joverflow.support.RefChainElement;
+import org.openjdk.jmc.joverflow.ui.JOverflowEditor;
+import org.openjdk.jmc.joverflow.ui.model.ModelListener;
+import org.openjdk.jmc.joverflow.ui.model.ObjectCluster;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+/* package-private */ class TreemapPage extends Page implements ModelListener {
+	private static final Color[] COLORS = {new Color(Display.getCurrent(), 250, 206, 210), // red
+			new Color(Display.getCurrent(), 185, 214, 255), // blue
+			new Color(Display.getCurrent(), 229, 229, 229), // grey
+			new Color(Display.getCurrent(), 255, 231, 199), // orange
+			new Color(Display.getCurrent(), 171, 235, 238), // aqua
+			new Color(Display.getCurrent(), 228, 209, 252), // purple
+			new Color(Display.getCurrent(), 255, 255, 255), // white
+			new Color(Display.getCurrent(), 205, 249, 212), // green
+	};
+	private static final String LABEL_ROOT = "[ROOT]"; //$NON-NLS-1$
+
+	private final JOverflowEditor editor;
+	private final TreemapAction[] treemapActions;
+
+	private Composite container;
+	private StackLayout containerLayout;
+	private Composite messageContainer;
+	private Composite treemapContainer;
+
+	private Label message;
+	private Treemap treemap;
+	private Breadcrumb breadcrumb;
+
+	private HashMap<String, Double> classes = new HashMap<>();
+
+	TreemapPage(JOverflowEditor editor, TreemapAction[] treemapActions) {
+		this.editor = Objects.requireNonNull(editor);
+		this.treemapActions = Objects.requireNonNull(treemapActions);
+	}
+
+	@Override
+	public void createControl(Composite parent) {
+		container = new Composite(parent, SWT.PUSH);
+		containerLayout = new StackLayout();
+		container.setLayout(containerLayout);
+
+		messageContainer = new Composite(container, SWT.NONE);
+		FillLayout layout = new FillLayout();
+		layout.marginHeight = 5;
+		layout.marginWidth = 5;
+		messageContainer.setLayout(layout);
+
+		message = new Label(messageContainer, SWT.NONE);
+		message.setText(Messages.TreemapPage_NO_INSTANCES_SELECTED);
+
+		treemapContainer = new Composite(container, SWT.NONE);
+		treemapContainer.setLayout(new FormLayout());
+
+		breadcrumb = new Breadcrumb(treemapContainer, SWT.NONE);
+		{
+			FormData bcLayoutData = new FormData();
+			bcLayoutData.top = new FormAttachment(0, 0);
+			bcLayoutData.left = new FormAttachment(0, 0);
+			bcLayoutData.right = new FormAttachment(100, 0);
+			breadcrumb.setLayoutData(bcLayoutData);
+		}
+
+		treemap = new Treemap(treemapContainer, SWT.NONE);
+		{
+			FormData tmLayoutData = new FormData();
+			tmLayoutData.bottom = new FormAttachment(100);
+			tmLayoutData.top = new FormAttachment(breadcrumb);
+			tmLayoutData.left = new FormAttachment(0);
+			tmLayoutData.right = new FormAttachment(100, 0);
+			treemap.setLayoutData(tmLayoutData);
+		}
+		treemap.setText(LABEL_ROOT);
+
+		// set "[ROOT]" item
+		{
+			TreemapItem rootItem = treemap.getRootItem();
+			BreadcrumbItem breadcrumbItem = new BreadcrumbItem(breadcrumb, SWT.NONE);
+			breadcrumbItem.setData(rootItem);
+			breadcrumbItem.setText(rootItem.getText());
+		}
+
+		// links treemap and breadcrumb events
+		{
+			breadcrumb.addSelectionListener(SelectionListener.widgetSelectedAdapter(selectionEvent -> {
+				if (!(selectionEvent.data instanceof TreemapItem)) {
+					return;
+				}
+
+				TreemapItem item = (TreemapItem) selectionEvent.data;
+				treemap.setTopItem(item);
+			}));
+
+			treemap.addTreemapListener(TreemapListener.treemapTopChangedAdapter(treemapEvent -> {
+				TreemapItem item = (TreemapItem) treemapEvent.item;
+				breadcrumb.removeAll();
+
+				List<TreemapItem> path = new ArrayList<>();
+				do {
+					path.add(item);
+					item = item.getParentItem();
+				} while (item != null);
+
+				Collections.reverse(path);
+				for (TreemapItem i : path) {
+					BreadcrumbItem breadcrumbItem = new BreadcrumbItem(breadcrumb, SWT.NONE);
+					breadcrumbItem.setData(i);
+					breadcrumbItem.setText(i.getText());
+				}
+			}));
+		}
+
+		// rebind action buttons
+		{
+			treemap.addSelectionListener(
+					SelectionListener.widgetSelectedAdapter(selectionEvent -> bindTreemapActions()));
+			treemap.addTreemapListener(TreemapListener.treemapTopChangedAdapter(treemapEvent -> bindTreemapActions()));
+		}
+
+		containerLayout.topControl = messageContainer;
+		updateInput();
+	}
+
+	@Override
+	public Control getControl() {
+		return container;
+	}
+
+	@Override
+	public void setFocus() {
+		getControl().setFocus();
+	}
+
+	@Override
+	public void include(ObjectCluster cluster, RefChainElement referenceChain) {
+		if (cluster.getObjectCount() == 0) {
+			return;
+		}
+
+		JavaClass clazz = getObjectAtPosition(cluster.getGlobalObjectIndex(0)).getClazz();
+		String className = clazz.getName();
+		if (className.charAt(0) == '[') {
+			className = cluster.getClassName();
+		}
+
+		classes.putIfAbsent(className, 0.0);
+		double size = classes.get(className);
+		size += cluster.getMemory();
+		classes.put(className, size);
+	}
+
+	@Override
+	public void allIncluded() {
+		updateInput();
+		classes.clear();
+
+		bindTreemapActions();
+	}
+
+	public void bindTreemapActions() {
+		if (containerLayout.topControl != treemapContainer) {
+			Stream.of(treemapActions).forEach((action) -> action.setEnabled(false));
+			return;
+		}
+
+		TreemapItem selected = treemap.getSelection();
+		TreemapItem root = treemap.getRootItem();
+		TreemapItem top = treemap.getTopItem();
+
+		Stream.of(treemapActions).forEach((action) -> {
+			switch (action.getType()) {
+			case ZOOM_IN:
+				action.setEnabled(selected != null && selected != top
+						&& !(selected.getItemCount() == 0 && selected.getParentItem() == top));
+				action.setRunnable(() -> treemap.setTopItem(selected));
+				break;
+			case ZOOM_OUT:
+				action.setEnabled(top.getParentItem() != null);
+				action.setRunnable(() -> treemap.setTopItem(top.getParentItem()));
+				break;
+			case ZOOM_OFF:
+				action.setEnabled(top != root);
+				action.setRunnable(() -> treemap.setTopItem(root));
+			}
+		});
+	}
+
+	private void updateInput() {
+		if (classes.size() == 0) {
+			containerLayout.topControl = messageContainer;
+			container.layout();
+			return;
+		}
+
+		if (treemap == null) {
+			return;
+		}
+
+		treemap.removeAll();
+		HashMap<String, TreemapItem> items = new HashMap<>();
+		for (Map.Entry<String, Double> entry : classes.entrySet()) {
+			addTreemapItem(treemap, items, entry.getKey(), entry.getValue());
+		}
+
+		TreemapItem rootItem = treemap.getRootItem();
+		rootItem.setToolTipText(LABEL_ROOT);
+		setColorAndToolTip(rootItem, 0);
+		treemap.setTopItem(rootItem);
+		treemap.setSelection(null);
+
+		containerLayout.topControl = treemapContainer;
+		container.layout();
+	}
+
+	private void addTreemapItem(Treemap parent, Map<String, TreemapItem> items, String fullName, double size) {
+		if (items.containsKey(fullName) && size != 0) {
+			TreemapItem item = items.get(fullName);
+			double bytes = item.getWeight() + size;
+			item.setWeight(bytes);
+			item.setToolTipText(fullName);
+			return;
+		}
+
+		if (fullName.indexOf('.') == -1) {
+			TreemapItem item = new TreemapItem(parent, SWT.NONE);
+			item.setText(fullName);
+			if (size != 0) {
+				item.setWeight(size);
+			}
+			item.setToolTipText(fullName);
+			items.put(fullName, item);
+			return;
+		}
+
+		String parentName = fullName.substring(0, fullName.lastIndexOf('.'));
+		if (!items.containsKey(parentName)) {
+			addTreemapItem(parent, items, parentName, 0);
+		}
+
+		TreemapItem parentItem = items.get(parentName);
+		TreemapItem item = new TreemapItem(parentItem, SWT.NONE);
+		item.setText(fullName.substring(parentName.length() + 1));
+		item.setToolTipText(fullName);
+		if (size != 0) {
+			item.setWeight(size);
+		}
+		items.put(fullName, item);
+	}
+
+	private void setColorAndToolTip(TreemapItem item, int depth) {
+		item.setToolTipText(item.getToolTipText() + "\n" + getHumanReadableSize(item.getWeight())); //$NON-NLS-1$
+		item.setBackground(COLORS[depth % COLORS.length]);
+
+		for (TreemapItem child : item.getItems()) {
+			setColorAndToolTip(child, depth + 1);
+		}
+	}
+
+	private String getHumanReadableSize(double bytes) {
+		String unit = "B"; //$NON-NLS-1$
+		double quantity = bytes;
+		if (quantity > 1024) {
+			quantity /= 1024;
+			unit = "KiB"; //$NON-NLS-1$
+		}
+		if (quantity > 1024) {
+			quantity /= 1024;
+			unit = "MiB"; //$NON-NLS-1$
+		}
+		if (quantity > 1024) {
+			quantity /= 1024;
+			unit = "GiB"; //$NON-NLS-1$
+		}
+		if (quantity > 1024) {
+			quantity /= 1024;
+			unit = "TiB"; //$NON-NLS-1$
+		}
+
+		return String.format("%.2f %s", quantity, unit); //$NON-NLS-1$
+	}
+
+	private JavaHeapObject getObjectAtPosition(int globalObjectPos) {
+		return editor.getSnapshot().getObjectAtGlobalIndex(globalObjectPos);
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPageBookView.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPageBookView.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/TreemapPageBookView.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap;
+
+import org.eclipse.jface.action.IToolBarManager;
+import org.eclipse.ui.IViewSite;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.part.IPage;
+import org.eclipse.ui.part.MessagePage;
+import org.eclipse.ui.part.PageBook;
+import org.eclipse.ui.part.PageBookView;
+import org.openjdk.jmc.joverflow.ui.JOverflowEditor;
+import org.openjdk.jmc.joverflow.ui.JOverflowUi;
+
+import java.util.stream.Stream;
+
+public class TreemapPageBookView extends PageBookView {
+
+	private TreemapAction[] treemapActions;
+
+	@Override
+	protected IPage createDefaultPage(PageBook book) {
+		MessagePage page = new MessagePage();
+		initPage(page);
+		page.createControl(book);
+		page.setMessage(Messages.TreemapPageBookView_NO_JOVERFLOW_EDITOR_SELECTED);
+		return page;
+	}
+
+	@Override
+	protected PageRec doCreatePage(IWorkbenchPart part) {
+		if (!(part instanceof JOverflowEditor)) {
+			return null;
+		}
+
+		final JOverflowEditor editor = ((JOverflowEditor) part);
+		TreemapPage page = new TreemapPage(editor, treemapActions);
+
+		editor.addUiLoadedListener((ui) -> ui.addModelListener(page));
+
+		initPage(page);
+		page.createControl(getPageBook());
+		return new PageRec(part, page);
+	}
+
+	@Override
+	protected void doDestroyPage(IWorkbenchPart part, PageRec pageRecord) {
+		if (part instanceof JOverflowEditor) {
+			final JOverflowUi ui = ((JOverflowEditor) part).getJOverflowUi();
+			if (ui != null) {
+				ui.removeModelListener((TreemapPage) pageRecord.page);
+			}
+		}
+
+		pageRecord.page.dispose();
+		pageRecord.dispose();
+
+	}
+
+	@Override
+	protected IWorkbenchPart getBootstrapPart() {
+		IWorkbenchPage page = getSite().getPage();
+		if (page != null) {
+			return page.getActiveEditor();
+		}
+		return null;
+	}
+
+	@Override
+	protected boolean isImportant(IWorkbenchPart part) {
+		// We only care about JOverflowEditor
+		return (part instanceof JOverflowEditor);
+	}
+
+	@Override
+	public void init(IViewSite site) throws PartInitException {
+		super.init(site);
+
+		treemapActions = new TreemapAction[] {new TreemapAction(TreemapAction.TreemapActionType.ZOOM_IN), //
+				new TreemapAction(TreemapAction.TreemapActionType.ZOOM_OUT), //
+				new TreemapAction(TreemapAction.TreemapActionType.ZOOM_OFF), //
+		};
+		Stream.of(treemapActions).forEach((action) -> action.setEnabled(false));
+
+		IToolBarManager toolBar = site.getActionBars().getToolBarManager();
+		Stream.of(treemapActions).forEach(toolBar::add);
+	}
+
+	@Override
+	protected void showPageRec(PageRec pageRec) {
+		super.showPageRec(pageRec);
+
+		if (pageRec.page instanceof TreemapPage) {
+			((TreemapPage) pageRec.page).bindTreemapActions();
+		} else {
+			Stream.of(treemapActions).forEach((action) -> action.setEnabled(false));
+		}
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Breadcrumb.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Breadcrumb.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Breadcrumb.java
@@ -0,0 +1,430 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.TypedListener;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
+
+/**
+ * Instances of this class represent a selectable user interface object that displays the currently
+ * location within programs, documents, or websites. The items of this receiver are kept in a stack
+ * structure.
+ * 
+ * @see BreadcrumbItem
+ */
+public class Breadcrumb extends Canvas {
+	private static final int TRIM = 2;
+
+	private Stack<BreadcrumbItem> items = new Stack<>();
+
+	private Map<SelectionListener, TypedListener> selectionListeners = new HashMap<>();
+
+	// the following members need to be disposed
+	private Cursor cursor;
+
+	/**
+	 * Constructs a new instance of this class given its parent and a style value describing its
+	 * behavior and appearance.
+	 * 
+	 * @param parent
+	 *            a composite control which will be the parent of the new instance (cannot be null)
+	 * @param style
+	 *            the style of control to construct
+	 */
+	public Breadcrumb(Composite parent, int style) {
+		super(checkNull(parent), style);
+
+		addPaintListener(this::onPaintControl);
+		addMouseListener(new MouseListener() {
+			@Override
+			public void mouseDoubleClick(MouseEvent mouseEvent) {
+				// noop
+			}
+
+			@Override
+			public void mouseDown(MouseEvent mouseEvent) {
+				onMouseDown(mouseEvent);
+			}
+
+			@Override
+			public void mouseUp(MouseEvent mouseEvent) {
+				// noop
+			}
+		});
+		addMouseMoveListener(this::onMouseMove);
+	}
+
+	/* package-private */
+	static Composite checkNull(Composite control) {
+		if (control == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		return control;
+	}
+
+	/* package-private */ void createItem(BreadcrumbItem item) {
+		items.push(item);
+
+		redraw();
+	}
+
+	private void onPaintControl(PaintEvent paintEvent) {
+		Rectangle bounds = getClientArea();
+
+		GC gc = paintEvent.gc;
+		// clear background
+		Color bg = gc.getBackground();
+		gc.setBackground(getBackground());
+		gc.fillRectangle(bounds);
+
+		int dx = 0;
+		for (BreadcrumbItem item : items) {
+			item.paintItem(paintEvent.gc, new Rectangle(bounds.x + dx, bounds.y, bounds.width - dx, bounds.height));
+			dx += item.getBounds().width;
+		}
+
+		gc.setBackground(bg);
+	}
+
+	private void onMouseDown(MouseEvent mouseEvent) {
+		if (mouseEvent.button != 1) { // we care only about left button
+			return;
+		}
+
+		BreadcrumbItem item = getItem(new Point(mouseEvent.x, mouseEvent.y));
+		if (item == null) {
+			return;
+		}
+
+		setSelection(item);
+	}
+
+	private void onMouseMove(MouseEvent mouseEvent) {
+		BreadcrumbItem item = getItem(new Point(mouseEvent.x, mouseEvent.y));
+
+		if (cursor != null && !cursor.isDisposed()) {
+			cursor.dispose();
+		}
+
+		cursor = item == null ? new Cursor(Display.getCurrent(), SWT.CURSOR_ARROW)
+				: new Cursor(Display.getCurrent(), SWT.CURSOR_HAND);
+		setCursor(cursor);
+	}
+
+	private Event createEventForItem(int type, BreadcrumbItem item) {
+		Event e = new Event();
+		e.display = getDisplay();
+		e.widget = this;
+		e.type = type;
+		e.item = item;
+		e.index = indexOf(item);
+
+		if (item != null) {
+			e.data = item.getData();
+		}
+
+		if (item != null && item.getBounds() != null) {
+			Rectangle bounds = item.getBounds();
+			e.x = bounds.x;
+			e.y = bounds.y;
+			e.width = bounds.width;
+			e.height = bounds.height;
+		}
+
+		return e;
+	}
+
+	@Override
+	public Point computeSize(int wHint, int hHint, boolean changed) {
+		int width = 0;
+		int height = 0;
+
+		GC gc = new GC(this);
+		for (BreadcrumbItem item : items) {
+			Point dimension = item.getDimension(gc);
+
+			width += dimension.x;
+			height = Math.max(height, dimension.y);
+		}
+		return new Point(Math.max(width, wHint) + 2 * TRIM, Math.max(height, hHint) + 2 * TRIM);
+	}
+
+	@Override
+	public Rectangle computeTrim(int x, int y, int width, int height) {
+		return new Rectangle(x - TRIM, y - TRIM, width + 2 * TRIM, height + 2 * TRIM);
+	}
+
+	/**
+	 * Adds the listener to the collection of listeners who will be notified when the user changes
+	 * the receiver's selection, by sending it one of the messages defined in the SelectionListener
+	 * interface.
+	 * 
+	 * @param listener
+	 *            the listener which should be notified when the user changes the receiver's
+	 *            selection
+	 */
+	public void addSelectionListener(SelectionListener listener) {
+		checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		selectionListeners.putIfAbsent(listener, new TypedListener(listener));
+		TypedListener typedListener = selectionListeners.get(listener);
+
+		addListener(SWT.Selection, typedListener);
+		addListener(SWT.DefaultSelection, typedListener);
+	}
+
+	/**
+	 * Removes the listener from the collection of listeners who will be notified when the user
+	 * changes the receiver's selection.
+	 * 
+	 * @param listener
+	 *            the listener which should no longer be notified
+	 */
+	public void removeSelectionListener(SelectionListener listener) {
+		checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		TypedListener typedListener = selectionListeners.remove(listener);
+		if (typedListener == null) {
+			return;
+		}
+
+		removeListener(SWT.Selection, typedListener);
+		removeListener(SWT.DefaultSelection, typedListener);
+	}
+
+	@Override
+	public Rectangle getClientArea() {
+		Rectangle bounds = super.getClientArea();
+		bounds.x += TRIM;
+		bounds.y += TRIM;
+		bounds.width -= 2 * TRIM;
+		bounds.height -= 2 * TRIM;
+
+		return bounds;
+	}
+
+	/**
+	 * Removes the last item from the receiver.
+	 */
+	public void popItem() {
+		checkWidget();
+
+		items.pop();
+
+		redraw();
+	}
+
+	/**
+	 * Return the last item from the receiver
+	 * 
+	 * @return the last item from the receiver
+	 */
+	public BreadcrumbItem peekItem() {
+		checkWidget();
+
+		return items.peek();
+	}
+
+	/**
+	 * Returns the item at the given, zero-relative index in the receiver. Throws an exception if
+	 * the index is out of range.
+	 * 
+	 * @param index
+	 *            the index of the item to return
+	 * @return the item at the given index
+	 */
+	public BreadcrumbItem getItem(int index) {
+		checkWidget();
+
+		return items.get(index);
+	}
+
+	/**
+	 * Returns the item at the given point in the receiver or null if no such item exists. The point
+	 * is in the coordinate system of the receiver. The item that is returned represents an item
+	 * that could be selected by the user.
+	 * 
+	 * @param point
+	 *            the point used to locate the item
+	 * @return the item at the given point, or null if the point is not in a selectable item
+	 */
+	public BreadcrumbItem getItem(Point point) {
+		checkWidget();
+
+		for (BreadcrumbItem item : items) {
+			if (item.getBounds() != null && item.getBounds().contains(point)) {
+				return item;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * Returns the number of items contained in the receiver that are direct item children of the
+	 * receiver.
+	 *
+	 * @return the number of items
+	 */
+	public int getItemCount() {
+		checkWidget();
+
+		return items.size();
+	}
+
+	/**
+	 * Returns a (possibly empty) array of items contained in the receiver that are direct item
+	 * children of the receiver. Note: This is not the actual structure used by the receiver to
+	 * maintain its list of items, so modifying the array will not affect the receiver.
+	 * 
+	 * @return the items
+	 */
+	public BreadcrumbItem[] getItems() {
+		checkWidget();
+
+		return items.toArray(new BreadcrumbItem[0]);
+	}
+
+	/**
+	 * An alias to #peekItem(). For breadcrumbs the selected item is always the last item.
+	 *
+	 * @return the item currently selected
+	 */
+	public BreadcrumbItem getSelection() {
+		checkWidget();
+
+		return peekItem();
+	}
+
+	/**
+	 * Selects the item at the given zero-relative index in the receiver. If the item at the index
+	 * was already selected, it remains selected. The current selection is first cleared, then the
+	 * new item is selected. Indices that are out of range are ignored.
+	 *
+	 * @param index
+	 *            the index of the item to select
+	 */
+	public void setSelection(int index) {
+		checkWidget();
+
+		removeFrom(index);
+
+		Event e = createEventForItem(SWT.Selection, peekItem());
+		notifyListeners(SWT.Selection, e);
+
+		redraw();
+	}
+
+	/**
+	 * Sets the receiver's selection to the given item. The current selection is cleared before the
+	 * new item is selected. If the item is not in the receiver, then it is ignored.
+	 *
+	 * @param item
+	 *            the item to select
+	 */
+	public void setSelection(BreadcrumbItem item) {
+		checkWidget();
+
+		if (item != null && item.getParent() != this) {
+			return; // not in the receiver
+		}
+
+		setSelection(items.indexOf(item));
+	}
+
+	/**
+	 * Searches the receiver's list starting at the first item (index 0) until an item is found that
+	 * is equal to the argument, and returns the index of that item. If no item is found, returns
+	 * -1.
+	 * 
+	 * @param item
+	 *            the search item
+	 * @return the index of the item
+	 */
+	public int indexOf(BreadcrumbItem item) {
+		checkWidget();
+
+		return items.indexOf(item);
+	}
+
+	/**
+	 * Removes all items from the receiver with index equal or larger than this number. Indices that
+	 * are out of range are ignored.
+	 * 
+	 * @param start
+	 *            index of first element to be removed
+	 */
+	public void removeFrom(int start) {
+		checkWidget();
+
+		while (items.size() > start + 1) {
+			items.pop();
+		}
+	}
+
+	/**
+	 * Removes all of the items from the receiver.
+	 */
+	public void removeAll() {
+		checkWidget();
+
+		items.clear();
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/BreadcrumbItem.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/BreadcrumbItem.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/BreadcrumbItem.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Item;
+
+/**
+ * Instances of this class represent a selectable user interface object that represents an entry in
+ * a breadcrumb widget.
+ */
+public class BreadcrumbItem extends Item {
+	private static final int PADDING = 4;
+	private static final int ARROW_WIDTH = 4;
+
+	private Breadcrumb parent;
+
+	private Color background = null;
+	private Color foreground = null;
+	private Font font = null;
+
+	private Rectangle bounds = null;
+	private Rectangle textBounds = null;
+
+	// to be disposed
+	private Color darkenBackground = null;
+	private Color lighterForeground = null;
+
+	/**
+	 * Constructs a new instance of this class and inserts it into the parent breadcrumb. The item
+	 * is inserted as the last item maintained by its parent.
+	 * 
+	 * @param parent
+	 *            a breadcrumb control which will be the parent of the new instance (cannot be null)
+	 * @param style
+	 *            the style of control to construct
+	 */
+	public BreadcrumbItem(Breadcrumb parent, int style) {
+		super(Breadcrumb.checkNull(parent), style);
+
+		this.parent = parent;
+		parent.createItem(this);
+	}
+
+	/* package-private */ void paintItem(GC gc, Rectangle bounds) {
+		Color bg = gc.getBackground();
+		Color fg = gc.getForeground();
+		Font font = gc.getFont();
+
+		gc.setFont(getFont());
+
+		textBounds = new Rectangle(bounds.x + PADDING + ARROW_WIDTH, bounds.y + PADDING, bounds.width, bounds.height);
+		Point textExtent = gc.textExtent(getText());
+		textBounds.width = textExtent.x;
+		textBounds.height = textExtent.y;
+
+		bounds = new Rectangle(bounds.x, bounds.y, textBounds.width + 2 * PADDING + 2 * ARROW_WIDTH,
+				textBounds.height + 2 * PADDING);
+		this.bounds = bounds;
+
+		gc.setForeground(getBackground());
+		gc.setBackground(getDarkenBackground());
+		gc.fillGradientRectangle(bounds.x, bounds.y, bounds.width, bounds.height, true);
+
+		gc.setBackground(getBackground());
+		gc.setForeground(getForeground());
+		int[] polygon = new int[] {bounds.x, bounds.y, //
+				bounds.x + ARROW_WIDTH, bounds.y + bounds.height / 2, //
+				bounds.x, bounds.y + bounds.height, //
+		};
+		gc.fillPolygon(polygon);
+
+		polygon = new int[] {bounds.x + bounds.width - ARROW_WIDTH, bounds.y, //
+				bounds.x + bounds.width, bounds.y, //
+				bounds.x + bounds.width, bounds.y + bounds.height, //
+				bounds.x + bounds.width - ARROW_WIDTH, bounds.y + bounds.height, //
+				bounds.x + bounds.width, bounds.y + bounds.height / 2, //
+		};
+		gc.fillPolygon(polygon);
+
+		gc.setForeground(getLighterForeground());
+		polygon = new int[] {bounds.x, bounds.y, //
+				bounds.x + bounds.width - ARROW_WIDTH, bounds.y, //
+				bounds.x + bounds.width, bounds.y + bounds.height / 2, //
+				bounds.x + bounds.width - ARROW_WIDTH, bounds.y + bounds.height, //
+				bounds.x, bounds.y + bounds.height, //
+				bounds.x + ARROW_WIDTH, bounds.y + bounds.height / 2,};
+		gc.drawPolygon(polygon);
+
+		gc.setForeground(getForeground());
+		gc.drawText(getText(), textBounds.x, textBounds.y, true);
+
+		gc.setBackground(bg);
+		gc.setForeground(fg);
+		gc.setFont(font);
+	}
+
+	/* package-private */ Point getDimension(GC gc) {
+		Font font = gc.getFont();
+		gc.setFont(getFont());
+
+		Point extend = gc.textExtent(getText());
+		extend.x += 2 * PADDING + 2 * ARROW_WIDTH;
+		extend.y += 2 * PADDING;
+
+		gc.setFont(font);
+		return extend;
+	}
+
+	public void clear() {
+		this.foreground = null;
+		this.background = null;
+		this.font = null;
+
+		this.setData(null);
+		this.setText(""); //$NON-NLS-1$
+	}
+
+	@Override
+	public void dispose() {
+		if (darkenBackground != null && !darkenBackground.isDisposed()) {
+			darkenBackground.dispose();
+		}
+
+		if (lighterForeground != null && !lighterForeground.isDisposed()) {
+			lighterForeground.dispose();
+		}
+
+		super.dispose();
+	}
+
+	/**
+	 * Returns the receiver's background color.
+	 *
+	 * @return the background color
+	 */
+	public Color getBackground() {
+		checkWidget();
+
+		if (background != null) {
+			return background;
+		}
+
+		return parent.getBackground();
+	}
+
+	private Color getDarkenBackground() {
+		if (darkenBackground == null || darkenBackground.isDisposed()) {
+			Color bg = getBackground();
+			int r = (int) (bg.getRed() * 0.9);
+			int g = (int) (bg.getGreen() * 0.9);
+			int b = (int) (bg.getBlue() * 0.9);
+
+			darkenBackground = new Color(Display.getCurrent(), r, g, b);
+		}
+		return darkenBackground;
+	}
+
+	/**
+	 * Sets the receiver's background color to the color specified by the argument, or to the
+	 * default system color for the item if the argument is null.
+	 *
+	 * @param color
+	 *            the new color (or null)
+	 */
+	public void setBackground(Color color) {
+		checkWidget();
+
+		background = color;
+
+		if (darkenBackground != null && !darkenBackground.isDisposed()) {
+			darkenBackground.dispose();
+		}
+		darkenBackground = null;
+	}
+
+	/**
+	 * Returns a rectangle describing the size and location of the receiver relative to its parent.
+	 *
+	 * @return the bounding rectangle of the receiver's text
+	 */
+	public Rectangle getBounds() {
+		checkWidget();
+
+		return bounds;
+	}
+
+	/**
+	 * Returns the font that the receiver will use to paint textual information for this item.
+	 *
+	 * @return the receiver's font
+	 */
+	public Font getFont() {
+		checkWidget();
+
+		if (font != null) {
+			return font;
+		}
+
+		return parent.getFont();
+	}
+
+	/**
+	 * Sets the font that the receiver will use to paint textual information for this item to the
+	 * font specified by the argument, or to the default font for that kind of control if the
+	 * argument is null.
+	 *
+	 * @param font
+	 *            the new font (or null)
+	 */
+	public void setFont(Font font) {
+		checkWidget();
+
+		this.font = font;
+	}
+
+	/**
+	 * Returns the foreground color that the receiver will use to draw.
+	 *
+	 * @return the receiver's foreground color
+	 */
+	public Color getForeground() {
+		checkWidget();
+
+		if (foreground != null) {
+			return foreground;
+		}
+
+		return parent.getForeground();
+	}
+
+	private Color getLighterForeground() {
+		if (lighterForeground == null || lighterForeground.isDisposed()) {
+			Color bg = getForeground();
+			int r = Math.min(bg.getRed() * 2, 255);
+			int g = Math.min(bg.getGreen() * 2, 255);
+			int b = Math.min(bg.getBlue() * 2, 255);
+
+			lighterForeground = new Color(Display.getCurrent(), r, g, b);
+		}
+		return lighterForeground;
+	}
+
+	/**
+	 * Sets the foreground color at the given column index in the receiver to the color specified by
+	 * the argument, or to the default system color for the item if the argument is null.
+	 *
+	 * @param color
+	 *            the new color (or null)
+	 */
+	public void setForeground(Color color) {
+		checkWidget();
+
+		this.foreground = color;
+
+		if (lighterForeground != null && !lighterForeground.isDisposed()) {
+			lighterForeground.dispose();
+		}
+		lighterForeground = null;
+	}
+
+	/**
+	 * Returns the receiver's parent, which must be a Breadcrumb.
+	 *
+	 * @return the receiver's parent
+	 */
+	public Breadcrumb getParent() {
+		checkWidget();
+
+		return parent;
+	}
+
+	/**
+	 * Returns a rectangle describing the size and location relative to its parent of the text.
+	 *
+	 * @return the receiver's bounding text rectangle
+	 */
+	public Rectangle getTextBounds() {
+		checkWidget();
+
+		return textBounds;
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/SquarifiedTreemap.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/SquarifiedTreemap.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/SquarifiedTreemap.java
@@ -0,0 +1,438 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * This class implements the Squarified algorithm for Treemaps. Using it, it is possible to
+ * associate a rectangle to a {@link TreemapItem} element and its children.
+ * <p>
+ * 
+ * @see TreemapItem
+ */
+/* package-private */ class SquarifiedTreemap {
+
+	/*
+	 * The algorithm this implements is described in detail here:
+	 *
+	 * https://bitbucket.org/Ammirate/thermostat-treemap/src/tip/Treemap%20documentation.pdf
+	 *
+	 * Which is an improvement on:
+	 *
+	 * Mark Bruls, Kees Huizing and Jarke J. van Wijk, "Squarified Treemaps" in Data Visualization
+	 * 2000: Proceedings of the Joint EUROGRAPHICS and IEEE TCVG Symposium on Visualization in
+	 * Amsterdam, The Netherlands, May 2930, 2000. Berlin, Germany: Springer Science & Business
+	 * Media, 2012
+	 *
+	 * The paper itself is also available online at: https://www.win.tue.nl/~vanwijk/stm.pdf
+	 */
+
+	/**
+	 * List of node to represent as TreeMap.
+	 */
+	private LinkedList<TreemapItem> elements;
+
+	private double totalRealWeight;
+
+	/**
+	 * Represent the area in which draw nodes.
+	 */
+	private Rectangle2D.Double container;
+
+	private enum DIRECTION {
+		LEFT_RIGHT, TOP_BOTTOM
+	}
+
+	/**
+	 * Indicates the drawing direction.
+	 */
+	private DIRECTION drawingDir;
+
+	/**
+	 * The rectangles area available for drawing.
+	 */
+	private Rectangle2D.Double availableRegion;
+
+	private double initialArea;
+
+	/**
+	 * Maps nodes to their representative rectangles, for all nodes in rows that have been
+	 * finalized.
+	 */
+	private Map<TreemapItem, Rectangle2D.Double> squarifiedMap;
+
+	/**
+	 * Coordinates on which to draw.
+	 */
+	private double lastX = 0;
+	private double lastY = 0;
+
+	/**
+	 * Performs setup to facilitate the generation of squarified rectangles to represent the nodes
+	 * in {@param elements}.
+	 *
+	 * @param region
+	 *            the region that is available for placing rectangles.
+	 * @param elements
+	 *            the list of nodes to represent, which must be sorted in descending order by weight
+	 */
+	public SquarifiedTreemap(Rectangle2D.Double region, List<TreemapItem> elements) {
+		this.elements = new LinkedList<>();
+		this.elements.addAll(Objects.requireNonNull(elements));
+		this.totalRealWeight = getRealSum(elements);
+		this.container = Objects.requireNonNull(region);
+		this.squarifiedMap = new HashMap<>();
+	}
+
+	/**
+	 * This method prepares for and initiates the process of determining rectangles to represent
+	 * nodes.
+	 *
+	 * @return a map that associates each node with the rectangle that represents it.
+	 */
+	public Map<TreemapItem, Rectangle2D.Double> squarify() {
+		if (elements.isEmpty()) {
+			return Collections.emptyMap();
+		}
+
+		initialArea = container.getWidth() * container.getHeight();
+		availableRegion = new Rectangle2D.Double(container.getX(), container.getY(), container.getWidth(),
+				container.getHeight());
+		lastX = 0;
+		lastY = 0;
+		updateDirection();
+
+		List<TreemapItem> row = new ArrayList<>();
+		squarifyHelper(elements, row, 0, getPrincipalSide());
+		return squarifiedMap;
+	}
+
+	/**
+	 * Recursively determine the rectangles that represent the set of nodes.
+	 *
+	 * @param nodes
+	 *            remaining nodes to be processed.
+	 * @param row
+	 *            the nodes that have been included in the row currently under construction.
+	 * @param rowArea
+	 *            the total area allocated to this row.
+	 * @param side
+	 *            the length of the side against which to calculate the the aspect ratio.
+	 */
+	private void squarifyHelper(LinkedList<TreemapItem> nodes, List<TreemapItem> row, double rowArea, double side) {
+
+		if (nodes.isEmpty() && row.isEmpty()) {
+			// nothing to do here, just return
+			return;
+		}
+		if (nodes.isEmpty()) {
+			// no more nodes to process, just finalize current row
+			finalizeRow(row, rowArea);
+			return;
+		}
+		if (row.isEmpty()) {
+			// add the first element to the row and process any remaining nodes recursively
+			row.add(nodes.getFirst());
+			double realWeight = nodes.getFirst().getWeight();
+			nodes.removeFirst();
+			double nodeArea = (realWeight / totalRealWeight) * initialArea;
+			squarifyHelper(nodes, row, nodeArea, side);
+			return;
+		}
+
+		/*
+		 * Determine if adding another rectangle to the current row improves the overall aspect
+		 * ratio. If the current row is not (and therefore cannot be) improved then it is finalized,
+		 * and the algorithm is run recursively on the remaining nodes that have not yet been placed
+		 * in a row.
+		 */
+		List<TreemapItem> expandedRow = new ArrayList<>(row);
+		expandedRow.add(nodes.getFirst());
+		double realWeight = nodes.getFirst().getWeight();
+		double nodeArea = (realWeight / totalRealWeight) * initialArea;
+		double expandedRowArea = rowArea + nodeArea;
+
+		double actualAspectRatio = maxAspectRatio(row, rowArea, side);
+		double expandedAspectRatio = maxAspectRatio(expandedRow, expandedRowArea, side);
+
+		if (!willImprove(actualAspectRatio, expandedAspectRatio)) {
+			finalizeRow(row, rowArea);
+			squarifyHelper(nodes, new ArrayList<>(), 0, getPrincipalSide());
+		} else {
+			nodes.removeFirst();
+			squarifyHelper(nodes, expandedRow, expandedRowArea, side);
+		}
+	}
+
+	public Map<TreemapItem, Rectangle2D.Double> getSquarifiedMap() {
+		return squarifiedMap;
+	}
+
+	/**
+	 * Recalculate the drawing direction.
+	 */
+	private void updateDirection() {
+		drawingDir = availableRegion.getWidth() > availableRegion.getHeight() ? DIRECTION.TOP_BOTTOM
+				: DIRECTION.LEFT_RIGHT;
+	}
+
+	/**
+	 * Invert the drawing direction.
+	 */
+	private void invertDirection() {
+		drawingDir = drawingDir == DIRECTION.LEFT_RIGHT ? DIRECTION.TOP_BOTTOM : DIRECTION.LEFT_RIGHT;
+	}
+
+	/**
+	 * For each node in the row, this method creates a rectangle to represent it graphically.
+	 *
+	 * @param row
+	 *            the set of nodes that constitute a row.
+	 * @param rowArea
+	 *            the area allocated to the row.
+	 */
+	private void finalizeRow(List<TreemapItem> row, double rowArea) {
+		if (row == null || row.isEmpty()) {
+			return;
+		}
+
+		// greedy optimization step: get the best aspect ratio for nodes drawn
+		// on the longer and on the smaller side, to evaluate the best.
+		double actualAR = maxAspectRatio(row, rowArea, getPrincipalSide());
+		double alternativeAR = maxAspectRatio(row, rowArea, getSecondarySide());
+
+		if (willImprove(actualAR, alternativeAR)) {
+			invertDirection();
+		}
+
+		Rectangle2D.Double reference = null;
+		for (TreemapItem node : row) {
+			Rectangle2D.Double r = createRectangle(rowArea, node.getWeight() / getRealSum(row));
+
+			// recalculate coordinates to draw next rectangle
+			updateXY(r);
+
+			squarifiedMap.put(node, r);
+
+			if (reference == null) {
+				reference = r;
+			}
+		}
+		reduceAvailableArea(reference);
+	}
+
+	/**
+	 * Create a rectangle that has a size determined by what fraction of the total row area is
+	 * allocated to it.
+	 *
+	 * @param rowArea
+	 *            the total area allocated to the row.
+	 * @param fraction
+	 *            the portion of the total area allocated to the rectangle being created.
+	 * @return the created rectangle.
+	 */
+	private Rectangle2D.Double createRectangle(Double rowArea, Double fraction) {
+		double side = getPrincipalSide();
+		double w;
+		double h;
+
+		if (validate(fraction) == 0 || validate(rowArea) == 0 || validate(side) == 0) {
+			return new Rectangle2D.Double(lastX, lastY, 0, 0);
+		}
+
+		if (drawingDir == DIRECTION.TOP_BOTTOM) {
+			// the length of the secondary side (width here) of the rectangle is consistent between
+			// rectangles in the row
+			w = rowArea / side;
+
+			// as the width is consistent, the length of the principal side (height here) of the
+			// rectangle is proportional to the ratio rectangleArea / rowArea = fraction.
+			h = fraction * side;
+		} else {
+			w = fraction * side;
+			h = rowArea / side;
+		}
+		return new Rectangle2D.Double(lastX, lastY, w, h);
+	}
+
+	/**
+	 * Ensure that a value is within an expected numeric range
+	 *
+	 * @param d
+	 *            the value to check.
+	 * @return 0 if the input is NaN, else the number
+	 */
+	double validate(double d) {
+		if (Double.isNaN(d)) {
+			return 0;
+		}
+		return d;
+	}
+
+	/**
+	 * Check in which direction the rectangles have to be drawn.
+	 *
+	 * @return the side on which rectangles will be created.
+	 */
+	private double getPrincipalSide() {
+		return drawingDir == DIRECTION.LEFT_RIGHT ? availableRegion.getWidth() : availableRegion.getHeight();
+	}
+
+	/**
+	 * @return the secondary available area's side.
+	 */
+	private double getSecondarySide() {
+		return drawingDir == DIRECTION.LEFT_RIGHT ? availableRegion.getHeight() : availableRegion.getWidth();
+	}
+
+	private double getRealSum(List<TreemapItem> nodes) {
+		double sum = 0;
+		for (TreemapItem node : nodes) {
+			sum += node.getWeight();
+		}
+		return sum;
+	}
+
+	/**
+	 * Recalculate the origin to draw next rectangles.
+	 *
+	 * @param r
+	 *            the rectangle from which recalculate the origin.
+	 */
+	private void updateXY(Rectangle2D.Double r) {
+		if (drawingDir == DIRECTION.LEFT_RIGHT) {
+			//lastY doesn't change
+			lastX += r.width;
+		} else {
+			//lastX doesn't change
+			lastY += r.height;
+		}
+	}
+
+	/**
+	 * Initialize the origin at the rectangle's origin.
+	 *
+	 * @param r
+	 *            the rectangle used as origin source.
+	 */
+	private void initializeXY(Rectangle2D.Double r) {
+		lastX = r.x;
+		lastY = r.y;
+	}
+
+	/**
+	 * Determine the region that will be available upon finalization of this row.
+	 */
+	private void reduceAvailableArea(Rectangle2D.Double reference) {
+		if (drawingDir == DIRECTION.LEFT_RIGHT) {
+			// all rectangles inside the row have the same height
+			availableRegion.height -= reference.height;
+			availableRegion.y = lastY + reference.height;
+			availableRegion.x = reference.x;
+		} else {
+			// all rectangles inside the row have the same width
+			availableRegion.width -= reference.width;
+			availableRegion.x = lastX + reference.width;
+			availableRegion.y = reference.y;
+		}
+		updateDirection();
+		initializeXY(availableRegion);
+	}
+
+	/**
+	 * For each node in the row, determine the ratio longer side / shorter side of the rectangle
+	 * that would represent it. Return the maximum ratio.
+	 *
+	 * @param row
+	 *            the list of nodes in this row.
+	 * @param rowArea
+	 *            the area allocated to this row.
+	 * @param side
+	 *            the length of the side against which to calculate the the aspect ratio.
+	 * @return the maximum ratio calculated for this row.
+	 */
+	private double maxAspectRatio(List<TreemapItem> row, double rowArea, double side) {
+		if (row == null || row.isEmpty()) {
+			return Double.MAX_VALUE;
+		}
+
+		double realSum = getRealSum(row);
+		double maxRatio = 0;
+
+		for (TreemapItem node : row) {
+			double fraction = node.getWeight() / realSum;
+			double length = rowArea / side;
+			double width = fraction * side;
+			double currentRatio = Math.max(length / width, width / length);
+
+			if (currentRatio > maxRatio) {
+				maxRatio = currentRatio;
+			}
+		}
+
+		return maxRatio;
+	}
+
+	/**
+	 * This method check which from the values in input, that represent rectangles' aspect ratio,
+	 * produces more approximatively a square. It checks if one of the aspect ratio values gives a
+	 * value nearest to 1 against the other, which means that width and height are similar.
+	 *
+	 * @param actualAR
+	 *            the actual aspect ratio
+	 * @param expandedAR
+	 *            the aspect ratio to evaluate
+	 * @return false if the actual aspect ratio is better than the new one, else true.
+	 */
+	private boolean willImprove(double actualAR, double expandedAR) {
+		if (actualAR == 0) {
+			return true;
+		}
+		if (expandedAR == 0) {
+			return false;
+		}
+		// check which value is closer to 1, the square's aspect ratio
+		double v1 = Math.abs(actualAR - 1);
+		double v2 = Math.abs(expandedAR - 1);
+		return v1 > v2;
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Treemap.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Treemap.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/Treemap.java
@@ -0,0 +1,734 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.TypedListener;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.events.TreemapEvent;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.events.TreemapListener;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Instances of this class represent a selectable user interface object that displays hierarchical
+ * data using nested figures. A treemap node's size is in proportion to its size. This widget
+ * implements the squarified treemap algorithm.
+ */
+public class Treemap extends Canvas {
+	private static final int TRIM = 2;
+
+	private TreemapItem rootItem = new TreemapItem(this, SWT.NONE);
+
+	private Map<SelectionListener, TypedListener> selectionListeners = new HashMap<>();
+	private Set<TreemapListener> treemapListeners = new HashSet<>();
+
+	private TreemapItem topItem = rootItem;
+	private TreemapItem selectedItem = null;
+
+	private boolean borderVisible = true;
+	private boolean toolTipEnabled = true;
+
+	// the following members need to be disposed
+	private Cursor cursor;
+	private TreemapToolTip toolTip = new TreemapToolTip(this);
+
+	/**
+	 * Constructs a new instance of this class given its parent and a style value describing its
+	 * behavior and appearance.
+	 *
+	 * @param parent
+	 *            a composite control which will be the parent of the new instance (cannot be null)
+	 * @param style
+	 *            the style of control to construct
+	 */
+	public Treemap(Composite parent, int style) {
+		super(checkNull(parent), style);
+
+		if ((style & SWT.VIRTUAL) == SWT.VIRTUAL) {
+			throw new UnsupportedOperationException("SWT.VIRTUAL is not support by Treemap"); //$NON-NLS-1$
+		}
+
+		addPaintListener(this::onPaintControl);
+		addMouseListener(new MouseListener() {
+			@Override
+			public void mouseDoubleClick(MouseEvent mouseEvent) {
+				onMouseDoubleClick(mouseEvent);
+			}
+
+			@Override
+			public void mouseDown(MouseEvent mouseEvent) {
+				onMouseDown(mouseEvent);
+			}
+
+			@Override
+			public void mouseUp(MouseEvent mouseEvent) {
+				// noop
+			}
+		});
+		addMouseMoveListener(this::onMouseMove);
+	}
+
+	/* package-private */
+	static Composite checkNull(Composite control) {
+		if (control == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		return control;
+	}
+
+	/* package-private */
+	static Treemap checkNull(Treemap treemap) {
+		if (treemap == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		return treemap;
+	}
+
+	private void onPaintControl(PaintEvent paintEvent) {
+		getTopItem().paintItem(paintEvent.gc, getClientArea(), true);
+	}
+
+	private void onMouseDoubleClick(MouseEvent mouseEvent) {
+		if (mouseEvent.button != 1) { // we care only about left button
+			return;
+		}
+
+		TreemapItem item = getItem(new Point(mouseEvent.x, mouseEvent.y));
+		if (item == null) {
+			return;
+		}
+
+		setTopItem(item);
+	}
+
+	private void onMouseDown(MouseEvent mouseEvent) {
+		// left button: select (highlight) a node
+		if (mouseEvent.button == 1) {
+			TreemapItem item = getItem(new Point(mouseEvent.x, mouseEvent.y));
+			if (item == null) {
+				return;
+			}
+
+			setSelection(item);
+			return;
+		}
+
+		// middle button: show the root node as top
+		if (mouseEvent.button == 2) {
+			setTopItem(getRootItem());
+			return;
+		}
+
+		// right button: show the parent node as top
+		if (mouseEvent.button == 3) {
+			TreemapItem parentItem = getTopItem().getParentItem();
+			if (parentItem == null) {
+				return;
+			}
+			setTopItem(parentItem);
+			return;
+		}
+	}
+
+	private void onMouseMove(MouseEvent mouseEvent) {
+		TreemapItem item = getItem(new Point(mouseEvent.x, mouseEvent.y));
+		if (item == null) {
+			return;
+		}
+
+		if (cursor != null && !cursor.isDisposed()) {
+			cursor.dispose();
+		}
+
+		cursor = item.getItemCount() == 0 ? new Cursor(Display.getCurrent(), SWT.CURSOR_ARROW)
+				: new Cursor(Display.getCurrent(), SWT.CURSOR_CROSS);
+		setCursor(cursor);
+
+		if (toolTipEnabled) {
+			toolTip.setItem(item);
+		}
+	}
+
+	private Event createEventForItem(int type, TreemapItem item) {
+		Event e = new Event();
+		e.display = getDisplay();
+		e.widget = this;
+		e.type = type;
+		e.item = item;
+		e.index = indexOf(item);
+
+		if (item != null) {
+			e.data = item.getData();
+		}
+
+		if (item != null && item.getBounds() != null) {
+			Rectangle bounds = item.getBounds();
+			e.x = bounds.x;
+			e.y = bounds.y;
+			e.width = bounds.width;
+			e.height = bounds.height;
+		}
+
+		return e;
+	}
+
+	@Override
+	public Rectangle getClientArea() {
+		Rectangle bounds = super.getClientArea();
+		bounds.x += TRIM;
+		bounds.y += TRIM;
+		bounds.width -= 2 * TRIM;
+		bounds.height -= 2 * TRIM;
+
+		return bounds;
+	}
+
+	@Override
+	public Rectangle computeTrim(int x, int y, int width, int height) {
+		return new Rectangle(x - TRIM, y - TRIM, width + 2 * TRIM, height + 2 * TRIM);
+	}
+
+	/**
+	 * Adds the listener to the collection of listeners who will be notified when the user changes
+	 * the receiver's selection, by sending it one of the messages defined in the SelectionListener
+	 * interface.
+	 *
+	 * @param listener
+	 *            the listener which should be notified when the user changes the receiver's
+	 *            selection
+	 */
+	public void addSelectionListener(SelectionListener listener) {
+		this.checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		selectionListeners.putIfAbsent(listener, new TypedListener(listener));
+		TypedListener typedListener = selectionListeners.get(listener);
+
+		addListener(SWT.Selection, typedListener);
+		addListener(SWT.DefaultSelection, typedListener);
+	}
+
+	/**
+	 * Removes the listener from the collection of listeners who will be notified when the user
+	 * changes the receiver's selection.
+	 *
+	 * @param listener
+	 *            the listener which should no longer be notified
+	 */
+	public void removeSelectionListener(SelectionListener listener) {
+		this.checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		TypedListener typedListener = selectionListeners.remove(listener);
+		if (typedListener == null) {
+			return;
+		}
+
+		removeListener(SWT.Selection, typedListener);
+		removeListener(SWT.DefaultSelection, typedListener);
+	}
+
+	/**
+	 * Adds the listener to the collection of listeners who will be notified when an item in the
+	 * receiver becomes the new top by sending it one of the messages defined in the interface.
+	 *
+	 * @param listener
+	 *            the listener which should be notified
+	 */
+	public void addTreemapListener(TreemapListener listener) {
+		this.checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		treemapListeners.add(listener);
+	}
+
+	/**
+	 * Removes the listener from the collection of listeners who will be notified when items in the
+	 * receiver becomes the new top
+	 *
+	 * @param listener
+	 *            the listener which should no longer be notified
+	 */
+	public void removeTreemapListener(TreemapListener listener) {
+		this.checkWidget();
+
+		if (listener == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		treemapListeners.remove(listener);
+	}
+
+	/**
+	 * Clears the item at the given zero-relative index, sorted in descending order by weight, in
+	 * the receiver. The text, icon and other attributes of the item are set to the default value
+	 *
+	 * @param index
+	 *            the index of the item to clear
+	 * @param all
+	 *            true if all child items of the indexed item should be cleared recursively, and
+	 *            false otherwise
+	 */
+	public void clear(int index, boolean all) {
+		checkWidget();
+
+		rootItem.clear(index, all);
+	}
+
+	/**
+	 * Clears all the items in the receiver. The text, icon and other attributes of the items are
+	 * set to their default values.
+	 *
+	 * @param all
+	 *            true if all child items should be cleared recursively, and false otherwise
+	 */
+	public void clearAll(boolean all) {
+		checkWidget();
+
+		rootItem.clearAll(all);
+	}
+
+	@Override
+	public void dispose() {
+		if (cursor != null && !cursor.isDisposed()) {
+			cursor.dispose();
+		}
+
+		super.dispose();
+	}
+
+	/**
+	 * Deselects an item in the receiver. If the item was already deselected, it remains deselected.
+	 * Indices that are out of range are ignored.
+	 *
+	 * @param index
+	 *            the index of the item to deselect
+	 */
+	public void deselect(int index) {
+		checkWidget();
+
+		try {
+			getItem(index);
+			deselect();
+		} catch (IndexOutOfBoundsException e) {
+			// noop
+		}
+	}
+
+	/**
+	 * Deselects the item in the receive that is currently selected. It is ignore if there is no
+	 * selection.
+	 */
+	public void deselect() {
+		checkWidget();
+
+		if (getSelection() != null) {
+			setSelection(null);
+		}
+	}
+
+	/**
+	 * Selects an item in the receiver. If the item was already selected, it remains selected.
+	 * Indices that are out of range are ignored.
+	 *
+	 * @param index
+	 *            the index of the item to select
+	 */
+	public void select(int index) {
+		checkWidget();
+
+		try {
+			setSelection(getItem(index));
+		} catch (IndexOutOfBoundsException e) {
+			// noop
+		}
+	}
+
+	/**
+	 * Returns the item at the given, zero-relative index, sorted in descending order by weight, in
+	 * the receiver. Throws an exception if the index is out of range.
+	 *
+	 * @param index
+	 *            the index of the item to return
+	 * @return the item at the given index
+	 */
+	public TreemapItem getItem(int index) {
+		checkWidget();
+
+		return rootItem.getItem(index);
+	}
+
+	/**
+	 * Returns the item at the given point in the receiver or null if no such item exists. The point
+	 * is in the coordinate system of the receiver. The item that is returned represents an item
+	 * that could be selected by the user.
+	 *
+	 * @param point
+	 *            the point used to locate the item
+	 * @return the item at the given point, or null if the point is not in a selectable item
+	 */
+	public TreemapItem getItem(Point point) {
+		checkWidget();
+
+		return topItem.getItem(point);
+	}
+
+	/**
+	 * Returns the number of items contained in the receiver that are direct item children of the
+	 * receiver. The number that is returned is the number of roots in the tree.
+	 *
+	 * @return the number of items
+	 */
+	public int getItemCount() {
+		checkWidget();
+
+		return rootItem.getItemCount();
+	}
+
+	/**
+	 * Returns a (possibly empty) array of items contained in the receiver that are direct item
+	 * children of the receiver. These are the roots of the tree. Note: This is not the actual
+	 * structure used by the receiver to maintain its list of items, so modifying the array will not
+	 * affect the receiver.
+	 *
+	 * @return the items
+	 */
+	public TreemapItem[] getItems() {
+		checkWidget();
+
+		return rootItem.getItems();
+	}
+
+	/**
+	 * Returns true if the receiver's borders are visible, and false otherwise. If one of the
+	 * receiver's ancestors is not visible or some other condition makes the receiver not visible,
+	 * this method may still indicate that it is considered visible even though it may not actually
+	 * be showing.
+	 *
+	 * @return the visibility state of the borders
+	 */
+	public boolean getBordersVisible() {
+		checkWidget();
+
+		return borderVisible;
+	}
+
+	/**
+	 * Marks the receiver's lines as visible if the argument is true, and marks it invisible
+	 * otherwise. If one of the receiver's ancestors is not visible or some other condition makes
+	 * the receiver not visible, marking it visible may not actually cause it to be displayed.
+	 *
+	 * @param show
+	 *            the new visibility state
+	 */
+	public void setBordersVisible(boolean show) {
+		checkWidget();
+
+		borderVisible = show;
+	}
+
+	/**
+	 * Returns true if the receiver's tooltip is enabled, and false otherwise.
+	 * 
+	 * @return true of the tooltip is enabled, and false otherwise
+	 * @see TreemapItem#setToolTipText(String)
+	 */
+	public boolean getToolTipEnabled() {
+		checkWidget();
+
+		return toolTipEnabled;
+	}
+
+	/**
+	 * Marks the receiver's tooltip as enabled if the argument is true.
+	 * 
+	 * @param enabled
+	 *            true of the tooltip is enabled, and false otherwise
+	 */
+	public void setToolTipEnabled(boolean enabled) {
+		checkWidget();
+
+		toolTipEnabled = enabled;
+		if (enabled) {
+			toolTip.activate();
+		} else {
+			toolTip.deactivate();
+		}
+	}
+
+	/**
+	 * Returns the receiver's root item, which must be a TreeItem.
+	 *
+	 * @return the receiver's parent item
+	 */
+	public TreemapItem getRootItem() {
+		checkWidget();
+
+		return rootItem;
+	}
+
+	/**
+	 * Returns the TreeItems that are currently selected in the receiver. A null value indicates
+	 * that no item is selected.
+	 *
+	 * @return the item currently selected (or null)
+	 */
+	public TreemapItem getSelection() {
+		checkWidget();
+
+		return selectedItem;
+	}
+
+	/**
+	 * Sets the receiver's selection to the given item. The current selection is cleared before the
+	 * new item is selected. If the item is not in the receiver, then it is ignored.
+	 *
+	 * @param item
+	 *            the item to select
+	 */
+	public void setSelection(TreemapItem item) {
+		checkWidget();
+
+		if (item != null && item.getParent() != this) {
+			return; // not in the receiver
+		}
+
+		selectedItem = item;
+
+		Event e = createEventForItem(SWT.Selection, item);
+		notifyListeners(SWT.Selection, e);
+		redraw();
+	}
+
+	/**
+	 * Sets the receiver's text. This is equivalent to getting text on the root item.
+	 *
+	 * @return the new text
+	 */
+	public String getText() {
+		checkWidget();
+
+		return rootItem.getText();
+	}
+
+	/**
+	 * Returns the receiver's text, which will be an empty string if it has never been set. This is
+	 * equivalent to setting text on the root item.
+	 *
+	 * @param message
+	 *            the receiver's text
+	 */
+	public void setText(String message) {
+		checkWidget();
+
+		rootItem.setText(message);
+	}
+
+	/**
+	 * Returns the item which is currently at the top of the receiver. This item can change when
+	 * items new item is added or set as the top.
+	 *
+	 * @return the item at the top of the receiver
+	 */
+	public TreemapItem getTopItem() {
+		checkWidget();
+
+		return topItem;
+	}
+
+	/**
+	 * Sets the item which is currently at the top of the receiver. This item can change when items
+	 * are expanded, collapsed, scrolled or new items are added or removed. If the item is a leaf
+	 * (ie. no child), then the parent item is set as top if not null.
+	 *
+	 * @param item
+	 *            the item to be displayed as top
+	 */
+	public void setTopItem(TreemapItem item) {
+		checkWidget();
+
+		item = TreemapItem.checkNull(item);
+
+		if (item.getParent() != this) {
+			throw new IllegalArgumentException("the given TreemapItem does not belong to the receiver"); //$NON-NLS-1$
+		}
+
+		// if item is a leaf, then show it's parent item.
+		if (item.getItemCount() == 0 && item.getParentItem() != null) {
+			item = item.getParentItem();
+		}
+
+		TreemapItem oldItem = topItem;
+		topItem = item;
+
+		if (oldItem == topItem) {
+			return;
+		}
+
+		Event e = createEventForItem(SWT.NONE, topItem);
+		for (TreemapListener listener : treemapListeners) {
+			listener.treemapTopChanged(new TreemapEvent(e));
+		}
+
+		redraw();
+	}
+
+	/**
+	 * Returns the widget's tool tip text indicating more information about this item.
+	 *
+	 * @return the widget message
+	 */
+	public String getToolTip() {
+		checkWidget();
+
+		return rootItem.getToolTipText();
+	}
+
+	/**
+	 * Sets the widget's tool tip text indicating more information about this item.
+	 *
+	 * @param message
+	 *            the new message
+	 */
+	public void setToolTip(String message) {
+		checkWidget();
+
+		rootItem.setToolTipText(message);
+	}
+
+	/**
+	 * Searches the receiver's list starting at the first item (index 0) until an item is found that
+	 * is equal to the argument, and returns the index of that item. If no item is found, returns
+	 * -1.
+	 *
+	 * @param item
+	 *            the search item
+	 * @return the index of the item
+	 */
+	public int indexOf(TreemapItem item) {
+		checkWidget();
+
+		return rootItem.indexOf(item);
+	}
+
+	/**
+	 * Removes the item at the given, zero-relative index, sorted in descending order by weight, in
+	 * the receiver. Throws an exception if the index is out of range.
+	 *
+	 * @param index
+	 *            index of the item to remove
+	 */
+	public void remove(int index) {
+		checkWidget();
+
+		rootItem.remove(index);
+	}
+
+	/**
+	 * Removes all of the items from the receiver.
+	 */
+	public void removeAll() {
+		checkWidget();
+
+		rootItem.removeAll();
+	}
+
+	/**
+	 * Shows the item. If the item is already showing in the receiver, this method simply returns.
+	 * Otherwise, the items are expanded until the item is visible.
+	 *
+	 * @param item
+	 *            the item to be shown
+	 */
+	public void showItem(TreemapItem item) {
+		checkWidget();
+
+		item = TreemapItem.checkNull(item);
+
+		if (item.getParent() != this) {
+			throw new IllegalArgumentException("the given TreemapItem does not belong to the receiver"); //$NON-NLS-1$
+		}
+
+		TreemapItem top = item.getParentItem();
+		if (top == null) {
+			top = item;
+		}
+
+		setTopItem(top);
+
+		if (item.getBounds() == null) {
+			setTopItem(top);
+		}
+	}
+
+	/**
+	 * Shows the selected item. If the selection is already showing in the receiver, this method
+	 * simply returns. Otherwise, the items are scrolled until the selection is visible.
+	 */
+	public void showSelection() {
+		checkWidget();
+
+		TreemapItem selection = getSelection();
+		if (selection == null) {
+			return;
+		}
+
+		showItem(selection);
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapItem.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapItem.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapItem.java
@@ -0,0 +1,677 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Item;
+
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Instances of this class represent a selectable user interface object that represents a node in a
+ * treemap widget.
+ */
+public class TreemapItem extends Item {
+	private static final String ELLIPSIS = "..."; //$NON-NLS-1$
+	private static final int HORIZONTAL_PADDING = 13;
+	private static final int VERTICAL_PADDING = 13;
+	private static final int MIN_SIZE = 1;
+
+	private Treemap parent;
+	private TreemapItem parentItem;
+	private List<TreemapItem> children = new ArrayList<>();
+
+	private Color background = null;
+	private Color foreground = null;
+	private Font font = null;
+
+	private Rectangle bounds = null;
+	private Rectangle textBounds = null;
+
+	private double realWeight = 0; // the weight of the node
+	// the cached sum of all direct children's apparent weights + realWeight. -1 indicates not yet cached
+	private double apparentWeight = -1;
+
+	private String toolTipText = ""; //$NON-NLS-1$
+
+	// to be disposed
+	private Color darkenBackground = null;
+
+	/**
+	 * Constructs a new instance of this class and inserts it into the parent treemap. The new item
+	 * is inserted as a direct child of the root.
+	 *
+	 * @param parent
+	 *            a treemap control which will be the parent of the new instance (cannot be null)
+	 * @param style
+	 *            the style of control to construct
+	 */
+	public TreemapItem(Treemap parent, int style) {
+		this(Treemap.checkNull(parent), parent.getRootItem(), style);
+	}
+
+	/**
+	 * Constructs TreeItem and inserts it into Tree. The new item is inserted as direct child of the
+	 * specified item..
+	 *
+	 * @param parentItem
+	 *            a treemap item which will be the parent of the new instance (cannot be null)
+	 * @param style
+	 *            the style of control to construct
+	 */
+	public TreemapItem(TreemapItem parentItem, int style) {
+		this(checkNull(parentItem).parent, parentItem, style);
+	}
+
+	private TreemapItem(Treemap parent, TreemapItem parentItem, int style) {
+		super(parent, style);
+
+		if ((style & SWT.VIRTUAL) == SWT.VIRTUAL) {
+			throw new UnsupportedOperationException("SWT.VIRTUAL is not support by TreemapItem"); //$NON-NLS-1$
+		}
+
+		this.parent = parent;
+		this.parentItem = parentItem;
+
+		if (parentItem != null) {
+			// adding a 0 weighted node to the end of decreasingly sorted list preserves the sorted structure
+			parentItem.children.add(this);
+		}
+	}
+
+	/* package-private */
+	static TreemapItem checkNull(TreemapItem item) {
+		if (item == null) {
+			SWT.error(SWT.ERROR_NULL_ARGUMENT);
+		}
+
+		return item;
+	}
+
+	private void sortChildren() {
+		children.sort(Comparator.comparingDouble(TreemapItem::getWeight).reversed());
+	}
+
+	void updateAncestor() {
+		// update apparentWeight for all ancestors
+		for (TreemapItem ancestor = parentItem; ancestor != null; ancestor = ancestor.parentItem) {
+			ancestor.sortChildren();
+			ancestor.cacheApparentWeight();
+		}
+	}
+
+	private void clearThis() {
+		this.realWeight = 0;
+		this.apparentWeight = -1;
+		this.foreground = null;
+		this.background = null;
+		this.font = null;
+
+		if (darkenBackground != null && !darkenBackground.isDisposed()) {
+			darkenBackground.dispose();
+		}
+		this.darkenBackground = null;
+
+		this.setData(null);
+		this.setText(""); //$NON-NLS-1$
+		this.setToolTipText(""); //$NON-NLS-1$
+
+		updateAncestor();
+	}
+
+	private void cacheApparentWeight() {
+		double sum = 0;
+		for (TreemapItem child : children) {
+			sum += child.getWeight();
+		}
+
+		sum += realWeight;
+		apparentWeight = sum;
+	}
+
+	/* package-private */ void paintItem(GC gc, Rectangle bounds, boolean all) {
+		this.bounds = bounds;
+
+		Color bg = gc.getBackground();
+		Color fg = gc.getForeground();
+		Font font = gc.getFont();
+
+		// fill background
+		gc.setBackground(parent.getSelection() == this ? getDarkenBackground() : getBackground());
+		gc.fillRectangle(bounds);
+
+		if (getParent().getBordersVisible()) {
+			gc.setForeground(getDarkenBackground());
+			gc.drawRectangle(bounds);
+		}
+
+		gc.setFont(getFont());
+		paintTextIfPossible(gc);
+		if (all) {
+			paintChildrenIfPossible(gc);
+		} else {
+			for (TreemapItem child : getItems()) {
+				child.clearBounds(true);
+			}
+		}
+
+		gc.setBackground(bg);
+		gc.setForeground(fg);
+		gc.setFont(font);
+	}
+
+	// add label to tile if space permits
+	private void paintTextIfPossible(GC gc) {
+		String text = getText();
+		if (text == null || text.equals("")) { //$NON-NLS-1$
+			return;
+		}
+
+		if (!tryPaintText(gc, text)) {
+			tryPaintText(gc, ELLIPSIS);
+		}
+	}
+
+	private boolean tryPaintText(GC gc, String text) {
+		Rectangle textBounds;
+		if (getParent().getBordersVisible()) {
+			textBounds = new Rectangle(bounds.x, bounds.y, bounds.width - 2, bounds.height - 2); // -2 for the border
+		} else {
+			textBounds = new Rectangle(bounds.x, bounds.y, bounds.width, bounds.height);
+		}
+
+		Point textExtent = gc.textExtent(text);
+
+		if (textExtent.x > textBounds.width || textExtent.y > textBounds.height) {
+			this.textBounds = null;
+			return false;
+		}
+
+		textBounds.width = textExtent.x;
+		textBounds.height = textExtent.y;
+
+		gc.setFont(getFont());
+		gc.setForeground(getForeground());
+
+		if (getParent().getBordersVisible()) {
+			gc.drawText(text, bounds.x + 1, bounds.y + 1); // +1 so it doesn't overlap with the border
+		} else {
+			gc.drawText(text, bounds.x, bounds.y);
+		}
+
+		this.textBounds = textBounds;
+		return true;
+	}
+
+	// add child tiles if space permits
+	private void paintChildrenIfPossible(GC gc) {
+		// calculate available sub region for child tiles
+		Rectangle2D.Double availableRegion;
+		{
+			double w = Math.max(0, bounds.width - 2 * HORIZONTAL_PADDING);
+			double h = Math.max(0, bounds.height - 2 * VERTICAL_PADDING);
+			if (textBounds != null && textBounds.height > VERTICAL_PADDING) {
+				h = h - textBounds.height + VERTICAL_PADDING;
+			}
+			availableRegion = new Rectangle2D.Double(0, 0, w, h);
+		}
+
+		if (availableRegion.width == 0 || availableRegion.height == 0) {
+			return;
+		}
+
+		// calculate child rectangles
+		List<TreemapItem> elements = Arrays.asList(getItems());
+		SquarifiedTreemap algorithm = new SquarifiedTreemap(availableRegion, elements);
+		Map<TreemapItem, Rectangle2D.Double> squarifiedMap = algorithm.squarify();
+
+		for (TreemapItem item : elements) {
+			Rectangle2D.Double childRect = squarifiedMap.get(item);
+
+			if (childRect.width < MIN_SIZE || childRect.height < MIN_SIZE) {
+				item.clearBounds(true);
+				continue;
+			}
+
+			Rectangle2D.Double childBounds = squarifiedMap.get(item);
+
+			int x = (int) childBounds.x + bounds.x + HORIZONTAL_PADDING;
+			int y = (int) childBounds.y + bounds.y + VERTICAL_PADDING;
+			if (textBounds != null && textBounds.height > VERTICAL_PADDING) {
+				y = y + textBounds.height - VERTICAL_PADDING;
+			}
+			int w = (int) childBounds.width;
+			int h = (int) childBounds.height;
+
+			item.paintItem(gc, new Rectangle(x, y, w, h), true);
+		}
+	}
+
+	private void clearBounds(boolean all) {
+		bounds = null;
+		textBounds = null;
+
+		if (!all) {
+			return;
+		}
+
+		for (TreemapItem child : getItems()) {
+			child.clearBounds(true);
+		}
+	}
+
+	/**
+	 * Clears the item at the given zero-relative index, sorted in descending order by weight, in
+	 * the receiver. The text, weight and other attributes of the item are set to the default value.
+	 * again as needed.
+	 *
+	 * @param index
+	 *            the index of the item to clear
+	 * @param all
+	 *            true if all child items of the indexed item should be cleared recursively, and
+	 *            false otherwise
+	 */
+	public void clear(int index, boolean all) {
+		checkWidget();
+
+		TreemapItem target = children.get(index);
+		target.clearThis();
+
+		if (all) {
+			target.clearAll(true);
+		}
+	}
+
+	/**
+	 * Clears all the items in the receiver. The text, weight and other attributes of the items are
+	 * set to their default values.
+	 *
+	 * @param all
+	 *            true if all child items should be cleared recursively, and false otherwise
+	 */
+	public void clearAll(boolean all) {
+		checkWidget();
+
+		children.forEach(item -> {
+			item.clearThis();
+
+			if (all) {
+				item.clearAll(true);
+			}
+		});
+	}
+
+	@Override
+	public void dispose() {
+		if (darkenBackground != null && !darkenBackground.isDisposed()) {
+			darkenBackground.dispose();
+		}
+
+		super.dispose();
+	}
+
+	/**
+	 * Returns the receiver's background color.
+	 *
+	 * @return the background color
+	 */
+	public Color getBackground() {
+		checkWidget();
+
+		if (background != null) {
+			return background;
+		}
+
+		if (parentItem != null) {
+			return parentItem.getBackground();
+		}
+
+		return parent.getBackground();
+	}
+
+	private Color getDarkenBackground() {
+		if (darkenBackground == null || darkenBackground.isDisposed()) {
+			Color bg = getBackground();
+			int r = (int) (bg.getRed() * 0.8);
+			int g = (int) (bg.getGreen() * 0.8);
+			int b = (int) (bg.getBlue() * 0.8);
+
+			darkenBackground = new Color(Display.getCurrent(), r, g, b);
+		}
+		return darkenBackground;
+	}
+
+	/**
+	 * Sets the receiver's background color to the color specified by the argument, or to the
+	 * default system color for the item if the argument is null.
+	 *
+	 * @param color
+	 *            the new color (or null)
+	 */
+	public void setBackground(Color color) {
+		checkWidget();
+
+		background = color;
+
+		if (darkenBackground != null && !darkenBackground.isDisposed()) {
+			darkenBackground.dispose();
+		}
+		darkenBackground = null;
+	}
+
+	/**
+	 * Returns a rectangle describing the size and location of the receiver relative to its parent.
+	 *
+	 * @return the bounding rectangle of the receiver's text
+	 */
+	public Rectangle getBounds() {
+		checkWidget();
+
+		return bounds;
+	}
+
+	/**
+	 * Returns the font that the receiver will use to paint textual information for this item.
+	 *
+	 * @return the receiver's font
+	 */
+	public Font getFont() {
+		checkWidget();
+
+		if (font != null) {
+			return font;
+		}
+
+		if (parentItem != null) {
+			return parentItem.getFont();
+		}
+
+		return parent.getFont();
+	}
+
+	/**
+	 * Sets the font that the receiver will use to paint textual information for this item to the
+	 * font specified by the argument, or to the default font for that kind of control if the
+	 * argument is null.
+	 *
+	 * @param font
+	 *            the new font (or null)
+	 */
+	public void setFont(Font font) {
+		checkWidget();
+
+		this.font = font;
+	}
+
+	/**
+	 * Returns the foreground color that the receiver will use to draw.
+	 *
+	 * @return the receiver's foreground color
+	 */
+	public Color getForeground() {
+		checkWidget();
+
+		if (foreground != null) {
+			return foreground;
+		}
+
+		if (parentItem != null) {
+			return parentItem.getForeground();
+		}
+
+		return parent.getForeground();
+	}
+
+	/**
+	 * Sets the foreground color at the given column index in the receiver to the color specified by
+	 * the argument, or to the default system color for the item if the argument is null.
+	 *
+	 * @param color
+	 *            the new color (or null)
+	 */
+	public void setForeground(Color color) {
+		checkWidget();
+
+		this.foreground = color;
+	}
+
+	/**
+	 * Returns the item at the given, zero-relative index, sorted in descending order by weight, in
+	 * the receiver. Throws an exception if the index is out of range.
+	 *
+	 * @param index
+	 *            the index of the item to return
+	 * @return the item at the given index
+	 */
+	public TreemapItem getItem(int index) {
+		checkWidget();
+
+		return children.get(index);
+	}
+
+	/**
+	 * Returns the item at the given point in the receiver or null if no such item exists. The point
+	 * is in the coordinate system of the receiver.
+	 *
+	 * @param point
+	 *            the point used to locate the item
+	 * @return the item at the given point, or null if the point is not in a selectable item
+	 */
+	public TreemapItem getItem(Point point) {
+		checkWidget();
+
+		if (getBounds() == null || !getBounds().contains(point)) {
+			return null;
+		}
+
+		for (TreemapItem child : children) {
+			if (child.getBounds() != null && child.getBounds().contains(point)) {
+				return child.getItem(point);
+			}
+		}
+
+		return this;
+	}
+
+	/**
+	 * Returns the number of items contained in the receiver that are direct item children of the
+	 * receiver.
+	 *
+	 * @return the number of items
+	 */
+	public int getItemCount() {
+		checkWidget();
+
+		return children.size();
+	}
+
+	/**
+	 * Returns a (possibly empty) array of TreeItems which are the direct item children of the
+	 * receiver. Note: This is not the actual structure used by the receiver to maintain its list of
+	 * items, so modifying the array will not affect the receiver.
+	 *
+	 * @return the receiver's items
+	 */
+	public TreemapItem[] getItems() {
+		checkWidget();
+
+		return children.toArray(new TreemapItem[0]);
+	}
+
+	/**
+	 * Returns the receiver's parent, which must be a Treemap.
+	 *
+	 * @return the receiver's parent
+	 */
+	public Treemap getParent() {
+		checkWidget();
+
+		return parent;
+	}
+
+	/**
+	 * Returns the receiver's parent item, which must be a TreeItem or null when the receiver is a
+	 * root.
+	 *
+	 * @return the receiver's parent item
+	 */
+	public TreemapItem getParentItem() {
+		checkWidget();
+
+		return parentItem;
+	}
+
+	/**
+	 * Returns a rectangle describing the size and location relative to its parent of the text.
+	 *
+	 * @return the receiver's bounding text rectangle
+	 */
+	public Rectangle getTextBounds() {
+		checkWidget();
+
+		return textBounds;
+	}
+
+	/**
+	 * Returns the receiver's weight, which is the sum of weights of all its direct children.
+	 *
+	 * @return the receiver's weight
+	 */
+	public double getWeight() {
+		checkWidget();
+
+		if (apparentWeight == -1) {
+			cacheApparentWeight();
+		}
+
+		return apparentWeight;
+	}
+
+	/**
+	 * Returns the widget's tool tip text indicating more information about this item.
+	 *
+	 * @return the widget tool tip text
+	 */
+	public String getToolTipText() {
+		checkWidget();
+
+		return toolTipText;
+	}
+
+	/**
+	 * Sets the widget's tool tip text indicating more information about this item.
+	 *
+	 * @param text
+	 *            the new tool tip text
+	 */
+	public void setToolTipText(String text) {
+		checkWidget();
+
+		Objects.requireNonNull(text);
+		this.toolTipText = text;
+	}
+
+	/**
+	 * Sets the receiver's weight, which must be a non-negative number.
+	 *
+	 * @param weight
+	 *            the new weight
+	 */
+	public void setWeight(double weight) {
+		checkWidget();
+
+		if (weight < 0) {
+			throw new IllegalArgumentException("weight must be positive"); //$NON-NLS-1$
+		}
+
+		realWeight = weight;
+		apparentWeight = -1;
+
+		updateAncestor();
+	}
+
+	/**
+	 * Searches the receiver's list starting at the first item (index 0) until an item is found that
+	 * is equal to the argument, and returns the index of that item. If no item is found, returns
+	 * -1.
+	 *
+	 * @param item
+	 *            the search item
+	 * @return the index of the item
+	 */
+	public int indexOf(TreemapItem item) {
+		checkWidget();
+
+		return children.indexOf(item);
+	}
+
+	/**
+	 * Removes the item at the given, zero-relative index, sorted in descending order by weight, in
+	 * the receiver. Throws an exception if the index is out of range.
+	 *
+	 * @param index
+	 *            index of the item to remove
+	 */
+	public void remove(int index) {
+		checkWidget();
+
+		TreemapItem item = getItem(index);
+		children.remove(item);
+	}
+
+	/**
+	 * Removes all of the items from the receiver.
+	 */
+	public void removeAll() {
+		checkWidget();
+
+		for (TreemapItem child : children) {
+			child.removeAll();
+		}
+
+		children.clear();
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapToolTip.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapToolTip.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/TreemapToolTip.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.jface.window.ToolTip;
+
+/*package-private*/ class TreemapToolTip extends ToolTip {
+	private static final int PADDING = 5;
+
+	private TreemapItem item = null;
+
+	public TreemapToolTip(Control parent) {
+		super(parent);
+	}
+
+	@Override
+	protected Composite createToolTipContentArea(Event event, Composite parent) {
+		Composite ret = new Composite(parent, SWT.NONE);
+
+		RowLayout rowLayout = new RowLayout();
+		rowLayout.marginLeft = PADDING;
+		rowLayout.marginTop = PADDING;
+		rowLayout.marginRight = PADDING;
+		rowLayout.marginBottom = PADDING;
+
+		ret.setLayout(rowLayout);
+		ret.setBackground(parent.getBackground());
+
+		Label label = new Label(ret, SWT.NONE);
+		label.setText(item != null ? item.getToolTipText() : ""); //$NON-NLS-1$
+		label.setForeground(parent.getForeground());
+
+		return ret;
+	}
+
+	public void setItem(TreemapItem item) {
+		this.item = item;
+
+		if (item.getToolTipText().isEmpty()) {
+			deactivate();
+		} else {
+			activate();
+		}
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapEvent.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapEvent.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapEvent.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt.events;
+
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.widgets.Event;
+
+/**
+ * Instances of this class are sent as a result of new item being set as the top.
+ */
+public final class TreemapEvent extends SelectionEvent {
+
+	static final long serialVersionUID = 1L;
+
+	/**
+	 * Constructs a new instance of this class based on the information in the given untyped event.
+	 * 
+	 * @param e
+	 *            the untyped event containing the information
+	 */
+	public TreemapEvent(Event e) {
+		super(e);
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapListener.java b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapListener.java
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/java/org/openjdk/jmc/joverflow/ext/treemap/swt/events/TreemapListener.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.joverflow.ext.treemap.swt.events;
+
+import org.eclipse.swt.internal.SWTEventListener;
+import org.openjdk.jmc.joverflow.ext.treemap.swt.Treemap;
+
+import java.util.function.Consumer;
+
+/**
+ * Classes which implement this interface provide methods that deal with setting new item as top for
+ * a treemap.
+ */
+public interface TreemapListener extends SWTEventListener {
+
+	/**
+	 * Sent when a treemap becomes the new top.
+	 *
+	 * @param event
+	 *            an event containing information about the treemap operation
+	 * @see Treemap#getTopItem()
+	 */
+	void treemapTopChanged(TreemapEvent event);
+
+	static TreemapListener treemapTopChangedAdapter(final Consumer<TreemapEvent> c) {
+		return c::accept;
+	}
+}
diff a/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/resources/org/openjdk/jmc/joverflow/ext/treemap/messages.properties b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/resources/org/openjdk/jmc/joverflow/ext/treemap/messages.properties
--- /dev/null
+++ b/application/org.openjdk.jmc.joverflow.ext.treemap/src/main/resources/org/openjdk/jmc/joverflow/ext/treemap/messages.properties
@@ -0,0 +1,38 @@
+#
+#  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2020, Red Hat Inc. All rights reserved.
+#
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  The contents of this file are subject to the terms of either the Universal Permissive License 
+#  v 1.0 as shown at http://oss.oracle.com/licenses/upl
+#   
+#  or the following license:
+#   
+#  Redistribution and use in source and binary forms, with or without modification, are permitted
+#  provided that the following conditions are met:
+#   
+#  1. Redistributions of source code must retain the above copyright notice, this list of conditions
+#  and the following disclaimer.
+#   
+#  2. Redistributions in binary form must reproduce the above copyright notice, this list of
+#  conditions and the following disclaimer in the documentation and/or other materials provided with
+#  the distribution.
+#   
+#  3. Neither the name of the copyright holder nor the names of its contributors may be used to
+#  endorse or promote products derived from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+TreemapAction_ZOOM_IN_DESCRIPTION=Zoom-in to the selected node
+TreemapAction_ZOOM_OUT_DESCRIPTION=Zoom-out to the parent node
+TreemapAction_ZOOM_OFF_DESCRIPTION=Display the root node
+TreemapPageBookView_NO_JOVERFLOW_EDITOR_SELECTED=No JOverflow editor selected
+TreemapPage_NO_INSTANCES_SELECTED=No instances selected
diff a/application/org.openjdk.jmc.joverflow.ui/META-INF/MANIFEST.MF b/application/org.openjdk.jmc.joverflow.ui/META-INF/MANIFEST.MF
--- a/application/org.openjdk.jmc.joverflow.ui/META-INF/MANIFEST.MF
+++ b/application/org.openjdk.jmc.joverflow.ui/META-INF/MANIFEST.MF
@@ -11,5 +11,7 @@
 Eclipse-BuddyPolicy: app
 Bundle-ActivationPolicy: lazy
 Bundle-Activator: org.openjdk.jmc.joverflow.ui.JOverflowPlugin
 Automatic-Module-Name: org.openjdk.jmc.joverflow.ui
 Import-Package: org.openjdk.jmc.flightrecorder.ui
+Export-Package: org.openjdk.jmc.joverflow.ui,
+ org.openjdk.jmc.joverflow.ui.model
diff a/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowEditor.java b/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowEditor.java
--- a/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowEditor.java
+++ b/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowEditor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -265,28 +265,28 @@
 	@Override
 	public boolean isSaveAsAllowed() {
 		return false;
 	}
 
-	JOverflowUi getJOverflowUi() {
+	public JOverflowUi getJOverflowUi() {
 		return mJOverflowUi;
 	}
 
-	Snapshot getSnapshot() {
+	public Snapshot getSnapshot() {
 		return mSnapshot;
 	}
 
-	void addUiLoadedListener(UiLoadedListener listener) {
+	public void addUiLoadedListener(UiLoadedListener listener) {
 		mUiLoadedListeners.add(listener);
 		if (mJOverflowUi != null) {
 			listener.uiLoaded(mJOverflowUi);
 		}
 	}
 
-	void removeUiLoadedListener(UiLoadedListener listener) {
+	public void removeUiLoadedListener(UiLoadedListener listener) {
 		mUiLoadedListeners.remove(listener);
 	}
 
-	interface UiLoadedListener {
+	public interface UiLoadedListener {
 		void uiLoaded(JOverflowUi ui);
 	}
 }
diff a/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowUi.java b/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowUi.java
--- a/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowUi.java
+++ b/application/org.openjdk.jmc.joverflow.ui/src/main/java/org/openjdk/jmc/joverflow/ui/JOverflowUi.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.
  *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -181,17 +181,17 @@
 		mAncestorViewer.reset();
 
 		updateModel();
 	}
 
-	void addModelListener(final ModelListener listener) {
+	public void addModelListener(final ModelListener listener) {
 		mModelListeners.add(listener);
 
 		if (mModel != null) {
 			updateModel();
 		}
 	}
 
-	void removeModelListener(final ModelListener listener) {
+	public void removeModelListener(final ModelListener listener) {
 		mModelListeners.remove(listener);
 	}
 }
diff a/application/pom.xml b/application/pom.xml
--- a/application/pom.xml
+++ b/application/pom.xml
@@ -75,10 +75,11 @@
 		<module>org.openjdk.jmc.feature.flightrecorder.metadata</module>
 		<module>org.openjdk.jmc.feature.ide</module>
 		<module>org.openjdk.jmc.feature.ide.launch</module>
 		<module>org.openjdk.jmc.feature.jconsole</module>
 		<module>org.openjdk.jmc.feature.joverflow</module>
+		<module>org.openjdk.jmc.feature.joverflow.ext.treemap</module>
 		<module>org.openjdk.jmc.feature.license</module>
 		<module>org.openjdk.jmc.feature.pde</module>
 		<module>org.openjdk.jmc.feature.rcp</module>
 		<module>org.openjdk.jmc.feature.rcp.update</module>
 		<module>org.openjdk.jmc.feature.twitter</module>
@@ -97,10 +98,11 @@
 		<module>org.openjdk.jmc.ide.jdt</module>
 		<module>org.openjdk.jmc.ide.launch</module>
 		<module>org.openjdk.jmc.ide.ui</module>
 		<module>org.openjdk.jmc.joverflow</module>
 		<module>org.openjdk.jmc.joverflow.ui</module>
+		<module>org.openjdk.jmc.joverflow.ext.treemap</module>
 		<module>org.openjdk.jmc.osgi.extension</module>
 		<module>org.openjdk.jmc.pde</module>
 		<module>org.openjdk.jmc.rcp.application</module>
 		<module>org.openjdk.jmc.rcp.intro</module>
 		<module>org.openjdk.jmc.rcp.product</module>
