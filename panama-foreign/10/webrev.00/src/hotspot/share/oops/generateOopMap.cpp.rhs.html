<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/generateOopMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interpreter/bytecodeStream.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;logging/logStream.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;oops/constantPool.hpp&quot;
  31 #include &quot;oops/generateOopMap.hpp&quot;
  32 #include &quot;oops/oop.inline.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;runtime/handles.inline.hpp&quot;
  35 #include &quot;runtime/java.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;runtime/relocator.hpp&quot;
  38 #include &quot;runtime/timerTrace.hpp&quot;
  39 #include &quot;utilities/bitMap.inline.hpp&quot;
  40 #include &quot;utilities/ostream.hpp&quot;
  41 
  42 //
  43 //
  44 // Compute stack layouts for each instruction in method.
  45 //
  46 //  Problems:
  47 //  - What to do about jsr with different types of local vars?
  48 //  Need maps that are conditional on jsr path?
  49 //  - Jsr and exceptions should be done more efficiently (the retAddr stuff)
  50 //
  51 //  Alternative:
  52 //  - Could extend verifier to provide this information.
  53 //    For: one fewer abstract interpreter to maintain. Against: the verifier
  54 //    solves a bigger problem so slower (undesirable to force verification of
  55 //    everything?).
  56 //
  57 //  Algorithm:
  58 //    Partition bytecodes into basic blocks
  59 //    For each basic block: store entry state (vars, stack). For instructions
  60 //    inside basic blocks we do not store any state (instead we recompute it
  61 //    from state produced by previous instruction).
  62 //
  63 //    Perform abstract interpretation of bytecodes over this lattice:
  64 //
  65 //                _--&#39;#&#39;--_
  66 //               /  /  \   \
  67 //             /   /     \   \
  68 //            /    |     |     \
  69 //          &#39;r&#39;   &#39;v&#39;   &#39;p&#39;   &#39; &#39;
  70 //           \     |     |     /
  71 //            \    \     /    /
  72 //              \   \   /    /
  73 //                -- &#39;@&#39; --
  74 //
  75 //    &#39;#&#39;  top, result of conflict merge
  76 //    &#39;r&#39;  reference type
  77 //    &#39;v&#39;  value type
  78 //    &#39;p&#39;  pc type for jsr/ret
  79 //    &#39; &#39;  uninitialized; never occurs on operand stack in Java
  80 //    &#39;@&#39;  bottom/unexecuted; initial state each bytecode.
  81 //
  82 //    Basic block headers are the only merge points. We use this iteration to
  83 //    compute the information:
  84 //
  85 //    find basic blocks;
  86 //    initialize them with uninitialized state;
  87 //    initialize first BB according to method signature;
  88 //    mark first BB changed
  89 //    while (some BB is changed) do {
  90 //      perform abstract interpration of all bytecodes in BB;
  91 //      merge exit state of BB into entry state of all successor BBs,
  92 //      noting if any of these change;
  93 //    }
  94 //
  95 //  One additional complication is necessary. The jsr instruction pushes
  96 //  a return PC on the stack (a &#39;p&#39; type in the abstract interpretation).
  97 //  To be able to process &quot;ret&quot; bytecodes, we keep track of these return
  98 //  PC&#39;s in a &#39;retAddrs&#39; structure in abstract interpreter context (when
  99 //  processing a &quot;ret&quot; bytecodes, it is not sufficient to know that it gets
 100 //  an argument of the right type &#39;p&#39;; we need to know which address it
 101 //  returns to).
 102 //
 103 // (Note this comment is borrowed form the original author of the algorithm)
 104 
 105 // ComputeCallStack
 106 //
 107 // Specialization of SignatureIterator - compute the effects of a call
 108 //
 109 class ComputeCallStack : public SignatureIterator {
 110   CellTypeState *_effect;
 111   int _idx;
 112 
 113   void setup();
 114   void set(CellTypeState state)         { _effect[_idx++] = state; }
 115   int  length()                         { return _idx; };
 116 
<a name="2" id="anc2"></a><span class="line-modified"> 117   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 118   void do_type(BasicType type, bool for_return = false) {</span>
<span class="line-modified"> 119     if (for_return &amp;&amp; type == T_VOID) {</span>
<span class="line-modified"> 120       set(CellTypeState::bottom);</span>
<span class="line-modified"> 121     } else if (is_reference_type(type)) {</span>
<span class="line-modified"> 122       set(CellTypeState::ref);</span>
<span class="line-modified"> 123     } else {</span>
<span class="line-modified"> 124       assert(is_java_primitive(type), &quot;&quot;);</span>
<span class="line-modified"> 125       set(CellTypeState::value);</span>
<span class="line-modified"> 126       if (is_double_word_type(type)) {</span>
<span class="line-modified"> 127         set(CellTypeState::value);</span>
<span class="line-modified"> 128       }</span>
<span class="line-modified"> 129     }</span>
<span class="line-modified"> 130   }</span>
<span class="line-modified"> 131 </span>
<span class="line-modified"> 132  public:</span>
 133   ComputeCallStack(Symbol* signature) : SignatureIterator(signature) {};
 134 
 135   // Compute methods
 136   int compute_for_parameters(bool is_static, CellTypeState *effect) {
 137     _idx    = 0;
 138     _effect = effect;
 139 
 140     if (!is_static)
 141       effect[_idx++] = CellTypeState::ref;
 142 
<a name="3" id="anc3"></a><span class="line-modified"> 143     do_parameters_on(this);</span>
 144 
 145     return length();
 146   };
 147 
 148   int compute_for_returntype(CellTypeState *effect) {
 149     _idx    = 0;
 150     _effect = effect;
<a name="4" id="anc4"></a><span class="line-modified"> 151     do_type(return_type(), true);</span>
 152     set(CellTypeState::bottom);  // Always terminate with a bottom state, so ppush works
 153 
 154     return length();
 155   }
 156 };
 157 
 158 //=========================================================================================
 159 // ComputeEntryStack
 160 //
 161 // Specialization of SignatureIterator - in order to set up first stack frame
 162 //
 163 class ComputeEntryStack : public SignatureIterator {
 164   CellTypeState *_effect;
 165   int _idx;
 166 
 167   void setup();
 168   void set(CellTypeState state)         { _effect[_idx++] = state; }
 169   int  length()                         { return _idx; };
 170 
<a name="5" id="anc5"></a><span class="line-modified"> 171   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 172   void do_type(BasicType type, bool for_return = false) {</span>
<span class="line-modified"> 173     if (for_return &amp;&amp; type == T_VOID) {</span>
<span class="line-modified"> 174       set(CellTypeState::bottom);</span>
<span class="line-modified"> 175     } else if (is_reference_type(type)) {</span>
<span class="line-modified"> 176       set(CellTypeState::make_slot_ref(_idx));</span>
<span class="line-modified"> 177     } else {</span>
<span class="line-modified"> 178       assert(is_java_primitive(type), &quot;&quot;);</span>
<span class="line-modified"> 179       set(CellTypeState::value);</span>
<span class="line-modified"> 180       if (is_double_word_type(type)) {</span>
<span class="line-modified"> 181         set(CellTypeState::value);</span>
<span class="line-modified"> 182       }</span>
<span class="line-modified"> 183     }</span>
<span class="line-modified"> 184   }</span>
<span class="line-modified"> 185 </span>
<span class="line-modified"> 186  public:</span>
 187   ComputeEntryStack(Symbol* signature) : SignatureIterator(signature) {};
 188 
 189   // Compute methods
 190   int compute_for_parameters(bool is_static, CellTypeState *effect) {
 191     _idx    = 0;
 192     _effect = effect;
 193 
 194     if (!is_static)
 195       effect[_idx++] = CellTypeState::make_slot_ref(0);
 196 
<a name="6" id="anc6"></a><span class="line-modified"> 197     do_parameters_on(this);</span>
 198 
 199     return length();
 200   };
 201 
 202   int compute_for_returntype(CellTypeState *effect) {
 203     _idx    = 0;
 204     _effect = effect;
<a name="7" id="anc7"></a><span class="line-modified"> 205     do_type(return_type(), true);</span>
 206     set(CellTypeState::bottom);  // Always terminate with a bottom state, so ppush works
 207 
 208     return length();
 209   }
 210 };
 211 
 212 //=====================================================================================
 213 //
 214 // Implementation of RetTable/RetTableEntry
 215 //
 216 // Contains function to itereate through all bytecodes
 217 // and find all return entry points
 218 //
 219 int RetTable::_init_nof_entries = 10;
 220 int RetTableEntry::_init_nof_jsrs = 5;
 221 
 222 RetTableEntry::RetTableEntry(int target, RetTableEntry *next) {
 223   _target_bci = target;
 224   _jsrs = new GrowableArray&lt;intptr_t&gt;(_init_nof_jsrs);
 225   _next = next;
 226 }
 227 
 228 void RetTableEntry::add_delta(int bci, int delta) {
 229   if (_target_bci &gt; bci) _target_bci += delta;
 230 
 231   for (int k = 0; k &lt; _jsrs-&gt;length(); k++) {
 232     int jsr = _jsrs-&gt;at(k);
 233     if (jsr &gt; bci) _jsrs-&gt;at_put(k, jsr+delta);
 234   }
 235 }
 236 
 237 void RetTable::compute_ret_table(const methodHandle&amp; method) {
 238   BytecodeStream i(method);
 239   Bytecodes::Code bytecode;
 240 
 241   while( (bytecode = i.next()) &gt;= 0) {
 242     switch (bytecode) {
 243       case Bytecodes::_jsr:
 244         add_jsr(i.next_bci(), i.dest());
 245         break;
 246       case Bytecodes::_jsr_w:
 247         add_jsr(i.next_bci(), i.dest_w());
 248         break;
 249       default:
 250         break;
 251     }
 252   }
 253 }
 254 
 255 void RetTable::add_jsr(int return_bci, int target_bci) {
 256   RetTableEntry* entry = _first;
 257 
 258   // Scan table for entry
 259   for (;entry &amp;&amp; entry-&gt;target_bci() != target_bci; entry = entry-&gt;next());
 260 
 261   if (!entry) {
 262     // Allocate new entry and put in list
 263     entry = new RetTableEntry(target_bci, _first);
 264     _first = entry;
 265   }
 266 
 267   // Now &quot;entry&quot; is set.  Make sure that the entry is initialized
 268   // and has room for the new jsr.
 269   entry-&gt;add_jsr(return_bci);
 270 }
 271 
 272 RetTableEntry* RetTable::find_jsrs_for_target(int targBci) {
 273   RetTableEntry *cur = _first;
 274 
 275   while(cur) {
 276     assert(cur-&gt;target_bci() != -1, &quot;sanity check&quot;);
 277     if (cur-&gt;target_bci() == targBci)  return cur;
 278     cur = cur-&gt;next();
 279   }
 280   ShouldNotReachHere();
 281   return NULL;
 282 }
 283 
 284 // The instruction at bci is changing size by &quot;delta&quot;.  Update the return map.
 285 void RetTable::update_ret_table(int bci, int delta) {
 286   RetTableEntry *cur = _first;
 287   while(cur) {
 288     cur-&gt;add_delta(bci, delta);
 289     cur = cur-&gt;next();
 290   }
 291 }
 292 
 293 //
 294 // Celltype state
 295 //
 296 
 297 CellTypeState CellTypeState::bottom      = CellTypeState::make_bottom();
 298 CellTypeState CellTypeState::uninit      = CellTypeState::make_any(uninit_value);
 299 CellTypeState CellTypeState::ref         = CellTypeState::make_any(ref_conflict);
 300 CellTypeState CellTypeState::value       = CellTypeState::make_any(val_value);
 301 CellTypeState CellTypeState::refUninit   = CellTypeState::make_any(ref_conflict | uninit_value);
 302 CellTypeState CellTypeState::top         = CellTypeState::make_top();
 303 CellTypeState CellTypeState::addr        = CellTypeState::make_any(addr_conflict);
 304 
 305 // Commonly used constants
 306 static CellTypeState epsilonCTS[1] = { CellTypeState::bottom };
 307 static CellTypeState   refCTS   = CellTypeState::ref;
 308 static CellTypeState   valCTS   = CellTypeState::value;
 309 static CellTypeState    vCTS[2] = { CellTypeState::value, CellTypeState::bottom };
 310 static CellTypeState    rCTS[2] = { CellTypeState::ref,   CellTypeState::bottom };
 311 static CellTypeState   rrCTS[3] = { CellTypeState::ref,   CellTypeState::ref,   CellTypeState::bottom };
 312 static CellTypeState   vrCTS[3] = { CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 313 static CellTypeState   vvCTS[3] = { CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 314 static CellTypeState  rvrCTS[4] = { CellTypeState::ref,   CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 315 static CellTypeState  vvrCTS[4] = { CellTypeState::value, CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 316 static CellTypeState  vvvCTS[4] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 317 static CellTypeState vvvrCTS[5] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::ref,   CellTypeState::bottom };
 318 static CellTypeState vvvvCTS[5] = { CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::value, CellTypeState::bottom };
 319 
 320 char CellTypeState::to_char() const {
 321   if (can_be_reference()) {
 322     if (can_be_value() || can_be_address())
 323       return &#39;#&#39;;    // Conflict that needs to be rewritten
 324     else
 325       return &#39;r&#39;;
 326   } else if (can_be_value())
 327     return &#39;v&#39;;
 328   else if (can_be_address())
 329     return &#39;p&#39;;
 330   else if (can_be_uninit())
 331     return &#39; &#39;;
 332   else
 333     return &#39;@&#39;;
 334 }
 335 
 336 
 337 // Print a detailed CellTypeState.  Indicate all bits that are set.  If
 338 // the CellTypeState represents an address or a reference, print the
 339 // value of the additional information.
 340 void CellTypeState::print(outputStream *os) {
 341   if (can_be_address()) {
 342     os-&gt;print(&quot;(p&quot;);
 343   } else {
 344     os-&gt;print(&quot;( &quot;);
 345   }
 346   if (can_be_reference()) {
 347     os-&gt;print(&quot;r&quot;);
 348   } else {
 349     os-&gt;print(&quot; &quot;);
 350   }
 351   if (can_be_value()) {
 352     os-&gt;print(&quot;v&quot;);
 353   } else {
 354     os-&gt;print(&quot; &quot;);
 355   }
 356   if (can_be_uninit()) {
 357     os-&gt;print(&quot;u|&quot;);
 358   } else {
 359     os-&gt;print(&quot; |&quot;);
 360   }
 361   if (is_info_top()) {
 362     os-&gt;print(&quot;Top)&quot;);
 363   } else if (is_info_bottom()) {
 364     os-&gt;print(&quot;Bot)&quot;);
 365   } else {
 366     if (is_reference()) {
 367       int info = get_info();
 368       int data = info &amp; ~(ref_not_lock_bit | ref_slot_bit);
 369       if (info &amp; ref_not_lock_bit) {
 370         // Not a monitor lock reference.
 371         if (info &amp; ref_slot_bit) {
 372           // slot
 373           os-&gt;print(&quot;slot%d)&quot;, data);
 374         } else {
 375           // line
 376           os-&gt;print(&quot;line%d)&quot;, data);
 377         }
 378       } else {
 379         // lock
 380         os-&gt;print(&quot;lock%d)&quot;, data);
 381       }
 382     } else {
 383       os-&gt;print(&quot;%d)&quot;, get_info());
 384     }
 385   }
 386 }
 387 
 388 //
 389 // Basicblock handling methods
 390 //
 391 
 392 void GenerateOopMap::initialize_bb() {
 393   _gc_points = 0;
 394   _bb_count  = 0;
 395   _bb_hdr_bits.reinitialize(method()-&gt;code_size());
 396 }
 397 
 398 void GenerateOopMap::bb_mark_fct(GenerateOopMap *c, int bci, int *data) {
 399   assert(bci&gt;= 0 &amp;&amp; bci &lt; c-&gt;method()-&gt;code_size(), &quot;index out of bounds&quot;);
 400   if (c-&gt;is_bb_header(bci))
 401      return;
 402 
 403   if (TraceNewOopMapGeneration) {
 404      tty-&gt;print_cr(&quot;Basicblock#%d begins at: %d&quot;, c-&gt;_bb_count, bci);
 405   }
 406   c-&gt;set_bbmark_bit(bci);
 407   c-&gt;_bb_count++;
 408 }
 409 
 410 
 411 void GenerateOopMap::mark_bbheaders_and_count_gc_points() {
 412   initialize_bb();
 413 
 414   bool fellThrough = false;  // False to get first BB marked.
 415 
 416   // First mark all exception handlers as start of a basic-block
 417   ExceptionTable excps(method());
 418   for(int i = 0; i &lt; excps.length(); i ++) {
 419     bb_mark_fct(this, excps.handler_pc(i), NULL);
 420   }
 421 
 422   // Then iterate through the code
 423   BytecodeStream bcs(_method);
 424   Bytecodes::Code bytecode;
 425 
 426   while( (bytecode = bcs.next()) &gt;= 0) {
 427     int bci = bcs.bci();
 428 
 429     if (!fellThrough)
 430         bb_mark_fct(this, bci, NULL);
 431 
 432     fellThrough = jump_targets_do(&amp;bcs, &amp;GenerateOopMap::bb_mark_fct, NULL);
 433 
 434      /* We will also mark successors of jsr&#39;s as basic block headers. */
 435     switch (bytecode) {
 436       case Bytecodes::_jsr:
 437         assert(!fellThrough, &quot;should not happen&quot;);
 438         bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);
 439         break;
 440       case Bytecodes::_jsr_w:
 441         assert(!fellThrough, &quot;should not happen&quot;);
 442         bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), NULL);
 443         break;
 444       default:
 445         break;
 446     }
 447 
 448     if (possible_gc_point(&amp;bcs))
 449       _gc_points++;
 450   }
 451 }
 452 
 453 void GenerateOopMap::set_bbmark_bit(int bci) {
 454   _bb_hdr_bits.at_put(bci, true);
 455 }
 456 
 457 void GenerateOopMap::reachable_basicblock(GenerateOopMap *c, int bci, int *data) {
 458   assert(bci&gt;= 0 &amp;&amp; bci &lt; c-&gt;method()-&gt;code_size(), &quot;index out of bounds&quot;);
 459   BasicBlock* bb = c-&gt;get_basic_block_at(bci);
 460   if (bb-&gt;is_dead()) {
 461     bb-&gt;mark_as_alive();
 462     *data = 1; // Mark basicblock as changed
 463   }
 464 }
 465 
 466 
 467 void GenerateOopMap::mark_reachable_code() {
 468   int change = 1; // int to get function pointers to work
 469 
 470   // Mark entry basic block as alive and all exception handlers
 471   _basic_blocks[0].mark_as_alive();
 472   ExceptionTable excps(method());
 473   for(int i = 0; i &lt; excps.length(); i++) {
 474     BasicBlock *bb = get_basic_block_at(excps.handler_pc(i));
 475     // If block is not already alive (due to multiple exception handlers to same bb), then
 476     // make it alive
 477     if (bb-&gt;is_dead()) bb-&gt;mark_as_alive();
 478   }
 479 
 480   BytecodeStream bcs(_method);
 481 
 482   // Iterate through all basic blocks until we reach a fixpoint
 483   while (change) {
 484     change = 0;
 485 
 486     for (int i = 0; i &lt; _bb_count; i++) {
 487       BasicBlock *bb = &amp;_basic_blocks[i];
 488       if (bb-&gt;is_alive()) {
 489         // Position bytecodestream at last bytecode in basicblock
 490         bcs.set_start(bb-&gt;_end_bci);
 491         bcs.next();
 492         Bytecodes::Code bytecode = bcs.code();
 493         int bci = bcs.bci();
 494         assert(bci == bb-&gt;_end_bci, &quot;wrong bci&quot;);
 495 
 496         bool fell_through = jump_targets_do(&amp;bcs, &amp;GenerateOopMap::reachable_basicblock, &amp;change);
 497 
 498         // We will also mark successors of jsr&#39;s as alive.
 499         switch (bytecode) {
 500           case Bytecodes::_jsr:
 501           case Bytecodes::_jsr_w:
 502             assert(!fell_through, &quot;should not happen&quot;);
 503             reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &amp;change);
 504             break;
 505           default:
 506             break;
 507         }
 508         if (fell_through) {
 509           // Mark successor as alive
 510           if (bb[1].is_dead()) {
 511             bb[1].mark_as_alive();
 512             change = 1;
 513           }
 514         }
 515       }
 516     }
 517   }
 518 }
 519 
 520 /* If the current instruction in &quot;c&quot; has no effect on control flow,
 521    returns &quot;true&quot;.  Otherwise, calls &quot;jmpFct&quot; one or more times, with
 522    &quot;c&quot;, an appropriate &quot;pcDelta&quot;, and &quot;data&quot; as arguments, then
 523    returns &quot;false&quot;.  There is one exception: if the current
 524    instruction is a &quot;ret&quot;, returns &quot;false&quot; without calling &quot;jmpFct&quot;.
 525    Arrangements for tracking the control flow of a &quot;ret&quot; must be made
 526    externally. */
 527 bool GenerateOopMap::jump_targets_do(BytecodeStream *bcs, jmpFct_t jmpFct, int *data) {
 528   int bci = bcs-&gt;bci();
 529 
 530   switch (bcs-&gt;code()) {
 531     case Bytecodes::_ifeq:
 532     case Bytecodes::_ifne:
 533     case Bytecodes::_iflt:
 534     case Bytecodes::_ifge:
 535     case Bytecodes::_ifgt:
 536     case Bytecodes::_ifle:
 537     case Bytecodes::_if_icmpeq:
 538     case Bytecodes::_if_icmpne:
 539     case Bytecodes::_if_icmplt:
 540     case Bytecodes::_if_icmpge:
 541     case Bytecodes::_if_icmpgt:
 542     case Bytecodes::_if_icmple:
 543     case Bytecodes::_if_acmpeq:
 544     case Bytecodes::_if_acmpne:
 545     case Bytecodes::_ifnull:
 546     case Bytecodes::_ifnonnull:
 547       (*jmpFct)(this, bcs-&gt;dest(), data);
 548       (*jmpFct)(this, bci + 3, data);
 549       break;
 550 
 551     case Bytecodes::_goto:
 552       (*jmpFct)(this, bcs-&gt;dest(), data);
 553       break;
 554     case Bytecodes::_goto_w:
 555       (*jmpFct)(this, bcs-&gt;dest_w(), data);
 556       break;
 557     case Bytecodes::_tableswitch:
 558       { Bytecode_tableswitch tableswitch(method(), bcs-&gt;bcp());
 559         int len = tableswitch.length();
 560 
 561         (*jmpFct)(this, bci + tableswitch.default_offset(), data); /* Default. jump address */
 562         while (--len &gt;= 0) {
 563           (*jmpFct)(this, bci + tableswitch.dest_offset_at(len), data);
 564         }
 565         break;
 566       }
 567 
 568     case Bytecodes::_lookupswitch:
 569       { Bytecode_lookupswitch lookupswitch(method(), bcs-&gt;bcp());
 570         int npairs = lookupswitch.number_of_pairs();
 571         (*jmpFct)(this, bci + lookupswitch.default_offset(), data); /* Default. */
 572         while(--npairs &gt;= 0) {
 573           LookupswitchPair pair = lookupswitch.pair_at(npairs);
 574           (*jmpFct)(this, bci + pair.offset(), data);
 575         }
 576         break;
 577       }
 578     case Bytecodes::_jsr:
 579       assert(bcs-&gt;is_wide()==false, &quot;sanity check&quot;);
 580       (*jmpFct)(this, bcs-&gt;dest(), data);
 581 
 582 
 583 
 584       break;
 585     case Bytecodes::_jsr_w:
 586       (*jmpFct)(this, bcs-&gt;dest_w(), data);
 587       break;
 588     case Bytecodes::_wide:
 589       ShouldNotReachHere();
 590       return true;
 591       break;
 592     case Bytecodes::_athrow:
 593     case Bytecodes::_ireturn:
 594     case Bytecodes::_lreturn:
 595     case Bytecodes::_freturn:
 596     case Bytecodes::_dreturn:
 597     case Bytecodes::_areturn:
 598     case Bytecodes::_return:
 599     case Bytecodes::_ret:
 600       break;
 601     default:
 602       return true;
 603   }
 604   return false;
 605 }
 606 
 607 /* Requires &quot;pc&quot; to be the head of a basic block; returns that basic
 608    block. */
 609 BasicBlock *GenerateOopMap::get_basic_block_at(int bci) const {
 610   BasicBlock* bb = get_basic_block_containing(bci);
 611   assert(bb-&gt;_bci == bci, &quot;should have found BB&quot;);
 612   return bb;
 613 }
 614 
 615 // Requires &quot;pc&quot; to be the start of an instruction; returns the basic
 616 //   block containing that instruction. */
 617 BasicBlock  *GenerateOopMap::get_basic_block_containing(int bci) const {
 618   BasicBlock *bbs = _basic_blocks;
 619   int lo = 0, hi = _bb_count - 1;
 620 
 621   while (lo &lt;= hi) {
 622     int m = (lo + hi) / 2;
 623     int mbci = bbs[m]._bci;
 624     int nbci;
 625 
 626     if ( m == _bb_count-1) {
 627       assert( bci &gt;= mbci &amp;&amp; bci &lt; method()-&gt;code_size(), &quot;sanity check failed&quot;);
 628       return bbs+m;
 629     } else {
 630       nbci = bbs[m+1]._bci;
 631     }
 632 
 633     if ( mbci &lt;= bci &amp;&amp; bci &lt; nbci) {
 634       return bbs+m;
 635     } else if (mbci &lt; bci) {
 636       lo = m + 1;
 637     } else {
 638       assert(mbci &gt; bci, &quot;sanity check&quot;);
 639       hi = m - 1;
 640     }
 641   }
 642 
 643   fatal(&quot;should have found BB&quot;);
 644   return NULL;
 645 }
 646 
 647 void GenerateOopMap::restore_state(BasicBlock *bb)
 648 {
 649   memcpy(_state, bb-&gt;_state, _state_len*sizeof(CellTypeState));
 650   _stack_top = bb-&gt;_stack_top;
 651   _monitor_top = bb-&gt;_monitor_top;
 652 }
 653 
 654 int GenerateOopMap::next_bb_start_pc(BasicBlock *bb) {
 655  int bbNum = bb - _basic_blocks + 1;
 656  if (bbNum == _bb_count)
 657     return method()-&gt;code_size();
 658 
 659  return _basic_blocks[bbNum]._bci;
 660 }
 661 
 662 //
 663 // CellType handling methods
 664 //
 665 
 666 // Allocate memory and throw LinkageError if failure.
 667 #define ALLOC_RESOURCE_ARRAY(var, type, count) \
 668   var = NEW_RESOURCE_ARRAY_RETURN_NULL(type, count);              \
 669   if (var == NULL) {                                              \
 670     report_error(&quot;Cannot reserve enough memory to analyze this method&quot;); \
 671     return;                                                       \
 672   }
 673 
 674 
 675 void GenerateOopMap::init_state() {
 676   _state_len     = _max_locals + _max_stack + _max_monitors;
 677   ALLOC_RESOURCE_ARRAY(_state, CellTypeState, _state_len);
 678   memset(_state, 0, _state_len * sizeof(CellTypeState));
 679   int count = MAX3(_max_locals, _max_stack, _max_monitors) + 1/*for null terminator char */;
 680   ALLOC_RESOURCE_ARRAY(_state_vec_buf, char, count);
 681 }
 682 
 683 void GenerateOopMap::make_context_uninitialized() {
 684   CellTypeState* vs = vars();
 685 
 686   for (int i = 0; i &lt; _max_locals; i++)
 687       vs[i] = CellTypeState::uninit;
 688 
 689   _stack_top = 0;
 690   _monitor_top = 0;
 691 }
 692 
 693 int GenerateOopMap::methodsig_to_effect(Symbol* signature, bool is_static, CellTypeState* effect) {
 694   ComputeEntryStack ces(signature);
 695   return ces.compute_for_parameters(is_static, effect);
 696 }
 697 
 698 // Return result of merging cts1 and cts2.
 699 CellTypeState CellTypeState::merge(CellTypeState cts, int slot) const {
 700   CellTypeState result;
 701 
 702   assert(!is_bottom() &amp;&amp; !cts.is_bottom(),
 703          &quot;merge of bottom values is handled elsewhere&quot;);
 704 
 705   result._state = _state | cts._state;
 706 
 707   // If the top bit is set, we don&#39;t need to do any more work.
 708   if (!result.is_info_top()) {
 709     assert((result.can_be_address() || result.can_be_reference()),
 710            &quot;only addresses and references have non-top info&quot;);
 711 
 712     if (!equal(cts)) {
 713       // The two values being merged are different.  Raise to top.
 714       if (result.is_reference()) {
 715         result = CellTypeState::make_slot_ref(slot);
 716       } else {
 717         result._state |= info_conflict;
 718       }
 719     }
 720   }
 721   assert(result.is_valid_state(), &quot;checking that CTS merge maintains legal state&quot;);
 722 
 723   return result;
 724 }
 725 
 726 // Merge the variable state for locals and stack from cts into bbts.
 727 bool GenerateOopMap::merge_local_state_vectors(CellTypeState* cts,
 728                                                CellTypeState* bbts) {
 729   int i;
 730   int len = _max_locals + _stack_top;
 731   bool change = false;
 732 
 733   for (i = len - 1; i &gt;= 0; i--) {
 734     CellTypeState v = cts[i].merge(bbts[i], i);
 735     change = change || !v.equal(bbts[i]);
 736     bbts[i] = v;
 737   }
 738 
 739   return change;
 740 }
 741 
 742 // Merge the monitor stack state from cts into bbts.
 743 bool GenerateOopMap::merge_monitor_state_vectors(CellTypeState* cts,
 744                                                  CellTypeState* bbts) {
 745   bool change = false;
 746   if (_max_monitors &gt; 0 &amp;&amp; _monitor_top != bad_monitors) {
 747     // If there are no monitors in the program, or there has been
 748     // a monitor matching error before this point in the program,
 749     // then we do not merge in the monitor state.
 750 
 751     int base = _max_locals + _max_stack;
 752     int len = base + _monitor_top;
 753     for (int i = len - 1; i &gt;= base; i--) {
 754       CellTypeState v = cts[i].merge(bbts[i], i);
 755 
 756       // Can we prove that, when there has been a change, it will already
 757       // have been detected at this point?  That would make this equal
 758       // check here unnecessary.
 759       change = change || !v.equal(bbts[i]);
 760       bbts[i] = v;
 761     }
 762   }
 763 
 764   return change;
 765 }
 766 
 767 void GenerateOopMap::copy_state(CellTypeState *dst, CellTypeState *src) {
 768   int len = _max_locals + _stack_top;
 769   for (int i = 0; i &lt; len; i++) {
 770     if (src[i].is_nonlock_reference()) {
 771       dst[i] = CellTypeState::make_slot_ref(i);
 772     } else {
 773       dst[i] = src[i];
 774     }
 775   }
 776   if (_max_monitors &gt; 0 &amp;&amp; _monitor_top != bad_monitors) {
 777     int base = _max_locals + _max_stack;
 778     len = base + _monitor_top;
 779     for (int i = base; i &lt; len; i++) {
 780       dst[i] = src[i];
 781     }
 782   }
 783 }
 784 
 785 
 786 // Merge the states for the current block and the next.  As long as a
 787 // block is reachable the locals and stack must be merged.  If the
 788 // stack heights don&#39;t match then this is a verification error and
 789 // it&#39;s impossible to interpret the code.  Simultaneously monitor
 790 // states are being check to see if they nest statically.  If monitor
 791 // depths match up then their states are merged.  Otherwise the
 792 // mismatch is simply recorded and interpretation continues since
 793 // monitor matching is purely informational and doesn&#39;t say anything
 794 // about the correctness of the code.
 795 void GenerateOopMap::merge_state_into_bb(BasicBlock *bb) {
 796   guarantee(bb != NULL, &quot;null basicblock&quot;);
 797   assert(bb-&gt;is_alive(), &quot;merging state into a dead basicblock&quot;);
 798 
 799   if (_stack_top == bb-&gt;_stack_top) {
 800     // always merge local state even if monitors don&#39;t match.
 801     if (merge_local_state_vectors(_state, bb-&gt;_state)) {
 802       bb-&gt;set_changed(true);
 803     }
 804     if (_monitor_top == bb-&gt;_monitor_top) {
 805       // monitors still match so continue merging monitor states.
 806       if (merge_monitor_state_vectors(_state, bb-&gt;_state)) {
 807         bb-&gt;set_changed(true);
 808       }
 809     } else {
 810       if (log_is_enabled(Info, monitormismatch)) {
 811         report_monitor_mismatch(&quot;monitor stack height merge conflict&quot;);
 812       }
 813       // When the monitor stacks are not matched, we set _monitor_top to
 814       // bad_monitors.  This signals that, from here on, the monitor stack cannot
 815       // be trusted.  In particular, monitorexit bytecodes may throw
 816       // exceptions.  We mark this block as changed so that the change
 817       // propagates properly.
 818       bb-&gt;_monitor_top = bad_monitors;
 819       bb-&gt;set_changed(true);
 820       _monitor_safe = false;
 821     }
 822   } else if (!bb-&gt;is_reachable()) {
 823     // First time we look at this  BB
 824     copy_state(bb-&gt;_state, _state);
 825     bb-&gt;_stack_top = _stack_top;
 826     bb-&gt;_monitor_top = _monitor_top;
 827     bb-&gt;set_changed(true);
 828   } else {
 829     verify_error(&quot;stack height conflict: %d vs. %d&quot;,  _stack_top, bb-&gt;_stack_top);
 830   }
 831 }
 832 
 833 void GenerateOopMap::merge_state(GenerateOopMap *gom, int bci, int* data) {
 834    gom-&gt;merge_state_into_bb(gom-&gt;get_basic_block_at(bci));
 835 }
 836 
 837 void GenerateOopMap::set_var(int localNo, CellTypeState cts) {
 838   assert(cts.is_reference() || cts.is_value() || cts.is_address(),
 839          &quot;wrong celltypestate&quot;);
 840   if (localNo &lt; 0 || localNo &gt; _max_locals) {
 841     verify_error(&quot;variable write error: r%d&quot;, localNo);
 842     return;
 843   }
 844   vars()[localNo] = cts;
 845 }
 846 
 847 CellTypeState GenerateOopMap::get_var(int localNo) {
 848   assert(localNo &lt; _max_locals + _nof_refval_conflicts, &quot;variable read error&quot;);
 849   if (localNo &lt; 0 || localNo &gt; _max_locals) {
 850     verify_error(&quot;variable read error: r%d&quot;, localNo);
 851     return valCTS; // just to pick something;
 852   }
 853   return vars()[localNo];
 854 }
 855 
 856 CellTypeState GenerateOopMap::pop() {
 857   if ( _stack_top &lt;= 0) {
 858     verify_error(&quot;stack underflow&quot;);
 859     return valCTS; // just to pick something
 860   }
 861   return  stack()[--_stack_top];
 862 }
 863 
 864 void GenerateOopMap::push(CellTypeState cts) {
 865   if ( _stack_top &gt;= _max_stack) {
 866     verify_error(&quot;stack overflow&quot;);
 867     return;
 868   }
 869   stack()[_stack_top++] = cts;
 870 }
 871 
 872 CellTypeState GenerateOopMap::monitor_pop() {
 873   assert(_monitor_top != bad_monitors, &quot;monitor_pop called on error monitor stack&quot;);
 874   if (_monitor_top == 0) {
 875     // We have detected a pop of an empty monitor stack.
 876     _monitor_safe = false;
 877      _monitor_top = bad_monitors;
 878 
 879     if (log_is_enabled(Info, monitormismatch)) {
 880       report_monitor_mismatch(&quot;monitor stack underflow&quot;);
 881     }
 882     return CellTypeState::ref; // just to keep the analysis going.
 883   }
 884   return  monitors()[--_monitor_top];
 885 }
 886 
 887 void GenerateOopMap::monitor_push(CellTypeState cts) {
 888   assert(_monitor_top != bad_monitors, &quot;monitor_push called on error monitor stack&quot;);
 889   if (_monitor_top &gt;= _max_monitors) {
 890     // Some monitorenter is being executed more than once.
 891     // This means that the monitor stack cannot be simulated.
 892     _monitor_safe = false;
 893     _monitor_top = bad_monitors;
 894 
 895     if (log_is_enabled(Info, monitormismatch)) {
 896       report_monitor_mismatch(&quot;monitor stack overflow&quot;);
 897     }
 898     return;
 899   }
 900   monitors()[_monitor_top++] = cts;
 901 }
 902 
 903 //
 904 // Interpretation handling methods
 905 //
 906 
 907 void GenerateOopMap::do_interpretation()
 908 {
 909   // &quot;i&quot; is just for debugging, so we can detect cases where this loop is
 910   // iterated more than once.
 911   int i = 0;
 912   do {
 913 #ifndef PRODUCT
 914     if (TraceNewOopMapGeneration) {
 915       tty-&gt;print(&quot;\n\nIteration #%d of do_interpretation loop, method:\n&quot;, i);
 916       method()-&gt;print_name(tty);
 917       tty-&gt;print(&quot;\n\n&quot;);
 918     }
 919 #endif
 920     _conflict = false;
 921     _monitor_safe = true;
 922     // init_state is now called from init_basic_blocks.  The length of a
 923     // state vector cannot be determined until we have made a pass through
 924     // the bytecodes counting the possible monitor entries.
 925     if (!_got_error) init_basic_blocks();
 926     if (!_got_error) setup_method_entry_state();
 927     if (!_got_error) interp_all();
 928     if (!_got_error) rewrite_refval_conflicts();
 929     i++;
 930   } while (_conflict &amp;&amp; !_got_error);
 931 }
 932 
 933 void GenerateOopMap::init_basic_blocks() {
 934   // Note: Could consider reserving only the needed space for each BB&#39;s state
 935   // (entry stack may not be of maximal height for every basic block).
 936   // But cumbersome since we don&#39;t know the stack heights yet.  (Nor the
 937   // monitor stack heights...)
 938 
 939   ALLOC_RESOURCE_ARRAY(_basic_blocks, BasicBlock, _bb_count);
 940 
 941   // Make a pass through the bytecodes.  Count the number of monitorenters.
 942   // This can be used an upper bound on the monitor stack depth in programs
 943   // which obey stack discipline with their monitor usage.  Initialize the
 944   // known information about basic blocks.
 945   BytecodeStream j(_method);
 946   Bytecodes::Code bytecode;
 947 
 948   int bbNo = 0;
 949   int monitor_count = 0;
 950   int prev_bci = -1;
 951   while( (bytecode = j.next()) &gt;= 0) {
 952     if (j.code() == Bytecodes::_monitorenter) {
 953       monitor_count++;
 954     }
 955 
 956     int bci = j.bci();
 957     if (is_bb_header(bci)) {
 958       // Initialize the basicblock structure
 959       BasicBlock *bb   = _basic_blocks + bbNo;
 960       bb-&gt;_bci         = bci;
 961       bb-&gt;_max_locals  = _max_locals;
 962       bb-&gt;_max_stack   = _max_stack;
 963       bb-&gt;set_changed(false);
 964       bb-&gt;_stack_top   = BasicBlock::_dead_basic_block; // Initialize all basicblocks are dead.
 965       bb-&gt;_monitor_top = bad_monitors;
 966 
 967       if (bbNo &gt; 0) {
 968         _basic_blocks[bbNo - 1]._end_bci = prev_bci;
 969       }
 970 
 971       bbNo++;
 972     }
 973     // Remember prevous bci.
 974     prev_bci = bci;
 975   }
 976   // Set
 977   _basic_blocks[bbNo-1]._end_bci = prev_bci;
 978 
 979 
 980   // Check that the correct number of basicblocks was found
 981   if (bbNo !=_bb_count) {
 982     if (bbNo &lt; _bb_count) {
 983       verify_error(&quot;jump into the middle of instruction?&quot;);
 984       return;
 985     } else {
 986       verify_error(&quot;extra basic blocks - should not happen?&quot;);
 987       return;
 988     }
 989   }
 990 
 991   _max_monitors = monitor_count;
 992 
 993   // Now that we have a bound on the depth of the monitor stack, we can
 994   // initialize the CellTypeState-related information.
 995   init_state();
 996 
 997   // We allocate space for all state-vectors for all basicblocks in one huge
 998   // chunk.  Then in the next part of the code, we set a pointer in each
 999   // _basic_block that points to each piece.
1000 
1001   // The product of bbNo and _state_len can get large if there are lots of
1002   // basic blocks and stack/locals/monitors.  Need to check to make sure
1003   // we don&#39;t overflow the capacity of a pointer.
1004   if ((unsigned)bbNo &gt; UINTPTR_MAX / sizeof(CellTypeState) / _state_len) {
1005     report_error(&quot;The amount of memory required to analyze this method &quot;
1006                  &quot;exceeds addressable range&quot;);
1007     return;
1008   }
1009 
1010   CellTypeState *basicBlockState;
1011   ALLOC_RESOURCE_ARRAY(basicBlockState, CellTypeState, bbNo * _state_len);
1012   memset(basicBlockState, 0, bbNo * _state_len * sizeof(CellTypeState));
1013 
1014   // Make a pass over the basicblocks and assign their state vectors.
1015   for (int blockNum=0; blockNum &lt; bbNo; blockNum++) {
1016     BasicBlock *bb = _basic_blocks + blockNum;
1017     bb-&gt;_state = basicBlockState + blockNum * _state_len;
1018 
1019 #ifdef ASSERT
1020     if (blockNum + 1 &lt; bbNo) {
1021       address bcp = _method-&gt;bcp_from(bb-&gt;_end_bci);
1022       int bc_len = Bytecodes::java_length_at(_method(), bcp);
1023       assert(bb-&gt;_end_bci + bc_len == bb[1]._bci, &quot;unmatched bci info in basicblock&quot;);
1024     }
1025 #endif
1026   }
1027 #ifdef ASSERT
1028   { BasicBlock *bb = &amp;_basic_blocks[bbNo-1];
1029     address bcp = _method-&gt;bcp_from(bb-&gt;_end_bci);
1030     int bc_len = Bytecodes::java_length_at(_method(), bcp);
1031     assert(bb-&gt;_end_bci + bc_len == _method-&gt;code_size(), &quot;wrong end bci&quot;);
1032   }
1033 #endif
1034 
1035   // Mark all alive blocks
1036   mark_reachable_code();
1037 }
1038 
1039 void GenerateOopMap::setup_method_entry_state() {
1040 
1041     // Initialize all locals to &#39;uninit&#39; and set stack-height to 0
1042     make_context_uninitialized();
1043 
1044     // Initialize CellState type of arguments
1045     methodsig_to_effect(method()-&gt;signature(), method()-&gt;is_static(), vars());
1046 
1047     // If some references must be pre-assigned to null, then set that up
1048     initialize_vars();
1049 
1050     // This is the start state
1051     merge_state_into_bb(&amp;_basic_blocks[0]);
1052 
1053     assert(_basic_blocks[0].changed(), &quot;we are not getting off the ground&quot;);
1054 }
1055 
1056 // The instruction at bci is changing size by &quot;delta&quot;.  Update the basic blocks.
1057 void GenerateOopMap::update_basic_blocks(int bci, int delta,
1058                                          int new_method_size) {
1059   assert(new_method_size &gt;= method()-&gt;code_size() + delta,
1060          &quot;new method size is too small&quot;);
1061 
1062   _bb_hdr_bits.reinitialize(new_method_size);
1063 
1064   for(int k = 0; k &lt; _bb_count; k++) {
1065     if (_basic_blocks[k]._bci &gt; bci) {
1066       _basic_blocks[k]._bci     += delta;
1067       _basic_blocks[k]._end_bci += delta;
1068     }
1069     _bb_hdr_bits.at_put(_basic_blocks[k]._bci, true);
1070   }
1071 }
1072 
1073 //
1074 // Initvars handling
1075 //
1076 
1077 void GenerateOopMap::initialize_vars() {
1078   for (int k = 0; k &lt; _init_vars-&gt;length(); k++)
1079     _state[_init_vars-&gt;at(k)] = CellTypeState::make_slot_ref(k);
1080 }
1081 
1082 void GenerateOopMap::add_to_ref_init_set(int localNo) {
1083 
1084   if (TraceNewOopMapGeneration)
1085     tty-&gt;print_cr(&quot;Added init vars: %d&quot;, localNo);
1086 
1087   // Is it already in the set?
1088   if (_init_vars-&gt;contains(localNo) )
1089     return;
1090 
1091    _init_vars-&gt;append(localNo);
1092 }
1093 
1094 //
1095 // Interpreration code
1096 //
1097 
1098 void GenerateOopMap::interp_all() {
1099   bool change = true;
1100 
1101   while (change &amp;&amp; !_got_error) {
1102     change = false;
1103     for (int i = 0; i &lt; _bb_count &amp;&amp; !_got_error; i++) {
1104       BasicBlock *bb = &amp;_basic_blocks[i];
1105       if (bb-&gt;changed()) {
1106          if (_got_error) return;
1107          change = true;
1108          bb-&gt;set_changed(false);
1109          interp_bb(bb);
1110       }
1111     }
1112   }
1113 }
1114 
1115 void GenerateOopMap::interp_bb(BasicBlock *bb) {
1116 
1117   // We do not want to do anything in case the basic-block has not been initialized. This
1118   // will happen in the case where there is dead-code hang around in a method.
1119   assert(bb-&gt;is_reachable(), &quot;should be reachable or deadcode exist&quot;);
1120   restore_state(bb);
1121 
1122   BytecodeStream itr(_method);
1123 
1124   // Set iterator interval to be the current basicblock
1125   int lim_bci = next_bb_start_pc(bb);
1126   itr.set_interval(bb-&gt;_bci, lim_bci);
1127   assert(lim_bci != bb-&gt;_bci, &quot;must be at least one instruction in a basicblock&quot;);
1128   itr.next(); // read first instruction
1129 
1130   // Iterates through all bytecodes except the last in a basic block.
1131   // We handle the last one special, since there is controlflow change.
1132   while(itr.next_bci() &lt; lim_bci &amp;&amp; !_got_error) {
1133     if (_has_exceptions || _monitor_top != 0) {
1134       // We do not need to interpret the results of exceptional
1135       // continuation from this instruction when the method has no
1136       // exception handlers and the monitor stack is currently
1137       // empty.
1138       do_exception_edge(&amp;itr);
1139     }
1140     interp1(&amp;itr);
1141     itr.next();
1142   }
1143 
1144   // Handle last instruction.
1145   if (!_got_error) {
1146     assert(itr.next_bci() == lim_bci, &quot;must point to end&quot;);
1147     if (_has_exceptions || _monitor_top != 0) {
1148       do_exception_edge(&amp;itr);
1149     }
1150     interp1(&amp;itr);
1151 
1152     bool fall_through = jump_targets_do(&amp;itr, GenerateOopMap::merge_state, NULL);
1153     if (_got_error)  return;
1154 
1155     if (itr.code() == Bytecodes::_ret) {
1156       assert(!fall_through, &quot;cannot be set if ret instruction&quot;);
1157       // Automatically handles &#39;wide&#39; ret indicies
1158       ret_jump_targets_do(&amp;itr, GenerateOopMap::merge_state, itr.get_index(), NULL);
1159     } else if (fall_through) {
1160      // Hit end of BB, but the instr. was a fall-through instruction,
1161      // so perform transition as if the BB ended in a &quot;jump&quot;.
1162      if (lim_bci != bb[1]._bci) {
1163        verify_error(&quot;bytecodes fell through last instruction&quot;);
1164        return;
1165      }
1166      merge_state_into_bb(bb + 1);
1167     }
1168   }
1169 }
1170 
1171 void GenerateOopMap::do_exception_edge(BytecodeStream* itr) {
1172   // Only check exception edge, if bytecode can trap
1173   if (!Bytecodes::can_trap(itr-&gt;code())) return;
1174   switch (itr-&gt;code()) {
1175     case Bytecodes::_aload_0:
1176       // These bytecodes can trap for rewriting.  We need to assume that
1177       // they do not throw exceptions to make the monitor analysis work.
1178       return;
1179 
1180     case Bytecodes::_ireturn:
1181     case Bytecodes::_lreturn:
1182     case Bytecodes::_freturn:
1183     case Bytecodes::_dreturn:
1184     case Bytecodes::_areturn:
1185     case Bytecodes::_return:
1186       // If the monitor stack height is not zero when we leave the method,
1187       // then we are either exiting with a non-empty stack or we have
1188       // found monitor trouble earlier in our analysis.  In either case,
1189       // assume an exception could be taken here.
1190       if (_monitor_top == 0) {
1191         return;
1192       }
1193       break;
1194 
1195     case Bytecodes::_monitorexit:
1196       // If the monitor stack height is bad_monitors, then we have detected a
1197       // monitor matching problem earlier in the analysis.  If the
1198       // monitor stack height is 0, we are about to pop a monitor
1199       // off of an empty stack.  In either case, the bytecode
1200       // could throw an exception.
1201       if (_monitor_top != bad_monitors &amp;&amp; _monitor_top != 0) {
1202         return;
1203       }
1204       break;
1205 
1206     default:
1207       break;
1208   }
1209 
1210   if (_has_exceptions) {
1211     int bci = itr-&gt;bci();
1212     ExceptionTable exct(method());
1213     for(int i = 0; i&lt; exct.length(); i++) {
1214       int start_pc   = exct.start_pc(i);
1215       int end_pc     = exct.end_pc(i);
1216       int handler_pc = exct.handler_pc(i);
1217       int catch_type = exct.catch_type_index(i);
1218 
1219       if (start_pc &lt;= bci &amp;&amp; bci &lt; end_pc) {
1220         BasicBlock *excBB = get_basic_block_at(handler_pc);
1221         guarantee(excBB != NULL, &quot;no basic block for exception&quot;);
1222         CellTypeState *excStk = excBB-&gt;stack();
1223         CellTypeState *cOpStck = stack();
1224         CellTypeState cOpStck_0 = cOpStck[0];
1225         int cOpStackTop = _stack_top;
1226 
1227         // Exception stacks are always the same.
1228         assert(method()-&gt;max_stack() &gt; 0, &quot;sanity check&quot;);
1229 
1230         // We remembered the size and first element of &quot;cOpStck&quot;
1231         // above; now we temporarily set them to the appropriate
1232         // values for an exception handler. */
1233         cOpStck[0] = CellTypeState::make_slot_ref(_max_locals);
1234         _stack_top = 1;
1235 
1236         merge_state_into_bb(excBB);
1237 
1238         // Now undo the temporary change.
1239         cOpStck[0] = cOpStck_0;
1240         _stack_top = cOpStackTop;
1241 
1242         // If this is a &quot;catch all&quot; handler, then we do not need to
1243         // consider any additional handlers.
1244         if (catch_type == 0) {
1245           return;
1246         }
1247       }
1248     }
1249   }
1250 
1251   // It is possible that none of the exception handlers would have caught
1252   // the exception.  In this case, we will exit the method.  We must
1253   // ensure that the monitor stack is empty in this case.
1254   if (_monitor_top == 0) {
1255     return;
1256   }
1257 
1258   // We pessimistically assume that this exception can escape the
1259   // method. (It is possible that it will always be caught, but
1260   // we don&#39;t care to analyse the types of the catch clauses.)
1261 
1262   // We don&#39;t set _monitor_top to bad_monitors because there are no successors
1263   // to this exceptional exit.
1264 
1265   if (log_is_enabled(Info, monitormismatch) &amp;&amp; _monitor_safe) {
1266     // We check _monitor_safe so that we only report the first mismatched
1267     // exceptional exit.
1268     report_monitor_mismatch(&quot;non-empty monitor stack at exceptional exit&quot;);
1269   }
1270   _monitor_safe = false;
1271 
1272 }
1273 
1274 void GenerateOopMap::report_monitor_mismatch(const char *msg) {
1275   ResourceMark rm;
1276   LogStream ls(Log(monitormismatch)::info());
1277   ls.print(&quot;Monitor mismatch in method &quot;);
1278   method()-&gt;print_short_name(&amp;ls);
1279   ls.print_cr(&quot;: %s&quot;, msg);
1280 }
1281 
1282 void GenerateOopMap::print_states(outputStream *os,
1283                                   CellTypeState* vec, int num) {
1284   for (int i = 0; i &lt; num; i++) {
1285     vec[i].print(tty);
1286   }
1287 }
1288 
1289 // Print the state values at the current bytecode.
1290 void GenerateOopMap::print_current_state(outputStream   *os,
1291                                          BytecodeStream *currentBC,
1292                                          bool            detailed) {
1293   if (detailed) {
1294     os-&gt;print(&quot;     %4d vars     = &quot;, currentBC-&gt;bci());
1295     print_states(os, vars(), _max_locals);
1296     os-&gt;print(&quot;    %s&quot;, Bytecodes::name(currentBC-&gt;code()));
1297   } else {
1298     os-&gt;print(&quot;    %4d  vars = &#39;%s&#39; &quot;, currentBC-&gt;bci(),  state_vec_to_string(vars(), _max_locals));
1299     os-&gt;print(&quot;     stack = &#39;%s&#39; &quot;, state_vec_to_string(stack(), _stack_top));
1300     if (_monitor_top != bad_monitors) {
1301       os-&gt;print(&quot;  monitors = &#39;%s&#39;  \t%s&quot;, state_vec_to_string(monitors(), _monitor_top), Bytecodes::name(currentBC-&gt;code()));
1302     } else {
1303       os-&gt;print(&quot;  [bad monitor stack]&quot;);
1304     }
1305   }
1306 
1307   switch(currentBC-&gt;code()) {
1308     case Bytecodes::_invokevirtual:
1309     case Bytecodes::_invokespecial:
1310     case Bytecodes::_invokestatic:
1311     case Bytecodes::_invokedynamic:
1312     case Bytecodes::_invokeinterface: {
1313       int idx = currentBC-&gt;has_index_u4() ? currentBC-&gt;get_index_u4() : currentBC-&gt;get_index_u2_cpcache();
1314       ConstantPool* cp      = method()-&gt;constants();
1315       int nameAndTypeIdx    = cp-&gt;name_and_type_ref_index_at(idx);
1316       int signatureIdx      = cp-&gt;signature_ref_index_at(nameAndTypeIdx);
1317       Symbol* signature     = cp-&gt;symbol_at(signatureIdx);
1318       os-&gt;print(&quot;%s&quot;, signature-&gt;as_C_string());
1319     }
1320     default:
1321       break;
1322   }
1323 
1324   if (detailed) {
1325     os-&gt;cr();
1326     os-&gt;print(&quot;          stack    = &quot;);
1327     print_states(os, stack(), _stack_top);
1328     os-&gt;cr();
1329     if (_monitor_top != bad_monitors) {
1330       os-&gt;print(&quot;          monitors = &quot;);
1331       print_states(os, monitors(), _monitor_top);
1332     } else {
1333       os-&gt;print(&quot;          [bad monitor stack]&quot;);
1334     }
1335   }
1336 
1337   os-&gt;cr();
1338 }
1339 
1340 // Sets the current state to be the state after executing the
1341 // current instruction, starting in the current state.
1342 void GenerateOopMap::interp1(BytecodeStream *itr) {
1343   if (TraceNewOopMapGeneration) {
1344     print_current_state(tty, itr, TraceNewOopMapGenerationDetailed);
1345   }
1346 
1347   // Should we report the results? Result is reported *before* the instruction at the current bci is executed.
1348   // However, not for calls. For calls we do not want to include the arguments, so we postpone the reporting until
1349   // they have been popped (in method ppl).
1350   if (_report_result == true) {
1351     switch(itr-&gt;code()) {
1352       case Bytecodes::_invokevirtual:
1353       case Bytecodes::_invokespecial:
1354       case Bytecodes::_invokestatic:
1355       case Bytecodes::_invokedynamic:
1356       case Bytecodes::_invokeinterface:
1357         _itr_send = itr;
1358         _report_result_for_send = true;
1359         break;
1360       default:
1361        fill_stackmap_for_opcodes(itr, vars(), stack(), _stack_top);
1362        break;
1363     }
1364   }
1365 
1366   // abstract interpretation of current opcode
1367   switch(itr-&gt;code()) {
1368     case Bytecodes::_nop:                                           break;
1369     case Bytecodes::_goto:                                          break;
1370     case Bytecodes::_goto_w:                                        break;
1371     case Bytecodes::_iinc:                                          break;
1372     case Bytecodes::_return:            do_return_monitor_check();
1373                                         break;
1374 
1375     case Bytecodes::_aconst_null:
1376     case Bytecodes::_new:               ppush1(CellTypeState::make_line_ref(itr-&gt;bci()));
1377                                         break;
1378 
1379     case Bytecodes::_iconst_m1:
1380     case Bytecodes::_iconst_0:
1381     case Bytecodes::_iconst_1:
1382     case Bytecodes::_iconst_2:
1383     case Bytecodes::_iconst_3:
1384     case Bytecodes::_iconst_4:
1385     case Bytecodes::_iconst_5:
1386     case Bytecodes::_fconst_0:
1387     case Bytecodes::_fconst_1:
1388     case Bytecodes::_fconst_2:
1389     case Bytecodes::_bipush:
1390     case Bytecodes::_sipush:            ppush1(valCTS);             break;
1391 
1392     case Bytecodes::_lconst_0:
1393     case Bytecodes::_lconst_1:
1394     case Bytecodes::_dconst_0:
1395     case Bytecodes::_dconst_1:          ppush(vvCTS);               break;
1396 
1397     case Bytecodes::_ldc2_w:            ppush(vvCTS);               break;
1398 
1399     case Bytecodes::_ldc:               // fall through:
1400     case Bytecodes::_ldc_w:             do_ldc(itr-&gt;bci());         break;
1401 
1402     case Bytecodes::_iload:
1403     case Bytecodes::_fload:             ppload(vCTS, itr-&gt;get_index()); break;
1404 
1405     case Bytecodes::_lload:
1406     case Bytecodes::_dload:             ppload(vvCTS,itr-&gt;get_index()); break;
1407 
1408     case Bytecodes::_aload:             ppload(rCTS, itr-&gt;get_index()); break;
1409 
1410     case Bytecodes::_iload_0:
1411     case Bytecodes::_fload_0:           ppload(vCTS, 0);            break;
1412     case Bytecodes::_iload_1:
1413     case Bytecodes::_fload_1:           ppload(vCTS, 1);            break;
1414     case Bytecodes::_iload_2:
1415     case Bytecodes::_fload_2:           ppload(vCTS, 2);            break;
1416     case Bytecodes::_iload_3:
1417     case Bytecodes::_fload_3:           ppload(vCTS, 3);            break;
1418 
1419     case Bytecodes::_lload_0:
1420     case Bytecodes::_dload_0:           ppload(vvCTS, 0);           break;
1421     case Bytecodes::_lload_1:
1422     case Bytecodes::_dload_1:           ppload(vvCTS, 1);           break;
1423     case Bytecodes::_lload_2:
1424     case Bytecodes::_dload_2:           ppload(vvCTS, 2);           break;
1425     case Bytecodes::_lload_3:
1426     case Bytecodes::_dload_3:           ppload(vvCTS, 3);           break;
1427 
1428     case Bytecodes::_aload_0:           ppload(rCTS, 0);            break;
1429     case Bytecodes::_aload_1:           ppload(rCTS, 1);            break;
1430     case Bytecodes::_aload_2:           ppload(rCTS, 2);            break;
1431     case Bytecodes::_aload_3:           ppload(rCTS, 3);            break;
1432 
1433     case Bytecodes::_iaload:
1434     case Bytecodes::_faload:
1435     case Bytecodes::_baload:
1436     case Bytecodes::_caload:
1437     case Bytecodes::_saload:            pp(vrCTS, vCTS); break;
1438 
1439     case Bytecodes::_laload:            pp(vrCTS, vvCTS);  break;
1440     case Bytecodes::_daload:            pp(vrCTS, vvCTS); break;
1441 
1442     case Bytecodes::_aaload:            pp_new_ref(vrCTS, itr-&gt;bci()); break;
1443 
1444     case Bytecodes::_istore:
1445     case Bytecodes::_fstore:            ppstore(vCTS, itr-&gt;get_index()); break;
1446 
1447     case Bytecodes::_lstore:
1448     case Bytecodes::_dstore:            ppstore(vvCTS, itr-&gt;get_index()); break;
1449 
1450     case Bytecodes::_astore:            do_astore(itr-&gt;get_index());     break;
1451 
1452     case Bytecodes::_istore_0:
1453     case Bytecodes::_fstore_0:          ppstore(vCTS, 0);           break;
1454     case Bytecodes::_istore_1:
1455     case Bytecodes::_fstore_1:          ppstore(vCTS, 1);           break;
1456     case Bytecodes::_istore_2:
1457     case Bytecodes::_fstore_2:          ppstore(vCTS, 2);           break;
1458     case Bytecodes::_istore_3:
1459     case Bytecodes::_fstore_3:          ppstore(vCTS, 3);           break;
1460 
1461     case Bytecodes::_lstore_0:
1462     case Bytecodes::_dstore_0:          ppstore(vvCTS, 0);          break;
1463     case Bytecodes::_lstore_1:
1464     case Bytecodes::_dstore_1:          ppstore(vvCTS, 1);          break;
1465     case Bytecodes::_lstore_2:
1466     case Bytecodes::_dstore_2:          ppstore(vvCTS, 2);          break;
1467     case Bytecodes::_lstore_3:
1468     case Bytecodes::_dstore_3:          ppstore(vvCTS, 3);          break;
1469 
1470     case Bytecodes::_astore_0:          do_astore(0);               break;
1471     case Bytecodes::_astore_1:          do_astore(1);               break;
1472     case Bytecodes::_astore_2:          do_astore(2);               break;
1473     case Bytecodes::_astore_3:          do_astore(3);               break;
1474 
1475     case Bytecodes::_iastore:
1476     case Bytecodes::_fastore:
1477     case Bytecodes::_bastore:
1478     case Bytecodes::_castore:
1479     case Bytecodes::_sastore:           ppop(vvrCTS);               break;
1480     case Bytecodes::_lastore:
1481     case Bytecodes::_dastore:           ppop(vvvrCTS);              break;
1482     case Bytecodes::_aastore:           ppop(rvrCTS);               break;
1483 
1484     case Bytecodes::_pop:               ppop_any(1);                break;
1485     case Bytecodes::_pop2:              ppop_any(2);                break;
1486 
1487     case Bytecodes::_dup:               ppdupswap(1, &quot;11&quot;);         break;
1488     case Bytecodes::_dup_x1:            ppdupswap(2, &quot;121&quot;);        break;
1489     case Bytecodes::_dup_x2:            ppdupswap(3, &quot;1321&quot;);       break;
1490     case Bytecodes::_dup2:              ppdupswap(2, &quot;2121&quot;);       break;
1491     case Bytecodes::_dup2_x1:           ppdupswap(3, &quot;21321&quot;);      break;
1492     case Bytecodes::_dup2_x2:           ppdupswap(4, &quot;214321&quot;);     break;
1493     case Bytecodes::_swap:              ppdupswap(2, &quot;12&quot;);         break;
1494 
1495     case Bytecodes::_iadd:
1496     case Bytecodes::_fadd:
1497     case Bytecodes::_isub:
1498     case Bytecodes::_fsub:
1499     case Bytecodes::_imul:
1500     case Bytecodes::_fmul:
1501     case Bytecodes::_idiv:
1502     case Bytecodes::_fdiv:
1503     case Bytecodes::_irem:
1504     case Bytecodes::_frem:
1505     case Bytecodes::_ishl:
1506     case Bytecodes::_ishr:
1507     case Bytecodes::_iushr:
1508     case Bytecodes::_iand:
1509     case Bytecodes::_ior:
1510     case Bytecodes::_ixor:
1511     case Bytecodes::_l2f:
1512     case Bytecodes::_l2i:
1513     case Bytecodes::_d2f:
1514     case Bytecodes::_d2i:
1515     case Bytecodes::_fcmpl:
1516     case Bytecodes::_fcmpg:             pp(vvCTS, vCTS); break;
1517 
1518     case Bytecodes::_ladd:
1519     case Bytecodes::_dadd:
1520     case Bytecodes::_lsub:
1521     case Bytecodes::_dsub:
1522     case Bytecodes::_lmul:
1523     case Bytecodes::_dmul:
1524     case Bytecodes::_ldiv:
1525     case Bytecodes::_ddiv:
1526     case Bytecodes::_lrem:
1527     case Bytecodes::_drem:
1528     case Bytecodes::_land:
1529     case Bytecodes::_lor:
1530     case Bytecodes::_lxor:              pp(vvvvCTS, vvCTS); break;
1531 
1532     case Bytecodes::_ineg:
1533     case Bytecodes::_fneg:
1534     case Bytecodes::_i2f:
1535     case Bytecodes::_f2i:
1536     case Bytecodes::_i2c:
1537     case Bytecodes::_i2s:
1538     case Bytecodes::_i2b:               pp(vCTS, vCTS); break;
1539 
1540     case Bytecodes::_lneg:
1541     case Bytecodes::_dneg:
1542     case Bytecodes::_l2d:
1543     case Bytecodes::_d2l:               pp(vvCTS, vvCTS); break;
1544 
1545     case Bytecodes::_lshl:
1546     case Bytecodes::_lshr:
1547     case Bytecodes::_lushr:             pp(vvvCTS, vvCTS); break;
1548 
1549     case Bytecodes::_i2l:
1550     case Bytecodes::_i2d:
1551     case Bytecodes::_f2l:
1552     case Bytecodes::_f2d:               pp(vCTS, vvCTS); break;
1553 
1554     case Bytecodes::_lcmp:              pp(vvvvCTS, vCTS); break;
1555     case Bytecodes::_dcmpl:
1556     case Bytecodes::_dcmpg:             pp(vvvvCTS, vCTS); break;
1557 
1558     case Bytecodes::_ifeq:
1559     case Bytecodes::_ifne:
1560     case Bytecodes::_iflt:
1561     case Bytecodes::_ifge:
1562     case Bytecodes::_ifgt:
1563     case Bytecodes::_ifle:
1564     case Bytecodes::_tableswitch:       ppop1(valCTS);
1565                                         break;
1566     case Bytecodes::_ireturn:
1567     case Bytecodes::_freturn:           do_return_monitor_check();
1568                                         ppop1(valCTS);
1569                                         break;
1570     case Bytecodes::_if_icmpeq:
1571     case Bytecodes::_if_icmpne:
1572     case Bytecodes::_if_icmplt:
1573     case Bytecodes::_if_icmpge:
1574     case Bytecodes::_if_icmpgt:
1575     case Bytecodes::_if_icmple:         ppop(vvCTS);
1576                                         break;
1577 
1578     case Bytecodes::_lreturn:           do_return_monitor_check();
1579                                         ppop(vvCTS);
1580                                         break;
1581 
1582     case Bytecodes::_dreturn:           do_return_monitor_check();
1583                                         ppop(vvCTS);
1584                                         break;
1585 
1586     case Bytecodes::_if_acmpeq:
1587     case Bytecodes::_if_acmpne:         ppop(rrCTS);                 break;
1588 
1589     case Bytecodes::_jsr:               do_jsr(itr-&gt;dest());         break;
1590     case Bytecodes::_jsr_w:             do_jsr(itr-&gt;dest_w());       break;
1591 
1592     case Bytecodes::_getstatic:         do_field(true,  true,  itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1593     case Bytecodes::_putstatic:         do_field(false, true,  itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1594     case Bytecodes::_getfield:          do_field(true,  false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1595     case Bytecodes::_putfield:          do_field(false, false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1596 
1597     case Bytecodes::_invokevirtual:
1598     case Bytecodes::_invokespecial:     do_method(false, false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1599     case Bytecodes::_invokestatic:      do_method(true,  false, itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1600     case Bytecodes::_invokedynamic:     do_method(true,  false, itr-&gt;get_index_u4(),         itr-&gt;bci()); break;
1601     case Bytecodes::_invokeinterface:   do_method(false, true,  itr-&gt;get_index_u2_cpcache(), itr-&gt;bci()); break;
1602     case Bytecodes::_newarray:
1603     case Bytecodes::_anewarray:         pp_new_ref(vCTS, itr-&gt;bci()); break;
1604     case Bytecodes::_checkcast:         do_checkcast(); break;
1605     case Bytecodes::_arraylength:
1606     case Bytecodes::_instanceof:        pp(rCTS, vCTS); break;
1607     case Bytecodes::_monitorenter:      do_monitorenter(itr-&gt;bci()); break;
1608     case Bytecodes::_monitorexit:       do_monitorexit(itr-&gt;bci()); break;
1609 
1610     case Bytecodes::_athrow:            // handled by do_exception_edge() BUT ...
1611                                         // vlh(apple): do_exception_edge() does not get
1612                                         // called if method has no exception handlers
1613                                         if ((!_has_exceptions) &amp;&amp; (_monitor_top &gt; 0)) {
1614                                           _monitor_safe = false;
1615                                         }
1616                                         break;
1617 
1618     case Bytecodes::_areturn:           do_return_monitor_check();
1619                                         ppop1(refCTS);
1620                                         break;
1621     case Bytecodes::_ifnull:
1622     case Bytecodes::_ifnonnull:         ppop1(refCTS); break;
1623     case Bytecodes::_multianewarray:    do_multianewarray(*(itr-&gt;bcp()+3), itr-&gt;bci()); break;
1624 
1625     case Bytecodes::_wide:              fatal(&quot;Iterator should skip this bytecode&quot;); break;
1626     case Bytecodes::_ret:                                           break;
1627 
1628     // Java opcodes
1629     case Bytecodes::_lookupswitch:      ppop1(valCTS);             break;
1630 
1631     default:
1632          tty-&gt;print(&quot;unexpected opcode: %d\n&quot;, itr-&gt;code());
1633          ShouldNotReachHere();
1634     break;
1635   }
1636 }
1637 
1638 void GenerateOopMap::check_type(CellTypeState expected, CellTypeState actual) {
1639   if (!expected.equal_kind(actual)) {
1640     verify_error(&quot;wrong type on stack (found: %c expected: %c)&quot;, actual.to_char(), expected.to_char());
1641   }
1642 }
1643 
1644 void GenerateOopMap::ppstore(CellTypeState *in, int loc_no) {
1645   while(!(*in).is_bottom()) {
1646     CellTypeState expected =*in++;
1647     CellTypeState actual   = pop();
1648     check_type(expected, actual);
1649     assert(loc_no &gt;= 0, &quot;sanity check&quot;);
1650     set_var(loc_no++, actual);
1651   }
1652 }
1653 
1654 void GenerateOopMap::ppload(CellTypeState *out, int loc_no) {
1655   while(!(*out).is_bottom()) {
1656     CellTypeState out1 = *out++;
1657     CellTypeState vcts = get_var(loc_no);
1658     assert(out1.can_be_reference() || out1.can_be_value(),
1659            &quot;can only load refs. and values.&quot;);
1660     if (out1.is_reference()) {
1661       assert(loc_no&gt;=0, &quot;sanity check&quot;);
1662       if (!vcts.is_reference()) {
1663         // We were asked to push a reference, but the type of the
1664         // variable can be something else
1665         _conflict = true;
1666         if (vcts.can_be_uninit()) {
1667           // It is a ref-uninit conflict (at least). If there are other
1668           // problems, we&#39;ll get them in the next round
1669           add_to_ref_init_set(loc_no);
1670           vcts = out1;
1671         } else {
1672           // It wasn&#39;t a ref-uninit conflict. So must be a
1673           // ref-val or ref-pc conflict. Split the variable.
1674           record_refval_conflict(loc_no);
1675           vcts = out1;
1676         }
1677         push(out1); // recover...
1678       } else {
1679         push(vcts); // preserve reference.
1680       }
1681       // Otherwise it is a conflict, but one that verification would
1682       // have caught if illegal. In particular, it can&#39;t be a topCTS
1683       // resulting from mergeing two difference pcCTS&#39;s since the verifier
1684       // would have rejected any use of such a merge.
1685     } else {
1686       push(out1); // handle val/init conflict
1687     }
1688     loc_no++;
1689   }
1690 }
1691 
1692 void GenerateOopMap::ppdupswap(int poplen, const char *out) {
1693   CellTypeState actual[5];
1694   assert(poplen &lt; 5, &quot;this must be less than length of actual vector&quot;);
1695 
1696   // Pop all arguments.
1697   for (int i = 0; i &lt; poplen; i++) {
1698     actual[i] = pop();
1699   }
1700   // Field _state is uninitialized when calling push.
1701   for (int i = poplen; i &lt; 5; i++) {
1702     actual[i] = CellTypeState::uninit;
1703   }
1704 
1705   // put them back
1706   char push_ch = *out++;
1707   while (push_ch != &#39;\0&#39;) {
1708     int idx = push_ch - &#39;1&#39;;
1709     assert(idx &gt;= 0 &amp;&amp; idx &lt; poplen, &quot;wrong arguments&quot;);
1710     push(actual[idx]);
1711     push_ch = *out++;
1712   }
1713 }
1714 
1715 void GenerateOopMap::ppop1(CellTypeState out) {
1716   CellTypeState actual = pop();
1717   check_type(out, actual);
1718 }
1719 
1720 void GenerateOopMap::ppop(CellTypeState *out) {
1721   while (!(*out).is_bottom()) {
1722     ppop1(*out++);
1723   }
1724 }
1725 
1726 void GenerateOopMap::ppush1(CellTypeState in) {
1727   assert(in.is_reference() | in.is_value(), &quot;sanity check&quot;);
1728   push(in);
1729 }
1730 
1731 void GenerateOopMap::ppush(CellTypeState *in) {
1732   while (!(*in).is_bottom()) {
1733     ppush1(*in++);
1734   }
1735 }
1736 
1737 void GenerateOopMap::pp(CellTypeState *in, CellTypeState *out) {
1738   ppop(in);
1739   ppush(out);
1740 }
1741 
1742 void GenerateOopMap::pp_new_ref(CellTypeState *in, int bci) {
1743   ppop(in);
1744   ppush1(CellTypeState::make_line_ref(bci));
1745 }
1746 
1747 void GenerateOopMap::ppop_any(int poplen) {
1748   if (_stack_top &gt;= poplen) {
1749     _stack_top -= poplen;
1750   } else {
1751     verify_error(&quot;stack underflow&quot;);
1752   }
1753 }
1754 
1755 // Replace all occurences of the state &#39;match&#39; with the state &#39;replace&#39;
1756 // in our current state vector.
1757 void GenerateOopMap::replace_all_CTS_matches(CellTypeState match,
1758                                              CellTypeState replace) {
1759   int i;
1760   int len = _max_locals + _stack_top;
1761   bool change = false;
1762 
1763   for (i = len - 1; i &gt;= 0; i--) {
1764     if (match.equal(_state[i])) {
1765       _state[i] = replace;
1766     }
1767   }
1768 
1769   if (_monitor_top &gt; 0) {
1770     int base = _max_locals + _max_stack;
1771     len = base + _monitor_top;
1772     for (i = len - 1; i &gt;= base; i--) {
1773       if (match.equal(_state[i])) {
1774         _state[i] = replace;
1775       }
1776     }
1777   }
1778 }
1779 
1780 void GenerateOopMap::do_checkcast() {
1781   CellTypeState actual = pop();
1782   check_type(refCTS, actual);
1783   push(actual);
1784 }
1785 
1786 void GenerateOopMap::do_monitorenter(int bci) {
1787   CellTypeState actual = pop();
1788   if (_monitor_top == bad_monitors) {
1789     return;
1790   }
1791 
1792   // Bail out when we get repeated locks on an identical monitor.  This case
1793   // isn&#39;t too hard to handle and can be made to work if supporting nested
1794   // redundant synchronized statements becomes a priority.
1795   //
1796   // See also &quot;Note&quot; in do_monitorexit(), below.
1797   if (actual.is_lock_reference()) {
1798     _monitor_top = bad_monitors;
1799     _monitor_safe = false;
1800 
1801     if (log_is_enabled(Info, monitormismatch)) {
1802       report_monitor_mismatch(&quot;nested redundant lock -- bailout...&quot;);
1803     }
1804     return;
1805   }
1806 
1807   CellTypeState lock = CellTypeState::make_lock_ref(bci);
1808   check_type(refCTS, actual);
1809   if (!actual.is_info_top()) {
1810     replace_all_CTS_matches(actual, lock);
1811     monitor_push(lock);
1812   }
1813 }
1814 
1815 void GenerateOopMap::do_monitorexit(int bci) {
1816   CellTypeState actual = pop();
1817   if (_monitor_top == bad_monitors) {
1818     return;
1819   }
1820   check_type(refCTS, actual);
1821   CellTypeState expected = monitor_pop();
1822   if (!actual.is_lock_reference() || !expected.equal(actual)) {
1823     // The monitor we are exiting is not verifiably the one
1824     // on the top of our monitor stack.  This causes a monitor
1825     // mismatch.
1826     _monitor_top = bad_monitors;
1827     _monitor_safe = false;
1828 
1829     // We need to mark this basic block as changed so that
1830     // this monitorexit will be visited again.  We need to
1831     // do this to ensure that we have accounted for the
1832     // possibility that this bytecode will throw an
1833     // exception.
1834     BasicBlock* bb = get_basic_block_containing(bci);
1835     guarantee(bb != NULL, &quot;no basic block for bci&quot;);
1836     bb-&gt;set_changed(true);
1837     bb-&gt;_monitor_top = bad_monitors;
1838 
1839     if (log_is_enabled(Info, monitormismatch)) {
1840       report_monitor_mismatch(&quot;improper monitor pair&quot;);
1841     }
1842   } else {
1843     // This code is a fix for the case where we have repeated
1844     // locking of the same object in straightline code.  We clear
1845     // out the lock when it is popped from the monitor stack
1846     // and replace it with an unobtrusive reference value that can
1847     // be locked again.
1848     //
1849     // Note: when generateOopMap is fixed to properly handle repeated,
1850     //       nested, redundant locks on the same object, then this
1851     //       fix will need to be removed at that time.
1852     replace_all_CTS_matches(actual, CellTypeState::make_line_ref(bci));
1853   }
1854 }
1855 
1856 void GenerateOopMap::do_return_monitor_check() {
1857   if (_monitor_top &gt; 0) {
1858     // The monitor stack must be empty when we leave the method
1859     // for the monitors to be properly matched.
1860     _monitor_safe = false;
1861 
1862     // Since there are no successors to the *return bytecode, it
1863     // isn&#39;t necessary to set _monitor_top to bad_monitors.
1864 
1865     if (log_is_enabled(Info, monitormismatch)) {
1866       report_monitor_mismatch(&quot;non-empty monitor stack at return&quot;);
1867     }
1868   }
1869 }
1870 
1871 void GenerateOopMap::do_jsr(int targ_bci) {
1872   push(CellTypeState::make_addr(targ_bci));
1873 }
1874 
1875 
1876 
1877 void GenerateOopMap::do_ldc(int bci) {
1878   Bytecode_loadconstant ldc(methodHandle(Thread::current(), method()), bci);
1879   ConstantPool* cp  = method()-&gt;constants();
1880   constantTag tag = cp-&gt;tag_at(ldc.pool_index()); // idx is index in resolved_references
1881   BasicType       bt  = ldc.result_type();
1882 #ifdef ASSERT
1883   BasicType   tag_bt = (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) ? bt : tag.basic_type();
1884   assert(bt == tag_bt, &quot;same result&quot;);
1885 #endif
1886   CellTypeState   cts;
1887   if (is_reference_type(bt)) {  // could be T_ARRAY with condy
1888     assert(!tag.is_string_index() &amp;&amp; !tag.is_klass_index(), &quot;Unexpected index tag&quot;);
1889     cts = CellTypeState::make_line_ref(bci);
1890   } else {
1891     cts = valCTS;
1892   }
1893   ppush1(cts);
1894 }
1895 
1896 void GenerateOopMap::do_multianewarray(int dims, int bci) {
1897   assert(dims &gt;= 1, &quot;sanity check&quot;);
1898   for(int i = dims -1; i &gt;=0; i--) {
1899     ppop1(valCTS);
1900   }
1901   ppush1(CellTypeState::make_line_ref(bci));
1902 }
1903 
1904 void GenerateOopMap::do_astore(int idx) {
1905   CellTypeState r_or_p = pop();
1906   if (!r_or_p.is_address() &amp;&amp; !r_or_p.is_reference()) {
1907     // We actually expected ref or pc, but we only report that we expected a ref. It does not
1908     // really matter (at least for now)
1909     verify_error(&quot;wrong type on stack (found: %c, expected: {pr})&quot;, r_or_p.to_char());
1910     return;
1911   }
1912   set_var(idx, r_or_p);
1913 }
1914 
1915 // Copies bottom/zero terminated CTS string from &quot;src&quot; into &quot;dst&quot;.
1916 //   Does NOT terminate with a bottom. Returns the number of cells copied.
1917 int GenerateOopMap::copy_cts(CellTypeState *dst, CellTypeState *src) {
1918   int idx = 0;
1919   while (!src[idx].is_bottom()) {
1920     dst[idx] = src[idx];
1921     idx++;
1922   }
1923   return idx;
1924 }
1925 
1926 void GenerateOopMap::do_field(int is_get, int is_static, int idx, int bci) {
1927   // Dig up signature for field in constant pool
1928   ConstantPool* cp     = method()-&gt;constants();
1929   int nameAndTypeIdx     = cp-&gt;name_and_type_ref_index_at(idx);
1930   int signatureIdx       = cp-&gt;signature_ref_index_at(nameAndTypeIdx);
1931   Symbol* signature      = cp-&gt;symbol_at(signatureIdx);
1932 
<a name="8" id="anc8"></a>



1933   CellTypeState temp[4];
<a name="9" id="anc9"></a><span class="line-modified">1934   CellTypeState *eff  = signature_to_effect(signature, bci, temp);</span>
1935 
1936   CellTypeState in[4];
1937   CellTypeState *out;
1938   int i =  0;
1939 
1940   if (is_get) {
1941     out = eff;
1942   } else {
1943     out = epsilonCTS;
1944     i   = copy_cts(in, eff);
1945   }
1946   if (!is_static) in[i++] = CellTypeState::ref;
1947   in[i] = CellTypeState::bottom;
1948   assert(i&lt;=3, &quot;sanity check&quot;);
1949   pp(in, out);
1950 }
1951 
1952 void GenerateOopMap::do_method(int is_static, int is_interface, int idx, int bci) {
1953  // Dig up signature for field in constant pool
1954   ConstantPool* cp  = _method-&gt;constants();
1955   Symbol* signature   = cp-&gt;signature_ref_at(idx);
1956 
1957   // Parse method signature
1958   CellTypeState out[4];
1959   CellTypeState in[MAXARGSIZE+1];   // Includes result
1960   ComputeCallStack cse(signature);
1961 
1962   // Compute return type
1963   int res_length=  cse.compute_for_returntype(out);
1964 
1965   // Temporary hack.
1966   if (out[0].equal(CellTypeState::ref) &amp;&amp; out[1].equal(CellTypeState::bottom)) {
1967     out[0] = CellTypeState::make_line_ref(bci);
1968   }
1969 
1970   assert(res_length&lt;=4, &quot;max value should be vv&quot;);
1971 
1972   // Compute arguments
1973   int arg_length = cse.compute_for_parameters(is_static != 0, in);
1974   assert(arg_length&lt;=MAXARGSIZE, &quot;too many locals&quot;);
1975 
1976   // Pop arguments
1977   for (int i = arg_length - 1; i &gt;= 0; i--) ppop1(in[i]);// Do args in reverse order.
1978 
1979   // Report results
1980   if (_report_result_for_send == true) {
1981      fill_stackmap_for_opcodes(_itr_send, vars(), stack(), _stack_top);
1982      _report_result_for_send = false;
1983   }
1984 
1985   // Push return address
1986   ppush(out);
1987 }
1988 
1989 // This is used to parse the signature for fields, since they are very simple...
<a name="10" id="anc10"></a><span class="line-modified">1990 CellTypeState *GenerateOopMap::signature_to_effect(const Symbol* sig, int bci, CellTypeState *out) {</span>
1991   // Object and array
<a name="11" id="anc11"></a><span class="line-modified">1992   BasicType bt = Signature::basic_type(sig);</span>
<span class="line-added">1993   if (is_reference_type(bt)) {</span>
1994     out[0] = CellTypeState::make_line_ref(bci);
1995     out[1] = CellTypeState::bottom;
1996     return out;
1997   }
<a name="12" id="anc12"></a><span class="line-modified">1998   if (is_double_word_type(bt)) return vvCTS; // Long and Double</span>
<span class="line-modified">1999   if (bt == T_VOID) return epsilonCTS;       // Void</span>
<span class="line-modified">2000   return vCTS;                               // Otherwise</span>
2001 }
2002 
2003 long GenerateOopMap::_total_byte_count = 0;
2004 elapsedTimer GenerateOopMap::_total_oopmap_time;
2005 
2006 // This function assumes &quot;bcs&quot; is at a &quot;ret&quot; instruction and that the vars
2007 // state is valid for that instruction. Furthermore, the ret instruction
2008 // must be the last instruction in &quot;bb&quot; (we store information about the
2009 // &quot;ret&quot; in &quot;bb&quot;).
2010 void GenerateOopMap::ret_jump_targets_do(BytecodeStream *bcs, jmpFct_t jmpFct, int varNo, int *data) {
2011   CellTypeState ra = vars()[varNo];
2012   if (!ra.is_good_address()) {
2013     verify_error(&quot;ret returns from two jsr subroutines?&quot;);
2014     return;
2015   }
2016   int target = ra.get_info();
2017 
2018   RetTableEntry* rtEnt = _rt.find_jsrs_for_target(target);
2019   int bci = bcs-&gt;bci();
2020   for (int i = 0; i &lt; rtEnt-&gt;nof_jsrs(); i++) {
2021     int target_bci = rtEnt-&gt;jsrs(i);
2022     // Make sure a jrtRet does not set the changed bit for dead basicblock.
2023     BasicBlock* jsr_bb    = get_basic_block_containing(target_bci - 1);
2024     debug_only(BasicBlock* target_bb = &amp;jsr_bb[1];)
2025     assert(target_bb  == get_basic_block_at(target_bci), &quot;wrong calc. of successor basicblock&quot;);
2026     bool alive = jsr_bb-&gt;is_alive();
2027     if (TraceNewOopMapGeneration) {
2028       tty-&gt;print(&quot;pc = %d, ret -&gt; %d alive: %s\n&quot;, bci, target_bci, alive ? &quot;true&quot; : &quot;false&quot;);
2029     }
2030     if (alive) jmpFct(this, target_bci, data);
2031   }
2032 }
2033 
2034 //
2035 // Debug method
2036 //
2037 char* GenerateOopMap::state_vec_to_string(CellTypeState* vec, int len) {
2038 #ifdef ASSERT
2039   int checklen = MAX3(_max_locals, _max_stack, _max_monitors) + 1;
2040   assert(len &lt; checklen, &quot;state_vec_buf overflow&quot;);
2041 #endif
2042   for (int i = 0; i &lt; len; i++) _state_vec_buf[i] = vec[i].to_char();
2043   _state_vec_buf[len] = 0;
2044   return _state_vec_buf;
2045 }
2046 
2047 void GenerateOopMap::print_time() {
2048   tty-&gt;print_cr (&quot;Accumulated oopmap times:&quot;);
2049   tty-&gt;print_cr (&quot;---------------------------&quot;);
2050   tty-&gt;print_cr (&quot;  Total : %3.3f sec.&quot;, GenerateOopMap::_total_oopmap_time.seconds());
2051   tty-&gt;print_cr (&quot;  (%3.0f bytecodes per sec) &quot;,
2052   GenerateOopMap::_total_byte_count / GenerateOopMap::_total_oopmap_time.seconds());
2053 }
2054 
2055 //
2056 //  ============ Main Entry Point ===========
2057 //
2058 GenerateOopMap::GenerateOopMap(const methodHandle&amp; method) {
2059   // We have to initialize all variables here, that can be queried directly
2060   _method = method;
2061   _max_locals=0;
2062   _init_vars = NULL;
2063 
2064 #ifndef PRODUCT
2065   // If we are doing a detailed trace, include the regular trace information.
2066   if (TraceNewOopMapGenerationDetailed) {
2067     TraceNewOopMapGeneration = true;
2068   }
2069 #endif
2070 }
2071 
2072 void GenerateOopMap::compute_map(TRAPS) {
2073 #ifndef PRODUCT
2074   if (TimeOopMap2) {
2075     method()-&gt;print_short_name(tty);
2076     tty-&gt;print(&quot;  &quot;);
2077   }
2078   if (TimeOopMap) {
2079     _total_byte_count += method()-&gt;code_size();
2080   }
2081 #endif
2082   TraceTime t_single(&quot;oopmap time&quot;, TimeOopMap2);
2083   TraceTime t_all(NULL, &amp;_total_oopmap_time, TimeOopMap);
2084 
2085   // Initialize values
2086   _got_error      = false;
2087   _conflict       = false;
2088   _max_locals     = method()-&gt;max_locals();
2089   _max_stack      = method()-&gt;max_stack();
2090   _has_exceptions = (method()-&gt;has_exception_handler());
2091   _nof_refval_conflicts = 0;
2092   _init_vars      = new GrowableArray&lt;intptr_t&gt;(5);  // There are seldom more than 5 init_vars
2093   _report_result  = false;
2094   _report_result_for_send = false;
2095   _new_var_map    = NULL;
2096   _ret_adr_tos    = new GrowableArray&lt;intptr_t&gt;(5);  // 5 seems like a good number;
2097   _did_rewriting  = false;
2098   _did_relocation = false;
2099 
2100   if (TraceNewOopMapGeneration) {
2101     tty-&gt;print(&quot;Method name: %s\n&quot;, method()-&gt;name()-&gt;as_C_string());
2102     if (Verbose) {
2103       _method-&gt;print_codes();
2104       tty-&gt;print_cr(&quot;Exception table:&quot;);
2105       ExceptionTable excps(method());
2106       for(int i = 0; i &lt; excps.length(); i ++) {
2107         tty-&gt;print_cr(&quot;[%d - %d] -&gt; %d&quot;,
2108                       excps.start_pc(i), excps.end_pc(i), excps.handler_pc(i));
2109       }
2110     }
2111   }
2112 
2113   // if no code - do nothing
2114   // compiler needs info
2115   if (method()-&gt;code_size() == 0 || _max_locals + method()-&gt;max_stack() == 0) {
2116     fill_stackmap_prolog(0);
2117     fill_stackmap_epilog();
2118     return;
2119   }
2120   // Step 1: Compute all jump targets and their return value
2121   if (!_got_error)
2122     _rt.compute_ret_table(_method);
2123 
2124   // Step 2: Find all basic blocks and count GC points
2125   if (!_got_error)
2126     mark_bbheaders_and_count_gc_points();
2127 
2128   // Step 3: Calculate stack maps
2129   if (!_got_error)
2130     do_interpretation();
2131 
2132   // Step 4:Return results
2133   if (!_got_error &amp;&amp; report_results())
2134      report_result();
2135 
2136   if (_got_error) {
2137     THROW_HANDLE(_exception);
2138   }
2139 }
2140 
2141 // Error handling methods
2142 // These methods create an exception for the current thread which is thrown
2143 // at the bottom of the call stack, when it returns to compute_map().  The
2144 // _got_error flag controls execution.  NOT TODO: The VM exception propagation
2145 // mechanism using TRAPS/CHECKs could be used here instead but it would need
2146 // to be added as a parameter to every function and checked for every call.
2147 // The tons of extra code it would generate didn&#39;t seem worth the change.
2148 //
2149 void GenerateOopMap::error_work(const char *format, va_list ap) {
2150   _got_error = true;
2151   char msg_buffer[512];
2152   os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);
2153   // Append method name
2154   char msg_buffer2[512];
2155   os::snprintf(msg_buffer2, sizeof(msg_buffer2), &quot;%s in method %s&quot;, msg_buffer, method()-&gt;name()-&gt;as_C_string());
2156   if (Thread::current()-&gt;can_call_java()) {
2157     _exception = Exceptions::new_exception(Thread::current(),
2158                   vmSymbols::java_lang_LinkageError(), msg_buffer2);
2159   } else {
2160     // We cannot instantiate an exception object from a compiler thread.
2161     // Exit the VM with a useful error message.
2162     fatal(&quot;%s&quot;, msg_buffer2);
2163   }
2164 }
2165 
2166 void GenerateOopMap::report_error(const char *format, ...) {
2167   va_list ap;
2168   va_start(ap, format);
2169   error_work(format, ap);
2170 }
2171 
2172 void GenerateOopMap::verify_error(const char *format, ...) {
2173   // We do not distinguish between different types of errors for verification
2174   // errors.  Let the verifier give a better message.
2175   report_error(&quot;Illegal class file encountered. Try running with -Xverify:all&quot;);
2176 }
2177 
2178 //
2179 // Report result opcodes
2180 //
2181 void GenerateOopMap::report_result() {
2182 
2183   if (TraceNewOopMapGeneration) tty-&gt;print_cr(&quot;Report result pass&quot;);
2184 
2185   // We now want to report the result of the parse
2186   _report_result = true;
2187 
2188   // Prolog code
2189   fill_stackmap_prolog(_gc_points);
2190 
2191    // Mark everything changed, then do one interpretation pass.
2192   for (int i = 0; i&lt;_bb_count; i++) {
2193     if (_basic_blocks[i].is_reachable()) {
2194       _basic_blocks[i].set_changed(true);
2195       interp_bb(&amp;_basic_blocks[i]);
2196     }
2197   }
2198 
2199   // Note: Since we are skipping dead-code when we are reporting results, then
2200   // the no. of encountered gc-points might be fewer than the previously number
2201   // we have counted. (dead-code is a pain - it should be removed before we get here)
2202   fill_stackmap_epilog();
2203 
2204   // Report initvars
2205   fill_init_vars(_init_vars);
2206 
2207   _report_result = false;
2208 }
2209 
2210 void GenerateOopMap::result_for_basicblock(int bci) {
2211  if (TraceNewOopMapGeneration) tty-&gt;print_cr(&quot;Report result pass for basicblock&quot;);
2212 
2213   // We now want to report the result of the parse
2214   _report_result = true;
2215 
2216   // Find basicblock and report results
2217   BasicBlock* bb = get_basic_block_containing(bci);
2218   guarantee(bb != NULL, &quot;no basic block for bci&quot;);
2219   assert(bb-&gt;is_reachable(), &quot;getting result from unreachable basicblock&quot;);
2220   bb-&gt;set_changed(true);
2221   interp_bb(bb);
2222 }
2223 
2224 //
2225 // Conflict handling code
2226 //
2227 
2228 void GenerateOopMap::record_refval_conflict(int varNo) {
2229   assert(varNo&gt;=0 &amp;&amp; varNo&lt; _max_locals, &quot;index out of range&quot;);
2230 
2231   if (TraceOopMapRewrites) {
2232      tty-&gt;print(&quot;### Conflict detected (local no: %d)\n&quot;, varNo);
2233   }
2234 
2235   if (!_new_var_map) {
2236     _new_var_map = NEW_RESOURCE_ARRAY(int, _max_locals);
2237     for (int k = 0; k &lt; _max_locals; k++)  _new_var_map[k] = k;
2238   }
2239 
2240   if ( _new_var_map[varNo] == varNo) {
2241     // Check if max. number of locals has been reached
2242     if (_max_locals + _nof_refval_conflicts &gt;= MAX_LOCAL_VARS) {
2243       report_error(&quot;Rewriting exceeded local variable limit&quot;);
2244       return;
2245     }
2246     _new_var_map[varNo] = _max_locals + _nof_refval_conflicts;
2247     _nof_refval_conflicts++;
2248   }
2249 }
2250 
2251 void GenerateOopMap::rewrite_refval_conflicts()
2252 {
2253   // We can get here two ways: Either a rewrite conflict was detected, or
2254   // an uninitialize reference was detected. In the second case, we do not
2255   // do any rewriting, we just want to recompute the reference set with the
2256   // new information
2257 
2258   int nof_conflicts = 0;              // Used for debugging only
2259 
2260   if ( _nof_refval_conflicts == 0 )
2261      return;
2262 
2263   // Check if rewrites are allowed in this parse.
2264   if (!allow_rewrites() &amp;&amp; !IgnoreRewrites) {
2265     fatal(&quot;Rewriting method not allowed at this stage&quot;);
2266   }
2267 
2268 
2269   // This following flag is to tempoary supress rewrites. The locals that might conflict will
2270   // all be set to contain values. This is UNSAFE - however, until the rewriting has been completely
2271   // tested it is nice to have.
2272   if (IgnoreRewrites) {
2273     if (Verbose) {
2274        tty-&gt;print(&quot;rewrites suppressed for local no. &quot;);
2275        for (int l = 0; l &lt; _max_locals; l++) {
2276          if (_new_var_map[l] != l) {
2277            tty-&gt;print(&quot;%d &quot;, l);
2278            vars()[l] = CellTypeState::value;
2279          }
2280        }
2281        tty-&gt;cr();
2282     }
2283 
2284     // That was that...
2285     _new_var_map = NULL;
2286     _nof_refval_conflicts = 0;
2287     _conflict = false;
2288 
2289     return;
2290   }
2291 
2292   // Tracing flag
2293   _did_rewriting = true;
2294 
2295   if (TraceOopMapRewrites) {
2296     tty-&gt;print_cr(&quot;ref/value conflict for method %s - bytecodes are getting rewritten&quot;, method()-&gt;name()-&gt;as_C_string());
2297     method()-&gt;print();
2298     method()-&gt;print_codes();
2299   }
2300 
2301   assert(_new_var_map!=NULL, &quot;nothing to rewrite&quot;);
2302   assert(_conflict==true, &quot;We should not be here&quot;);
2303 
2304   compute_ret_adr_at_TOS();
2305   if (!_got_error) {
2306     for (int k = 0; k &lt; _max_locals &amp;&amp; !_got_error; k++) {
2307       if (_new_var_map[k] != k) {
2308         if (TraceOopMapRewrites) {
2309           tty-&gt;print_cr(&quot;Rewriting: %d -&gt; %d&quot;, k, _new_var_map[k]);
2310         }
2311         rewrite_refval_conflict(k, _new_var_map[k]);
2312         if (_got_error) return;
2313         nof_conflicts++;
2314       }
2315     }
2316   }
2317 
2318   assert(nof_conflicts == _nof_refval_conflicts, &quot;sanity check&quot;);
2319 
2320   // Adjust the number of locals
2321   method()-&gt;set_max_locals(_max_locals+_nof_refval_conflicts);
2322   _max_locals += _nof_refval_conflicts;
2323 
2324   // That was that...
2325   _new_var_map = NULL;
2326   _nof_refval_conflicts = 0;
2327 }
2328 
2329 void GenerateOopMap::rewrite_refval_conflict(int from, int to) {
2330   bool startOver;
2331   do {
2332     // Make sure that the BytecodeStream is constructed in the loop, since
2333     // during rewriting a new method oop is going to be used, and the next time
2334     // around we want to use that.
2335     BytecodeStream bcs(_method);
2336     startOver = false;
2337 
2338     while( !startOver &amp;&amp; !_got_error &amp;&amp;
2339            // test bcs in case method changed and it became invalid
2340            bcs.next() &gt;=0) {
2341       startOver = rewrite_refval_conflict_inst(&amp;bcs, from, to);
2342     }
2343   } while (startOver &amp;&amp; !_got_error);
2344 }
2345 
2346 /* If the current instruction is one that uses local variable &quot;from&quot;
2347    in a ref way, change it to use &quot;to&quot;. There&#39;s a subtle reason why we
2348    renumber the ref uses and not the non-ref uses: non-ref uses may be
2349    2 slots wide (double, long) which would necessitate keeping track of
2350    whether we should add one or two variables to the method. If the change
2351    affected the width of some instruction, returns &quot;TRUE&quot;; otherwise, returns &quot;FALSE&quot;.
2352    Another reason for moving ref&#39;s value is for solving (addr, ref) conflicts, which
2353    both uses aload/astore methods.
2354 */
2355 bool GenerateOopMap::rewrite_refval_conflict_inst(BytecodeStream *itr, int from, int to) {
2356   Bytecodes::Code bc = itr-&gt;code();
2357   int index;
2358   int bci = itr-&gt;bci();
2359 
2360   if (is_aload(itr, &amp;index) &amp;&amp; index == from) {
2361     if (TraceOopMapRewrites) {
2362       tty-&gt;print_cr(&quot;Rewriting aload at bci: %d&quot;, bci);
2363     }
2364     return rewrite_load_or_store(itr, Bytecodes::_aload, Bytecodes::_aload_0, to);
2365   }
2366 
2367   if (is_astore(itr, &amp;index) &amp;&amp; index == from) {
2368     if (!stack_top_holds_ret_addr(bci)) {
2369       if (TraceOopMapRewrites) {
2370         tty-&gt;print_cr(&quot;Rewriting astore at bci: %d&quot;, bci);
2371       }
2372       return rewrite_load_or_store(itr, Bytecodes::_astore, Bytecodes::_astore_0, to);
2373     } else {
2374       if (TraceOopMapRewrites) {
2375         tty-&gt;print_cr(&quot;Supress rewriting of astore at bci: %d&quot;, bci);
2376       }
2377     }
2378   }
2379 
2380   return false;
2381 }
2382 
2383 // The argument to this method is:
2384 // bc : Current bytecode
2385 // bcN : either _aload or _astore
2386 // bc0 : either _aload_0 or _astore_0
2387 bool GenerateOopMap::rewrite_load_or_store(BytecodeStream *bcs, Bytecodes::Code bcN, Bytecodes::Code bc0, unsigned int varNo) {
2388   assert(bcN == Bytecodes::_astore   || bcN == Bytecodes::_aload,   &quot;wrong argument (bcN)&quot;);
2389   assert(bc0 == Bytecodes::_astore_0 || bc0 == Bytecodes::_aload_0, &quot;wrong argument (bc0)&quot;);
2390   int ilen = Bytecodes::length_at(_method(), bcs-&gt;bcp());
2391   int newIlen;
2392 
2393   if (ilen == 4) {
2394     // Original instruction was wide; keep it wide for simplicity
2395     newIlen = 4;
2396   } else if (varNo &lt; 4)
2397      newIlen = 1;
2398   else if (varNo &gt;= 256)
2399      newIlen = 4;
2400   else
2401      newIlen = 2;
2402 
2403   // If we need to relocate in order to patch the byte, we
2404   // do the patching in a temp. buffer, that is passed to the reloc.
2405   // The patching of the bytecode stream is then done by the Relocator.
2406   // This is neccesary, since relocating the instruction at a certain bci, might
2407   // also relocate that instruction, e.g., if a _goto before it gets widen to a _goto_w.
2408   // Hence, we do not know which bci to patch after relocation.
2409 
2410   assert(newIlen &lt;= 4, &quot;sanity check&quot;);
2411   u_char inst_buffer[4]; // Max. instruction size is 4.
2412   address bcp;
2413 
2414   if (newIlen != ilen) {
2415     // Relocation needed do patching in temp. buffer
2416     bcp = (address)inst_buffer;
2417   } else {
2418     bcp = _method-&gt;bcp_from(bcs-&gt;bci());
2419   }
2420 
2421   // Patch either directly in Method* or in temp. buffer
2422   if (newIlen == 1) {
2423     assert(varNo &lt; 4, &quot;varNo too large&quot;);
2424     *bcp = bc0 + varNo;
2425   } else if (newIlen == 2) {
2426     assert(varNo &lt; 256, &quot;2-byte index needed!&quot;);
2427     *(bcp + 0) = bcN;
2428     *(bcp + 1) = varNo;
2429   } else {
2430     assert(newIlen == 4, &quot;Wrong instruction length&quot;);
2431     *(bcp + 0) = Bytecodes::_wide;
2432     *(bcp + 1) = bcN;
2433     Bytes::put_Java_u2(bcp+2, varNo);
2434   }
2435 
2436   if (newIlen != ilen) {
2437     expand_current_instr(bcs-&gt;bci(), ilen, newIlen, inst_buffer);
2438   }
2439 
2440 
2441   return (newIlen != ilen);
2442 }
2443 
2444 class RelocCallback : public RelocatorListener {
2445  private:
2446   GenerateOopMap* _gom;
2447  public:
2448    RelocCallback(GenerateOopMap* gom) { _gom = gom; };
2449 
2450   // Callback method
2451   virtual void relocated(int bci, int delta, int new_code_length) {
2452     _gom-&gt;update_basic_blocks  (bci, delta, new_code_length);
2453     _gom-&gt;update_ret_adr_at_TOS(bci, delta);
2454     _gom-&gt;_rt.update_ret_table (bci, delta);
2455   }
2456 };
2457 
2458 // Returns true if expanding was succesful. Otherwise, reports an error and
2459 // returns false.
2460 void GenerateOopMap::expand_current_instr(int bci, int ilen, int newIlen, u_char inst_buffer[]) {
2461   Thread *THREAD = Thread::current();  // Could really have TRAPS argument.
2462   RelocCallback rcb(this);
2463   Relocator rc(_method, &amp;rcb);
2464   methodHandle m= rc.insert_space_at(bci, newIlen, inst_buffer, THREAD);
2465   if (m.is_null() || HAS_PENDING_EXCEPTION) {
2466     report_error(&quot;could not rewrite method - exception occurred or bytecode buffer overflow&quot;);
2467     return;
2468   }
2469 
2470   // Relocator returns a new method oop.
2471   _did_relocation = true;
2472   _method = m;
2473 }
2474 
2475 
2476 bool GenerateOopMap::is_astore(BytecodeStream *itr, int *index) {
2477   Bytecodes::Code bc = itr-&gt;code();
2478   switch(bc) {
2479     case Bytecodes::_astore_0:
2480     case Bytecodes::_astore_1:
2481     case Bytecodes::_astore_2:
2482     case Bytecodes::_astore_3:
2483       *index = bc - Bytecodes::_astore_0;
2484       return true;
2485     case Bytecodes::_astore:
2486       *index = itr-&gt;get_index();
2487       return true;
2488     default:
2489       return false;
2490   }
2491 }
2492 
2493 bool GenerateOopMap::is_aload(BytecodeStream *itr, int *index) {
2494   Bytecodes::Code bc = itr-&gt;code();
2495   switch(bc) {
2496     case Bytecodes::_aload_0:
2497     case Bytecodes::_aload_1:
2498     case Bytecodes::_aload_2:
2499     case Bytecodes::_aload_3:
2500       *index = bc - Bytecodes::_aload_0;
2501       return true;
2502 
2503     case Bytecodes::_aload:
2504       *index = itr-&gt;get_index();
2505       return true;
2506 
2507     default:
2508       return false;
2509   }
2510 }
2511 
2512 
2513 // Return true iff the top of the operand stack holds a return address at
2514 // the current instruction
2515 bool GenerateOopMap::stack_top_holds_ret_addr(int bci) {
2516   for(int i = 0; i &lt; _ret_adr_tos-&gt;length(); i++) {
2517     if (_ret_adr_tos-&gt;at(i) == bci)
2518       return true;
2519   }
2520 
2521   return false;
2522 }
2523 
2524 void GenerateOopMap::compute_ret_adr_at_TOS() {
2525   assert(_ret_adr_tos != NULL, &quot;must be initialized&quot;);
2526   _ret_adr_tos-&gt;clear();
2527 
2528   for (int i = 0; i &lt; bb_count(); i++) {
2529     BasicBlock* bb = &amp;_basic_blocks[i];
2530 
2531     // Make sure to only check basicblocks that are reachable
2532     if (bb-&gt;is_reachable()) {
2533 
2534       // For each Basic block we check all instructions
2535       BytecodeStream bcs(_method);
2536       bcs.set_interval(bb-&gt;_bci, next_bb_start_pc(bb));
2537 
2538       restore_state(bb);
2539 
2540       while (bcs.next()&gt;=0 &amp;&amp; !_got_error) {
2541         // TDT: should this be is_good_address() ?
2542         if (_stack_top &gt; 0 &amp;&amp; stack()[_stack_top-1].is_address()) {
2543           _ret_adr_tos-&gt;append(bcs.bci());
2544           if (TraceNewOopMapGeneration) {
2545             tty-&gt;print_cr(&quot;Ret_adr TOS at bci: %d&quot;, bcs.bci());
2546           }
2547         }
2548         interp1(&amp;bcs);
2549       }
2550     }
2551   }
2552 }
2553 
2554 void GenerateOopMap::update_ret_adr_at_TOS(int bci, int delta) {
2555   for(int i = 0; i &lt; _ret_adr_tos-&gt;length(); i++) {
2556     int v = _ret_adr_tos-&gt;at(i);
2557     if (v &gt; bci)  _ret_adr_tos-&gt;at_put(i, v + delta);
2558   }
2559 }
2560 
2561 // ===================================================================
2562 
2563 #ifndef PRODUCT
2564 int ResolveOopMapConflicts::_nof_invocations  = 0;
2565 int ResolveOopMapConflicts::_nof_rewrites     = 0;
2566 int ResolveOopMapConflicts::_nof_relocations  = 0;
2567 #endif
2568 
2569 methodHandle ResolveOopMapConflicts::do_potential_rewrite(TRAPS) {
2570   compute_map(CHECK_(methodHandle()));
2571 
2572 #ifndef PRODUCT
2573   // Tracking and statistics
2574   if (PrintRewrites) {
2575     _nof_invocations++;
2576     if (did_rewriting()) {
2577       _nof_rewrites++;
2578       if (did_relocation()) _nof_relocations++;
2579       tty-&gt;print(&quot;Method was rewritten %s: &quot;, (did_relocation()) ? &quot;and relocated&quot; : &quot;&quot;);
2580       method()-&gt;print_value(); tty-&gt;cr();
2581       tty-&gt;print_cr(&quot;Cand.: %d rewrts: %d (%d%%) reloc.: %d (%d%%)&quot;,
2582           _nof_invocations,
2583           _nof_rewrites,    (_nof_rewrites    * 100) / _nof_invocations,
2584           _nof_relocations, (_nof_relocations * 100) / _nof_invocations);
2585     }
2586   }
2587 #endif
2588   return methodHandle(THREAD, method());
2589 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>