<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  27 #define CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
  28 
  29 #include &quot;asm/assembler.hpp&quot;
  30 #include &quot;oops/compressedOops.hpp&quot;
<a name="1" id="anc1"></a>
  31 
  32 // MacroAssembler extends Assembler by frequently used macros.
  33 //
  34 // Instructions for which a &#39;better&#39; code sequence exists depending
  35 // on arguments should also go in here.
  36 
  37 class MacroAssembler: public Assembler {
  38   friend class LIR_Assembler;
  39 
  40  public:
  41   using Assembler::mov;
  42   using Assembler::movi;
  43 
  44  protected:
  45 
  46   // Support for VM calls
  47   //
  48   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  49   // may customize this version by overriding it for its purposes (e.g., to save/restore
  50   // additional registers when doing a VM call).
  51   virtual void call_VM_leaf_base(
  52     address entry_point,               // the entry point
  53     int     number_of_arguments,        // the number of arguments to pop after the call
  54     Label *retaddr = NULL
  55   );
  56 
  57   virtual void call_VM_leaf_base(
  58     address entry_point,               // the entry point
  59     int     number_of_arguments,        // the number of arguments to pop after the call
  60     Label &amp;retaddr) {
  61     call_VM_leaf_base(entry_point, number_of_arguments, &amp;retaddr);
  62   }
  63 
  64   // This is the base routine called by the different versions of call_VM. The interpreter
  65   // may customize this version by overriding it for its purposes (e.g., to save/restore
  66   // additional registers when doing a VM call).
  67   //
  68   // If no java_thread register is specified (noreg) than rthread will be used instead. call_VM_base
  69   // returns the register which contains the thread upon return. If a thread register has been
  70   // specified, the return value will correspond to that register. If no last_java_sp is specified
  71   // (noreg) than rsp will be used instead.
  72   virtual void call_VM_base(           // returns the register containing the thread upon return
  73     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  74     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  75     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  76     address  entry_point,              // the entry point
  77     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  78     bool     check_exceptions          // whether to check for pending exceptions after return
  79   );
  80 
  81   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  82 
  83   enum KlassDecodeMode {
  84     KlassDecodeNone,
  85     KlassDecodeZero,
  86     KlassDecodeXor,
  87     KlassDecodeMovk
  88   };
  89 
  90   KlassDecodeMode klass_decode_mode();
  91 
  92  private:
  93   static KlassDecodeMode _klass_decode_mode;
  94 
  95  public:
  96   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  97 
  98  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  99  // The implementation is only non-empty for the InterpreterMacroAssembler,
 100  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
 101  virtual void check_and_handle_popframe(Register java_thread);
 102  virtual void check_and_handle_earlyret(Register java_thread);
 103 
 104   void safepoint_poll(Label&amp; slow_path);
 105   void safepoint_poll_acquire(Label&amp; slow_path);
 106 
 107   // Biased locking support
 108   // lock_reg and obj_reg must be loaded up with the appropriate values.
 109   // swap_reg is killed.
 110   // tmp_reg must be supplied and must not be rscratch1 or rscratch2
 111   // Optional slow case is for implementations (interpreter and C1) which branch to
 112   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 113   // Returns offset of first potentially-faulting instruction for null
 114   // check info (currently consumed only by C1). If
 115   // swap_reg_contains_mark is true then returns -1 as it is assumed
 116   // the calling code has already passed any potential faults.
 117   int biased_locking_enter(Register lock_reg, Register obj_reg,
 118                            Register swap_reg, Register tmp_reg,
 119                            bool swap_reg_contains_mark,
 120                            Label&amp; done, Label* slow_case = NULL,
 121                            BiasedLockingCounters* counters = NULL);
 122   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 123 
 124 
 125   // Helper functions for statistics gathering.
 126   // Unconditional atomic increment.
 127   void atomic_incw(Register counter_addr, Register tmp, Register tmp2);
 128   void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {
 129     lea(tmp1, counter_addr);
 130     atomic_incw(tmp1, tmp2, tmp3);
 131   }
 132   // Load Effective Address
 133   void lea(Register r, const Address &amp;a) {
 134     InstructionMark im(this);
 135     code_section()-&gt;relocate(inst_mark(), a.rspec());
 136     a.lea(this, r);
 137   }
 138 
 139   /* Sometimes we get misaligned loads and stores, usually from Unsafe
 140      accesses, and these can exceed the offset range. */
 141   Address legitimize_address(const Address &amp;a, int size, Register scratch) {
 142     if (a.getMode() == Address::base_plus_offset) {
 143       if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {
 144         block_comment(&quot;legitimize_address {&quot;);
 145         lea(scratch, a);
 146         block_comment(&quot;} legitimize_address&quot;);
 147         return Address(scratch);
 148       }
 149     }
 150     return a;
 151   }
 152 
 153   void addmw(Address a, Register incr, Register scratch) {
 154     ldrw(scratch, a);
 155     addw(scratch, scratch, incr);
 156     strw(scratch, a);
 157   }
 158 
 159   // Add constant to memory word
 160   void addmw(Address a, int imm, Register scratch) {
 161     ldrw(scratch, a);
 162     if (imm &gt; 0)
 163       addw(scratch, scratch, (unsigned)imm);
 164     else
 165       subw(scratch, scratch, (unsigned)-imm);
 166     strw(scratch, a);
 167   }
 168 
 169   void bind(Label&amp; L) {
 170     Assembler::bind(L);
 171     code()-&gt;clear_last_insn();
 172   }
 173 
 174   void membar(Membar_mask_bits order_constraint);
 175 
 176   using Assembler::ldr;
 177   using Assembler::str;
 178 
 179   void ldr(Register Rx, const Address &amp;adr);
 180   void ldrw(Register Rw, const Address &amp;adr);
 181   void str(Register Rx, const Address &amp;adr);
 182   void strw(Register Rx, const Address &amp;adr);
 183 
 184   // Frame creation and destruction shared between JITs.
 185   void build_frame(int framesize);
 186   void remove_frame(int framesize);
 187 
 188   virtual void _call_Unimplemented(address call_site) {
 189     mov(rscratch2, call_site);
 190   }
 191 
 192 #define call_Unimplemented() _call_Unimplemented((address)__PRETTY_FUNCTION__)
 193 
 194   // aliases defined in AARCH64 spec
 195 
 196   template&lt;class T&gt;
 197   inline void cmpw(Register Rd, T imm)  { subsw(zr, Rd, imm); }
 198 
 199   inline void cmp(Register Rd, unsigned char imm8)  { subs(zr, Rd, imm8); }
 200   inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));
 201 
 202   inline void cmnw(Register Rd, unsigned imm) { addsw(zr, Rd, imm); }
 203   inline void cmn(Register Rd, unsigned imm) { adds(zr, Rd, imm); }
 204 
 205   void cset(Register Rd, Assembler::Condition cond) {
 206     csinc(Rd, zr, zr, ~cond);
 207   }
 208   void csetw(Register Rd, Assembler::Condition cond) {
 209     csincw(Rd, zr, zr, ~cond);
 210   }
 211 
 212   void cneg(Register Rd, Register Rn, Assembler::Condition cond) {
 213     csneg(Rd, Rn, Rn, ~cond);
 214   }
 215   void cnegw(Register Rd, Register Rn, Assembler::Condition cond) {
 216     csnegw(Rd, Rn, Rn, ~cond);
 217   }
 218 
 219   inline void movw(Register Rd, Register Rn) {
 220     if (Rd == sp || Rn == sp) {
 221       addw(Rd, Rn, 0U);
 222     } else {
 223       orrw(Rd, zr, Rn);
 224     }
 225   }
 226   inline void mov(Register Rd, Register Rn) {
 227     assert(Rd != r31_sp &amp;&amp; Rn != r31_sp, &quot;should be&quot;);
 228     if (Rd == Rn) {
 229     } else if (Rd == sp || Rn == sp) {
 230       add(Rd, Rn, 0U);
 231     } else {
 232       orr(Rd, zr, Rn);
 233     }
 234   }
 235 
 236   inline void moviw(Register Rd, unsigned imm) { orrw(Rd, zr, imm); }
 237   inline void movi(Register Rd, unsigned imm) { orr(Rd, zr, imm); }
 238 
 239   inline void tstw(Register Rd, Register Rn) { andsw(zr, Rd, Rn); }
 240   inline void tst(Register Rd, Register Rn) { ands(zr, Rd, Rn); }
 241 
 242   inline void tstw(Register Rd, uint64_t imm) { andsw(zr, Rd, imm); }
 243   inline void tst(Register Rd, uint64_t imm) { ands(zr, Rd, imm); }
 244 
 245   inline void bfiw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 246     bfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 247   }
 248   inline void bfi(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 249     bfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 250   }
 251 
 252   inline void bfxilw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 253     bfmw(Rd, Rn, lsb, (lsb + width - 1));
 254   }
 255   inline void bfxil(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 256     bfm(Rd, Rn, lsb , (lsb + width - 1));
 257   }
 258 
 259   inline void sbfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 260     sbfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 261   }
 262   inline void sbfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 263     sbfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 264   }
 265 
 266   inline void sbfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 267     sbfmw(Rd, Rn, lsb, (lsb + width - 1));
 268   }
 269   inline void sbfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 270     sbfm(Rd, Rn, lsb , (lsb + width - 1));
 271   }
 272 
 273   inline void ubfizw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 274     ubfmw(Rd, Rn, ((32 - lsb) &amp; 31), (width - 1));
 275   }
 276   inline void ubfiz(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 277     ubfm(Rd, Rn, ((64 - lsb) &amp; 63), (width - 1));
 278   }
 279 
 280   inline void ubfxw(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 281     ubfmw(Rd, Rn, lsb, (lsb + width - 1));
 282   }
 283   inline void ubfx(Register Rd, Register Rn, unsigned lsb, unsigned width) {
 284     ubfm(Rd, Rn, lsb , (lsb + width - 1));
 285   }
 286 
 287   inline void asrw(Register Rd, Register Rn, unsigned imm) {
 288     sbfmw(Rd, Rn, imm, 31);
 289   }
 290 
 291   inline void asr(Register Rd, Register Rn, unsigned imm) {
 292     sbfm(Rd, Rn, imm, 63);
 293   }
 294 
 295   inline void lslw(Register Rd, Register Rn, unsigned imm) {
 296     ubfmw(Rd, Rn, ((32 - imm) &amp; 31), (31 - imm));
 297   }
 298 
 299   inline void lsl(Register Rd, Register Rn, unsigned imm) {
 300     ubfm(Rd, Rn, ((64 - imm) &amp; 63), (63 - imm));
 301   }
 302 
 303   inline void lsrw(Register Rd, Register Rn, unsigned imm) {
 304     ubfmw(Rd, Rn, imm, 31);
 305   }
 306 
 307   inline void lsr(Register Rd, Register Rn, unsigned imm) {
 308     ubfm(Rd, Rn, imm, 63);
 309   }
 310 
 311   inline void rorw(Register Rd, Register Rn, unsigned imm) {
 312     extrw(Rd, Rn, Rn, imm);
 313   }
 314 
 315   inline void ror(Register Rd, Register Rn, unsigned imm) {
 316     extr(Rd, Rn, Rn, imm);
 317   }
 318 
 319   inline void sxtbw(Register Rd, Register Rn) {
 320     sbfmw(Rd, Rn, 0, 7);
 321   }
 322   inline void sxthw(Register Rd, Register Rn) {
 323     sbfmw(Rd, Rn, 0, 15);
 324   }
 325   inline void sxtb(Register Rd, Register Rn) {
 326     sbfm(Rd, Rn, 0, 7);
 327   }
 328   inline void sxth(Register Rd, Register Rn) {
 329     sbfm(Rd, Rn, 0, 15);
 330   }
 331   inline void sxtw(Register Rd, Register Rn) {
 332     sbfm(Rd, Rn, 0, 31);
 333   }
 334 
 335   inline void uxtbw(Register Rd, Register Rn) {
 336     ubfmw(Rd, Rn, 0, 7);
 337   }
 338   inline void uxthw(Register Rd, Register Rn) {
 339     ubfmw(Rd, Rn, 0, 15);
 340   }
 341   inline void uxtb(Register Rd, Register Rn) {
 342     ubfm(Rd, Rn, 0, 7);
 343   }
 344   inline void uxth(Register Rd, Register Rn) {
 345     ubfm(Rd, Rn, 0, 15);
 346   }
 347   inline void uxtw(Register Rd, Register Rn) {
 348     ubfm(Rd, Rn, 0, 31);
 349   }
 350 
 351   inline void cmnw(Register Rn, Register Rm) {
 352     addsw(zr, Rn, Rm);
 353   }
 354   inline void cmn(Register Rn, Register Rm) {
 355     adds(zr, Rn, Rm);
 356   }
 357 
 358   inline void cmpw(Register Rn, Register Rm) {
 359     subsw(zr, Rn, Rm);
 360   }
 361   inline void cmp(Register Rn, Register Rm) {
 362     subs(zr, Rn, Rm);
 363   }
 364 
 365   inline void negw(Register Rd, Register Rn) {
 366     subw(Rd, zr, Rn);
 367   }
 368 
 369   inline void neg(Register Rd, Register Rn) {
 370     sub(Rd, zr, Rn);
 371   }
 372 
 373   inline void negsw(Register Rd, Register Rn) {
 374     subsw(Rd, zr, Rn);
 375   }
 376 
 377   inline void negs(Register Rd, Register Rn) {
 378     subs(Rd, zr, Rn);
 379   }
 380 
 381   inline void cmnw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 382     addsw(zr, Rn, Rm, kind, shift);
 383   }
 384   inline void cmn(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 385     adds(zr, Rn, Rm, kind, shift);
 386   }
 387 
 388   inline void cmpw(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 389     subsw(zr, Rn, Rm, kind, shift);
 390   }
 391   inline void cmp(Register Rn, Register Rm, enum shift_kind kind, unsigned shift = 0) {
 392     subs(zr, Rn, Rm, kind, shift);
 393   }
 394 
 395   inline void negw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 396     subw(Rd, zr, Rn, kind, shift);
 397   }
 398 
 399   inline void neg(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 400     sub(Rd, zr, Rn, kind, shift);
 401   }
 402 
 403   inline void negsw(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 404     subsw(Rd, zr, Rn, kind, shift);
 405   }
 406 
 407   inline void negs(Register Rd, Register Rn, enum shift_kind kind, unsigned shift = 0) {
 408     subs(Rd, zr, Rn, kind, shift);
 409   }
 410 
 411   inline void mnegw(Register Rd, Register Rn, Register Rm) {
 412     msubw(Rd, Rn, Rm, zr);
 413   }
 414   inline void mneg(Register Rd, Register Rn, Register Rm) {
 415     msub(Rd, Rn, Rm, zr);
 416   }
 417 
 418   inline void mulw(Register Rd, Register Rn, Register Rm) {
 419     maddw(Rd, Rn, Rm, zr);
 420   }
 421   inline void mul(Register Rd, Register Rn, Register Rm) {
 422     madd(Rd, Rn, Rm, zr);
 423   }
 424 
 425   inline void smnegl(Register Rd, Register Rn, Register Rm) {
 426     smsubl(Rd, Rn, Rm, zr);
 427   }
 428   inline void smull(Register Rd, Register Rn, Register Rm) {
 429     smaddl(Rd, Rn, Rm, zr);
 430   }
 431 
 432   inline void umnegl(Register Rd, Register Rn, Register Rm) {
 433     umsubl(Rd, Rn, Rm, zr);
 434   }
 435   inline void umull(Register Rd, Register Rn, Register Rm) {
 436     umaddl(Rd, Rn, Rm, zr);
 437   }
 438 
 439 #define WRAP(INSN)                                                            \
 440   void INSN(Register Rd, Register Rn, Register Rm, Register Ra) {             \
 441     if ((VM_Version::features() &amp; VM_Version::CPU_A53MAC) &amp;&amp; Ra != zr)        \
 442       nop();                                                                  \
 443     Assembler::INSN(Rd, Rn, Rm, Ra);                                          \
 444   }
 445 
 446   WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)
 447   WRAP(smaddl) WRAP(smsubl) WRAP(umaddl) WRAP(umsubl)
 448 #undef WRAP
 449 
 450 
 451   // macro assembly operations needed for aarch64
 452 
 453   // first two private routines for loading 32 bit or 64 bit constants
 454 private:
 455 
 456   void mov_immediate64(Register dst, u_int64_t imm64);
 457   void mov_immediate32(Register dst, u_int32_t imm32);
 458 
 459   int push(unsigned int bitset, Register stack);
 460   int pop(unsigned int bitset, Register stack);
 461 
 462   int push_fp(unsigned int bitset, Register stack);
 463   int pop_fp(unsigned int bitset, Register stack);
 464 
 465   void mov(Register dst, Address a);
 466 
 467 public:
 468   void push(RegSet regs, Register stack) { if (regs.bits()) push(regs.bits(), stack); }
 469   void pop(RegSet regs, Register stack) { if (regs.bits()) pop(regs.bits(), stack); }
 470 
 471   void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }
 472   void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }
 473 
 474   // Push and pop everything that might be clobbered by a native
 475   // runtime call except rscratch1 and rscratch2.  (They are always
 476   // scratch, so we don&#39;t have to protect them.)  Only save the lower
 477   // 64 bits of each vector register.
 478   void push_call_clobbered_registers();
 479   void pop_call_clobbered_registers();
 480 
 481   // now mov instructions for loading absolute addresses and 32 or
 482   // 64 bit integers
 483 
 484   inline void mov(Register dst, address addr)
 485   {
 486     mov_immediate64(dst, (u_int64_t)addr);
 487   }
 488 
 489   inline void mov(Register dst, u_int64_t imm64)
 490   {
 491     mov_immediate64(dst, imm64);
 492   }
 493 
 494   inline void movw(Register dst, u_int32_t imm32)
 495   {
 496     mov_immediate32(dst, imm32);
 497   }
 498 
 499   inline void mov(Register dst, long l)
 500   {
 501     mov(dst, (u_int64_t)l);
 502   }
 503 
 504   inline void mov(Register dst, int i)
 505   {
 506     mov(dst, (long)i);
 507   }
 508 
 509   void mov(Register dst, RegisterOrConstant src) {
 510     if (src.is_register())
 511       mov(dst, src.as_register());
 512     else
 513       mov(dst, src.as_constant());
 514   }
 515 
 516   void movptr(Register r, uintptr_t imm64);
 517 
 518   void mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32);
 519 
 520   void mov(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {
 521     orr(Vd, T, Vn, Vn);
 522   }
 523 
 524 public:
 525 
 526   // Generalized Test Bit And Branch, including a &quot;far&quot; variety which
 527   // spans more than 32KiB.
 528   void tbr(Condition cond, Register Rt, int bitpos, Label &amp;dest, bool far = false) {
 529     assert(cond == EQ || cond == NE, &quot;must be&quot;);
 530 
 531     if (far)
 532       cond = ~cond;
 533 
 534     void (Assembler::* branch)(Register Rt, int bitpos, Label &amp;L);
 535     if (cond == Assembler::EQ)
 536       branch = &amp;Assembler::tbz;
 537     else
 538       branch = &amp;Assembler::tbnz;
 539 
 540     if (far) {
 541       Label L;
 542       (this-&gt;*branch)(Rt, bitpos, L);
 543       b(dest);
 544       bind(L);
 545     } else {
 546       (this-&gt;*branch)(Rt, bitpos, dest);
 547     }
 548   }
 549 
 550   // macro instructions for accessing and updating floating point
 551   // status register
 552   //
 553   // FPSR : op1 == 011
 554   //        CRn == 0100
 555   //        CRm == 0100
 556   //        op2 == 001
 557 
 558   inline void get_fpsr(Register reg)
 559   {
 560     mrs(0b11, 0b0100, 0b0100, 0b001, reg);
 561   }
 562 
 563   inline void set_fpsr(Register reg)
 564   {
 565     msr(0b011, 0b0100, 0b0100, 0b001, reg);
 566   }
 567 
 568   inline void clear_fpsr()
 569   {
 570     msr(0b011, 0b0100, 0b0100, 0b001, zr);
 571   }
 572 
 573   // DCZID_EL0: op1 == 011
 574   //            CRn == 0000
 575   //            CRm == 0000
 576   //            op2 == 111
 577   inline void get_dczid_el0(Register reg)
 578   {
 579     mrs(0b011, 0b0000, 0b0000, 0b111, reg);
 580   }
 581 
 582   // CTR_EL0:   op1 == 011
 583   //            CRn == 0000
 584   //            CRm == 0000
 585   //            op2 == 001
 586   inline void get_ctr_el0(Register reg)
 587   {
 588     mrs(0b011, 0b0000, 0b0000, 0b001, reg);
 589   }
 590 
 591   // idiv variant which deals with MINLONG as dividend and -1 as divisor
 592   int corrected_idivl(Register result, Register ra, Register rb,
 593                       bool want_remainder, Register tmp = rscratch1);
 594   int corrected_idivq(Register result, Register ra, Register rb,
 595                       bool want_remainder, Register tmp = rscratch1);
 596 
 597   // Support for NULL-checks
 598   //
 599   // Generates code that causes a NULL OS exception if the content of reg is NULL.
 600   // If the accessed location is M[reg + offset] and the offset is known, provide the
 601   // offset. No explicit code generation is needed if the offset is within a certain
 602   // range (0 &lt;= offset &lt;= page_size).
 603 
 604   virtual void null_check(Register reg, int offset = -1);
 605   static bool needs_explicit_null_check(intptr_t offset);
 606   static bool uses_implicit_null_check(void* address);
 607 
 608   static address target_addr_for_insn(address insn_addr, unsigned insn);
 609   static address target_addr_for_insn(address insn_addr) {
 610     unsigned insn = *(unsigned*)insn_addr;
 611     return target_addr_for_insn(insn_addr, insn);
 612   }
 613 
 614   // Required platform-specific helpers for Label::patch_instructions.
 615   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 616   static int pd_patch_instruction_size(address branch, address target);
 617   static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {
 618     pd_patch_instruction_size(branch, target);
 619   }
 620   static address pd_call_destination(address branch) {
 621     return target_addr_for_insn(branch);
 622   }
 623 #ifndef PRODUCT
 624   static void pd_print_patched_instruction(address branch);
 625 #endif
 626 
 627   static int patch_oop(address insn_addr, address o);
 628   static int patch_narrow_klass(address insn_addr, narrowKlass n);
 629 
 630   address emit_trampoline_stub(int insts_call_instruction_offset, address target);
 631   void emit_static_call_stub();
 632 
 633   // The following 4 methods return the offset of the appropriate move instruction
 634 
 635   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 636   int load_unsigned_byte(Register dst, Address src);
 637   int load_unsigned_short(Register dst, Address src);
 638 
 639   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 640   int load_signed_byte(Register dst, Address src);
 641   int load_signed_short(Register dst, Address src);
 642 
 643   int load_signed_byte32(Register dst, Address src);
 644   int load_signed_short32(Register dst, Address src);
 645 
 646   // Support for sign-extension (hi:lo = extend_sign(lo))
 647   void extend_sign(Register hi, Register lo);
 648 
 649   // Load and store values by size and signed-ness
 650   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 651   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 652 
 653   // Support for inc/dec with optimal instruction selection depending on value
 654 
 655   // x86_64 aliases an unqualified register/address increment and
 656   // decrement to call incrementq and decrementq but also supports
 657   // explicitly sized calls to incrementq/decrementq or
 658   // incrementl/decrementl
 659 
 660   // for aarch64 the proper convention would be to use
 661   // increment/decrement for 64 bit operatons and
 662   // incrementw/decrementw for 32 bit operations. so when porting
 663   // x86_64 code we can leave calls to increment/decrement as is,
 664   // replace incrementq/decrementq with increment/decrement and
 665   // replace incrementl/decrementl with incrementw/decrementw.
 666 
 667   // n.b. increment/decrement calls with an Address destination will
 668   // need to use a scratch register to load the value to be
 669   // incremented. increment/decrement calls which add or subtract a
 670   // constant value greater than 2^12 will need to use a 2nd scratch
 671   // register to hold the constant. so, a register increment/decrement
 672   // may trash rscratch2 and an address increment/decrement trash
 673   // rscratch and rscratch2
 674 
 675   void decrementw(Address dst, int value = 1);
 676   void decrementw(Register reg, int value = 1);
 677 
 678   void decrement(Register reg, int value = 1);
 679   void decrement(Address dst, int value = 1);
 680 
 681   void incrementw(Address dst, int value = 1);
 682   void incrementw(Register reg, int value = 1);
 683 
 684   void increment(Register reg, int value = 1);
 685   void increment(Address dst, int value = 1);
 686 
 687 
 688   // Alignment
 689   void align(int modulus);
 690 
 691   // Stack frame creation/removal
 692   void enter()
 693   {
 694     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
 695     mov(rfp, sp);
 696   }
 697   void leave()
 698   {
 699     mov(sp, rfp);
 700     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
 701   }
 702 
 703   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 704   // The pointer will be loaded into the thread register.
 705   void get_thread(Register thread);
 706 
 707 
 708   // Support for VM calls
 709   //
 710   // It is imperative that all calls into the VM are handled via the call_VM macros.
 711   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 712   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 713 
 714 
 715   void call_VM(Register oop_result,
 716                address entry_point,
 717                bool check_exceptions = true);
 718   void call_VM(Register oop_result,
 719                address entry_point,
 720                Register arg_1,
 721                bool check_exceptions = true);
 722   void call_VM(Register oop_result,
 723                address entry_point,
 724                Register arg_1, Register arg_2,
 725                bool check_exceptions = true);
 726   void call_VM(Register oop_result,
 727                address entry_point,
 728                Register arg_1, Register arg_2, Register arg_3,
 729                bool check_exceptions = true);
 730 
 731   // Overloadings with last_Java_sp
 732   void call_VM(Register oop_result,
 733                Register last_java_sp,
 734                address entry_point,
 735                int number_of_arguments = 0,
 736                bool check_exceptions = true);
 737   void call_VM(Register oop_result,
 738                Register last_java_sp,
 739                address entry_point,
 740                Register arg_1, bool
 741                check_exceptions = true);
 742   void call_VM(Register oop_result,
 743                Register last_java_sp,
 744                address entry_point,
 745                Register arg_1, Register arg_2,
 746                bool check_exceptions = true);
 747   void call_VM(Register oop_result,
 748                Register last_java_sp,
 749                address entry_point,
 750                Register arg_1, Register arg_2, Register arg_3,
 751                bool check_exceptions = true);
 752 
 753   void get_vm_result  (Register oop_result, Register thread);
 754   void get_vm_result_2(Register metadata_result, Register thread);
 755 
 756   // These always tightly bind to MacroAssembler::call_VM_base
 757   // bypassing the virtual implementation
 758   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 759   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 760   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 761   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 762   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 763 
 764   void call_VM_leaf(address entry_point,
 765                     int number_of_arguments = 0);
 766   void call_VM_leaf(address entry_point,
 767                     Register arg_1);
 768   void call_VM_leaf(address entry_point,
 769                     Register arg_1, Register arg_2);
 770   void call_VM_leaf(address entry_point,
 771                     Register arg_1, Register arg_2, Register arg_3);
 772 
 773   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 774   // bypassing the virtual implementation
 775   void super_call_VM_leaf(address entry_point);
 776   void super_call_VM_leaf(address entry_point, Register arg_1);
 777   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 778   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 779   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 780 
 781   // last Java Frame (fills frame anchor)
 782   void set_last_Java_frame(Register last_java_sp,
 783                            Register last_java_fp,
 784                            address last_java_pc,
 785                            Register scratch);
 786 
 787   void set_last_Java_frame(Register last_java_sp,
 788                            Register last_java_fp,
 789                            Label &amp;last_java_pc,
 790                            Register scratch);
 791 
 792   void set_last_Java_frame(Register last_java_sp,
 793                            Register last_java_fp,
 794                            Register last_java_pc,
 795                            Register scratch);
 796 
 797   void reset_last_Java_frame(Register thread);
 798 
 799   // thread in the default location (rthread)
 800   void reset_last_Java_frame(bool clear_fp);
 801 
 802   // Stores
 803   void store_check(Register obj);                // store check for obj - register is destroyed afterwards
 804   void store_check(Register obj, Address dst);   // same as above, dst is exact store location (reg. is destroyed)
 805 
 806   void resolve_jobject(Register value, Register thread, Register tmp);
 807 
 808   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 809   void c2bool(Register x);
 810 
 811   void load_method_holder(Register holder, Register method);
 812 
 813   // oop manipulations
 814   void load_klass(Register dst, Register src);
 815   void store_klass(Register dst, Register src);
 816   void cmp_klass(Register oop, Register trial_klass, Register tmp);
 817 
 818   void resolve_oop_handle(Register result, Register tmp = r5);
 819   void load_mirror(Register dst, Register method, Register tmp = r5);
 820 
 821   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 822                       Register tmp1, Register tmp_thread);
 823 
 824   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 825                        Register tmp1, Register tmp_thread);
 826 
 827   // Resolves obj for access. Result is placed in the same register.
 828   // All other registers are preserved.
 829   void resolve(DecoratorSet decorators, Register obj);
 830 
 831   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 832                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 833 
 834   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 835                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 836   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 837                       Register tmp_thread = noreg, DecoratorSet decorators = 0);
 838 
 839   // currently unimplemented
 840   // Used for storing NULL. All other oop constants should be
 841   // stored using routines that take a jobject.
 842   void store_heap_oop_null(Address dst);
 843 
 844   void load_prototype_header(Register dst, Register src);
 845 
 846   void store_klass_gap(Register dst, Register src);
 847 
 848   // This dummy is to prevent a call to store_heap_oop from
 849   // converting a zero (like NULL) into a Register by giving
 850   // the compiler two choices it can&#39;t resolve
 851 
 852   void store_heap_oop(Address dst, void* dummy);
 853 
 854   void encode_heap_oop(Register d, Register s);
 855   void encode_heap_oop(Register r) { encode_heap_oop(r, r); }
 856   void decode_heap_oop(Register d, Register s);
 857   void decode_heap_oop(Register r) { decode_heap_oop(r, r); }
 858   void encode_heap_oop_not_null(Register r);
 859   void decode_heap_oop_not_null(Register r);
 860   void encode_heap_oop_not_null(Register dst, Register src);
 861   void decode_heap_oop_not_null(Register dst, Register src);
 862 
 863   void set_narrow_oop(Register dst, jobject obj);
 864 
 865   void encode_klass_not_null(Register r);
 866   void decode_klass_not_null(Register r);
 867   void encode_klass_not_null(Register dst, Register src);
 868   void decode_klass_not_null(Register dst, Register src);
 869 
 870   void set_narrow_klass(Register dst, Klass* k);
 871 
 872   // if heap base register is used - reinit it with the correct value
 873   void reinit_heapbase();
 874 
 875   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 876 
 877   void push_CPU_state(bool save_vectors = false);
 878   void pop_CPU_state(bool restore_vectors = false) ;
 879 
 880   // Round up to a power of two
 881   void round_to(Register reg, int modulus);
 882 
 883   // allocation
 884   void eden_allocate(
 885     Register obj,                      // result: pointer to object after successful allocation
 886     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 887     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 888     Register t1,                       // temp register
 889     Label&amp;   slow_case                 // continuation point if fast allocation fails
 890   );
 891   void tlab_allocate(
 892     Register obj,                      // result: pointer to object after successful allocation
 893     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 894     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 895     Register t1,                       // temp register
 896     Register t2,                       // temp register
 897     Label&amp;   slow_case                 // continuation point if fast allocation fails
 898   );
 899   void zero_memory(Register addr, Register len, Register t1);
 900   void verify_tlab();
 901 
 902   // interface method calling
 903   void lookup_interface_method(Register recv_klass,
 904                                Register intf_klass,
 905                                RegisterOrConstant itable_index,
 906                                Register method_result,
 907                                Register scan_temp,
 908                                Label&amp; no_such_interface,
 909                    bool return_method = true);
 910 
 911   // virtual method calling
 912   // n.b. x86 allows RegisterOrConstant for vtable_index
 913   void lookup_virtual_method(Register recv_klass,
 914                              RegisterOrConstant vtable_index,
 915                              Register method_result);
 916 
 917   // Test sub_klass against super_klass, with fast and slow paths.
 918 
 919   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 920   // One of the three labels can be NULL, meaning take the fall-through.
 921   // If super_check_offset is -1, the value is loaded up from super_klass.
 922   // No registers are killed, except temp_reg.
 923   void check_klass_subtype_fast_path(Register sub_klass,
 924                                      Register super_klass,
 925                                      Register temp_reg,
 926                                      Label* L_success,
 927                                      Label* L_failure,
 928                                      Label* L_slow_path,
 929                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 930 
 931   // The rest of the type check; must be wired to a corresponding fast path.
 932   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 933   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 934   // Updates the sub&#39;s secondary super cache as necessary.
 935   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 936   void check_klass_subtype_slow_path(Register sub_klass,
 937                                      Register super_klass,
 938                                      Register temp_reg,
 939                                      Register temp2_reg,
 940                                      Label* L_success,
 941                                      Label* L_failure,
 942                                      bool set_cond_codes = false);
 943 
 944   // Simplified, combined version, good for typical uses.
 945   // Falls through on failure.
 946   void check_klass_subtype(Register sub_klass,
 947                            Register super_klass,
 948                            Register temp_reg,
 949                            Label&amp; L_success);
 950 
 951   void clinit_barrier(Register klass,
 952                       Register thread,
 953                       Label* L_fast_path = NULL,
 954                       Label* L_slow_path = NULL);
 955 
 956   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 957 
 958 
 959   // Debugging
 960 
 961   // only if +VerifyOops
 962   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
 963   void verify_oop_addr(Address addr, const char * s = &quot;broken oop addr&quot;);
 964 
 965 // TODO: verify method and klass metadata (compare against vptr?)
 966   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 967   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 968 
 969 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 970 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 971 
 972   // only if +VerifyFPU
 973   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 974 
 975   // prints msg, dumps registers and stops execution
 976   void stop(const char* msg);
 977 
 978   // prints msg and continues
 979   void warn(const char* msg);
 980 
 981   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 982 
 983   void untested()                                { stop(&quot;untested&quot;); }
 984 
 985   void unimplemented(const char* what = &quot;&quot;);
 986 
 987   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 988 
 989   // Stack overflow checking
 990   void bang_stack_with_offset(int offset) {
 991     // stack grows down, caller passes positive offset
 992     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 993     sub(rscratch2, sp, offset);
 994     str(zr, Address(rscratch2));
 995   }
 996 
 997   // Writes to stack successive pages until offset reached to check for
 998   // stack overflow + shadow pages.  Also, clobbers tmp
 999   void bang_stack_size(Register size, Register tmp);
1000 
1001   // Check for reserved stack access in method being exited (for JIT)
1002   void reserved_stack_check();
1003 
1004   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
1005                                                 Register tmp,
1006                                                 int offset);
1007 
1008   // Arithmetics
1009 
1010   void addptr(const Address &amp;dst, int32_t src);
1011   void cmpptr(Register src1, Address src2);
1012 
1013   void cmpoop(Register obj1, Register obj2);
1014 
1015   // Various forms of CAS
1016 
1017   void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
1018                           Label &amp;suceed, Label *fail);
1019   void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
1020                   Label &amp;suceed, Label *fail);
1021 
1022   void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
1023                   Label &amp;suceed, Label *fail);
1024 
1025   void atomic_add(Register prev, RegisterOrConstant incr, Register addr);
1026   void atomic_addw(Register prev, RegisterOrConstant incr, Register addr);
1027   void atomic_addal(Register prev, RegisterOrConstant incr, Register addr);
1028   void atomic_addalw(Register prev, RegisterOrConstant incr, Register addr);
1029 
1030   void atomic_xchg(Register prev, Register newv, Register addr);
1031   void atomic_xchgw(Register prev, Register newv, Register addr);
1032   void atomic_xchgal(Register prev, Register newv, Register addr);
1033   void atomic_xchgalw(Register prev, Register newv, Register addr);
1034 
1035   void orptr(Address adr, RegisterOrConstant src) {
1036     ldr(rscratch1, adr);
1037     if (src.is_register())
1038       orr(rscratch1, rscratch1, src.as_register());
1039     else
1040       orr(rscratch1, rscratch1, src.as_constant());
1041     str(rscratch1, adr);
1042   }
1043 
1044   // A generic CAS; success or failure is in the EQ flag.
1045   // Clobbers rscratch1
1046   void cmpxchg(Register addr, Register expected, Register new_val,
1047                enum operand_size size,
1048                bool acquire, bool release, bool weak,
1049                Register result);
1050 private:
1051   void compare_eq(Register rn, Register rm, enum operand_size size);
1052 
1053 public:
1054   // Calls
1055 
1056   address trampoline_call(Address entry, CodeBuffer *cbuf = NULL);
1057 
1058   static bool far_branches() {
1059     return ReservedCodeCacheSize &gt; branch_range || UseAOT;
1060   }
1061 
1062   // Jumps that can reach anywhere in the code cache.
1063   // Trashes tmp.
1064   void far_call(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1065   void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);
1066 
1067   static int far_branch_size() {
1068     if (far_branches()) {
1069       return 3 * 4;  // adrp, add, br
1070     } else {
1071       return 4;
1072     }
1073   }
1074 
1075   // Emit the CompiledIC call idiom
1076   address ic_call(address entry, jint method_index = 0);
1077 
1078 public:
1079 
1080   // Data
1081 
1082   void mov_metadata(Register dst, Metadata* obj);
1083   Address allocate_metadata_address(Metadata* obj);
1084   Address constant_oop_address(jobject obj);
1085 
1086   void movoop(Register dst, jobject obj, bool immediate = false);
1087 
1088   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1089   void kernel_crc32(Register crc, Register buf, Register len,
1090         Register table0, Register table1, Register table2, Register table3,
1091         Register tmp, Register tmp2, Register tmp3);
1092   // CRC32 code for java.util.zip.CRC32C::updateBytes() instrinsic.
1093   void kernel_crc32c(Register crc, Register buf, Register len,
1094         Register table0, Register table1, Register table2, Register table3,
1095         Register tmp, Register tmp2, Register tmp3);
1096 
1097   // Stack push and pop individual 64 bit registers
1098   void push(Register src);
1099   void pop(Register dst);
1100 
1101   // push all registers onto the stack
1102   void pusha();
1103   void popa();
1104 
1105   void repne_scan(Register addr, Register value, Register count,
1106                   Register scratch);
1107   void repne_scanw(Register addr, Register value, Register count,
1108                    Register scratch);
1109 
1110   typedef void (MacroAssembler::* add_sub_imm_insn)(Register Rd, Register Rn, unsigned imm);
1111   typedef void (MacroAssembler::* add_sub_reg_insn)(Register Rd, Register Rn, Register Rm, enum shift_kind kind, unsigned shift);
1112 
1113   // If a constant does not fit in an immediate field, generate some
1114   // number of MOV instructions and then perform the operation
1115   void wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
1116                              add_sub_imm_insn insn1,
1117                              add_sub_reg_insn insn2);
1118   // Seperate vsn which sets the flags
1119   void wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
1120                              add_sub_imm_insn insn1,
1121                              add_sub_reg_insn insn2);
1122 
1123 #define WRAP(INSN)                                                      \
1124   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1125     wrap_add_sub_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1126   }                                                                     \
1127                                                                         \
1128   void INSN(Register Rd, Register Rn, Register Rm,                      \
1129              enum shift_kind kind, unsigned shift = 0) {                \
1130     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1131   }                                                                     \
1132                                                                         \
1133   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1134     Assembler::INSN(Rd, Rn, Rm);                                        \
1135   }                                                                     \
1136                                                                         \
1137   void INSN(Register Rd, Register Rn, Register Rm,                      \
1138            ext::operation option, int amount = 0) {                     \
1139     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1140   }
1141 
1142   WRAP(add) WRAP(addw) WRAP(sub) WRAP(subw)
1143 
1144 #undef WRAP
1145 #define WRAP(INSN)                                                      \
1146   void INSN(Register Rd, Register Rn, unsigned imm) {                   \
1147     wrap_adds_subs_imm_insn(Rd, Rn, imm, &amp;Assembler::INSN, &amp;Assembler::INSN); \
1148   }                                                                     \
1149                                                                         \
1150   void INSN(Register Rd, Register Rn, Register Rm,                      \
1151              enum shift_kind kind, unsigned shift = 0) {                \
1152     Assembler::INSN(Rd, Rn, Rm, kind, shift);                           \
1153   }                                                                     \
1154                                                                         \
1155   void INSN(Register Rd, Register Rn, Register Rm) {                    \
1156     Assembler::INSN(Rd, Rn, Rm);                                        \
1157   }                                                                     \
1158                                                                         \
1159   void INSN(Register Rd, Register Rn, Register Rm,                      \
1160            ext::operation option, int amount = 0) {                     \
1161     Assembler::INSN(Rd, Rn, Rm, option, amount);                        \
1162   }
1163 
1164   WRAP(adds) WRAP(addsw) WRAP(subs) WRAP(subsw)
1165 
1166   void add(Register Rd, Register Rn, RegisterOrConstant increment);
1167   void addw(Register Rd, Register Rn, RegisterOrConstant increment);
1168   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
1169   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
1170 
1171   void adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset);
1172 
1173   void tableswitch(Register index, jint lowbound, jint highbound,
1174                    Label &amp;jumptable, Label &amp;jumptable_end, int stride = 1) {
1175     adr(rscratch1, jumptable);
1176     subsw(rscratch2, index, lowbound);
1177     subsw(zr, rscratch2, highbound - lowbound);
1178     br(Assembler::HS, jumptable_end);
1179     add(rscratch1, rscratch1, rscratch2,
1180         ext::sxtw, exact_log2(stride * Assembler::instruction_size));
1181     br(rscratch1);
1182   }
1183 
1184   // Form an address from base + offset in Rd.  Rd may or may not
1185   // actually be used: you must use the Address that is returned.  It
1186   // is up to you to ensure that the shift provided matches the size
1187   // of your data.
1188   Address form_address(Register Rd, Register base, long byte_offset, int shift);
1189 
1190   // Return true iff an address is within the 48-bit AArch64 address
1191   // space.
1192   bool is_valid_AArch64_address(address a) {
1193     return ((uint64_t)a &gt;&gt; 48) == 0;
1194   }
1195 
1196   // Load the base of the cardtable byte map into reg.
1197   void load_byte_map_base(Register reg);
1198 
1199   // Prolog generator routines to support switch between x86 code and
1200   // generated ARM code
1201 
1202   // routine to generate an x86 prolog for a stub function which
1203   // bootstraps into the generated ARM code which directly follows the
1204   // stub
1205   //
1206 
1207   public:
1208 
1209   void ldr_constant(Register dest, const Address &amp;const_addr) {
1210     if (NearCpool) {
1211       ldr(dest, const_addr);
1212     } else {
1213       unsigned long offset;
1214       adrp(dest, InternalAddress(const_addr.target()), offset);
1215       ldr(dest, Address(dest, offset));
1216     }
1217   }
1218 
1219   address read_polling_page(Register r, address page, relocInfo::relocType rtype);
1220   address read_polling_page(Register r, relocInfo::relocType rtype);
1221   void get_polling_page(Register dest, address page, relocInfo::relocType rtype);
1222 
1223   // CRC32 code for java.util.zip.CRC32::updateBytes() instrinsic.
1224   void update_byte_crc32(Register crc, Register val, Register table);
1225   void update_word_crc32(Register crc, Register v, Register tmp,
1226         Register table0, Register table1, Register table2, Register table3,
1227         bool upper = false);
1228 
1229   void string_compare(Register str1, Register str2,
1230                       Register cnt1, Register cnt2, Register result,
1231                       Register tmp1, Register tmp2, FloatRegister vtmp1,
1232                       FloatRegister vtmp2, FloatRegister vtmp3, int ae);
1233 
1234   void has_negatives(Register ary1, Register len, Register result);
1235 
1236   void arrays_equals(Register a1, Register a2, Register result, Register cnt1,
1237                      Register tmp1, Register tmp2, Register tmp3, int elem_size);
1238 
1239   void string_equals(Register a1, Register a2, Register result, Register cnt1,
1240                      int elem_size);
1241 
1242   void fill_words(Register base, Register cnt, Register value);
1243   void zero_words(Register base, u_int64_t cnt);
1244   void zero_words(Register ptr, Register cnt);
1245   void zero_dcache_blocks(Register base, Register cnt);
1246 
1247   static const int zero_words_block_size;
1248 
1249   void byte_array_inflate(Register src, Register dst, Register len,
1250                           FloatRegister vtmp1, FloatRegister vtmp2,
1251                           FloatRegister vtmp3, Register tmp4);
1252 
1253   void char_array_compress(Register src, Register dst, Register len,
1254                            FloatRegister tmp1Reg, FloatRegister tmp2Reg,
1255                            FloatRegister tmp3Reg, FloatRegister tmp4Reg,
1256                            Register result);
1257 
1258   void encode_iso_array(Register src, Register dst,
1259                         Register len, Register result,
1260                         FloatRegister Vtmp1, FloatRegister Vtmp2,
1261                         FloatRegister Vtmp3, FloatRegister Vtmp4);
1262   void string_indexof(Register str1, Register str2,
1263                       Register cnt1, Register cnt2,
1264                       Register tmp1, Register tmp2,
1265                       Register tmp3, Register tmp4,
1266                       Register tmp5, Register tmp6,
1267                       int int_cnt1, Register result, int ae);
1268   void string_indexof_char(Register str1, Register cnt1,
1269                            Register ch, Register result,
1270                            Register tmp1, Register tmp2, Register tmp3);
1271   void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,
1272                 FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,
1273                 FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,
1274                 FloatRegister tmpC4, Register tmp1, Register tmp2,
1275                 Register tmp3, Register tmp4, Register tmp5);
1276   void generate_dsin_dcos(bool isCos, address npio2_hw, address two_over_pi,
1277       address pio2, address dsin_coef, address dcos_coef);
1278  private:
1279   // begin trigonometric functions support block
1280   void generate__ieee754_rem_pio2(address npio2_hw, address two_over_pi, address pio2);
1281   void generate__kernel_rem_pio2(address two_over_pi, address pio2);
1282   void generate_kernel_sin(FloatRegister x, bool iyIsOne, address dsin_coef);
1283   void generate_kernel_cos(FloatRegister x, address dcos_coef);
1284   // end trigonometric functions support block
1285   void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
1286                        Register src1, Register src2);
1287   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
1288     add2_with_carry(dest_hi, dest_hi, dest_lo, src1, src2);
1289   }
1290   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1291                              Register y, Register y_idx, Register z,
1292                              Register carry, Register product,
1293                              Register idx, Register kdx);
1294   void multiply_128_x_128_loop(Register y, Register z,
1295                                Register carry, Register carry2,
1296                                Register idx, Register jdx,
1297                                Register yz_idx1, Register yz_idx2,
1298                                Register tmp, Register tmp3, Register tmp4,
1299                                Register tmp7, Register product_hi);
1300   void kernel_crc32_using_crc32(Register crc, Register buf,
1301         Register len, Register tmp0, Register tmp1, Register tmp2,
1302         Register tmp3);
1303   void kernel_crc32c_using_crc32c(Register crc, Register buf,
1304         Register len, Register tmp0, Register tmp1, Register tmp2,
1305         Register tmp3);
1306 public:
1307   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z,
1308                        Register zlen, Register tmp1, Register tmp2, Register tmp3,
1309                        Register tmp4, Register tmp5, Register tmp6, Register tmp7);
1310   void mul_add(Register out, Register in, Register offs, Register len, Register k);
1311   // ISB may be needed because of a safepoint
1312   void maybe_isb() { isb(); }
1313 
1314 private:
1315   // Return the effective address r + (r1 &lt;&lt; ext) + offset.
1316   // Uses rscratch2.
1317   Address offsetted_address(Register r, Register r1, Address::extend ext,
1318                             int offset, int size);
1319 
1320 private:
1321   // Returns an address on the stack which is reachable with a ldr/str of size
1322   // Uses rscratch2 if the address is not directly reachable
1323   Address spill_address(int size, int offset, Register tmp=rscratch2);
1324 
1325   bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
1326 
1327   // Check whether two loads/stores can be merged into ldp/stp.
1328   bool ldst_can_merge(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store) const;
1329 
1330   // Merge current load/store with previous load/store into ldp/stp.
1331   void merge_ldst(Register rx, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1332 
1333   // Try to merge two loads/stores into ldp/stp. If success, returns true else false.
1334   bool try_merge_ldst(Register rt, const Address &amp;adr, size_t cur_size_in_bytes, bool is_store);
1335 
1336 public:
1337   void spill(Register Rx, bool is64, int offset) {
1338     if (is64) {
1339       str(Rx, spill_address(8, offset));
1340     } else {
1341       strw(Rx, spill_address(4, offset));
1342     }
1343   }
1344   void spill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1345     str(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1346   }
1347   void unspill(Register Rx, bool is64, int offset) {
1348     if (is64) {
1349       ldr(Rx, spill_address(8, offset));
1350     } else {
1351       ldrw(Rx, spill_address(4, offset));
1352     }
1353   }
1354   void unspill(FloatRegister Vx, SIMD_RegVariant T, int offset) {
1355     ldr(Vx, T, spill_address(1 &lt;&lt; (int)T, offset));
1356   }
1357   void spill_copy128(int src_offset, int dst_offset,
1358                      Register tmp1=rscratch1, Register tmp2=rscratch2) {
1359     if (src_offset &lt; 512 &amp;&amp; (src_offset &amp; 7) == 0 &amp;&amp;
1360         dst_offset &lt; 512 &amp;&amp; (dst_offset &amp; 7) == 0) {
1361       ldp(tmp1, tmp2, Address(sp, src_offset));
1362       stp(tmp1, tmp2, Address(sp, dst_offset));
1363     } else {
1364       unspill(tmp1, true, src_offset);
1365       spill(tmp1, true, dst_offset);
1366       unspill(tmp1, true, src_offset+8);
1367       spill(tmp1, true, dst_offset+8);
1368     }
1369   }
1370 
1371   void cache_wb(Address line);
1372   void cache_wbsync(bool is_pre);
1373 };
1374 
1375 #ifdef ASSERT
1376 inline bool AbstractAssembler::pd_check_instruction_mark() { return false; }
1377 #endif
1378 
1379 /**
1380  * class SkipIfEqual:
1381  *
1382  * Instantiating this class will result in assembly code being output that will
1383  * jump around any code emitted between the creation of the instance and it&#39;s
1384  * automatic destruction at the end of a scope block, depending on the value of
1385  * the flag passed to the constructor, which will be checked at run-time.
1386  */
1387 class SkipIfEqual {
1388  private:
1389   MacroAssembler* _masm;
1390   Label _label;
1391 
1392  public:
1393    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1394    ~SkipIfEqual();
1395 };
1396 
1397 struct tableswitch {
1398   Register _reg;
1399   int _insn_index; jint _first_key; jint _last_key;
1400   Label _after;
1401   Label _branches;
1402 };
1403 
1404 #endif // CPU_AARCH64_MACROASSEMBLER_AARCH64_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>