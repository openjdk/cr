<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/javaAssertions.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/stringTable.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  41 #include &quot;interpreter/bytecode.hpp&quot;
  42 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/referenceType.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/access.inline.hpp&quot;
  52 #include &quot;oops/constantPool.hpp&quot;
  53 #include &quot;oops/fieldStreams.inline.hpp&quot;
  54 #include &quot;oops/instanceKlass.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/recordComponent.hpp&quot;
  57 #include &quot;oops/objArrayKlass.hpp&quot;
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;prims/jvm_misc.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;prims/nativeLookup.hpp&quot;
  64 #include &quot;prims/stackwalk.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/init.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/deoptimization.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.inline.hpp&quot;
  77 #include &quot;runtime/perfData.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/synchronizer.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;runtime/threadSMR.hpp&quot;
  82 #include &quot;runtime/vframe.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
  84 #include &quot;runtime/vm_version.hpp&quot;
  85 #include &quot;services/attachListener.hpp&quot;
  86 #include &quot;services/management.hpp&quot;
  87 #include &quot;services/threadService.hpp&quot;
  88 #include &quot;utilities/copy.hpp&quot;
  89 #include &quot;utilities/defaultStream.hpp&quot;
  90 #include &quot;utilities/dtrace.hpp&quot;
  91 #include &quot;utilities/events.hpp&quot;
  92 #include &quot;utilities/histogram.hpp&quot;
  93 #include &quot;utilities/macros.hpp&quot;
  94 #include &quot;utilities/utf8.hpp&quot;
  95 #if INCLUDE_CDS
  96 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  97 #endif
  98 
  99 #include &lt;errno.h&gt;
 100 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
 101 
 102 /*
 103   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 104   such ctors and calls MUST NOT come between an oop declaration/init and its
 105   usage because if objects are move this may cause various memory stomps, bus
 106   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 107   failures&quot;:
 108 
 109       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 110           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 111 
 112           // Object address to be held directly in mirror &amp; not visible to GC
 113           oop mirror = JNIHandles::resolve_non_null(ofClass);
 114 
 115           // If this ctor can hit a safepoint, moving objects around, then
 116           ComplexConstructor foo;
 117 
 118           // Boom! mirror may point to JUNK instead of the intended object
 119           (some dereference of mirror)
 120 
 121           // Here&#39;s another call that may block for GC, making mirror stale
 122           MutexLocker ml(some_lock);
 123 
 124           // And here&#39;s an initializer that can result in a stale oop
 125           // all in one step.
 126           oop o = call_that_can_throw_exception(TRAPS);
 127 
 128 
 129   The solution is to keep the oop declaration BELOW the ctor or function
 130   call that might cause a GC, do another resolve to reassign the oop, or
 131   consider use of a Handle instead of an oop so there is immunity from object
 132   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 133   and thus can only support use of handles passed in.
 134 */
 135 
 136 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 137   ResourceMark rm;
 138   int line_number = -1;
 139   const char * source_file = NULL;
 140   const char * trace = &quot;explicit&quot;;
 141   InstanceKlass* caller = NULL;
 142   JavaThread* jthread = JavaThread::current();
 143   if (jthread-&gt;has_last_Java_frame()) {
 144     vframeStream vfst(jthread);
 145 
 146     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 147     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 148     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 149     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 150     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 151 
 152     Method* last_caller = NULL;
 153 
 154     while (!vfst.at_end()) {
 155       Method* m = vfst.method();
 156       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 157           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 158           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 159         break;
 160       }
 161       last_caller = m;
 162       vfst.next();
 163     }
 164     // if this is called from Class.forName0 and that is called from Class.forName,
 165     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 166     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 167     bool found_it = false;
 168     if (!vfst.at_end() &amp;&amp;
 169         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 170         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 171       vfst.next();
 172       if (!vfst.at_end() &amp;&amp;
 173           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 174           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 175         vfst.next();
 176         found_it = true;
 177       }
 178     } else if (last_caller != NULL &amp;&amp;
 179                last_caller-&gt;method_holder()-&gt;name() ==
 180                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 181                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 182       found_it = true;
 183     } else if (!vfst.at_end()) {
 184       if (vfst.method()-&gt;is_native()) {
 185         // JNI call
 186         found_it = true;
 187       }
 188     }
 189     if (found_it &amp;&amp; !vfst.at_end()) {
 190       // found the caller
 191       caller = vfst.method()-&gt;method_holder();
 192       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 193       if (line_number == -1) {
 194         // show method name if it&#39;s a native method
 195         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 196       }
 197       Symbol* s = caller-&gt;source_file_name();
 198       if (s != NULL) {
 199         source_file = s-&gt;as_C_string();
 200       }
 201     }
 202   }
 203   if (caller != NULL) {
 204     if (to_class != caller) {
 205       const char * from = caller-&gt;external_name();
 206       const char * to = to_class-&gt;external_name();
 207       // print in a single call to reduce interleaving between threads
 208       if (source_file != NULL) {
 209         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 210       } else {
 211         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 212       }
 213     }
 214   }
 215 }
 216 
 217 void trace_class_resolution(Klass* to_class) {
 218   EXCEPTION_MARK;
 219   trace_class_resolution_impl(to_class, THREAD);
 220   if (HAS_PENDING_EXCEPTION) {
 221     CLEAR_PENDING_EXCEPTION;
 222   }
 223 }
 224 
 225 // Wrapper to trace JVM functions
 226 
 227 #ifdef ASSERT
 228   Histogram* JVMHistogram;
 229   volatile int JVMHistogram_lock = 0;
 230 
 231   class JVMHistogramElement : public HistogramElement {
 232     public:
 233      JVMHistogramElement(const char* name);
 234   };
 235 
 236   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 237     _name = elementName;
 238     uintx count = 0;
 239 
 240     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 241       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 242         count +=1;
 243         if ( (WarnOnStalledSpinLock &gt; 0)
 244           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 245           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 246         }
 247       }
 248      }
 249 
 250     if(JVMHistogram == NULL)
 251       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 252 
 253     JVMHistogram-&gt;add_element(this);
 254     Atomic::dec(&amp;JVMHistogram_lock);
 255   }
 256 
 257   #define JVMCountWrapper(arg) \
 258       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 259       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 260 
 261   #define JVMWrapper(arg) JVMCountWrapper(arg);
 262 #else
 263   #define JVMWrapper(arg)
 264 #endif
 265 
 266 
 267 // Interface version /////////////////////////////////////////////////////////////////////
 268 
 269 
 270 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 271   return JVM_INTERFACE_VERSION;
 272 JVM_END
 273 
 274 
 275 // java.lang.System //////////////////////////////////////////////////////////////////////
 276 
 277 
 278 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 279   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 280   return os::javaTimeMillis();
 281 JVM_END
 282 
 283 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 284   JVMWrapper(&quot;JVM_NanoTime&quot;);
 285   return os::javaTimeNanos();
 286 JVM_END
 287 
 288 // The function below is actually exposed by jdk.internal.misc.VM and not
 289 // java.lang.System, but we choose to keep it here so that it stays next
 290 // to JVM_CurrentTimeMillis and JVM_NanoTime
 291 
 292 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 293 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 294 
 295 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 296   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 297   jlong seconds;
 298   jlong nanos;
 299 
 300   os::javaTimeSystemUTC(seconds, nanos);
 301 
 302   // We&#39;re going to verify that the result can fit in a long.
 303   // For that we need the difference in seconds between &#39;seconds&#39;
 304   // and &#39;offset_secs&#39; to be such that:
 305   //     |seconds - offset_secs| &lt; (2^63/10^9)
 306   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 307   // which makes |seconds - offset_secs| &lt; 2^33
 308   // and we will prefer +/- 2^32 as the maximum acceptable diff
 309   // as 2^32 has a more natural feel than 2^33...
 310   //
 311   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 312   // sentinel value (-1) which the caller should take as an
 313   // exception value indicating that the offset given to us is
 314   // too far from range of the current time - leading to too big
 315   // a nano adjustment. The caller is expected to recover by
 316   // computing a more accurate offset and calling this method
 317   // again. (For the record 2^32 secs is ~136 years, so that
 318   // should rarely happen)
 319   //
 320   jlong diff = seconds - offset_secs;
 321   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 322      return -1; // sentinel value: the offset is too far off the target
 323   }
 324 
 325   // return the adjustment. If you compute a time by adding
 326   // this number of nanoseconds along with the number of seconds
 327   // in the offset you should get the current UTC time.
 328   return (diff * (jlong)1000000000) + nanos;
 329 JVM_END
 330 
 331 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 332                                jobject dst, jint dst_pos, jint length))
 333   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 334   // Check if we have null pointers
 335   if (src == NULL || dst == NULL) {
 336     THROW(vmSymbols::java_lang_NullPointerException());
 337   }
 338   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 339   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 340   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 341   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 342   // Do copy
 343   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 344 JVM_END
 345 
 346 
 347 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 348   JavaValue r(T_OBJECT);
 349   // public synchronized Object put(Object key, Object value);
 350   HandleMark hm(THREAD);
 351   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 352   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 353   JavaCalls::call_virtual(&amp;r,
 354                           props,
 355                           SystemDictionary::Properties_klass(),
 356                           vmSymbols::put_name(),
 357                           vmSymbols::object_object_object_signature(),
 358                           key_str,
 359                           value_str,
 360                           THREAD);
 361 }
 362 
 363 
 364 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 365 
 366 /*
 367  * Return all of the system properties in a Java String array with alternating
 368  * names and values from the jvm SystemProperty.
 369  * Which includes some internal and all commandline -D defined properties.
 370  */
 371 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 372   JVMWrapper(&quot;JVM_GetProperties&quot;);
 373   ResourceMark rm(THREAD);
 374   HandleMark hm(THREAD);
 375   int ndx = 0;
 376   int fixedCount = 2;
 377 
 378   SystemProperty* p = Arguments::system_properties();
 379   int count = Arguments::PropertyList_count(p);
 380 
 381   // Allocate result String array
 382   InstanceKlass* ik = SystemDictionary::String_klass();
 383   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 384   objArrayHandle result_h(THREAD, r);
 385 
 386   while (p != NULL) {
 387     const char * key = p-&gt;key();
 388     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 389         const char * value = p-&gt;value();
 390         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 391         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 392         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 393         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 394         ndx++;
 395     }
 396     p = p-&gt;next();
 397   }
 398 
 399   // Convert the -XX:MaxDirectMemorySize= command line flag
 400   // to the sun.nio.MaxDirectMemorySize property.
 401   // Do this after setting user properties to prevent people
 402   // from setting the value with a -D option, as requested.
 403   // Leave empty if not supplied
 404   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 405     char as_chars[256];
 406     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 407     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 408     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 409     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 410     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 411     ndx++;
 412   }
 413 
 414   // JVM monitoring and management support
 415   // Add the sun.management.compiler property for the compiler&#39;s name
 416   {
 417 #undef CSIZE
 418 #if defined(_LP64) || defined(_WIN64)
 419   #define CSIZE &quot;64-Bit &quot;
 420 #else
 421   #define CSIZE
 422 #endif // 64bit
 423 
 424 #ifdef TIERED
 425     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 426 #else
 427 #if defined(COMPILER1)
 428     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 429 #elif defined(COMPILER2)
 430     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 431 #elif INCLUDE_JVMCI
 432     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 433 #else
 434     const char* compiler_name = &quot;&quot;;
 435 #endif // compilers
 436 #endif // TIERED
 437 
 438     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 439         (Arguments::mode() != Arguments::_int)) {
 440       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 441       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 442       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 443       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 444       ndx++;
 445     }
 446   }
 447 
 448   return (jobjectArray) JNIHandles::make_local(env, result_h());
 449 JVM_END
 450 
 451 
 452 /*
 453  * Return the temporary directory that the VM uses for the attach
 454  * and perf data files.
 455  *
 456  * It is important that this directory is well-known and the
 457  * same for all VM instances. It cannot be affected by configuration
 458  * variables such as java.io.tmpdir.
 459  */
 460 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 461   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 462   HandleMark hm(THREAD);
 463   const char* temp_dir = os::get_temp_directory();
 464   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 465   return (jstring) JNIHandles::make_local(env, h());
 466 JVM_END
 467 
 468 
 469 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 470 
 471 extern volatile jint vm_created;
 472 
 473 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 474   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 475   // Link all classes for dynamic CDS dumping before vm exit.
 476   if (DynamicDumpSharedSpaces) {
 477     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 478   }
 479   EventShutdown event;
 480   if (event.should_commit()) {
 481     event.set_reason(&quot;Shutdown requested from Java&quot;);
 482     event.commit();
 483   }
 484 JVM_END
 485 
 486 
 487 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 488   before_exit(thread);
 489   vm_exit(code);
 490 JVM_END
 491 
 492 
 493 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 494   JVMWrapper(&quot;JVM_GC&quot;);
 495   if (!DisableExplicitGC) {
<a name="1" id="anc1"></a>




 496     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 497   }
 498 JVM_END
 499 
 500 
 501 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 502   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 503   return Universe::heap()-&gt;millis_since_last_gc();
 504 JVM_END
 505 
 506 
 507 static inline jlong convert_size_t_to_jlong(size_t val) {
 508   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 509   NOT_LP64 (return (jlong)val;)
 510   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 511 }
 512 
 513 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 514   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 515   size_t n = Universe::heap()-&gt;capacity();
 516   return convert_size_t_to_jlong(n);
 517 JVM_END
 518 
 519 
 520 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 521   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 522   size_t n = Universe::heap()-&gt;unused();
 523   return convert_size_t_to_jlong(n);
 524 JVM_END
 525 
 526 
 527 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 528   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 529   size_t n = Universe::heap()-&gt;max_capacity();
 530   return convert_size_t_to_jlong(n);
 531 JVM_END
 532 
 533 
 534 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 535   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 536   return os::active_processor_count();
 537 JVM_END
 538 
 539 
 540 
 541 // java.lang.Throwable //////////////////////////////////////////////////////
 542 
 543 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 544   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 545   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 546   java_lang_Throwable::fill_in_stack_trace(exception);
 547 JVM_END
 548 
 549 // java.lang.NullPointerException ///////////////////////////////////////////
 550 
 551 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 552   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 553 
 554   oop exc = JNIHandles::resolve_non_null(throwable);
 555 
 556   Method* method;
 557   int bci;
 558   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 559     return NULL;
 560   }
 561   if (method-&gt;is_native()) {
 562     return NULL;
 563   }
 564 
 565   stringStream ss;
 566   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 567   if (ok) {
 568     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 569     return (jstring) JNIHandles::make_local(env, result);
 570   } else {
 571     return NULL;
 572   }
 573 JVM_END
 574 
 575 // java.lang.StackTraceElement //////////////////////////////////////////////
 576 
 577 
 578 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 579   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 580   Handle exception(THREAD, JNIHandles::resolve(throwable));
 581   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 582   objArrayHandle stack_trace(THREAD, st);
 583   // Fill in the allocated stack trace
 584   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 585 JVM_END
 586 
 587 
 588 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 589   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 590   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 591   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 592   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 593 JVM_END
 594 
 595 
 596 // java.lang.StackWalker //////////////////////////////////////////////////////
 597 
 598 
 599 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 600                                      jint skip_frames, jint frame_count, jint start_index,
 601                                      jobjectArray frames))
 602   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 603   JavaThread* jt = (JavaThread*) THREAD;
 604   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 605     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 606   }
 607 
 608   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 609 
 610   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 611   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 612   // be null.
 613   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 614   objArrayHandle frames_array_h(THREAD, fa);
 615 
 616   int limit = start_index + frame_count;
 617   if (frames_array_h-&gt;length() &lt; limit) {
 618     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 619   }
 620 
 621   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 622                                start_index, frames_array_h, CHECK_NULL);
 623   return JNIHandles::make_local(env, result);
 624 JVM_END
 625 
 626 
 627 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 628                                   jint frame_count, jint start_index,
 629                                   jobjectArray frames))
 630   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 631   JavaThread* jt = (JavaThread*) THREAD;
 632 
 633   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 634   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 635   // be null.
 636   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 637   objArrayHandle frames_array_h(THREAD, fa);
 638 
 639   int limit = start_index+frame_count;
 640   if (frames_array_h-&gt;length() &lt; limit) {
 641     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 642   }
 643 
 644   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 645   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 646                                    start_index, frames_array_h, THREAD);
 647 JVM_END
 648 
 649 // java.lang.Object ///////////////////////////////////////////////
 650 
 651 
 652 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 653   JVMWrapper(&quot;JVM_IHashCode&quot;);
 654   // as implemented in the classic virtual machine; return 0 if object is NULL
 655   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 656 JVM_END
 657 
 658 
 659 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 660   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 661   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 662   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 663   if (JvmtiExport::should_post_monitor_wait()) {
 664     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 665 
 666     // The current thread already owns the monitor and it has not yet
 667     // been added to the wait queue so the current thread cannot be
 668     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 669     // event handler cannot accidentally consume an unpark() meant for
 670     // the ParkEvent associated with this ObjectMonitor.
 671   }
 672   ObjectSynchronizer::wait(obj, ms, CHECK);
 673 JVM_END
 674 
 675 
 676 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 677   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 678   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 679   ObjectSynchronizer::notify(obj, CHECK);
 680 JVM_END
 681 
 682 
 683 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 684   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 685   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 686   ObjectSynchronizer::notifyall(obj, CHECK);
 687 JVM_END
 688 
 689 
 690 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 691   JVMWrapper(&quot;JVM_Clone&quot;);
 692   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 693   Klass* klass = obj-&gt;klass();
 694   JvmtiVMObjectAllocEventCollector oam;
 695 
 696 #ifdef ASSERT
 697   // Just checking that the cloneable flag is set correct
 698   if (obj-&gt;is_array()) {
 699     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 700   } else {
 701     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 702     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 703     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 704   }
 705 #endif
 706 
 707   // Check if class of obj supports the Cloneable interface.
 708   // All arrays are considered to be cloneable (See JLS 20.1.5).
 709   // All j.l.r.Reference classes are considered non-cloneable.
 710   if (!klass-&gt;is_cloneable() ||
 711       (klass-&gt;is_instance_klass() &amp;&amp;
 712        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 713     ResourceMark rm(THREAD);
 714     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 715   }
 716 
 717   // Make shallow object copy
 718   const int size = obj-&gt;size();
 719   oop new_obj_oop = NULL;
 720   if (obj-&gt;is_array()) {
 721     const int length = ((arrayOop)obj())-&gt;length();
 722     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 723                                                    /* do_zero */ true, CHECK_NULL);
 724   } else {
 725     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 726   }
 727 
 728   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 729 
 730   Handle new_obj(THREAD, new_obj_oop);
 731   // Caution: this involves a java upcall, so the clone should be
 732   // &quot;gc-robust&quot; by this stage.
 733   if (klass-&gt;has_finalizer()) {
 734     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 735     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 736     new_obj = Handle(THREAD, new_obj_oop);
 737   }
 738 
 739   return JNIHandles::make_local(env, new_obj());
 740 JVM_END
 741 
 742 // java.io.File ///////////////////////////////////////////////////////////////
 743 
 744 JVM_LEAF(char*, JVM_NativePath(char* path))
 745   JVMWrapper(&quot;JVM_NativePath&quot;);
 746   return os::native_path(path);
 747 JVM_END
 748 
 749 
 750 // Misc. class handling ///////////////////////////////////////////////////////////
 751 
 752 
 753 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 754   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 755 
 756   // Getting the class of the caller frame.
 757   //
 758   // The call stack at this point looks something like this:
 759   //
 760   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 761   // [1] [ @CallerSensitive API.method                                   ]
 762   // [.] [ (skipped intermediate frames)                                 ]
 763   // [n] [ caller                                                        ]
 764   vframeStream vfst(thread);
 765   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 766   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 767     Method* m = vfst.method();
 768     assert(m != NULL, &quot;sanity&quot;);
 769     switch (n) {
 770     case 0:
 771       // This must only be called from Reflection.getCallerClass
 772       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 773         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 774       }
 775       // fall-through
 776     case 1:
 777       // Frame 0 and 1 must be caller sensitive.
 778       if (!m-&gt;caller_sensitive()) {
 779         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 780       }
 781       break;
 782     default:
 783       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 784         // We have reached the desired frame; return the holder class.
 785         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 786       }
 787       break;
 788     }
 789   }
 790   return NULL;
 791 JVM_END
 792 
 793 
 794 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 795   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 796   oop mirror = NULL;
 797   BasicType t = name2type(utf);
 798   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 799     mirror = Universe::java_mirror(t);
 800   }
 801   if (mirror == NULL) {
 802     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 803   } else {
 804     return (jclass) JNIHandles::make_local(env, mirror);
 805   }
 806 JVM_END
 807 
 808 
 809 // Returns a class loaded by the bootstrap class loader; or null
 810 // if not found.  ClassNotFoundException is not thrown.
 811 // FindClassFromBootLoader is exported to the launcher for windows.
 812 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 813                                               const char* name))
 814   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 815 
 816   // Java libraries should ensure that name is never null or illegal.
 817   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 818     // It&#39;s impossible to create this class;  the name cannot fit
 819     // into the constant pool.
 820     return NULL;
 821   }
 822   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), &quot;illegal UTF name&quot;);
 823 
 824   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 825   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 826   if (k == NULL) {
 827     return NULL;
 828   }
 829 
 830   if (log_is_enabled(Debug, class, resolve)) {
 831     trace_class_resolution(k);
 832   }
 833   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 834 JVM_END
 835 
 836 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 837 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 838                                           jboolean init, jobject loader,
 839                                           jclass caller))
 840   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 841 
 842   TempNewSymbol h_name =
 843        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 844                                            CHECK_NULL);
 845 
 846   oop loader_oop = JNIHandles::resolve(loader);
 847   oop from_class = JNIHandles::resolve(caller);
 848   oop protection_domain = NULL;
 849   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 850   // NPE. Put it in another way, the bootstrap class loader has all permission and
 851   // thus no checkPackageAccess equivalence in the VM class loader.
 852   // The caller is also passed as NULL by the java code if there is no security
 853   // manager to avoid the performance cost of getting the calling class.
 854   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 855     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 856   }
 857 
 858   Handle h_loader(THREAD, loader_oop);
 859   Handle h_prot(THREAD, protection_domain);
 860   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 861                                                h_prot, false, THREAD);
 862 
 863   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 864     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 865   }
 866   return result;
 867 JVM_END
 868 
 869 // Currently only called from the old verifier.
 870 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 871                                          jboolean init, jclass from))
 872   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 873   TempNewSymbol h_name =
 874        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 875                                            CHECK_NULL);
 876   oop from_class_oop = JNIHandles::resolve(from);
 877   Klass* from_class = (from_class_oop == NULL)
 878                            ? (Klass*)NULL
 879                            : java_lang_Class::as_Klass(from_class_oop);
 880   oop class_loader = NULL;
 881   oop protection_domain = NULL;
 882   if (from_class != NULL) {
 883     class_loader = from_class-&gt;class_loader();
 884     protection_domain = from_class-&gt;protection_domain();
 885   }
 886   Handle h_loader(THREAD, class_loader);
 887   Handle h_prot  (THREAD, protection_domain);
 888   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 889                                                h_prot, true, thread);
 890 
 891   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 892     // this function is generally only used for class loading during verification.
 893     ResourceMark rm;
 894     oop from_mirror = JNIHandles::resolve_non_null(from);
 895     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 896     const char * from_name = from_class-&gt;external_name();
 897 
 898     oop mirror = JNIHandles::resolve_non_null(result);
 899     Klass* to_class = java_lang_Class::as_Klass(mirror);
 900     const char * to = to_class-&gt;external_name();
 901     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 902   }
 903 
 904   return result;
 905 JVM_END
 906 
 907 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 908   if (loader.is_null()) {
 909     return;
 910   }
 911 
 912   // check whether the current caller thread holds the lock or not.
 913   // If not, increment the corresponding counter
 914   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 915       ObjectSynchronizer::owner_self) {
 916     counter-&gt;inc();
 917   }
 918 }
 919 
 920 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 921 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 922                                       jobject loader, const jbyte *buf,
 923                                       jsize len, jobject pd, const char *source,
 924                                       TRAPS) {
 925   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 926 
 927   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 928   JavaThread* jt = (JavaThread*) THREAD;
 929 
 930   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 931                              ClassLoader::perf_define_appclass_selftime(),
 932                              ClassLoader::perf_define_appclasses(),
 933                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 934                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 935                              PerfClassTraceTime::DEFINE_CLASS);
 936 
 937   if (UsePerfData) {
 938     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 939   }
 940 
 941   // Class resolution will get the class name from the .class stream if the name is null.
 942   TempNewSymbol class_name = name == NULL ? NULL :
 943        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 944                                            CHECK_NULL);
 945 
 946   ResourceMark rm(THREAD);
 947   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 948   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 949   if (UsePerfData) {
 950     is_lock_held_by_thread(class_loader,
 951                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 952                            THREAD);
 953   }
 954   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 955   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 956                                                    class_loader,
 957                                                    protection_domain,
 958                                                    &amp;st,
 959                                                    CHECK_NULL);
 960 
 961   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 962     trace_class_resolution(k);
 963   }
 964 
 965   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 966 }
 967 
 968 enum {
 969   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 970   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 971   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
 972   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
 973 };
 974 
 975 /*
 976  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
 977  * hidden, or strongly referenced from class loader.
 978  */
 979 static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
 980                                       const jbyte *buf, jsize len, jobject pd,
 981                                       jboolean init, int flags, jobject classData, TRAPS) {
 982   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 983   JavaThread* jt = (JavaThread*) THREAD;
 984   ResourceMark rm(THREAD);
 985 
 986   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
 987   // Lookup class must be a non-null instance
 988   if (lookup_k == NULL) {
 989     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
 990   }
 991   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
 992 
 993   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
 994 
 995   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
 996   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
 997   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
 998   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
 999 
1000   InstanceKlass* host_class = NULL;
1001   if (is_nestmate) {
1002     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1003   }
1004 
1005   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1006                              name,
1007                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1008                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1009                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1010                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1011                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1012 
1013   if (!is_hidden) {
1014     // classData is only applicable for hidden classes
1015     if (classData != NULL) {
1016       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1017     }
1018     if (is_nestmate) {
1019       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1020     }
1021     if (!is_strong) {
1022       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1023     }
1024     if (vm_annotations) {
1025       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1026     }
1027     if (flags != STRONG_LOADER_LINK) {
1028       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1029                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1030     }
1031   }
1032 
1033   // Class resolution will get the class name from the .class stream if the name is null.
1034   TempNewSymbol class_name = name == NULL ? NULL :
1035        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
1036                                            CHECK_NULL);
1037 
1038   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1039   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1040   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1041 
1042   Klass* defined_k;
1043   InstanceKlass* ik = NULL;
1044   if (!is_hidden) {
1045     defined_k = SystemDictionary::resolve_from_stream(class_name,
1046                                                       class_loader,
1047                                                       protection_domain,
1048                                                       &amp;st,
1049                                                       CHECK_NULL);
1050 
1051     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1052       trace_class_resolution(defined_k);
1053     }
1054     ik = InstanceKlass::cast(defined_k);
1055   } else { // hidden
1056     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1057     ClassLoadInfo cl_info(protection_domain,
1058                           NULL, // unsafe_anonymous_host
1059                           NULL, // cp_patches
1060                           host_class,
1061                           classData_h,
1062                           is_hidden,
1063                           is_strong,
1064                           vm_annotations);
1065     defined_k = SystemDictionary::parse_stream(class_name,
1066                                                class_loader,
1067                                                &amp;st,
1068                                                cl_info,
1069                                                CHECK_NULL);
1070     if (defined_k == NULL) {
1071       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1072     }
1073 
1074     ik = InstanceKlass::cast(defined_k);
1075 
1076     // The hidden class loader data has been artificially been kept alive to
1077     // this point. The mirror and any instances of this class have to keep
1078     // it alive afterwards.
1079     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1080 
1081     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1082       ModuleEntry* module = ik-&gt;module();
1083       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1084       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1085                                   module_name,
1086                                   ik-&gt;external_name(),
1087                                   host_class-&gt;external_name(),
1088                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1089     }
1090   }
1091   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1092          &quot;lookup class and defined class are in different packages&quot;);
1093 
1094   if (init) {
1095     ik-&gt;initialize(CHECK_NULL);
1096   } else {
1097     ik-&gt;link_class(CHECK_NULL);
1098   }
1099 
1100   return (jclass) JNIHandles::make_local(env, defined_k-&gt;java_mirror());
1101 }
1102 
1103 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1104   JVMWrapper(&quot;JVM_DefineClass&quot;);
1105 
1106   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1107 JVM_END
1108 
1109 /*
1110  * Define a class with the specified lookup class.
1111  *  lookup:  Lookup class
1112  *  name:    the name of the class
1113  *  buf:     class bytes
1114  *  len:     length of class bytes
1115  *  pd:      protection domain
1116  *  init:    initialize the class
1117  *  flags:   properties of the class
1118  *  classData: private static pre-initialized field
1119  */
1120 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1121           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1122   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1123 
1124   if (lookup == NULL) {
1125     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1126   }
1127 
1128   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1129 
1130   return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1131 JVM_END
1132 
1133 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1134   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1135 
1136   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1137 JVM_END
1138 
1139 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1140   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1141   ResourceMark rm(THREAD);
1142 
1143   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1144   char* str = java_lang_String::as_utf8_string(h_name());
1145 
1146   // Sanity check, don&#39;t expect null
1147   if (str == NULL) return NULL;
1148 
1149   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1150   char* p = (char*)str;
1151   while (*p != &#39;\0&#39;) {
1152       if (*p == &#39;.&#39;) {
1153           *p = &#39;/&#39;;
1154       }
1155       p++;
1156   }
1157 
1158   const int str_len = (int)(p - str);
1159   if (str_len &gt; Symbol::max_length()) {
1160     // It&#39;s impossible to create this class;  the name cannot fit
1161     // into the constant pool.
1162     return NULL;
1163   }
1164   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1165 
1166   // Security Note:
1167   //   The Java level wrapper will perform the necessary security check allowing
1168   //   us to pass the NULL as the initiating class loader.
1169   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1170   if (UsePerfData) {
1171     is_lock_held_by_thread(h_loader,
1172                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1173                            THREAD);
1174   }
1175 
1176   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1177                                                               h_loader,
1178                                                               Handle(),
1179                                                               CHECK_NULL);
1180 #if INCLUDE_CDS
1181   if (k == NULL) {
1182     // If the class is not already loaded, try to see if it&#39;s in the shared
1183     // archive for the current classloader (h_loader).
1184     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1185   }
1186 #endif
1187   return (k == NULL) ? NULL :
1188             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1189 JVM_END
1190 
1191 // Module support //////////////////////////////////////////////////////////////////////////////
1192 
1193 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1194                                  jstring location, jobjectArray packages))
1195   JVMWrapper(&quot;JVM_DefineModule&quot;);
1196   Modules::define_module(module, is_open, version, location, packages, CHECK);
1197 JVM_END
1198 
1199 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1200   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1201   Modules::set_bootloader_unnamed_module(module, CHECK);
1202 JVM_END
1203 
1204 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1205   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1206   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1207 JVM_END
1208 
1209 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1210   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1211   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1212 JVM_END
1213 
1214 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1215   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1216   Modules::add_module_exports(from_module, package, NULL, CHECK);
1217 JVM_END
1218 
1219 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1220   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1221   Modules::add_reads_module(from_module, source_module, CHECK);
1222 JVM_END
1223 
1224 // Reflection support //////////////////////////////////////////////////////////////////////////////
1225 
1226 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1227   assert (cls != NULL, &quot;illegal class&quot;);
1228   JVMWrapper(&quot;JVM_InitClassName&quot;);
1229   JvmtiVMObjectAllocEventCollector oam;
1230   ResourceMark rm(THREAD);
1231   HandleMark hm(THREAD);
1232   Handle java_class(THREAD, JNIHandles::resolve(cls));
1233   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1234   return (jstring) JNIHandles::make_local(env, result);
1235 JVM_END
1236 
1237 
1238 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1239   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1240   JvmtiVMObjectAllocEventCollector oam;
1241   oop mirror = JNIHandles::resolve_non_null(cls);
1242 
1243   // Special handling for primitive objects
1244   if (java_lang_Class::is_primitive(mirror)) {
1245     // Primitive objects does not have any interfaces
1246     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1247     return (jobjectArray) JNIHandles::make_local(env, r);
1248   }
1249 
1250   Klass* klass = java_lang_Class::as_Klass(mirror);
1251   // Figure size of result array
1252   int size;
1253   if (klass-&gt;is_instance_klass()) {
1254     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1255   } else {
1256     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1257     size = 2;
1258   }
1259 
1260   // Allocate result array
1261   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1262   objArrayHandle result (THREAD, r);
1263   // Fill in result
1264   if (klass-&gt;is_instance_klass()) {
1265     // Regular instance klass, fill in all local interfaces
1266     for (int index = 0; index &lt; size; index++) {
1267       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1268       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1269     }
1270   } else {
1271     // All arrays implement java.lang.Cloneable and java.io.Serializable
1272     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1273     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1274   }
1275   return (jobjectArray) JNIHandles::make_local(env, result());
1276 JVM_END
1277 
1278 
1279 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1280   JVMWrapper(&quot;JVM_IsInterface&quot;);
1281   oop mirror = JNIHandles::resolve_non_null(cls);
1282   if (java_lang_Class::is_primitive(mirror)) {
1283     return JNI_FALSE;
1284   }
1285   Klass* k = java_lang_Class::as_Klass(mirror);
1286   jboolean result = k-&gt;is_interface();
1287   assert(!result || k-&gt;is_instance_klass(),
1288          &quot;all interfaces are instance types&quot;);
1289   // The compiler intrinsic for isInterface tests the
1290   // Klass::_access_flags bits in the same way.
1291   return result;
1292 JVM_END
1293 
1294 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1295   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1296   oop mirror = JNIHandles::resolve_non_null(cls);
1297   if (java_lang_Class::is_primitive(mirror)) {
1298     return JNI_FALSE;
1299   }
1300   Klass* k = java_lang_Class::as_Klass(mirror);
1301   return k-&gt;is_hidden();
1302 JVM_END
1303 
1304 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1305   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1306   JvmtiVMObjectAllocEventCollector oam;
1307   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1308     // There are no signers for primitive types
1309     return NULL;
1310   }
1311 
1312   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1313 
1314   // If there are no signers set in the class, or if the class
1315   // is an array, return NULL.
1316   if (signers == NULL) return NULL;
1317 
1318   // copy of the signers array
1319   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1320   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1321   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1322     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1323   }
1324 
1325   // return the copy
1326   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1327 JVM_END
1328 
1329 
1330 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1331   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1332   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1333     // This call is ignored for primitive types and arrays.
1334     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1335     // be called with an array.  Only the bootstrap loader creates arrays.
1336     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1337     if (k-&gt;is_instance_klass()) {
1338       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1339     }
1340   }
1341 JVM_END
1342 
1343 
1344 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1345   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1346   if (JNIHandles::resolve(cls) == NULL) {
1347     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1348   }
1349 
1350   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1351     // Primitive types does not have a protection domain.
1352     return NULL;
1353   }
1354 
1355   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1356   return (jobject) JNIHandles::make_local(env, pd);
1357 JVM_END
1358 
1359 
1360 // Returns the inherited_access_control_context field of the running thread.
1361 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1362   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1363   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1364   return JNIHandles::make_local(env, result);
1365 JVM_END
1366 
1367 class RegisterArrayForGC {
1368  private:
1369   JavaThread *_thread;
1370  public:
1371   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1372     _thread = thread;
1373     _thread-&gt;register_array_for_gc(array);
1374   }
1375 
1376   ~RegisterArrayForGC() {
1377     _thread-&gt;register_array_for_gc(NULL);
1378   }
1379 };
1380 
1381 
1382 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1383   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1384   if (!UsePrivilegedStack) return NULL;
1385 
1386   ResourceMark rm(THREAD);
1387   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1388   JvmtiVMObjectAllocEventCollector oam;
1389 
1390   // count the protection domains on the execution stack. We collapse
1391   // duplicate consecutive protection domains into a single one, as
1392   // well as stopping when we hit a privileged frame.
1393 
1394   oop previous_protection_domain = NULL;
1395   Handle privileged_context(thread, NULL);
1396   bool is_privileged = false;
1397   oop protection_domain = NULL;
1398 
1399   // Iterate through Java frames
1400   vframeStream vfst(thread);
1401   for(; !vfst.at_end(); vfst.next()) {
1402     // get method of frame
1403     Method* method = vfst.method();
1404 
1405     // stop at the first privileged frame
1406     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1407       method-&gt;name() == vmSymbols::executePrivileged_name())
1408     {
1409       // this frame is privileged
1410       is_privileged = true;
1411 
1412       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1413 
1414       StackValueCollection* locals = priv-&gt;locals();
1415       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1416       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1417       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1418       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1419       privileged_context    = ctx_sv-&gt;get_obj();
1420       Handle caller         = clr_sv-&gt;get_obj();
1421 
1422       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1423       protection_domain  = caller_klass-&gt;protection_domain();
1424     } else {
1425       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1426     }
1427 
1428     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1429       local_array-&gt;push(protection_domain);
1430       previous_protection_domain = protection_domain;
1431     }
1432 
1433     if (is_privileged) break;
1434   }
1435 
1436 
1437   // either all the domains on the stack were system domains, or
1438   // we had a privileged system domain
1439   if (local_array-&gt;is_empty()) {
1440     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1441 
1442     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1443     return JNIHandles::make_local(env, result);
1444   }
1445 
1446   // the resource area must be registered in case of a gc
1447   RegisterArrayForGC ragc(thread, local_array);
1448   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1449                                                  local_array-&gt;length(), CHECK_NULL);
1450   objArrayHandle h_context(thread, context);
1451   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1452     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1453   }
1454 
1455   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1456 
1457   return JNIHandles::make_local(env, result);
1458 JVM_END
1459 
1460 
1461 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1462   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1463   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1464   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1465 JVM_END
1466 
1467 
1468 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1469   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1470   oop mirror = JNIHandles::resolve_non_null(cls);
1471   return (jboolean) java_lang_Class::is_primitive(mirror);
1472 JVM_END
1473 
1474 
1475 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1476   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1477   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1478     // Primitive type
1479     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1480   }
1481 
1482   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1483   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1484   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1485   return k-&gt;modifier_flags();
1486 JVM_END
1487 
1488 
1489 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1490 
1491 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1492   JvmtiVMObjectAllocEventCollector oam;
1493   // ofClass is a reference to a java_lang_Class object. The mirror object
1494   // of an InstanceKlass
1495 
1496   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1497       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1498     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1499     return (jobjectArray)JNIHandles::make_local(env, result);
1500   }
1501 
1502   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1503   InnerClassesIterator iter(k);
1504 
1505   if (iter.length() == 0) {
1506     // Neither an inner nor outer class
1507     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1508     return (jobjectArray)JNIHandles::make_local(env, result);
1509   }
1510 
1511   // find inner class info
1512   constantPoolHandle cp(thread, k-&gt;constants());
1513   int length = iter.length();
1514 
1515   // Allocate temp. result array
1516   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1517   objArrayHandle result (THREAD, r);
1518   int members = 0;
1519 
1520   for (; !iter.done(); iter.next()) {
1521     int ioff = iter.inner_class_info_index();
1522     int ooff = iter.outer_class_info_index();
1523 
1524     if (ioff != 0 &amp;&amp; ooff != 0) {
1525       // Check to see if the name matches the class we&#39;re looking for
1526       // before attempting to find the class.
1527       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1528         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1529         if (outer_klass == k) {
1530            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1531            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1532 
1533            // Throws an exception if outer klass has not declared k as
1534            // an inner klass
1535            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1536 
1537            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1538            members++;
1539         }
1540       }
1541     }
1542   }
1543 
1544   if (members != length) {
1545     // Return array of right length
1546     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1547     for(int i = 0; i &lt; members; i++) {
1548       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1549     }
1550     return (jobjectArray)JNIHandles::make_local(env, res);
1551   }
1552 
1553   return (jobjectArray)JNIHandles::make_local(env, result());
1554 JVM_END
1555 
1556 
1557 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1558 {
1559   // ofClass is a reference to a java_lang_Class object.
1560   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1561       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1562     return NULL;
1563   }
1564 
1565   bool inner_is_member = false;
1566   Klass* outer_klass
1567     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1568                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1569   if (outer_klass == NULL)  return NULL;  // already a top-level class
1570   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1571   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1572 }
1573 JVM_END
1574 
1575 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1576 {
1577   oop mirror = JNIHandles::resolve_non_null(cls);
1578   if (java_lang_Class::is_primitive(mirror) ||
1579       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1580     return NULL;
1581   }
1582   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1583   int ooff = 0, noff = 0;
1584   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1585     if (noff != 0) {
1586       constantPoolHandle i_cp(thread, k-&gt;constants());
1587       Symbol* name = i_cp-&gt;symbol_at(noff);
1588       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1589       return (jstring) JNIHandles::make_local(env, str());
1590     }
1591   }
1592   return NULL;
1593 }
1594 JVM_END
1595 
1596 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1597   assert (cls != NULL, &quot;illegal class&quot;);
1598   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1599   JvmtiVMObjectAllocEventCollector oam;
1600   ResourceMark rm(THREAD);
1601   // Return null for arrays and primatives
1602   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1603     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1604     if (k-&gt;is_instance_klass()) {
1605       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1606       if (sym == NULL) return NULL;
1607       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1608       return (jstring) JNIHandles::make_local(env, str());
1609     }
1610   }
1611   return NULL;
1612 JVM_END
1613 
1614 
1615 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1616   assert (cls != NULL, &quot;illegal class&quot;);
1617   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1618 
1619   // Return null for arrays and primitives
1620   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1621     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1622     if (k-&gt;is_instance_klass()) {
1623       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1624       return (jbyteArray) JNIHandles::make_local(env, a);
1625     }
1626   }
1627   return NULL;
1628 JVM_END
1629 
1630 
1631 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1632   // some of this code was adapted from from jni_FromReflectedField
1633 
1634   oop reflected = JNIHandles::resolve_non_null(field);
1635   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1636   Klass* k    = java_lang_Class::as_Klass(mirror);
1637   int slot      = java_lang_reflect_Field::slot(reflected);
1638   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1639 
1640   InstanceKlass* ik = InstanceKlass::cast(k);
1641   intptr_t offset = ik-&gt;field_offset(slot);
1642 
1643   if (modifiers &amp; JVM_ACC_STATIC) {
1644     // for static fields we only look in the current class
1645     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1646       assert(false, &quot;cannot find static field&quot;);
1647       return false;
1648     }
1649   } else {
1650     // for instance fields we start with the current class and work
1651     // our way up through the superclass chain
1652     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1653       assert(false, &quot;cannot find instance field&quot;);
1654       return false;
1655     }
1656   }
1657   return true;
1658 }
1659 
1660 static Method* jvm_get_method_common(jobject method) {
1661   // some of this code was adapted from from jni_FromReflectedMethod
1662 
1663   oop reflected = JNIHandles::resolve_non_null(method);
1664   oop mirror    = NULL;
1665   int slot      = 0;
1666 
1667   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1668     mirror = java_lang_reflect_Constructor::clazz(reflected);
1669     slot   = java_lang_reflect_Constructor::slot(reflected);
1670   } else {
1671     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1672            &quot;wrong type&quot;);
1673     mirror = java_lang_reflect_Method::clazz(reflected);
1674     slot   = java_lang_reflect_Method::slot(reflected);
1675   }
1676   Klass* k = java_lang_Class::as_Klass(mirror);
1677 
1678   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1679   assert(m != NULL, &quot;cannot find method&quot;);
1680   return m;  // caller has to deal with NULL in product mode
1681 }
1682 
1683 /* Type use annotations support (JDK 1.8) */
1684 
1685 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1686   assert (cls != NULL, &quot;illegal class&quot;);
1687   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1688   ResourceMark rm(THREAD);
1689   // Return null for arrays and primitives
1690   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1691     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1692     if (k-&gt;is_instance_klass()) {
1693       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1694       if (type_annotations != NULL) {
1695         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1696         return (jbyteArray) JNIHandles::make_local(env, a);
1697       }
1698     }
1699   }
1700   return NULL;
1701 JVM_END
1702 
1703 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1704   assert (method != NULL, &quot;illegal method&quot;);
1705   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1706 
1707   // method is a handle to a java.lang.reflect.Method object
1708   Method* m = jvm_get_method_common(method);
1709   if (m == NULL) {
1710     return NULL;
1711   }
1712 
1713   AnnotationArray* type_annotations = m-&gt;type_annotations();
1714   if (type_annotations != NULL) {
1715     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1716     return (jbyteArray) JNIHandles::make_local(env, a);
1717   }
1718 
1719   return NULL;
1720 JVM_END
1721 
1722 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1723   assert (field != NULL, &quot;illegal field&quot;);
1724   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1725 
1726   fieldDescriptor fd;
1727   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1728   if (!gotFd) {
1729     return NULL;
1730   }
1731 
1732   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1733 JVM_END
1734 
1735 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1736   if (!cp-&gt;is_within_bounds(index)) {
1737     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1738   }
1739 }
1740 
1741 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1742 {
1743   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1744   // method is a handle to a java.lang.reflect.Method object
1745   Method* method_ptr = jvm_get_method_common(method);
1746   methodHandle mh (THREAD, method_ptr);
1747   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1748   const int num_params = mh-&gt;method_parameters_length();
1749 
1750   if (num_params &lt; 0) {
1751     // A -1 return value from method_parameters_length means there is no
1752     // parameter data.  Return null to indicate this to the reflection
1753     // API.
1754     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1755     return (jobjectArray)NULL;
1756   } else {
1757     // Otherwise, we return something up to reflection, even if it is
1758     // a zero-length array.  Why?  Because in some cases this can
1759     // trigger a MalformedParametersException.
1760 
1761     // make sure all the symbols are properly formatted
1762     for (int i = 0; i &lt; num_params; i++) {
1763       MethodParametersElement* params = mh-&gt;method_parameters_start();
1764       int index = params[i].name_cp_index;
1765       constantPoolHandle cp(THREAD, mh-&gt;constants());
1766       bounds_check(cp, index, CHECK_NULL);
1767 
1768       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1769         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1770                     &quot;Wrong type at constant pool index&quot;);
1771       }
1772 
1773     }
1774 
1775     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1776     objArrayHandle result (THREAD, result_oop);
1777 
1778     for (int i = 0; i &lt; num_params; i++) {
1779       MethodParametersElement* params = mh-&gt;method_parameters_start();
1780       // For a 0 index, give a NULL symbol
1781       Symbol* sym = 0 != params[i].name_cp_index ?
1782         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1783       int flags = params[i].flags;
1784       oop param = Reflection::new_parameter(reflected_method, i, sym,
1785                                             flags, CHECK_NULL);
1786       result-&gt;obj_at_put(i, param);
1787     }
1788     return (jobjectArray)JNIHandles::make_local(env, result());
1789   }
1790 }
1791 JVM_END
1792 
1793 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1794 
1795 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1796 {
1797   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1798   JvmtiVMObjectAllocEventCollector oam;
1799 
1800   // Exclude primitive types and array types
1801   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1802       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1803     // Return empty array
1804     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1805     return (jobjectArray) JNIHandles::make_local(env, res);
1806   }
1807 
1808   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1809   constantPoolHandle cp(THREAD, k-&gt;constants());
1810 
1811   // Ensure class is linked
1812   k-&gt;link_class(CHECK_NULL);
1813 
1814   // Allocate result
1815   int num_fields;
1816 
1817   if (publicOnly) {
1818     num_fields = 0;
1819     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1820       if (fs.access_flags().is_public()) ++num_fields;
1821     }
1822   } else {
1823     num_fields = k-&gt;java_fields_count();
1824   }
1825 
1826   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1827   objArrayHandle result (THREAD, r);
1828 
1829   int out_idx = 0;
1830   fieldDescriptor fd;
1831   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1832     if (!publicOnly || fs.access_flags().is_public()) {
1833       fd.reinitialize(k, fs.index());
1834       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1835       result-&gt;obj_at_put(out_idx, field);
1836       ++out_idx;
1837     }
1838   }
1839   assert(out_idx == num_fields, &quot;just checking&quot;);
1840   return (jobjectArray) JNIHandles::make_local(env, result());
1841 }
1842 JVM_END
1843 
1844 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1845 {
1846   JVMWrapper(&quot;JVM_IsRecord&quot;);
1847   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1848   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1849     InstanceKlass* ik = InstanceKlass::cast(k);
1850     return ik-&gt;is_record();
1851   } else {
1852     return false;
1853   }
1854 }
1855 JVM_END
1856 
1857 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1858 {
1859   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1860   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1861   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1862   InstanceKlass* ik = InstanceKlass::cast(c);
1863 
1864   if (ik-&gt;is_record()) {
1865     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1866     assert(components != NULL, &quot;components should not be NULL&quot;);
1867     {
1868       JvmtiVMObjectAllocEventCollector oam;
1869       constantPoolHandle cp(THREAD, ik-&gt;constants());
1870       int length = components-&gt;length();
1871       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1872       objArrayOop record_components =
1873         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1874       objArrayHandle components_h (THREAD, record_components);
1875 
1876       for (int x = 0; x &lt; length; x++) {
1877         RecordComponent* component = components-&gt;at(x);
1878         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1879         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1880         components_h-&gt;obj_at_put(x, component_oop);
1881       }
1882       return (jobjectArray)JNIHandles::make_local(components_h());
1883     }
1884   }
1885 
1886   // Return empty array if ofClass is not a record.
1887   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1888   return (jobjectArray)JNIHandles::make_local(env, result);
1889 }
1890 JVM_END
1891 
1892 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1893   if (want_constructor) {
1894     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1895   } else {
1896     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1897   }
1898 }
1899 
1900 static jobjectArray get_class_declared_methods_helper(
1901                                   JNIEnv *env,
1902                                   jclass ofClass, jboolean publicOnly,
1903                                   bool want_constructor,
1904                                   Klass* klass, TRAPS) {
1905 
1906   JvmtiVMObjectAllocEventCollector oam;
1907 
1908   // Exclude primitive types and array types
1909   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1910       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1911     // Return empty array
1912     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1913     return (jobjectArray) JNIHandles::make_local(env, res);
1914   }
1915 
1916   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1917 
1918   // Ensure class is linked
1919   k-&gt;link_class(CHECK_NULL);
1920 
1921   Array&lt;Method*&gt;* methods = k-&gt;methods();
1922   int methods_length = methods-&gt;length();
1923 
1924   // Save original method_idnum in case of redefinition, which can change
1925   // the idnum of obsolete methods.  The new method will have the same idnum
1926   // but if we refresh the methods array, the counts will be wrong.
1927   ResourceMark rm(THREAD);
1928   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1929   int num_methods = 0;
1930 
1931   for (int i = 0; i &lt; methods_length; i++) {
1932     methodHandle method(THREAD, methods-&gt;at(i));
1933     if (select_method(method, want_constructor)) {
1934       if (!publicOnly || method-&gt;is_public()) {
1935         idnums-&gt;push(method-&gt;method_idnum());
1936         ++num_methods;
1937       }
1938     }
1939   }
1940 
1941   // Allocate result
1942   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1943   objArrayHandle result (THREAD, r);
1944 
1945   // Now just put the methods that we selected above, but go by their idnum
1946   // in case of redefinition.  The methods can be redefined at any safepoint,
1947   // so above when allocating the oop array and below when creating reflect
1948   // objects.
1949   for (int i = 0; i &lt; num_methods; i++) {
1950     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1951     if (method.is_null()) {
1952       // Method may have been deleted and seems this API can handle null
1953       // Otherwise should probably put a method that throws NSME
1954       result-&gt;obj_at_put(i, NULL);
1955     } else {
1956       oop m;
1957       if (want_constructor) {
1958         m = Reflection::new_constructor(method, CHECK_NULL);
1959       } else {
1960         m = Reflection::new_method(method, false, CHECK_NULL);
1961       }
1962       result-&gt;obj_at_put(i, m);
1963     }
1964   }
1965 
1966   return (jobjectArray) JNIHandles::make_local(env, result());
1967 }
1968 
1969 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1970 {
1971   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1972   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1973                                            /*want_constructor*/ false,
1974                                            SystemDictionary::reflect_Method_klass(), THREAD);
1975 }
1976 JVM_END
1977 
1978 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1979 {
1980   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1981   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1982                                            /*want_constructor*/ true,
1983                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1984 }
1985 JVM_END
1986 
1987 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1988 {
1989   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
1990   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1991     // Primitive type
1992     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1993   }
1994 
1995   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1996   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1997 }
1998 JVM_END
1999 
2000 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2001 {
2002   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2003   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2004   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2005   InstanceKlass* ck = InstanceKlass::cast(c);
2006   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2007   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2008   InstanceKlass* mk = InstanceKlass::cast(m);
2009   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2010 }
2011 JVM_END
2012 
2013 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2014 {
2015   // current is not a primitive or array class
2016   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2017   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2018   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2019   InstanceKlass* ck = InstanceKlass::cast(c);
2020   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2021   return (jclass) (host == NULL ? NULL :
2022                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2023 }
2024 JVM_END
2025 
2026 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2027 {
2028   // current is not a primitive or array class
2029   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2030   ResourceMark rm(THREAD);
2031   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2032   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2033   InstanceKlass* ck = InstanceKlass::cast(c);
2034   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2035 
2036   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2037                               ck-&gt;external_name(), host-&gt;external_name());
2038   {
2039     JvmtiVMObjectAllocEventCollector oam;
2040     Array&lt;u2&gt;* members = host-&gt;nest_members();
2041     int length = members == NULL ? 0 : members-&gt;length();
2042 
2043     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2044 
2045     // nest host is first in the array so make it one bigger
2046     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2047                                              length + 1, CHECK_NULL);
2048     objArrayHandle result(THREAD, r);
2049     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2050     if (length != 0) {
2051       int count = 0;
2052       for (int i = 0; i &lt; length; i++) {
2053         int cp_index = members-&gt;at(i);
2054         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2055         if (HAS_PENDING_EXCEPTION) {
2056           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2057             return NULL; // propagate VMEs
2058           }
2059           if (log_is_enabled(Trace, class, nestmates)) {
2060             stringStream ss;
2061             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2062             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2063             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2064             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2065           }
2066           CLEAR_PENDING_EXCEPTION;
2067           continue;
2068         }
2069         if (k-&gt;is_instance_klass()) {
2070           InstanceKlass* ik = InstanceKlass::cast(k);
2071           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2072           if (nest_host_k == host) {
2073             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2074             count++;
2075             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2076           } else {
2077             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2078                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2079           }
2080         } else {
2081           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2082                                       k-&gt;external_name());
2083         }
2084       }
2085       if (count &lt; length) {
2086         // we had invalid entries so we need to compact the array
2087         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2088                                     length + 1, count + 1);
2089 
2090         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2091                                                   count + 1, CHECK_NULL);
2092         objArrayHandle result2(THREAD, r2);
2093         for (int i = 0; i &lt; count + 1; i++) {
2094           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2095         }
2096         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2097       }
2098     }
2099     else {
2100       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2101     }
2102     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2103   }
2104 }
2105 JVM_END
2106 
2107 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2108 {
2109   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
2110   assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), &quot;should not be&quot;);
2111   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2112   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2113   InstanceKlass* ik = InstanceKlass::cast(c);
2114   {
2115     JvmtiVMObjectAllocEventCollector oam;
2116     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2117     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2118     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2119                                              length, CHECK_NULL);
2120     objArrayHandle result(THREAD, r);
2121     for (int i = 0; i &lt; length; i++) {
2122       int cp_index = subclasses-&gt;at(i);
2123       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2124       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2125       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2126       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2127       result-&gt;obj_at_put(i, perm_subtype_h());
2128     }
2129     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2130   }
2131 }
2132 JVM_END
2133 
2134 // Constant pool access //////////////////////////////////////////////////////////
2135 
2136 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2137 {
2138   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2139   JvmtiVMObjectAllocEventCollector oam;
2140 
2141   // Return null for primitives and arrays
2142   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2143     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2144     if (k-&gt;is_instance_klass()) {
2145       InstanceKlass* k_h = InstanceKlass::cast(k);
2146       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2147       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2148       return JNIHandles::make_local(jcp());
2149     }
2150   }
2151   return NULL;
2152 }
2153 JVM_END
2154 
2155 
2156 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2157 {
2158   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2159   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2160   return cp-&gt;length();
2161 }
2162 JVM_END
2163 
2164 
2165 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2166 {
2167   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2168   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2169   bounds_check(cp, index, CHECK_NULL);
2170   constantTag tag = cp-&gt;tag_at(index);
2171   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2172     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2173   }
2174   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2175   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2176 }
2177 JVM_END
2178 
2179 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2180 {
2181   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2182   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2183   bounds_check(cp, index, CHECK_NULL);
2184   constantTag tag = cp-&gt;tag_at(index);
2185   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2186     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2187   }
2188   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2189   if (k == NULL) return NULL;
2190   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2191 }
2192 JVM_END
2193 
2194 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2195   constantTag tag = cp-&gt;tag_at(index);
2196   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2197     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2198   }
2199   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2200   Klass* k_o;
2201   if (force_resolution) {
2202     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2203   } else {
2204     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2205     if (k_o == NULL) return NULL;
2206   }
2207   InstanceKlass* k = InstanceKlass::cast(k_o);
2208   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2209   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2210   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2211   if (m.is_null()) {
2212     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2213   }
2214   oop method;
2215   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2216     method = Reflection::new_method(m, true, CHECK_NULL);
2217   } else {
2218     method = Reflection::new_constructor(m, CHECK_NULL);
2219   }
2220   return JNIHandles::make_local(method);
2221 }
2222 
2223 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2224 {
2225   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2226   JvmtiVMObjectAllocEventCollector oam;
2227   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2228   bounds_check(cp, index, CHECK_NULL);
2229   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2230   return res;
2231 }
2232 JVM_END
2233 
2234 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2235 {
2236   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2237   JvmtiVMObjectAllocEventCollector oam;
2238   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2239   bounds_check(cp, index, CHECK_NULL);
2240   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2241   return res;
2242 }
2243 JVM_END
2244 
2245 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2246   constantTag tag = cp-&gt;tag_at(index);
2247   if (!tag.is_field()) {
2248     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2249   }
2250   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2251   Klass* k_o;
2252   if (force_resolution) {
2253     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2254   } else {
2255     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2256     if (k_o == NULL) return NULL;
2257   }
2258   InstanceKlass* k = InstanceKlass::cast(k_o);
2259   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2260   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2261   fieldDescriptor fd;
2262   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2263   if (target_klass == NULL) {
2264     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2265   }
2266   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2267   return JNIHandles::make_local(field);
2268 }
2269 
2270 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2271 {
2272   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2273   JvmtiVMObjectAllocEventCollector oam;
2274   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2275   bounds_check(cp, index, CHECK_NULL);
2276   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2277   return res;
2278 }
2279 JVM_END
2280 
2281 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2282 {
2283   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2284   JvmtiVMObjectAllocEventCollector oam;
2285   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2286   bounds_check(cp, index, CHECK_NULL);
2287   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2288   return res;
2289 }
2290 JVM_END
2291 
2292 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2293 {
2294   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2295   JvmtiVMObjectAllocEventCollector oam;
2296   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2297   bounds_check(cp, index, CHECK_NULL);
2298   constantTag tag = cp-&gt;tag_at(index);
2299   if (!tag.is_field_or_method()) {
2300     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2301   }
2302   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2303   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2304   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2305   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2306   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2307   objArrayHandle dest(THREAD, dest_o);
2308   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2309   dest-&gt;obj_at_put(0, str());
2310   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2311   dest-&gt;obj_at_put(1, str());
2312   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2313   dest-&gt;obj_at_put(2, str());
2314   return (jobjectArray) JNIHandles::make_local(dest());
2315 }
2316 JVM_END
2317 
2318 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2319 {
2320   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2321   JvmtiVMObjectAllocEventCollector oam;
2322   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2323   bounds_check(cp, index, CHECK_0);
2324   constantTag tag = cp-&gt;tag_at(index);
2325   if (!tag.is_field_or_method()) {
2326     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2327   }
2328   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2329 }
2330 JVM_END
2331 
2332 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2333 {
2334   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2335   JvmtiVMObjectAllocEventCollector oam;
2336   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2337   bounds_check(cp, index, CHECK_0);
2338   constantTag tag = cp-&gt;tag_at(index);
2339   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2340     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2341   }
2342   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2343 }
2344 JVM_END
2345 
2346 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2347 {
2348   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2349   JvmtiVMObjectAllocEventCollector oam;
2350   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2351   bounds_check(cp, index, CHECK_NULL);
2352   constantTag tag = cp-&gt;tag_at(index);
2353   if (!tag.is_name_and_type()) {
2354     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2355   }
2356   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2357   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2358   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2359   objArrayHandle dest(THREAD, dest_o);
2360   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2361   dest-&gt;obj_at_put(0, str());
2362   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2363   dest-&gt;obj_at_put(1, str());
2364   return (jobjectArray) JNIHandles::make_local(dest());
2365 }
2366 JVM_END
2367 
2368 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2369 {
2370   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2371   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2372   bounds_check(cp, index, CHECK_0);
2373   constantTag tag = cp-&gt;tag_at(index);
2374   if (!tag.is_int()) {
2375     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2376   }
2377   return cp-&gt;int_at(index);
2378 }
2379 JVM_END
2380 
2381 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2382 {
2383   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2384   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2385   bounds_check(cp, index, CHECK_(0L));
2386   constantTag tag = cp-&gt;tag_at(index);
2387   if (!tag.is_long()) {
2388     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2389   }
2390   return cp-&gt;long_at(index);
2391 }
2392 JVM_END
2393 
2394 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2395 {
2396   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2397   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2398   bounds_check(cp, index, CHECK_(0.0f));
2399   constantTag tag = cp-&gt;tag_at(index);
2400   if (!tag.is_float()) {
2401     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2402   }
2403   return cp-&gt;float_at(index);
2404 }
2405 JVM_END
2406 
2407 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2408 {
2409   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2410   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2411   bounds_check(cp, index, CHECK_(0.0));
2412   constantTag tag = cp-&gt;tag_at(index);
2413   if (!tag.is_double()) {
2414     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2415   }
2416   return cp-&gt;double_at(index);
2417 }
2418 JVM_END
2419 
2420 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2421 {
2422   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2423   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2424   bounds_check(cp, index, CHECK_NULL);
2425   constantTag tag = cp-&gt;tag_at(index);
2426   if (!tag.is_string()) {
2427     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2428   }
2429   oop str = cp-&gt;string_at(index, CHECK_NULL);
2430   return (jstring) JNIHandles::make_local(str);
2431 }
2432 JVM_END
2433 
2434 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2435 {
2436   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2437   JvmtiVMObjectAllocEventCollector oam;
2438   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2439   bounds_check(cp, index, CHECK_NULL);
2440   constantTag tag = cp-&gt;tag_at(index);
2441   if (!tag.is_symbol()) {
2442     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2443   }
2444   Symbol* sym = cp-&gt;symbol_at(index);
2445   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2446   return (jstring) JNIHandles::make_local(str());
2447 }
2448 JVM_END
2449 
2450 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2451 {
2452   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2453   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2454   bounds_check(cp, index, CHECK_0);
2455   constantTag tag = cp-&gt;tag_at(index);
2456   jbyte result = tag.value();
2457   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2458   // they are changed to the corresponding tags from the JVM spec, so that java code in
2459   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2460   if (tag.is_klass_or_reference()) {
2461       result = JVM_CONSTANT_Class;
2462   } else if (tag.is_string_index()) {
2463       result = JVM_CONSTANT_String;
2464   } else if (tag.is_method_type_in_error()) {
2465       result = JVM_CONSTANT_MethodType;
2466   } else if (tag.is_method_handle_in_error()) {
2467       result = JVM_CONSTANT_MethodHandle;
2468   } else if (tag.is_dynamic_constant_in_error()) {
2469       result = JVM_CONSTANT_Dynamic;
2470   }
2471   return result;
2472 }
2473 JVM_END
2474 
2475 // Assertion support. //////////////////////////////////////////////////////////
2476 
2477 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2478   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2479   assert(cls != NULL, &quot;bad class&quot;);
2480 
2481   oop r = JNIHandles::resolve(cls);
2482   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2483   if (java_lang_Class::is_primitive(r)) return false;
2484 
2485   Klass* k = java_lang_Class::as_Klass(r);
2486   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2487   if (!k-&gt;is_instance_klass()) return false;
2488 
2489   ResourceMark rm(THREAD);
2490   const char* name = k-&gt;name()-&gt;as_C_string();
2491   bool system_class = k-&gt;class_loader() == NULL;
2492   return JavaAssertions::enabled(name, system_class);
2493 
2494 JVM_END
2495 
2496 
2497 // Return a new AssertionStatusDirectives object with the fields filled in with
2498 // command-line assertion arguments (i.e., -ea, -da).
2499 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2500   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2501   JvmtiVMObjectAllocEventCollector oam;
2502   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2503   return JNIHandles::make_local(env, asd);
2504 JVM_END
2505 
2506 // Verification ////////////////////////////////////////////////////////////////////////////////
2507 
2508 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2509 
2510 // RedefineClasses support: bug 6214132 caused verification to fail.
2511 // All functions from this section should call the jvmtiThreadSate function:
2512 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2513 // The function returns a Klass* of the _scratch_class if the verifier
2514 // was invoked in the middle of the class redefinition.
2515 // Otherwise it returns its argument value which is the _the_class Klass*.
2516 // Please, refer to the description in the jvmtiThreadSate.hpp.
2517 
2518 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2519   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2520   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2521   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2522   return k-&gt;name()-&gt;as_utf8();
2523 JVM_END
2524 
2525 
2526 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2527   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2528   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2529   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2530   // types will have length zero if this is not an InstanceKlass
2531   // (length is determined by call to JVM_GetClassCPEntriesCount)
2532   if (k-&gt;is_instance_klass()) {
2533     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2534     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2535       constantTag tag = cp-&gt;tag_at(index);
2536       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2537     }
2538   }
2539 JVM_END
2540 
2541 
2542 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2543   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2544   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2545   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2546   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2547 JVM_END
2548 
2549 
2550 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2551   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2552   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2553   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2554   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2555 JVM_END
2556 
2557 
2558 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2559   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2560   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2561   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2562   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2563 JVM_END
2564 
2565 
2566 // The following methods, used for the verifier, are never called with
2567 // array klasses, so a direct cast to InstanceKlass is safe.
2568 // Typically, these methods are called in a loop with bounds determined
2569 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2570 // zero for arrays.
2571 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2572   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2573   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2574   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2575   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2576   int length = method-&gt;checked_exceptions_length();
2577   if (length &gt; 0) {
2578     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2579     for (int i = 0; i &lt; length; i++) {
2580       exceptions[i] = table[i].class_cp_index;
2581     }
2582   }
2583 JVM_END
2584 
2585 
2586 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2587   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2588   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2589   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2590   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2591   return method-&gt;checked_exceptions_length();
2592 JVM_END
2593 
2594 
2595 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2596   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2597   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2598   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2599   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2600   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2601 JVM_END
2602 
2603 
2604 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2605   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2606   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2607   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2608   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2609   return method-&gt;code_size();
2610 JVM_END
2611 
2612 
2613 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2614   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2615   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2616   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2617   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2618   ExceptionTable extable(method);
2619   entry-&gt;start_pc   = extable.start_pc(entry_index);
2620   entry-&gt;end_pc     = extable.end_pc(entry_index);
2621   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2622   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2623 JVM_END
2624 
2625 
2626 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2627   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2628   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2629   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2630   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2631   return method-&gt;exception_table_length();
2632 JVM_END
2633 
2634 
2635 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2636   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2637   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2638   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2639   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2640   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2641 JVM_END
2642 
2643 
2644 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2645   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2646   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2647   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2648   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2649 JVM_END
2650 
2651 
2652 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2653   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2654   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2655   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2656   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2657   return method-&gt;max_locals();
2658 JVM_END
2659 
2660 
2661 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2662   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2663   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2664   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2665   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2666   return method-&gt;size_of_parameters();
2667 JVM_END
2668 
2669 
2670 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2671   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2672   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2673   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2674   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2675   return method-&gt;verifier_max_stack();
2676 JVM_END
2677 
2678 
2679 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2680   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2681   ResourceMark rm(THREAD);
2682   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2683   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2684   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2685   return method-&gt;name() == vmSymbols::object_initializer_name();
2686 JVM_END
2687 
2688 
2689 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2690   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2691   ResourceMark rm(THREAD);
2692   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2693   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2694   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2695   return method-&gt;is_overpass();
2696 JVM_END
2697 
2698 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2699   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2700   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2701   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2702   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2703   return method-&gt;name()-&gt;as_utf8();
2704 JVM_END
2705 
2706 
2707 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2708   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2709   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2710   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2711   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2712   return method-&gt;signature()-&gt;as_utf8();
2713 JVM_END
2714 
2715 /**
2716  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2717  * read entries in the constant pool.  Since the old verifier always
2718  * works on a copy of the code, it will not see any rewriting that
2719  * may possibly occur in the middle of verification.  So it is important
2720  * that nothing it calls tries to use the cpCache instead of the raw
2721  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2722  */
2723 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2724   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2725   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2726   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2727   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2728   switch (cp-&gt;tag_at(cp_index).value()) {
2729     case JVM_CONSTANT_Fieldref:
2730       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2731     default:
2732       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2733   }
2734   ShouldNotReachHere();
2735   return NULL;
2736 JVM_END
2737 
2738 
2739 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2740   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2741   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2742   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2743   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2744   switch (cp-&gt;tag_at(cp_index).value()) {
2745     case JVM_CONSTANT_InterfaceMethodref:
2746     case JVM_CONSTANT_Methodref:
2747       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2748     default:
2749       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2750   }
2751   ShouldNotReachHere();
2752   return NULL;
2753 JVM_END
2754 
2755 
2756 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2757   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2758   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2759   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2760   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2761   switch (cp-&gt;tag_at(cp_index).value()) {
2762     case JVM_CONSTANT_InterfaceMethodref:
2763     case JVM_CONSTANT_Methodref:
2764       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2765     default:
2766       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2767   }
2768   ShouldNotReachHere();
2769   return NULL;
2770 JVM_END
2771 
2772 
2773 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2774   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2775   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2776   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2777   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2778   switch (cp-&gt;tag_at(cp_index).value()) {
2779     case JVM_CONSTANT_Fieldref:
2780       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2781     default:
2782       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2783   }
2784   ShouldNotReachHere();
2785   return NULL;
2786 JVM_END
2787 
2788 
2789 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2790   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2791   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2792   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2793   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2794   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2795   return classname-&gt;as_utf8();
2796 JVM_END
2797 
2798 
2799 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2800   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2801   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2802   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2803   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2804   switch (cp-&gt;tag_at(cp_index).value()) {
2805     case JVM_CONSTANT_Fieldref: {
2806       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2807       Symbol* classname = cp-&gt;klass_name_at(class_index);
2808       return classname-&gt;as_utf8();
2809     }
2810     default:
2811       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2812   }
2813   ShouldNotReachHere();
2814   return NULL;
2815 JVM_END
2816 
2817 
2818 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2819   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2820   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2821   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2822   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2823   switch (cp-&gt;tag_at(cp_index).value()) {
2824     case JVM_CONSTANT_Methodref:
2825     case JVM_CONSTANT_InterfaceMethodref: {
2826       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2827       Symbol* classname = cp-&gt;klass_name_at(class_index);
2828       return classname-&gt;as_utf8();
2829     }
2830     default:
2831       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2832   }
2833   ShouldNotReachHere();
2834   return NULL;
2835 JVM_END
2836 
2837 
2838 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2839   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2840   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2841   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2842   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2843   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2844   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2845   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2846   switch (cp-&gt;tag_at(cp_index).value()) {
2847     case JVM_CONSTANT_Fieldref: {
2848       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2849       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2850       InstanceKlass* ik = InstanceKlass::cast(k_called);
2851       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2852         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2853           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2854         }
2855       }
2856       return -1;
2857     }
2858     default:
2859       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2860   }
2861   ShouldNotReachHere();
2862   return 0;
2863 JVM_END
2864 
2865 
2866 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2867   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2868   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2869   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2870   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2871   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2872   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2873   switch (cp-&gt;tag_at(cp_index).value()) {
2874     case JVM_CONSTANT_Methodref:
2875     case JVM_CONSTANT_InterfaceMethodref: {
2876       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2877       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2878       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2879       int methods_count = methods-&gt;length();
2880       for (int i = 0; i &lt; methods_count; i++) {
2881         Method* method = methods-&gt;at(i);
2882         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2883             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2884         }
2885       }
2886       return -1;
2887     }
2888     default:
2889       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2890   }
2891   ShouldNotReachHere();
2892   return 0;
2893 JVM_END
2894 
2895 
2896 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2897 
2898 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2899   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2900 JVM_END
2901 
2902 
2903 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2904   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2905   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2906   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2907   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2908   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2909   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2910 JVM_END
2911 
2912 // Printing support //////////////////////////////////////////////////
2913 extern &quot;C&quot; {
2914 
2915 ATTRIBUTE_PRINTF(3, 0)
2916 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2917   // Reject count values that are negative signed values converted to
2918   // unsigned; see bug 4399518, 4417214
2919   if ((intptr_t)count &lt;= 0) return -1;
2920 
2921   int result = os::vsnprintf(str, count, fmt, args);
2922   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2923     result = -1;
2924   }
2925 
2926   return result;
2927 }
2928 
2929 ATTRIBUTE_PRINTF(3, 4)
2930 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2931   va_list args;
2932   int len;
2933   va_start(args, fmt);
2934   len = jio_vsnprintf(str, count, fmt, args);
2935   va_end(args);
2936   return len;
2937 }
2938 
2939 ATTRIBUTE_PRINTF(2, 3)
2940 int jio_fprintf(FILE* f, const char *fmt, ...) {
2941   int len;
2942   va_list args;
2943   va_start(args, fmt);
2944   len = jio_vfprintf(f, fmt, args);
2945   va_end(args);
2946   return len;
2947 }
2948 
2949 ATTRIBUTE_PRINTF(2, 0)
2950 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2951   if (Arguments::vfprintf_hook() != NULL) {
2952      return Arguments::vfprintf_hook()(f, fmt, args);
2953   } else {
2954     return vfprintf(f, fmt, args);
2955   }
2956 }
2957 
2958 ATTRIBUTE_PRINTF(1, 2)
2959 JNIEXPORT int jio_printf(const char *fmt, ...) {
2960   int len;
2961   va_list args;
2962   va_start(args, fmt);
2963   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2964   va_end(args);
2965   return len;
2966 }
2967 
2968 // HotSpot specific jio method
2969 void jio_print(const char* s, size_t len) {
2970   // Try to make this function as atomic as possible.
2971   if (Arguments::vfprintf_hook() != NULL) {
2972     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2973   } else {
2974     // Make an unused local variable to avoid warning from gcc compiler.
2975     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2976   }
2977 }
2978 
2979 } // Extern C
2980 
2981 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2982 
2983 // In most of the JVM thread support functions we need to access the
2984 // thread through a ThreadsListHandle to prevent it from exiting and
2985 // being reclaimed while we try to operate on it. The exceptions to this
2986 // rule are when operating on the current thread, or if the monitor of
2987 // the target java.lang.Thread is locked at the Java level - in both
2988 // cases the target cannot exit.
2989 
2990 static void thread_entry(JavaThread* thread, TRAPS) {
2991   HandleMark hm(THREAD);
2992   Handle obj(THREAD, thread-&gt;threadObj());
2993   JavaValue result(T_VOID);
2994   JavaCalls::call_virtual(&amp;result,
2995                           obj,
2996                           SystemDictionary::Thread_klass(),
2997                           vmSymbols::run_method_name(),
2998                           vmSymbols::void_method_signature(),
2999                           THREAD);
3000 }
3001 
3002 
3003 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3004   JVMWrapper(&quot;JVM_StartThread&quot;);
3005   JavaThread *native_thread = NULL;
3006 
3007   // We cannot hold the Threads_lock when we throw an exception,
3008   // due to rank ordering issues. Example:  we might need to grab the
3009   // Heap_lock while we construct the exception.
3010   bool throw_illegal_thread_state = false;
3011 
3012   // We must release the Threads_lock before we can post a jvmti event
3013   // in Thread::start.
3014   {
3015     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3016     // we operate.
3017     MutexLocker mu(Threads_lock);
3018 
3019     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3020     // re-starting an already started thread, so we should usually find
3021     // that the JavaThread is null. However for a JNI attached thread
3022     // there is a small window between the Thread object being created
3023     // (with its JavaThread set) and the update to its threadStatus, so we
3024     // have to check for this
3025     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3026       throw_illegal_thread_state = true;
3027     } else {
3028       // We could also check the stillborn flag to see if this thread was already stopped, but
3029       // for historical reasons we let the thread detect that itself when it starts running
3030 
3031       jlong size =
3032              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3033       // Allocate the C++ Thread structure and create the native thread.  The
3034       // stack size retrieved from java is 64-bit signed, but the constructor takes
3035       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3036       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3037       //  - Avoid passing negative values which would result in really large stacks.
3038       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3039       size_t sz = size &gt; 0 ? (size_t) size : 0;
3040       native_thread = new JavaThread(&amp;thread_entry, sz);
3041 
3042       // At this point it may be possible that no osthread was created for the
3043       // JavaThread due to lack of memory. Check for this situation and throw
3044       // an exception if necessary. Eventually we may want to change this so
3045       // that we only grab the lock if the thread was created successfully -
3046       // then we can also do this check and throw the exception in the
3047       // JavaThread constructor.
3048       if (native_thread-&gt;osthread() != NULL) {
3049         // Note: the current thread is not being used within &quot;prepare&quot;.
3050         native_thread-&gt;prepare(jthread);
3051       }
3052     }
3053   }
3054 
3055   if (throw_illegal_thread_state) {
3056     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3057   }
3058 
3059   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3060 
3061   if (native_thread-&gt;osthread() == NULL) {
3062     // No one should hold a reference to the &#39;native_thread&#39;.
3063     native_thread-&gt;smr_delete();
3064     if (JvmtiExport::should_post_resource_exhausted()) {
3065       JvmtiExport::post_resource_exhausted(
3066         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3067         os::native_thread_creation_failed_msg());
3068     }
3069     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3070               os::native_thread_creation_failed_msg());
3071   }
3072 
3073 #if INCLUDE_JFR
3074   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3075       EventThreadStart::is_stacktrace_enabled()) {
3076     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3077     // skip Thread.start() and Thread.start0()
3078     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3079   }
3080 #endif
3081 
3082   Thread::start(native_thread);
3083 
3084 JVM_END
3085 
3086 
3087 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3088 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3089 // but is thought to be reliable and simple. In the case, where the receiver is the
3090 // same thread as the sender, no VM_Operation is needed.
3091 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3092   JVMWrapper(&quot;JVM_StopThread&quot;);
3093 
3094   // A nested ThreadsListHandle will grab the Threads_lock so create
3095   // tlh before we resolve throwable.
3096   ThreadsListHandle tlh(thread);
3097   oop java_throwable = JNIHandles::resolve(throwable);
3098   if (java_throwable == NULL) {
3099     THROW(vmSymbols::java_lang_NullPointerException());
3100   }
3101   oop java_thread = NULL;
3102   JavaThread* receiver = NULL;
3103   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3104   Events::log_exception(thread,
3105                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3106                         p2i(receiver), p2i(java_thread), p2i(throwable));
3107 
3108   if (is_alive) {
3109     // jthread refers to a live JavaThread.
3110     if (thread == receiver) {
3111       // Exception is getting thrown at self so no VM_Operation needed.
3112       THROW_OOP(java_throwable);
3113     } else {
3114       // Use a VM_Operation to throw the exception.
3115       Thread::send_async_exception(java_thread, java_throwable);
3116     }
3117   } else {
3118     // Either:
3119     // - target thread has not been started before being stopped, or
3120     // - target thread already terminated
3121     // We could read the threadStatus to determine which case it is
3122     // but that is overkill as it doesn&#39;t matter. We must set the
3123     // stillborn flag for the first case, and if the thread has already
3124     // exited setting this flag has no effect.
3125     java_lang_Thread::set_stillborn(java_thread);
3126   }
3127 JVM_END
3128 
3129 
3130 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3131   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3132 
3133   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3134   return java_lang_Thread::is_alive(thread_oop);
3135 JVM_END
3136 
3137 
3138 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3139   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3140 
3141   ThreadsListHandle tlh(thread);
3142   JavaThread* receiver = NULL;
3143   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3144   if (is_alive) {
3145     // jthread refers to a live JavaThread.
3146     {
3147       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3148       if (receiver-&gt;is_external_suspend()) {
3149         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3150         // an error from this interface so just ignore the problem.
3151         return;
3152       }
3153       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3154         return;
3155       }
3156       receiver-&gt;set_external_suspend();
3157     }
3158 
3159     // java_suspend() will catch threads in the process of exiting
3160     // and will ignore them.
3161     receiver-&gt;java_suspend();
3162 
3163     // It would be nice to have the following assertion in all the
3164     // time, but it is possible for a racing resume request to have
3165     // resumed this thread right after we suspended it. Temporarily
3166     // enable this assertion if you are chasing a different kind of
3167     // bug.
3168     //
3169     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3170     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3171   }
3172 JVM_END
3173 
3174 
3175 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3176   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3177 
3178   ThreadsListHandle tlh(thread);
3179   JavaThread* receiver = NULL;
3180   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3181   if (is_alive) {
3182     // jthread refers to a live JavaThread.
3183 
3184     // This is the original comment for this Threads_lock grab:
3185     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3186     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3187     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3188     //   looks at it.
3189     //
3190     // The above comment dates back to when we had both internal and
3191     // external suspend APIs that shared a common underlying mechanism.
3192     // External suspend is now entirely cooperative and doesn&#39;t share
3193     // anything with internal suspend. That said, there are some
3194     // assumptions in the VM that an external resume grabs the
3195     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3196     // resolve the assumptions that exist elsewhere.
3197     //
3198     MutexLocker ml(Threads_lock);
3199     receiver-&gt;java_resume();
3200   }
3201 JVM_END
3202 
3203 
3204 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3205   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3206 
3207   ThreadsListHandle tlh(thread);
3208   oop java_thread = NULL;
3209   JavaThread* receiver = NULL;
3210   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3211   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3212 
3213   if (is_alive) {
3214     // jthread refers to a live JavaThread.
3215     Thread::set_priority(receiver, (ThreadPriority)prio);
3216   }
3217   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3218   // priority set in the java.lang.Thread object above will be pushed
3219   // down when it does start.
3220 JVM_END
3221 
3222 
3223 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3224   JVMWrapper(&quot;JVM_Yield&quot;);
3225   if (os::dont_yield()) return;
3226   HOTSPOT_THREAD_YIELD();
3227   os::naked_yield();
3228 JVM_END
3229 
3230 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3231   assert(event != NULL, &quot;invariant&quot;);
3232   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3233   event-&gt;set_time(millis);
3234   event-&gt;commit();
3235 }
3236 
3237 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3238   JVMWrapper(&quot;JVM_Sleep&quot;);
3239 
3240   if (millis &lt; 0) {
3241     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3242   }
3243 
3244   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3245     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3246   }
3247 
3248   // Save current thread state and restore it at the end of this block.
3249   // And set new thread state to SLEEPING.
3250   JavaThreadSleepState jtss(thread);
3251 
3252   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3253   EventThreadSleep event;
3254 
3255   if (millis == 0) {
3256     os::naked_yield();
3257   } else {
3258     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3259     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3260     if (!thread-&gt;sleep(millis)) { // interrupted
3261       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3262       // us while we were sleeping. We do not overwrite those.
3263       if (!HAS_PENDING_EXCEPTION) {
3264         if (event.should_commit()) {
3265           post_thread_sleep_event(&amp;event, millis);
3266         }
3267         HOTSPOT_THREAD_SLEEP_END(1);
3268 
3269         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3270         // to properly restore the thread state.  That&#39;s likely wrong.
3271         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3272       }
3273     }
3274     thread-&gt;osthread()-&gt;set_state(old_state);
3275   }
3276   if (event.should_commit()) {
3277     post_thread_sleep_event(&amp;event, millis);
3278   }
3279   HOTSPOT_THREAD_SLEEP_END(0);
3280 JVM_END
3281 
3282 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3283   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3284   oop jthread = thread-&gt;threadObj();
3285   assert (thread != NULL, &quot;no current thread!&quot;);
3286   return JNIHandles::make_local(env, jthread);
3287 JVM_END
3288 
3289 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3290   JVMWrapper(&quot;JVM_Interrupt&quot;);
3291 
3292   ThreadsListHandle tlh(thread);
3293   JavaThread* receiver = NULL;
3294   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3295   if (is_alive) {
3296     // jthread refers to a live JavaThread.
3297     receiver-&gt;interrupt();
3298   }
3299 JVM_END
3300 
3301 
3302 // Return true iff the current thread has locked the object passed in
3303 
3304 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3305   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3306   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3307   if (obj == NULL) {
3308     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3309   }
3310   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3311   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3312 JVM_END
3313 
3314 
3315 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3316   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3317   VM_PrintThreads op;
3318   VMThread::execute(&amp;op);
3319   if (JvmtiExport::should_post_data_dump()) {
3320     JvmtiExport::post_data_dump();
3321   }
3322 JVM_END
3323 
3324 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3325   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3326 
3327   // We don&#39;t use a ThreadsListHandle here because the current thread
3328   // must be alive.
3329   oop java_thread = JNIHandles::resolve_non_null(jthread);
3330   JavaThread* thr = java_lang_Thread::thread(java_thread);
3331   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3332     // Thread naming is only supported for the current thread and
3333     // we don&#39;t set the name of an attached thread to avoid stepping
3334     // on other programs.
3335     ResourceMark rm(thread);
3336     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3337     os::set_native_thread_name(thread_name);
3338   }
3339 JVM_END
3340 
3341 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3342 
3343 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3344   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3345   ResourceMark rm(THREAD);
3346   JvmtiVMObjectAllocEventCollector oam;
3347   vframeStream vfst(thread);
3348 
3349   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3350     // This must only be called from SecurityManager.getClassContext
3351     Method* m = vfst.method();
3352     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3353           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3354           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3355       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3356     }
3357   }
3358 
3359   // Collect method holders
3360   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3361   for (; !vfst.at_end(); vfst.security_next()) {
3362     Method* m = vfst.method();
3363     // Native frames are not returned
3364     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3365       Klass* holder = m-&gt;method_holder();
3366       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3367       klass_array-&gt;append(holder);
3368     }
3369   }
3370 
3371   // Create result array of type [Ljava/lang/Class;
3372   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3373   // Fill in mirrors corresponding to method holders
3374   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3375     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3376   }
3377 
3378   return (jobjectArray) JNIHandles::make_local(env, result);
3379 JVM_END
3380 
3381 
3382 // java.lang.Package ////////////////////////////////////////////////////////////////
3383 
3384 
3385 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3386   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3387   ResourceMark rm(THREAD);
3388   JvmtiVMObjectAllocEventCollector oam;
3389   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3390   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3391   return (jstring) JNIHandles::make_local(result);
3392 JVM_END
3393 
3394 
3395 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3396   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3397   JvmtiVMObjectAllocEventCollector oam;
3398   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3399   return (jobjectArray) JNIHandles::make_local(result);
3400 JVM_END
3401 
3402 
3403 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3404 
3405 
3406 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3407   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3408 
3409   MonitorLocker ml(Heap_lock);
3410   oop ref = Universe::reference_pending_list();
3411   if (ref != NULL) {
3412     Universe::set_reference_pending_list(NULL);
3413   }
3414   return JNIHandles::make_local(env, ref);
3415 JVM_END
3416 
3417 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3418   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3419   MonitorLocker ml(Heap_lock);
3420   return Universe::has_reference_pending_list();
3421 JVM_END
3422 
3423 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3424   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3425   MonitorLocker ml(Heap_lock);
3426   while (!Universe::has_reference_pending_list()) {
3427     ml.wait();
3428   }
3429 JVM_END
3430 
3431 
3432 // ObjectInputStream ///////////////////////////////////////////////////////////////
3433 
3434 // Return the first user-defined class loader up the execution stack, or null
3435 // if only code from the bootstrap or platform class loader is on the stack.
3436 
3437 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3438   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3439     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3440     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3441     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3442       return JNIHandles::make_local(env, loader);
3443     }
3444   }
3445   return NULL;
3446 JVM_END
3447 
3448 
3449 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3450 
3451 
3452 // resolve array handle and check arguments
3453 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3454   if (arr == NULL) {
3455     THROW_0(vmSymbols::java_lang_NullPointerException());
3456   }
3457   oop a = JNIHandles::resolve_non_null(arr);
3458   if (!a-&gt;is_array()) {
3459     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3460   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3461     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3462   }
3463   return arrayOop(a);
3464 }
3465 
3466 
3467 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3468   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3469   arrayOop a = check_array(env, arr, false, CHECK_0);
3470   return a-&gt;length();
3471 JVM_END
3472 
3473 
3474 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3475   JVMWrapper(&quot;JVM_Array_Get&quot;);
3476   JvmtiVMObjectAllocEventCollector oam;
3477   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3478   jvalue value;
3479   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3480   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3481   return JNIHandles::make_local(env, box);
3482 JVM_END
3483 
3484 
3485 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3486   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3487   jvalue value;
3488   value.i = 0; // to initialize value before getting used in CHECK
3489   arrayOop a = check_array(env, arr, true, CHECK_(value));
3490   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3491   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3492   BasicType wide_type = (BasicType) wCode;
3493   if (type != wide_type) {
3494     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3495   }
3496   return value;
3497 JVM_END
3498 
3499 
3500 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3501   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3502   arrayOop a = check_array(env, arr, false, CHECK);
3503   oop box = JNIHandles::resolve(val);
3504   jvalue value;
3505   value.i = 0; // to initialize value before getting used in CHECK
3506   BasicType value_type;
3507   if (a-&gt;is_objArray()) {
3508     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3509     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3510   } else {
3511     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3512   }
3513   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3514 JVM_END
3515 
3516 
3517 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3518   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3519   arrayOop a = check_array(env, arr, true, CHECK);
3520   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3521   BasicType value_type = (BasicType) vCode;
3522   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3523 JVM_END
3524 
3525 
3526 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3527   JVMWrapper(&quot;JVM_NewArray&quot;);
3528   JvmtiVMObjectAllocEventCollector oam;
3529   oop element_mirror = JNIHandles::resolve(eltClass);
3530   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3531   return JNIHandles::make_local(env, result);
3532 JVM_END
3533 
3534 
3535 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3536   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3537   JvmtiVMObjectAllocEventCollector oam;
3538   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3539   oop element_mirror = JNIHandles::resolve(eltClass);
3540   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3541   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3542   return JNIHandles::make_local(env, result);
3543 JVM_END
3544 
3545 
3546 // Library support ///////////////////////////////////////////////////////////////////////////
3547 
3548 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3549   //%note jvm_ct
3550   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3551   char ebuf[1024];
3552   void *load_result;
3553   {
3554     ThreadToNativeFromVM ttnfvm(thread);
3555     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3556   }
3557   if (load_result == NULL) {
3558     char msg[1024];
3559     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3560     // Since &#39;ebuf&#39; may contain a string encoded using
3561     // platform encoding scheme, we need to pass
3562     // Exceptions::unsafe_to_utf8 to the new_exception method
3563     // as the last argument. See bug 6367357.
3564     Handle h_exception =
3565       Exceptions::new_exception(thread,
3566                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3567                                 msg, Exceptions::unsafe_to_utf8);
3568 
3569     THROW_HANDLE_0(h_exception);
3570   }
3571   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3572   return load_result;
3573 JVM_END
3574 
3575 
3576 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3577   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3578   os::dll_unload(handle);
3579   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3580 JVM_END
3581 
3582 
3583 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3584   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3585   void* find_result = os::dll_lookup(handle, name);
3586   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3587                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3588                     name, p2i(handle));
3589   return find_result;
3590 JVM_END
3591 
3592 
3593 // JNI version ///////////////////////////////////////////////////////////////////////////////
3594 
3595 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3596   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3597   return Threads::is_supported_jni_version_including_1_1(version);
3598 JVM_END
3599 
3600 
3601 // String support ///////////////////////////////////////////////////////////////////////////
3602 
3603 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3604   JVMWrapper(&quot;JVM_InternString&quot;);
3605   JvmtiVMObjectAllocEventCollector oam;
3606   if (str == NULL) return NULL;
3607   oop string = JNIHandles::resolve_non_null(str);
3608   oop result = StringTable::intern(string, CHECK_NULL);
3609   return (jstring) JNIHandles::make_local(env, result);
3610 JVM_END
3611 
3612 
3613 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3614 
3615 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3616 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3617 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3618 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3619 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3620 
3621 
3622 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3623   VM_Exit::block_if_vm_exited();
3624   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3625   return new os::PlatformMutex();
3626 }
3627 
3628 
3629 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3630   VM_Exit::block_if_vm_exited();
3631   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3632   delete ((os::PlatformMutex*) mon);
3633 }
3634 
3635 
3636 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3637   VM_Exit::block_if_vm_exited();
3638   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3639   ((os::PlatformMutex*) mon)-&gt;lock();
3640   return 0;
3641 }
3642 
3643 
3644 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3645   VM_Exit::block_if_vm_exited();
3646   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3647   ((os::PlatformMutex*) mon)-&gt;unlock();
3648 }
3649 
3650 
3651 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3652 
3653 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3654                                     Handle loader, Handle protection_domain,
3655                                     jboolean throwError, TRAPS) {
3656   // Security Note:
3657   //   The Java level wrapper will perform the necessary security check allowing
3658   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3659   //   the checkPackageAccess relative to the initiating class loader via the
3660   //   protection_domain. The protection_domain is passed as NULL by the java code
3661   //   if there is no security manager in 3-arg Class.forName().
3662   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3663 
3664   // Check if we should initialize the class
3665   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3666     klass-&gt;initialize(CHECK_NULL);
3667   }
3668   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3669 }
3670 
3671 
3672 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3673 
3674 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3675   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3676   Handle method_handle;
3677   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3678     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3679     Handle receiver(THREAD, JNIHandles::resolve(obj));
3680     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3681     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3682     jobject res = JNIHandles::make_local(env, result);
3683     if (JvmtiExport::should_post_vm_object_alloc()) {
3684       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3685       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3686       if (java_lang_Class::is_primitive(ret_type)) {
3687         // Only for primitive type vm allocates memory for java object.
3688         // See box() method.
3689         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3690       }
3691     }
3692     return res;
3693   } else {
3694     THROW_0(vmSymbols::java_lang_StackOverflowError());
3695   }
3696 JVM_END
3697 
3698 
3699 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3700   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3701   oop constructor_mirror = JNIHandles::resolve(c);
3702   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3703   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3704   jobject res = JNIHandles::make_local(env, result);
3705   if (JvmtiExport::should_post_vm_object_alloc()) {
3706     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3707   }
3708   return res;
3709 JVM_END
3710 
3711 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3712 
3713 JVM_LEAF(jboolean, JVM_SupportsCX8())
3714   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3715   return VM_Version::supports_cx8();
3716 JVM_END
3717 
3718 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3719   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3720   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3721   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3722   HeapShared::initialize_from_archived_subgraph(k);
3723 JVM_END
3724 
3725 JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,
3726                                               jclass caller,
3727                                               jstring invokedName,
3728                                               jobject invokedType,
3729                                               jobject methodType,
3730                                               jobject implMethodMember,
3731                                               jobject instantiatedMethodType,
3732                                               jclass lambdaProxyClass))
3733   JVMWrapper(&quot;JVM_RegisterLambdaProxyClassForArchiving&quot;);
3734 #if INCLUDE_CDS
3735   if (!DynamicDumpSharedSpaces) {
3736     return;
3737   }
3738 
3739   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3740   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3741   if (caller_ik-&gt;is_hidden() || caller_ik-&gt;is_unsafe_anonymous()) {
3742     // VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.
3743     // If the caller_ik is of one of the above types, the corresponding lambda proxy class won&#39;t be
3744     // registered for archiving.
3745     return;
3746   }
3747   Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));
3748   InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);
3749   assert(lambda_ik-&gt;is_hidden(), &quot;must be a hidden class&quot;);
3750   assert(!lambda_ik-&gt;is_non_strong_hidden(), &quot;expected a strong hidden class&quot;);
3751 
3752   Symbol* invoked_name = NULL;
3753   if (invokedName != NULL) {
3754     invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3755   }
3756   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3757   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3758 
3759   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3760   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3761 
3762   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3763   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3764   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3765 
3766   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3767   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3768 
3769   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,
3770                                                  method_type, m, instantiated_method_type);
3771 #endif // INCLUDE_CDS
3772 JVM_END
3773 
3774 JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,
3775                                                         jclass caller,
3776                                                         jstring invokedName,
3777                                                         jobject invokedType,
3778                                                         jobject methodType,
3779                                                         jobject implMethodMember,
3780                                                         jobject instantiatedMethodType,
3781                                                         jboolean initialize))
3782   JVMWrapper(&quot;JVM_LookupLambdaProxyClassFromArchive&quot;);
3783 #if INCLUDE_CDS
3784   if (!DynamicArchive::is_mapped()) {
3785     return NULL;
3786   }
3787 
3788   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||
3789       implMethodMember == NULL || instantiatedMethodType == NULL) {
3790     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
3791   }
3792 
3793   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));
3794   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);
3795   if (!caller_ik-&gt;is_shared()) {
3796     // there won&#39;t be a shared lambda class if the caller_ik is not in the shared archive.
3797     return NULL;
3798   }
3799 
3800   Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));
3801   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));
3802   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);
3803 
3804   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));
3805   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);
3806 
3807   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));
3808   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);
3809   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());
3810 
3811   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));
3812   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);
3813 
3814   InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,
3815                                                                                    method_type, m, instantiated_method_type);
3816   jclass jcls = NULL;
3817   if (lambda_ik != NULL) {
3818     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);
3819     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda-&gt;java_mirror());
3820   }
3821   return jcls;
3822 #else
3823   return NULL;
3824 #endif // INCLUDE_CDS
3825 JVM_END
3826 
3827 JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))
3828     JVMWrapper(&quot;JVM_IsCDSDumpingEnable&quot;);
3829     return DynamicDumpSharedSpaces;
3830 JVM_END
3831 
3832 JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))
3833     JVMWrapper(&quot;JVM_IsCDSSharingEnable&quot;);
3834     return UseSharedSpaces;
3835 JVM_END
3836 
3837 JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
3838   JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
3839   if (DumpSharedSpaces) {
3840     const char* release = Abstract_VM_Version::vm_release();
3841     const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
3842     const char* version = VM_Version::internal_vm_info_string();
3843     jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^
3844                          java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^
3845                          java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));
3846     seed += (jlong)Abstract_VM_Version::vm_major_version();
3847     seed += (jlong)Abstract_VM_Version::vm_minor_version();
3848     seed += (jlong)Abstract_VM_Version::vm_security_version();
3849     seed += (jlong)Abstract_VM_Version::vm_patch_version();
3850     if (seed == 0) { // don&#39;t let this ever be zero.
3851       seed = 0x87654321;
3852     }
3853     log_debug(cds)(&quot;JVM_GetRandomSeedForCDSDump() = &quot; JLONG_FORMAT, seed);
3854     return seed;
3855   } else {
3856     return 0;
3857   }
3858 JVM_END
3859 
3860 // Returns an array of all live Thread objects (VM internal JavaThreads,
3861 // jvmti agent threads, and JNI attaching threads  are skipped)
3862 // See CR 6404306 regarding JNI attaching threads
3863 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3864   ResourceMark rm(THREAD);
3865   ThreadsListEnumerator tle(THREAD, false, false);
3866   JvmtiVMObjectAllocEventCollector oam;
3867 
3868   int num_threads = tle.num_threads();
3869   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3870   objArrayHandle threads_ah(THREAD, r);
3871 
3872   for (int i = 0; i &lt; num_threads; i++) {
3873     Handle h = tle.get_threadObj(i);
3874     threads_ah-&gt;obj_at_put(i, h());
3875   }
3876 
3877   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3878 JVM_END
3879 
3880 
3881 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3882 // Return StackTraceElement[][], each element is the stack trace of a thread in
3883 // the corresponding entry in the given threads array
3884 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3885   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3886   JvmtiVMObjectAllocEventCollector oam;
3887 
3888   // Check if threads is null
3889   if (threads == NULL) {
3890     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3891   }
3892 
3893   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3894   objArrayHandle ah(THREAD, a);
3895   int num_threads = ah-&gt;length();
3896   // check if threads is non-empty array
3897   if (num_threads == 0) {
3898     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3899   }
3900 
3901   // check if threads is not an array of objects of Thread class
3902   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3903   if (k != SystemDictionary::Thread_klass()) {
3904     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3905   }
3906 
3907   ResourceMark rm(THREAD);
3908 
3909   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3910   for (int i = 0; i &lt; num_threads; i++) {
3911     oop thread_obj = ah-&gt;obj_at(i);
3912     instanceHandle h(THREAD, (instanceOop) thread_obj);
3913     thread_handle_array-&gt;append(h);
3914   }
3915 
3916   // The JavaThread references in thread_handle_array are validated
3917   // in VM_ThreadDump::doit().
3918   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3919   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3920 
3921 JVM_END
3922 
3923 // JVM monitoring and management support
3924 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3925   return Management::get_jmm_interface(version);
3926 JVM_END
3927 
3928 // com.sun.tools.attach.VirtualMachine agent properties support
3929 //
3930 // Initialize the agent properties with the properties maintained in the VM
3931 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3932   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3933   ResourceMark rm;
3934 
3935   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3936 
3937   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3938   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3939   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3940   return properties;
3941 JVM_END
3942 
3943 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3944 {
3945   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3946   JvmtiVMObjectAllocEventCollector oam;
3947 
3948   if (ofClass == NULL) {
3949     return NULL;
3950   }
3951   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3952   // Special handling for primitive objects
3953   if (java_lang_Class::is_primitive(mirror())) {
3954     return NULL;
3955   }
3956   Klass* k = java_lang_Class::as_Klass(mirror());
3957   if (!k-&gt;is_instance_klass()) {
3958     return NULL;
3959   }
3960   InstanceKlass* ik = InstanceKlass::cast(k);
3961   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3962   if (encl_method_class_idx == 0) {
3963     return NULL;
3964   }
3965   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3966   objArrayHandle dest(THREAD, dest_o);
3967   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3968   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3969   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3970   if (encl_method_method_idx != 0) {
3971     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3972                         extract_low_short_from_int(
3973                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3974     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3975     dest-&gt;obj_at_put(1, str());
3976     sym = ik-&gt;constants()-&gt;symbol_at(
3977               extract_high_short_from_int(
3978                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3979     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3980     dest-&gt;obj_at_put(2, str());
3981   }
3982   return (jobjectArray) JNIHandles::make_local(dest());
3983 }
3984 JVM_END
3985 
3986 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3987 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3988   ResourceMark rm(THREAD);
3989 
3990   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3991     return NULL;
3992   }
3993 
3994   char** vm_flags = Arguments::jvm_flags_array();
3995   char** vm_args = Arguments::jvm_args_array();
3996   int num_flags = Arguments::num_jvm_flags();
3997   int num_args = Arguments::num_jvm_args();
3998 
3999   InstanceKlass* ik = SystemDictionary::String_klass();
4000   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
4001   objArrayHandle result_h(THREAD, r);
4002 
4003   int index = 0;
4004   for (int j = 0; j &lt; num_flags; j++, index++) {
4005     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
4006     result_h-&gt;obj_at_put(index, h());
4007   }
4008   for (int i = 0; i &lt; num_args; i++, index++) {
4009     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
4010     result_h-&gt;obj_at_put(index, h());
4011   }
4012   return (jobjectArray) JNIHandles::make_local(env, result_h());
4013 JVM_END
4014 
4015 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
4016   return os::get_signal_number(name);
4017 JVM_END
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>