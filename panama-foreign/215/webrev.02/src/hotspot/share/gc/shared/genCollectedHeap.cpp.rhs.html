<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;gc/serial/defNewGeneration.hpp&quot;
  34 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;gc/shared/cardTableRS.hpp&quot;
  37 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  38 #include &quot;gc/shared/collectorCounters.hpp&quot;
  39 #include &quot;gc/shared/gcId.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.hpp&quot;
  41 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  42 #include &quot;gc/shared/gcTrace.hpp&quot;
  43 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  44 #include &quot;gc/shared/genArguments.hpp&quot;
  45 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  46 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  47 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  48 #include &quot;gc/shared/generationSpec.hpp&quot;
  49 #include &quot;gc/shared/gcInitLogger.hpp&quot;
  50 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  51 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  52 #include &quot;gc/shared/oopStorageSet.inline.hpp&quot;</span>
  53 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  54 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  55 #include &quot;gc/shared/space.hpp&quot;
  56 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  57 #include &quot;gc/shared/weakProcessor.hpp&quot;
  58 #include &quot;gc/shared/workgroup.hpp&quot;
  59 #include &quot;memory/filemap.hpp&quot;
  60 #include &quot;memory/iterator.hpp&quot;
  61 #include &quot;memory/metaspaceCounters.hpp&quot;
  62 #include &quot;memory/resourceArea.hpp&quot;
  63 #include &quot;memory/universe.hpp&quot;
  64 #include &quot;oops/oop.inline.hpp&quot;
  65 #include &quot;runtime/biasedLocking.hpp&quot;
  66 #include &quot;runtime/flags/flagSetting.hpp&quot;
  67 #include &quot;runtime/handles.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/java.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;services/management.hpp&quot;
  72 #include &quot;services/memoryService.hpp&quot;
  73 #include &quot;utilities/debug.hpp&quot;
  74 #include &quot;utilities/formatBuffer.hpp&quot;
  75 #include &quot;utilities/macros.hpp&quot;
  76 #include &quot;utilities/stack.inline.hpp&quot;
  77 #include &quot;utilities/vmError.hpp&quot;
  78 #if INCLUDE_JVMCI
  79 #include &quot;jvmci/jvmci.hpp&quot;
  80 #endif
  81 
  82 GenCollectedHeap::GenCollectedHeap(Generation::Name young,
  83                                    Generation::Name old,
  84                                    const char* policy_counters_name) :
  85   CollectedHeap(),
  86   _young_gen(NULL),
  87   _old_gen(NULL),
  88   _young_gen_spec(new GenerationSpec(young,
  89                                      NewSize,
  90                                      MaxNewSize,
  91                                      GenAlignment)),
  92   _old_gen_spec(new GenerationSpec(old,
  93                                    OldSize,
  94                                    MaxOldSize,
  95                                    GenAlignment)),
  96   _rem_set(NULL),
  97   _soft_ref_gen_policy(),
  98   _size_policy(NULL),
  99   _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),
 100   _incremental_collection_failed(false),
 101   _full_collections_completed(0),
 102   _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)),
 103   _young_manager(NULL),
 104   _old_manager(NULL) {
 105 }
 106 
 107 jint GenCollectedHeap::initialize() {
 108   // While there are no constraints in the GC code that HeapWordSize
 109   // be any particular value, there are multiple other areas in the
 110   // system which believe this to be true (e.g. oop-&gt;object_size in some
 111   // cases incorrectly returns the size in wordSize units rather than
 112   // HeapWordSize).
 113   guarantee(HeapWordSize == wordSize, &quot;HeapWordSize must equal wordSize&quot;);
 114 
 115   // Allocate space for the heap.
 116 
 117   ReservedHeapSpace heap_rs = allocate(HeapAlignment);
 118 
 119   if (!heap_rs.is_reserved()) {
 120     vm_shutdown_during_initialization(
 121       &quot;Could not reserve enough space for object heap&quot;);
 122     return JNI_ENOMEM;
 123   }
 124 
 125   initialize_reserved_region(heap_rs);
 126 
 127   _rem_set = create_rem_set(heap_rs.region());
 128   _rem_set-&gt;initialize();
 129   CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
 130   bs-&gt;initialize();
 131   BarrierSet::set_barrier_set(bs);
 132 
 133   ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec-&gt;max_size());
 134   _young_gen = _young_gen_spec-&gt;init(young_rs, rem_set());
 135   ReservedSpace old_rs = heap_rs.last_part(_young_gen_spec-&gt;max_size());
 136 
 137   old_rs = old_rs.first_part(_old_gen_spec-&gt;max_size());
 138   _old_gen = _old_gen_spec-&gt;init(old_rs, rem_set());
 139 
 140   GCInitLogger::print();
 141 
 142   return JNI_OK;
 143 }
 144 
 145 CardTableRS* GenCollectedHeap::create_rem_set(const MemRegion&amp; reserved_region) {
 146   return new CardTableRS(reserved_region, false /* scan_concurrently */);
 147 }
 148 
 149 void GenCollectedHeap::initialize_size_policy(size_t init_eden_size,
 150                                               size_t init_promo_size,
 151                                               size_t init_survivor_size) {
 152   const double max_gc_pause_sec = ((double) MaxGCPauseMillis) / 1000.0;
 153   _size_policy = new AdaptiveSizePolicy(init_eden_size,
 154                                         init_promo_size,
 155                                         init_survivor_size,
 156                                         max_gc_pause_sec,
 157                                         GCTimeRatio);
 158 }
 159 
 160 ReservedHeapSpace GenCollectedHeap::allocate(size_t alignment) {
 161   // Now figure out the total size.
 162   const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();
 163   assert(alignment % pageSize == 0, &quot;Must be&quot;);
 164 
 165   // Check for overflow.
 166   size_t total_reserved = _young_gen_spec-&gt;max_size() + _old_gen_spec-&gt;max_size();
 167   if (total_reserved &lt; _young_gen_spec-&gt;max_size()) {
 168     vm_exit_during_initialization(&quot;The size of the object heap + VM data exceeds &quot;
 169                                   &quot;the maximum representable size&quot;);
 170   }
 171   assert(total_reserved % alignment == 0,
 172          &quot;Gen size; total_reserved=&quot; SIZE_FORMAT &quot;, alignment=&quot;
 173          SIZE_FORMAT, total_reserved, alignment);
 174 
 175   ReservedHeapSpace heap_rs = Universe::reserve_heap(total_reserved, alignment);
 176 
 177   os::trace_page_sizes(&quot;Heap&quot;,
 178                        MinHeapSize,
 179                        total_reserved,
 180                        alignment,
 181                        heap_rs.base(),
 182                        heap_rs.size());
 183 
 184   return heap_rs;
 185 }
 186 
 187 class GenIsScavengable : public BoolObjectClosure {
 188 public:
 189   bool do_object_b(oop obj) {
 190     return GenCollectedHeap::heap()-&gt;is_in_young(obj);
 191   }
 192 };
 193 
 194 static GenIsScavengable _is_scavengable;
 195 
 196 void GenCollectedHeap::post_initialize() {
 197   CollectedHeap::post_initialize();
 198   ref_processing_init();
 199 
 200   DefNewGeneration* def_new_gen = (DefNewGeneration*)_young_gen;
 201 
 202   initialize_size_policy(def_new_gen-&gt;eden()-&gt;capacity(),
 203                          _old_gen-&gt;capacity(),
 204                          def_new_gen-&gt;from()-&gt;capacity());
 205 
 206   MarkSweep::initialize();
 207 
 208   ScavengableNMethods::initialize(&amp;_is_scavengable);
 209 }
 210 
 211 void GenCollectedHeap::ref_processing_init() {
 212   _young_gen-&gt;ref_processor_init();
 213   _old_gen-&gt;ref_processor_init();
 214 }
 215 
 216 PreGenGCValues GenCollectedHeap::get_pre_gc_values() const {
 217   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();
 218 
 219   return PreGenGCValues(def_new_gen-&gt;used(),
 220                         def_new_gen-&gt;capacity(),
 221                         def_new_gen-&gt;eden()-&gt;used(),
 222                         def_new_gen-&gt;eden()-&gt;capacity(),
 223                         def_new_gen-&gt;from()-&gt;used(),
 224                         def_new_gen-&gt;from()-&gt;capacity(),
 225                         old_gen()-&gt;used(),
 226                         old_gen()-&gt;capacity());
 227 }
 228 
 229 GenerationSpec* GenCollectedHeap::young_gen_spec() const {
 230   return _young_gen_spec;
 231 }
 232 
 233 GenerationSpec* GenCollectedHeap::old_gen_spec() const {
 234   return _old_gen_spec;
 235 }
 236 
 237 size_t GenCollectedHeap::capacity() const {
 238   return _young_gen-&gt;capacity() + _old_gen-&gt;capacity();
 239 }
 240 
 241 size_t GenCollectedHeap::used() const {
 242   return _young_gen-&gt;used() + _old_gen-&gt;used();
 243 }
 244 
 245 void GenCollectedHeap::save_used_regions() {
 246   _old_gen-&gt;save_used_region();
 247   _young_gen-&gt;save_used_region();
 248 }
 249 
 250 size_t GenCollectedHeap::max_capacity() const {
 251   return _young_gen-&gt;max_capacity() + _old_gen-&gt;max_capacity();
 252 }
 253 
 254 // Update the _full_collections_completed counter
 255 // at the end of a stop-world full GC.
 256 unsigned int GenCollectedHeap::update_full_collections_completed() {
 257   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
 258   assert(_full_collections_completed &lt;= _total_full_collections,
 259          &quot;Can&#39;t complete more collections than were started&quot;);
 260   _full_collections_completed = _total_full_collections;
 261   ml.notify_all();
 262   return _full_collections_completed;
 263 }
 264 
 265 // Update the _full_collections_completed counter, as appropriate,
 266 // at the end of a concurrent GC cycle. Note the conditional update
 267 // below to allow this method to be called by a concurrent collector
 268 // without synchronizing in any manner with the VM thread (which
 269 // may already have initiated a STW full collection &quot;concurrently&quot;).
 270 unsigned int GenCollectedHeap::update_full_collections_completed(unsigned int count) {
 271   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
 272   assert((_full_collections_completed &lt;= _total_full_collections) &amp;&amp;
 273          (count &lt;= _total_full_collections),
 274          &quot;Can&#39;t complete more collections than were started&quot;);
 275   if (count &gt; _full_collections_completed) {
 276     _full_collections_completed = count;
 277     ml.notify_all();
 278   }
 279   return _full_collections_completed;
 280 }
 281 
 282 // Return true if any of the following is true:
 283 // . the allocation won&#39;t fit into the current young gen heap
 284 // . gc locker is occupied (jni critical section)
 285 // . heap memory is tight -- the most recent previous collection
 286 //   was a full collection because a partial collection (would
 287 //   have) failed and is likely to fail again
 288 bool GenCollectedHeap::should_try_older_generation_allocation(size_t word_size) const {
 289   size_t young_capacity = _young_gen-&gt;capacity_before_gc();
 290   return    (word_size &gt; heap_word_size(young_capacity))
 291          || GCLocker::is_active_and_needs_gc()
 292          || incremental_collection_failed();
 293 }
 294 
 295 HeapWord* GenCollectedHeap::expand_heap_and_allocate(size_t size, bool   is_tlab) {
 296   HeapWord* result = NULL;
 297   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 298     result = _old_gen-&gt;expand_and_allocate(size, is_tlab);
 299   }
 300   if (result == NULL) {
 301     if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 302       result = _young_gen-&gt;expand_and_allocate(size, is_tlab);
 303     }
 304   }
 305   assert(result == NULL || is_in_reserved(result), &quot;result not in heap&quot;);
 306   return result;
 307 }
 308 
 309 HeapWord* GenCollectedHeap::mem_allocate_work(size_t size,
 310                                               bool is_tlab,
 311                                               bool* gc_overhead_limit_was_exceeded) {
 312   // In general gc_overhead_limit_was_exceeded should be false so
 313   // set it so here and reset it to true only if the gc time
 314   // limit is being exceeded as checked below.
 315   *gc_overhead_limit_was_exceeded = false;
 316 
 317   HeapWord* result = NULL;
 318 
 319   // Loop until the allocation is satisfied, or unsatisfied after GC.
 320   for (uint try_count = 1, gclocker_stalled_count = 0; /* return or throw */; try_count += 1) {
 321     HandleMark hm; // Discard any handles allocated in each iteration.
 322 
 323     // First allocation attempt is lock-free.
 324     Generation *young = _young_gen;
 325     assert(young-&gt;supports_inline_contig_alloc(),
 326       &quot;Otherwise, must do alloc within heap lock&quot;);
 327     if (young-&gt;should_allocate(size, is_tlab)) {
 328       result = young-&gt;par_allocate(size, is_tlab);
 329       if (result != NULL) {
 330         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 331         return result;
 332       }
 333     }
 334     uint gc_count_before;  // Read inside the Heap_lock locked region.
 335     {
 336       MutexLocker ml(Heap_lock);
 337       log_trace(gc, alloc)(&quot;GenCollectedHeap::mem_allocate_work: attempting locked slow path allocation&quot;);
 338       // Note that only large objects get a shot at being
 339       // allocated in later generations.
 340       bool first_only = !should_try_older_generation_allocation(size);
 341 
 342       result = attempt_allocation(size, is_tlab, first_only);
 343       if (result != NULL) {
 344         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 345         return result;
 346       }
 347 
 348       if (GCLocker::is_active_and_needs_gc()) {
 349         if (is_tlab) {
 350           return NULL;  // Caller will retry allocating individual object.
 351         }
 352         if (!is_maximal_no_gc()) {
 353           // Try and expand heap to satisfy request.
 354           result = expand_heap_and_allocate(size, is_tlab);
 355           // Result could be null if we are out of space.
 356           if (result != NULL) {
 357             return result;
 358           }
 359         }
 360 
 361         if (gclocker_stalled_count &gt; GCLockerRetryAllocationCount) {
 362           return NULL; // We didn&#39;t get to do a GC and we didn&#39;t get any memory.
 363         }
 364 
 365         // If this thread is not in a jni critical section, we stall
 366         // the requestor until the critical section has cleared and
 367         // GC allowed. When the critical section clears, a GC is
 368         // initiated by the last thread exiting the critical section; so
 369         // we retry the allocation sequence from the beginning of the loop,
 370         // rather than causing more, now probably unnecessary, GC attempts.
 371         JavaThread* jthr = JavaThread::current();
 372         if (!jthr-&gt;in_critical()) {
 373           MutexUnlocker mul(Heap_lock);
 374           // Wait for JNI critical section to be exited
 375           GCLocker::stall_until_clear();
 376           gclocker_stalled_count += 1;
 377           continue;
 378         } else {
 379           if (CheckJNICalls) {
 380             fatal(&quot;Possible deadlock due to allocating while&quot;
 381                   &quot; in jni critical section&quot;);
 382           }
 383           return NULL;
 384         }
 385       }
 386 
 387       // Read the gc count while the heap lock is held.
 388       gc_count_before = total_collections();
 389     }
 390 
 391     VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);
 392     VMThread::execute(&amp;op);
 393     if (op.prologue_succeeded()) {
 394       result = op.result();
 395       if (op.gc_locked()) {
 396          assert(result == NULL, &quot;must be NULL if gc_locked() is true&quot;);
 397          continue;  // Retry and/or stall as necessary.
 398       }
 399 
 400       // Allocation has failed and a collection
 401       // has been done.  If the gc time limit was exceeded the
 402       // this time, return NULL so that an out-of-memory
 403       // will be thrown.  Clear gc_overhead_limit_exceeded
 404       // so that the overhead exceeded does not persist.
 405 
 406       const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded();
 407       const bool softrefs_clear = soft_ref_policy()-&gt;all_soft_refs_clear();
 408 
 409       if (limit_exceeded &amp;&amp; softrefs_clear) {
 410         *gc_overhead_limit_was_exceeded = true;
 411         size_policy()-&gt;set_gc_overhead_limit_exceeded(false);
 412         if (op.result() != NULL) {
 413           CollectedHeap::fill_with_object(op.result(), size);
 414         }
 415         return NULL;
 416       }
 417       assert(result == NULL || is_in_reserved(result),
 418              &quot;result not in heap&quot;);
 419       return result;
 420     }
 421 
 422     // Give a warning if we seem to be looping forever.
 423     if ((QueuedAllocationWarningCount &gt; 0) &amp;&amp;
 424         (try_count % QueuedAllocationWarningCount == 0)) {
 425           log_warning(gc, ergo)(&quot;GenCollectedHeap::mem_allocate_work retries %d times,&quot;
 426                                 &quot; size=&quot; SIZE_FORMAT &quot; %s&quot;, try_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);
 427     }
 428   }
 429 }
 430 
 431 HeapWord* GenCollectedHeap::attempt_allocation(size_t size,
 432                                                bool is_tlab,
 433                                                bool first_only) {
 434   HeapWord* res = NULL;
 435 
 436   if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 437     res = _young_gen-&gt;allocate(size, is_tlab);
 438     if (res != NULL || first_only) {
 439       return res;
 440     }
 441   }
 442 
 443   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 444     res = _old_gen-&gt;allocate(size, is_tlab);
 445   }
 446 
 447   return res;
 448 }
 449 
 450 HeapWord* GenCollectedHeap::mem_allocate(size_t size,
 451                                          bool* gc_overhead_limit_was_exceeded) {
 452   return mem_allocate_work(size,
 453                            false /* is_tlab */,
 454                            gc_overhead_limit_was_exceeded);
 455 }
 456 
 457 bool GenCollectedHeap::must_clear_all_soft_refs() {
 458   return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||
 459          _gc_cause == GCCause::_wb_full_gc;
 460 }
 461 
 462 void GenCollectedHeap::collect_generation(Generation* gen, bool full, size_t size,
 463                                           bool is_tlab, bool run_verification, bool clear_soft_refs,
 464                                           bool restore_marks_for_biased_locking) {
 465   FormatBuffer&lt;&gt; title(&quot;Collect gen: %s&quot;, gen-&gt;short_name());
 466   GCTraceTime(Trace, gc, phases) t1(title);
 467   TraceCollectorStats tcs(gen-&gt;counters());
 468   TraceMemoryManagerStats tmms(gen-&gt;gc_manager(), gc_cause());
 469 
 470   gen-&gt;stat_record()-&gt;invocations++;
 471   gen-&gt;stat_record()-&gt;accumulated_time.start();
 472 
 473   // Must be done anew before each collection because
 474   // a previous collection will do mangling and will
 475   // change top of some spaces.
 476   record_gen_tops_before_GC();
 477 
 478   log_trace(gc)(&quot;%s invoke=%d size=&quot; SIZE_FORMAT, heap()-&gt;is_young_gen(gen) ? &quot;Young&quot; : &quot;Old&quot;, gen-&gt;stat_record()-&gt;invocations, size * HeapWordSize);
 479 
 480   if (run_verification &amp;&amp; VerifyBeforeGC) {
 481     HandleMark hm;  // Discard invalid handles created during verification
 482     Universe::verify(&quot;Before GC&quot;);
 483   }
 484   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());
 485 
 486   if (restore_marks_for_biased_locking) {
 487     // We perform this mark word preservation work lazily
 488     // because it&#39;s only at this point that we know whether we
 489     // absolutely have to do it; we want to avoid doing it for
 490     // scavenge-only collections where it&#39;s unnecessary
 491     BiasedLocking::preserve_marks();
 492   }
 493 
 494   // Do collection work
 495   {
 496     // Note on ref discovery: For what appear to be historical reasons,
 497     // GCH enables and disabled (by enqueing) refs discovery.
 498     // In the future this should be moved into the generation&#39;s
 499     // collect method so that ref discovery and enqueueing concerns
 500     // are local to a generation. The collect method could return
 501     // an appropriate indication in the case that notification on
 502     // the ref lock was needed. This will make the treatment of
 503     // weak refs more uniform (and indeed remove such concerns
 504     // from GCH). XXX
 505 
 506     HandleMark hm;  // Discard invalid handles created during gc
 507     save_marks();   // save marks for all gens
 508     // We want to discover references, but not process them yet.
 509     // This mode is disabled in process_discovered_references if the
 510     // generation does some collection work, or in
 511     // enqueue_discovered_references if the generation returns
 512     // without doing any work.
 513     ReferenceProcessor* rp = gen-&gt;ref_processor();
 514     // If the discovery of (&quot;weak&quot;) refs in this generation is
 515     // atomic wrt other collectors in this configuration, we
 516     // are guaranteed to have empty discovered ref lists.
 517     if (rp-&gt;discovery_is_atomic()) {
 518       rp-&gt;enable_discovery();
 519       rp-&gt;setup_policy(clear_soft_refs);
 520     } else {
 521       // collect() below will enable discovery as appropriate
 522     }
 523     gen-&gt;collect(full, clear_soft_refs, size, is_tlab);
 524     if (!rp-&gt;enqueuing_is_done()) {
 525       rp-&gt;disable_discovery();
 526     } else {
 527       rp-&gt;set_enqueuing_is_done(false);
 528     }
 529     rp-&gt;verify_no_references_recorded();
 530   }
 531 
 532   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());
 533 
 534   gen-&gt;stat_record()-&gt;accumulated_time.stop();
 535 
 536   update_gc_stats(gen, full);
 537 
 538   if (run_verification &amp;&amp; VerifyAfterGC) {
 539     HandleMark hm;  // Discard invalid handles created during verification
 540     Universe::verify(&quot;After GC&quot;);
 541   }
 542 }
 543 
 544 void GenCollectedHeap::do_collection(bool           full,
 545                                      bool           clear_all_soft_refs,
 546                                      size_t         size,
 547                                      bool           is_tlab,
 548                                      GenerationType max_generation) {
 549   ResourceMark rm;
 550   DEBUG_ONLY(Thread* my_thread = Thread::current();)
 551 
 552   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
 553   assert(my_thread-&gt;is_VM_thread() ||
 554          my_thread-&gt;is_ConcurrentGC_thread(),
 555          &quot;incorrect thread type capability&quot;);
 556   assert(Heap_lock-&gt;is_locked(),
 557          &quot;the requesting thread should have the Heap_lock&quot;);
 558   guarantee(!is_gc_active(), &quot;collection is not reentrant&quot;);
 559 
 560   if (GCLocker::check_active_before_gc()) {
 561     return; // GC is disabled (e.g. JNI GetXXXCritical operation)
 562   }
 563 
 564   const bool do_clear_all_soft_refs = clear_all_soft_refs ||
 565                           soft_ref_policy()-&gt;should_clear_all_soft_refs();
 566 
 567   ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());
 568 
 569   FlagSetting fl(_is_gc_active, true);
 570 
 571   bool complete = full &amp;&amp; (max_generation == OldGen);
 572   bool old_collects_young = complete &amp;&amp; !ScavengeBeforeFullGC;
 573   bool do_young_collection = !old_collects_young &amp;&amp; _young_gen-&gt;should_collect(full, size, is_tlab);
 574 
 575   const PreGenGCValues pre_gc_values = get_pre_gc_values();
 576 
 577   bool run_verification = total_collections() &gt;= VerifyGCStartAt;
 578   bool prepared_for_verification = false;
 579   bool do_full_collection = false;
 580 
 581   if (do_young_collection) {
 582     GCIdMark gc_id_mark;
 583     GCTraceCPUTime tcpu;
 584     GCTraceTime(Info, gc) t(&quot;Pause Young&quot;, NULL, gc_cause(), true);
 585 
 586     print_heap_before_gc();
 587 
 588     if (run_verification &amp;&amp; VerifyGCLevel &lt;= 0 &amp;&amp; VerifyBeforeGC) {
 589       prepare_for_verify();
 590       prepared_for_verification = true;
 591     }
 592 
 593     gc_prologue(complete);
 594     increment_total_collections(complete);
 595 
 596     collect_generation(_young_gen,
 597                        full,
 598                        size,
 599                        is_tlab,
 600                        run_verification &amp;&amp; VerifyGCLevel &lt;= 0,
 601                        do_clear_all_soft_refs,
 602                        false);
 603 
 604     if (size &gt; 0 &amp;&amp; (!is_tlab || _young_gen-&gt;supports_tlab_allocation()) &amp;&amp;
 605         size * HeapWordSize &lt;= _young_gen-&gt;unsafe_max_alloc_nogc()) {
 606       // Allocation request was met by young GC.
 607       size = 0;
 608     }
 609 
 610     // Ask if young collection is enough. If so, do the final steps for young collection,
 611     // and fallthrough to the end.
 612     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 613     if (!do_full_collection) {
 614       // Adjust generation sizes.
 615       _young_gen-&gt;compute_new_size();
 616 
 617       print_heap_change(pre_gc_values);
 618 
 619       // Track memory usage and detect low memory after GC finishes
 620       MemoryService::track_memory_usage();
 621 
 622       gc_epilogue(complete);
 623     }
 624 
 625     print_heap_after_gc();
 626 
 627   } else {
 628     // No young collection, ask if we need to perform Full collection.
 629     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 630   }
 631 
 632   if (do_full_collection) {
 633     GCIdMark gc_id_mark;
 634     GCTraceCPUTime tcpu;
 635     GCTraceTime(Info, gc) t(&quot;Pause Full&quot;, NULL, gc_cause(), true);
 636 
 637     print_heap_before_gc();
 638 
 639     if (!prepared_for_verification &amp;&amp; run_verification &amp;&amp;
 640         VerifyGCLevel &lt;= 1 &amp;&amp; VerifyBeforeGC) {
 641       prepare_for_verify();
 642     }
 643 
 644     if (!do_young_collection) {
 645       gc_prologue(complete);
 646       increment_total_collections(complete);
 647     }
 648 
 649     // Accounting quirk: total full collections would be incremented when &quot;complete&quot;
 650     // is set, by calling increment_total_collections above. However, we also need to
 651     // account Full collections that had &quot;complete&quot; unset.
 652     if (!complete) {
 653       increment_total_full_collections();
 654     }
 655 
 656     collect_generation(_old_gen,
 657                        full,
 658                        size,
 659                        is_tlab,
 660                        run_verification &amp;&amp; VerifyGCLevel &lt;= 1,
 661                        do_clear_all_soft_refs,
 662                        true);
 663 
 664     // Adjust generation sizes.
 665     _old_gen-&gt;compute_new_size();
 666     _young_gen-&gt;compute_new_size();
 667 
 668     // Delete metaspaces for unloaded class loaders and clean up loader_data graph
 669     ClassLoaderDataGraph::purge();
 670     MetaspaceUtils::verify_metrics();
 671     // Resize the metaspace capacity after full collections
 672     MetaspaceGC::compute_new_size();
 673     update_full_collections_completed();
 674 
 675     print_heap_change(pre_gc_values);
 676 
 677     // Track memory usage and detect low memory after GC finishes
 678     MemoryService::track_memory_usage();
 679 
 680     // Need to tell the epilogue code we are done with Full GC, regardless what was
 681     // the initial value for &quot;complete&quot; flag.
 682     gc_epilogue(true);
 683 
 684     BiasedLocking::restore_marks();
 685 
 686     print_heap_after_gc();
 687   }
 688 }
 689 
 690 bool GenCollectedHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,
 691                                                  GenCollectedHeap::GenerationType max_gen) const {
 692   return max_gen == OldGen &amp;&amp; _old_gen-&gt;should_collect(full, size, is_tlab);
 693 }
 694 
 695 void GenCollectedHeap::register_nmethod(nmethod* nm) {
 696   ScavengableNMethods::register_nmethod(nm);
 697 }
 698 
 699 void GenCollectedHeap::unregister_nmethod(nmethod* nm) {
 700   ScavengableNMethods::unregister_nmethod(nm);
 701 }
 702 
 703 void GenCollectedHeap::verify_nmethod(nmethod* nm) {
 704   ScavengableNMethods::verify_nmethod(nm);
 705 }
 706 
 707 void GenCollectedHeap::flush_nmethod(nmethod* nm) {
 708   // Do nothing.
 709 }
 710 
 711 void GenCollectedHeap::prune_scavengable_nmethods() {
 712   ScavengableNMethods::prune_nmethods();
 713 }
 714 
 715 HeapWord* GenCollectedHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {
 716   GCCauseSetter x(this, GCCause::_allocation_failure);
 717   HeapWord* result = NULL;
 718 
 719   assert(size != 0, &quot;Precondition violated&quot;);
 720   if (GCLocker::is_active_and_needs_gc()) {
 721     // GC locker is active; instead of a collection we will attempt
 722     // to expand the heap, if there&#39;s room for expansion.
 723     if (!is_maximal_no_gc()) {
 724       result = expand_heap_and_allocate(size, is_tlab);
 725     }
 726     return result;   // Could be null if we are out of space.
 727   } else if (!incremental_collection_will_fail(false /* don&#39;t consult_young */)) {
 728     // Do an incremental collection.
 729     do_collection(false,                     // full
 730                   false,                     // clear_all_soft_refs
 731                   size,                      // size
 732                   is_tlab,                   // is_tlab
 733                   GenCollectedHeap::OldGen); // max_generation
 734   } else {
 735     log_trace(gc)(&quot; :: Trying full because partial may fail :: &quot;);
 736     // Try a full collection; see delta for bug id 6266275
 737     // for the original code and why this has been simplified
 738     // with from-space allocation criteria modified and
 739     // such allocation moved out of the safepoint path.
 740     do_collection(true,                      // full
 741                   false,                     // clear_all_soft_refs
 742                   size,                      // size
 743                   is_tlab,                   // is_tlab
 744                   GenCollectedHeap::OldGen); // max_generation
 745   }
 746 
 747   result = attempt_allocation(size, is_tlab, false /*first_only*/);
 748 
 749   if (result != NULL) {
 750     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 751     return result;
 752   }
 753 
 754   // OK, collection failed, try expansion.
 755   result = expand_heap_and_allocate(size, is_tlab);
 756   if (result != NULL) {
 757     return result;
 758   }
 759 
 760   // If we reach this point, we&#39;re really out of memory. Try every trick
 761   // we can to reclaim memory. Force collection of soft references. Force
 762   // a complete compaction of the heap. Any additional methods for finding
 763   // free memory should be here, especially if they are expensive. If this
 764   // attempt fails, an OOM exception will be thrown.
 765   {
 766     UIntFlagSetting flag_change(MarkSweepAlwaysCompactCount, 1); // Make sure the heap is fully compacted
 767 
 768     do_collection(true,                      // full
 769                   true,                      // clear_all_soft_refs
 770                   size,                      // size
 771                   is_tlab,                   // is_tlab
 772                   GenCollectedHeap::OldGen); // max_generation
 773   }
 774 
 775   result = attempt_allocation(size, is_tlab, false /* first_only */);
 776   if (result != NULL) {
 777     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 778     return result;
 779   }
 780 
 781   assert(!soft_ref_policy()-&gt;should_clear_all_soft_refs(),
 782     &quot;Flag should have been handled and cleared prior to this point&quot;);
 783 
 784   // What else?  We might try synchronous finalization later.  If the total
 785   // space available is large enough for the allocation, then a more
 786   // complete compaction phase than we&#39;ve tried so far might be
 787   // appropriate.
 788   return NULL;
 789 }
 790 
 791 #ifdef ASSERT
 792 class AssertNonScavengableClosure: public OopClosure {
 793 public:
 794   virtual void do_oop(oop* p) {
 795     assert(!GenCollectedHeap::heap()-&gt;is_in_partial_collection(*p),
 796       &quot;Referent should not be scavengable.&quot;);  }
 797   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
 798 };
 799 static AssertNonScavengableClosure assert_is_non_scavengable_closure;
 800 #endif
 801 
 802 void GenCollectedHeap::process_roots(StrongRootsScope* scope,
 803                                      ScanningOption so,
 804                                      OopClosure* strong_roots,
 805                                      CLDClosure* strong_cld_closure,
 806                                      CLDClosure* weak_cld_closure,
 807                                      CodeBlobToOopClosure* code_roots) {
 808   // General roots.
 809   assert(code_roots != NULL, &quot;code root closure should always be set&quot;);
 810   // _n_termination for _process_strong_tasks should be set up stream
 811   // in a method not running in a GC worker.  Otherwise the GC worker
 812   // could be trying to change the termination condition while the task
 813   // is executing in another GC worker.
 814 
 815   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ClassLoaderDataGraph_oops_do)) {
 816     ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);
 817   }
 818 
 819   // Only process code roots from thread stacks if we aren&#39;t visiting the entire CodeCache anyway
 820   CodeBlobToOopClosure* roots_from_code_p = (so &amp; SO_AllCodeCache) ? NULL : code_roots;
 821 
 822   bool is_par = scope-&gt;n_threads() &gt; 1;
 823   Threads::possibly_parallel_oops_do(is_par, strong_roots, roots_from_code_p);
 824 
 825   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Universe_oops_do)) {
 826     Universe::oops_do(strong_roots);
 827   }
<a name="2" id="anc2"></a>



 828 
 829   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ObjectSynchronizer_oops_do)) {
 830     ObjectSynchronizer::oops_do(strong_roots);
 831   }
 832   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Management_oops_do)) {
 833     Management::oops_do(strong_roots);
 834   }
 835   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_jvmti_oops_do)) {
 836     JvmtiExport::oops_do(strong_roots);
 837   }
 838 #if INCLUDE_AOT
 839   if (UseAOT &amp;&amp; _process_strong_tasks-&gt;try_claim_task(GCH_PS_aot_oops_do)) {
 840     AOTLoader::oops_do(strong_roots);
 841   }
 842 #endif
<a name="3" id="anc3"></a><span class="line-modified"> 843   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_OopStorageSet_oops_do)) {</span>
<span class="line-modified"> 844     OopStorageSet::strong_oops_do(strong_roots);</span>
 845   }
 846 
 847   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_CodeCache_oops_do)) {
 848     if (so &amp; SO_ScavengeCodeCache) {
 849       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 850 
 851       // We only visit parts of the CodeCache when scavenging.
 852       ScavengableNMethods::nmethods_do(code_roots);
 853     }
 854     if (so &amp; SO_AllCodeCache) {
 855       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 856 
 857       // CMSCollector uses this to do intermediate-strength collections.
 858       // We scan the entire code cache, since CodeCache::do_unloading is not called.
 859       CodeCache::blobs_do(code_roots);
 860     }
 861     // Verify that the code cache contents are not subject to
 862     // movement by a scavenging collection.
 863     DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&amp;assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));
 864     DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&amp;assert_code_is_non_scavengable));
 865   }
 866 }
 867 
 868 void GenCollectedHeap::young_process_roots(StrongRootsScope* scope,
 869                                            OopsInGenClosure* root_closure,
 870                                            OopsInGenClosure* old_gen_closure,
 871                                            CLDClosure* cld_closure) {
 872   MarkingCodeBlobClosure mark_code_closure(root_closure, CodeBlobToOopClosure::FixRelocations);
 873 
 874   process_roots(scope, SO_ScavengeCodeCache, root_closure,
 875                 cld_closure, cld_closure, &amp;mark_code_closure);
 876 
 877   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_younger_gens)) {
 878     root_closure-&gt;reset_generation();
 879   }
 880 
 881   // When collection is parallel, all threads get to cooperate to do
 882   // old generation scanning.
 883   old_gen_closure-&gt;set_generation(_old_gen);
 884   rem_set()-&gt;younger_refs_iterate(_old_gen, old_gen_closure, scope-&gt;n_threads());
 885   old_gen_closure-&gt;reset_generation();
 886 
 887   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 888 }
 889 
 890 void GenCollectedHeap::full_process_roots(StrongRootsScope* scope,
 891                                           bool is_adjust_phase,
 892                                           ScanningOption so,
 893                                           bool only_strong_roots,
 894                                           OopsInGenClosure* root_closure,
 895                                           CLDClosure* cld_closure) {
 896   MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase);
 897   CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;
 898 
 899   process_roots(scope, so, root_closure, cld_closure, weak_cld_closure, &amp;mark_code_closure);
 900   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 901 }
 902 
 903 void GenCollectedHeap::gen_process_weak_roots(OopClosure* root_closure) {
 904   WeakProcessor::oops_do(root_closure);
 905   _young_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 906   _old_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 907 }
 908 
 909 bool GenCollectedHeap::no_allocs_since_save_marks() {
 910   return _young_gen-&gt;no_allocs_since_save_marks() &amp;&amp;
 911          _old_gen-&gt;no_allocs_since_save_marks();
 912 }
 913 
 914 bool GenCollectedHeap::supports_inline_contig_alloc() const {
 915   return _young_gen-&gt;supports_inline_contig_alloc();
 916 }
 917 
 918 HeapWord* volatile* GenCollectedHeap::top_addr() const {
 919   return _young_gen-&gt;top_addr();
 920 }
 921 
 922 HeapWord** GenCollectedHeap::end_addr() const {
 923   return _young_gen-&gt;end_addr();
 924 }
 925 
 926 // public collection interfaces
 927 
 928 void GenCollectedHeap::collect(GCCause::Cause cause) {
 929   if ((cause == GCCause::_wb_young_gc) ||
 930       (cause == GCCause::_gc_locker)) {
 931     // Young collection for WhiteBox or GCLocker.
 932     collect(cause, YoungGen);
 933   } else {
 934 #ifdef ASSERT
 935   if (cause == GCCause::_scavenge_alot) {
 936     // Young collection only.
 937     collect(cause, YoungGen);
 938   } else {
 939     // Stop-the-world full collection.
 940     collect(cause, OldGen);
 941   }
 942 #else
 943     // Stop-the-world full collection.
 944     collect(cause, OldGen);
 945 #endif
 946   }
 947 }
 948 
 949 void GenCollectedHeap::collect(GCCause::Cause cause, GenerationType max_generation) {
 950   // The caller doesn&#39;t have the Heap_lock
 951   assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);
 952   MutexLocker ml(Heap_lock);
 953   collect_locked(cause, max_generation);
 954 }
 955 
 956 void GenCollectedHeap::collect_locked(GCCause::Cause cause) {
 957   // The caller has the Heap_lock
 958   assert(Heap_lock-&gt;owned_by_self(), &quot;this thread should own the Heap_lock&quot;);
 959   collect_locked(cause, OldGen);
 960 }
 961 
 962 // this is the private collection interface
 963 // The Heap_lock is expected to be held on entry.
 964 
 965 void GenCollectedHeap::collect_locked(GCCause::Cause cause, GenerationType max_generation) {
 966   // Read the GC count while holding the Heap_lock
 967   unsigned int gc_count_before      = total_collections();
 968   unsigned int full_gc_count_before = total_full_collections();
 969 
 970   if (GCLocker::should_discard(cause, gc_count_before)) {
 971     return;
 972   }
 973 
 974   {
 975     MutexUnlocker mu(Heap_lock);  // give up heap lock, execute gets it back
 976     VM_GenCollectFull op(gc_count_before, full_gc_count_before,
 977                          cause, max_generation);
 978     VMThread::execute(&amp;op);
 979   }
 980 }
 981 
 982 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
 983    do_full_collection(clear_all_soft_refs, OldGen);
 984 }
 985 
 986 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs,
 987                                           GenerationType last_generation) {
 988   do_collection(true,                   // full
 989                 clear_all_soft_refs,    // clear_all_soft_refs
 990                 0,                      // size
 991                 false,                  // is_tlab
 992                 last_generation);       // last_generation
 993   // Hack XXX FIX ME !!!
 994   // A scavenge may not have been attempted, or may have
 995   // been attempted and failed, because the old gen was too full
 996   if (gc_cause() == GCCause::_gc_locker &amp;&amp; incremental_collection_failed()) {
 997     log_debug(gc, jni)(&quot;GC locker: Trying a full collection because scavenge failed&quot;);
 998     // This time allow the old gen to be collected as well
 999     do_collection(true,                // full
1000                   clear_all_soft_refs, // clear_all_soft_refs
1001                   0,                   // size
1002                   false,               // is_tlab
1003                   OldGen);             // last_generation
1004   }
1005 }
1006 
1007 bool GenCollectedHeap::is_in_young(oop p) {
1008   bool result = cast_from_oop&lt;HeapWord*&gt;(p) &lt; _old_gen-&gt;reserved().start();
1009   assert(result == _young_gen-&gt;is_in_reserved(p),
1010          &quot;incorrect test - result=%d, p=&quot; INTPTR_FORMAT, result, p2i((void*)p));
1011   return result;
1012 }
1013 
1014 // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
1015 bool GenCollectedHeap::is_in(const void* p) const {
1016   return _young_gen-&gt;is_in(p) || _old_gen-&gt;is_in(p);
1017 }
1018 
1019 #ifdef ASSERT
1020 // Don&#39;t implement this by using is_in_young().  This method is used
1021 // in some cases to check that is_in_young() is correct.
1022 bool GenCollectedHeap::is_in_partial_collection(const void* p) {
1023   assert(is_in_reserved(p) || p == NULL,
1024     &quot;Does not work if address is non-null and outside of the heap&quot;);
1025   return p &lt; _young_gen-&gt;reserved().end() &amp;&amp; p != NULL;
1026 }
1027 #endif
1028 
1029 void GenCollectedHeap::oop_iterate(OopIterateClosure* cl) {
1030   _young_gen-&gt;oop_iterate(cl);
1031   _old_gen-&gt;oop_iterate(cl);
1032 }
1033 
1034 void GenCollectedHeap::object_iterate(ObjectClosure* cl) {
1035   _young_gen-&gt;object_iterate(cl);
1036   _old_gen-&gt;object_iterate(cl);
1037 }
1038 
1039 Space* GenCollectedHeap::space_containing(const void* addr) const {
1040   Space* res = _young_gen-&gt;space_containing(addr);
1041   if (res != NULL) {
1042     return res;
1043   }
1044   res = _old_gen-&gt;space_containing(addr);
1045   assert(res != NULL, &quot;Could not find containing space&quot;);
1046   return res;
1047 }
1048 
1049 HeapWord* GenCollectedHeap::block_start(const void* addr) const {
1050   assert(is_in_reserved(addr), &quot;block_start of address outside of heap&quot;);
1051   if (_young_gen-&gt;is_in_reserved(addr)) {
1052     assert(_young_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1053     return _young_gen-&gt;block_start(addr);
1054   }
1055 
1056   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1057   assert(_old_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1058   return _old_gen-&gt;block_start(addr);
1059 }
1060 
1061 bool GenCollectedHeap::block_is_obj(const HeapWord* addr) const {
1062   assert(is_in_reserved(addr), &quot;block_is_obj of address outside of heap&quot;);
1063   assert(block_start(addr) == addr, &quot;addr must be a block start&quot;);
1064   if (_young_gen-&gt;is_in_reserved(addr)) {
1065     return _young_gen-&gt;block_is_obj(addr);
1066   }
1067 
1068   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1069   return _old_gen-&gt;block_is_obj(addr);
1070 }
1071 
1072 bool GenCollectedHeap::supports_tlab_allocation() const {
1073   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1074   return _young_gen-&gt;supports_tlab_allocation();
1075 }
1076 
1077 size_t GenCollectedHeap::tlab_capacity(Thread* thr) const {
1078   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1079   if (_young_gen-&gt;supports_tlab_allocation()) {
1080     return _young_gen-&gt;tlab_capacity();
1081   }
1082   return 0;
1083 }
1084 
1085 size_t GenCollectedHeap::tlab_used(Thread* thr) const {
1086   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1087   if (_young_gen-&gt;supports_tlab_allocation()) {
1088     return _young_gen-&gt;tlab_used();
1089   }
1090   return 0;
1091 }
1092 
1093 size_t GenCollectedHeap::unsafe_max_tlab_alloc(Thread* thr) const {
1094   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1095   if (_young_gen-&gt;supports_tlab_allocation()) {
1096     return _young_gen-&gt;unsafe_max_tlab_alloc();
1097   }
1098   return 0;
1099 }
1100 
1101 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1102                                               size_t requested_size,
1103                                               size_t* actual_size) {
1104   bool gc_overhead_limit_was_exceeded;
1105   HeapWord* result = mem_allocate_work(requested_size /* size */,
1106                                        true /* is_tlab */,
1107                                        &amp;gc_overhead_limit_was_exceeded);
1108   if (result != NULL) {
1109     *actual_size = requested_size;
1110   }
1111 
1112   return result;
1113 }
1114 
1115 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1116 // from the list headed by &quot;*prev_ptr&quot;.
1117 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1118   bool first = true;
1119   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
1120   ScratchBlock **smallest_ptr, *smallest;
1121   ScratchBlock  *cur = *prev_ptr;
1122   while (cur) {
1123     assert(*prev_ptr == cur, &quot;just checking&quot;);
1124     if (first || cur-&gt;num_words &lt; min_size) {
1125       smallest_ptr = prev_ptr;
1126       smallest     = cur;
1127       min_size     = smallest-&gt;num_words;
1128       first        = false;
1129     }
1130     prev_ptr = &amp;cur-&gt;next;
1131     cur     =  cur-&gt;next;
1132   }
1133   smallest      = *smallest_ptr;
1134   *smallest_ptr = smallest-&gt;next;
1135   return smallest;
1136 }
1137 
1138 // Sort the scratch block list headed by res into decreasing size order,
1139 // and set &quot;res&quot; to the result.
1140 static void sort_scratch_list(ScratchBlock*&amp; list) {
1141   ScratchBlock* sorted = NULL;
1142   ScratchBlock* unsorted = list;
1143   while (unsorted) {
1144     ScratchBlock *smallest = removeSmallestScratch(&amp;unsorted);
1145     smallest-&gt;next  = sorted;
1146     sorted          = smallest;
1147   }
1148   list = sorted;
1149 }
1150 
1151 ScratchBlock* GenCollectedHeap::gather_scratch(Generation* requestor,
1152                                                size_t max_alloc_words) {
1153   ScratchBlock* res = NULL;
1154   _young_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1155   _old_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1156   sort_scratch_list(res);
1157   return res;
1158 }
1159 
1160 void GenCollectedHeap::release_scratch() {
1161   _young_gen-&gt;reset_scratch();
1162   _old_gen-&gt;reset_scratch();
1163 }
1164 
1165 class GenPrepareForVerifyClosure: public GenCollectedHeap::GenClosure {
1166   void do_generation(Generation* gen) {
1167     gen-&gt;prepare_for_verify();
1168   }
1169 };
1170 
1171 void GenCollectedHeap::prepare_for_verify() {
1172   ensure_parsability(false);        // no need to retire TLABs
1173   GenPrepareForVerifyClosure blk;
1174   generation_iterate(&amp;blk, false);
1175 }
1176 
1177 void GenCollectedHeap::generation_iterate(GenClosure* cl,
1178                                           bool old_to_young) {
1179   if (old_to_young) {
1180     cl-&gt;do_generation(_old_gen);
1181     cl-&gt;do_generation(_young_gen);
1182   } else {
1183     cl-&gt;do_generation(_young_gen);
1184     cl-&gt;do_generation(_old_gen);
1185   }
1186 }
1187 
1188 bool GenCollectedHeap::is_maximal_no_gc() const {
1189   return _young_gen-&gt;is_maximal_no_gc() &amp;&amp; _old_gen-&gt;is_maximal_no_gc();
1190 }
1191 
1192 void GenCollectedHeap::save_marks() {
1193   _young_gen-&gt;save_marks();
1194   _old_gen-&gt;save_marks();
1195 }
1196 
1197 GenCollectedHeap* GenCollectedHeap::heap() {
<a name="4" id="anc4"></a><span class="line-modified">1198   // SerialHeap is the only subtype of GenCollectedHeap.</span>
<span class="line-modified">1199   return named_heap&lt;GenCollectedHeap&gt;(CollectedHeap::Serial);</span>


1200 }
1201 
1202 #if INCLUDE_SERIALGC
1203 void GenCollectedHeap::prepare_for_compaction() {
1204   // Start by compacting into same gen.
1205   CompactPoint cp(_old_gen);
1206   _old_gen-&gt;prepare_for_compaction(&amp;cp);
1207   _young_gen-&gt;prepare_for_compaction(&amp;cp);
1208 }
1209 #endif // INCLUDE_SERIALGC
1210 
1211 void GenCollectedHeap::verify(VerifyOption option /* ignored */) {
1212   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1213   _old_gen-&gt;verify();
1214 
1215   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1216   _young_gen-&gt;verify();
1217 
1218   log_debug(gc, verify)(&quot;RemSet&quot;);
1219   rem_set()-&gt;verify();
1220 }
1221 
1222 void GenCollectedHeap::print_on(outputStream* st) const {
1223   if (_young_gen != NULL) {
1224     _young_gen-&gt;print_on(st);
1225   }
1226   if (_old_gen != NULL) {
1227     _old_gen-&gt;print_on(st);
1228   }
1229   MetaspaceUtils::print_on(st);
1230 }
1231 
1232 void GenCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
1233 }
1234 
1235 bool GenCollectedHeap::print_location(outputStream* st, void* addr) const {
1236   return BlockLocationPrinter&lt;GenCollectedHeap&gt;::print_location(st, addr);
1237 }
1238 
1239 void GenCollectedHeap::print_tracing_info() const {
1240   if (log_is_enabled(Debug, gc, heap, exit)) {
1241     LogStreamHandle(Debug, gc, heap, exit) lsh;
1242     _young_gen-&gt;print_summary_info_on(&amp;lsh);
1243     _old_gen-&gt;print_summary_info_on(&amp;lsh);
1244   }
1245 }
1246 
1247 void GenCollectedHeap::print_heap_change(const PreGenGCValues&amp; pre_gc_values) const {
1248   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();
1249 
1250   log_info(gc, heap)(HEAP_CHANGE_FORMAT&quot; &quot;
1251                      HEAP_CHANGE_FORMAT&quot; &quot;
1252                      HEAP_CHANGE_FORMAT,
1253                      HEAP_CHANGE_FORMAT_ARGS(def_new_gen-&gt;short_name(),
1254                                              pre_gc_values.young_gen_used(),
1255                                              pre_gc_values.young_gen_capacity(),
1256                                              def_new_gen-&gt;used(),
1257                                              def_new_gen-&gt;capacity()),
1258                      HEAP_CHANGE_FORMAT_ARGS(&quot;Eden&quot;,
1259                                              pre_gc_values.eden_used(),
1260                                              pre_gc_values.eden_capacity(),
1261                                              def_new_gen-&gt;eden()-&gt;used(),
1262                                              def_new_gen-&gt;eden()-&gt;capacity()),
1263                      HEAP_CHANGE_FORMAT_ARGS(&quot;From&quot;,
1264                                              pre_gc_values.from_used(),
1265                                              pre_gc_values.from_capacity(),
1266                                              def_new_gen-&gt;from()-&gt;used(),
1267                                              def_new_gen-&gt;from()-&gt;capacity()));
1268   log_info(gc, heap)(HEAP_CHANGE_FORMAT,
1269                      HEAP_CHANGE_FORMAT_ARGS(old_gen()-&gt;short_name(),
1270                                              pre_gc_values.old_gen_used(),
1271                                              pre_gc_values.old_gen_capacity(),
1272                                              old_gen()-&gt;used(),
1273                                              old_gen()-&gt;capacity()));
1274   MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());
1275 }
1276 
1277 class GenGCPrologueClosure: public GenCollectedHeap::GenClosure {
1278  private:
1279   bool _full;
1280  public:
1281   void do_generation(Generation* gen) {
1282     gen-&gt;gc_prologue(_full);
1283   }
1284   GenGCPrologueClosure(bool full) : _full(full) {};
1285 };
1286 
1287 void GenCollectedHeap::gc_prologue(bool full) {
1288   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
1289 
1290   // Fill TLAB&#39;s and such
1291   ensure_parsability(true);   // retire TLABs
1292 
1293   // Walk generations
1294   GenGCPrologueClosure blk(full);
1295   generation_iterate(&amp;blk, false);  // not old-to-young.
1296 };
1297 
1298 class GenGCEpilogueClosure: public GenCollectedHeap::GenClosure {
1299  private:
1300   bool _full;
1301  public:
1302   void do_generation(Generation* gen) {
1303     gen-&gt;gc_epilogue(_full);
1304   }
1305   GenGCEpilogueClosure(bool full) : _full(full) {};
1306 };
1307 
1308 void GenCollectedHeap::gc_epilogue(bool full) {
1309 #if COMPILER2_OR_JVMCI
1310   assert(DerivedPointerTable::is_empty(), &quot;derived pointer present&quot;);
1311   size_t actual_gap = pointer_delta((HeapWord*) (max_uintx-3), *(end_addr()));
1312   guarantee(is_client_compilation_mode_vm() || actual_gap &gt; (size_t)FastAllocateSizeLimit, &quot;inline allocation wraps&quot;);
1313 #endif // COMPILER2_OR_JVMCI
1314 
1315   resize_all_tlabs();
1316 
1317   GenGCEpilogueClosure blk(full);
1318   generation_iterate(&amp;blk, false);  // not old-to-young.
1319 
1320   if (!CleanChunkPoolAsync) {
1321     Chunk::clean_chunk_pool();
1322   }
1323 
1324   MetaspaceCounters::update_performance_counters();
1325   CompressedClassSpaceCounters::update_performance_counters();
1326 };
1327 
1328 #ifndef PRODUCT
1329 class GenGCSaveTopsBeforeGCClosure: public GenCollectedHeap::GenClosure {
1330  private:
1331  public:
1332   void do_generation(Generation* gen) {
1333     gen-&gt;record_spaces_top();
1334   }
1335 };
1336 
1337 void GenCollectedHeap::record_gen_tops_before_GC() {
1338   if (ZapUnusedHeapArea) {
1339     GenGCSaveTopsBeforeGCClosure blk;
1340     generation_iterate(&amp;blk, false);  // not old-to-young.
1341   }
1342 }
1343 #endif  // not PRODUCT
1344 
1345 class GenEnsureParsabilityClosure: public GenCollectedHeap::GenClosure {
1346  public:
1347   void do_generation(Generation* gen) {
1348     gen-&gt;ensure_parsability();
1349   }
1350 };
1351 
1352 void GenCollectedHeap::ensure_parsability(bool retire_tlabs) {
1353   CollectedHeap::ensure_parsability(retire_tlabs);
1354   GenEnsureParsabilityClosure ep_cl;
1355   generation_iterate(&amp;ep_cl, false);
1356 }
1357 
1358 oop GenCollectedHeap::handle_failed_promotion(Generation* old_gen,
1359                                               oop obj,
1360                                               size_t obj_size) {
1361   guarantee(old_gen == _old_gen, &quot;We only get here with an old generation&quot;);
1362   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
1363   HeapWord* result = NULL;
1364 
1365   result = old_gen-&gt;expand_and_allocate(obj_size, false);
1366 
1367   if (result != NULL) {
1368     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), result, obj_size);
1369   }
1370   return oop(result);
1371 }
1372 
1373 class GenTimeOfLastGCClosure: public GenCollectedHeap::GenClosure {
1374   jlong _time;   // in ms
1375   jlong _now;    // in ms
1376 
1377  public:
1378   GenTimeOfLastGCClosure(jlong now) : _time(now), _now(now) { }
1379 
1380   jlong time() { return _time; }
1381 
1382   void do_generation(Generation* gen) {
1383     _time = MIN2(_time, gen-&gt;time_of_last_gc(_now));
1384   }
1385 };
1386 
1387 jlong GenCollectedHeap::millis_since_last_gc() {
1388   // javaTimeNanos() is guaranteed to be monotonically non-decreasing
1389   // provided the underlying platform provides such a time source
1390   // (and it is bug free). So we still have to guard against getting
1391   // back a time later than &#39;now&#39;.
1392   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
1393   GenTimeOfLastGCClosure tolgc_cl(now);
1394   // iterate over generations getting the oldest
1395   // time that a generation was collected
1396   generation_iterate(&amp;tolgc_cl, false);
1397 
1398   jlong retVal = now - tolgc_cl.time();
1399   if (retVal &lt; 0) {
1400     log_warning(gc)(&quot;millis_since_last_gc() would return : &quot; JLONG_FORMAT
1401        &quot;. returning zero instead.&quot;, retVal);
1402     return 0;
1403   }
1404   return retVal;
1405 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>