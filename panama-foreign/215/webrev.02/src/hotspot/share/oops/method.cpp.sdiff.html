<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspaceShared.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopHandle.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 340 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 341   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 342 
 343   it-&gt;push(&amp;_constMethod);
 344   it-&gt;push(&amp;_method_data);
 345   it-&gt;push(&amp;_method_counters);
 346 
 347   Method* this_ptr = this;
 348   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 349   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);
 350   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 351 }
 352 
 353 // Attempt to return method oop to original state.  Clear any pointers
 354 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 355 // where they should point in a new JVM.  Further initialize some
 356 // entries now in order allow them to be write protected later.
 357 
 358 void Method::remove_unshareable_info() {
 359   unlink_method();

 360 }
 361 
 362 void Method::set_vtable_index(int index) {
 363   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 364     // At runtime initialize_vtable is rerun as part of link_class_impl()
 365     // for a shared class loaded by the non-boot loader to obtain the loader
 366     // constraints based on the runtime classloaders&#39; context.
 367     return; // don&#39;t write into the shared class
 368   } else {
 369     _vtable_index = index;
 370   }
 371 }
 372 
 373 void Method::set_itable_index(int index) {
 374   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 375     // At runtime initialize_itable is rerun as part of link_class_impl()
 376     // for a shared class loaded by the non-boot loader to obtain the loader
 377     // constraints based on the runtime classloaders&#39; context. The dumptime
 378     // itable index should be the same as the runtime index.
 379     assert(_vtable_index == itable_index_max - index,
</pre>
</td>
<td>
<hr />
<pre>
 340 void Method::metaspace_pointers_do(MetaspaceClosure* it) {
 341   log_trace(cds)(&quot;Iter(Method): %p&quot;, this);
 342 
 343   it-&gt;push(&amp;_constMethod);
 344   it-&gt;push(&amp;_method_data);
 345   it-&gt;push(&amp;_method_counters);
 346 
 347   Method* this_ptr = this;
 348   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_i2i_entry);
 349   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_compiled_entry);
 350   it-&gt;push_method_entry(&amp;this_ptr, (intptr_t*)&amp;_from_interpreted_entry);
 351 }
 352 
 353 // Attempt to return method oop to original state.  Clear any pointers
 354 // (to objects outside the shared spaces).  We won&#39;t be able to predict
 355 // where they should point in a new JVM.  Further initialize some
 356 // entries now in order allow them to be write protected later.
 357 
 358 void Method::remove_unshareable_info() {
 359   unlink_method();
<span class="line-added"> 360   JFR_ONLY(REMOVE_METHOD_ID(this);)</span>
 361 }
 362 
 363 void Method::set_vtable_index(int index) {
 364   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 365     // At runtime initialize_vtable is rerun as part of link_class_impl()
 366     // for a shared class loaded by the non-boot loader to obtain the loader
 367     // constraints based on the runtime classloaders&#39; context.
 368     return; // don&#39;t write into the shared class
 369   } else {
 370     _vtable_index = index;
 371   }
 372 }
 373 
 374 void Method::set_itable_index(int index) {
 375   if (is_shared() &amp;&amp; !MetaspaceShared::remapped_readwrite()) {
 376     // At runtime initialize_itable is rerun as part of link_class_impl()
 377     // for a shared class loaded by the non-boot loader to obtain the loader
 378     // constraints based on the runtime classloaders&#39; context. The dumptime
 379     // itable index should be the same as the runtime index.
 380     assert(_vtable_index == itable_index_max - index,
</pre>
</td>
</tr>
</table>
<center><a href="../memory/metaspaceShared.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopHandle.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>