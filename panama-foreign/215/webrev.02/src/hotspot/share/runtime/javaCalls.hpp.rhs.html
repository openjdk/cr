<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/javaCalls.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_JAVACALLS_HPP
 26 #define SHARE_RUNTIME_JAVACALLS_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/method.hpp&quot;
 30 #include &quot;runtime/handles.hpp&quot;
 31 #include &quot;runtime/javaFrameAnchor.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;runtime/vmThread.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 #include CPU_HEADER(jniTypes)
 37 
 38 // A JavaCallWrapper is constructed before each JavaCall and destructed after the call.
 39 // Its purpose is to allocate/deallocate a new handle block and to save/restore the last
 40 // Java fp/sp. A pointer to the JavaCallWrapper is stored on the stack.
 41 
 42 class JavaCallWrapper: StackObj {
 43   friend class VMStructs;
 44  private:
 45   JavaThread*      _thread;                 // the thread to which this call belongs
 46   JNIHandleBlock*  _handles;                // the saved handle block
 47   Method*          _callee_method;          // to be able to collect arguments if entry frame is top frame
 48   oop              _receiver;               // the receiver of the call (if a non-static call)
 49 
 50   JavaFrameAnchor  _anchor;                 // last thread anchor state that we must restore
 51 
 52   JavaValue*       _result;                 // result value
 53 
 54  public:
 55   // Construction/destruction
 56    JavaCallWrapper(const methodHandle&amp; callee_method, Handle receiver, JavaValue* result, TRAPS);
 57   ~JavaCallWrapper();
 58 
 59   // Accessors
 60   JavaThread*      thread() const           { return _thread; }
 61   JNIHandleBlock*  handles() const          { return _handles; }
 62 
 63   JavaFrameAnchor* anchor(void)             { return &amp;_anchor; }
 64 
 65   JavaValue*       result() const           { return _result; }
 66   // GC support
 67   Method*          callee_method()          { return _callee_method; }
 68   oop              receiver()               { return _receiver; }
 69   void             oops_do(OopClosure* f);
 70 
 71   bool             is_first_frame() const   { return _anchor.last_Java_sp() == NULL; }
 72 
 73 };
 74 
 75 
 76 // Encapsulates arguments to a JavaCall (faster, safer, and more convenient than using var-args)
 77 class JavaCallArguments : public StackObj {
 78  private:
 79   enum Constants {
 80    _default_size = 8    // Must be at least # of arguments in JavaCalls methods
 81   };
 82 
 83   intptr_t    _value_buffer      [_default_size + 1];
 84   u_char      _value_state_buffer[_default_size + 1];
 85 
 86   intptr_t*   _value;
 87   u_char*     _value_state;
 88   int         _size;
 89   int         _max_size;
 90   bool        _start_at_zero;      // Support late setting of receiver
<a name="1" id="anc1"></a><span class="line-modified"> 91 #if INCLUDE_JVMCI</span>
<span class="line-added"> 92   Handle      _alternative_target; // HotSpotNmethod wrapping an nmethod whose verified entry point</span>
<span class="line-added"> 93                                    // should be called instead of the normal target</span>
<span class="line-added"> 94 #endif</span>
 95 
 96   void initialize() {
 97     // Starts at first element to support set_receiver.
 98     _value       = &amp;_value_buffer[1];
 99     _value_state = &amp;_value_state_buffer[1];
100 
101     _max_size = _default_size;
102     _size = 0;
103     _start_at_zero = false;
<a name="2" id="anc2"></a>
104   }
105 
106   // Helper for push_oop and the like.  The value argument is a
107   // &quot;handle&quot; that refers to an oop.  We record the address of the
108   // handle rather than the designated oop.  The handle is later
109   // resolved to the oop by parameters().  This delays the exposure of
110   // naked oops until it is GC-safe.
111   template&lt;typename T&gt;
112   inline int push_oop_impl(T handle, int size) {
113     // JNITypes::put_obj expects an oop value, so we play fast and
114     // loose with the type system.  The cast from handle type to oop
115     // *must* use a C-style cast.  In a product build it performs a
116     // reinterpret_cast. In a debug build (more accurately, in a
117     // CHECK_UNHANDLED_OOPS build) it performs a static_cast, invoking
118     // the debug-only oop class&#39;s conversion from void* constructor.
119     JNITypes::put_obj((oop)handle, _value, size); // Updates size.
120     return size;                // Return the updated size.
121   }
122 
123  public:
124   JavaCallArguments() { initialize(); }
125 
126   JavaCallArguments(Handle receiver) {
127     initialize();
128     push_oop(receiver);
129   }
130 
131   JavaCallArguments(int max_size) {
132     if (max_size &gt; _default_size) {
133       _value = NEW_RESOURCE_ARRAY(intptr_t, max_size + 1);
134       _value_state = NEW_RESOURCE_ARRAY(u_char, max_size + 1);
135 
136       // Reserve room for potential receiver in value and state
137       _value++;
138       _value_state++;
139 
140       _max_size = max_size;
141       _size = 0;
142       _start_at_zero = false;
<a name="3" id="anc3"></a>
143     } else {
144       initialize();
145     }
146   }
147 
148 #if INCLUDE_JVMCI
<a name="4" id="anc4"></a><span class="line-modified">149   void set_alternative_target(Handle target) {</span>
150     _alternative_target = target;
151   }
152 
<a name="5" id="anc5"></a><span class="line-modified">153   Handle alternative_target() {</span>
154     return _alternative_target;
155   }
156 #endif
157 
158   // The possible values for _value_state elements.
159   enum {
160     value_state_primitive,
161     value_state_oop,
162     value_state_handle,
163     value_state_jobject,
164     value_state_limit
165   };
166 
167   inline void push_oop(Handle h) {
168     _value_state[_size] = value_state_handle;
169     _size = push_oop_impl(h.raw_value(), _size);
170   }
171 
172   inline void push_jobject(jobject h) {
173     _value_state[_size] = value_state_jobject;
174     _size = push_oop_impl(h, _size);
175   }
176 
177   inline void push_int(int i) {
178     _value_state[_size] = value_state_primitive;
179     JNITypes::put_int(i, _value, _size);
180   }
181 
182   inline void push_double(double d) {
183     _value_state[_size] = value_state_primitive;
184     _value_state[_size + 1] = value_state_primitive;
185     JNITypes::put_double(d, _value, _size);
186   }
187 
188   inline void push_long(jlong l) {
189     _value_state[_size] = value_state_primitive;
190     _value_state[_size + 1] = value_state_primitive;
191     JNITypes::put_long(l, _value, _size);
192   }
193 
194   inline void push_float(float f) {
195     _value_state[_size] = value_state_primitive;
196     JNITypes::put_float(f, _value, _size);
197   }
198 
199   // receiver
200   Handle receiver() {
201     assert(_size &gt; 0, &quot;must at least be one argument&quot;);
202     assert(_value_state[0] == value_state_handle,
203            &quot;first argument must be an oop&quot;);
204     assert(_value[0] != 0, &quot;receiver must be not-null&quot;);
205     return Handle((oop*)_value[0], false);
206   }
207 
208   void set_receiver(Handle h) {
209     assert(_start_at_zero == false, &quot;can only be called once&quot;);
210     _start_at_zero = true;
211     _value_state--;
212     _value--;
213     _size++;
214     _value_state[0] = value_state_handle;
215     push_oop_impl(h.raw_value(), 0);
216   }
217 
218   // Converts all Handles to oops, and returns a reference to parameter vector
219   intptr_t* parameters() ;
220   int   size_of_parameters() const { return _size; }
221 
222   // Verify that pushed arguments fits a given method
223   void verify(const methodHandle&amp; method, BasicType return_type);
224 };
225 
226 // All calls to Java have to go via JavaCalls. Sets up the stack frame
227 // and makes sure that the last_Java_frame pointers are chained correctly.
228 //
229 
230 class JavaCalls: AllStatic {
231   static void call_helper(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS);
232  public:
233   // call_special
234   // ------------
235   // The receiver must be first oop in argument list
236   static void call_special(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
237 
238   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, TRAPS); // No args
239   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
240   static void call_special(JavaValue* result, Handle receiver, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
241 
242   // virtual call
243   // ------------
244 
245   // The receiver must be first oop in argument list
246   static void call_virtual(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
247 
248   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, TRAPS); // No args
249   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
250   static void call_virtual(JavaValue* result, Handle receiver, Klass* spec_klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
251 
252   // Static call
253   // -----------
254   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS);
255 
256   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, TRAPS);
257   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, TRAPS);
258   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, TRAPS);
259   static void call_static(JavaValue* result, Klass* klass, Symbol* name, Symbol* signature, Handle arg1, Handle arg2, Handle arg3, TRAPS);
260 
261   // Allocate instance + invoke constructor. This is equivalent to &quot;new Klass(args ...)&quot; expression in Java code.
262   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, JavaCallArguments* args, TRAPS);
263 
264   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, TRAPS);
265   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, Handle arg1, TRAPS);
266   static Handle construct_new_instance(InstanceKlass* klass, Symbol* constructor_signature, Handle arg1, Handle arg2, TRAPS);
267 
268   // Low-level interface
269   static void call(JavaValue* result, const methodHandle&amp; method, JavaCallArguments* args, TRAPS);
270 };
271 
272 #endif // SHARE_RUNTIME_JAVACALLS_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>