<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old doc/nashorn/JavaScriptingProgrammersGuide.html</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
  <body>
    <pre>
  1 &lt;!--
  2  Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  3  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 
  5  This code is free software; you can redistribute it and/or modify it
  6  under the terms of the GNU General Public License version 2 only, as
  7  published by the Free Software Foundation.  Oracle designates this
  8  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  by Oracle in the LICENSE file that accompanied this code.
 10 
 11  This code is distributed in the hope that it will be useful, but WITHOUT
 12  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  version 2 for more details (a copy is included in the LICENSE file that
 15  accompanied this code).
 16 
 17  You should have received a copy of the GNU General Public License version
 18  2 along with this work; if not, write to the Free Software Foundation,
 19  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 
 21  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  or visit www.oracle.com if you need additional information or have any
 23  questions.
 24 --&gt;
 25 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
 26 &lt;html class=&quot; regenabled  gecko radius jsenabled regloaded&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;
 27 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
 28 &lt;title&gt;Java Scripting Programmer&#39;s Guide&lt;/title&gt;
 29 
 30 &lt;!-- ============ --&gt;
 31 &lt;!-- MAIN CONTENT --&gt;
 32 &lt;!-- ============ --&gt;
 33 &lt;table summary=&quot;layout&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;
 34 &lt;tbody&gt;&lt;tr&gt;
 35 &lt;td&gt;
 36 
 37 &lt;div id=&quot;sharepage&quot; class=&quot;smallpagetitle&quot;&gt;&lt;h1&gt;Java Scripting Programmer&#39;s Guide&lt;/h1&gt;&lt;div class=&quot;sharepage&quot;&gt;		&lt;div class=&quot;sharepagew1 share-mailto&quot;&gt;		&lt;table summary=&quot;&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;		&lt;td id=&quot;share-mailto&quot;&gt;&lt;a href=&quot;mailto:?subject=Java%20Documentation%20Page:%20Java%20Scripting%20Programmer%27s%20Guide&amp;amp;body=Check%20out%20this%20page:%20%0A%0Ahttp%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fscripting%2Fprogrammer_guide%2Findex.html&quot; class=&quot;sharelink mailto&quot; title=&quot;Email this page to a friend&quot;&gt;&lt;/a&gt;&lt;/td&gt;		&lt;td id=&quot;share-technorati&quot;&gt;&lt;a href=&quot;http://technorati.com/search/http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fscripting%2Fprogrammer_guide%2Findex.html&quot; class=&quot;sharelink technorati&quot; title=&quot;See who links to this page on Technorati&quot;&gt;&lt;/a&gt;&lt;/td&gt;		&lt;td id=&quot;share-delicious&quot;&gt;&lt;a href=&quot;http://del.icio.us/post?v=4;url=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fscripting%2Fprogrammer_guide%2Findex.html;title=Java%20Scripting%20Programmer%27s%20Guide&quot; class=&quot;sharelink delicious&quot; title=&quot;Bookmark this page in del.icio.us&quot;&gt;&lt;/a&gt;&lt;/td&gt;		&lt;td id=&quot;share-digg&quot;&gt;&lt;a href=&quot;http://digg.com/submit?phase=2&amp;amp;url=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fscripting%2Fprogrammer_guide%2Findex.html&amp;amp;title=Java%20Scripting%20Programmer%27s%20Guide&quot; class=&quot;sharelink digg&quot; title=&quot;Submit this page to Digg&quot;&gt;&lt;/a&gt;&lt;/td&gt;		&lt;td id=&quot;share-slashdot&quot;&gt;&lt;a href=&quot;http://slashdot.org/bookmark.pl?title=Java%20Scripting%20Programmer%27s%20Guide&amp;amp;url=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fscripting%2Fprogrammer_guide%2Findex.html&quot; class=&quot;sharelink slashdot&quot; title=&quot;Submit this page to Slashdot&quot;&gt;&lt;/a&gt;&lt;/td&gt;		&lt;td id=&quot;share-blank&quot;&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
 38 
 39 &lt;/td&gt;
 40 &lt;/tr&gt;
 41 &lt;/tbody&gt;&lt;/table&gt;
 42 &lt;!-- Body text begins here --&gt;
 43 &lt;ul&gt;
 44 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#who&quot;&gt;Who is the Java Scripting API
 45 For?&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 46 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#package&quot;&gt;Scripting Package&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 47 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt;&lt;/span&gt;
 48 &lt;ul&gt;
 49 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#helloworld&quot;&gt;&quot;Hello, World&quot;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 50 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#evalfile&quot;&gt;Evaluating a Script
 51 File&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 52 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#scriptvars&quot;&gt;Script Variables&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 53 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#invoke&quot;&gt;Invoking Script Functions and
 54 Methods&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 55 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#interfaces&quot;&gt;Implementing Java Interfaces by
 56 Scripts&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 57 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#scopes&quot;&gt;Multiple Scopes for
 58 Scripts&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 59 &lt;/ul&gt;
 60 &lt;/li&gt;
 61 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsengine&quot;&gt;JavaScript Script
 62 Engine&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 63 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jstojava&quot;&gt;JavaScript to Java
 64 Communication&lt;/a&gt;&lt;/span&gt;
 65 &lt;ul&gt;
 66 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsjavaclass&quot;&gt;Accessing Java
 67 Classes&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 68 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsimport&quot;&gt;Importing Java Packages,
 69 Classes&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 70 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsarrays&quot;&gt;Creating, Converting and Using Java
 71 Arrays&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 72 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsimplement&quot;&gt;Implementing Java
 73 Interfaces&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 74 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsextendabstract&quot;&gt;Extending Abstract Java Classes
 75 &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 76 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsextendconcrete&quot;&gt;Extending Concrete Java Classes
 77 &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 78 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsimplementmultiple&quot;&gt;Implementing Multiple Java Interfaces
 79 &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 80 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#classBoundImplementations&quot;&gt;Class-Bound Implementations
 81 &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 82 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#jsoverload&quot;&gt;Overload Resolution&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 83 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#dataTypeMapping&quot;&gt;Mapping of Data Types Between Java
 84 and JavaScript&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 85 
 86 
 87 
 88 &lt;/ul&gt;
 89 &lt;/li&gt;
 90 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#engineimpl&quot;&gt;Implementing Your Own Script
 91 Engine&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 92 &lt;li&gt;&lt;span&gt;&lt;a href=&quot;#refs&quot;&gt;References&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
 93 &lt;/ul&gt;
 94 &lt;span&gt;&lt;a name=&quot;who&quot; id=&quot;who&quot;&gt;&lt;/a&gt;&lt;/span&gt;
 95 &lt;h2&gt;&lt;span&gt;Who is the Java Scripting API For?&lt;/span&gt;&lt;/h2&gt;
 96 &lt;span&gt;Some useful characteristics of scripting languages
 97 are:&lt;/span&gt;
 98 &lt;ul&gt;
 99 &lt;li&gt;&lt;span&gt;&lt;b&gt;Convenience&lt;/b&gt;: Most scripting languages are
100 dynamically typed. You can usually create new variables without
101 declaring the variable type, and you can reuse variables to store
102 objects of different types. Also, scripting languages tend to
103 perform many type conversions automatically, for example,
104 converting the number 10 to the text &quot;10&quot; as necessary.&lt;/span&gt;&lt;/li&gt;
105 &lt;li&gt;&lt;span&gt;&lt;b&gt;Developing rapid prototypes&lt;/b&gt;: You can avoid the
106 edit-compile-run cycle and just use edit-run!&lt;/span&gt;&lt;/li&gt;
107 &lt;li&gt;&lt;span&gt;&lt;b&gt;Application extension/customization&lt;/b&gt;: You can
108 &quot;externalize&quot; parts of your application - like configuration
109 scripts, business logic/rules and math expressions for financial
110 applications.&lt;/span&gt;&lt;/li&gt;
111 &lt;li&gt;&lt;span&gt;&lt;b&gt;&quot;Command line&quot; shells for applications&lt;/b&gt; -for
112 debugging, runtime/deploy time configuration etc. Most applications
113 have a web-based GUI configuaration tool these days. But
114 sysadmins/deployers frequently prefer command line tools. Instead
115 of inventing ad-hoc scripting language for that purpose, a
116 &quot;standard&quot; scripting language can be used.&lt;/span&gt;&lt;/li&gt;
117 &lt;/ul&gt;
118 &lt;p&gt;&lt;span&gt;The Java&lt;font size=&quot;-1&quot;&gt;&lt;sup&gt;TM&lt;/sup&gt;&lt;/font&gt; Scripting API
119 is a scripting language indepedent framework for using script
120 engines from Java code. With the Java Scripting API, it is possible
121 to write customizable/extendable applications in the Java language
122 and leave the customization scripting language choice to the end
123 user. The Java application developer need not choose the extension
124 language during development. If you write your application with
125 JSR-223 API, then your users can use any JSR-223 compliant
126 scripting language.&lt;/span&gt;&lt;/p&gt;
127 &lt;hr&gt;
128 &lt;span&gt;&lt;a name=&quot;package&quot; id=&quot;package&quot;&gt;&lt;/a&gt;&lt;/span&gt;
129 &lt;h2&gt;&lt;span&gt;Scripting Package&lt;/span&gt;&lt;/h2&gt;
130 &lt;p&gt;&lt;span&gt;The Java Scripting functionality is in the &lt;code&gt;&lt;a href=&quot;http://docs.oracle.com/javase/9/docs/api/javax/script/package-summary.html&quot;&gt;javax.script&lt;/a&gt;&lt;/code&gt;
131 package. This is a relatively small, simple API. The starting point
132 of the scripting API is the &lt;code&gt;ScriptEngineManager&lt;/code&gt; class.
133 A ScriptEngineManager object can discover script engines through
134 the jar file service discovery mechanism. It can also instantiate
135 ScriptEngine objects that interpret scripts written in a specific
136 scripting language. The simplest way to use the scripting API is as
137 follows:&lt;/span&gt;&lt;/p&gt;
138 &lt;ol&gt;
139 &lt;li&gt;&lt;span&gt;Create a &lt;code&gt;ScriptEngineManager&lt;/code&gt;
140 object.&lt;/span&gt;&lt;/li&gt;
141 &lt;li&gt;&lt;span&gt;Get a &lt;code&gt;ScriptEngine&lt;/code&gt; object from the
142 manager.&lt;/span&gt;&lt;/li&gt;
143 &lt;li&gt;&lt;span&gt;Evaluate script using the &lt;code&gt;ScriptEngine&lt;/code&gt;&#39;s
144 &lt;code&gt;eval&lt;/code&gt; methods.&lt;/span&gt;&lt;/li&gt;
145 &lt;/ol&gt;
146 &lt;p&gt;&lt;span&gt;Now, it is time to look at some sample code. While it is
147 not mandatory, it may be useful to know a bit of JavaScript to read
148 these examples.&lt;/span&gt;&lt;/p&gt;
149 &lt;hr&gt;
150 &lt;span&gt;&lt;a name=&quot;examples&quot; id=&quot;examples&quot;&gt;&lt;/a&gt;&lt;/span&gt;
151 &lt;h2&gt;&lt;span&gt;Examples&lt;/span&gt;&lt;/h2&gt;
152 &lt;span&gt;&lt;a name=&quot;helloworld&quot; id=&quot;helloworld&quot;&gt;&lt;/a&gt;&lt;/span&gt;
153 &lt;h3&gt;&lt;span&gt;&quot;Hello, World&quot;&lt;/span&gt;&lt;/h3&gt;
154 &lt;p&gt;&lt;span&gt;From the &lt;code&gt;ScriptEngineManager&lt;/code&gt; instance, we
155 request a JavaScript engine instance using
156 &lt;code&gt;getEngineByName&lt;/code&gt; method. On the script engine, the
157 &lt;code&gt;eval&lt;/code&gt; method is called to execute a given String as
158 JavaScript code! For brevity, in this as well as in subsequent
159 examples, we have not shown exception handling. There are checked
160 and runtime exceptions thrown from &lt;code&gt;javax.script&lt;/code&gt; API.
161 Needless to say, you have to handle the exceptions
162 appropriately.&lt;/span&gt;&lt;/p&gt;
163 &lt;pre&gt;
164 &lt;span&gt;&lt;code&gt;
165 // &lt;a href=&quot;source/EvalScript.java&quot;&gt;EvalScript.java&lt;/a&gt;
166 
167 import javax.script.*;
168 public class EvalScript {
169     public static void main(String[] args) throws Exception {
170         // create a script engine manager
171         &lt;span class=&quot;classref&quot;&gt;ScriptEngineManager&lt;/span&gt; factory = new ScriptEngineManager();
172         // create a JavaScript engine
173         &lt;span class=&quot;classref&quot;&gt;ScriptEngine&lt;/span&gt; engine = factory.&lt;span class=&quot;methodref&quot;&gt;getEngineByName&lt;/span&gt;(&quot;nashorn&quot;);
174         // evaluate JavaScript code from String
175         engine.&lt;span class=&quot;methodref&quot;&gt;eval&lt;/span&gt;(&quot;print(&#39;Hello, World&#39;)&quot;);
176     }
177 }
178 &lt;/code&gt;&lt;/span&gt;
179 &lt;/pre&gt;
180 &lt;hr&gt;
181 &lt;a name=&quot;evalfile&quot; id=&quot;evalfile&quot;&gt;&lt;/a&gt;
182 &lt;h3&gt;Evaluating a Script File&lt;/h3&gt;
183 &lt;p&gt;In this example, we call the &lt;code&gt;eval&lt;/code&gt; method that
184 accepts &lt;code&gt;java.io.Reader&lt;/code&gt; for the input source. The
185 script read by the given reader is executed. This way it is
186 possible to execute scripts from files, URLs and resources by
187 wrapping the relevant input stream objects as readers.&lt;/p&gt;
188 &lt;pre&gt;
189 &lt;code&gt;
190 // &lt;a href=&quot;source/EvalFile.java&quot;&gt;EvalFile.java&lt;/a&gt;
191 
192 import javax.script.*;
193 
194 public class EvalFile {
195     public static void main(String[] args) throws Exception {
196         // create a script engine manager
197         &lt;span class=&quot;classref&quot;&gt;ScriptEngineManager&lt;/span&gt; factory = new ScriptEngineManager();
198         // create JavaScript engine
199         &lt;span class=&quot;classref&quot;&gt;ScriptEngine&lt;/span&gt; engine = factory.&lt;span class=&quot;methodref&quot;&gt;getEngineByName&lt;/span&gt;(&quot;nashorn&quot;);
200         // evaluate JavaScript code from given file - specified by first argument
201         engine.&lt;span class=&quot;methodref&quot;&gt;eval&lt;/span&gt;(new java.io.FileReader(args[0]));
202     }
203 }
204 &lt;/code&gt;
205 &lt;/pre&gt;
206 Let us assume that we have the file named &lt;a href=&quot;source/test.js&quot;&gt;test.js&lt;/a&gt; with the
207 following text:
208 &lt;pre&gt;&lt;code&gt;
209 print(&quot;This is hello from test.js&quot;);
210 &lt;/code&gt;
211 &lt;/pre&gt;
212 We can run the above Java as
213 &lt;pre&gt;&lt;code&gt;
214 java EvalFile test.js
215 &lt;/code&gt;
216 &lt;/pre&gt;
217 &lt;hr&gt;
218 &lt;a name=&quot;scriptvars&quot; id=&quot;scriptvars&quot;&gt;&lt;/a&gt;
219 &lt;h3&gt;Script Variables&lt;/h3&gt;
220 &lt;p&gt;When you embed script engines and scripts with your Java
221 application, you may want to expose your application objects as
222 global variables to scripts. This example demonstrates how you can
223 expose your application objects as global variables to a script. We
224 create a &lt;code&gt;java.io.File&lt;/code&gt; in the application and expose
225 the same as a global variable with the name &quot;file&quot;. The script can
226 access the variable - for example, it can call public methods on
227 it. Note that the syntax to access Java objects, methods and fields
228 is dependent on the scripting language. JavaScript supports the
229 most &quot;natural&quot; Java-like syntax.&lt;/p&gt;
230 &lt;p&gt;
231 Nashorn script engine pre-defines two global variables named &quot;context&quot;
232 and &quot;engine&quot;. The &quot;context&quot; variable is of type javax.script.ScriptContext
233 and refers to the current ScriptContext instance passed to script engine&#39;s
234 eval method. The &quot;engine&quot; variable is of type javax.script.ScriptEngine and
235 refers to the current nashorn script engine instance evaluating the script.
236 Both of these variables are non-writable, non-enumerable and non-configurable
237 - which implies script code can not write overwrite the value, for..loop iteration
238 on global object will not iterate these variables and these variables can not be
239 deleted by script.
240 &lt;pre&gt;&lt;code&gt;
241 // &lt;a href=&quot;source/ScriptVars.java&quot;&gt;ScriptVars.java&lt;/a&gt;
242 
243 import javax.script.*;
244 import java.io.*;
245 
246 public class ScriptVars { 
247     public static void main(String[] args) throws Exception {
248         ScriptEngineManager manager = new ScriptEngineManager();
249         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
250 
251         File f = new File(&quot;test.txt&quot;);
252         // expose File object as variable to script
253         engine.&lt;span class=&quot;methodref&quot;&gt;put&lt;/span&gt;(&quot;file&quot;, f);
254 
255         // evaluate a script string. The script accesses &quot;file&quot; 
256         // variable and calls method on it
257         engine.eval(&quot;print(file.getAbsolutePath())&quot;);
258     }
259 }
260 
261 &lt;/code&gt;
262 &lt;/pre&gt;
263 &lt;hr&gt;
264 &lt;a name=&quot;invoke&quot; id=&quot;invoke&quot;&gt;&lt;/a&gt;
265 &lt;h3&gt;Invoking Script Functions and Methods&lt;/h3&gt;
266 &lt;p&gt;Sometimes you may want to call a specific scripting function
267 repeatedly - for example, your application menu functionality might
268 be implemented by a script. In your menu&#39;s action event handler you
269 may want to call a specific script function. The following example
270 demonstrates invoking a specific script function from Java
271 code.&lt;/p&gt;
272 &lt;pre&gt;&lt;code&gt;
273 // &lt;a href=&quot;source/InvokeScriptFunction.java&quot;&gt;InvokeScriptFunction.java&lt;/a&gt;
274 
275 import javax.script.*;
276 
277 public class InvokeScriptFunction {
278     public static void main(String[] args) throws Exception {
279         ScriptEngineManager manager = new ScriptEngineManager();
280         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
281 
282         // JavaScript code in a String
283         String script = &quot;function hello(name) { print(&#39;Hello, &#39; + name); }&quot;;
284         // evaluate script
285         engine.eval(script);
286 
287         // &lt;code&gt;javax.script.Invocable&lt;/code&gt; is an optional interface.
288         // Check whether your script engine implements it or not!
289         // Note that the JavaScript engine implements Invocable interface.
290         &lt;span class=&quot;classref&quot;&gt;Invocable&lt;/span&gt; inv = (Invocable) engine;
291 
292         // invoke the global function named &quot;hello&quot;
293         inv.&lt;span class=&quot;methodref&quot;&gt;invokeFunction&lt;/span&gt;(&quot;hello&quot;, &quot;Scripting!!&quot; );
294     }
295 }
296 
297 &lt;/code&gt;
298 &lt;/pre&gt;
299 &lt;p&gt;If your scripting language is object based (like JavaScript) or
300 object-oriented, then you can invoke a script method on a script
301 object.&lt;/p&gt;
302 &lt;pre&gt;&lt;code&gt;
303 // &lt;a href=&quot;source/InvokeScriptMethod.java&quot;&gt;InvokeScriptMethod.java&lt;/a&gt;
304 
305 import javax.script.*;
306 
307 public class InvokeScriptMethod {
308     public static void main(String[] args) throws Exception {
309         ScriptEngineManager manager = new ScriptEngineManager();
310         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
311 
312         // JavaScript code in a String. This code defines a script object &#39;obj&#39;
313         // with one method called &#39;hello&#39;.        
314         String script = &quot;var obj = new Object(); obj.hello = function(name) { print(&#39;Hello, &#39; + name); }&quot;;
315         // evaluate script
316         engine.eval(script);
317 
318         // &lt;code&gt;javax.script.Invocable&lt;/code&gt; is an optional interface.
319         // Check whether your script engine implements or not!
320         // Note that the JavaScript engine implements Invocable interface.
321         &lt;span class=&quot;classref&quot;&gt;Invocable&lt;/span&gt; inv = (Invocable) engine;
322 
323         // get script object on which we want to call the method
324         Object obj = engine.&lt;span class=&quot;methodref&quot;&gt;get&lt;/span&gt;(&quot;obj&quot;);
325 
326         // invoke the method named &quot;hello&quot; on the script object &quot;obj&quot;
327         inv.&lt;span class=&quot;methodref&quot;&gt;invokeMethod&lt;/span&gt;(obj, &quot;hello&quot;, &quot;Script Method !!&quot; );
328     }
329 }
330 
331 &lt;/code&gt;
332 &lt;/pre&gt;
333 &lt;hr&gt;
334 &lt;a name=&quot;interfaces&quot; id=&quot;interfaces&quot;&gt;&lt;/a&gt;
335 &lt;h3&gt;Implementing Java Interfaces by Scripts&lt;/h3&gt;
336 &lt;p&gt;Instead of calling specific script functions from Java,
337 sometimes it is convenient to implement a Java interface by script
338 functions or methods. Also, by using interfaces we can avoid having
339 to use the &lt;code&gt;javax.script&lt;/code&gt; API in many places. We can get
340 an interface implementor object and pass it to various Java APIs.
341 The following example demonstrates implementing the
342 &lt;code&gt;java.lang.Runnable&lt;/code&gt; interface with a script.&lt;/p&gt;
343 &lt;pre&gt;&lt;code&gt;
344 // &lt;a href=&quot;source/RunnableImpl.java&quot;&gt;RunnableImpl.java&lt;/a&gt;
345 
346 import javax.script.*;
347 
348 public class RunnableImpl {
349     public static void main(String[] args) throws Exception {
350         ScriptEngineManager manager = new ScriptEngineManager();
351         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
352 
353         // JavaScript code in a String
354         String script = &quot;function run() { print(&#39;run called&#39;); }&quot;;
355 
356         // evaluate script
357         engine.eval(script);
358 
359         &lt;span class=&quot;classref&quot;&gt;Invocable&lt;/span&gt; inv = (Invocable) engine;
360 
361         // get Runnable interface object from engine. This interface methods
362         // are implemented by script functions with the matching name.
363         Runnable r = inv.&lt;span class=&quot;methodref&quot;&gt;getInterface&lt;/span&gt;(Runnable.class);
364 
365         // start a new thread that runs the script implemented
366         // runnable interface
367         Thread th = new Thread(r);
368         th.start();
369         th.join();
370     }
371 }
372 &lt;/code&gt;
373 &lt;/pre&gt;
374 &lt;p&gt;If your scripting language is object-based or object-oriented,
375 it is possible to implement a Java interface by script methods on
376 script objects. This avoids having to call script global functions
377 for interface methods. The script object can store the &quot;state&quot;
378 associated with the interface implementor.&lt;/p&gt;
379 &lt;pre&gt;&lt;code&gt;
380 // &lt;a href=&quot;source/RunnableImplObject.java&quot;&gt;RunnableImplObject.java&lt;/a&gt;
381 
382 import javax.script.*;
383 
384 public class RunnableImplObject {
385     public static void main(String[] args) throws Exception {
386         ScriptEngineManager manager = new ScriptEngineManager();
387         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
388 
389         // JavaScript code in a String
390         String script = &quot;var obj = new Object(); obj.run = function() { print(&#39;run method called&#39;); }&quot;;
391 
392         // evaluate script
393         engine.eval(script);
394 
395         // get script object on which we want to implement the interface with
396         Object obj = engine.&lt;span class=&quot;methodref&quot;&gt;get&lt;/span&gt;(&quot;obj&quot;);
397 
398         &lt;span class=&quot;classref&quot;&gt;Invocable&lt;/span&gt; inv = (Invocable) engine;
399 
400         // get Runnable interface object from engine. This interface methods
401         // are implemented by script methods of object &#39;obj&#39;
402         Runnable r = inv.&lt;span class=&quot;methodref&quot;&gt;getInterface&lt;/span&gt;(obj, Runnable.class);
403 
404         // start a new thread that runs the script implemented
405         // runnable interface
406         Thread th = new Thread(r);
407         th.start();
408         th.join();
409     }
410 }
411 &lt;/code&gt;
412 &lt;/pre&gt;
413 &lt;hr&gt;
414 &lt;a name=&quot;scopes&quot; id=&quot;scopes&quot;&gt;&lt;/a&gt;
415 &lt;h3&gt;Multiple Scopes for Scripts&lt;/h3&gt;
416 &lt;p&gt;In the &lt;a href=&quot;#scriptvars&quot;&gt;script variables&lt;/a&gt; example, we
417 saw how to expose application objects as script global variables.
418 It is possible to expose multiple global &quot;scopes&quot; for scripts. A
419 single scope is an instance of &lt;code&gt;javax.script.Bindings&lt;/code&gt;.
420 This interface is derived from &lt;code&gt;java.util.Map&amp;lt;String,
421 Object&amp;gt;&lt;/code&gt;. A scope a set of name-value pairs where name is
422 any non-empty, non-null String.
423 &lt;code&gt;javax.script.ScriptContext&lt;/code&gt; interface supports multiple
424 scopes with associated Bindings for each
425 scope. By default, every script engine has a default script
426 context. The default script context has atleast one scope called
427 &quot;ENGINE_SCOPE&quot;. Various scopes supported by a script context are
428 available through &lt;code&gt;getScopes&lt;/code&gt; method.&lt;/p&gt;
429 &lt;pre&gt;&lt;code&gt;
430 // &lt;a href=&quot;source/MultiScopes.java&quot;&gt;MultiScopes.java&lt;/a&gt;
431 
432 import javax.script.*;
433 
434 public class MultiScopes {
435     public static void main(String[] args) throws Exception {
436         ScriptEngineManager manager = new ScriptEngineManager();
437         ScriptEngine engine = manager.getEngineByName(&quot;nashorn&quot;);
438 
439         engine.put(&quot;x&quot;, &quot;hello&quot;);
440         // print global variable &quot;x&quot;
441         engine.eval(&quot;print(x);&quot;);
442         // the above line prints &quot;hello&quot;
443 
444         // Now, pass a different script context
445         &lt;span class=&quot;classref&quot;&gt;ScriptContext&lt;/span&gt; newContext = new &lt;span class=&quot;classref&quot;&gt;SimpleScriptContext&lt;/span&gt;();
446         newContext.setBindings(engine.createBindings(), ScriptContext.ENGINE_SCOPE);
447         &lt;span class=&quot;classref&quot;&gt;Bindings&lt;/span&gt; engineScope = newContext.&lt;span class=&quot;methodref&quot;&gt;getBindings&lt;/span&gt;(ScriptContext.ENGINE_SCOPE);
448 
449         // add new variable &quot;x&quot; to the new engineScope        
450         engineScope.&lt;span class=&quot;methodref&quot;&gt;put&lt;/span&gt;(&quot;x&quot;, &quot;world&quot;);
451 
452         // execute the same script - but this time pass a different script context
453         engine.eval(&quot;print(x);&quot;, newContext);
454         // the above line prints &quot;world&quot;
455     }
456 }
457 
458 &lt;/code&gt;
459 &lt;/pre&gt;
460 &lt;hr&gt;
461 &lt;a name=&quot;jsengine&quot; id=&quot;jsengine&quot;&gt;&lt;/a&gt;
462 &lt;h2&gt;JavaScript Script Engine&lt;/h2&gt;
463 &lt;p&gt;Oracle&#39;s implementation of JDK 8 is co-bundled with the Nashorn ECMAScript
464 script engine.
465 &lt;hr&gt;
466 &lt;a name=&quot;jstojava&quot; id=&quot;jstojava&quot;&gt;&lt;/a&gt;
467 &lt;h2&gt;JavaScript to Java Communication&lt;/h2&gt;
468 &lt;p&gt;For the most part, accessing Java classes, objects and methods
469 is straightforward. In particular field and method access from
470 JavaScript is the same as it is from Java. We highlight important
471 aspects of JavaScript Java access here. 
472 The following examples are JavaScript snippets accessing Java. This
473 section requires knowledge of JavaScript. This section can be
474 skipped if you are planning to use some other JSR-223 scripting
475 language rather than JavaScript.&lt;/p&gt;
476 &lt;hr&gt;
477 &lt;a name=&quot;jsjavaclass&quot; id=jsjavalass&quot;&gt;&lt;/a&gt;
478 &lt;h3&gt;Accessing Java Classes&lt;/h3&gt;
479 &lt;pre&gt;
480 &lt;code&gt;
481 // &lt;a href=&quot;source/javatypes.js&quot;&gt;javatypes.js&lt;/a&gt;
482 
483  var arrayListType = Java.type(&quot;java.util.ArrayList&quot;)
484  var intType = Java.type(&quot;int&quot;)
485  var stringArrayType = Java.type(&quot;java.lang.String[]&quot;)
486  var int2DArrayType = Java.type(&quot;int[][]&quot;)
487 &lt;/code&gt;
488 &lt;/pre&gt; 
489 
490 Note that the name of the type is always a string for a fully qualified name. You can use any of these expressions to create new instances, e.g.:
491 
492 &lt;pre&gt;&lt;code&gt;
493  var anArrayList = new (Java.type(&quot;java.util.ArrayList&quot;))
494 &lt;/code&gt;&lt;/pre&gt; 
495 
496 or
497 
498 &lt;pre&gt;&lt;code&gt;
499  var ArrayList = Java.type(&quot;java.util.ArrayList&quot;)
500  var anArrayList = new ArrayList
501  var anArrayListWithSize = new ArrayList(16)
502 &lt;/code&gt;&lt;/pre&gt; 
503 
504 In the special case of inner classes, you can either use the JVM fully qualified name, meaning using the dollar sign in the class name, or you can use the dot:
505 
506 &lt;pre&gt;&lt;code&gt;
507  var ftype = Java.type(&quot;java.awt.geom.Arc2D$Float&quot;)
508 &lt;/code&gt;&lt;/pre&gt; 
509  
510 and
511  
512 &lt;pre&gt;&lt;code&gt;
513  var ftype = Java.type(&quot;java.awt.geom.Arc2D.Float&quot;)
514 &lt;/code&gt;&lt;/pre&gt; 
515 
516 both work. Note however that using the dollar sign is faster, as Java.type first tries to resolve the class name as it is originally specified, and the internal JVM names for inner classes use the dollar sign. If you use the dot, Java.type will internally get a ClassNotFoundException and subsequently retry by changing the last dot to dollar sign. As a matter of fact, it&#39;ll keep replacing dots with dollar signs until it either successfully loads the class or runs out of all dots in the name. This way it can correctly resolve and load even multiply nested inner classes with the dot notation. Again, this will be slower than using the dollar signs in the name. An alternative way to access the inner class is as a property of the outer class:
517 
518 &lt;pre&gt;&lt;code&gt;
519  var arctype = Java.type(&quot;java.awt.geom.Arc2D&quot;)
520  var ftype = arctype.Float
521 &lt;/code&gt;&lt;/pre&gt; 
522 &lt;p&gt;
523 You can access both static and non-static inner classes. If you want to create an instance of a non-static inner class, remember to pass an instance of its outer class as the first argument to the constructor.
524 &lt;/p&gt;
525 &lt;p&gt;
526 In addition to creating new instances, the type objects returned from &lt;code&gt;Java.type&lt;/code&gt; calls can also be used to access the
527 static fields and methods of the classes:
528 &lt;pre&gt;&lt;code&gt;
529  var File = Java.type(&quot;java.io.File&quot;)
530  File.createTempFile(&quot;nashorn&quot;, &quot;.tmp&quot;)
531 &lt;/code&gt;&lt;/pre&gt; 
532 &lt;p&gt;
533 Methods with names of the form &lt;code&gt;isXxx()&lt;/code&gt;, &lt;code&gt;getXxx()&lt;/code&gt;, and &lt;code&gt;setXxx()&lt;/code&gt; can also be used as properties, for both instances and statics.
534 &lt;/p&gt;
535 &lt;p&gt;
536 A type object returned from &lt;code&gt;Java.type&lt;/code&gt; is distinct from a &lt;code&gt;java.lang.Class&lt;/code&gt; object. You can obtain one from the other using properties &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; on them.
537 &lt;pre&gt;&lt;code&gt;
538  var ArrayList = Java.type(&quot;java.util.ArrayList&quot;)
539  var a = new ArrayList
540 
541  // All of the following print true:
542  print(&quot;Type acts as target of instanceof: &quot; + (a instanceof ArrayList))
543  print(&quot;Class doesn&#39;t act as target of instanceof: &quot; + !(a instanceof a.getClass()))
544  print(&quot;Type is not same as instance&#39;s getClass(): &quot; + (a.getClass() !== ArrayList))
545  print(&quot;Type&#39;s `class` property is same as instance getClass(): &quot; + (a.getClass() === ArrayList.class))
546  print(&quot;Type is same as instance getClass()&#39;s `static` property: &quot; + (a.getClass().static === ArrayList))
547 &lt;/code&gt;&lt;/pre&gt; 
548 &lt;p&gt;
549 You can think of the type object as similar to the class names as used in Java source code: you use them as the
550 arguments to the &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and as the namespace for the static fields
551 and methods, but they are different than the runtime &lt;code&gt;Class&lt;/code&gt; objects returned by &lt;code&gt;getClass()&lt;/code&gt; calls.
552 Syntactically and semantically, this separation produces code that is most similar to Java code, where a distinction
553 between compile-time class expressions and runtime class objects also exists. (Also, Java can&#39;t have the equivalent of &lt;code&gt;static&lt;/code&gt;
554 property on a &lt;code&gt;Class&lt;/code&gt; object since compile-time class expressions are never reified as objects).
555 &lt;/p&gt;
556 &lt;hr&gt;
557 &lt;a name=&quot;jsimport&quot; id=&quot;jsimport&quot;&gt;&lt;/a&gt;
558 &lt;h3&gt;Importing Java Packages, Classes&lt;/h3&gt;
559 &lt;p&gt;The built-in functions &lt;code&gt;importPackage&lt;/code&gt; (in compatibility script) and
560 &lt;code&gt;importClass&lt;/code&gt; can be used to import Java packages and
561 classes.&lt;/p&gt;
562 &lt;pre&gt;&lt;code&gt;
563 
564 // &lt;a href=&quot;source/importpackageclass.js&quot;&gt;importpackageclass.js&lt;/a&gt;
565 
566 // load compatibility script
567 load(&quot;nashorn:mozilla_compat.js&quot;);
568 // Import Java packages and classes 
569 // like import package.*; in Java
570 &lt;span class=&quot;functionref&quot;&gt;importPackage&lt;/span&gt;(java.awt);
571 // like import java.awt.Frame in Java
572 &lt;span class=&quot;functionref&quot;&gt;importClass&lt;/span&gt;(java.awt.Frame);
573 // Create Java Objects by &quot;new ClassName&quot;
574 var frame = new java.awt.Frame(&quot;hello&quot;);
575 // Call Java public methods from script
576 frame.setVisible(true);
577 // Access &quot;JavaBean&quot; properties like &quot;fields&quot;
578 print(frame.title);
579 &lt;/code&gt;
580 &lt;/pre&gt;
581 &lt;p&gt;The &lt;span class=&quot;objectref&quot;&gt;Packages&lt;/span&gt; global variable can
582 be used to access Java packages. Examples:
583 &lt;code&gt;Packages.java.util.Vector&lt;/code&gt;,
584 &lt;code&gt;Packages.javax.swing.JFrame&lt;/code&gt;. Please note that &quot;java&quot;
585 is a shortcut for &quot;Packages.java&quot;. There are equivalent shortcuts
586 for javax, org, edu, com, net prefixes, so pratically all JDK
587 platform classes can be accessed without the &quot;Packages&quot; prefix.&lt;/p&gt;
588 &lt;p&gt;Note that java.lang is not imported by default (unlike Java)
589 because that would result in conflicts with JavaScript&#39;s built-in
590 Object, Boolean, Math and so on.&lt;/p&gt;
591 &lt;p&gt;&lt;code&gt;importPackage&lt;/code&gt; and &lt;code&gt;importClass&lt;/code&gt;
592 functions &quot;pollute&quot; the global variable scope of JavaScript. To
593 avoid that, you may use &lt;span class=&quot;functionref&quot;&gt;JavaImporter&lt;/span&gt;.&lt;/p&gt;
594 &lt;pre&gt;&lt;code&gt;
595 
596 // &lt;a href=&quot;source/javaimporter.js&quot;&gt;javaimporter.js&lt;/a&gt;
597 
598 // create JavaImporter with specific packages and classes to import
599 
600 var SwingGui = new &lt;span class=&quot;functionref&quot;&gt;JavaImporter&lt;/span&gt;(javax.swing,
601                             javax.swing.event,
602                             javax.swing.border,
603                             java.awt.event);
604 with (SwingGui) {
605     // within this &#39;with&#39; statement, we can access Swing and AWT
606     // classes by unqualified (simple) names.
607 
608     var mybutton = new JButton(&quot;test&quot;);
609     var myframe = new JFrame(&quot;test&quot;);
610 }
611 
612 &lt;/code&gt;
613 &lt;/pre&gt;
614 &lt;hr&gt;
615 &lt;a name=&quot;jsarrays&quot; id=&quot;jsarrays&quot;&gt;&lt;/a&gt;
616 &lt;h3&gt;Creating, Converting and Using Java Arrays&lt;/h3&gt;
617 &lt;p&gt;
618 Array element access or length access is the same as in Java.&lt;/p&gt;
619 &lt;pre&gt;&lt;code&gt;
620 // &lt;a href=&quot;source/javaarray.js&quot;&gt;javaarray.js&lt;/a&gt;
621 
622 // create Java String array of 5 elements
623 var StringArray = Java.type(&quot;java.lang.String[]&quot;);
624 var a = new StringArray(5);
625 
626 // Accessing elements and length access is by usual Java syntax
627 a[0] = &quot;scripting is great!&quot;;
628 print(a.length);
629 print(a[0]);
630 &lt;/code&gt;
631 &lt;/pre&gt;
632 &lt;p&gt;
633 It is also possible to convert between JavaScript and Java arrays.
634 Given a JavaScript array and a Java type, &lt;code&gt;Java.to&lt;/code&gt; returns a Java array with the same initial contents, and with the specified array type. 
635 &lt;/p&gt;
636 &lt;pre&gt;&lt;code&gt;
637  var anArray = [1, &quot;13&quot;, false]
638  var javaIntArray = Java.to(anArray, &quot;int[]&quot;)
639  print(javaIntArray[0]) // prints 1
640  print(javaIntArray[1]) // prints 13, as string &quot;13&quot; was converted to number 13 as per ECMAScript ToNumber conversion
641  print(javaIntArray[2]) // prints 0, as boolean false was converted to number 0 as per ECMAScript ToNumber conversion
642 &lt;/code&gt;&lt;/pre&gt;
643 &lt;p&gt;
644 You can use either a string or a type object returned from &lt;code&gt;Java.type()&lt;/code&gt; to specify the type of the array. 
645 You can also omit the array type, in which case a &lt;code&gt;Object[]&lt;/code&gt; will be created.
646 &lt;/p&gt;
647 &lt;p&gt;
648 Given a Java array or Collection, &lt;code&gt;Java.from&lt;/code&gt; returns a JavaScript array with a shallow copy of its contents. Note that in most cases, you can use Java arrays and lists natively in Nashorn; in cases where for some reason you need to have an actual JavaScript native array (e.g. to work with the array comprehensions functions), you will want to use this method.
649 &lt;/p&gt;
650 &lt;pre&gt;&lt;code&gt;
651 var File = Java.type(&quot;java.io.File&quot;);
652 var listCurDir = new File(&quot;.&quot;).listFiles();
653 var jsList = Java.from(listCurDir);
654 print(jsList);
655 &lt;/code&gt;&lt;/pre&gt;
656 &lt;hr&gt;
657 &lt;a name=&quot;jsimplement&quot; id=&quot;jsimplement&quot;&gt;&lt;/a&gt;
658 &lt;h3&gt;Implementing Java interfaces&lt;/h3&gt;
659 &lt;p&gt;A Java interface can be implemented in JavaScript by using a
660 Java anonymous class-like syntax:&lt;/p&gt;
661 &lt;pre&gt;&lt;code&gt;
662 // &lt;a href=&quot;source/runnable.js&quot;&gt;runnable.js&lt;/a&gt;
663 
664 var r  = new java.lang.Runnable() {
665     run: function() {
666         print(&quot;running...\n&quot;);
667     }
668 };
669 
670 // &quot;r&quot; can be passed to Java methods that expect java.lang.Runnable
671 var th = new java.lang.Thread(r);
672 th.start();
673 th.join();
674 &lt;/code&gt;
675 &lt;/pre&gt;
676 &lt;p&gt;When an interface with a single method is expected, you can pass
677 a script function directly.(auto conversion)&lt;/p&gt;
678 &lt;pre&gt;&lt;code&gt;
679 // &lt;a href=&quot;source/samfunc.js&quot;&gt;samfunc.js&lt;/a&gt;
680 
681 function func() {
682      print(&quot;I am func!&quot;);
683 }
684 
685 // pass script function for java.lang.Runnable argument
686 var th = new java.lang.Thread(func);
687 th.start();
688 th.join();
689 &lt;/code&gt;
690 &lt;/pre&gt;
691 &lt;hr&gt;
692 &lt;a name=&quot;jsextendabstract&quot; id=&quot;jsextendabstract&quot;&gt;&lt;/a&gt;
693 &lt;h3&gt;Extending Abstract Java Classes&lt;/h3&gt;
694 &lt;p&gt;
695 If a Java class is abstract, you can instantiate an anonymous subclass of it using an argument list that is applicable to any of its public or protected constructors, but inserting a JavaScript object with functions properties that provide JavaScript implementations of the abstract methods. If method names are overloaded, the JavaScript function will provide implementation for all overloads. E.g.:
696 &lt;/p&gt;
697 
698 &lt;pre&gt;&lt;code&gt;
699  var TimerTask =  Java.type(&quot;java.util.TimerTask&quot;)
700  var task = new TimerTask({ run: function() { print(&quot;Hello World!&quot;) } })
701 &lt;/code&gt;&lt;/pre&gt;
702 
703 Nashorn supports a syntactic extension where a &quot;new&quot; expression followed by an argument is identical to invoking the constructor and passing the argument to it, so you can write the above example also as:
704 
705 &lt;pre&gt;&lt;code&gt;
706  var task = new TimerTask {
707      run: function() {
708        print(&quot;Hello World!&quot;)
709      }
710  }
711 &lt;/code&gt;&lt;/pre&gt;
712 
713 which is very similar to Java anonymous inner class definition. On the other hand, if the type is an abstract type with a single abstract method (commonly referred to as a &quot;SAM type&quot;) or all abstract methods it has share the same overloaded name), then instead of an object, you can just pass a function, so the above example can become even more simplified to:
714 
715 &lt;pre&gt;&lt;code&gt;
716  var task = new TimerTask(function() { print(&quot;Hello World!&quot;) })
717 &lt;/code&gt;&lt;/pre&gt;
718 
719 &lt;p&gt;
720 Note that in every one of these cases if you are trying to instantiate an abstract class that has constructors that take some arguments, you can invoke those simply by specifying the arguments after the initial implementation object or function.
721 &lt;/p&gt;
722 &lt;p&gt;
723 The use of functions can be taken even further; if you are invoking a Java method that takes a SAM type, you can just pass in a function object, and Nashorn will know what you meant:
724 &lt;/p&gt;
725 &lt;code&gt;&lt;pre&gt;
726  Java.type(&quot;java.util.Timer&quot;)
727  timer.schedule(function() { print(&quot;Hello World!&quot;) })
728 &lt;/code&gt;&lt;/pre&gt;
729 
730 Here, &lt;code&gt;Timer.schedule()&lt;/code&gt; expects a &lt;code&gt;TimerTask&lt;/code&gt; as its argument, so Nashorn creates an instance of a TimerTask subclass and uses the passed function to implement its only abstract method, run(). In this usage though, you can&#39;t use non-default constructors; the type must be either an interface, or must have a protected or public no-arg constructor.
731 
732 &lt;hr&gt;
733 &lt;a name=&quot;jsextendconcrete&quot; id=&quot;jsextendconcrete&quot;&gt;&lt;/a&gt;
734 &lt;h3&gt;Extending Concrete Java Classes&lt;/h3&gt;
735 &lt;p&gt;
736 To extend a concrete Java class, you have to use &lt;code&gt;Java.extend&lt;/code&gt; function.
737 &lt;code&gt;Java.extend&lt;/code&gt; returns a type object for a subclass of the specified Java class (or implementation of the specified interface) that acts as a script-to-Java adapter for it.  
738 &lt;/p&gt;
739 &lt;pre&gt;&lt;code&gt;
740 // &lt;a href=&quot;source/javaextend.js&quot;&gt;javaextend.js&lt;/a&gt;
741 
742 var ArrayList = Java.type(&quot;java.util.ArrayList&quot;)
743 var ArrayListExtender = Java.extend(ArrayList)
744 var printSizeInvokedArrayList = new ArrayListExtender() {
745     size: function() { print(&quot;size invoked!&quot;); }
746 }
747 var printAddInvokedArrayList = new ArrayListExtender() {
748     add: function(x, y) {
749         if(typeof(y) === &quot;undefined&quot;) {
750             print(&quot;add(e) invoked!&quot;);
751         } else {
752             print(&quot;add(i, e) invoked!&quot;);
753         }
754     }
755 };
756 printSizeInvokedArrayList.size();
757 printAddInvokedArrayList.add(33, 33);
758 &lt;/code&gt;&lt;/pre&gt;
759 &lt;p&gt;
760 The reason you must use &lt;code&gt;Java.extend()&lt;/code&gt; with concrete classes is that with concrete classes, there can be a 
761 syntactic ambiguity if you just invoke their constructor. Consider this example:
762 &lt;/p&gt;
763 &lt;pre&gt;&lt;code&gt;
764 var t = new java.lang.Thread({ run: function() { print(&quot;Hello!&quot;) } })
765 &lt;/code&gt;&lt;/pre&gt;
766 &lt;p&gt;
767 If we allowed subclassing of concrete classes with constructor syntax, Nashorn couldn&#39;t tell if you&#39;re creating a new 
768 &lt;code&gt;Thread&lt;/code&gt; and passing it a &lt;code&gt;Runnable&lt;/code&gt; at this point, or you are subclassing &lt;code&gt;Thread&lt;/code&gt; and
769 passing it a new implementation for its own &lt;code&gt;run()&lt;/code&gt; method.
770 &lt;/p&gt;
771 &lt;hr&gt;
772 &lt;a name=&quot;jsimplementmultiple&quot; id=&quot;jsimplementmultiple&quot;&gt;&lt;/a&gt;
773 &lt;h3&gt;Implementing Multiple Interfaces&lt;/h3&gt;
774 &lt;p&gt;
775 &lt;code&gt;Java.extend&lt;/code&gt; can in fact take a list of multiple types. At most one of the types can be a class, and the rest must
776 be interfaces (the class doesn&#39;t have to be the first in the list). You will get back an object that extends the class and 
777 implements all the interfaces. (Obviously, if you only specify interfaces and no class, the object will extend &lt;code&gt;java.lang.Object&lt;/code&gt;).
778 &lt;hr&gt;
779 &lt;a name=&quot;classBoundImplementations&quot; id=&quot;classBoundImplementations&quot;&gt;&lt;/a&gt;
780 &lt;h3&gt;Class-Bound Implementations&lt;/h3&gt;
781 &lt;p&gt;
782 The methods shown so far for extending Java classes and implementing interfaces &amp;ndash; passing an implementation JavaScript object 
783 or function to a constructor, or using &lt;code&gt;Java.extend&lt;/code&gt; with &lt;code&gt;new&lt;/code&gt; &amp;ndash; all produce classes that take an
784 extra JavaScript object parameter in their constructors that specifies the implementation. The implementation is therefore always bound
785 to the actual instance being created with &lt;code&gt;new&lt;/code&gt;, and not to the whole class. This has some advantages, for example in the
786 memory footprint of the runtime, as Nashorn can just create a single &quot;universal adapter&quot; for every combination of types being implemented.
787 In reality, the below code shows that different instantiations of, say, &lt;code&gt;Runnable&lt;/code&gt; have the same class regardless of them having
788 different JavaScript implementation objects:
789 &lt;/p&gt;
790 &lt;pre&gt;&lt;code&gt;
791 var Runnable = java.lang.Runnable;
792 var r1 = new Runnable(function() { print(&quot;I&#39;m runnable 1!&quot;) })
793 var r2 = new Runnable(function() { print(&quot;I&#39;m runnable 2!&quot;) })
794 r1.run()
795 r2.run()
796 print(&quot;We share the same class: &quot; + (r1.class === r2.class))
797 &lt;/code&gt;&lt;/pre&gt;
798 &lt;p&gt;
799 prints:
800 &lt;/p&gt;
801 &lt;pre&gt;&lt;code&gt;
802 I&#39;m runnable 1!
803 I&#39;m runnable 2!
804 We share the same class: true
805 &lt;/code&gt;&lt;/pre&gt;
806 &lt;p&gt;
807 Sometimes, however, you&#39;ll want to extend a Java class or implement an interface with implementation bound to the class, not to
808 its instances. Such a need arises, for example, when you need to pass the class for instantiation to an external API; prime example
809 of this is the JavaFX framework where you need to pass an Application class to the FX API and let it instantiate it.
810 &lt;/p&gt;
811 &lt;p&gt;
812 Fortunately, there&#39;s a solution for that: &lt;code&gt;Java.extend()&lt;/code&gt; &amp;ndash; aside from being able to take any number of type parameters
813 denoting a class to extend and interfaces to implement &amp;ndash; can also take one last argument that has to be a JavaScript object
814 that serves as the implementation for the methods. In this case, &lt;code&gt;Java.extend()&lt;/code&gt; will create a class that has the same
815 constructors as the original class had, as they don&#39;t need to take an an extra implementation object parameter. The example below
816 shows how you can create class-bound implementations, and shows that in this case, the implementation classes for different invocations
817 are indeed different:
818 &lt;/p&gt;
819 &lt;pre&gt;&lt;code&gt;
820 var RunnableImpl1 = Java.extend(java.lang.Runnable, function() { print(&quot;I&#39;m runnable 1!&quot;) })
821 var RunnableImpl2 = Java.extend(java.lang.Runnable, function() { print(&quot;I&#39;m runnable 2!&quot;) })
822 var r1 = new RunnableImpl1()
823 var r2 = new RunnableImpl2()
824 r1.run()
825 r2.run()
826 print(&quot;We share the same class: &quot; + (r1.class === r2.class))
827 &lt;/code&gt;&lt;/pre&gt;
828 &lt;p&gt;
829 prints:
830 &lt;/p&gt;
831 &lt;pre&gt;&lt;code&gt;
832 I&#39;m runnable 1!
833 I&#39;m runnable 2!
834 We share the same class: false
835 &lt;/code&gt;&lt;/pre&gt;
836 &lt;p&gt;
837 As you can see, the major difference here is that we moved the implementation object into the invocation of &lt;code&gt;Java.extend&lt;/code&gt;
838 from the constructor invocations &amp;ndash; indeed the constructor invocations now don&#39;t even need to take an extra parameter! Since
839 the implementations are bound to a class, the two classes obviously can&#39;t be the same, and we indeed see that the two runnables no
840 longer share the same class &amp;ndash; every invocation of &lt;code&gt;Java.extend()&lt;/code&gt; with a class-specific implementation object triggers
841 the creation of a new Java adapter class.
842 &lt;/p&gt;
843 &lt;p&gt;
844 Finally, the adapter classes with class-bound implementations can &lt;i&gt;still&lt;/i&gt; take an additional constructor parameter to further
845 override the behavior on a per-instance basis. Thus, you can even combine the two approaches: you can provide part of the implementation
846 in a class-based JavaScript implementation object passed to &lt;code&gt;Java.extend&lt;/code&gt;, and part in another object passed to the constructor.
847 Whatever functions are provided by the constructor-passed object will override the functions in the class-bound object.
848 &lt;/p&gt;
849 &lt;pre&gt;&lt;code&gt;
850 var RunnableImpl = Java.extend(java.lang.Runnable, function() { print(&quot;I&#39;m runnable 1!&quot;) })
851 var r1 = new RunnableImpl()
852 var r2 = new RunnableImpl(function() { print(&quot;I&#39;m runnable 2!&quot;) })
853 r1.run()
854 r2.run()
855 print(&quot;We share the same class: &quot; + (r1.class === r2.class))
856 &lt;/code&gt;&lt;/pre&gt;
857 &lt;p&gt;
858 prints:
859 &lt;/p&gt;
860 &lt;pre&gt;&lt;code&gt;
861 I&#39;m runnable 1!
862 I&#39;m runnable 2!
863 We share the same class: true
864 &lt;/code&gt;&lt;/pre&gt;
865 &lt;hr&gt;
866 &lt;a name=&quot;jsoverload&quot; id=&quot;jsoverload&quot;&gt;&lt;/a&gt;
867 &lt;h3&gt;Overload Resolution&lt;/h3&gt;
868 &lt;p&gt;Java methods can be overloaded by argument types. In Java,
869 overload resolution occurs at compile time (performed by javac).
870 When calling Java methods from Nashorn, the appropriate method will be
871 selected based on the argument types at invocation time. You do not need
872 to do anything special &amp;ndash; the correct Java method overload variant 
873 is selected based automatically. You still have the option of explicitly
874 specifying a particular overload variant. Reasons for this include 
875 either running into a genuine ambiguity with actual argument types, or 
876 rarely reasons of performance &amp;ndash; if you specify the actual overload
877 then the engine doesn&#39;t have to perform resolution during invocation.
878 Individual overloads of a Java methods are exposed as special properties
879 with the name of the method followed with its signature in parentheses. 
880 You can invoke them like this:&lt;/p&gt;
881 &lt;pre&gt;&lt;code&gt;
882 // &lt;a href=&quot;source/overload.js&quot;&gt;overload.js&lt;/a&gt;
883 
884 var out = java.lang.System.out;
885 
886 // select a particular print function 
887 out[&quot;println(Object)&quot;](&quot;hello&quot;);
888 &lt;/code&gt;
889 &lt;/pre&gt;
890 &lt;p&gt;
891 Note that you normally don&#39;t even have to use qualified class names in 
892 the signatures as long as the unqualified name of the type is sufficient
893 for uniquely identifying the signature. In practice this means that only
894 in the extremely unlikely case that two overloads only differ in 
895 parameter types that have identical unqualified names but come from 
896 different packages would you need to use the fully qualified name of the
897 class.
898 &lt;/p&gt;
899 &lt;hr&gt;
900 &lt;a name=&quot;dataTypeMapping&quot; id=&quot;dataTypeMapping&quot;&gt;&lt;/a&gt;
901 &lt;h3&gt;Mapping of Data Types Between Java and JavaScript&lt;/h3&gt;
902 &lt;p&gt;
903 We have previously shown some of the data type mappings between Java and JavaScript.
904 We saw that arrays need to be explicitly converted. We have also shown that JavaScript functions
905 are automatically converted to SAM types when passed as parameters to Java methods. Most other
906 conversions work as you would expect.
907 &lt;/p&gt;
908 &lt;p&gt;
909 Every JavaScript object is also a &lt;code&gt;java.util.Map&lt;/code&gt; so APIs receiving maps will receive them directly.
910 &lt;/p&gt;
911 &lt;p&gt;
912 When numbers are passed to a Java API, they will be converted to the expected target numeric type, either boxed or
913 primitive, but if the target type is less specific, say &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt;, you can only
914 count on them being a &lt;code&gt;Number&lt;/code&gt;, and have to test specifically for whether it&#39;s a boxed &lt;code&gt;Double&lt;/code&gt;,
915 &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, etc. &amp;ndash; it can be any of these due to internal optimizations. Also, you 
916 can pass any JavaScript value to a Java API expecting either a boxed or primitive number; the JavaScript specification&#39;s
917 &lt;code&gt;ToNumber&lt;/code&gt; conversion algorithm will be applied to the value.
918 &lt;/p&gt;
919 &lt;p&gt;
920 In a similar vein, if a Java method expects a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Boolean&lt;/code&gt;, the values will be
921 converted using all conversions allowed by the JavaScript specification&#39;s &lt;code&gt;ToString&lt;/code&gt; and &lt;code&gt;ToBoolean&lt;/code&gt;
922 conversions.
923 &lt;/p&gt;
924 &lt;p&gt;
925 Finally, a word of caution about strings. Due to internal performance optimizations of string operations, JavaScript strings are
926 not always necessarily of type &lt;code&gt;java.lang.String&lt;/code&gt;, but they will always be of type &lt;code&gt;java.lang.CharSequence&lt;/code&gt;.
927 If you pass them to a Java method that expects a &lt;code&gt;java.lang.String&lt;/code&gt; parameter, then you will naturally receive a Java
928 String, but if the signature of your method is more generic, i.e. it receives a &lt;code&gt;java.lang.Object&lt;/code&gt; parameter, you can 
929 end up with an object of private engine implementation class that implements &lt;code&gt;CharSequence&lt;/code&gt; but is not a Java String.
930 &lt;/p&gt;
931 &lt;hr&gt;
932 &lt;a name=&quot;engineimpl&quot; id=&quot;engineimpl&quot;&gt;&lt;/a&gt;
933 &lt;h2&gt;Implementing Your Own Script Engine&lt;/h2&gt;
934 &lt;p&gt;We will not cover implementation of JSR-223 compliant script
935 engines in detail. Minimally, you need to implement the
936 &lt;code&gt;javax.script.ScriptEngine&lt;/code&gt; and
937 &lt;code&gt;javax.script.ScriptEngineFactory&lt;/code&gt; interfaces. The
938 abstract class &lt;code&gt;javax.script.AbstractScriptEngine&lt;/code&gt;
939 provides useful defaults for a few methods of the
940 &lt;code&gt;ScriptEngine&lt;/code&gt; interface.&lt;/p&gt;
941 &lt;p&gt;Before starting to implement a JSR-223 engine, you may want to
942 check &lt;a href=&quot;http://java.net/projects/Scripting&quot;&gt;http://java.net/projects/Scripting&lt;/a&gt;
943 project. This project maintains JSR-223 implementations for many
944 popular open source scripting languages.&lt;/p&gt;
945 &lt;hr&gt;
946 &lt;a name=&quot;refs&quot; id=&quot;refs&quot;&gt;&lt;/a&gt;
947 &lt;h2&gt;References&lt;/h2&gt;
948 &lt;ul&gt;
949 &lt;li&gt;&lt;a href=&quot;http://jcp.org/en/jsr/detail?id=223&quot;&gt;JSR-223 Scripting
950 for the Java Platform&lt;/a&gt;&lt;/li&gt;
951 &lt;li&gt;&lt;a href=&quot;http://java.net/projects/Scripting&quot;&gt;http://java.net/projects/Scripting
952 &lt;/a&gt;&lt;/li&gt;
953 &lt;/ul&gt;
954 
955 
956 
957 &lt;div class=&quot;hr&quot;&gt;&lt;hr&gt;&lt;/div&gt;
958 &lt;table summary=&quot;layout&quot; border=&quot;0&quot; width=&quot;100%&quot;&gt;
959 &lt;tbody&gt;&lt;tr valign=&quot;TOP&quot;&gt;
960 &lt;td width=&quot;30%&quot;&gt; &lt;img src=&quot;Java%20Scripting%20Programmer%27s%20Guide_files/logo_oracle_footer.gif&quot; alt=&quot;Oracle and/or its affiliates&quot; border=&quot;0&quot; height=&quot;29&quot; width=&quot;100&quot;&gt;&lt;br&gt;
961 &lt;font size=&quot;+1&quot;&gt; &lt;i&gt;Java Technology&lt;/i&gt;&lt;/font&gt; &lt;/td&gt;
962 
963 &lt;td width=&quot;30%&quot;&gt;
964 &lt;p&gt;&lt;font size=&quot;-2&quot;&gt;
965 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/legal/cpyr.html&quot;&gt;Copyright &lt;/a&gt; 2013, Oracle and/or its affiliates. All rights reserved.
966 &lt;/font&gt;&lt;/p&gt; 
967 &lt;/td&gt;
968 &lt;td width=&quot;30%&quot;&gt;
969 &lt;p align=&quot;right&quot;&gt;&lt;font size=&quot;-2&quot;&gt;&lt;a href=&quot;http://download.oracle.com/javase/feedback.html&quot;&gt;Contact Us&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;&lt;font size=&quot;-2&quot;&gt;
970 &lt;/font&gt;&lt;/td&gt;
971 &lt;/tr&gt;
972 &lt;/tbody&gt;&lt;/table&gt; 
973 &lt;div class=&quot;hr&quot;&gt;&lt;hr&gt;&lt;/div&gt;
974 &lt;/div&gt;
975 
976 &lt;!-- Start SiteCatalyst code   --&gt;
977 &lt;script language=&quot;JavaScript&quot; src=&quot;Java%20Scripting%20Programmer%27s%20Guide_files/s_code_download.js&quot;&gt;&lt;/script&gt;
978 &lt;script language=&quot;JavaScript&quot; src=&quot;Java%20Scripting%20Programmer%27s%20Guide_files/s_code.js&quot;&gt;&lt;/script&gt;
979  
980 &lt;!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** --&gt;
981 &lt;!--  Below code will send the info to Omniture server --&gt;
982 &lt;script language=&quot;javascript&quot;&gt;var s_code=s.t();if(s_code)document.write(s_code)&lt;/script&gt;
983  
984 &lt;!-- End SiteCatalyst code --&gt;
985 
986 
987 
988 &lt;/body&gt;&lt;/html&gt;
    </pre>
  </body>
</html>