<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
<a name="1" id="anc1"></a><span class="line-added"> 189         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 190                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 191     }
 192 
 193     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 194         return  keepEndPositions
 195                 ? new SimpleEndPosTable(this)
 196                 : new EmptyEndPosTable(this);
 197     }
 198 
 199     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 200         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 201     }
 202 
 203     /** Switch: should we fold strings?
 204      */
 205     boolean allowStringFolding;
 206 
 207     /** Switch: should we keep docComments?
 208      */
 209     boolean keepDocComments;
 210 
 211     /** Switch: should we keep line table?
 212      */
 213     boolean keepLineMap;
 214 
 215     /** Switch: is &quot;this&quot; allowed as an identifier?
 216      * This is needed to parse receiver types.
 217      */
 218     boolean allowThisIdent;
 219 
 220     /** Switch: is yield statement allowed in this source level?
 221      */
 222     boolean allowYieldStatement;
 223 
 224     /** Switch: are records allowed in this source level?
 225      */
 226     boolean allowRecords;
 227 
<a name="2" id="anc2"></a><span class="line-added"> 228     /** Switch: are sealed types allowed in this source level?</span>
<span class="line-added"> 229      */</span>
<span class="line-added"> 230     boolean allowSealedTypes;</span>
<span class="line-added"> 231 </span>
 232     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 233      */
 234     JCVariableDecl receiverParam;
 235 
 236     /** When terms are parsed, the mode determines which is expected:
 237      *     mode = EXPR        : an expression
 238      *     mode = TYPE        : a type
 239      *     mode = NOPARAMS    : no parameters allowed for type
 240      *     mode = TYPEARG     : type argument
 241      *     mode |= NOLAMBDA   : lambdas are not allowed
 242      */
 243     protected static final int EXPR = 0x1;
 244     protected static final int TYPE = 0x2;
 245     protected static final int NOPARAMS = 0x4;
 246     protected static final int TYPEARG = 0x8;
 247     protected static final int DIAMOND = 0x10;
 248     protected static final int NOLAMBDA = 0x20;
 249 
 250     protected void selectExprMode() {
 251         mode = (mode &amp; NOLAMBDA) | EXPR;
 252     }
 253 
 254     protected void selectTypeMode() {
 255         mode = (mode &amp; NOLAMBDA) | TYPE;
 256     }
 257 
 258     /** The current mode.
 259      */
 260     protected int mode = 0;
 261 
 262     /** The mode of the term that was parsed last.
 263      */
 264     protected int lastmode = 0;
 265 
 266     /* ---------- token management -------------- */
 267 
 268     protected Token token;
 269 
 270     public Token token() {
 271         return token;
 272     }
 273 
 274     public void nextToken() {
 275         S.nextToken();
 276         token = S.token();
 277     }
 278 
 279     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 280         return peekToken(0, tk);
 281     }
 282 
 283     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 284         return tk.accepts(S.token(lookahead + 1).kind);
 285     }
 286 
 287     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 288         return peekToken(0, tk1, tk2);
 289     }
 290 
 291     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 292         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 293                 tk2.accepts(S.token(lookahead + 2).kind);
 294     }
 295 
 296     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 297         return peekToken(0, tk1, tk2, tk3);
 298     }
 299 
 300     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 301         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 302                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 303                 tk3.accepts(S.token(lookahead + 3).kind);
 304     }
 305 
 306     @SuppressWarnings(&quot;unchecked&quot;)
 307     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 308         return peekToken(0, kinds);
 309     }
 310 
 311     @SuppressWarnings(&quot;unchecked&quot;)
 312     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 313         for (; lookahead &lt; kinds.length ; lookahead++) {
 314             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 315                 return false;
 316             }
 317         }
 318         return true;
 319     }
 320 
 321     /* ---------- error recovery -------------- */
 322 
 323     private JCErroneous errorTree;
 324 
 325     /** Skip forward until a suitable stop token is found.
 326      */
 327     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 328          while (true) {
 329              switch (token.kind) {
 330                 case SEMI:
 331                     nextToken();
 332                     return;
 333                 case PUBLIC:
 334                 case FINAL:
 335                 case ABSTRACT:
 336                 case MONKEYS_AT:
 337                 case EOF:
 338                 case CLASS:
 339                 case INTERFACE:
 340                 case ENUM:
 341                     return;
 342                 case IMPORT:
 343                     if (stopAtImport)
 344                         return;
 345                     break;
 346                 case LBRACE:
 347                 case RBRACE:
 348                 case PRIVATE:
 349                 case PROTECTED:
 350                 case STATIC:
 351                 case TRANSIENT:
 352                 case NATIVE:
 353                 case VOLATILE:
 354                 case SYNCHRONIZED:
 355                 case STRICTFP:
 356                 case LT:
 357                 case BYTE:
 358                 case SHORT:
 359                 case CHAR:
 360                 case INT:
 361                 case LONG:
 362                 case FLOAT:
 363                 case DOUBLE:
 364                 case BOOLEAN:
 365                 case VOID:
 366                     if (stopAtMemberDecl)
 367                         return;
 368                     break;
 369                 case UNDERSCORE:
 370                 case IDENTIFIER:
 371                    if (stopAtIdentifier)
 372                         return;
 373                     break;
 374                 case CASE:
 375                 case DEFAULT:
 376                 case IF:
 377                 case FOR:
 378                 case WHILE:
 379                 case DO:
 380                 case TRY:
 381                 case SWITCH:
 382                 case RETURN:
 383                 case THROW:
 384                 case BREAK:
 385                 case CONTINUE:
 386                 case ELSE:
 387                 case FINALLY:
 388                 case CATCH:
 389                 case THIS:
 390                 case SUPER:
 391                 case NEW:
 392                     if (stopAtStatement)
 393                         return;
 394                     break;
 395                 case ASSERT:
 396                     if (stopAtStatement)
 397                         return;
 398                     break;
 399             }
 400             nextToken();
 401         }
 402     }
 403 
 404     protected JCErroneous syntaxError(int pos, Error errorKey) {
 405         return syntaxError(pos, List.nil(), errorKey);
 406     }
 407 
 408     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 409         setErrorEndPos(pos);
 410         JCErroneous err = F.at(pos).Erroneous(errs);
 411         reportSyntaxError(err, errorKey);
 412         if (errs != null) {
 413             JCTree last = errs.last();
 414             if (last != null)
 415                 storeEnd(last, pos);
 416         }
 417         return toP(err);
 418     }
 419 
 420     private static final int RECOVERY_THRESHOLD = 50;
 421     private int errorPos = Position.NOPOS;
 422     private int count = 0;
 423 
 424     /**
 425      * Report a syntax using the given the position parameter and arguments,
 426      * unless one was already reported at the same position.
 427      */
 428     protected void reportSyntaxError(int pos, Error errorKey) {
 429         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 430         reportSyntaxError(diag, errorKey);
 431     }
 432 
 433     /**
 434      * Report a syntax error using the given DiagnosticPosition object and
 435      * arguments, unless one was already reported at the same position.
 436      */
 437     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 438         int pos = diagPos.getPreferredPosition();
 439         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 440             if (token.kind == EOF) {
 441                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 442             } else {
 443                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 444             }
 445         }
 446         S.errPos(pos);
 447         if (token.pos == errorPos) {
 448             //check for a possible infinite loop in parsing:
 449             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 450         } else {
 451             count = 0;
 452             errorPos = token.pos;
 453         }
 454     }
 455 
 456     /** If next input token matches given token, skip it, otherwise report
 457      *  an error.
 458      */
 459     public void accept(TokenKind tk) {
 460         accept(tk, Errors::Expected);
 461     }
 462 
 463     /** If next input token matches given token, skip it, otherwise report
 464      *  an error.
 465      */
 466     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 467         if (token.kind == tk) {
 468             nextToken();
 469         } else {
 470             setErrorEndPos(token.pos);
 471             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 472         }
 473     }
 474 
 475     /** Report an illegal start of expression/type error at given position.
 476      */
 477     JCExpression illegal(int pos) {
 478         setErrorEndPos(pos);
 479         if ((mode &amp; EXPR) != 0)
 480             return syntaxError(pos, Errors.IllegalStartOfExpr);
 481         else
 482             return syntaxError(pos, Errors.IllegalStartOfType);
 483 
 484     }
 485 
 486     /** Report an illegal start of expression/type error at current position.
 487      */
 488     JCExpression illegal() {
 489         return illegal(token.pos);
 490     }
 491 
 492     /** Diagnose a modifier flag from the set, if any. */
 493     protected void checkNoMods(long mods) {
 494         if (mods != 0) {
 495             long lowestMod = mods &amp; -mods;
 496             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 497         }
 498     }
 499 
 500 /* ---------- doc comments --------- */
 501 
 502     /** A table to store all documentation comments
 503      *  indexed by the tree nodes they refer to.
 504      *  defined only if option flag keepDocComment is set.
 505      */
 506     private final DocCommentTable docComments;
 507 
 508     /** Make an entry into docComments hashtable,
 509      *  provided flag keepDocComments is set and given doc comment is non-null.
 510      *  @param tree   The tree to be used as index in the hashtable
 511      *  @param dc     The doc comment to associate with the tree, or null.
 512      */
 513     protected void attach(JCTree tree, Comment dc) {
 514         if (keepDocComments &amp;&amp; dc != null) {
 515 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 516             docComments.putComment(tree, dc);
 517         }
 518     }
 519 
 520 /* -------- source positions ------- */
 521 
 522     protected void setErrorEndPos(int errPos) {
 523         endPosTable.setErrorEndPos(errPos);
 524     }
 525 
 526     protected void storeEnd(JCTree tree, int endpos) {
 527         endPosTable.storeEnd(tree, endpos);
 528     }
 529 
 530     protected &lt;T extends JCTree&gt; T to(T t) {
 531         return endPosTable.to(t);
 532     }
 533 
 534     protected &lt;T extends JCTree&gt; T toP(T t) {
 535         return endPosTable.toP(t);
 536     }
 537 
 538     /** Get the start position for a tree node.  The start position is
 539      * defined to be the position of the first character of the first
 540      * token of the node&#39;s source text.
 541      * @param tree  The tree node
 542      */
 543     public int getStartPos(JCTree tree) {
 544         return TreeInfo.getStartPos(tree);
 545     }
 546 
 547     /**
 548      * Get the end position for a tree node.  The end position is
 549      * defined to be the position of the last character of the last
 550      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 551      * positions are not generated or the position is otherwise not
 552      * found.
 553      * @param tree  The tree node
 554      */
 555     public int getEndPos(JCTree tree) {
 556         return endPosTable.getEndPos(tree);
 557     }
 558 
 559 
 560 
 561 /* ---------- parsing -------------- */
 562 
 563     /**
 564      * Ident = IDENTIFIER
 565      */
 566     public Name ident() {
 567         return ident(false);
 568     }
 569 
 570     protected Name ident(boolean advanceOnErrors) {
 571         if (token.kind == IDENTIFIER) {
 572             Name name = token.name();
 573             nextToken();
 574             return name;
 575         } else if (token.kind == ASSERT) {
 576             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 577             nextToken();
 578             return names.error;
 579         } else if (token.kind == ENUM) {
 580             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 581             nextToken();
 582             return names.error;
 583         } else if (token.kind == THIS) {
 584             if (allowThisIdent) {
 585                 // Make sure we&#39;re using a supported source version.
 586                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 587                 Name name = token.name();
 588                 nextToken();
 589                 return name;
 590             } else {
 591                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 592                 nextToken();
 593                 return names.error;
 594             }
 595         } else if (token.kind == UNDERSCORE) {
 596             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 597                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 598             } else {
 599                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 600             }
 601             Name name = token.name();
 602             nextToken();
 603             return name;
 604         } else {
 605             accept(IDENTIFIER);
 606             if (advanceOnErrors) {
 607                 nextToken();
 608             }
 609             return names.error;
 610         }
 611     }
 612 
 613     /**
 614      * Qualident = Ident { DOT [Annotations] Ident }
 615      */
 616     public JCExpression qualident(boolean allowAnnos) {
 617         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 618         while (token.kind == DOT) {
 619             int pos = token.pos;
 620             nextToken();
 621             List&lt;JCAnnotation&gt; tyannos = null;
 622             if (allowAnnos) {
 623                 tyannos = typeAnnotationsOpt();
 624             }
 625             t = toP(F.at(pos).Select(t, ident()));
 626             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 627                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 628             }
 629         }
 630         return t;
 631     }
 632 
 633     JCExpression literal(Name prefix) {
 634         return literal(prefix, token.pos);
 635     }
 636 
 637     /**
 638      * Literal =
 639      *     INTLITERAL
 640      *   | LONGLITERAL
 641      *   | FLOATLITERAL
 642      *   | DOUBLELITERAL
 643      *   | CHARLITERAL
 644      *   | STRINGLITERAL
 645      *   | TRUE
 646      *   | FALSE
 647      *   | NULL
 648      */
 649     JCExpression literal(Name prefix, int pos) {
 650         JCExpression t = errorTree;
 651         switch (token.kind) {
 652         case INTLITERAL:
 653             try {
 654                 t = F.at(pos).Literal(
 655                     TypeTag.INT,
 656                     Convert.string2int(strval(prefix), token.radix()));
 657             } catch (NumberFormatException ex) {
 658                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 659             }
 660             break;
 661         case LONGLITERAL:
 662             try {
 663                 t = F.at(pos).Literal(
 664                     TypeTag.LONG,
 665                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 666             } catch (NumberFormatException ex) {
 667                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 668             }
 669             break;
 670         case FLOATLITERAL: {
 671             String proper = token.radix() == 16 ?
 672                     (&quot;0x&quot;+ token.stringVal()) :
 673                     token.stringVal();
 674             Float n;
 675             try {
 676                 n = Float.valueOf(proper);
 677             } catch (NumberFormatException ex) {
 678                 // error already reported in scanner
 679                 n = Float.NaN;
 680             }
 681             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 682                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 683             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 684                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 685             else
 686                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 687             break;
 688         }
 689         case DOUBLELITERAL: {
 690             String proper = token.radix() == 16 ?
 691                     (&quot;0x&quot;+ token.stringVal()) :
 692                     token.stringVal();
 693             Double n;
 694             try {
 695                 n = Double.valueOf(proper);
 696             } catch (NumberFormatException ex) {
 697                 // error already reported in scanner
 698                 n = Double.NaN;
 699             }
 700             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 701                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 702             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 703                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 704             else
 705                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 706             break;
 707         }
 708         case CHARLITERAL:
 709             t = F.at(pos).Literal(
 710                 TypeTag.CHAR,
 711                 token.stringVal().charAt(0) + 0);
 712             break;
 713         case STRINGLITERAL:
 714             t = F.at(pos).Literal(
 715                 TypeTag.CLASS,
 716                 token.stringVal());
 717             break;
 718         case TRUE: case FALSE:
 719             t = F.at(pos).Literal(
 720                 TypeTag.BOOLEAN,
 721                 (token.kind == TRUE ? 1 : 0));
 722             break;
 723         case NULL:
 724             t = F.at(pos).Literal(
 725                 TypeTag.BOT,
 726                 null);
 727             break;
 728         default:
 729             Assert.error();
 730         }
 731         if (t == errorTree)
 732             t = F.at(pos).Erroneous();
 733         storeEnd(t, token.endPos);
 734         nextToken();
 735         return t;
 736     }
 737     //where
 738         boolean isZero(String s) {
 739             char[] cs = s.toCharArray();
 740             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 741             int i = ((base==16) ? 2 : 0);
 742             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 743             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 744         }
 745 
 746         String strval(Name prefix) {
 747             String s = token.stringVal();
 748             return prefix.isEmpty() ? s : prefix + s;
 749         }
 750 
 751     /** terms can be either expressions or types.
 752      */
 753     public JCExpression parseExpression() {
 754         return term(EXPR);
 755     }
 756 
 757     /**
 758      * parses (optional) type annotations followed by a type. If the
 759      * annotations are present before the type and are not consumed during array
 760      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 761      * these annotations and the underlying type. Otherwise, it returns the
 762      * underlying type.
 763      *
 764      * &lt;p&gt;
 765      *
 766      * Note that this method sets {@code mode} to {@code TYPE} first, before
 767      * parsing annotations.
 768      */
 769     public JCExpression parseType() {
 770         return parseType(false);
 771     }
 772 
 773     public JCExpression parseType(boolean allowVar) {
 774         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 775         return parseType(allowVar, annotations);
 776     }
 777 
 778     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 779         JCExpression result = unannotatedType(allowVar);
 780 
 781         if (annotations.nonEmpty()) {
 782             result = insertAnnotationsToMostInner(result, annotations, false);
 783         }
 784 
 785         return result;
 786     }
 787 
 788     public JCExpression unannotatedType(boolean allowVar) {
 789         JCExpression result = term(TYPE);
 790         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 791 
 792         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 793             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 794         }
 795 
 796         return result;
 797     }
 798 
 799 
 800 
 801     protected JCExpression term(int newmode) {
 802         int prevmode = mode;
 803         mode = newmode;
 804         JCExpression t = term();
 805         lastmode = mode;
 806         mode = prevmode;
 807         return t;
 808     }
 809 
 810     /**
 811      *  {@literal
 812      *  Expression = Expression1 [ExpressionRest]
 813      *  ExpressionRest = [AssignmentOperator Expression1]
 814      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 815      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 816      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 817      *  Type = Type1
 818      *  TypeNoParams = TypeNoParams1
 819      *  StatementExpression = Expression
 820      *  ConstantExpression = Expression
 821      *  }
 822      */
 823     JCExpression term() {
 824         JCExpression t = term1();
 825         if ((mode &amp; EXPR) != 0 &amp;&amp;
 826             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 827             return termRest(t);
 828         else
 829             return t;
 830     }
 831 
 832     JCExpression termRest(JCExpression t) {
 833         switch (token.kind) {
 834         case EQ: {
 835             int pos = token.pos;
 836             nextToken();
 837             selectExprMode();
 838             JCExpression t1 = term();
 839             return toP(F.at(pos).Assign(t, t1));
 840         }
 841         case PLUSEQ:
 842         case SUBEQ:
 843         case STAREQ:
 844         case SLASHEQ:
 845         case PERCENTEQ:
 846         case AMPEQ:
 847         case BAREQ:
 848         case CARETEQ:
 849         case LTLTEQ:
 850         case GTGTEQ:
 851         case GTGTGTEQ:
 852             int pos = token.pos;
 853             TokenKind tk = token.kind;
 854             nextToken();
 855             selectExprMode();
 856             JCExpression t1 = term();
 857             return F.at(pos).Assignop(optag(tk), t, t1);
 858         default:
 859             return t;
 860         }
 861     }
 862 
 863     /** Expression1   = Expression2 [Expression1Rest]
 864      *  Type1         = Type2
 865      *  TypeNoParams1 = TypeNoParams2
 866      */
 867     JCExpression term1() {
 868         JCExpression t = term2();
 869         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 870             selectExprMode();
 871             return term1Rest(t);
 872         } else {
 873             return t;
 874         }
 875     }
 876 
 877     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 878      */
 879     JCExpression term1Rest(JCExpression t) {
 880         if (token.kind == QUES) {
 881             int pos = token.pos;
 882             nextToken();
 883             JCExpression t1 = term();
 884             accept(COLON);
 885             JCExpression t2 = term1();
 886             return F.at(pos).Conditional(t, t1, t2);
 887         } else {
 888             return t;
 889         }
 890     }
 891 
 892     /** Expression2   = Expression3 [Expression2Rest]
 893      *  Type2         = Type3
 894      *  TypeNoParams2 = TypeNoParams3
 895      */
 896     JCExpression term2() {
 897         JCExpression t = term3();
 898         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 899             selectExprMode();
 900             return term2Rest(t, TreeInfo.orPrec);
 901         } else {
 902             return t;
 903         }
 904     }
 905 
 906     /*  Expression2Rest = {infixop Expression3}
 907      *                  | Expression3 instanceof Type
 908      *                  | Expression3 instanceof Pattern
 909      *  infixop         = &quot;||&quot;
 910      *                  | &quot;&amp;&amp;&quot;
 911      *                  | &quot;|&quot;
 912      *                  | &quot;^&quot;
 913      *                  | &quot;&amp;&quot;
 914      *                  | &quot;==&quot; | &quot;!=&quot;
 915      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 916      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 917      *                  | &quot;+&quot; | &quot;-&quot;
 918      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 919      */
 920     JCExpression term2Rest(JCExpression t, int minprec) {
 921         JCExpression[] odStack = newOdStack();
 922         Token[] opStack = newOpStack();
 923 
 924         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 925         int top = 0;
 926         odStack[0] = t;
 927         int startPos = token.pos;
 928         Token topOp = Tokens.DUMMY;
 929         while (prec(token.kind) &gt;= minprec) {
 930             opStack[top] = topOp;
 931 
 932             if (token.kind == INSTANCEOF) {
 933                 int pos = token.pos;
 934                 nextToken();
 935                 JCTree pattern = parseType();
 936                 if (token.kind == IDENTIFIER) {
 937                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 938                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 939                 }
 940                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 941             } else {
 942                 topOp = token;
 943                 nextToken();
 944                 top++;
 945                 odStack[top] = term3();
 946             }
 947             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 948                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 949                 top--;
 950                 topOp = opStack[top];
 951             }
 952         }
 953         Assert.check(top == 0);
 954         t = odStack[0];
 955 
 956         if (t.hasTag(JCTree.Tag.PLUS)) {
 957             t = foldStrings(t);
 958         }
 959 
 960         odStackSupply.add(odStack);
 961         opStackSupply.add(opStack);
 962         return t;
 963     }
 964     //where
 965         /** If tree is a concatenation of string literals, replace it
 966          *  by a single literal representing the concatenated string.
 967          */
 968         protected JCExpression foldStrings(JCExpression tree) {
 969             if (!allowStringFolding)
 970                 return tree;
 971             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 972             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 973             boolean needsFolding = false;
 974             JCExpression curr = tree;
 975             while (true) {
 976                 if (curr.hasTag(JCTree.Tag.PLUS)) {
 977                     JCBinary op = (JCBinary)curr;
 978                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
 979                     curr = op.lhs;
 980                 } else {
 981                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
 982                     break; //last one!
 983                 }
 984             }
 985             if (needsFolding) {
 986                 List&lt;JCExpression&gt; ops = opStack.toList();
 987                 JCExpression res = ops.head;
 988                 for (JCExpression op : ops.tail) {
 989                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
 990                     storeEnd(res, getEndPos(op));
 991                 }
 992                 return res;
 993             } else {
 994                 return tree;
 995             }
 996         }
 997 
 998         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
 999                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1000             JCLiteral str = stringLiteral(tree);
1001             if (str != null) {
1002                 litBuf.prepend(str);
1003                 return last &amp;&amp; merge(litBuf, opStack);
1004             } else {
1005                 boolean res = merge(litBuf, opStack);
1006                 litBuf.clear();
1007                 opStack.prepend(tree);
1008                 return res;
1009             }
1010         }
1011 
1012         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1013             if (litBuf.isEmpty()) {
1014                 return false;
1015             } else if (litBuf.size() == 1) {
1016                 opStack.prepend(litBuf.first());
1017                 return false;
1018             } else {
1019                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1020                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1021                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1022                 opStack.prepend(t);
1023                 return true;
1024             }
1025         }
1026 
1027         private JCLiteral stringLiteral(JCTree tree) {
1028             if (tree.hasTag(LITERAL)) {
1029                 JCLiteral lit = (JCLiteral)tree;
1030                 if (lit.typetag == TypeTag.CLASS) {
1031                     return lit;
1032                 }
1033             }
1034             return null;
1035         }
1036 
1037 
1038         /** optimization: To save allocating a new operand/operator stack
1039          *  for every binary operation, we use supplys.
1040          */
1041         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1042         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1043 
1044         private JCExpression[] newOdStack() {
1045             if (odStackSupply.isEmpty())
1046                 return new JCExpression[infixPrecedenceLevels + 1];
1047             return odStackSupply.remove(odStackSupply.size() - 1);
1048         }
1049 
1050         private Token[] newOpStack() {
1051             if (opStackSupply.isEmpty())
1052                 return new Token[infixPrecedenceLevels + 1];
1053             return opStackSupply.remove(opStackSupply.size() - 1);
1054         }
1055 
1056     /**
1057      *  Expression3    = PrefixOp Expression3
1058      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1059      *                 | Primary {Selector} {PostfixOp}
1060      *
1061      *  {@literal
1062      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1063      *                 | Literal
1064      *                 | [TypeArguments] THIS [Arguments]
1065      *                 | [TypeArguments] SUPER SuperSuffix
1066      *                 | NEW [TypeArguments] Creator
1067      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1068      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1069      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1070      *                 | Expression3 MemberReferenceSuffix
1071      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1072      *                   | Arguments
1073      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1074      *                   ]
1075      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1076      *  }
1077      *
1078      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1079      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1080      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1081      *                 | BasicType
1082      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1083      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1084      *                 | &quot;.&quot; THIS
1085      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1086      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1087      *                 | &quot;[&quot; Expression &quot;]&quot;
1088      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1089      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1090      */
1091     protected JCExpression term3() {
1092         int pos = token.pos;
1093         JCExpression t;
1094         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1095         switch (token.kind) {
1096         case QUES:
1097             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1098                 selectTypeMode();
1099                 return typeArgument();
1100             } else
1101                 return illegal();
1102         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1103             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1104                 TokenKind tk = token.kind;
1105                 nextToken();
1106                 selectExprMode();
1107                 if (tk == SUB &amp;&amp;
1108                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1109                     token.radix() == 10) {
1110                     selectExprMode();
1111                     t = literal(names.hyphen, pos);
1112                 } else {
1113                     t = term3();
1114                     return F.at(pos).Unary(unoptag(tk), t);
1115                 }
1116             } else return illegal();
1117             break;
1118         case LPAREN:
1119             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1120                 ParensResult pres = analyzeParens();
1121                 switch (pres) {
1122                     case CAST:
1123                        accept(LPAREN);
1124                        selectTypeMode();
1125                        int pos1 = pos;
1126                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1127                        while (token.kind == AMP) {
1128                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1129                            accept(AMP);
1130                            targets = targets.prepend(parseType());
1131                        }
1132                        if (targets.length() &gt; 1) {
1133                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1134                        }
1135                        accept(RPAREN);
1136                        selectExprMode();
1137                        JCExpression t1 = term3();
1138                        return F.at(pos).TypeCast(t, t1);
1139                     case IMPLICIT_LAMBDA:
1140                     case EXPLICIT_LAMBDA:
1141                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1142                         break;
1143                     default: //PARENS
1144                         accept(LPAREN);
1145                         selectExprMode();
1146                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1147                         accept(RPAREN);
1148                         t = toP(F.at(pos).Parens(t));
1149                         break;
1150                 }
1151             } else {
1152                 return illegal();
1153             }
1154             break;
1155         case THIS:
1156             if ((mode &amp; EXPR) != 0) {
1157                 selectExprMode();
1158                 t = to(F.at(pos).Ident(names._this));
1159                 nextToken();
1160                 if (typeArgs == null)
1161                     t = argumentsOpt(null, t);
1162                 else
1163                     t = arguments(typeArgs, t);
1164                 typeArgs = null;
1165             } else return illegal();
1166             break;
1167         case SUPER:
1168             if ((mode &amp; EXPR) != 0) {
1169                 selectExprMode();
1170                 t = to(F.at(pos).Ident(names._super));
1171                 t = superSuffix(typeArgs, t);
1172                 typeArgs = null;
1173             } else return illegal();
1174             break;
1175         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1176         case CHARLITERAL: case STRINGLITERAL:
1177         case TRUE: case FALSE: case NULL:
1178             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1179                 selectExprMode();
1180                 t = literal(names.empty);
1181             } else return illegal();
1182             break;
1183         case NEW:
1184             if (typeArgs != null) return illegal();
1185             if ((mode &amp; EXPR) != 0) {
1186                 selectExprMode();
1187                 nextToken();
1188                 if (token.kind == LT) typeArgs = typeArguments(false);
1189                 t = creator(pos, typeArgs);
1190                 typeArgs = null;
1191             } else return illegal();
1192             break;
1193         case MONKEYS_AT:
1194             // Only annotated cast types and method references are valid
1195             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1196             if (typeAnnos.isEmpty()) {
1197                 // else there would be no &#39;@&#39;
1198                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1199             }
1200 
1201             JCExpression expr = term3();
1202 
1203             if ((mode &amp; TYPE) == 0) {
1204                 // Type annotations on class literals no longer legal
1205                 switch (expr.getTag()) {
1206                 case REFERENCE: {
1207                     JCMemberReference mref = (JCMemberReference) expr;
1208                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1209                     t = mref;
1210                     break;
1211                 }
1212                 case SELECT: {
1213                     JCFieldAccess sel = (JCFieldAccess) expr;
1214 
1215                     if (sel.name != names._class) {
1216                         return illegal();
1217                     } else {
1218                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1219                         return expr;
1220                     }
1221                 }
1222                 default:
1223                     return illegal(typeAnnos.head.pos);
1224                 }
1225 
1226             } else {
1227                 // Type annotations targeting a cast
1228                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1229             }
1230             break;
1231         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1232             if (typeArgs != null) return illegal();
1233             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1234                 t = lambdaExpressionOrStatement(false, false, pos);
1235             } else {
1236                 t = toP(F.at(token.pos).Ident(ident()));
1237                 loop: while (true) {
1238                     pos = token.pos;
1239                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1240 
1241                     // need to report an error later if LBRACKET is for array
1242                     // index access rather than array creation level
1243                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1244                         return illegal(annos.head.pos);
1245 
1246                     switch (token.kind) {
1247                     case LBRACKET:
1248                         nextToken();
1249                         if (token.kind == RBRACKET) {
1250                             nextToken();
1251                             t = bracketsOpt(t);
1252                             t = toP(F.at(pos).TypeArray(t));
1253                             if (annos.nonEmpty()) {
1254                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1255                             }
1256                             t = bracketsSuffix(t);
1257                         } else {
1258                             if ((mode &amp; EXPR) != 0) {
1259                                 selectExprMode();
1260                                 JCExpression t1 = term();
1261                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1262                                 t = to(F.at(pos).Indexed(t, t1));
1263                             }
1264                             accept(RBRACKET);
1265                         }
1266                         break loop;
1267                     case LPAREN:
1268                         if ((mode &amp; EXPR) != 0) {
1269                             selectExprMode();
1270                             t = arguments(typeArgs, t);
1271                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1272                             typeArgs = null;
1273                         }
1274                         break loop;
1275                     case DOT:
1276                         nextToken();
1277                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1278                             return illegal();
1279                         }
1280                         int oldmode = mode;
1281                         mode &amp;= ~NOPARAMS;
1282                         typeArgs = typeArgumentsOpt(EXPR);
1283                         mode = oldmode;
1284                         if ((mode &amp; EXPR) != 0) {
1285                             switch (token.kind) {
1286                             case CLASS:
1287                                 if (typeArgs != null) return illegal();
1288                                 selectExprMode();
1289                                 t = to(F.at(pos).Select(t, names._class));
1290                                 nextToken();
1291                                 break loop;
1292                             case THIS:
1293                                 if (typeArgs != null) return illegal();
1294                                 selectExprMode();
1295                                 t = to(F.at(pos).Select(t, names._this));
1296                                 nextToken();
1297                                 break loop;
1298                             case SUPER:
1299                                 selectExprMode();
1300                                 t = to(F.at(pos).Select(t, names._super));
1301                                 t = superSuffix(typeArgs, t);
1302                                 typeArgs = null;
1303                                 break loop;
1304                             case NEW:
1305                                 if (typeArgs != null) return illegal();
1306                                 selectExprMode();
1307                                 int pos1 = token.pos;
1308                                 nextToken();
1309                                 if (token.kind == LT) typeArgs = typeArguments(false);
1310                                 t = innerCreator(pos1, typeArgs, t);
1311                                 typeArgs = null;
1312                                 break loop;
1313                             }
1314                         }
1315 
1316                         List&lt;JCAnnotation&gt; tyannos = null;
1317                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1318                             tyannos = typeAnnotationsOpt();
1319                         }
1320                         // typeArgs saved for next loop iteration.
1321                         t = toP(F.at(pos).Select(t, ident()));
1322                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1323                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1324                         }
1325                         break;
1326                     case ELLIPSIS:
1327                         if (this.permitTypeAnnotationsPushBack) {
1328                             this.typeAnnotationsPushedBack = annos;
1329                         } else if (annos.nonEmpty()) {
1330                             // Don&#39;t return here -- error recovery attempt
1331                             illegal(annos.head.pos);
1332                         }
1333                         break loop;
1334                     case LT:
1335                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1336                             //this is an unbound method reference whose qualifier
1337                             //is a generic type i.e. A&lt;S&gt;::m
1338                             int pos1 = token.pos;
1339                             accept(LT);
1340                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1341                             args.append(typeArgument());
1342                             while (token.kind == COMMA) {
1343                                 nextToken();
1344                                 args.append(typeArgument());
1345                             }
1346                             accept(GT);
1347                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1348                             while (token.kind == DOT) {
1349                                 nextToken();
1350                                 selectTypeMode();
1351                                 t = toP(F.at(token.pos).Select(t, ident()));
1352                                 t = typeArgumentsOpt(t);
1353                             }
1354                             t = bracketsOpt(t);
1355                             if (token.kind != COLCOL) {
1356                                 //method reference expected here
1357                                 t = illegal();
1358                             }
1359                             selectExprMode();
1360                             return term3Rest(t, typeArgs);
1361                         }
1362                         break loop;
1363                     default:
1364                         break loop;
1365                     }
1366                 }
1367             }
1368             if (typeArgs != null) illegal();
1369             t = typeArgumentsOpt(t);
1370             break;
1371         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1372         case DOUBLE: case BOOLEAN:
1373             if (typeArgs != null) illegal();
1374             t = bracketsSuffix(bracketsOpt(basicType()));
1375             break;
1376         case VOID:
1377             if (typeArgs != null) illegal();
1378             if ((mode &amp; EXPR) != 0) {
1379                 nextToken();
1380                 if (token.kind == DOT) {
1381                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1382                     t = bracketsSuffix(ti);
1383                 } else {
1384                     return illegal(pos);
1385                 }
1386             } else {
1387                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1388                 // a void type (like other primitive types) to the next phase.
1389                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1390                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1391                 nextToken();
1392                 return ti;
1393                 //return illegal();
1394             }
1395             break;
1396         case SWITCH:
1397             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1398             allowYieldStatement = true;
1399             int switchPos = token.pos;
1400             nextToken();
1401             JCExpression selector = parExpression();
1402             accept(LBRACE);
1403             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1404             while (true) {
1405                 pos = token.pos;
1406                 switch (token.kind) {
1407                 case CASE:
1408                 case DEFAULT:
1409                     cases.appendList(switchExpressionStatementGroup());
1410                     break;
1411                 case RBRACE: case EOF:
1412                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1413                                                                                cases.toList()));
1414                     e.endpos = token.pos;
1415                     accept(RBRACE);
1416                     return e;
1417                 default:
1418                     nextToken(); // to ensure progress
1419                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1420                 }
1421             }
1422         default:
1423             return illegal();
1424         }
1425         return term3Rest(t, typeArgs);
1426     }
1427 
1428     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1429         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1430         int casePos = token.pos;
1431         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1432 
1433         if (token.kind == DEFAULT) {
1434             nextToken();
1435         } else {
1436             accept(CASE);
1437             while (true) {
1438                 pats.append(term(EXPR | NOLAMBDA));
1439                 if (token.kind != COMMA) break;
1440                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1441                 nextToken();
1442             };
1443         }
1444         List&lt;JCStatement&gt; stats = null;
1445         JCTree body = null;
1446         CaseTree.CaseKind kind;
1447         switch (token.kind) {
1448             case ARROW:
1449                 checkSourceLevel(Feature.SWITCH_RULE);
1450                 nextToken();
1451                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1452                     stats = List.of(parseStatement());
1453                     body = stats.head;
1454                     kind = JCCase.RULE;
1455                 } else {
1456                     JCExpression value = parseExpression();
1457                     stats = List.of(to(F.at(value).Yield(value)));
1458                     body = value;
1459                     kind = JCCase.RULE;
1460                     accept(SEMI);
1461                 }
1462                 break;
1463             default:
1464                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1465                 stats = blockStatements();
1466                 kind = JCCase.STATEMENT;
1467                 break;
1468         }
1469         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1470         return caseExprs.toList();
1471     }
1472 
1473     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1474         if (typeArgs != null) illegal();
1475         while (true) {
1476             int pos1 = token.pos;
1477             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1478 
1479             if (token.kind == LBRACKET) {
1480                 nextToken();
1481                 if ((mode &amp; TYPE) != 0) {
1482                     int oldmode = mode;
1483                     selectTypeMode();
1484                     if (token.kind == RBRACKET) {
1485                         nextToken();
1486                         t = bracketsOpt(t);
1487                         t = toP(F.at(pos1).TypeArray(t));
1488                         if (token.kind == COLCOL) {
1489                             selectExprMode();
1490                             continue;
1491                         }
1492                         if (annos.nonEmpty()) {
1493                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1494                         }
1495                         return t;
1496                     }
1497                     mode = oldmode;
1498                 }
1499                 if ((mode &amp; EXPR) != 0) {
1500                     selectExprMode();
1501                     JCExpression t1 = term();
1502                     t = to(F.at(pos1).Indexed(t, t1));
1503                 }
1504                 accept(RBRACKET);
1505             } else if (token.kind == DOT) {
1506                 nextToken();
1507                 typeArgs = typeArgumentsOpt(EXPR);
1508                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1509                     selectExprMode();
1510                     t = to(F.at(pos1).Select(t, names._super));
1511                     nextToken();
1512                     t = arguments(typeArgs, t);
1513                     typeArgs = null;
1514                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1515                     if (typeArgs != null) return illegal();
1516                     selectExprMode();
1517                     int pos2 = token.pos;
1518                     nextToken();
1519                     if (token.kind == LT) typeArgs = typeArguments(false);
1520                     t = innerCreator(pos2, typeArgs, t);
1521                     typeArgs = null;
1522                 } else {
1523                     List&lt;JCAnnotation&gt; tyannos = null;
1524                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1525                         // is the mode check needed?
1526                         tyannos = typeAnnotationsOpt();
1527                     }
1528                     t = toP(F.at(pos1).Select(t, ident(true)));
1529                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1530                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1531                     }
1532                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1533                     typeArgs = null;
1534                 }
1535             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1536                 selectExprMode();
1537                 if (typeArgs != null) return illegal();
1538                 accept(COLCOL);
1539                 t = memberReferenceSuffix(pos1, t);
1540             } else {
1541                 if (!annos.isEmpty()) {
1542                     if (permitTypeAnnotationsPushBack)
1543                         typeAnnotationsPushedBack = annos;
1544                     else
1545                         return illegal(annos.head.pos);
1546                 }
1547                 break;
1548             }
1549         }
1550         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1551             selectExprMode();
1552             t = to(F.at(token.pos).Unary(
1553                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1554             nextToken();
1555         }
1556         return toP(t);
1557     }
1558 
1559     /**
1560      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1561      * method reference or a binary expression. To disambiguate, look for a
1562      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1563      */
1564     @SuppressWarnings(&quot;fallthrough&quot;)
1565     boolean isUnboundMemberRef() {
1566         int pos = 0, depth = 0;
1567         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1568             switch (t.kind) {
1569                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1570                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1571                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1572                 case DOUBLE: case BOOLEAN: case CHAR:
1573                 case MONKEYS_AT:
1574                     break;
1575 
1576                 case LPAREN:
1577                     // skip annotation values
1578                     int nesting = 0;
1579                     for (; ; pos++) {
1580                         TokenKind tk2 = S.token(pos).kind;
1581                         switch (tk2) {
1582                             case EOF:
1583                                 return false;
1584                             case LPAREN:
1585                                 nesting++;
1586                                 break;
1587                             case RPAREN:
1588                                 nesting--;
1589                                 if (nesting == 0) {
1590                                     continue outer;
1591                                 }
1592                                 break;
1593                         }
1594                     }
1595 
1596                 case LT:
1597                     depth++; break;
1598                 case GTGTGT:
1599                     depth--;
1600                 case GTGT:
1601                     depth--;
1602                 case GT:
1603                     depth--;
1604                     if (depth == 0) {
1605                         TokenKind nextKind = S.token(pos + 1).kind;
1606                         return
1607                             nextKind == TokenKind.DOT ||
1608                             nextKind == TokenKind.LBRACKET ||
1609                             nextKind == TokenKind.COLCOL;
1610                     }
1611                     break;
1612                 default:
1613                     return false;
1614             }
1615         }
1616     }
1617 
1618     /**
1619      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1620      * method reference or a binary expression. To disambiguate, look for a
1621      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1622      */
1623     @SuppressWarnings(&quot;fallthrough&quot;)
1624     ParensResult analyzeParens() {
1625         int depth = 0;
1626         boolean type = false;
1627         ParensResult defaultResult = ParensResult.PARENS;
1628         outer: for (int lookahead = 0; ; lookahead++) {
1629             TokenKind tk = S.token(lookahead).kind;
1630             switch (tk) {
1631                 case COMMA:
1632                     type = true;
1633                 case EXTENDS: case SUPER: case DOT: case AMP:
1634                     //skip
1635                     break;
1636                 case QUES:
1637                     if (peekToken(lookahead, EXTENDS) ||
1638                             peekToken(lookahead, SUPER)) {
1639                         //wildcards
1640                         type = true;
1641                     }
1642                     break;
1643                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1644                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1645                     if (peekToken(lookahead, RPAREN)) {
1646                         //Type, &#39;)&#39; -&gt; cast
1647                         return ParensResult.CAST;
1648                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1649                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1650                         return ParensResult.EXPLICIT_LAMBDA;
1651                     }
1652                     break;
1653                 case LPAREN:
1654                     if (lookahead != 0) {
1655                         // &#39;(&#39; in a non-starting position -&gt; parens
1656                         return ParensResult.PARENS;
1657                     } else if (peekToken(lookahead, RPAREN)) {
1658                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1659                         return ParensResult.EXPLICIT_LAMBDA;
1660                     }
1661                     break;
1662                 case RPAREN:
1663                     // if we have seen something that looks like a type,
1664                     // then it&#39;s a cast expression
1665                     if (type) return ParensResult.CAST;
1666                     // otherwise, disambiguate cast vs. parenthesized expression
1667                     // based on subsequent token.
1668                     switch (S.token(lookahead + 1).kind) {
1669                         /*case PLUSPLUS: case SUBSUB: */
1670                         case BANG: case TILDE:
1671                         case LPAREN: case THIS: case SUPER:
1672                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1673                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1674                         case TRUE: case FALSE: case NULL:
1675                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1676                         case SWITCH:
1677                         case BYTE: case SHORT: case CHAR: case INT:
1678                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1679                             return ParensResult.CAST;
1680                         default:
1681                             return defaultResult;
1682                     }
1683                 case UNDERSCORE:
1684                 case ASSERT:
1685                 case ENUM:
1686                 case IDENTIFIER:
1687                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1688                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1689                         return ParensResult.EXPLICIT_LAMBDA;
1690                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1691                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1692                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1693                                                       : ParensResult.PARENS;
1694                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1695                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1696                     }
1697                     type = false;
1698                     break;
1699                 case FINAL:
1700                 case ELLIPSIS:
1701                     //those can only appear in explicit lambdas
1702                     return ParensResult.EXPLICIT_LAMBDA;
1703                 case MONKEYS_AT:
1704                     type = true;
1705                     lookahead += 1; //skip &#39;@&#39;
1706                     while (peekToken(lookahead, DOT)) {
1707                         lookahead += 2;
1708                     }
1709                     if (peekToken(lookahead, LPAREN)) {
1710                         lookahead++;
1711                         //skip annotation values
1712                         int nesting = 0;
1713                         for (; ; lookahead++) {
1714                             TokenKind tk2 = S.token(lookahead).kind;
1715                             switch (tk2) {
1716                                 case EOF:
1717                                     return ParensResult.PARENS;
1718                                 case LPAREN:
1719                                     nesting++;
1720                                     break;
1721                                 case RPAREN:
1722                                     nesting--;
1723                                     if (nesting == 0) {
1724                                         continue outer;
1725                                     }
1726                                 break;
1727                             }
1728                         }
1729                     }
1730                     break;
1731                 case LBRACKET:
1732                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1733                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1734                         return ParensResult.EXPLICIT_LAMBDA;
1735                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1736                             peekToken(lookahead, RBRACKET, AMP)) {
1737                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1738                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1739                         return ParensResult.CAST;
1740                     } else if (peekToken(lookahead, RBRACKET)) {
1741                         //consume the &#39;]&#39; and skip
1742                         type = true;
1743                         lookahead++;
1744                         break;
1745                     } else {
1746                         return ParensResult.PARENS;
1747                     }
1748                 case LT:
1749                     depth++; break;
1750                 case GTGTGT:
1751                     depth--;
1752                 case GTGT:
1753                     depth--;
1754                 case GT:
1755                     depth--;
1756                     if (depth == 0) {
1757                         if (peekToken(lookahead, RPAREN) ||
1758                                 peekToken(lookahead, AMP)) {
1759                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1760                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1761                             return ParensResult.CAST;
1762                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1763                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1764                                 peekToken(lookahead, ELLIPSIS)) {
1765                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1766                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1767                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1768                             return ParensResult.EXPLICIT_LAMBDA;
1769                         }
1770                         //it looks a type, but could still be (i) a cast to generic type,
1771                         //(ii) an unbound method reference or (iii) an explicit lambda
1772                         type = true;
1773                         break;
1774                     } else if (depth &lt; 0) {
1775                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1776                         return ParensResult.PARENS;
1777                     }
1778                     break;
1779                 default:
1780                     //this includes EOF
1781                     return defaultResult;
1782             }
1783         }
1784     }
1785 
1786     /** Accepts all identifier-like tokens */
1787     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1788 
1789     enum ParensResult {
1790         CAST,
1791         EXPLICIT_LAMBDA,
1792         IMPLICIT_LAMBDA,
1793         PARENS
1794     }
1795 
1796     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1797         List&lt;JCVariableDecl&gt; params = explicitParams ?
1798                 formalParameters(true, false) :
1799                 implicitParameters(hasParens);
1800         if (explicitParams) {
1801             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1802             for (JCVariableDecl param: params) {
1803                 Name restrictedTypeName;
1804                 if (param.vartype != null &amp;&amp;
1805                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1806                         param.vartype.hasTag(TYPEARRAY)) {
1807                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1808                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1809                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1810                 }
1811                 lambdaClassifier.addParameter(param);
1812                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1813                     break;
1814                 }
1815             }
1816             if (lambdaClassifier.diagFragment != null) {
1817                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1818             }
1819             for (JCVariableDecl param: params) {
1820                 if (param.vartype != null
1821                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1822                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1823                     param.startPos = TreeInfo.getStartPos(param.vartype);
1824                     param.vartype = null;
1825                 }
1826             }
1827         }
1828         return lambdaExpressionOrStatementRest(params, pos);
1829     }
1830 
1831     enum LambdaParameterKind {
1832         VAR(0),
1833         EXPLICIT(1),
1834         IMPLICIT(2),
1835         ERROR(-1);
1836 
1837         private final int index;
1838 
1839         LambdaParameterKind(int index) {
1840             this.index = index;
1841         }
1842     }
1843 
1844     private final static Fragment[][] decisionTable = new Fragment[][] {
1845         /*              VAR                              EXPLICIT                         IMPLICIT  */
1846         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1847         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1848         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1849     };
1850 
1851     class LambdaClassifier {
1852 
1853         LambdaParameterKind kind;
1854         Fragment diagFragment;
1855         List&lt;JCVariableDecl&gt; params;
1856 
1857         void addParameter(JCVariableDecl param) {
1858             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1859                 if (restrictedTypeName(param.vartype, false) != null) {
1860                     reduce(LambdaParameterKind.VAR);
1861                 } else {
1862                     reduce(LambdaParameterKind.EXPLICIT);
1863                 }
1864             }
1865             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1866                 param.vartype != null &amp;&amp; param.name == names.empty) {
1867                 reduce(LambdaParameterKind.IMPLICIT);
1868             }
1869         }
1870 
1871         private void reduce(LambdaParameterKind newKind) {
1872             if (kind == null) {
1873                 kind = newKind;
1874             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1875                 LambdaParameterKind currentKind = kind;
1876                 kind = LambdaParameterKind.ERROR;
1877                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1878                         newKind.index == LambdaParameterKind.VAR.index;
1879                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1880                         decisionTable[currentKind.index][newKind.index] : null;
1881             }
1882         }
1883 
1884         LambdaParameterKind result() {
1885             return kind;
1886         }
1887     }
1888 
1889     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1890         checkSourceLevel(Feature.LAMBDA);
1891         accept(ARROW);
1892 
1893         return token.kind == LBRACE ?
1894             lambdaStatement(args, pos, token.pos) :
1895             lambdaExpression(args, pos);
1896     }
1897 
1898     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1899         JCBlock block = block(pos2, 0);
1900         return toP(F.at(pos).Lambda(args, block));
1901     }
1902 
1903     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1904         JCTree expr = parseExpression();
1905         return toP(F.at(pos).Lambda(args, expr));
1906     }
1907 
1908     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1909      */
1910     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1911         nextToken();
1912         if (token.kind == LPAREN || typeArgs != null) {
1913             t = arguments(typeArgs, t);
1914         } else if (token.kind == COLCOL) {
1915             if (typeArgs != null) return illegal();
1916             t = memberReferenceSuffix(t);
1917         } else {
1918             int pos = token.pos;
1919             accept(DOT);
1920             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1921             t = toP(F.at(pos).Select(t, ident()));
1922             t = argumentsOpt(typeArgs, t);
1923         }
1924         return t;
1925     }
1926 
1927     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1928      */
1929     JCPrimitiveTypeTree basicType() {
1930         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1931         nextToken();
1932         return t;
1933     }
1934 
1935     /** ArgumentsOpt = [ Arguments ]
1936      */
1937     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1938         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1939             selectExprMode();
1940             return arguments(typeArgs, t);
1941         } else {
1942             return t;
1943         }
1944     }
1945 
1946     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1947      */
1948     List&lt;JCExpression&gt; arguments() {
1949         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1950         if (token.kind == LPAREN) {
1951             nextToken();
1952             if (token.kind != RPAREN) {
1953                 args.append(parseExpression());
1954                 while (token.kind == COMMA) {
1955                     nextToken();
1956                     args.append(parseExpression());
1957                 }
1958             }
1959             accept(RPAREN);
1960         } else {
1961             syntaxError(token.pos, Errors.Expected(LPAREN));
1962         }
1963         return args.toList();
1964     }
1965 
1966     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1967         int pos = token.pos;
1968         List&lt;JCExpression&gt; args = arguments();
1969         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
1970         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
1971                                                                     ((JCIdent) t).name)) {
1972             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
1973             mi = F.Erroneous(List.of(mi));
1974         }
1975         return toP(mi);
1976     }
1977 
1978     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
1979         if (name == names.yield) {
1980             if (allowYieldStatement) {
1981                 return true;
1982             } else {
1983                 log.warning(pos, Warnings.InvalidYield);
1984             }
1985         }
1986         return false;
1987     }
1988 
1989     /**  TypeArgumentsOpt = [ TypeArguments ]
1990      */
1991     JCExpression typeArgumentsOpt(JCExpression t) {
1992         if (token.kind == LT &amp;&amp;
1993             (mode &amp; TYPE) != 0 &amp;&amp;
1994             (mode &amp; NOPARAMS) == 0) {
1995             selectTypeMode();
1996             return typeArguments(t, false);
1997         } else {
1998             return t;
1999         }
2000     }
2001     List&lt;JCExpression&gt; typeArgumentsOpt() {
2002         return typeArgumentsOpt(TYPE);
2003     }
2004 
2005     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2006         if (token.kind == LT) {
2007             if ((mode &amp; useMode) == 0 ||
2008                 (mode &amp; NOPARAMS) != 0) {
2009                 illegal();
2010             }
2011             mode = useMode;
2012             return typeArguments(false);
2013         }
2014         return null;
2015     }
2016 
2017     /**
2018      *  {@literal
2019      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2020      *  }
2021      */
2022     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2023         if (token.kind == LT) {
2024             nextToken();
2025             if (token.kind == GT &amp;&amp; diamondAllowed) {
2026                 checkSourceLevel(Feature.DIAMOND);
2027                 mode |= DIAMOND;
2028                 nextToken();
2029                 return List.nil();
2030             } else {
2031                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2032                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2033                 while (token.kind == COMMA) {
2034                     nextToken();
2035                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2036                 }
2037                 switch (token.kind) {
2038 
2039                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2040                 case GTGTGT: case GTGT:
2041                     token = S.split();
2042                     break;
2043                 case GT:
2044                     nextToken();
2045                     break;
2046                 default:
2047                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2048                     break;
2049                 }
2050                 return args.toList();
2051             }
2052         } else {
2053             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2054         }
2055     }
2056 
2057     /**
2058      *  {@literal
2059      *  TypeArgument = Type
2060      *               | [Annotations] &quot;?&quot;
2061      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2062      *               | [Annotations] &quot;?&quot; SUPER Type
2063      *  }
2064      */
2065     JCExpression typeArgument() {
2066         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2067         if (token.kind != QUES) return parseType(false, annotations);
2068         int pos = token.pos;
2069         nextToken();
2070         JCExpression result;
2071         if (token.kind == EXTENDS) {
2072             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2073             nextToken();
2074             JCExpression bound = parseType();
2075             result = F.at(pos).Wildcard(t, bound);
2076         } else if (token.kind == SUPER) {
2077             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2078             nextToken();
2079             JCExpression bound = parseType();
2080             result = F.at(pos).Wildcard(t, bound);
2081         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2082             //error recovery
2083             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2084             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2085             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2086             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2087             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2088             result = err;
2089         } else {
2090             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2091             result = toP(F.at(pos).Wildcard(t, null));
2092         }
2093         if (!annotations.isEmpty()) {
2094             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2095         }
2096         return result;
2097     }
2098 
2099     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2100         int pos = token.pos;
2101         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2102         return toP(F.at(pos).TypeApply(t, args));
2103     }
2104 
2105     /**
2106      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2107      *
2108      * &lt;p&gt;
2109      *
2110      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2111      * the expression &lt;code&gt;t&lt;/code&gt;.
2112      */
2113     private JCExpression bracketsOpt(JCExpression t,
2114             List&lt;JCAnnotation&gt; annotations) {
2115         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2116 
2117         if (token.kind == LBRACKET) {
2118             int pos = token.pos;
2119             nextToken();
2120             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2121         } else if (!nextLevelAnnotations.isEmpty()) {
2122             if (permitTypeAnnotationsPushBack) {
2123                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2124             } else {
2125                 return illegal(nextLevelAnnotations.head.pos);
2126             }
2127         }
2128 
2129         if (!annotations.isEmpty()) {
2130             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2131         }
2132         return t;
2133     }
2134 
2135     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2136      */
2137     private JCExpression bracketsOpt(JCExpression t) {
2138         return bracketsOpt(t, List.nil());
2139     }
2140 
2141     private JCExpression bracketsOptCont(JCExpression t, int pos,
2142             List&lt;JCAnnotation&gt; annotations) {
2143         accept(RBRACKET);
2144         t = bracketsOpt(t);
2145         t = toP(F.at(pos).TypeArray(t));
2146         if (annotations.nonEmpty()) {
2147             t = toP(F.at(pos).AnnotatedType(annotations, t));
2148         }
2149         return t;
2150     }
2151 
2152     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2153      *  BracketsSuffixType =
2154      */
2155     JCExpression bracketsSuffix(JCExpression t) {
2156         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2157             selectExprMode();
2158             int pos = token.pos;
2159             nextToken();
2160             accept(CLASS);
2161             if (token.pos == endPosTable.errorEndPos) {
2162                 // error recovery
2163                 Name name;
2164                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2165                     name = token.name();
2166                     nextToken();
2167                 } else {
2168                     name = names.error;
2169                 }
2170                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2171             } else {
2172                 Tag tag = t.getTag();
2173                 // Type annotations are illegal on class literals. Annotated non array class literals
2174                 // are complained about directly in term3(), Here check for type annotations on dimensions
2175                 // taking care to handle some interior dimension(s) being annotated.
2176                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2177                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2178                 t = toP(F.at(pos).Select(t, names._class));
2179             }
2180         } else if ((mode &amp; TYPE) != 0) {
2181             if (token.kind != COLCOL) {
2182                 selectTypeMode();
2183             }
2184         } else if (token.kind != COLCOL) {
2185             syntaxError(token.pos, Errors.DotClassExpected);
2186         }
2187         return t;
2188     }
2189 
2190     /**
2191      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2192      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2193      */
2194     JCExpression memberReferenceSuffix(JCExpression t) {
2195         int pos1 = token.pos;
2196         accept(COLCOL);
2197         return memberReferenceSuffix(pos1, t);
2198     }
2199 
2200     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2201         checkSourceLevel(Feature.METHOD_REFERENCES);
2202         selectExprMode();
2203         List&lt;JCExpression&gt; typeArgs = null;
2204         if (token.kind == LT) {
2205             typeArgs = typeArguments(false);
2206         }
2207         Name refName;
2208         ReferenceMode refMode;
2209         if (token.kind == NEW) {
2210             refMode = ReferenceMode.NEW;
2211             refName = names.init;
2212             nextToken();
2213         } else {
2214             refMode = ReferenceMode.INVOKE;
2215             refName = ident();
2216         }
2217         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2218     }
2219 
2220     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2221      */
2222     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2223         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2224 
2225         switch (token.kind) {
2226         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2227         case DOUBLE: case BOOLEAN:
2228             if (typeArgs == null) {
2229                 if (newAnnotations.isEmpty()) {
2230                     return arrayCreatorRest(newpos, basicType());
2231                 } else {
2232                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2233                 }
2234             }
2235             break;
2236         default:
2237         }
2238         JCExpression t = qualident(true);
2239 
2240         int oldmode = mode;
2241         selectTypeMode();
2242         boolean diamondFound = false;
2243         int lastTypeargsPos = -1;
2244         if (token.kind == LT) {
2245             lastTypeargsPos = token.pos;
2246             t = typeArguments(t, true);
2247             diamondFound = (mode &amp; DIAMOND) != 0;
2248         }
2249         while (token.kind == DOT) {
2250             if (diamondFound) {
2251                 //cannot select after a diamond
2252                 illegal();
2253             }
2254             int pos = token.pos;
2255             nextToken();
2256             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2257             t = toP(F.at(pos).Select(t, ident()));
2258 
2259             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2260                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2261             }
2262 
2263             if (token.kind == LT) {
2264                 lastTypeargsPos = token.pos;
2265                 t = typeArguments(t, true);
2266                 diamondFound = (mode &amp; DIAMOND) != 0;
2267             }
2268         }
2269         mode = oldmode;
2270         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2271             // handle type annotations for non primitive arrays
2272             if (newAnnotations.nonEmpty()) {
2273                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2274             }
2275 
2276             JCExpression e = arrayCreatorRest(newpos, t);
2277             if (diamondFound) {
2278                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2279                 return toP(F.at(newpos).Erroneous(List.of(e)));
2280             }
2281             else if (typeArgs != null) {
2282                 int pos = newpos;
2283                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2284                     // note: this should always happen but we should
2285                     // not rely on this as the parser is continuously
2286                     // modified to improve error recovery.
2287                     pos = typeArgs.head.pos;
2288                 }
2289                 setErrorEndPos(S.prevToken().endPos);
2290                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2291                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2292                 return toP(err);
2293             }
2294             return e;
2295         } else if (token.kind == LPAREN) {
2296             // handle type annotations for instantiations and anonymous classes
2297             if (newAnnotations.nonEmpty()) {
2298                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2299             }
2300             return classCreatorRest(newpos, null, typeArgs, t);
2301         } else {
2302             setErrorEndPos(token.pos);
2303             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2304             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2305             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2306         }
2307     }
2308 
2309     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2310      */
2311     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2312         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2313 
2314         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2315 
2316         if (newAnnotations.nonEmpty()) {
2317             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2318         }
2319 
2320         if (token.kind == LT) {
2321             int oldmode = mode;
2322             t = typeArguments(t, true);
2323             mode = oldmode;
2324         }
2325         return classCreatorRest(newpos, encl, typeArgs, t);
2326     }
2327 
2328     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2329      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2330      */
2331     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2332         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2333 
2334         accept(LBRACKET);
2335         if (token.kind == RBRACKET) {
2336             accept(RBRACKET);
2337             elemtype = bracketsOpt(elemtype, annos);
2338             if (token.kind == LBRACE) {
2339                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2340                 if (annos.nonEmpty()) {
2341                     // when an array initializer is present then
2342                     // the parsed annotations should target the
2343                     // new array tree
2344                     // bracketsOpt inserts the annotation in
2345                     // elemtype, and it needs to be corrected
2346                     //
2347                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2348                     assert annotated.annotations == annos;
2349                     na.annotations = annotated.annotations;
2350                     na.elemtype = annotated.underlyingType;
2351                 }
2352                 return na;
2353             } else {
2354                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2355                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2356             }
2357         } else {
2358             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2359 
2360             // maintain array dimension type annotations
2361             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2362             dimAnnotations.append(annos);
2363 
2364             dims.append(parseExpression());
2365             accept(RBRACKET);
2366             while (token.kind == LBRACKET
2367                     || token.kind == MONKEYS_AT) {
2368                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2369                 int pos = token.pos;
2370                 nextToken();
2371                 if (token.kind == RBRACKET) {
2372                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2373                 } else {
2374                     if (token.kind == RBRACKET) { // no dimension
2375                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2376                     } else {
2377                         dimAnnotations.append(maybeDimAnnos);
2378                         dims.append(parseExpression());
2379                         accept(RBRACKET);
2380                     }
2381                 }
2382             }
2383 
2384             List&lt;JCExpression&gt; elems = null;
2385             int errpos = token.pos;
2386 
2387             if (token.kind == LBRACE) {
2388                 elems = arrayInitializerElements(newpos, elemtype);
2389             }
2390 
2391             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2392             na.dimAnnotations = dimAnnotations.toList();
2393 
2394             if (elems != null) {
2395                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2396             }
2397 
2398             return na;
2399         }
2400     }
2401 
2402     /** ClassCreatorRest = Arguments [ClassBody]
2403      */
2404     JCNewClass classCreatorRest(int newpos,
2405                                   JCExpression encl,
2406                                   List&lt;JCExpression&gt; typeArgs,
2407                                   JCExpression t)
2408     {
2409         List&lt;JCExpression&gt; args = arguments();
2410         JCClassDecl body = null;
2411         if (token.kind == LBRACE) {
2412             int pos = token.pos;
2413             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2414             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2415             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2416         }
2417         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2418     }
2419 
2420     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2421      */
2422     JCExpression arrayInitializer(int newpos, JCExpression t) {
2423         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2424         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2425     }
2426 
2427     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2428         accept(LBRACE);
2429         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2430         if (token.kind == COMMA) {
2431             nextToken();
2432         } else if (token.kind != RBRACE) {
2433             elems.append(variableInitializer());
2434             while (token.kind == COMMA) {
2435                 nextToken();
2436                 if (token.kind == RBRACE) break;
2437                 elems.append(variableInitializer());
2438             }
2439         }
2440         accept(RBRACE);
2441         return elems.toList();
2442     }
2443 
2444     /** VariableInitializer = ArrayInitializer | Expression
2445      */
2446     public JCExpression variableInitializer() {
2447         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2448     }
2449 
2450     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2451      */
2452     JCExpression parExpression() {
2453         int pos = token.pos;
2454         accept(LPAREN);
2455         JCExpression t = parseExpression();
2456         accept(RPAREN);
2457         return toP(F.at(pos).Parens(t));
2458     }
2459 
2460     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2461      */
2462     JCBlock block(int pos, long flags) {
2463         accept(LBRACE);
2464         List&lt;JCStatement&gt; stats = blockStatements();
2465         JCBlock t = F.at(pos).Block(flags, stats);
2466         while (token.kind == CASE || token.kind == DEFAULT) {
2467             syntaxError(token.pos, Errors.Orphaned(token.kind));
2468             switchBlockStatementGroups();
2469         }
2470         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2471         // usually but not necessarily the last char of the last token.
2472         t.endpos = token.pos;
2473         accept(RBRACE);
2474         return toP(t);
2475     }
2476 
2477     public JCBlock block() {
2478         return block(token.pos, 0);
2479     }
2480 
2481     /** BlockStatements = { BlockStatement }
2482      *  BlockStatement  = LocalVariableDeclarationStatement
2483      *                  | ClassOrInterfaceOrEnumDeclaration
2484      *                  | [Ident &quot;:&quot;] Statement
2485      *  LocalVariableDeclarationStatement
2486      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2487      */
2488     @SuppressWarnings(&quot;fallthrough&quot;)
2489     List&lt;JCStatement&gt; blockStatements() {
2490         //todo: skip to anchor on error(?)
2491         int lastErrPos = -1;
2492         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2493         while (true) {
2494             List&lt;JCStatement&gt; stat = blockStatement();
2495             if (stat.isEmpty()) {
2496                 return stats.toList();
2497             } else {
2498                 // error recovery
2499                 if (token.pos == lastErrPos)
2500                     return stats.toList();
2501                 if (token.pos &lt;= endPosTable.errorEndPos) {
2502                     skip(false, true, true, true);
2503                     lastErrPos = token.pos;
2504                 }
2505                 stats.addAll(stat);
2506             }
2507         }
2508     }
2509 
2510     /*
2511      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2512      * this method will also recognize variable and class declarations (which are
2513      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2514      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2515      * and an error will be produced by this method.
2516      */
2517     JCStatement parseStatementAsBlock() {
2518         int pos = token.pos;
2519         List&lt;JCStatement&gt; stats = blockStatement();
2520         if (stats.isEmpty()) {
2521             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2522             return toP(F.at(pos).Exec(e));
2523         } else {
2524             JCStatement first = stats.head;
2525             Error error = null;
2526             switch (first.getTag()) {
2527             case CLASSDEF:
2528                 error = Errors.ClassNotAllowed;
2529                 break;
2530             case VARDEF:
2531                 error = Errors.VariableNotAllowed;
2532                 break;
2533             }
2534             if (error != null) {
2535                 log.error(DiagnosticFlag.SYNTAX, first, error);
2536                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2537                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2538             }
2539             return first;
2540         }
2541     }
2542 
2543     /**This method parses a statement appearing inside a block.
2544      */
2545     @SuppressWarnings(&quot;fallthrough&quot;)
2546     List&lt;JCStatement&gt; blockStatement() {
2547         //todo: skip to anchor on error(?)
2548         Comment dc;
2549         int pos = token.pos;
2550         switch (token.kind) {
2551         case RBRACE: case CASE: case DEFAULT: case EOF:
2552             return List.nil();
2553         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2554         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2555         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2556         case ASSERT:
2557             return List.of(parseSimpleStatement());
2558         case MONKEYS_AT:
2559         case FINAL: {
2560             dc = token.comment(CommentStyle.JAVADOC);
2561             JCModifiers mods = modifiersOpt();
2562             if (token.kind == INTERFACE ||
2563                 token.kind == CLASS ||
2564                 token.kind == ENUM ||
2565                 isRecordStart()) {
2566                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2567             } else {
2568                 JCExpression t = parseType(true);
2569                 return localVariableDeclarations(mods, t);
2570             }
2571         }
2572         case ABSTRACT: case STRICTFP: {
2573             dc = token.comment(CommentStyle.JAVADOC);
2574             JCModifiers mods = modifiersOpt();
2575             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2576         }
2577         case INTERFACE:
2578         case CLASS:
2579             dc = token.comment(CommentStyle.JAVADOC);
2580             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2581         case ENUM:
2582             if (!allowRecords) {
2583                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2584             }
2585             dc = token.comment(CommentStyle.JAVADOC);
2586             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2587         case IDENTIFIER:
2588             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2589                 Token next = S.token(1);
2590                 boolean isYieldStatement;
2591                 switch (next.kind) {
2592                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2593                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2594                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2595                     case NEW: case SWITCH: case THIS: case SUPER:
2596                         isYieldStatement = true;
2597                         break;
2598                     case PLUSPLUS: case SUBSUB:
2599                         isYieldStatement = S.token(2).kind != SEMI;
2600                         break;
2601                     case LPAREN:
2602                         int lookahead = 2;
2603                         int balance = 1;
2604                         boolean hasComma = false;
2605                         Token l;
2606                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2607                             switch (l.kind) {
2608                                 case LPAREN: balance++; break;
2609                                 case RPAREN: balance--; break;
2610                                 case COMMA: if (balance == 1) hasComma = true; break;
2611                             }
2612                             lookahead++;
2613                         }
2614                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2615                         break;
2616                     case SEMI: //error recovery - this is not a valid statement:
2617                         isYieldStatement = true;
2618                         break;
2619                     default:
2620                         isYieldStatement = false;
2621                         break;
2622                 }
2623 
2624                 if (isYieldStatement) {
2625                     nextToken();
2626                     JCExpression t = term(EXPR);
2627                     accept(SEMI);
2628                     return List.of(toP(F.at(pos).Yield(t)));
2629                 }
2630 
2631                 //else intentional fall-through
<a name="3" id="anc3"></a><span class="line-added">2632             } else {</span>
<span class="line-added">2633                 if (isNonSealedClassStart(true)) {</span>
<span class="line-added">2634                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2635                     nextToken();</span>
<span class="line-added">2636                     nextToken();</span>
<span class="line-added">2637                     nextToken();</span>
<span class="line-added">2638                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2639                 } else if (isSealedClassStart(true)) {</span>
<span class="line-added">2640                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">2641                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2642                     nextToken();</span>
<span class="line-added">2643                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2644                 }</span>
2645             }
2646         }
2647         if (isRecordStart() &amp;&amp; allowRecords) {
2648             dc = token.comment(CommentStyle.JAVADOC);
2649             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2650         } else {
2651             Token prevToken = token;
2652             JCExpression t = term(EXPR | TYPE);
2653             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2654                 nextToken();
2655                 JCStatement stat = parseStatementAsBlock();
2656                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2657             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2658                 pos = token.pos;
2659                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2660                 F.at(pos);
2661                 return localVariableDeclarations(mods, t);
2662             } else {
2663                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2664                 t = checkExprStat(t);
2665                 accept(SEMI);
2666                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2667                 return List.of(expr);
2668             }
2669         }
2670     }
2671     //where
2672         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2673             ListBuffer&lt;JCStatement&gt; stats =
2674                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2675             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2676             accept(SEMI);
2677             storeEnd(stats.last(), S.prevToken().endPos);
2678             return stats.toList();
2679         }
2680 
2681     /** Statement =
2682      *       Block
2683      *     | IF ParExpression Statement [ELSE Statement]
2684      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2685      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2686      *     | WHILE ParExpression Statement
2687      *     | DO Statement WHILE ParExpression &quot;;&quot;
2688      *     | TRY Block ( Catches | [Catches] FinallyPart )
2689      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2690      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2691      *     | SYNCHRONIZED ParExpression Block
2692      *     | RETURN [Expression] &quot;;&quot;
2693      *     | THROW Expression &quot;;&quot;
2694      *     | BREAK [Ident] &quot;;&quot;
2695      *     | CONTINUE [Ident] &quot;;&quot;
2696      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2697      *     | &quot;;&quot;
2698      */
2699     public JCStatement parseSimpleStatement() {
2700         int pos = token.pos;
2701         switch (token.kind) {
2702         case LBRACE:
2703             return block();
2704         case IF: {
2705             nextToken();
2706             JCExpression cond = parExpression();
2707             JCStatement thenpart = parseStatementAsBlock();
2708             JCStatement elsepart = null;
2709             if (token.kind == ELSE) {
2710                 nextToken();
2711                 elsepart = parseStatementAsBlock();
2712             }
2713             return F.at(pos).If(cond, thenpart, elsepart);
2714         }
2715         case FOR: {
2716             nextToken();
2717             accept(LPAREN);
2718             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2719             if (inits.length() == 1 &amp;&amp;
2720                 inits.head.hasTag(VARDEF) &amp;&amp;
2721                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2722                 token.kind == COLON) {
2723                 JCVariableDecl var = (JCVariableDecl)inits.head;
2724                 accept(COLON);
2725                 JCExpression expr = parseExpression();
2726                 accept(RPAREN);
2727                 JCStatement body = parseStatementAsBlock();
2728                 return F.at(pos).ForeachLoop(var, expr, body);
2729             } else {
2730                 accept(SEMI);
2731                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2732                 accept(SEMI);
2733                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2734                 accept(RPAREN);
2735                 JCStatement body = parseStatementAsBlock();
2736                 return F.at(pos).ForLoop(inits, cond, steps, body);
2737             }
2738         }
2739         case WHILE: {
2740             nextToken();
2741             JCExpression cond = parExpression();
2742             JCStatement body = parseStatementAsBlock();
2743             return F.at(pos).WhileLoop(cond, body);
2744         }
2745         case DO: {
2746             nextToken();
2747             JCStatement body = parseStatementAsBlock();
2748             accept(WHILE);
2749             JCExpression cond = parExpression();
2750             accept(SEMI);
2751             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2752             return t;
2753         }
2754         case TRY: {
2755             nextToken();
2756             List&lt;JCTree&gt; resources = List.nil();
2757             if (token.kind == LPAREN) {
2758                 nextToken();
2759                 resources = resources();
2760                 accept(RPAREN);
2761             }
2762             JCBlock body = block();
2763             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2764             JCBlock finalizer = null;
2765             if (token.kind == CATCH || token.kind == FINALLY) {
2766                 while (token.kind == CATCH) catchers.append(catchClause());
2767                 if (token.kind == FINALLY) {
2768                     nextToken();
2769                     finalizer = block();
2770                 }
2771             } else {
2772                 if (resources.isEmpty()) {
2773                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2774                 }
2775             }
2776             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2777         }
2778         case SWITCH: {
2779             nextToken();
2780             JCExpression selector = parExpression();
2781             accept(LBRACE);
2782             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2783             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2784             accept(RBRACE);
2785             return t;
2786         }
2787         case SYNCHRONIZED: {
2788             nextToken();
2789             JCExpression lock = parExpression();
2790             JCBlock body = block();
2791             return F.at(pos).Synchronized(lock, body);
2792         }
2793         case RETURN: {
2794             nextToken();
2795             JCExpression result = token.kind == SEMI ? null : parseExpression();
2796             accept(SEMI);
2797             JCReturn t = toP(F.at(pos).Return(result));
2798             return t;
2799         }
2800         case THROW: {
2801             nextToken();
2802             JCExpression exc = parseExpression();
2803             accept(SEMI);
2804             JCThrow t = toP(F.at(pos).Throw(exc));
2805             return t;
2806         }
2807         case BREAK: {
2808             nextToken();
2809             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2810             accept(SEMI);
2811             JCBreak t = toP(F.at(pos).Break(label));
2812             return t;
2813         }
2814         case CONTINUE: {
2815             nextToken();
2816             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2817             accept(SEMI);
2818             JCContinue t =  toP(F.at(pos).Continue(label));
2819             return t;
2820         }
2821         case SEMI:
2822             nextToken();
2823             return toP(F.at(pos).Skip());
2824         case ELSE:
2825             int elsePos = token.pos;
2826             nextToken();
2827             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2828         case FINALLY:
2829             int finallyPos = token.pos;
2830             nextToken();
2831             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2832         case CATCH:
2833             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2834         case ASSERT: {
2835             nextToken();
2836             JCExpression assertion = parseExpression();
2837             JCExpression message = null;
2838             if (token.kind == COLON) {
2839                 nextToken();
2840                 message = parseExpression();
2841             }
2842             accept(SEMI);
2843             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2844             return t;
2845         }
2846         default:
2847             Assert.error();
2848             return null;
2849         }
2850     }
2851 
2852     @Override
2853     public JCStatement parseStatement() {
2854         return parseStatementAsBlock();
2855     }
2856 
2857     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2858         int errPos = S.errPos();
2859         JCTree stm = action.doRecover(this);
2860         S.errPos(errPos);
2861         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2862     }
2863 
2864     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2865      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2866      */
2867     protected JCCatch catchClause() {
2868         int pos = token.pos;
2869         accept(CATCH);
2870         accept(LPAREN);
2871         JCModifiers mods = optFinal(Flags.PARAMETER);
2872         List&lt;JCExpression&gt; catchTypes = catchTypes();
2873         JCExpression paramType = catchTypes.size() &gt; 1 ?
2874                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2875                 catchTypes.head;
2876         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2877         accept(RPAREN);
2878         JCBlock body = block();
2879         return F.at(pos).Catch(formal, body);
2880     }
2881 
2882     List&lt;JCExpression&gt; catchTypes() {
2883         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2884         catchTypes.add(parseType());
2885         while (token.kind == BAR) {
2886             nextToken();
2887             // Instead of qualident this is now parseType.
2888             // But would that allow too much, e.g. arrays or generics?
2889             catchTypes.add(parseType());
2890         }
2891         return catchTypes.toList();
2892     }
2893 
2894     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2895      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2896      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2897      */
2898     List&lt;JCCase&gt; switchBlockStatementGroups() {
2899         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2900         while (true) {
2901             int pos = token.pos;
2902             switch (token.kind) {
2903             case CASE:
2904             case DEFAULT:
2905                 cases.appendList(switchBlockStatementGroup());
2906                 break;
2907             case RBRACE: case EOF:
2908                 return cases.toList();
2909             default:
2910                 nextToken(); // to ensure progress
2911                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2912             }
2913         }
2914     }
2915 
2916     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2917         int pos = token.pos;
2918         List&lt;JCStatement&gt; stats;
2919         JCCase c;
2920         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2921         switch (token.kind) {
2922         case CASE: {
2923             nextToken();
2924             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2925             while (true) {
2926                 pats.append(term(EXPR | NOLAMBDA));
2927                 if (token.kind != COMMA) break;
2928                 nextToken();
2929                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2930             };
2931             CaseTree.CaseKind caseKind;
2932             JCTree body = null;
2933             if (token.kind == ARROW) {
2934                 checkSourceLevel(Feature.SWITCH_RULE);
2935                 accept(ARROW);
2936                 caseKind = JCCase.RULE;
2937                 JCStatement statement = parseStatementAsBlock();
2938                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2939                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2940                 }
2941                 stats = List.of(statement);
2942                 body = stats.head;
2943             } else {
2944                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2945                 caseKind = JCCase.STATEMENT;
2946                 stats = blockStatements();
2947             }
2948             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2949             if (stats.isEmpty())
2950                 storeEnd(c, S.prevToken().endPos);
2951             return cases.append(c).toList();
2952         }
2953         case DEFAULT: {
2954             nextToken();
2955             CaseTree.CaseKind caseKind;
2956             JCTree body = null;
2957             if (token.kind == ARROW) {
2958                 checkSourceLevel(Feature.SWITCH_RULE);
2959                 accept(ARROW);
2960                 caseKind = JCCase.RULE;
2961                 JCStatement statement = parseStatementAsBlock();
2962                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2963                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2964                 }
2965                 stats = List.of(statement);
2966                 body = stats.head;
2967             } else {
2968                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2969                 caseKind = JCCase.STATEMENT;
2970                 stats = blockStatements();
2971             }
2972             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2973             if (stats.isEmpty())
2974                 storeEnd(c, S.prevToken().endPos);
2975             return cases.append(c).toList();
2976         }
2977         }
2978         throw new AssertionError(&quot;should not reach here&quot;);
2979     }
2980 
2981     /** MoreStatementExpressions = { COMMA StatementExpression }
2982      */
2983     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
2984                                                                     JCExpression first,
2985                                                                     T stats) {
2986         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2987         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
2988         while (token.kind == COMMA) {
2989             nextToken();
2990             pos = token.pos;
2991             JCExpression t = parseExpression();
2992             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2993             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
2994         }
2995         return stats;
2996     }
2997 
2998     /** ForInit = StatementExpression MoreStatementExpressions
2999      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3000      */
3001     List&lt;JCStatement&gt; forInit() {
3002         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3003         int pos = token.pos;
3004         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3005             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3006         } else {
3007             JCExpression t = term(EXPR | TYPE);
3008             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3009                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3010             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3011                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3012                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3013             } else {
3014                 return moreStatementExpressions(pos, t, stats).toList();
3015             }
3016         }
3017     }
3018 
3019     /** ForUpdate = StatementExpression MoreStatementExpressions
3020      */
3021     List&lt;JCExpressionStatement&gt; forUpdate() {
3022         return moreStatementExpressions(token.pos,
3023                                         parseExpression(),
3024                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3025     }
3026 
3027     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3028      *
3029      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3030      */
3031     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3032         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3033         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3034         int prevmode = mode;
3035         while (token.kind == MONKEYS_AT) {
3036             int pos = token.pos;
3037             nextToken();
3038             buf.append(annotation(pos, kind));
3039         }
3040         lastmode = mode;
3041         mode = prevmode;
3042         List&lt;JCAnnotation&gt; annotations = buf.toList();
3043 
3044         return annotations;
3045     }
3046 
3047     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3048         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3049         return annotations;
3050     }
3051 
3052     /** ModifiersOpt = { Modifier }
3053      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3054      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3055      *           | &quot;@&quot; Annotation
3056      */
3057     protected JCModifiers modifiersOpt() {
3058         return modifiersOpt(null);
3059     }
3060     protected JCModifiers modifiersOpt(JCModifiers partial) {
3061         long flags;
3062         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3063         int pos;
3064         if (partial == null) {
3065             flags = 0;
3066             pos = token.pos;
3067         } else {
3068             flags = partial.flags;
3069             annotations.appendList(partial.annotations);
3070             pos = partial.pos;
3071         }
3072         if (token.deprecatedFlag()) {
3073             flags |= Flags.DEPRECATED;
3074         }
3075         int lastPos;
3076     loop:
3077         while (true) {
3078             long flag;
3079             switch (token.kind) {
3080             case PRIVATE     : flag = Flags.PRIVATE; break;
3081             case PROTECTED   : flag = Flags.PROTECTED; break;
3082             case PUBLIC      : flag = Flags.PUBLIC; break;
3083             case STATIC      : flag = Flags.STATIC; break;
3084             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3085             case FINAL       : flag = Flags.FINAL; break;
3086             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3087             case NATIVE      : flag = Flags.NATIVE; break;
3088             case VOLATILE    : flag = Flags.VOLATILE; break;
3089             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3090             case STRICTFP    : flag = Flags.STRICTFP; break;
3091             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3092             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3093             case ERROR       : flag = 0; nextToken(); break;
<a name="4" id="anc4"></a><span class="line-added">3094             case IDENTIFIER  : {</span>
<span class="line-added">3095                 if (isNonSealedClassStart(false)) {</span>
<span class="line-added">3096                     flag = Flags.NON_SEALED;</span>
<span class="line-added">3097                     nextToken();</span>
<span class="line-added">3098                     nextToken();</span>
<span class="line-added">3099                     break;</span>
<span class="line-added">3100                 }</span>
<span class="line-added">3101                 if (isSealedClassStart(false)) {</span>
<span class="line-added">3102                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3103                     flag = Flags.SEALED;</span>
<span class="line-added">3104                     break;</span>
<span class="line-added">3105                 }</span>
<span class="line-added">3106                 break loop;</span>
<span class="line-added">3107             }</span>
3108             default: break loop;
3109             }
3110             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3111             lastPos = token.pos;
3112             nextToken();
3113             if (flag == Flags.ANNOTATION) {
3114                 if (token.kind != INTERFACE) {
3115                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3116                     // if first modifier is an annotation, set pos to annotation&#39;s.
3117                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3118                         pos = ann.pos;
3119                     annotations.append(ann);
3120                     flag = 0;
3121                 }
3122             }
3123             flags |= flag;
3124         }
3125         switch (token.kind) {
3126         case ENUM: flags |= Flags.ENUM; break;
3127         case INTERFACE: flags |= Flags.INTERFACE; break;
3128         default: break;
3129         }
3130 
3131         /* A modifiers tree with no modifier tokens or annotations
3132          * has no text position. */
3133         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3134             pos = Position.NOPOS;
3135 
3136         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3137         if (pos != Position.NOPOS)
3138             storeEnd(mods, S.prevToken().endPos);
3139         return mods;
3140     }
3141 
3142     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3143      *
3144      * @param pos position of &quot;@&quot; token
3145      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3146      */
3147     JCAnnotation annotation(int pos, Tag kind) {
3148         // accept(AT); // AT consumed by caller
3149         if (kind == Tag.TYPE_ANNOTATION) {
3150             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3151         }
3152         JCTree ident = qualident(false);
3153         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3154         JCAnnotation ann;
3155         if (kind == Tag.ANNOTATION) {
3156             ann = F.at(pos).Annotation(ident, fieldValues);
3157         } else if (kind == Tag.TYPE_ANNOTATION) {
3158             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3159         } else {
3160             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3161         }
3162 
3163         storeEnd(ann, S.prevToken().endPos);
3164         return ann;
3165     }
3166 
3167     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3168         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3169     }
3170 
3171     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3172     List&lt;JCExpression&gt; annotationFieldValues() {
3173         accept(LPAREN);
3174         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3175         if (token.kind != RPAREN) {
3176             buf.append(annotationFieldValue());
3177             while (token.kind == COMMA) {
3178                 nextToken();
3179                 buf.append(annotationFieldValue());
3180             }
3181         }
3182         accept(RPAREN);
3183         return buf.toList();
3184     }
3185 
3186     /** AnnotationFieldValue    = AnnotationValue
3187      *                          | Identifier &quot;=&quot; AnnotationValue
3188      */
3189     JCExpression annotationFieldValue() {
3190         if (LAX_IDENTIFIER.accepts(token.kind)) {
3191             selectExprMode();
3192             JCExpression t1 = term1();
3193             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3194                 int pos = token.pos;
3195                 accept(EQ);
3196                 JCExpression v = annotationValue();
3197                 return toP(F.at(pos).Assign(t1, v));
3198             } else {
3199                 return t1;
3200             }
3201         }
3202         return annotationValue();
3203     }
3204 
3205     /* AnnotationValue          = ConditionalExpression
3206      *                          | Annotation
3207      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3208      */
3209     JCExpression annotationValue() {
3210         int pos;
3211         switch (token.kind) {
3212         case MONKEYS_AT:
3213             pos = token.pos;
3214             nextToken();
3215             return annotation(pos, Tag.ANNOTATION);
3216         case LBRACE:
3217             pos = token.pos;
3218             accept(LBRACE);
3219             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3220             if (token.kind == COMMA) {
3221                 nextToken();
3222             } else if (token.kind != RBRACE) {
3223                 buf.append(annotationValue());
3224                 while (token.kind == COMMA) {
3225                     nextToken();
3226                     if (token.kind == RBRACE) break;
3227                     buf.append(annotationValue());
3228                 }
3229             }
3230             accept(RBRACE);
3231             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3232         default:
3233             selectExprMode();
3234             return term1();
3235         }
3236     }
3237 
3238     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3239      */
3240     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3241                                                                          JCExpression type,
3242                                                                          T vdefs,
3243                                                                          boolean localDecl)
3244     {
3245         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3246     }
3247 
3248     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3249      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3250      *
3251      *  @param reqInit  Is an initializer always required?
3252      *  @param dc       The documentation comment for the variable declarations, or null.
3253      */
3254     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3255                                                                      JCModifiers mods,
3256                                                                      JCExpression type,
3257                                                                      Name name,
3258                                                                      boolean reqInit,
3259                                                                      Comment dc,
3260                                                                      T vdefs,
3261                                                                      boolean localDecl)
3262     {
3263         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3264         vdefs.append(head);
3265         while (token.kind == COMMA) {
3266             // All but last of multiple declarators subsume a comma
3267             storeEnd((JCTree)vdefs.last(), token.endPos);
3268             nextToken();
3269             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3270         }
3271         return vdefs;
3272     }
3273 
3274     /** VariableDeclarator = Ident VariableDeclaratorRest
3275      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3276      */
3277     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3278         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3279     }
3280 
3281     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3282      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3283      *
3284      *  @param reqInit  Is an initializer always required?
3285      *  @param dc       The documentation comment for the variable declarations, or null.
3286      */
3287     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3288                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3289         type = bracketsOpt(type);
3290         JCExpression init = null;
3291         if (token.kind == EQ) {
3292             nextToken();
3293             init = variableInitializer();
3294         }
3295         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3296         JCTree elemType = TreeInfo.innermostType(type, true);
3297         int startPos = Position.NOPOS;
3298         if (elemType.hasTag(IDENT)) {
3299             Name typeName = ((JCIdent)elemType).name;
3300             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3301                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3302                     //error - &#39;var&#39; and arrays
3303                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3304                 } else {
3305                     if(compound)
3306                         //error - &#39;var&#39; in compound local var decl
3307                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3308                     startPos = TreeInfo.getStartPos(mods);
3309                     if (startPos == Position.NOPOS)
3310                         startPos = TreeInfo.getStartPos(type);
3311                     //implicit type
3312                     type = null;
3313                 }
3314             }
3315         }
3316         JCVariableDecl result =
3317             toP(F.at(pos).VarDef(mods, name, type, init));
3318         attach(result, dc);
3319         result.startPos = startPos;
3320         return result;
3321     }
3322 
3323     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3324         switch (e.getTag()) {
3325             case IDENT:
3326                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3327             case TYPEARRAY:
3328                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3329             default:
3330                 return null;
3331         }
3332     }
3333 
3334     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3335         if (name == names.var) {
3336             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3337                 return Source.JDK10;
3338             } else if (shouldWarn) {
3339                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3340             }
3341         }
3342         if (name == names.yield) {
3343             if (allowYieldStatement) {
3344                 return Source.JDK14;
3345             } else if (shouldWarn) {
3346                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3347             }
3348         }
3349         if (name == names.record) {
3350             if (allowRecords) {
3351                 return Source.JDK14;
3352             } else if (shouldWarn) {
3353                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3354             }
3355         }
<a name="5" id="anc5"></a><span class="line-added">3356         if (name == names.sealed) {</span>
<span class="line-added">3357             if (allowSealedTypes) {</span>
<span class="line-added">3358                 return Source.JDK15;</span>
<span class="line-added">3359             } else if (shouldWarn) {</span>
<span class="line-added">3360                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));</span>
<span class="line-added">3361             }</span>
<span class="line-added">3362         }</span>
3363         return null;
3364     }
3365 
3366     /** VariableDeclaratorId = Ident BracketsOpt
3367      */
3368     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3369         return variableDeclaratorId(mods, type, false);
3370     }
3371     //where
3372     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3373         int pos = token.pos;
3374         Name name;
3375         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3376             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3377             name = token.name();
3378             nextToken();
3379         } else {
3380             if (allowThisIdent ||
3381                 !lambdaParameter ||
3382                 LAX_IDENTIFIER.accepts(token.kind) ||
3383                 mods.flags != Flags.PARAMETER ||
3384                 mods.annotations.nonEmpty()) {
3385                 JCExpression pn = qualident(false);
3386                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3387                     name = ((JCIdent)pn).name;
3388                 } else {
3389                     if (allowThisIdent) {
3390                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3391                             log.error(token.pos, Errors.VarargsAndReceiver);
3392                         }
3393                         if (token.kind == LBRACKET) {
3394                             log.error(token.pos, Errors.ArrayAndReceiver);
3395                         }
3396                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3397                             log.error(token.pos, Errors.WrongReceiver);
3398                         }
3399                     }
3400                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3401                 }
3402             } else {
3403                 /** if it is a lambda parameter and the token kind is not an identifier,
3404                  *  and there are no modifiers or annotations, then this means that the compiler
3405                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3406                  *  var or explicit parameters. So we assign the error name to the parameter name
3407                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3408                  *  a higher level.
3409                  */
3410                 name = names.empty;
3411             }
3412         }
3413         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3414                 token.kind == LBRACKET) {
3415             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3416         }
3417         type = bracketsOpt(type);
3418 
3419         return toP(F.at(pos).VarDef(mods, name, type, null));
3420     }
3421 
3422     /** Resources = Resource { &quot;;&quot; Resources }
3423      */
3424     List&lt;JCTree&gt; resources() {
3425         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3426         defs.append(resource());
3427         while (token.kind == SEMI) {
3428             // All but last of multiple declarators must subsume a semicolon
3429             storeEnd(defs.last(), token.endPos);
3430             int semiColonPos = token.pos;
3431             nextToken();
3432             if (token.kind == RPAREN) { // Optional trailing semicolon
3433                                        // after last resource
3434                 break;
3435             }
3436             defs.append(resource());
3437         }
3438         return defs.toList();
3439     }
3440 
3441     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3442      *           | Expression
3443      */
3444     protected JCTree resource() {
3445         int startPos = token.pos;
3446         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3447             JCModifiers mods = optFinal(Flags.FINAL);
3448             JCExpression t = parseType(true);
3449             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3450         }
3451         JCExpression t = term(EXPR | TYPE);
3452         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3453             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3454             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3455         } else {
3456             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3457             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3458                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3459             }
3460 
3461             return t;
3462         }
3463     }
3464 
3465     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3466      */
3467     public JCTree.JCCompilationUnit parseCompilationUnit() {
3468         Token firstToken = token;
3469         JCModifiers mods = null;
3470         boolean consumedToplevelDoc = false;
3471         boolean seenImport = false;
3472         boolean seenPackage = false;
3473         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3474         if (token.kind == MONKEYS_AT)
3475             mods = modifiersOpt();
3476 
3477         if (token.kind == PACKAGE) {
3478             int packagePos = token.pos;
3479             List&lt;JCAnnotation&gt; annotations = List.nil();
3480             seenPackage = true;
3481             if (mods != null) {
3482                 checkNoMods(mods.flags);
3483                 annotations = mods.annotations;
3484                 mods = null;
3485             }
3486             nextToken();
3487             JCExpression pid = qualident(false);
3488             accept(SEMI);
3489             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3490             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3491             consumedToplevelDoc = true;
3492             defs.append(pd);
3493         }
3494 
3495         boolean checkForImports = true;
3496         boolean firstTypeDecl = true;
3497         while (token.kind != EOF) {
3498             if (token.pos &lt;= endPosTable.errorEndPos) {
3499                 // error recovery
3500                 skip(checkForImports, false, false, false);
3501                 if (token.kind == EOF)
3502                     break;
3503             }
3504             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3505                 seenImport = true;
3506                 defs.append(importDeclaration());
3507             } else {
3508                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3509                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3510                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3511                     consumedToplevelDoc = true;
3512                 }
3513                 if (mods != null || token.kind != SEMI)
3514                     mods = modifiersOpt(mods);
3515                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3516                     ModuleKind kind = ModuleKind.STRONG;
3517                     if (token.name() == names.open) {
3518                         kind = ModuleKind.OPEN;
3519                         nextToken();
3520                     }
3521                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3522                         if (mods != null) {
3523                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3524                         }
3525                         defs.append(moduleDecl(mods, kind, docComment));
3526                         consumedToplevelDoc = true;
3527                         break;
3528                     } else if (kind != ModuleKind.STRONG) {
3529                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3530                     }
3531                 }
3532                 JCTree def = typeDeclaration(mods, docComment);
3533                 if (def instanceof JCExpressionStatement)
3534                     def = ((JCExpressionStatement)def).expr;
3535                 defs.append(def);
3536                 if (def instanceof JCClassDecl)
3537                     checkForImports = false;
3538                 mods = null;
3539                 firstTypeDecl = false;
3540             }
3541         }
3542         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3543         if (!consumedToplevelDoc)
3544             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3545         if (defs.isEmpty())
3546             storeEnd(toplevel, S.prevToken().endPos);
3547         if (keepDocComments)
3548             toplevel.docComments = docComments;
3549         if (keepLineMap)
3550             toplevel.lineMap = S.getLineMap();
3551         this.endPosTable.setParser(null); // remove reference to parser
3552         toplevel.endPositions = this.endPosTable;
3553         return toplevel;
3554     }
3555 
3556     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3557         int pos = token.pos;
3558         checkSourceLevel(Feature.MODULES);
3559 
3560         nextToken();
3561         JCExpression name = qualident(false);
3562         List&lt;JCDirective&gt; directives = null;
3563 
3564         accept(LBRACE);
3565         directives = moduleDirectiveList();
3566         accept(RBRACE);
3567         accept(EOF);
3568 
3569         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3570         attach(result, dc);
3571         return result;
3572     }
3573 
3574     List&lt;JCDirective&gt; moduleDirectiveList() {
3575         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3576         while (token.kind == IDENTIFIER) {
3577             int pos = token.pos;
3578             if (token.name() == names.requires) {
3579                 nextToken();
3580                 boolean isTransitive = false;
3581                 boolean isStaticPhase = false;
3582             loop:
3583                 while (true) {
3584                     switch (token.kind) {
3585                         case IDENTIFIER:
3586                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3587                                 Token t1 = S.token(1);
3588                                 if (t1.kind == SEMI || t1.kind == DOT) {
3589                                     break loop;
3590                                 }
3591                                 isTransitive = true;
3592                                 break;
3593                             } else {
3594                                 break loop;
3595                             }
3596                         case STATIC:
3597                             if (isStaticPhase) {
3598                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3599                             }
3600                             isStaticPhase = true;
3601                             break;
3602                         default:
3603                             break loop;
3604                     }
3605                     nextToken();
3606                 }
3607                 JCExpression moduleName = qualident(false);
3608                 accept(SEMI);
3609                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3610             } else if (token.name() == names.exports || token.name() == names.opens) {
3611                 boolean exports = token.name() == names.exports;
3612                 nextToken();
3613                 JCExpression pkgName = qualident(false);
3614                 List&lt;JCExpression&gt; moduleNames = null;
3615                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3616                     nextToken();
3617                     moduleNames = qualidentList(false);
3618                 }
3619                 accept(SEMI);
3620                 JCDirective d;
3621                 if (exports) {
3622                     d = F.at(pos).Exports(pkgName, moduleNames);
3623                 } else {
3624                     d = F.at(pos).Opens(pkgName, moduleNames);
3625                 }
3626                 defs.append(toP(d));
3627             } else if (token.name() == names.provides) {
3628                 nextToken();
3629                 JCExpression serviceName = qualident(false);
3630                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3631                     nextToken();
3632                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3633                     accept(SEMI);
3634                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3635                 } else {
3636                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3637                     skip(false, false, false, false);
3638                 }
3639             } else if (token.name() == names.uses) {
3640                 nextToken();
3641                 JCExpression service = qualident(false);
3642                 accept(SEMI);
3643                 defs.append(toP(F.at(pos).Uses(service)));
3644             } else {
3645                 setErrorEndPos(pos);
3646                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3647                 break;
3648             }
3649         }
3650         return defs.toList();
3651     }
3652 
3653     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3654      */
3655     protected JCTree importDeclaration() {
3656         int pos = token.pos;
3657         nextToken();
3658         boolean importStatic = false;
3659         if (token.kind == STATIC) {
3660             importStatic = true;
3661             nextToken();
3662         }
3663         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3664         do {
3665             int pos1 = token.pos;
3666             accept(DOT);
3667             if (token.kind == STAR) {
3668                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3669                 nextToken();
3670                 break;
3671             } else {
3672                 pid = toP(F.at(pos1).Select(pid, ident()));
3673             }
3674         } while (token.kind == DOT);
3675         accept(SEMI);
3676         return toP(F.at(pos).Import(pid, importStatic));
3677     }
3678 
3679     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3680      *                  | &quot;;&quot;
3681      */
3682     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3683         int pos = token.pos;
3684         if (mods == null &amp;&amp; token.kind == SEMI) {
3685             nextToken();
3686             return toP(F.at(pos).Skip());
3687         } else {
3688             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3689         }
3690     }
3691 
3692     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3693      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3694      *  @param mods     Any modifiers starting the class or interface declaration
3695      *  @param dc       The documentation comment for the class, or null.
3696      */
3697     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3698         if (token.kind == CLASS) {
3699             return classDeclaration(mods, dc);
3700         } if (isRecordStart()) {
3701             return recordDeclaration(mods, dc);
3702         } else if (token.kind == INTERFACE) {
3703             return interfaceDeclaration(mods, dc);
3704         } else if (token.kind == ENUM) {
3705             return enumDeclaration(mods, dc);
3706         } else {
3707             int pos = token.pos;
3708             List&lt;JCTree&gt; errs;
3709             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3710                 checkSourceLevel(Feature.RECORDS);
3711                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3712                 return toP(F.Exec(erroneousTree));
3713             } else {
3714                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3715                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3716                     setErrorEndPos(token.pos);
3717                 } else {
3718                     errs = List.of(mods);
3719                 }
3720                 final JCErroneous erroneousTree;
3721                 if (parseModuleInfo) {
3722                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3723                 } else {
3724                     if (allowRecords) {
3725                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3726                     } else {
3727                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3728                     }
3729                 }
3730                 return toP(F.Exec(erroneousTree));
3731             }
3732         }
3733     }
3734 
3735     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3736      *                     [IMPLEMENTS TypeList] ClassBody
3737      *  @param mods    The modifiers starting the class declaration
3738      *  @param dc       The documentation comment for the class, or null.
3739      */
3740     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3741         int pos = token.pos;
3742         accept(CLASS);
3743         Name name = typeName();
3744 
3745         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3746 
3747         JCExpression extending = null;
3748         if (token.kind == EXTENDS) {
3749             nextToken();
3750             extending = parseType();
3751         }
3752         List&lt;JCExpression&gt; implementing = List.nil();
3753         if (token.kind == IMPLEMENTS) {
3754             nextToken();
3755             implementing = typeList();
3756         }
<a name="6" id="anc6"></a><span class="line-added">3757         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3758         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3759             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3760             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3761                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;class&quot;)));</span>
<span class="line-added">3762             }</span>
<span class="line-added">3763             nextToken();</span>
<span class="line-added">3764             permitting = qualidentList(false);</span>
<span class="line-added">3765         }</span>
3766         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3767         JCClassDecl result = toP(F.at(pos).ClassDef(
<a name="7" id="anc7"></a><span class="line-modified">3768             mods, name, typarams, extending, implementing, permitting, defs));</span>
3769         attach(result, dc);
3770         return result;
3771     }
3772 
3773     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3774         int pos = token.pos;
3775         nextToken();
3776         mods.flags |= Flags.RECORD;
3777         Name name = typeName();
3778 
3779         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3780 
3781         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3782 
3783         List&lt;JCExpression&gt; implementing = List.nil();
3784         if (token.kind == IMPLEMENTS) {
3785             nextToken();
3786             implementing = typeList();
3787         }
3788         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3789         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3790         for (JCVariableDecl field : headerFields) {
3791             fields.add(field);
3792         }
3793         for (JCTree def : defs) {
3794             if (def.hasTag(METHODDEF)) {
3795                 JCMethodDecl methDef = (JCMethodDecl) def;
3796                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3797                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3798                     for (JCVariableDecl param : headerFields) {
3799                         tmpParams.add(F.at(param)
3800                                 // we will get flags plus annotations from the record component
3801                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3802                                 param.name, param.vartype, null));
3803                     }
3804                     methDef.params = tmpParams.toList();
3805                 }
3806             }
3807         }
3808         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3809             JCVariableDecl field = fields.get(i);
3810             defs = defs.prepend(field);
3811         }
3812         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3813         attach(result, dc);
3814         return result;
3815     }
3816 
3817     Name typeName() {
3818         int pos = token.pos;
3819         Name name = ident();
3820         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3821         if (source != null) {
3822             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3823         }
3824         return name;
3825     }
3826 
3827     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3828      *                         [EXTENDS TypeList] InterfaceBody
3829      *  @param mods    The modifiers starting the interface declaration
3830      *  @param dc       The documentation comment for the interface, or null.
3831      */
3832     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3833         int pos = token.pos;
3834         accept(INTERFACE);
3835 
3836         Name name = typeName();
3837 
3838         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3839 
3840         List&lt;JCExpression&gt; extending = List.nil();
3841         if (token.kind == EXTENDS) {
3842             nextToken();
3843             extending = typeList();
3844         }
<a name="8" id="anc8"></a><span class="line-modified">3845         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3846         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3847             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3848             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3849                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;interface&quot;)));</span>
<span class="line-added">3850             }</span>
<span class="line-added">3851             nextToken();</span>
<span class="line-added">3852             permitting = typeList();</span>
<span class="line-added">3853         }</span>
<span class="line-added">3854         List&lt;JCTree&gt; defs;</span>
<span class="line-added">3855         defs = classInterfaceOrRecordBody(name, true, false);</span>
3856         JCClassDecl result = toP(F.at(pos).ClassDef(
<a name="9" id="anc9"></a><span class="line-modified">3857             mods, name, typarams, null, extending, permitting, defs));</span>
3858         attach(result, dc);
3859         return result;
3860     }
3861 
3862     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3863      *  @param mods    The modifiers starting the enum declaration
3864      *  @param dc       The documentation comment for the enum, or null.
3865      */
3866     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3867         int pos = token.pos;
3868         accept(ENUM);
3869 
3870         Name name = typeName();
3871 
3872         List&lt;JCExpression&gt; implementing = List.nil();
3873         if (token.kind == IMPLEMENTS) {
3874             nextToken();
3875             implementing = typeList();
3876         }
3877 
3878         List&lt;JCTree&gt; defs = enumBody(name);
3879         mods.flags |= Flags.ENUM;
3880         JCClassDecl result = toP(F.at(pos).
3881             ClassDef(mods, name, List.nil(),
3882                      null, implementing, defs));
3883         attach(result, dc);
3884         return result;
3885     }
3886 
3887     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3888      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3889      */
3890     List&lt;JCTree&gt; enumBody(Name enumName) {
3891         accept(LBRACE);
3892         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3893         boolean wasSemi = false;
3894         boolean hasStructuralErrors = false;
3895         boolean wasError = false;
3896         if (token.kind == COMMA) {
3897             nextToken();
3898             if (token.kind == SEMI) {
3899                 wasSemi = true;
3900                 nextToken();
3901             } else if (token.kind != RBRACE) {
3902                 reportSyntaxError(S.prevToken().endPos,
3903                                   Errors.Expected2(RBRACE, SEMI));
3904                 wasError = true;
3905             }
3906         }
3907         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3908             if (token.kind == SEMI) {
3909                 accept(SEMI);
3910                 wasSemi = true;
3911                 if (token.kind == RBRACE || token.kind == EOF) break;
3912             }
3913             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3914             if (memberType == EnumeratorEstimate.UNKNOWN) {
3915                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3916                                      : EnumeratorEstimate.ENUMERATOR;
3917             }
3918             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3919                 wasError = false;
3920                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3921                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3922                     hasStructuralErrors = true;
3923                 }
3924                 defs.append(enumeratorDeclaration(enumName));
3925                 if (token.pos &lt;= endPosTable.errorEndPos) {
3926                     // error recovery
3927                    skip(false, true, true, false);
3928                 } else {
3929                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3930                         if (token.kind == COMMA) {
3931                             nextToken();
3932                         } else {
3933                             setErrorEndPos(token.pos);
3934                             reportSyntaxError(S.prevToken().endPos,
3935                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3936                             wasError = true;
3937                         }
3938                     }
3939                 }
3940             } else {
3941                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3942                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3943                     hasStructuralErrors = true;
3944                 }
3945                 wasError = false;
3946                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3947                                                                 false, false));
3948                 if (token.pos &lt;= endPosTable.errorEndPos) {
3949                     // error recovery
3950                    skip(false, true, true, false);
3951                 }
3952             }
3953         }
3954         accept(RBRACE);
3955         return defs.toList();
3956     }
3957 
3958     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3959         // if we are seeing a record declaration inside of an enum we want the same error message as expected for a
3960         // let&#39;s say an interface declaration inside an enum
3961         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName &amp;&amp;
3962                 (!allowRecords || !isRecordStart())) {
3963             Token next = S.token(1);
3964             switch (next.kind) {
3965                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3966                     return EnumeratorEstimate.ENUMERATOR;
3967             }
3968         }
3969         switch (token.kind) {
3970             case IDENTIFIER: case MONKEYS_AT: case LT:
3971                 if (token.kind == IDENTIFIER) {
3972                     if (allowRecords &amp;&amp; isRecordStart()) {
3973                         return EnumeratorEstimate.MEMBER;
3974                     }
3975                 }
3976                 return EnumeratorEstimate.UNKNOWN;
3977             default:
3978                 return EnumeratorEstimate.MEMBER;
3979         }
3980     }
3981 
3982     private enum EnumeratorEstimate {
3983         ENUMERATOR,
3984         MEMBER,
3985         UNKNOWN;
3986     }
3987 
3988     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3989      */
3990     JCTree enumeratorDeclaration(Name enumName) {
3991         Comment dc = token.comment(CommentStyle.JAVADOC);
3992         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3993         if (token.deprecatedFlag()) {
3994             flags |= Flags.DEPRECATED;
3995         }
3996         int pos = token.pos;
3997         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3998         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3999         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4000         int identPos = token.pos;
4001         Name name = ident();
4002         int createPos = token.pos;
4003         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4004             ? arguments() : List.nil();
4005         JCClassDecl body = null;
4006         if (token.kind == LBRACE) {
4007             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4008             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4009             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4010         }
4011         if (args.isEmpty() &amp;&amp; body == null)
4012             createPos = identPos;
4013         JCIdent ident = F.at(identPos).Ident(enumName);
4014         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4015         if (createPos != identPos)
4016             storeEnd(create, S.prevToken().endPos);
4017         ident = F.at(identPos).Ident(enumName);
4018         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4019         attach(result, dc);
4020         return result;
4021     }
4022 
4023     /** TypeList = Type {&quot;,&quot; Type}
4024      */
4025     List&lt;JCExpression&gt; typeList() {
4026         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4027         ts.append(parseType());
4028         while (token.kind == COMMA) {
4029             nextToken();
4030             ts.append(parseType());
4031         }
4032         return ts.toList();
4033     }
4034 
4035     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4036      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4037      */
4038     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4039         accept(LBRACE);
4040         if (token.pos &lt;= endPosTable.errorEndPos) {
4041             // error recovery
4042             skip(false, true, false, false);
4043             if (token.kind == LBRACE)
4044                 nextToken();
4045         }
4046         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4047         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4048             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4049             if (token.pos &lt;= endPosTable.errorEndPos) {
4050                // error recovery
4051                skip(false, true, true, false);
4052            }
4053         }
4054         accept(RBRACE);
4055         return defs.toList();
4056     }
4057 
4058     /** ClassBodyDeclaration =
4059      *      &quot;;&quot;
4060      *    | [STATIC] Block
4061      *    | ModifiersOpt
4062      *      ( Type Ident
4063      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4064      *      | VOID Ident VoidMethodDeclaratorRest
4065      *      | TypeParameters [Annotations]
4066      *        ( Type Ident MethodDeclaratorRest
4067      *        | VOID Ident VoidMethodDeclaratorRest
4068      *        )
4069      *      | Ident ConstructorDeclaratorRest
4070      *      | TypeParameters Ident ConstructorDeclaratorRest
4071      *      | ClassOrInterfaceOrEnumDeclaration
4072      *      )
4073      *  InterfaceBodyDeclaration =
4074      *      &quot;;&quot;
4075      *    | ModifiersOpt
4076      *      ( Type Ident
4077      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4078      *      | VOID Ident MethodDeclaratorRest
4079      *      | TypeParameters [Annotations]
4080      *        ( Type Ident MethodDeclaratorRest
4081      *        | VOID Ident VoidMethodDeclaratorRest
4082      *        )
4083      *      | ClassOrInterfaceOrEnumDeclaration
4084      *      )
4085      *
4086      */
4087     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4088         if (token.kind == SEMI) {
4089             nextToken();
4090             return List.nil();
4091         } else {
4092             Comment dc = token.comment(CommentStyle.JAVADOC);
4093             int pos = token.pos;
4094             JCModifiers mods = modifiersOpt();
4095             if (token.kind == CLASS ||
4096                 allowRecords &amp;&amp; isRecordStart() ||
4097                 token.kind == INTERFACE ||
4098                 token.kind == ENUM) {
4099                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4100             } else if (token.kind == LBRACE &amp;&amp;
4101                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4102                        mods.annotations.isEmpty()) {
4103                 if (isInterface) {
4104                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4105                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4106                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4107                 }
4108                 return List.of(block(pos, mods.flags));
4109             } else {
4110                 pos = token.pos;
4111                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4112                 // if there are type parameters but no modifiers, save the start
4113                 // position of the method in the modifiers.
4114                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4115                     mods.pos = pos;
4116                     storeEnd(mods, pos);
4117                 }
4118                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4119 
4120                 if (annosAfterParams.nonEmpty()) {
4121                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4122                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4123                     if (mods.pos == Position.NOPOS)
4124                         mods.pos = mods.annotations.head.pos;
4125                 }
4126 
4127                 Token tk = token;
4128                 pos = token.pos;
4129                 JCExpression type;
4130                 boolean isVoid = token.kind == VOID;
4131                 if (isVoid) {
4132                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4133                     nextToken();
4134                 } else {
4135                     // method returns types are un-annotated types
4136                     type = unannotatedType(false);
4137                 }
4138                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4139                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4140                     if (isInterface || tk.name() != className)
4141                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4142                     else if (annosAfterParams.nonEmpty())
4143                         illegal(annosAfterParams.head.pos);
4144                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4145                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4146                     }
4147                     return List.of(methodDeclaratorRest(
4148                         pos, mods, null, names.init, typarams,
4149                         isInterface, true, isRecord, dc));
4150                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4151                     // trying to define a compact constructor with a throws clause
4152                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4153                             Errors.InvalidCanonicalConstructorInRecord(
4154                                     Fragments.Compact,
4155                                     className,
4156                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4157                     skip(false, true, false, false);
4158                     return List.of(methodDeclaratorRest(
4159                             pos, mods, null, names.init, typarams,
4160                             isInterface, true, isRecord, dc));
4161                 } else {
4162                     pos = token.pos;
4163                     Name name = ident();
4164                     if (token.kind == LPAREN) {
4165                         return List.of(methodDeclaratorRest(
4166                             pos, mods, type, name, typarams,
4167                             isInterface, isVoid, false, dc));
4168                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4169                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4170                         List&lt;JCTree&gt; defs =
4171                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4172                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4173                         accept(SEMI);
4174                         storeEnd(defs.last(), S.prevToken().endPos);
4175                         return defs;
4176                     } else {
4177                             int errPos = pos;
4178                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4179                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4180                             accept(SEMI);
4181                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4182                         }
4183                     } else {
4184                         pos = token.pos;
4185                         List&lt;JCTree&gt; err;
4186                         if (isVoid || typarams.nonEmpty()) {
4187                             JCMethodDecl m =
4188                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4189                                                             List.nil(), List.nil(), null, null));
4190                             attach(m, dc);
4191                             err = List.of(m);
4192                         } else {
4193                             err = List.nil();
4194                         }
4195                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4196                     }
4197                 }
4198             }
4199         }
4200     }
4201 
4202     protected boolean isRecordStart() {
<a name="10" id="anc10"></a><span class="line-modified">4203         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4204             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4205              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4206              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<a name="11" id="anc11"></a><span class="line-modified">4207              checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4208             return true;</span>
<span class="line-modified">4209         } else {</span>
<span class="line-modified">4210             return false;</span>
<span class="line-modified">4211         }</span>
<span class="line-modified">4212     }</span>
<span class="line-added">4213 </span>
<span class="line-added">4214     protected boolean isNonSealedClassStart(boolean local) {</span>
<span class="line-added">4215         if (isNonSealedIdentifier(token, 0)) {</span>
<span class="line-added">4216             Token next = S.token(3);</span>
<span class="line-added">4217             return allowedAfterSealedOrNonSealed(next, local, true);</span>
<span class="line-added">4218         }</span>
<span class="line-added">4219         return false;</span>
<span class="line-added">4220     }</span>
<span class="line-added">4221 </span>
<span class="line-added">4222     protected boolean isNonSealedIdentifier(Token someToken, int lookAheadOffset) {</span>
<span class="line-added">4223         if (someToken.name() == names.non &amp;&amp; peekToken(lookAheadOffset, TokenKind.SUB, TokenKind.IDENTIFIER)) {</span>
<span class="line-added">4224             Token tokenSub = S.token(lookAheadOffset + 1);</span>
<span class="line-added">4225             Token tokenSealed = S.token(lookAheadOffset + 2);</span>
<span class="line-added">4226             if (someToken.endPos == tokenSub.pos &amp;&amp;</span>
<span class="line-added">4227                     tokenSub.endPos == tokenSealed.pos &amp;&amp;</span>
<span class="line-added">4228                     tokenSealed.name() == names.sealed) {</span>
<span class="line-added">4229                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4230                 return true;</span>
<span class="line-added">4231             }</span>
<span class="line-added">4232         }</span>
<span class="line-added">4233         return false;</span>
<span class="line-added">4234     }</span>
<span class="line-added">4235 </span>
<span class="line-added">4236     protected boolean isSealedClassStart(boolean local) {</span>
<span class="line-added">4237         if (token.name() == names.sealed) {</span>
<span class="line-added">4238             Token next = S.token(1);</span>
<span class="line-added">4239             if (allowedAfterSealedOrNonSealed(next, local, false)) {</span>
<span class="line-added">4240                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4241                 return true;</span>
<span class="line-added">4242             }</span>
<span class="line-added">4243         }</span>
<span class="line-added">4244         return false;</span>
<span class="line-added">4245     }</span>
<span class="line-added">4246 </span>
<span class="line-added">4247     private boolean allowedAfterSealedOrNonSealed(Token next, boolean local, boolean currentIsNonSealed) {</span>
<span class="line-added">4248         return local ?</span>
<span class="line-added">4249             switch (next.kind) {</span>
<span class="line-added">4250                 case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4251                 default -&gt; false;</span>
<span class="line-added">4252             } :</span>
<span class="line-added">4253             switch (next.kind) {</span>
<span class="line-added">4254                 case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4255                 case IDENTIFIER -&gt; isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;</span>
<span class="line-added">4256                 default -&gt; false;</span>
<span class="line-added">4257             };</span>
<span class="line-added">4258     }</span>
4259 
4260     /** MethodDeclaratorRest =
4261      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4262      *  VoidMethodDeclaratorRest =
4263      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4264      *  ConstructorDeclaratorRest =
4265      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4266      */
4267     protected JCTree methodDeclaratorRest(int pos,
4268                               JCModifiers mods,
4269                               JCExpression type,
4270                               Name name,
4271                               List&lt;JCTypeParameter&gt; typarams,
4272                               boolean isInterface, boolean isVoid,
4273                               boolean isRecord,
4274                               Comment dc) {
4275         if (isInterface) {
4276             if ((mods.flags &amp; Flags.STATIC) != 0) {
4277                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4278             }
4279             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4280                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4281             }
4282         }
4283         JCVariableDecl prevReceiverParam = this.receiverParam;
4284         try {
4285             this.receiverParam = null;
4286             // Parsing formalParameters sets the receiverParam, if present
4287             List&lt;JCVariableDecl&gt; params = List.nil();
4288             List&lt;JCExpression&gt; thrown = List.nil();
4289             if (!isRecord || name != names.init || token.kind == LPAREN) {
4290                 params = formalParameters();
4291                 if (!isVoid) type = bracketsOpt(type);
4292                 if (token.kind == THROWS) {
4293                     nextToken();
4294                     thrown = qualidentList(true);
4295                 }
4296             }
4297             JCBlock body = null;
4298             JCExpression defaultValue;
4299             if (token.kind == LBRACE) {
4300                 body = block();
4301                 defaultValue = null;
4302             } else {
4303                 if (token.kind == DEFAULT) {
4304                     accept(DEFAULT);
4305                     defaultValue = annotationValue();
4306                 } else {
4307                     defaultValue = null;
4308                 }
4309                 accept(SEMI);
4310                 if (token.pos &lt;= endPosTable.errorEndPos) {
4311                     // error recovery
4312                     skip(false, true, false, false);
4313                     if (token.kind == LBRACE) {
4314                         body = block();
4315                     }
4316                 }
4317             }
4318 
4319             JCMethodDecl result =
4320                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4321                                             receiverParam, params, thrown,
4322                                             body, defaultValue));
4323             attach(result, dc);
4324             return result;
4325         } finally {
4326             this.receiverParam = prevReceiverParam;
4327         }
4328     }
4329 
4330     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4331      */
4332     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4333         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4334 
4335         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4336         JCExpression qi = qualident(allowAnnos);
4337         if (!typeAnnos.isEmpty()) {
4338             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4339             ts.append(at);
4340         } else {
4341             ts.append(qi);
4342         }
4343         while (token.kind == COMMA) {
4344             nextToken();
4345 
4346             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4347             qi = qualident(allowAnnos);
4348             if (!typeAnnos.isEmpty()) {
4349                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4350                 ts.append(at);
4351             } else {
4352                 ts.append(qi);
4353             }
4354         }
4355         return ts.toList();
4356     }
4357 
4358     /**
4359      *  {@literal
4360      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4361      *  }
4362      */
4363     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4364         if (token.kind == LT) {
4365             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4366             nextToken();
4367             typarams.append(typeParameter());
4368             while (token.kind == COMMA) {
4369                 nextToken();
4370                 typarams.append(typeParameter());
4371             }
4372             accept(GT);
4373             return typarams.toList();
4374         } else {
4375             return List.nil();
4376         }
4377     }
4378 
4379     /**
4380      *  {@literal
4381      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4382      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4383      *  TypeVariable = Ident
4384      *  }
4385      */
4386     JCTypeParameter typeParameter() {
4387         int pos = token.pos;
4388         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4389         Name name = typeName();
4390         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4391         if (token.kind == EXTENDS) {
4392             nextToken();
4393             bounds.append(parseType());
4394             while (token.kind == AMP) {
4395                 nextToken();
4396                 bounds.append(parseType());
4397             }
4398         }
4399         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4400     }
4401 
4402     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4403      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4404      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4405      */
4406     List&lt;JCVariableDecl&gt; formalParameters() {
4407         return formalParameters(false, false);
4408     }
4409     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4410         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4411         JCVariableDecl lastParam;
4412         accept(LPAREN);
4413         if (token.kind != RPAREN) {
4414             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4415             lastParam = formalParameter(lambdaParameters, recordComponents);
4416             if (lastParam.nameexpr != null) {
4417                 this.receiverParam = lastParam;
4418             } else {
4419                 params.append(lastParam);
4420             }
4421             this.allowThisIdent = false;
4422             while (token.kind == COMMA) {
4423                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4424                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4425                 }
4426                 nextToken();
4427                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4428             }
4429         }
4430         if (token.kind == RPAREN) {
4431             nextToken();
4432         } else {
4433             setErrorEndPos(token.pos);
4434             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4435         }
4436         return params.toList();
4437     }
4438 
4439     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4440         if (hasParens) {
4441             accept(LPAREN);
4442         }
4443         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4444         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4445             params.append(implicitParameter());
4446             while (token.kind == COMMA) {
4447                 nextToken();
4448                 params.append(implicitParameter());
4449             }
4450         }
4451         if (hasParens) {
4452             accept(RPAREN);
4453         }
4454         return params.toList();
4455     }
4456 
4457     JCModifiers optFinal(long flags) {
4458         JCModifiers mods = modifiersOpt();
4459         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4460         mods.flags |= flags;
4461         return mods;
4462     }
4463 
4464     /**
4465      * Inserts the annotations (and possibly a new array level)
4466      * to the left-most type in an array or nested type.
4467      *
4468      * When parsing a type like {@code @B Outer.Inner @A []}, the
4469      * {@code @A} annotation should target the array itself, while
4470      * {@code @B} targets the nested type {@code Outer}.
4471      *
4472      * Currently the parser parses the annotation first, then
4473      * the array, and then inserts the annotation to the left-most
4474      * nested type.
4475      *
4476      * When {@code createNewLevel} is true, then a new array
4477      * level is inserted as the most inner type, and have the
4478      * annotations target it.  This is useful in the case of
4479      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4480      * first parses the type {@code String @A []} then inserts
4481      * a new array level with {@code @B} annotation.
4482      */
4483     private JCExpression insertAnnotationsToMostInner(
4484             JCExpression type, List&lt;JCAnnotation&gt; annos,
4485             boolean createNewLevel) {
4486         int origEndPos = getEndPos(type);
4487         JCExpression mostInnerType = type;
4488         JCArrayTypeTree mostInnerArrayType = null;
4489         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4490             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4491             mostInnerType = mostInnerArrayType.elemtype;
4492         }
4493 
4494         if (createNewLevel) {
4495             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4496         }
4497 
4498         JCExpression mostInnerTypeToReturn = mostInnerType;
4499         if (annos.nonEmpty()) {
4500             JCExpression lastToModify = mostInnerType;
4501 
4502             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4503                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4504                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4505                     lastToModify = mostInnerType;
4506                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4507                 }
4508                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4509                     lastToModify = mostInnerType;
4510                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4511                 }
4512             }
4513 
4514             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4515 
4516             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4517                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4518             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4519                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4520             } else {
4521                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4522                 mostInnerTypeToReturn = mostInnerType;
4523             }
4524         }
4525 
4526         if (mostInnerArrayType == null) {
4527             return mostInnerTypeToReturn;
4528         } else {
4529             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4530             storeEnd(type, origEndPos);
4531             return type;
4532         }
4533     }
4534 
4535     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4536      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4537      */
4538     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4539         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4540         if (recordComponent &amp;&amp; mods.flags != 0) {
4541             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4542         }
4543         if (recordComponent) {
4544             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4545         }
4546         // need to distinguish between vararg annos and array annos
4547         // look at typeAnnotationsPushedBack comment
4548         this.permitTypeAnnotationsPushBack = true;
4549         JCExpression type = parseType(lambdaParameter);
4550         this.permitTypeAnnotationsPushBack = false;
4551 
4552         if (token.kind == ELLIPSIS) {
4553             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4554             typeAnnotationsPushedBack = List.nil();
4555             mods.flags |= Flags.VARARGS;
4556             // insert var arg type annotations
4557             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4558             nextToken();
4559         } else {
4560             // if not a var arg, then typeAnnotationsPushedBack should be null
4561             if (typeAnnotationsPushedBack.nonEmpty()) {
4562                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4563             }
4564             typeAnnotationsPushedBack = List.nil();
4565         }
4566         return variableDeclaratorId(mods, type, lambdaParameter);
4567     }
4568 
4569     protected JCVariableDecl implicitParameter() {
4570         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4571         return variableDeclaratorId(mods, null, true);
4572     }
4573 
4574 /* ---------- auxiliary methods -------------- */
4575     /** Check that given tree is a legal expression statement.
4576      */
4577     protected JCExpression checkExprStat(JCExpression t) {
4578         if (!TreeInfo.isExpressionStatement(t)) {
4579             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4580             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4581             return ret;
4582         } else {
4583             return t;
4584         }
4585     }
4586 
4587     /** Return precedence of operator represented by token,
4588      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4589      */
4590     static int prec(TokenKind token) {
4591         JCTree.Tag oc = optag(token);
4592         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4593     }
4594 
4595     /**
4596      * Return the lesser of two positions, making allowance for either one
4597      * being unset.
4598      */
4599     static int earlier(int pos1, int pos2) {
4600         if (pos1 == Position.NOPOS)
4601             return pos2;
4602         if (pos2 == Position.NOPOS)
4603             return pos1;
4604         return (pos1 &lt; pos2 ? pos1 : pos2);
4605     }
4606 
4607     /** Return operation tag of binary operator represented by token,
4608      *  No_TAG if token is not a binary operator.
4609      */
4610     static JCTree.Tag optag(TokenKind token) {
4611         switch (token) {
4612         case BARBAR:
4613             return OR;
4614         case AMPAMP:
4615             return AND;
4616         case BAR:
4617             return BITOR;
4618         case BAREQ:
4619             return BITOR_ASG;
4620         case CARET:
4621             return BITXOR;
4622         case CARETEQ:
4623             return BITXOR_ASG;
4624         case AMP:
4625             return BITAND;
4626         case AMPEQ:
4627             return BITAND_ASG;
4628         case EQEQ:
4629             return JCTree.Tag.EQ;
4630         case BANGEQ:
4631             return NE;
4632         case LT:
4633             return JCTree.Tag.LT;
4634         case GT:
4635             return JCTree.Tag.GT;
4636         case LTEQ:
4637             return LE;
4638         case GTEQ:
4639             return GE;
4640         case LTLT:
4641             return SL;
4642         case LTLTEQ:
4643             return SL_ASG;
4644         case GTGT:
4645             return SR;
4646         case GTGTEQ:
4647             return SR_ASG;
4648         case GTGTGT:
4649             return USR;
4650         case GTGTGTEQ:
4651             return USR_ASG;
4652         case PLUS:
4653             return JCTree.Tag.PLUS;
4654         case PLUSEQ:
4655             return PLUS_ASG;
4656         case SUB:
4657             return MINUS;
4658         case SUBEQ:
4659             return MINUS_ASG;
4660         case STAR:
4661             return MUL;
4662         case STAREQ:
4663             return MUL_ASG;
4664         case SLASH:
4665             return DIV;
4666         case SLASHEQ:
4667             return DIV_ASG;
4668         case PERCENT:
4669             return MOD;
4670         case PERCENTEQ:
4671             return MOD_ASG;
4672         case INSTANCEOF:
4673             return TYPETEST;
4674         default:
4675             return NO_TAG;
4676         }
4677     }
4678 
4679     /** Return operation tag of unary operator represented by token,
4680      *  No_TAG if token is not a binary operator.
4681      */
4682     static JCTree.Tag unoptag(TokenKind token) {
4683         switch (token) {
4684         case PLUS:
4685             return POS;
4686         case SUB:
4687             return NEG;
4688         case BANG:
4689             return NOT;
4690         case TILDE:
4691             return COMPL;
4692         case PLUSPLUS:
4693             return PREINC;
4694         case SUBSUB:
4695             return PREDEC;
4696         default:
4697             return NO_TAG;
4698         }
4699     }
4700 
4701     /** Return type tag of basic type represented by token,
4702      *  NONE if token is not a basic type identifier.
4703      */
4704     static TypeTag typetag(TokenKind token) {
4705         switch (token) {
4706         case BYTE:
4707             return TypeTag.BYTE;
4708         case CHAR:
4709             return TypeTag.CHAR;
4710         case SHORT:
4711             return TypeTag.SHORT;
4712         case INT:
4713             return TypeTag.INT;
4714         case LONG:
4715             return TypeTag.LONG;
4716         case FLOAT:
4717             return TypeTag.FLOAT;
4718         case DOUBLE:
4719             return TypeTag.DOUBLE;
4720         case BOOLEAN:
4721             return TypeTag.BOOLEAN;
4722         default:
4723             return TypeTag.NONE;
4724         }
4725     }
4726 
4727     void checkSourceLevel(Feature feature) {
4728         checkSourceLevel(token.pos, feature);
4729     }
4730 
4731     protected void checkSourceLevel(int pos, Feature feature) {
4732         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4733             //preview feature without --preview flag, error
4734             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4735         } else if (!feature.allowedInSource(source)) {
4736             //incompatible source level, error
4737             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4738         } else if (preview.isPreview(feature)) {
4739             //use of preview feature, warn
4740             preview.warnPreview(pos, feature);
4741         }
4742     }
4743 
4744     /*
4745      * a functional source tree and end position mappings
4746      */
4747     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4748 
4749         private final IntHashTable endPosMap;
4750 
4751         SimpleEndPosTable(JavacParser parser) {
4752             super(parser);
4753             endPosMap = new IntHashTable();
4754         }
4755 
4756         public void storeEnd(JCTree tree, int endpos) {
4757             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4758                                  endPosMap.lookup(tree));
4759         }
4760 
4761         protected &lt;T extends JCTree&gt; T to(T t) {
4762             storeEnd(t, parser.token.endPos);
4763             return t;
4764         }
4765 
4766         protected &lt;T extends JCTree&gt; T toP(T t) {
4767             storeEnd(t, parser.S.prevToken().endPos);
4768             return t;
4769         }
4770 
4771         public int getEndPos(JCTree tree) {
4772             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4773             // As long as Position.NOPOS==-1, this just returns value.
4774             return (value == -1) ? Position.NOPOS : value;
4775         }
4776 
4777         public int replaceTree(JCTree oldTree, JCTree newTree) {
4778             int pos = endPosMap.remove(oldTree);
4779             if (pos != -1) {
4780                 storeEnd(newTree, pos);
4781                 return pos;
4782             }
4783             return Position.NOPOS;
4784         }
4785     }
4786 
4787     /*
4788      * a default skeletal implementation without any mapping overhead.
4789      */
4790     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4791 
4792         EmptyEndPosTable(JavacParser parser) {
4793             super(parser);
4794         }
4795 
4796         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4797 
4798         protected &lt;T extends JCTree&gt; T to(T t) {
4799             return t;
4800         }
4801 
4802         protected &lt;T extends JCTree&gt; T toP(T t) {
4803             return t;
4804         }
4805 
4806         public int getEndPos(JCTree tree) {
4807             return Position.NOPOS;
4808         }
4809 
4810         public int replaceTree(JCTree oldTree, JCTree newTree) {
4811             return Position.NOPOS;
4812         }
4813 
4814     }
4815 
4816     protected static abstract class AbstractEndPosTable implements EndPosTable {
4817         /**
4818          * The current parser.
4819          */
4820         protected JavacParser parser;
4821 
4822         /**
4823          * Store the last error position.
4824          */
4825         public int errorEndPos = Position.NOPOS;
4826 
4827         public AbstractEndPosTable(JavacParser parser) {
4828             this.parser = parser;
4829         }
4830 
4831         /**
4832          * Store current token&#39;s ending position for a tree, the value of which
4833          * will be the greater of last error position and the ending position of
4834          * the current token.
4835          * @param t The tree.
4836          */
4837         protected abstract &lt;T extends JCTree&gt; T to(T t);
4838 
4839         /**
4840          * Store current token&#39;s ending position for a tree, the value of which
4841          * will be the greater of last error position and the ending position of
4842          * the previous token.
4843          * @param t The tree.
4844          */
4845         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4846 
4847         /**
4848          * Set the error position during the parsing phases, the value of which
4849          * will be set only if it is greater than the last stored error position.
4850          * @param errPos The error position
4851          */
4852         public void setErrorEndPos(int errPos) {
4853             if (errPos &gt; errorEndPos) {
4854                 errorEndPos = errPos;
4855             }
4856         }
4857 
4858         public void setParser(JavacParser parser) {
4859             this.parser = parser;
4860         }
4861     }
4862 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>