<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  32 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  33 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  34 #include &quot;gc/shenandoah/heuristics/shenandoahHeuristics.hpp&quot;
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/idealKit.hpp&quot;
  39 #include &quot;opto/macro.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
  44 
  45 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  46   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  47 }
  48 
  49 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
  50   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),
  51     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {
  52 }
  53 
  54 int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {
  55   return _enqueue_barriers-&gt;length();
  56 }
  57 
  58 ShenandoahEnqueueBarrierNode* ShenandoahBarrierSetC2State::enqueue_barrier(int idx) const {
  59   return _enqueue_barriers-&gt;at(idx);
  60 }
  61 
  62 void ShenandoahBarrierSetC2State::add_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {
  63   assert(!_enqueue_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);
  64   _enqueue_barriers-&gt;append(n);
  65 }
  66 
  67 void ShenandoahBarrierSetC2State::remove_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {
  68   if (_enqueue_barriers-&gt;contains(n)) {
  69     _enqueue_barriers-&gt;remove(n);
  70   }
  71 }
  72 
  73 int ShenandoahBarrierSetC2State::load_reference_barriers_count() const {
  74   return _load_reference_barriers-&gt;length();
  75 }
  76 
  77 ShenandoahLoadReferenceBarrierNode* ShenandoahBarrierSetC2State::load_reference_barrier(int idx) const {
  78   return _load_reference_barriers-&gt;at(idx);
  79 }
  80 
  81 void ShenandoahBarrierSetC2State::add_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {
  82   assert(!_load_reference_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);
  83   _load_reference_barriers-&gt;append(n);
  84 }
  85 
  86 void ShenandoahBarrierSetC2State::remove_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {
  87   if (_load_reference_barriers-&gt;contains(n)) {
  88     _load_reference_barriers-&gt;remove(n);
  89   }
  90 }
  91 
  92 Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {
  93   if (ShenandoahStoreValEnqueueBarrier) {
  94     obj = shenandoah_enqueue_barrier(kit, obj);
  95   }
  96   return obj;
  97 }
  98 
  99 #define __ kit-&gt;
 100 
 101 bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
 102                                                          BasicType bt, uint adr_idx) const {
 103   intptr_t offset = 0;
 104   Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 105   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);
 106 
 107   if (offset == Type::OffsetBot) {
 108     return false; // cannot unalias unless there are precise offsets
 109   }
 110 
 111   if (alloc == NULL) {
 112     return false; // No allocation found
 113   }
 114 
 115   intptr_t size_in_bytes = type2aelembytes(bt);
 116 
 117   Node* mem = __ memory(adr_idx); // start searching here...
 118 
 119   for (int cnt = 0; cnt &lt; 50; cnt++) {
 120 
 121     if (mem-&gt;is_Store()) {
 122 
 123       Node* st_adr = mem-&gt;in(MemNode::Address);
 124       intptr_t st_offset = 0;
 125       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 126 
 127       if (st_base == NULL) {
 128         break; // inscrutable pointer
 129       }
 130 
 131       // Break we have found a store with same base and offset as ours so break
 132       if (st_base == base &amp;&amp; st_offset == offset) {
 133         break;
 134       }
 135 
 136       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 137         const int MAX_STORE = BytesPerLong;
 138         if (st_offset &gt;= offset + size_in_bytes ||
 139             st_offset &lt;= offset - MAX_STORE ||
 140             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 141           // Success:  The offsets are provably independent.
 142           // (You may ask, why not just test st_offset != offset and be done?
 143           // The answer is that stores of different sizes can co-exist
 144           // in the same sequence of RawMem effects.  We sometimes initialize
 145           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 146           mem = mem-&gt;in(MemNode::Memory);
 147           continue; // advance through independent store memory
 148         }
 149       }
 150 
 151       if (st_base != base
 152           &amp;&amp; MemNode::detect_ptr_independence(base, alloc, st_base,
 153                                               AllocateNode::Ideal_allocation(st_base, phase),
 154                                               phase)) {
 155         // Success:  The bases are provably independent.
 156         mem = mem-&gt;in(MemNode::Memory);
 157         continue; // advance through independent store memory
 158       }
 159     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 160 
 161       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 162       AllocateNode* st_alloc = st_init-&gt;allocation();
 163 
 164       // Make sure that we are looking at the same allocation site.
 165       // The alloc variable is guaranteed to not be null here from earlier check.
 166       if (alloc == st_alloc) {
 167         // Check that the initialization is storing NULL so that no previous store
 168         // has been moved up and directly write a reference
 169         Node* captured_store = st_init-&gt;find_captured_store(offset,
 170                                                             type2aelembytes(T_OBJECT),
 171                                                             phase);
 172         if (captured_store == NULL || captured_store == st_init-&gt;zero_memory()) {
 173           return true;
 174         }
 175       }
 176     }
 177 
 178     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 179     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 180     break;
 181   }
 182 
 183   return false;
 184 }
 185 
 186 #undef __
 187 #define __ ideal.
 188 
 189 void ShenandoahBarrierSetC2::satb_write_barrier_pre(GraphKit* kit,
 190                                                     bool do_load,
 191                                                     Node* obj,
 192                                                     Node* adr,
 193                                                     uint alias_idx,
 194                                                     Node* val,
 195                                                     const TypeOopPtr* val_type,
 196                                                     Node* pre_val,
 197                                                     BasicType bt) const {
 198   // Some sanity checks
 199   // Note: val is unused in this routine.
 200 
 201   if (do_load) {
 202     // We need to generate the load of the previous value
 203     assert(obj != NULL, &quot;must have a base&quot;);
 204     assert(adr != NULL, &quot;where are loading from?&quot;);
 205     assert(pre_val == NULL, &quot;loaded already?&quot;);
 206     assert(val_type != NULL, &quot;need a type&quot;);
 207 
 208     if (ReduceInitialCardMarks
 209         &amp;&amp; satb_can_remove_pre_barrier(kit, &amp;kit-&gt;gvn(), adr, bt, alias_idx)) {
 210       return;
 211     }
 212 
 213   } else {
 214     // In this case both val_type and alias_idx are unused.
 215     assert(pre_val != NULL, &quot;must be loaded already&quot;);
 216     // Nothing to be done if pre_val is null.
 217     if (pre_val-&gt;bottom_type() == TypePtr::NULL_PTR) return;
 218     assert(pre_val-&gt;bottom_type()-&gt;basic_type() == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 219   }
 220   assert(bt == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 221 
 222   IdealKit ideal(kit, true);
 223 
 224   Node* tls = __ thread(); // ThreadLocalStorage
 225 
 226   Node* no_base = __ top();
 227   Node* zero  = __ ConI(0);
 228   Node* zeroX = __ ConX(0);
 229 
 230   float likely  = PROB_LIKELY(0.999);
 231   float unlikely  = PROB_UNLIKELY(0.999);
 232 
 233   // Offsets into the thread
 234   const int index_offset   = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
 235   const int buffer_offset  = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
 236 
 237   // Now the actual pointers into the thread
 238   Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));
 239   Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));
 240 
 241   // Now some of the values
 242   Node* marking;
 243   Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
 244   Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
 245   marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
 246   assert(ShenandoahBarrierC2Support::is_gc_state_load(ld), &quot;Should match the shape&quot;);
 247 
 248   // if (!marking)
 249   __ if_then(marking, BoolTest::ne, zero, unlikely); {
 250     BasicType index_bt = TypeX_X-&gt;basic_type();
 251     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
 252     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
 253 
 254     if (do_load) {
 255       // load original value
 256       // alias_idx correct??
 257       pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
 258     }
 259 
 260     // if (pre_val != NULL)
 261     __ if_then(pre_val, BoolTest::ne, kit-&gt;null()); {
 262       Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);
 263 
 264       // is the queue for this thread full?
 265       __ if_then(index, BoolTest::ne, zeroX, likely); {
 266 
 267         // decrement the index
 268         Node* next_index = kit-&gt;gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));
 269 
 270         // Now get the buffer location we will log the previous value into and store it
 271         Node *log_addr = __ AddP(no_base, buffer, next_index);
 272         __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);
 273         // update the index
 274         __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);
 275 
 276       } __ else_(); {
 277 
 278         // logging buffer is full, call the runtime
 279         const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();
 280         __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, pre_val, tls);
 281       } __ end_if();  // (!index)
 282     } __ end_if();  // (pre_val != NULL)
 283   } __ end_if();  // (!marking)
 284 
 285   // Final sync IdealKit and GraphKit.
 286   kit-&gt;final_sync(ideal);
 287 
 288   if (ShenandoahSATBBarrier &amp;&amp; adr != NULL) {
 289     Node* c = kit-&gt;control();
 290     Node* call = c-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(0);
 291     assert(is_shenandoah_wb_pre_call(call), &quot;shenandoah_wb_pre call expected&quot;);
 292     call-&gt;add_req(adr);
 293   }
 294 }
 295 
 296 bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
 297   return call-&gt;is_CallLeaf() &amp;&amp;
 298          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
 299 }
 300 
 301 bool ShenandoahBarrierSetC2::is_shenandoah_lrb_call(Node* call) {
 302   if (!call-&gt;is_CallLeaf()) {
 303     return false;
 304   }
 305 
 306   address entry_point = call-&gt;as_CallLeaf()-&gt;entry_point();
 307   return (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier)) ||
 308          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow)) ||
 309          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));
 310 }
 311 
 312 bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
 313   if (n-&gt;Opcode() != Op_If) {
 314     return false;
 315   }
 316 
 317   Node* bol = n-&gt;in(1);
 318   assert(bol-&gt;is_Bool(), &quot;&quot;);
 319   Node* cmpx = bol-&gt;in(1);
 320   if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 321       cmpx-&gt;is_Cmp() &amp;&amp; cmpx-&gt;in(2) == phase-&gt;intcon(0) &amp;&amp;
 322       is_shenandoah_state_load(cmpx-&gt;in(1)-&gt;in(1)) &amp;&amp;
 323       cmpx-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp;
 324       cmpx-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(ShenandoahHeap::MARKING)) {
 325     return true;
 326   }
 327 
 328   return false;
 329 }
 330 
 331 bool ShenandoahBarrierSetC2::is_shenandoah_state_load(Node* n) {
 332   if (!n-&gt;is_Load()) return false;
 333   const int state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());
 334   return n-&gt;in(2)-&gt;is_AddP() &amp;&amp; n-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
 335          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;is_Con()
 336          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == state_offset;
 337 }
 338 
 339 void ShenandoahBarrierSetC2::shenandoah_write_barrier_pre(GraphKit* kit,
 340                                                           bool do_load,
 341                                                           Node* obj,
 342                                                           Node* adr,
 343                                                           uint alias_idx,
 344                                                           Node* val,
 345                                                           const TypeOopPtr* val_type,
 346                                                           Node* pre_val,
 347                                                           BasicType bt) const {
 348   if (ShenandoahSATBBarrier) {
 349     IdealKit ideal(kit);
 350     kit-&gt;sync_kit(ideal);
 351 
 352     satb_write_barrier_pre(kit, do_load, obj, adr, alias_idx, val, val_type, pre_val, bt);
 353 
 354     ideal.sync_kit(kit);
 355     kit-&gt;final_sync(ideal);
 356   }
 357 }
 358 
 359 Node* ShenandoahBarrierSetC2::shenandoah_enqueue_barrier(GraphKit* kit, Node* pre_val) const {
 360   return kit-&gt;gvn().transform(new ShenandoahEnqueueBarrierNode(pre_val));
 361 }
 362 
 363 // Helper that guards and inserts a pre-barrier.
 364 void ShenandoahBarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,
 365                                                 Node* pre_val, bool need_mem_bar) const {
 366   // We could be accessing the referent field of a reference object. If so, when G1
 367   // is enabled, we need to log the value in the referent field in an SATB buffer.
 368   // This routine performs some compile time filters and generates suitable
 369   // runtime filters that guard the pre-barrier code.
 370   // Also add memory barrier for non volatile load from the referent field
 371   // to prevent commoning of loads across safepoint.
 372 
 373   // Some compile time checks.
 374 
 375   // If offset is a constant, is it java_lang_ref_Reference::_reference_offset?
 376   const TypeX* otype = offset-&gt;find_intptr_t_type();
 377   if (otype != NULL &amp;&amp; otype-&gt;is_con() &amp;&amp;
 378       otype-&gt;get_con() != java_lang_ref_Reference::referent_offset) {
 379     // Constant offset but not the reference_offset so just return
 380     return;
 381   }
 382 
 383   // We only need to generate the runtime guards for instances.
 384   const TypeOopPtr* btype = base_oop-&gt;bottom_type()-&gt;isa_oopptr();
 385   if (btype != NULL) {
 386     if (btype-&gt;isa_aryptr()) {
 387       // Array type so nothing to do
 388       return;
 389     }
 390 
 391     const TypeInstPtr* itype = btype-&gt;isa_instptr();
 392     if (itype != NULL) {
 393       // Can the klass of base_oop be statically determined to be
 394       // _not_ a sub-class of Reference and _not_ Object?
 395       ciKlass* klass = itype-&gt;klass();
 396       if ( klass-&gt;is_loaded() &amp;&amp;
 397           !klass-&gt;is_subtype_of(kit-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 398           !kit-&gt;env()-&gt;Object_klass()-&gt;is_subtype_of(klass)) {
 399         return;
 400       }
 401     }
 402   }
 403 
 404   // The compile time filters did not reject base_oop/offset so
 405   // we need to generate the following runtime filters
 406   //
 407   // if (offset == java_lang_ref_Reference::_reference_offset) {
 408   //   if (instance_of(base, java.lang.ref.Reference)) {
 409   //     pre_barrier(_, pre_val, ...);
 410   //   }
 411   // }
 412 
 413   float likely   = PROB_LIKELY(  0.999);
 414   float unlikely = PROB_UNLIKELY(0.999);
 415 
 416   IdealKit ideal(kit);
 417 
 418   Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset);
 419 
 420   __ if_then(offset, BoolTest::eq, referent_off, unlikely); {
 421       // Update graphKit memory and control from IdealKit.
 422       kit-&gt;sync_kit(ideal);
 423 
 424       Node* ref_klass_con = kit-&gt;makecon(TypeKlassPtr::make(kit-&gt;env()-&gt;Reference_klass()));
 425       Node* is_instof = kit-&gt;gen_instanceof(base_oop, ref_klass_con);
 426 
 427       // Update IdealKit memory and control from graphKit.
 428       __ sync_kit(kit);
 429 
 430       Node* one = __ ConI(1);
 431       // is_instof == 0 if base_oop == NULL
 432       __ if_then(is_instof, BoolTest::eq, one, unlikely); {
 433 
 434         // Update graphKit from IdeakKit.
 435         kit-&gt;sync_kit(ideal);
 436 
 437         // Use the pre-barrier to record the value in the referent field
 438         satb_write_barrier_pre(kit, false /* do_load */,
 439                                NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 440                                pre_val /* pre_val */,
 441                                T_OBJECT);
 442         if (need_mem_bar) {
 443           // Add memory barrier to prevent commoning reads from this field
 444           // across safepoint since GC can change its value.
 445           kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 446         }
 447         // Update IdealKit from graphKit.
 448         __ sync_kit(kit);
 449 
 450       } __ end_if(); // _ref_type != ref_none
 451   } __ end_if(); // offset == referent_offset
 452 
 453   // Final sync IdealKit and GraphKit.
 454   kit-&gt;final_sync(ideal);
 455 }
 456 
 457 #undef __
 458 
 459 const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {
 460   const Type **fields = TypeTuple::fields(2);
 461   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 462   fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
 463   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 464 
 465   // create result type (range)
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {
 485   const Type **fields = TypeTuple::fields(2);
 486   fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM; // original field value
 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // original load address
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
 493   fields[TypeFunc::Parms+0] = TypeOopPtr::BOTTOM;
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 514     GraphKit* kit = parse_access.kit();
 515 
 516     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 517     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 518     Node* value = val.node();
 519     value = shenandoah_storeval_barrier(kit, value);
 520     val.set_node(value);
 521     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 522                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 523   } else {
 524     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 525     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 526     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 527     PhaseGVN&amp; gvn =  opt_access.gvn();
 528 
 529     if (ShenandoahStoreValEnqueueBarrier) {
 530       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));
 531       val.set_node(enqueue);
 532     }
 533   }
 534   return BarrierSetC2::store_at_resolved(access, val);
 535 }
 536 
 537 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 538   // 1: non-reference load, no additional barrier is needed
 539   if (!access.is_oop()) {
 540     return BarrierSetC2::load_at_resolved(access, val_type);;
 541   }
 542 
 543   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
 544   DecoratorSet decorators = access.decorators();
 545   BasicType type = access.type();
 546 
 547   // 2: apply LRB if needed
 548   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {
 549     load = new ShenandoahLoadReferenceBarrierNode(NULL,
 550                                                   load,
 551                                                   ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));
 552     if (access.is_parse_access()) {
 553       load = static_cast&lt;C2ParseAccess &amp;&gt;(access).kit()-&gt;gvn().transform(load);
 554     } else {
 555       load = static_cast&lt;C2OptAccess &amp;&gt;(access).gvn().transform(load);
 556     }
 557   }
 558 
 559   // 3: apply keep-alive barrier if needed
 560   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {
 561     Node* top = Compile::current()-&gt;top();
 562     Node* adr = access.addr().node();
 563     Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;
 564     Node* obj = access.base();
 565 
 566     bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 567     bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;
 568     bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0;
 569 
 570     // If we are reading the value of the referent field of a Reference
 571     // object (either by using Unsafe directly or through reflection)
 572     // then, if SATB is enabled, we need to record the referent in an
 573     // SATB log buffer using the pre-barrier mechanism.
 574     // Also we need to add memory barrier to prevent commoning reads
 575     // from this field across safepoint since GC can change its value.
 576     if (!on_weak_ref || (unknown &amp;&amp; (offset == top || obj == top)) || !keep_alive) {
 577       return load;
 578     }
 579 
 580     assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);
 581     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 582     GraphKit* kit = parse_access.kit();
 583     bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
 584     bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;
 585     bool in_native = (decorators &amp; IN_NATIVE) != 0;
 586     bool need_cpu_mem_bar = !is_unordered || mismatched || in_native;
 587 
 588     if (on_weak_ref) {
 589       // Use the pre-barrier to record the value in the referent field
 590       satb_write_barrier_pre(kit, false /* do_load */,
 591                              NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 592                              load /* pre_val */, T_OBJECT);
 593       // Add memory barrier to prevent commoning reads from this field
 594       // across safepoint since GC can change its value.
 595       kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 596     } else if (unknown) {
 597       // We do not require a mem bar inside pre_barrier if need_mem_bar
 598       // is set: the barriers would be emitted by us.
 599       insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);
 600     }
 601   }
 602 
 603   return load;
 604 }
 605 
 606 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 607                                                    Node* new_val, const Type* value_type) const {
 608   GraphKit* kit = access.kit();
 609   if (access.is_oop()) {
 610     new_val = shenandoah_storeval_barrier(kit, new_val);
 611     shenandoah_write_barrier_pre(kit, false /* do_load */,
 612                                  NULL, NULL, max_juint, NULL, NULL,
 613                                  expected_val /* pre_val */, T_OBJECT);
 614 
 615     MemNode::MemOrd mo = access.mem_node_mo();
 616     Node* mem = access.memory();
 617     Node* adr = access.addr().node();
 618     const TypePtr* adr_type = access.addr().type();
 619     Node* load_store = NULL;
 620 
 621 #ifdef _LP64
 622     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 623       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 624       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 625       if (ShenandoahCASBarrier) {
 626         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 627       } else {
 628         load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 629       }
 630     } else
 631 #endif
 632     {
 633       if (ShenandoahCASBarrier) {
 634         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 635       } else {
 636         load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 637       }
 638     }
 639 
 640     access.set_raw_access(load_store);
 641     pin_atomic_op(access);
 642 
 643 #ifdef _LP64
 644     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 645       load_store = kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));
 646     }
 647 #endif
 648     load_store = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, false));
 649     return load_store;
 650   }
 651   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
 652 }
 653 
 654 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 655                                                               Node* new_val, const Type* value_type) const {
 656   GraphKit* kit = access.kit();
 657   if (access.is_oop()) {
 658     new_val = shenandoah_storeval_barrier(kit, new_val);
 659     shenandoah_write_barrier_pre(kit, false /* do_load */,
 660                                  NULL, NULL, max_juint, NULL, NULL,
 661                                  expected_val /* pre_val */, T_OBJECT);
 662     DecoratorSet decorators = access.decorators();
 663     MemNode::MemOrd mo = access.mem_node_mo();
 664     Node* mem = access.memory();
 665     bool is_weak_cas = (decorators &amp; C2_WEAK_CMPXCHG) != 0;
 666     Node* load_store = NULL;
 667     Node* adr = access.addr().node();
 668 #ifdef _LP64
 669     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 670       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 671       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 672       if (ShenandoahCASBarrier) {
 673         if (is_weak_cas) {
 674           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 675         } else {
 676           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 677         }
 678       } else {
 679         if (is_weak_cas) {
 680           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 681         } else {
 682           load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 683         }
 684       }
 685     } else
 686 #endif
 687     {
 688       if (ShenandoahCASBarrier) {
 689         if (is_weak_cas) {
 690           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 691         } else {
 692           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 693         }
 694       } else {
 695         if (is_weak_cas) {
 696           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 697         } else {
 698           load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 699         }
 700       }
 701     }
 702     access.set_raw_access(load_store);
 703     pin_atomic_op(access);
 704     return load_store;
 705   }
 706   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 707 }
 708 
 709 Node* ShenandoahBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* val, const Type* value_type) const {
 710   GraphKit* kit = access.kit();
 711   if (access.is_oop()) {
 712     val = shenandoah_storeval_barrier(kit, val);
 713   }
 714   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
 715   if (access.is_oop()) {
 716     result = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, false));
 717     shenandoah_write_barrier_pre(kit, false /* do_load */,
 718                                  NULL, NULL, max_juint, NULL, NULL,
 719                                  result /* pre_val */, T_OBJECT);
 720   }
 721   return result;
 722 }
 723 
 724 // Support for GC barriers emitted during parsing
 725 bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
 726   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;
 727   if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
 728     return false;
 729   }
 730   CallLeafNode *call = node-&gt;as_CallLeaf();
 731   if (call-&gt;_name == NULL) {
 732     return false;
 733   }
 734 
 735   return strcmp(call-&gt;_name, &quot;shenandoah_clone_barrier&quot;) == 0 ||
 736          strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
 737          strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
 738 }
 739 
 740 Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
 741   if (c == NULL) {
 742     return c;
 743   }
 744   if (c-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 745     return c-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
 746   }
 747   if (c-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 748     c = c-&gt;in(1);
 749   }
 750   return c;
 751 }
 752 
 753 bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
 754   return !ShenandoahBarrierC2Support::expand(C, igvn);
 755 }
 756 
 757 bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
 758   if (mode == LoopOptsShenandoahExpand) {
 759     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 760     ShenandoahBarrierC2Support::pin_and_expand(phase);
 761     return true;
 762   } else if (mode == LoopOptsShenandoahPostExpand) {
 763     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 764     visited.clear();
 765     ShenandoahBarrierC2Support::optimize_after_expansion(visited, nstack, worklist, phase);
 766     return true;
 767   }
 768   return false;
 769 }
 770 
 771 bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
 772   bool is_oop = is_reference_type(type);
 773   if (!is_oop) {
 774     return false;
 775   }
 776   if (ShenandoahSATBBarrier &amp;&amp; tightly_coupled_alloc) {
 777     if (phase == Optimization) {
 778       return false;
 779     }
 780     return !is_clone;
 781   }
 782   if (phase == Optimization) {
 783     return !ShenandoahStoreValEnqueueBarrier;
 784   }
 785   return true;
 786 }
 787 
 788 bool ShenandoahBarrierSetC2::clone_needs_barrier(Node* src, PhaseGVN&amp; gvn) {
 789   const TypeOopPtr* src_type = gvn.type(src)-&gt;is_oopptr();
 790   if (src_type-&gt;isa_instptr() != NULL) {
 791     ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
 792     if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
 793       if (ik-&gt;has_object_fields()) {
 794         return true;
 795       } else {
 796         if (!src_type-&gt;klass_is_exact()) {
 797           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);
 798         }
 799       }
 800     } else {
 801       return true;
 802         }
 803   } else if (src_type-&gt;isa_aryptr()) {
 804     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 805     if (is_reference_type(src_elem)) {
 806       return true;
 807     }
 808   } else {
 809     return true;
 810   }
 811   return false;
 812 }
 813 
 814 void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
 815   Node* ctrl = ac-&gt;in(TypeFunc::Control);
 816   Node* mem = ac-&gt;in(TypeFunc::Memory);
 817   Node* src_base = ac-&gt;in(ArrayCopyNode::Src);
 818   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
 819   Node* dest_base = ac-&gt;in(ArrayCopyNode::Dest);
 820   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
 821   Node* length = ac-&gt;in(ArrayCopyNode::Length);
 822 
 823   Node* src = phase-&gt;basic_plus_adr(src_base, src_offset);
 824   Node* dest = phase-&gt;basic_plus_adr(dest_base, dest_offset);
 825 
 826   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {
 827     // Check if heap is has forwarded objects. If it does, we need to call into the special
 828     // routine that would fix up source references before we can continue.
 829 
 830     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
 831     Node* region = new RegionNode(PATH_LIMIT);
 832     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);
 833 
 834     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());
 835     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 836     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));
 837 
 838     uint gc_state_idx = Compile::AliasIdxRaw;
 839     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 840     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 841 
 842     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));
 843     int flags = ShenandoahHeap::HAS_FORWARDED;
 844     if (ShenandoahStoreValEnqueueBarrier) {
 845       flags |= ShenandoahHeap::MARKING;
 846     }
 847     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(flags)));
 848     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));
 849     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));
 850 
 851     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();
 852     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));
 853     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));
 854 
 855     // Heap is stable, no need to do anything additional
 856     region-&gt;init_req(_heap_stable, stable_ctrl);
 857     mem_phi-&gt;init_req(_heap_stable, mem);
 858 
 859     // Heap is unstable, call into clone barrier stub
 860     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,
 861                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),
 862                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),
 863                     &quot;shenandoah_clone&quot;,
 864                     TypeRawPtr::BOTTOM,
 865                     src_base);
 866     call = phase-&gt;transform_later(call);
 867 
 868     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));
 869     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));
 870     region-&gt;init_req(_heap_unstable, ctrl);
 871     mem_phi-&gt;init_req(_heap_unstable, mem);
 872 
 873     // Wire up the actual arraycopy stub now
 874     ctrl = phase-&gt;transform_later(region);
 875     mem = phase-&gt;transform_later(mem_phi);
 876 
 877     const char* name = &quot;arraycopy&quot;;
 878     call = phase-&gt;make_leaf_call(ctrl, mem,
 879                                  OptoRuntime::fast_arraycopy_Type(),
 880                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),
 881                                  name, TypeRawPtr::BOTTOM,
 882                                  src, dest, length
 883                                  LP64_ONLY(COMMA phase-&gt;top()));
 884     call = phase-&gt;transform_later(call);
 885 
 886     // Hook up the whole thing into the graph
 887     phase-&gt;igvn().replace_node(ac, call);
 888   } else {
 889     BarrierSetC2::clone_at_expansion(phase, ac);
 890   }
 891 }
 892 
 893 
 894 // Support for macro expanded GC barriers
 895 void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
 896   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 897     state()-&gt;add_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);
 898   }
 899   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 900     state()-&gt;add_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);
 901   }
 902 }
 903 
 904 void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
 905   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 906     state()-&gt;remove_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);
 907   }
 908   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 909     state()-&gt;remove_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);
 910   }
 911 }
 912 
 913 void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
 914   if (is_shenandoah_wb_pre_call(n)) {
 915     shenandoah_eliminate_wb_pre(n, &amp;macro-&gt;igvn());
 916   }
 917 }
 918 
 919 void ShenandoahBarrierSetC2::shenandoah_eliminate_wb_pre(Node* call, PhaseIterGVN* igvn) const {
 920   assert(UseShenandoahGC &amp;&amp; is_shenandoah_wb_pre_call(call), &quot;&quot;);
 921   Node* c = call-&gt;as_Call()-&gt;proj_out(TypeFunc::Control);
 922   c = c-&gt;unique_ctrl_out();
 923   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 924   c = c-&gt;unique_ctrl_out();
 925   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 926   Node* iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 927   assert(iff-&gt;is_If(), &quot;expect test&quot;);
 928   if (!is_shenandoah_marking_if(igvn, iff)) {
 929     c = c-&gt;unique_ctrl_out();
 930     assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 931     iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 932     assert(is_shenandoah_marking_if(igvn, iff), &quot;expect marking test&quot;);
 933   }
 934   Node* cmpx = iff-&gt;in(1)-&gt;in(1);
 935   igvn-&gt;replace_node(cmpx, igvn-&gt;makecon(TypeInt::CC_EQ));
 936   igvn-&gt;rehash_node_delayed(call);
 937   call-&gt;del_req(call-&gt;req()-1);
 938 }
 939 
 940 void ShenandoahBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
 941   if (node-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(node)) {
 942     igvn-&gt;add_users_to_worklist(node);
 943   }
 944 }
 945 
 946 void ShenandoahBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
 947   for (uint i = 0; i &lt; useful.size(); i++) {
 948     Node* n = useful.at(i);
 949     if (n-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(n)) {
 950       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 951         C-&gt;record_for_igvn(n-&gt;fast_out(i));
 952       }
 953     }
 954   }
 955   for (int i = state()-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {
 956     ShenandoahEnqueueBarrierNode* n = state()-&gt;enqueue_barrier(i);
 957     if (!useful.member(n)) {
 958       state()-&gt;remove_enqueue_barrier(n);
 959     }
 960   }
 961   for (int i = state()-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
 962     ShenandoahLoadReferenceBarrierNode* n = state()-&gt;load_reference_barrier(i);
 963     if (!useful.member(n)) {
 964       state()-&gt;remove_load_reference_barrier(n);
 965     }
 966   }
 967 }
 968 
 969 void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
 970   return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
 971 }
 972 
 973 ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
 974   return reinterpret_cast&lt;ShenandoahBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
 975 }
 976 
 977 // If the BarrierSetC2 state has kept macro nodes in its compilation unit state to be
 978 // expanded later, then now is the time to do so.
 979 bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
 980 
 981 #ifdef ASSERT
 982 void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
 983   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeMacroExpand) {
 984     ShenandoahBarrierC2Support::verify(Compile::current()-&gt;root());
 985   } else if (phase == BarrierSetC2::BeforeCodeGen) {
 986     // Verify G1 pre-barriers
 987     const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
 988 
 989     ResourceArea *area = Thread::current()-&gt;resource_area();
 990     Unique_Node_List visited(area);
 991     Node_List worklist(area);
 992     // We&#39;re going to walk control flow backwards starting from the Root
 993     worklist.push(compile-&gt;root());
 994     while (worklist.size() &gt; 0) {
 995       Node *x = worklist.pop();
 996       if (x == NULL || x == compile-&gt;top()) continue;
 997       if (visited.member(x)) {
 998         continue;
 999       } else {
1000         visited.push(x);
1001       }
1002 
1003       if (x-&gt;is_Region()) {
1004         for (uint i = 1; i &lt; x-&gt;req(); i++) {
1005           worklist.push(x-&gt;in(i));
1006         }
1007       } else {
1008         worklist.push(x-&gt;in(0));
1009         // We are looking for the pattern:
1010         //                            /-&gt;ThreadLocal
1011         // If-&gt;Bool-&gt;CmpI-&gt;LoadB-&gt;AddP-&gt;ConL(marking_offset)
1012         //              \-&gt;ConI(0)
1013         // We want to verify that the If and the LoadB have the same control
1014         // See GraphKit::g1_write_barrier_pre()
1015         if (x-&gt;is_If()) {
1016           IfNode *iff = x-&gt;as_If();
1017           if (iff-&gt;in(1)-&gt;is_Bool() &amp;&amp; iff-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1018             CmpNode *cmp = iff-&gt;in(1)-&gt;in(1)-&gt;as_Cmp();
1019             if (cmp-&gt;Opcode() == Op_CmpI &amp;&amp; cmp-&gt;in(2)-&gt;is_Con() &amp;&amp; cmp-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0
1020                 &amp;&amp; cmp-&gt;in(1)-&gt;is_Load()) {
1021               LoadNode *load = cmp-&gt;in(1)-&gt;as_Load();
1022               if (load-&gt;Opcode() == Op_LoadB &amp;&amp; load-&gt;in(2)-&gt;is_AddP() &amp;&amp; load-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
1023                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;is_Con()
1024                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == marking_offset) {
1025 
1026                 Node *if_ctrl = iff-&gt;in(0);
1027                 Node *load_ctrl = load-&gt;in(0);
1028 
1029                 if (if_ctrl != load_ctrl) {
1030                   // Skip possible CProj-&gt;NeverBranch in infinite loops
1031                   if ((if_ctrl-&gt;is_Proj() &amp;&amp; if_ctrl-&gt;Opcode() == Op_CProj)
1032                       &amp;&amp; (if_ctrl-&gt;in(0)-&gt;is_MultiBranch() &amp;&amp; if_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch)) {
1033                     if_ctrl = if_ctrl-&gt;in(0)-&gt;in(0);
1034                   }
1035                 }
1036                 assert(load_ctrl != NULL &amp;&amp; if_ctrl == load_ctrl, &quot;controls must match&quot;);
1037               }
1038             }
1039           }
1040         }
1041       }
1042     }
1043   }
1044 }
1045 #endif
1046 
1047 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1048   if (is_shenandoah_wb_pre_call(n)) {
1049     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1050     if (n-&gt;req() &gt; cnt) {
1051       Node* addp = n-&gt;in(cnt);
1052       if (has_only_shenandoah_wb_pre_uses(addp)) {
1053         n-&gt;del_req(cnt);
1054         if (can_reshape) {
1055           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1056         }
1057         return n;
1058       }
1059     }
1060   }
1061   if (n-&gt;Opcode() == Op_CmpP) {
1062     Node* in1 = n-&gt;in(1);
1063     Node* in2 = n-&gt;in(2);
1064     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {
1065       in2 = step_over_gc_barrier(in2);
1066     }
1067     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {
1068       in1 = step_over_gc_barrier(in1);
1069     }
1070     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1071     if (in1 != n-&gt;in(1)) {
1072       if (igvn != NULL) {
1073         n-&gt;set_req_X(1, in1, igvn);
1074       } else {
1075         n-&gt;set_req(1, in1);
1076       }
1077       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);
1078       return n;
1079     }
1080     if (in2 != n-&gt;in(2)) {
1081       if (igvn != NULL) {
1082         n-&gt;set_req_X(2, in2, igvn);
1083       } else {
1084         n-&gt;set_req(2, in2);
1085       }
1086       return n;
1087     }
1088   } else if (can_reshape &amp;&amp;
1089              n-&gt;Opcode() == Op_If &amp;&amp;
1090              ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;
1091              n-&gt;in(0) != NULL) {
1092     Node* dom = n-&gt;in(0);
1093     Node* prev_dom = n;
1094     int op = n-&gt;Opcode();
1095     int dist = 16;
1096     // Search up the dominator tree for another heap stable test
1097     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1098            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?
1099            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1100       if (dist &lt; 0) return NULL;
1101 
1102       dist--;
1103       prev_dom = dom;
1104       dom = IfNode::up_one_dom(dom);
1105       if (!dom) return NULL;
1106     }
1107 
1108     // Check that we did not follow a loop back to ourselves
1109     if (n == dom) {
1110       return NULL;
1111     }
1112 
1113     return n-&gt;as_If()-&gt;dominated_by(prev_dom, phase-&gt;is_IterGVN());
1114   }
1115 
1116   return NULL;
1117 }
1118 
1119 bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
1120   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1121     Node* u = n-&gt;fast_out(i);
1122     if (!is_shenandoah_wb_pre_call(u)) {
1123       return false;
1124     }
1125   }
1126   return n-&gt;outcnt() &gt; 0;
1127 }
1128 
1129 bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1130   switch (opcode) {
1131     case Op_CallLeaf:
1132     case Op_CallLeafNoFP: {
1133       assert (n-&gt;is_Call(), &quot;&quot;);
1134       CallNode *call = n-&gt;as_Call();
1135       if (ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(call)) {
1136         uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1137         if (call-&gt;req() &gt; cnt) {
1138           assert(call-&gt;req() == cnt + 1, &quot;only one extra input&quot;);
1139           Node *addp = call-&gt;in(cnt);
1140           assert(!ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(addp), &quot;useless address computation?&quot;);
1141           call-&gt;del_req(cnt);
1142         }
1143       }
1144       return false;
1145     }
1146     case Op_ShenandoahCompareAndSwapP:
1147     case Op_ShenandoahCompareAndSwapN:
1148     case Op_ShenandoahWeakCompareAndSwapN:
1149     case Op_ShenandoahWeakCompareAndSwapP:
1150     case Op_ShenandoahCompareAndExchangeP:
1151     case Op_ShenandoahCompareAndExchangeN:
1152 #ifdef ASSERT
1153       if( VerifyOptoOopOffsets ) {
1154         MemNode* mem  = n-&gt;as_Mem();
1155         // Check to see if address types have grounded out somehow.
1156         const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1157         ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
1158         bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1159         assert( !tp || oop_offset_is_sane, &quot;&quot; );
1160       }
1161 #endif
1162       return true;
1163     case Op_ShenandoahLoadReferenceBarrier:
1164       assert(false, &quot;should have been expanded already&quot;);
1165       return true;
1166     default:
1167       return false;
1168   }
1169 }
1170 
1171 bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1172   switch (opcode) {
1173     case Op_ShenandoahCompareAndExchangeP:
1174     case Op_ShenandoahCompareAndExchangeN:
1175       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1176       // fallthrough
1177     case Op_ShenandoahWeakCompareAndSwapP:
1178     case Op_ShenandoahWeakCompareAndSwapN:
1179     case Op_ShenandoahCompareAndSwapP:
1180     case Op_ShenandoahCompareAndSwapN:
1181       conn_graph-&gt;add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
1182       return true;
1183     case Op_StoreP: {
1184       Node* adr = n-&gt;in(MemNode::Address);
1185       const Type* adr_type = gvn-&gt;type(adr);
1186       // Pointer stores in G1 barriers looks like unsafe access.
1187       // Ignore such stores to be able scalar replace non-escaping
1188       // allocations.
1189       if (adr_type-&gt;isa_rawptr() &amp;&amp; adr-&gt;is_AddP()) {
1190         Node* base = conn_graph-&gt;get_addp_base(adr);
1191         if (base-&gt;Opcode() == Op_LoadP &amp;&amp;
1192           base-&gt;in(MemNode::Address)-&gt;is_AddP()) {
1193           adr = base-&gt;in(MemNode::Address);
1194           Node* tls = conn_graph-&gt;get_addp_base(adr);
1195           if (tls-&gt;Opcode() == Op_ThreadLocal) {
1196              int offs = (int) gvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
1197              const int buf_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1198              if (offs == buf_offset) {
1199                return true; // Pre barrier previous oop value store.
1200              }
1201           }
1202         }
1203       }
1204       return false;
1205     }
1206     case Op_ShenandoahEnqueueBarrier:
1207       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
1208       break;
1209     case Op_ShenandoahLoadReferenceBarrier:
1210       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), delayed_worklist);
1211       return true;
1212     default:
1213       // Nothing
1214       break;
1215   }
1216   return false;
1217 }
1218 
1219 bool ShenandoahBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1220   switch (opcode) {
1221     case Op_ShenandoahCompareAndExchangeP:
1222     case Op_ShenandoahCompareAndExchangeN: {
1223       Node *adr = n-&gt;in(MemNode::Address);
1224       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
1225       // fallthrough
1226     }
1227     case Op_ShenandoahCompareAndSwapP:
1228     case Op_ShenandoahCompareAndSwapN:
1229     case Op_ShenandoahWeakCompareAndSwapP:
1230     case Op_ShenandoahWeakCompareAndSwapN:
1231       return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
1232     case Op_ShenandoahEnqueueBarrier:
1233       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
1234       return true;
1235     case Op_ShenandoahLoadReferenceBarrier:
1236       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), NULL);
1237       return true;
1238     default:
1239       // Nothing
1240       break;
1241   }
1242   return false;
1243 }
1244 
1245 bool ShenandoahBarrierSetC2::escape_has_out_with_unsafe_object(Node* n) const {
1246   return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
1247          n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
1248 
1249 }
1250 
1251 bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
1252   switch (opcode) {
1253     case Op_ShenandoahCompareAndExchangeP:
1254     case Op_ShenandoahCompareAndExchangeN:
1255     case Op_ShenandoahWeakCompareAndSwapP:
1256     case Op_ShenandoahWeakCompareAndSwapN:
1257     case Op_ShenandoahCompareAndSwapP:
1258     case Op_ShenandoahCompareAndSwapN: {   // Convert trinary to binary-tree
1259       Node* newval = n-&gt;in(MemNode::ValueIn);
1260       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
1261       Node* pair = new BinaryNode(oldval, newval);
1262       n-&gt;set_req(MemNode::ValueIn,pair);
1263       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
1264       return true;
1265     }
1266     default:
1267       break;
1268   }
1269   return false;
1270 }
1271 
1272 bool ShenandoahBarrierSetC2::matcher_is_store_load_barrier(Node* x, uint xop) const {
1273   return xop == Op_ShenandoahCompareAndExchangeP ||
1274          xop == Op_ShenandoahCompareAndExchangeN ||
1275          xop == Op_ShenandoahWeakCompareAndSwapP ||
1276          xop == Op_ShenandoahWeakCompareAndSwapN ||
1277          xop == Op_ShenandoahCompareAndSwapN ||
1278          xop == Op_ShenandoahCompareAndSwapP;
1279 }
    </pre>
  </body>
</html>