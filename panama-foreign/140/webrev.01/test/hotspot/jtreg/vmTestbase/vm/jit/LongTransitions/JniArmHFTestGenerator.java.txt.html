<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/vmTestbase/vm/jit/LongTransitions/JniArmHFTestGenerator.java.txt</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* This code generate an LTTest.java and LTTest.c files with corresponding *.cfg files which containt test defenition
 25  * for JNI testing.
 26  *
 27  */
 28 import java.io.File;
 29 import java.io.FileWriter;
 30 import java.io.IOException;
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Random;
 34 
 35 //Java and C file generator for JNI tests
 36 public class JniArmHFTestGenerator {
 37 
 38     private final String JAVA_CLASS_NAME = &quot;LTTest&quot;;
 39     private final String C_FNC_NAME_PREFIX = &quot;Java_vm_jit_LongTransitions_&quot; + JAVA_CLASS_NAME + &quot;_&quot;;
 40     private final String JAVA_PACKAGE_NAME = &quot;vm.jit.LongTransitions&quot;;
 41     private final String TEST_LIST_PREFIX = &quot;vm/jit/LongTransitions&quot;;
 42     private final String TEST_LIST_NAME = &quot;vm.jit.long.testlist&quot;;
 43     //Maximal line length for some SRC generation function
 44     private final int LINE_LENGTH = 70;
 45     //127 is maximal value for JAVA parameters list
 46     private final int PARAMS_COUNTER = 127;
 47     StringBuilder javaFileSrc;
 48     StringBuilder cFileSrc;
 49     //StringBuilder cfgFileSrc;
 50     private String javaTxtFileName;
 51     private String cTxtFileName;
 52     private File outputDir;
 53     private ArrayList&lt;String&gt; javaFncNames = new ArrayList&lt;String&gt;();
 54 
 55     public static void main(String[] args) throws IOException {
 56         new JniArmHFTestGenerator().makeSomeTest();
 57     }
 58 
 59     public void makeSomeTest() throws IOException {
 60 
 61         makeJavaIntro(JAVA_CLASS_NAME);
 62         makeCIntro();
 63         int cnt = PARAMS_COUNTER;
 64 
 65         makeOneTest(cnt, ParamType.EASY_F, TestType.RANDOM, &quot;nativeFnc1&quot;);
 66         makeOneTest(cnt, ParamType.EASY_D, TestType.RANDOM, &quot;nativeFnc2&quot;);
 67         makeOneTest(cnt, ParamType.MIXED_FI1, TestType.RANDOM, &quot;nativeFnc3&quot;);
 68         makeOneTest(cnt, ParamType.MIXED_FB1, TestType.RANDOM, &quot;nativeFnc4&quot;);
 69         makeOneTest(cnt, ParamType.MIXED_FBI1, TestType.RANDOM, &quot;nativeFnc5&quot;);
 70         makeOneTest(cnt, ParamType.MIXED_DI1, TestType.RANDOM, &quot;nativeFnc6&quot;);
 71         makeOneTest(cnt, ParamType.MIXED_DB1, TestType.RANDOM, &quot;nativeFnc7&quot;);
 72         makeOneTest(cnt, ParamType.MIXED_DBI1, TestType.RANDOM, &quot;nativeFnc8&quot;);
 73         makeOneTest(cnt, ParamType.MIXED_DFBI1, TestType.RANDOM, &quot;nativeFnc9&quot;);
 74         makeOneTest(cnt, ParamType.MIXED_DF1, TestType.RANDOM, &quot;nativeFnc10&quot;);
 75         makeOneTest(cnt, ParamType.MIXED_DFI1, TestType.RANDOM, &quot;nativeFnc11&quot;);
 76         makeOneTest(cnt, ParamType.MIXED_DFB1, TestType.RANDOM, &quot;nativeFnc12&quot;);
 77 
 78         makeOneTest(cnt, ParamType.MIXED_FI2, TestType.RANDOM, &quot;nativeFnc13&quot;);
 79         makeOneTest(cnt, ParamType.MIXED_FB2, TestType.RANDOM, &quot;nativeFnc14&quot;);
 80         makeOneTest(cnt, ParamType.MIXED_FBI2, TestType.RANDOM, &quot;nativeFnc15&quot;);
 81         makeOneTest(cnt, ParamType.MIXED_DI2, TestType.RANDOM, &quot;nativeFnc16&quot;);
 82         makeOneTest(cnt, ParamType.MIXED_DB2, TestType.RANDOM, &quot;nativeFnc17&quot;);
 83         makeOneTest(cnt, ParamType.MIXED_DBI2, TestType.RANDOM, &quot;nativeFnc18&quot;);
 84         makeOneTest(cnt, ParamType.MIXED_DFBI2, TestType.RANDOM, &quot;nativeFnc19&quot;);
 85         makeOneTest(cnt, ParamType.MIXED_DF2, TestType.RANDOM, &quot;nativeFnc20&quot;);
 86         makeOneTest(cnt, ParamType.MIXED_DFI2, TestType.RANDOM, &quot;nativeFnc21&quot;);
 87         makeOneTest(cnt, ParamType.MIXED_DFB2, TestType.RANDOM, &quot;nativeFnc22&quot;);
 88 
 89         makeOneTest(cnt, ParamType.MIXED_FI3, TestType.RANDOM, &quot;nativeFnc23&quot;);
 90         makeOneTest(cnt, ParamType.MIXED_FB3, TestType.RANDOM, &quot;nativeFnc24&quot;);
 91         makeOneTest(cnt, ParamType.MIXED_FBI3, TestType.RANDOM, &quot;nativeFnc25&quot;);
 92         makeOneTest(cnt, ParamType.MIXED_DI3, TestType.RANDOM, &quot;nativeFnc26&quot;);
 93         makeOneTest(cnt, ParamType.MIXED_DB3, TestType.RANDOM, &quot;nativeFnc27&quot;);
 94         makeOneTest(cnt, ParamType.MIXED_DBI3, TestType.RANDOM, &quot;nativeFnc28&quot;);
 95         makeOneTest(cnt, ParamType.MIXED_DFBI3, TestType.RANDOM, &quot;nativeFnc29&quot;);
 96         makeOneTest(cnt, ParamType.MIXED_DF3, TestType.RANDOM, &quot;nativeFnc30&quot;);
 97         makeOneTest(cnt, ParamType.MIXED_DFI3, TestType.RANDOM, &quot;nativeFnc31&quot;);
 98         makeOneTest(cnt, ParamType.MIXED_DFB3, TestType.RANDOM, &quot;nativeFnc32&quot;);
 99 
100         makeOneTest(cnt, ParamType.MIXED_FI4, TestType.RANDOM, &quot;nativeFnc33&quot;);
101         makeOneTest(cnt, ParamType.MIXED_FB4, TestType.RANDOM, &quot;nativeFnc34&quot;);
102         makeOneTest(cnt, ParamType.MIXED_FBI4, TestType.RANDOM, &quot;nativeFnc35&quot;);
103         makeOneTest(cnt, ParamType.MIXED_DI4, TestType.RANDOM, &quot;nativeFnc36&quot;);
104         makeOneTest(cnt, ParamType.MIXED_DB4, TestType.RANDOM, &quot;nativeFnc37&quot;);
105         makeOneTest(cnt, ParamType.MIXED_DBI4, TestType.RANDOM, &quot;nativeFnc38&quot;);
106         makeOneTest(cnt, ParamType.MIXED_DFBI4, TestType.RANDOM, &quot;nativeFnc39&quot;);
107         makeOneTest(cnt, ParamType.MIXED_DF4, TestType.RANDOM, &quot;nativeFnc40&quot;);
108         makeOneTest(cnt, ParamType.MIXED_DFI4, TestType.RANDOM, &quot;nativeFnc41&quot;);
109         makeOneTest(cnt, ParamType.MIXED_DFB4, TestType.RANDOM, &quot;nativeFnc42&quot;);
110 
111         makeOneTest(cnt, ParamType.MIXED_FI5, TestType.RANDOM, &quot;nativeFnc43&quot;);
112         makeOneTest(cnt, ParamType.MIXED_FB5, TestType.RANDOM, &quot;nativeFnc44&quot;);
113         makeOneTest(cnt, ParamType.MIXED_FBI5, TestType.RANDOM, &quot;nativeFnc45&quot;);
114         makeOneTest(cnt, ParamType.MIXED_DI5, TestType.RANDOM, &quot;nativeFnc46&quot;);
115         makeOneTest(cnt, ParamType.MIXED_DB5, TestType.RANDOM, &quot;nativeFnc47&quot;);
116         makeOneTest(cnt, ParamType.MIXED_DBI5, TestType.RANDOM, &quot;nativeFnc48&quot;);
117         makeOneTest(cnt, ParamType.MIXED_DFBI5, TestType.RANDOM, &quot;nativeFnc49&quot;);
118         makeOneTest(cnt, ParamType.MIXED_DF5, TestType.RANDOM, &quot;nativeFnc50&quot;);
119         makeOneTest(cnt, ParamType.MIXED_DFI5, TestType.RANDOM, &quot;nativeFnc51&quot;);
120         makeOneTest(cnt, ParamType.MIXED_DFB5, TestType.RANDOM, &quot;nativeFnc52&quot;);
121         makeJavaInvoke();
122         makeJavaOutro();
123 
124         writeToJavaFile(JAVA_CLASS_NAME);
125         writeToCFile(JAVA_CLASS_NAME);
126         //writeCmpFile();
127 
128         writeTestListFile();
129         writeCfgFile();
130     }
131 
132     private void makeJavaInvoke() {
133         appendToJava(&quot;    public static void main(String[] args) throws Exception&quot;);
134         appendToJava(&quot;    {&quot;);
135         appendToJava(&quot;        if ( System.getProperty(\&quot;os.name\&quot;).matches(\&quot;.*[Ww][Ii][Nn].*\&quot;) )&quot;);
136         appendToJava(&quot;        {&quot;);
137         appendToJava(&quot;            System.out.println(\&quot;TEST PASSED! Dummy execution on Windows* OS!\&quot;);&quot;);
138         appendToJava(&quot;            return;&quot;);
139         appendToJava(&quot;        }&quot;);
140 
141         appendToJava(&quot;        deleteFiles();&quot;);
142         appendToJavaN(&quot;        PrintStream ps=new PrintStream(new File(\&quot;&quot;);
143         appendToJavaN(javaTxtFileName);
144         appendToJava(&quot;\&quot;));&quot;);
145 
146         appendToJava(&quot;    if (args.length&gt;0)&quot;);
147         appendToJava(&quot;        switch(args[0])&quot;);
148         appendToJava(&quot;        {&quot;);
149 
150         for (String s : javaFncNames) {
151             appendToJava(&quot;        case \&quot;&quot; + s + &quot;\&quot;:&quot;);
152             appendToJavaN(&quot;            &quot;);
153             appendToJavaN(s);
154             appendToJava(&quot;_invoke(ps);&quot;);
155             appendToJava(&quot;            break;&quot;);
156 
157         }
158         appendToJava(&quot;        default:&quot;);
159         appendToJava(&quot;            throw new Exception(\&quot;FAIL: invalid args!\&quot;);&quot;);
160         appendToJava(&quot;        }&quot;);
161         appendToJava(&quot;        else&quot;);
162         appendToJava(&quot;        {&quot;);
163         appendToJava(&quot;            throw new Exception(\&quot;FAIL: invalid args!\&quot;);&quot;);
164         appendToJava(&quot;        }&quot;);
165 
166 
167     }
168 
169     private void makeCIntro() {
170         //appendToC(&quot; //------------------------C----------------------------&quot;);
171         //appendToC(&quot;#include \&quot;&quot;+className+&quot;.h\&quot;&quot;);
172         appendToC(&quot;#include &lt;jni.h&gt;&quot;);
173         appendToC(&quot;#include &lt;stdio.h&gt;&quot;);
174     }
175 
176     private void makeJavaIntro(String className) {
177 
178         cFileSrc = new StringBuilder();
179         javaFileSrc = new StringBuilder();
180 
181 
182         File outputDirL1 = new File(&quot;vm&quot; + File.separatorChar + &quot;jit&quot; + File.separatorChar + &quot;LongTransitions&quot;);
183         //outputDir=new File(outputDirL1,className);
184         outputDir = outputDirL1;
185         outputDir.mkdirs();
186 
187         javaTxtFileName = className + &quot;_java.txt&quot;;
188         cTxtFileName = className + &quot;_c.txt&quot;;
189 
190         appendToJava(&quot;package &quot; + JAVA_PACKAGE_NAME + &quot;;&quot;);
191         appendToJava(&quot;import java.io.*;&quot;);
192         appendToJava(&quot;import java.util.Random;&quot;);
193         appendToJava(&quot;import jdk.test.lib.Utils;&quot;);
194         appendToJava(&quot;public class &quot; + className);
195         appendToJava(&quot;{&quot;);
196         appendToJava(&quot;    public static boolean flag = false;&quot;);
197         appendToJava(&quot;    static Random rnd;&quot;);
198         appendToJava(&quot;    static{&quot;);
199         appendToJava(&quot;        rnd=Utils.getRandomInstance();&quot;);
200         appendToJava(&quot;        System.loadLibrary(\&quot;&quot; + className + &quot;\&quot;);&quot;);
201         appendToJava(&quot;    }&quot;);
202         //Different randoms
203         appendToJava(&quot;    public static int getRndInt(){return rnd.nextInt(Integer.MAX_VALUE);}&quot;);
204         appendToJava(&quot;    public static float getRndFloat(){return rnd.nextFloat()*Float.MAX_VALUE;}&quot;);
205         appendToJava(&quot;    public static double getRndDouble(){return rnd.nextDouble()*Double.MAX_VALUE;}&quot;);
206         appendToJava(&quot;    public static byte getRndByte(){return (byte)rnd.nextInt(Byte.MAX_VALUE);}&quot;);
207 
208         //deleteFiles method
209         appendToJava(&quot;    private static void deleteFiles()&quot;);
210         appendToJava(&quot;    {&quot;);
211         appendToJavaN(&quot;        File f=new File(\&quot;&quot;);
212         appendToJavaN(javaTxtFileName);
213         appendToJava(&quot;\&quot;);&quot;);
214         appendToJava(&quot;        if ( f.exists())&quot;);
215         appendToJava(&quot;        f.delete();&quot;);
216         appendToJavaN(&quot;        f=new File(\&quot;&quot;);
217         appendToJavaN(cTxtFileName);
218         appendToJava(&quot;\&quot;);&quot;);
219         appendToJava(&quot;        if ( f.exists())&quot;);
220         appendToJava(&quot;         f.delete();&quot;);
221         appendToJava(&quot;    }&quot;);
222     }
223 
224     private void makeJavaOutro() {
225         appendToJava(&quot;        flag=chkFile();&quot;);
226         appendToJava(&quot;        if(!flag)&quot;);
227         appendToJava(&quot;            throw new Exception(\&quot;FAIL:Tests failed!\&quot;); &quot;);
228         appendToJava(&quot;    }&quot;);
229         appendToJava(&quot;    private static boolean chkFile()&quot;);
230         appendToJava(&quot;    {&quot;);
231         appendToJava(&quot;        File javaFile=new File(\&quot;&quot; + javaTxtFileName + &quot;\&quot;);&quot;);
232         appendToJava(&quot;        if (! javaFile.exists())&quot;);
233         appendToJava(&quot;        {&quot;);
234         appendToJava(&quot;            System.out.println(\&quot;FAIL:Failed to open file &quot; + javaTxtFileName + &quot; - file not exists!\&quot;);&quot;);
235         appendToJava(&quot;            return false;&quot;);
236         appendToJava(&quot;        }&quot;);
237         appendToJava(&quot;        File cFile=new File(\&quot;&quot; + cTxtFileName + &quot;\&quot;);&quot;);
238         appendToJava(&quot;        if (! cFile.exists())&quot;);
239         appendToJava(&quot;        {&quot;);
240         appendToJava(&quot;                System.out.println(\&quot;FAIL:Failed to open file &quot; + cTxtFileName + &quot; - file not exists!\&quot;);&quot;);
241         appendToJava(&quot;                return false;&quot;);
242         appendToJava(&quot;        }&quot;);
243         appendToJava(&quot;        if ( cFile.length()!=javaFile.length() )&quot;);
244         appendToJava(&quot;        {&quot;);
245         appendToJava(&quot;            System.out.println(\&quot;FAIL:File length not equal!\&quot;);&quot;);
246         appendToJava(&quot;            return false;&quot;);
247         appendToJava(&quot;        }&quot;);
248         appendToJava(&quot;        long byteCount=cFile.length();&quot;);
249 
250 
251         appendToJava(&quot;        try{&quot;);
252         appendToJava(&quot;            FileInputStream fisC=new FileInputStream(cFile);&quot;);
253         appendToJava(&quot;            FileInputStream fisJava=new FileInputStream(javaFile);&quot;);
254         appendToJava(&quot;            byte[] cData=new byte[fisC.available()];&quot;);
255         appendToJava(&quot;            fisC.read(cData);&quot;);
256         appendToJava(&quot;            byte[] javaData=new byte[fisJava.available()];&quot;);
257         appendToJava(&quot;            fisJava.read(javaData);&quot;);
258 
259         appendToJava(&quot;            for ( int cnt=0;cnt&lt;byteCount;++cnt)&quot;);
260         appendToJava(&quot;            {&quot;);
261         appendToJava(&quot;                if ( cData[cnt]!=javaData[cnt] )&quot;);
262         appendToJava(&quot;                {&quot;);
263         appendToJava(&quot;                    System.out.println(\&quot;FAIL:Test failed! \&quot;+cnt+\&quot; byte are wrong! C file - \&quot; + cData[cnt] + \&quot; Java file - \&quot;+javaData[cnt] );&quot;);
264         appendToJava(&quot;                    return false;&quot;);
265         appendToJava(&quot;                }&quot;);
266         appendToJava(&quot;            }&quot;);
267         appendToJava(&quot;        }&quot;);
268         appendToJava(&quot;        catch (FileNotFoundException ex)&quot;);
269         appendToJava(&quot;        {&quot;);
270         appendToJava(&quot;            System.out.println(\&quot;FAIL:Some of files not found!\&quot;);&quot;);
271         appendToJava(&quot;            return false;&quot;);
272         appendToJava(&quot;        }&quot;);
273         appendToJava(&quot;        catch (IOException ex)&quot;);
274         appendToJava(&quot;        {&quot;);
275         appendToJava(&quot;            System.out.println(\&quot;FAIL:Failed to read files!\&quot;);&quot;);
276         appendToJava(&quot;            return false;&quot;);
277         appendToJava(&quot;        }&quot;);
278         appendToJava(&quot;        System.out.println(\&quot;PASS: all data passed correctly!\&quot;);&quot;);
279         appendToJava(&quot;        return true;&quot;);
280 
281 
282 
283         appendToJava(&quot;    }&quot;);
284 
285         appendToJava(&quot;}&quot;);
286 
287 
288     }
289 
290     private void makeOneTest(int paramCounter, ParamType paramType, TestType testType, String fncName) throws IOException {
291 
292         javaFncNames.add(fncName);
293         SrcGenerator gen = new SrcGenerator(paramCounter, 1, paramType, testType, fncName, LINE_LENGTH);
294         generateJava(gen);
295         generateCpp(gen);
296 
297 
298     }
299 
300     /*
301      * Create Java file containing code to call C native method. Method
302      * arguments list generated randomly.
303      *
304      */
305     private void generateJava(SrcGenerator srcGen) throws IOException {
306 
307         //native method
308         appendToJavaN(&quot;    native public static void &quot; + srcGen.getFncName() + &quot;(&quot;);
309         //appendToJavaN(srcGen.getJParm().toString());
310         appendToJavaN(srcGen.getJParm().toFormatString(&quot;        &quot;, LINE_LENGTH));
311         appendToJava(&quot;    );&quot;);
312         //main
313         //appendToJava(srcGen.getJExecVarCreation());
314         appendToJava(&quot;    private static void &quot; + srcGen.getFncName() + &quot;_invoke(PrintStream ps)&quot;);
315         appendToJava(srcGen.getJExec(&quot;        &quot;));
316     }
317 
318     private void writeToJavaFile(String className) throws IOException {
319 
320         File javaFile = new File(outputDir, className + &quot;.java&quot;);
321         try (FileWriter javaFileWriter = new FileWriter(javaFile)) {
322             javaFileWriter.write(javaFileSrc.toString());
323         }
324     }
325 
326     private void writeToCFile(String className) throws IOException {
327 
328         File cFile = new File(outputDir, className + &quot;.c&quot;);
329         try (FileWriter cFileWriter = new FileWriter(cFile)) {
330             cFileWriter.write(cFileSrc.toString());
331         }
332     }
333 
334     private void writeTestListFile() {
335 
336         StringBuilder cfg = new StringBuilder();
337 
338         for (String fncName : javaFncNames) {
339             cfg.append(TEST_LIST_PREFIX).append(&quot;/&quot;).append(fncName);
340             cfg.append(&quot; &quot;).append(&quot;execute_positive\n&quot;);
341         }
342 
343         File cfgFile = new File(outputDir, TEST_LIST_NAME);
344         try (FileWriter fw = new FileWriter(cfgFile)) {
345             fw.write(cfg.toString());
346         } catch (Exception e) {
347         }
348 
349     }
350 
351     private void writeCfgFile() {
352 
353         for (String fncName : javaFncNames) {
354 
355             StringBuilder cfg = new StringBuilder();
356 
357             cfg.append(&quot;LD_LIBRARY_PATH=${COMMON_LIBS_LOCATION}/lib/${ARCH}/vm/jit/LongTransitions${PS}$LD_LIBRARY_PATH\n&quot;);
358             cfg.append(&quot;export LD_LIBRARY_PATH\n&quot;);
359             cfg.append(&quot;JAVA_OPTS=${JAVA_OPTS} ${JIT_OPTS}\n&quot;);
360             cfg.append(&quot;export JAVA_OPTS\n&quot;);
361             cfg.append(&quot;EXECUTE_CLASS=&quot; + JAVA_PACKAGE_NAME + &quot;.&quot; + JAVA_CLASS_NAME + &quot;\n&quot;);
362             cfg.append(&quot;TEST_ARGS=&quot; + fncName);
363 
364             File tdir = new File(outputDir, fncName);
365             tdir.mkdirs();
366             File cfgFile = new File(tdir, fncName + &quot;.cfg&quot;);
367             try (FileWriter fw = new FileWriter(cfgFile)) {
368                 fw.write(cfg.toString());
369             } catch (Exception e) {
370             }
371         }
372     }
373 
374     /*
375      * Generate C file. This file containing instructions to put passed
376      * arguments into output file for further comparsion with java output *
377      */
378     private void generateCpp(SrcGenerator srcGen) throws IOException {
379 
380         appendToC(&quot;JNIEXPORT void JNICALL &quot; + C_FNC_NAME_PREFIX + srcGen.getFncName() + &quot;(JNIEnv *e, jclass c&quot;);
381         appendToCN(srcGen.getCParm().toFormatString(&quot;    &quot;, LINE_LENGTH));
382         appendToCN(&quot;)&quot;);
383         appendToC(&quot;\n{&quot;);
384 
385         appendToCN(&quot;    FILE *file=fopen(\&quot;&quot;);
386         appendToCN(cTxtFileName);
387         appendToCN(&quot;\&quot;,\&quot;a\&quot;);&quot;);
388 
389         appendToC(srcGen.getCExec(LINE_LENGTH,&quot;    &quot;));
390         appendToC(&quot;    fclose(file);&quot;);
391         appendToC(&quot;}&quot;);
392     }
393 
394     private void appendToJava(String s) {
395         javaFileSrc.append(s);
396         javaFileSrc.append(&quot;\n&quot;);
397         System.out.println(s);
398     }
399 
400     private void appendToJavaN(String s) {
401         javaFileSrc.append(s);
402         System.out.print(s);
403     }
404 
405     private void appendToC(String s) {
406         cFileSrc.append(s);
407         cFileSrc.append(&quot;\n&quot;);
408         System.out.println(s);
409     }
410 
411     private void appendToCN(String s) {
412         cFileSrc.append(s);
413         System.out.print(s);
414 
415     }
416 }
417 
418 enum NumberType {
419 
420     INT(&quot;int &quot;, &quot;getRndInt()&quot;, &quot;jint &quot;, &quot;%d&quot;, &quot;%d&quot;),
421     DOUBLE(&quot;double &quot;, &quot;getRndDouble()&quot;, &quot;jdouble &quot;, &quot;%e&quot;, &quot;%e&quot;),
422     FLOAT(&quot;float &quot;, &quot;getRndFloat()&quot;, &quot;jfloat &quot;, &quot;%e&quot;, &quot;%e&quot;),
423     BYTE(&quot;byte &quot;, &quot;getRndByte()&quot;, &quot;jbyte &quot;, &quot;%d&quot;, &quot;%d&quot;);
424     private String cType;
425     private String jType;
426     private String cConv;
427     private String jConv;
428     private String rndFnc;
429 
430     NumberType(String jType, String rndFnc, String cType, String jConv, String cConv) {
431         this.cType = cType;
432         this.jType = jType;
433         this.cConv = cConv;
434         this.jConv = jConv;
435         this.rndFnc = rndFnc;
436     }
437 
438     public String get小Type() {
439         return cType;
440     }
441 
442     public String getJType() {
443         return jType;
444     }
445 
446     public String get小Conv() {
447         return cConv;
448     }
449 
450     public String getJConv() {
451         return jConv;
452     }
453 
454     public String getFnc() {
455         return rndFnc;
456     }
457 }
458 
459 //Types for testing
460 enum ParamType {
461     //DFBI
462 
463     MIXED_DFBI1(NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
464     MIXED_DFBI2(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
465     MIXED_DFBI3(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
466     MIXED_DFBI4(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
467     MIXED_DFBI5(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
468     //DFB
469     MIXED_DFB1(NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE),
470     MIXED_DFB2(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE),
471     MIXED_DFB3(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE),
472     MIXED_DFB4(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE),
473     MIXED_DFB5(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.BYTE),
474     //DFI
475     MIXED_DFI1(NumberType.DOUBLE, NumberType.FLOAT, NumberType.INT),
476     MIXED_DFI2(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.INT),
477     MIXED_DFI3(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.INT),
478     MIXED_DFI4(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.INT),
479     MIXED_DFI5(NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.DOUBLE, NumberType.FLOAT, NumberType.INT),
480     //
481     MIXED_DF1(NumberType.DOUBLE, NumberType.FLOAT),
482     MIXED_DF2(NumberType.DOUBLE, NumberType.FLOAT, NumberType.FLOAT),
483     MIXED_DF3(NumberType.DOUBLE, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT),
484     MIXED_DF4(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.FLOAT),
485     MIXED_DF5(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.FLOAT),
486     //
487     EASY_D(NumberType.DOUBLE),
488     EASY_F(NumberType.FLOAT),
489     //Not needed
490     EASY_I(NumberType.INT),
491     EASY_B(NumberType.BYTE),
492     MIXED_IB(NumberType.INT, NumberType.BYTE),
493     //
494     MIXED_FBI1(NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
495     MIXED_FBI2(NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
496     MIXED_FBI3(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
497     MIXED_FBI4(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
498     MIXED_FBI5(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE, NumberType.INT),
499     //
500     MIXED_FB1(NumberType.FLOAT, NumberType.BYTE),
501     MIXED_FB2(NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE),
502     MIXED_FB3(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE),
503     MIXED_FB4(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE),
504     MIXED_FB5(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.BYTE),
505     //
506     MIXED_DBI1(NumberType.DOUBLE, NumberType.BYTE, NumberType.INT),
507     MIXED_DBI2(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE, NumberType.INT),
508     MIXED_DBI3(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE, NumberType.INT),
509     MIXED_DBI4(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE, NumberType.INT),
510     MIXED_DBI5(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE, NumberType.INT),
511     //
512     MIXED_DB1(NumberType.DOUBLE, NumberType.BYTE),
513     MIXED_DB2(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE),
514     MIXED_DB3(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE),
515     MIXED_DB4(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE),
516     MIXED_DB5(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.BYTE),
517     //
518     MIXED_FI1(NumberType.FLOAT, NumberType.INT),
519     MIXED_FI2(NumberType.FLOAT, NumberType.FLOAT, NumberType.INT),
520     MIXED_FI3(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.INT),
521     MIXED_FI4(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.INT),
522     MIXED_FI5(NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.FLOAT, NumberType.INT),
523     //
524     MIXED_DI1(NumberType.DOUBLE, NumberType.INT),
525     MIXED_DI2(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.INT),
526     MIXED_DI3(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.INT),
527     MIXED_DI4(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.INT),
528     MIXED_DI5(NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.DOUBLE, NumberType.INT);
529     ArrayList&lt;NumberType&gt; value = new ArrayList();
530 
531     ParamType(NumberType... type) {
532         value.addAll(Arrays.asList(type));
533     }
534 
535     public ArrayList&lt;NumberType&gt; getValue() {
536         return value;
537     }
538 }
539 
540 class GeneratorLogic {
541 
542     public String generateJava(String fncName, ParameterList parmOut, ParameterList parmType, int maxLength, String prefix) {
543         StringBuilder sb = new StringBuilder();
544 
545         sb.append(&quot;    {\n&quot;).append(prefix);
546         int lineLength = 0;
547         for (ParameterItem p : parmType.getList()) {
548             sb.append(p.value1);
549             sb.append(&quot; &quot;);
550             sb.append(p.value2);
551             sb.append(&quot;=&quot;);
552             sb.append(p.value3);
553             sb.append(&quot;;&quot;);
554             if (sb.length() - lineLength &gt; maxLength) {
555                 sb.append(&quot;\n&quot;).append(prefix);
556                 lineLength = sb.length();
557             }
558         }
559 
560         sb.append(&quot;\n&quot;);
561         sb.append(prefix);
562         for (ParameterItem p : parmOut.getList()) {
563             sb.append(&quot;ps.format(\&quot;&quot;);
564             sb.append(p.value2);
565             sb.append(&quot;=&quot;);
566             sb.append(p.value1);
567             sb.append(&quot;\\n\&quot;,&quot;);
568 
569 
570             sb.append(p.value2);
571             sb.append(&quot;);&quot;);
572             if (sb.length() - lineLength &gt; maxLength) {
573                 sb.append(&quot;\n&quot;).append(prefix);
574                 lineLength = sb.length();
575             }
576 
577         }
578 
579         sb.append(&quot;\n&quot;).append(prefix);
580 
581         sb.append(fncName);
582         sb.append(&quot;(&quot;);
583         for (ParameterItem p : parmOut.getList()) {
584             sb.append(p.getDelim());
585             sb.append(p.value2);
586             if (sb.length() - lineLength &gt; maxLength) {
587                 sb.append(&quot;\n&quot;).append(prefix);
588                 lineLength = sb.length();
589             }
590         }
591         sb.append(&quot;);\n}\n&quot;);
592 
593         return sb.toString();
594     }
595 }
596 
597 //Test types
598 enum TestType {
599 
600     RANDOM(new GeneratorLogic());
601     private GeneratorLogic genLogic;
602 
603     TestType(GeneratorLogic genLogic) {
604         this.genLogic = genLogic;
605     }
606 
607     public GeneratorLogic getLogic() {
608         return genLogic;
609     }
610 }
611 
612 //One item for ParameterList (delimiter and value to build strings)
613 class ParameterItem {
614 
615     private String delimiter;
616     String value1;
617     String value2;
618     String value3;
619     //private String endVal=&quot;&quot;;
620 
621     public ParameterItem(String delimiter, String value) {
622         this.delimiter = delimiter;
623         this.value1 = value;
624         value2 = &quot;&quot;;
625         value3 = &quot;&quot;;
626     }
627 
628     public ParameterItem(String delimiter, String value1, String value2) {
629         this.delimiter = delimiter;
630         this.value1 = value1;
631         this.value2 = value2;
632         value3 = &quot;&quot;;
633     }
634 
635     public ParameterItem(String delimiter, String value1, String value2, String value3) {
636         this.delimiter = delimiter;
637         this.value1 = value1;
638         this.value2 = value2;
639         this.value3 = value3;
640     }
641 
642     public String toString() {
643         return delimiter + value1 + value2 + value3;
644     }
645 
646     public String getDelim() {
647         return delimiter;
648     }
649 }
650 //Delimiters and values to generate calls, etc.
651 class ParameterList {
652 
653     ArrayList&lt;ParameterItem&gt; list = new ArrayList();
654     private String initDelim;
655     private String delim;
656     boolean lineBreak;
657 
658     public ParameterList(String initialDelimiter, String delimiter, boolean lineBreak) {
659         initDelim = initialDelimiter;
660         delim = delimiter;
661         this.lineBreak = lineBreak;
662     }
663 
664     public ArrayList&lt;ParameterItem&gt; getList() {
665         return list;
666     }
667 
668     public void add(String value) {
669         list.add(new ParameterItem(initDelim, value));
670         initDelim = delim;
671     }
672 
673     public void add(String value1, String value2) {
674         list.add(new ParameterItem(initDelim, value1, value2));
675         initDelim = delim;
676     }
677 
678     public void add(String value1, String value2, String value3) {
679         list.add(new ParameterItem(initDelim, value1, value2, value3));
680         initDelim = delim;
681     }
682 
683     public ParameterItem get(int id) {
684         return list.get(id);
685     }
686 
687     public String toString() {
688         StringBuilder sb = new StringBuilder();
689         for (ParameterItem p : list) {
690             sb.append(p.toString());
691             if (lineBreak) {
692                 sb.append(&quot;\n&quot;);
693             }
694 
695         }
696         return sb.toString();
697     }
698 
699     public String toFormatString(String prefix, int maxLength) {
700         StringBuilder sb = new StringBuilder();
701         int charCount = 0;
702         for (ParameterItem p : list) {
703             sb.append(p.toString());
704             if (sb.length() - charCount &gt; maxLength) {
705                 sb.append(&quot;\n&quot;).append(prefix);
706                 charCount = sb.length();
707             }
708         }
709         return sb.toString();
710     }
711 
712     public int size() {
713         return list.size();
714     }
715 
716     public String getAllItemExclude(int excludeId) {
717         StringBuilder sb = new StringBuilder();
718         int cnt = list.size();
719 
720         for (int id = 0; id &lt; cnt; ++id) {
721             ParameterItem p = list.get(id);
722             if (id == excludeId) {
723                 sb.append(p.getDelim());
724                 sb.append(&quot;0&quot;);
725             } else {
726                 sb.append(p.toString());
727 
728             }
729         }
730 
731         return sb.toString();
732 
733     }
734 
735     public String getAllItemExcludeNot(int excludeId) {
736         StringBuilder sb = new StringBuilder();
737         int cnt = list.size();
738 
739         for (int id = 0; id &lt; cnt; ++id) {
740             ParameterItem p = list.get(id);
741             if (id != excludeId) {
742                 sb.append(p.getDelim());
743                 sb.append(&quot;0&quot;);
744 //                sb.append(p.getEnd());
745             } else {
746                 sb.append(p.toString());
747 
748             }
749         }
750 
751         return sb.toString();
752     }
753 }
754 
755 class ParameterListGenerator {
756 
757     private ArrayList&lt;NumberType&gt; list = new ArrayList();
758     private Random random;
759     private int typeCnt;
760     ParameterList cParms = new ParameterList(&quot;,&quot;, &quot;,&quot;, true);
761     ParameterList rParms = new ParameterList(&quot;&quot;, &quot;,&quot;, true);
762     ParameterList jParms = new ParameterList(&quot;&quot;, &quot;,&quot;, true);
763     ParameterList cExec = new ParameterList(&quot;&quot;, &quot;&quot;, true);
764     ParameterList jExecParm = new ParameterList(&quot;&quot;, &quot;,&quot;, true);
765     ParameterList jExecOut = new ParameterList(&quot;&quot;, &quot;,&quot;, true);
766 
767     public ParameterListGenerator(int length, ParamType paramType) {
768         generateRndTest(paramType, length);
769     }
770 
771     private void add(ParameterList list, String s1) {
772         list.add(s1);
773     }
774 
775     private void add(ParameterList list, String s1, String s2) {
776         list.add(s1, s2);
777     }
778 
779     private void add(ParameterList list, String s1, String s2, String s3) {
780         list.add(s1, s2, s3);
781     }
782 
783     private void generateRndTest(ParamType paramType, int length) {
784         generateTypeList(paramType);
785 
786         typeCnt = list.size();
787         random = new Random();
788         random.setSeed(System.currentTimeMillis());
789 
790         for (int cnt = 0; cnt &lt; length; ++cnt) {
791             int type = random.nextInt(typeCnt);
792 
793             String randomVal = list.get(type).getFnc();
794 
795             String ctype = list.get(type).get小Type();
796             String jtype = list.get(type).getJType();
797             String cconv = list.get(type).get小Conv();
798             String jconv = list.get(type).getJConv();
799 
800             String varName = &quot;p&quot; + cnt;
801             add(jParms, jtype, varName);
802             //jParmGen.add(jtype + varName);
803 
804             //cParms.add(ctype + varName);
805             add(cParms, ctype, varName);
806 
807 
808             //rParms.add(varName);
809             add(rParms, varName);
810 
811             add(cExec, varName, cconv);
812 
813             add(jExecParm, jtype, varName, randomVal);
814             //jExecOut.add(new PairString(jconv,varName,jtype));
815             add(jExecOut, jconv, varName, jtype);
816         }
817 
818     }
819 
820     public ParameterList getCExec() {
821         return cExec;
822     }
823 
824     public ParameterList getCParm() {
825         return cParms;
826     }
827 
828     //Return generated java text
829     public ParameterList getJExecParameters() {
830         return jExecParm;
831     }
832 
833     public ParameterList getJExecOut() {
834         return jExecOut;
835     }
836 
837     /*
838      * Return string containing parameters for Java
839      */
840     public ParameterList getJParm() {
841         return jParms;
842     }
843 
844     public ParameterList getRParm() {
845         return rParms;
846     }
847 
848     private void generateTypeList(ParamType paramType) {
849         list.addAll(paramType.getValue());
850     }
851 }
852 
853 class SrcGenerator {
854 
855     ParameterListGenerator parmListGen;
856     GeneratorLogic genLogic;
857     int iterationCounter;
858     int parametersCounter;
859     ParamType paramType;
860     TestType testType;
861     String fncName;
862     //SrcGenerator g1=new SrcGenerator(3,1,ParamType.MIXED_DFIB,TestType.RANDOM,&quot;callRandom&quot;);
863     int maxLength;
864 
865     public SrcGenerator(int parmCounter, int iterCounter, ParamType parType, TestType testType, String fncName, int maxLength) {
866         this.maxLength = maxLength;
867         parametersCounter = parmCounter;
868         iterationCounter = iterCounter;
869         paramType = parType;
870         this.testType = testType;
871         this.fncName = fncName;
872         parmListGen = new ParameterListGenerator(parametersCounter, paramType);
873         genLogic = testType.getLogic();
874 
875     }
876 
877     public String getFncName() {
878         return fncName;
879     }
880 
881     public ParameterList getJParm() {
882         return parmListGen.getJParm();
883     }
884 
885     public ParameterList getCParm() {
886         return parmListGen.getCParm();
887     }
888 
889     public String getCExec() {
890 
891         StringBuilder sb = new StringBuilder();
892         for (ParameterItem p : parmListGen.getCExec().getList()) {
893             sb.append(&quot;fprintf(file,\&quot;&quot;);
894             sb.append(p.value1);
895             sb.append(&quot;=&quot;);
896             sb.append(p.value2);
897             sb.append(&quot;\\n\&quot;,&quot;);
898             sb.append(p.value1);
899             sb.append(&quot;);\n&quot;);
900         }
901         return sb.toString();
902     }
903 
904     public String getCExec(int maxLength,String prefix) {
905 
906         int lineLength = 0;
907         StringBuilder sb = new StringBuilder();
908         for (ParameterItem p : parmListGen.getCExec().getList()) {
909             sb.append(&quot;fprintf(file,\&quot;&quot;);
910             sb.append(p.value1);
911             sb.append(&quot;=&quot;);
912             sb.append(p.value2);
913             sb.append(&quot;\\n\&quot;,&quot;);
914             sb.append(p.value1);
915             sb.append(&quot;);&quot;);
916             if (sb.length() - lineLength &gt; maxLength) {
917                 lineLength = sb.length();
918                 sb.append(&quot;\n&quot;).append(prefix);
919             }
920         }
921         return sb.toString();
922     }
923 
924     public String getJExec(String prefix) {
925         return genLogic.generateJava(fncName, parmListGen.getJExecOut(), parmListGen.getJExecParameters(), maxLength, prefix);
926 
927     }
928 }
    </pre>
  </body>
</html>