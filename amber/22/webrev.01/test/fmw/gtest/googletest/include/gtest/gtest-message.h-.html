<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/fmw/gtest/googletest/include/gtest/gtest-message.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2005, Google Inc.
  2 // All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //     * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //     * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //     * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 //
 31 // The Google C++ Testing and Mocking Framework (Google Test)
 32 //
 33 // This header file defines the Message class.
 34 //
 35 // IMPORTANT NOTE: Due to limitation of the C++ language, we have to
 36 // leave some internal implementation details in this header file.
 37 // They are clearly marked by comments like this:
 38 //
 39 //   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
 40 //
 41 // Such code is NOT meant to be used by a user directly, and is subject
 42 // to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user
 43 // program!
 44 
 45 // GOOGLETEST_CM0001 DO NOT DELETE
 46 
 47 #ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 48 #define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 49 
 50 #include &lt;limits&gt;
 51 
 52 #include &quot;gtest/internal/gtest-port.h&quot;
 53 
 54 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
 55 /* class A needs to have dll-interface to be used by clients of class B */)
 56 
 57 // Ensures that there is at least one operator&lt;&lt; in the global namespace.
 58 // See Message&amp; operator&lt;&lt;(...) below for why.
 59 void operator&lt;&lt;(const testing::internal::Secret&amp;, int);
 60 
 61 namespace testing {
 62 
 63 // The Message class works like an ostream repeater.
 64 //
 65 // Typical usage:
 66 //
 67 //   1. You stream a bunch of values to a Message object.
 68 //      It will remember the text in a stringstream.
 69 //   2. Then you stream the Message object to an ostream.
 70 //      This causes the text in the Message to be streamed
 71 //      to the ostream.
 72 //
 73 // For example;
 74 //
 75 //   testing::Message foo;
 76 //   foo &lt;&lt; 1 &lt;&lt; &quot; != &quot; &lt;&lt; 2;
 77 //   std::cout &lt;&lt; foo;
 78 //
 79 // will print &quot;1 != 2&quot;.
 80 //
 81 // Message is not intended to be inherited from.  In particular, its
 82 // destructor is not virtual.
 83 //
 84 // Note that stringstream behaves differently in gcc and in MSVC.  You
 85 // can stream a NULL char pointer to it in the former, but not in the
 86 // latter (it causes an access violation if you do).  The Message
 87 // class hides this difference by treating a NULL char pointer as
 88 // &quot;(null)&quot;.
 89 class GTEST_API_ Message {
 90  private:
 91   // The type of basic IO manipulators (endl, ends, and flush) for
 92   // narrow streams.
 93   typedef std::ostream&amp; (*BasicNarrowIoManip)(std::ostream&amp;);
 94 
 95  public:
 96   // Constructs an empty Message.
 97   Message();
 98 
 99   // Copy constructor.
100   Message(const Message&amp; msg) : ss_(new ::std::stringstream) {  // NOLINT
101     *ss_ &lt;&lt; msg.GetString();
102   }
103 
104   // Constructs a Message from a C-string.
105   explicit Message(const char* str) : ss_(new ::std::stringstream) {
106     *ss_ &lt;&lt; str;
107   }
108 
109 #if GTEST_OS_SYMBIAN
110   // Streams a value (either a pointer or not) to this object.
111   template &lt;typename T&gt;
112   inline Message&amp; operator &lt;&lt;(const T&amp; value) {
113     StreamHelper(typename internal::is_pointer&lt;T&gt;::type(), value);
114     return *this;
115   }
116 #else
117   // Streams a non-pointer value to this object.
118   template &lt;typename T&gt;
119   inline Message&amp; operator &lt;&lt;(const T&amp; val) {
120     // Some libraries overload &lt;&lt; for STL containers.  These
121     // overloads are defined in the global namespace instead of ::std.
122     //
123     // C++&#39;s symbol lookup rule (i.e. Koenig lookup) says that these
124     // overloads are visible in either the std namespace or the global
125     // namespace, but not other namespaces, including the testing
126     // namespace which Google Test&#39;s Message class is in.
127     //
128     // To allow STL containers (and other types that has a &lt;&lt; operator
129     // defined in the global namespace) to be used in Google Test
130     // assertions, testing::Message must access the custom &lt;&lt; operator
131     // from the global namespace.  With this using declaration,
132     // overloads of &lt;&lt; defined in the global namespace and those
133     // visible via Koenig lookup are both exposed in this function.
134     using ::operator &lt;&lt;;
135     *ss_ &lt;&lt; val;
136     return *this;
137   }
138 
139   // Streams a pointer value to this object.
140   //
141   // This function is an overload of the previous one.  When you
142   // stream a pointer to a Message, this definition will be used as it
143   // is more specialized.  (The C++ Standard, section
144   // [temp.func.order].)  If you stream a non-pointer, then the
145   // previous definition will be used.
146   //
147   // The reason for this overload is that streaming a NULL pointer to
148   // ostream is undefined behavior.  Depending on the compiler, you
149   // may get &quot;0&quot;, &quot;(nil)&quot;, &quot;(null)&quot;, or an access violation.  To
150   // ensure consistent result across compilers, we always treat NULL
151   // as &quot;(null)&quot;.
152   template &lt;typename T&gt;
153   inline Message&amp; operator &lt;&lt;(T* const&amp; pointer) {  // NOLINT
154     if (pointer == NULL) {
155       *ss_ &lt;&lt; &quot;(null)&quot;;
156     } else {
157       *ss_ &lt;&lt; pointer;
158     }
159     return *this;
160   }
161 #endif  // GTEST_OS_SYMBIAN
162 
163   // Since the basic IO manipulators are overloaded for both narrow
164   // and wide streams, we have to provide this specialized definition
165   // of operator &lt;&lt;, even though its body is the same as the
166   // templatized version above.  Without this definition, streaming
167   // endl or other basic IO manipulators to Message will confuse the
168   // compiler.
169   Message&amp; operator &lt;&lt;(BasicNarrowIoManip val) {
170     *ss_ &lt;&lt; val;
171     return *this;
172   }
173 
174   // Instead of 1/0, we want to see true/false for bool values.
175   Message&amp; operator &lt;&lt;(bool b) {
176     return *this &lt;&lt; (b ? &quot;true&quot; : &quot;false&quot;);
177   }
178 
179   // These two overloads allow streaming a wide C string to a Message
180   // using the UTF-8 encoding.
181   Message&amp; operator &lt;&lt;(const wchar_t* wide_c_str);
182   Message&amp; operator &lt;&lt;(wchar_t* wide_c_str);
183 
184 #if GTEST_HAS_STD_WSTRING
185   // Converts the given wide string to a narrow string using the UTF-8
186   // encoding, and streams the result to this Message object.
187   Message&amp; operator &lt;&lt;(const ::std::wstring&amp; wstr);
188 #endif  // GTEST_HAS_STD_WSTRING
189 
190 #if GTEST_HAS_GLOBAL_WSTRING
191   // Converts the given wide string to a narrow string using the UTF-8
192   // encoding, and streams the result to this Message object.
193   Message&amp; operator &lt;&lt;(const ::wstring&amp; wstr);
194 #endif  // GTEST_HAS_GLOBAL_WSTRING
195 
196   // Gets the text streamed to this object so far as an std::string.
197   // Each &#39;\0&#39; character in the buffer is replaced with &quot;\\0&quot;.
198   //
199   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
200   std::string GetString() const;
201 
202  private:
203 #if GTEST_OS_SYMBIAN
204   // These are needed as the Nokia Symbian Compiler cannot decide between
205   // const T&amp; and const T* in a function template. The Nokia compiler _can_
206   // decide between class template specializations for T and T*, so a
207   // tr1::type_traits-like is_pointer works, and we can overload on that.
208   template &lt;typename T&gt;
209   inline void StreamHelper(internal::true_type /*is_pointer*/, T* pointer) {
210     if (pointer == NULL) {
211       *ss_ &lt;&lt; &quot;(null)&quot;;
212     } else {
213       *ss_ &lt;&lt; pointer;
214     }
215   }
216   template &lt;typename T&gt;
217   inline void StreamHelper(internal::false_type /*is_pointer*/,
218                            const T&amp; value) {
219     // See the comments in Message&amp; operator &lt;&lt;(const T&amp;) above for why
220     // we need this using statement.
221     using ::operator &lt;&lt;;
222     *ss_ &lt;&lt; value;
223   }
224 #endif  // GTEST_OS_SYMBIAN
225 
226   // We&#39;ll hold the text streamed to this object here.
227   const internal::scoped_ptr&lt; ::std::stringstream&gt; ss_;
228 
229   // We declare (but don&#39;t implement) this to prevent the compiler
230   // from implementing the assignment operator.
231   void operator=(const Message&amp;);
232 };
233 
234 // Streams a Message to an ostream.
235 inline std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const Message&amp; sb) {
236   return os &lt;&lt; sb.GetString();
237 }
238 
239 namespace internal {
240 
241 // Converts a streamable value to an std::string.  A NULL pointer is
242 // converted to &quot;(null)&quot;.  When the input value is a ::string,
243 // ::std::string, ::wstring, or ::std::wstring object, each NUL
244 // character in it is replaced with &quot;\\0&quot;.
245 template &lt;typename T&gt;
246 std::string StreamableToString(const T&amp; streamable) {
247   return (Message() &lt;&lt; streamable).GetString();
248 }
249 
250 }  // namespace internal
251 }  // namespace testing
252 
253 GTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251
254 
255 #endif  // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
    </pre>
  </body>
</html>