<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 
   25 // z/Architecture Architecture Description File
   26 
   27 // Major contributions by AS, JL, LS.
   28 
   29 //
   30 // Following information is derived from private mail communication
   31 // (Oct. 2011).
   32 //
   33 // General branch target alignment considerations
   34 //
   35 // z/Architecture does not imply a general branch target alignment requirement.
   36 // There are side effects and side considerations, though, which may
   37 // provide some performance benefit. These are:
   38 //  - Align branch target on octoword (32-byte) boundary
   39 //    On more recent models (from z9 on), I-fetch is done on a Octoword
   40 //    (32 bytes at a time) basis. To avoid I-fetching unnecessary
   41 //    instructions, branch targets should be 32-byte aligend. If this
   42 //    exact alingment cannot be achieved, having the branch target in
   43 //    the first doubleword still provides some benefit.
   44 //  - Avoid branch targets at the end of cache lines (&gt; 64 bytes distance).
   45 //    Sequential instruction prefetching after the branch target starts
   46 //    immediately after having fetched the octoword containing the
   47 //    branch target. When I-fetching crosses a cache line, there may be
   48 //    a small stall. The worst case: the branch target (at the end of
   49 //    a cache line) is a L1 I-cache miss and the next line as well.
   50 //    Then, the entire target line must be filled first (to contine at the
   51 //    branch target). Only then can the next sequential line be filled.
   52 //  - Avoid multiple poorly predicted branches in a row.
   53 //
   54 
   55 //----------REGISTER DEFINITION BLOCK------------------------------------------
   56 // This information is used by the matcher and the register allocator to
   57 // describe individual registers and classes of registers within the target
   58 // architecture.
   59 
   60 register %{
   61 
   62 //----------Architecture Description Register Definitions----------------------
   63 // General Registers
   64 // &quot;reg_def&quot; name (register save type, C convention save type,
   65 //                   ideal register type, encoding);
   66 //
   67 // Register Save Types:
   68 //
   69 //   NS  = No-Save:     The register allocator assumes that these registers
   70 //                      can be used without saving upon entry to the method, &amp;
   71 //                      that they do not need to be saved at call sites.
   72 //
   73 //   SOC = Save-On-Call: The register allocator assumes that these registers
   74 //                      can be used without saving upon entry to the method,
   75 //                      but that they must be saved at call sites.
   76 //
   77 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   78 //                      must be saved before using them upon entry to the
   79 //                      method, but they do not need to be saved at call sites.
   80 //
   81 //   AS  = Always-Save: The register allocator assumes that these registers
   82 //                      must be saved before using them upon entry to the
   83 //                      method, &amp; that they must be saved at call sites.
   84 //
   85 // Ideal Register Type is used to determine how to save &amp; restore a
   86 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   87 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   88 //
   89 // The encoding number is the actual bit-pattern placed into the opcodes.
   90 
   91 // z/Architecture register definitions, based on the z/Architecture Principles
   92 // of Operation, 5th Edition, September 2005, and z/Linux Elf ABI Supplement,
   93 // 5th Edition, March 2001.
   94 //
   95 // For each 64-bit register we must define two registers: the register
   96 // itself, e.g. Z_R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   97 // e.g. Z_R3_H, which is needed by the allocator, but is not used
   98 // for stores, loads, etc.
   99 
  100   // Integer/Long Registers
  101   // ----------------------------
  102 
  103   // z/Architecture has 16 64-bit integer registers.
  104 
  105   // types: v = volatile, nv = non-volatile, s = system
  106   reg_def Z_R0   (SOC, SOC, Op_RegI,  0, Z_R0-&gt;as_VMReg());   // v   scratch1
  107   reg_def Z_R0_H (SOC, SOC, Op_RegI, 99, Z_R0-&gt;as_VMReg()-&gt;next());
  108   reg_def Z_R1   (SOC, SOC, Op_RegI,  1, Z_R1-&gt;as_VMReg());   // v   scratch2
  109   reg_def Z_R1_H (SOC, SOC, Op_RegI, 99, Z_R1-&gt;as_VMReg()-&gt;next());
  110   reg_def Z_R2   (SOC, SOC, Op_RegI,  2, Z_R2-&gt;as_VMReg());   // v   iarg1 &amp; iret
  111   reg_def Z_R2_H (SOC, SOC, Op_RegI, 99, Z_R2-&gt;as_VMReg()-&gt;next());
  112   reg_def Z_R3   (SOC, SOC, Op_RegI,  3, Z_R3-&gt;as_VMReg());   // v   iarg2
  113   reg_def Z_R3_H (SOC, SOC, Op_RegI, 99, Z_R3-&gt;as_VMReg()-&gt;next());
  114   reg_def Z_R4   (SOC, SOC, Op_RegI,  4, Z_R4-&gt;as_VMReg());   // v   iarg3
  115   reg_def Z_R4_H (SOC, SOC, Op_RegI, 99, Z_R4-&gt;as_VMReg()-&gt;next());
  116   reg_def Z_R5   (SOC, SOC, Op_RegI,  5, Z_R5-&gt;as_VMReg());   // v   iarg4
  117   reg_def Z_R5_H (SOC, SOC, Op_RegI, 99, Z_R5-&gt;as_VMReg()-&gt;next());
  118   reg_def Z_R6   (SOC, SOE, Op_RegI,  6, Z_R6-&gt;as_VMReg());   // v   iarg5
  119   reg_def Z_R6_H (SOC, SOE, Op_RegI, 99, Z_R6-&gt;as_VMReg()-&gt;next());
  120   reg_def Z_R7   (SOC, SOE, Op_RegI,  7, Z_R7-&gt;as_VMReg());
  121   reg_def Z_R7_H (SOC, SOE, Op_RegI, 99, Z_R7-&gt;as_VMReg()-&gt;next());
  122   reg_def Z_R8   (SOC, SOE, Op_RegI,  8, Z_R8-&gt;as_VMReg());
  123   reg_def Z_R8_H (SOC, SOE, Op_RegI, 99, Z_R8-&gt;as_VMReg()-&gt;next());
  124   reg_def Z_R9   (SOC, SOE, Op_RegI,  9, Z_R9-&gt;as_VMReg());
  125   reg_def Z_R9_H (SOC, SOE, Op_RegI, 99, Z_R9-&gt;as_VMReg()-&gt;next());
  126   reg_def Z_R10  (SOC, SOE, Op_RegI, 10, Z_R10-&gt;as_VMReg());
  127   reg_def Z_R10_H(SOC, SOE, Op_RegI, 99, Z_R10-&gt;as_VMReg()-&gt;next());
  128   reg_def Z_R11  (SOC, SOE, Op_RegI, 11, Z_R11-&gt;as_VMReg());
  129   reg_def Z_R11_H(SOC, SOE, Op_RegI, 99, Z_R11-&gt;as_VMReg()-&gt;next());
  130   reg_def Z_R12  (SOC, SOE, Op_RegI, 12, Z_R12-&gt;as_VMReg());
  131   reg_def Z_R12_H(SOC, SOE, Op_RegI, 99, Z_R12-&gt;as_VMReg()-&gt;next());
  132   reg_def Z_R13  (SOC, SOE, Op_RegI, 13, Z_R13-&gt;as_VMReg());
  133   reg_def Z_R13_H(SOC, SOE, Op_RegI, 99, Z_R13-&gt;as_VMReg()-&gt;next());
  134   reg_def Z_R14  (NS,  NS,  Op_RegI, 14, Z_R14-&gt;as_VMReg());   // s  return_pc
  135   reg_def Z_R14_H(NS,  NS,  Op_RegI, 99, Z_R14-&gt;as_VMReg()-&gt;next());
  136   reg_def Z_R15  (NS,  NS,  Op_RegI, 15, Z_R15-&gt;as_VMReg());   // s  SP
  137   reg_def Z_R15_H(NS,  NS,  Op_RegI, 99, Z_R15-&gt;as_VMReg()-&gt;next());
  138 
  139   // Float/Double Registers
  140 
  141   // The rules of ADL require that double registers be defined in pairs.
  142   // Each pair must be two 32-bit values, but not necessarily a pair of
  143   // single float registers. In each pair, ADLC-assigned register numbers
  144   // must be adjacent, with the lower number even. Finally, when the
  145   // CPU stores such a register pair to memory, the word associated with
  146   // the lower ADLC-assigned number must be stored to the lower address.
  147 
  148   // z/Architecture has 16 64-bit floating-point registers. Each can store a single
  149   // or double precision floating-point value.
  150 
  151   // types: v = volatile, nv = non-volatile, s = system
  152   reg_def Z_F0   (SOC, SOC, Op_RegF,  0, Z_F0-&gt;as_VMReg());   // v   farg1 &amp; fret
  153   reg_def Z_F0_H (SOC, SOC, Op_RegF, 99, Z_F0-&gt;as_VMReg()-&gt;next());
  154   reg_def Z_F1   (SOC, SOC, Op_RegF,  1, Z_F1-&gt;as_VMReg());
  155   reg_def Z_F1_H (SOC, SOC, Op_RegF, 99, Z_F1-&gt;as_VMReg()-&gt;next());
  156   reg_def Z_F2   (SOC, SOC, Op_RegF,  2, Z_F2-&gt;as_VMReg());   // v   farg2
  157   reg_def Z_F2_H (SOC, SOC, Op_RegF, 99, Z_F2-&gt;as_VMReg()-&gt;next());
  158   reg_def Z_F3   (SOC, SOC, Op_RegF,  3, Z_F3-&gt;as_VMReg());
  159   reg_def Z_F3_H (SOC, SOC, Op_RegF, 99, Z_F3-&gt;as_VMReg()-&gt;next());
  160   reg_def Z_F4   (SOC, SOC, Op_RegF,  4, Z_F4-&gt;as_VMReg());   // v   farg3
  161   reg_def Z_F4_H (SOC, SOC, Op_RegF, 99, Z_F4-&gt;as_VMReg()-&gt;next());
  162   reg_def Z_F5   (SOC, SOC, Op_RegF,  5, Z_F5-&gt;as_VMReg());
  163   reg_def Z_F5_H (SOC, SOC, Op_RegF, 99, Z_F5-&gt;as_VMReg()-&gt;next());
  164   reg_def Z_F6   (SOC, SOC, Op_RegF,  6, Z_F6-&gt;as_VMReg());
  165   reg_def Z_F6_H (SOC, SOC, Op_RegF, 99, Z_F6-&gt;as_VMReg()-&gt;next());
  166   reg_def Z_F7   (SOC, SOC, Op_RegF,  7, Z_F7-&gt;as_VMReg());
  167   reg_def Z_F7_H (SOC, SOC, Op_RegF, 99, Z_F7-&gt;as_VMReg()-&gt;next());
  168   reg_def Z_F8   (SOC, SOE, Op_RegF,  8, Z_F8-&gt;as_VMReg());
  169   reg_def Z_F8_H (SOC, SOE, Op_RegF, 99, Z_F8-&gt;as_VMReg()-&gt;next());
  170   reg_def Z_F9   (SOC, SOE, Op_RegF,  9, Z_F9-&gt;as_VMReg());
  171   reg_def Z_F9_H (SOC, SOE, Op_RegF, 99, Z_F9-&gt;as_VMReg()-&gt;next());
  172   reg_def Z_F10  (SOC, SOE, Op_RegF, 10, Z_F10-&gt;as_VMReg());
  173   reg_def Z_F10_H(SOC, SOE, Op_RegF, 99, Z_F10-&gt;as_VMReg()-&gt;next());
  174   reg_def Z_F11  (SOC, SOE, Op_RegF, 11, Z_F11-&gt;as_VMReg());
  175   reg_def Z_F11_H(SOC, SOE, Op_RegF, 99, Z_F11-&gt;as_VMReg()-&gt;next());
  176   reg_def Z_F12  (SOC, SOE, Op_RegF, 12, Z_F12-&gt;as_VMReg());
  177   reg_def Z_F12_H(SOC, SOE, Op_RegF, 99, Z_F12-&gt;as_VMReg()-&gt;next());
  178   reg_def Z_F13  (SOC, SOE, Op_RegF, 13, Z_F13-&gt;as_VMReg());
  179   reg_def Z_F13_H(SOC, SOE, Op_RegF, 99, Z_F13-&gt;as_VMReg()-&gt;next());
  180   reg_def Z_F14  (SOC, SOE, Op_RegF, 14, Z_F14-&gt;as_VMReg());
  181   reg_def Z_F14_H(SOC, SOE, Op_RegF, 99, Z_F14-&gt;as_VMReg()-&gt;next());
  182   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15-&gt;as_VMReg());
  183   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15-&gt;as_VMReg()-&gt;next());
  184 
  185 
  186   // Special Registers
  187 
  188   // Condition Codes Flag Registers
  189 
  190   // z/Architecture has the PSW (program status word) that contains
  191   // (among other information) the condition code. We treat this
  192   // part of the PSW as a condition register CR. It consists of 4
  193   // bits. Floating point instructions influence the same condition register CR.
  194 
  195   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR-&gt;as_VMReg());   // volatile
  196 
  197 
  198 // Specify priority of register selection within phases of register
  199 // allocation. Highest priority is first. A useful heuristic is to
  200 // give registers a low priority when they are required by machine
  201 // instructions, and choose no-save registers before save-on-call, and
  202 // save-on-call before save-on-entry. Registers which participate in
  203 // fix calling sequences should come last. Registers which are used
  204 // as pairs must fall on an even boundary.
  205 
  206 // It&#39;s worth about 1% on SPEC geomean to get this right.
  207 
  208 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  209 // in adGlobals_s390.hpp which defines the &lt;register&gt;_num values, e.g.
  210 // Z_R3_num. Therefore, Z_R3_num may not be (and in reality is not)
  211 // the same as Z_R3-&gt;encoding()! Furthermore, we cannot make any
  212 // assumptions on ordering, e.g. Z_R3_num may be less than Z_R2_num.
  213 // Additionally, the function
  214 //   static enum RC rc_class(OptoReg::Name reg)
  215 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  216 // and its current implementation relies on chunk0 and chunk1 having a
  217 // size of 64 each.
  218 
  219 alloc_class chunk0(
  220   // chunk0 contains *all* 32 integer registers halves.
  221 
  222   // potential SOE regs
  223   Z_R13,Z_R13_H,
  224   Z_R12,Z_R12_H,
  225   Z_R11,Z_R11_H,
  226   Z_R10,Z_R10_H,
  227 
  228   Z_R9,Z_R9_H,
  229   Z_R8,Z_R8_H,
  230   Z_R7,Z_R7_H,
  231 
  232   Z_R1,Z_R1_H,
  233   Z_R0,Z_R0_H,
  234 
  235   // argument registers
  236   Z_R6,Z_R6_H,
  237   Z_R5,Z_R5_H,
  238   Z_R4,Z_R4_H,
  239   Z_R3,Z_R3_H,
  240   Z_R2,Z_R2_H,
  241 
  242   // special registers
  243   Z_R14,Z_R14_H,
  244   Z_R15,Z_R15_H
  245 );
  246 
  247 alloc_class chunk1(
  248   // Chunk1 contains *all* 64 floating-point registers halves.
  249 
  250   Z_F15,Z_F15_H,
  251   Z_F14,Z_F14_H,
  252   Z_F13,Z_F13_H,
  253   Z_F12,Z_F12_H,
  254   Z_F11,Z_F11_H,
  255   Z_F10,Z_F10_H,
  256   Z_F9,Z_F9_H,
  257   Z_F8,Z_F8_H,
  258   // scratch register
  259   Z_F7,Z_F7_H,
  260   Z_F5,Z_F5_H,
  261   Z_F3,Z_F3_H,
  262   Z_F1,Z_F1_H,
  263   // argument registers
  264   Z_F6,Z_F6_H,
  265   Z_F4,Z_F4_H,
  266   Z_F2,Z_F2_H,
  267   Z_F0,Z_F0_H
  268 );
  269 
  270 alloc_class chunk2(
  271   Z_CR
  272 );
  273 
  274 
  275 //-------Architecture Description Register Classes-----------------------
  276 
  277 // Several register classes are automatically defined based upon
  278 // information in this architecture description.
  279 
  280 // 1) reg_class inline_cache_reg           (as defined in frame section)
  281 // 2) reg_class compiler_method_oop_reg    (as defined in frame section)
  282 // 2) reg_class interpreter_method_oop_reg (as defined in frame section)
  283 // 3) reg_class stack_slots(/* one chunk of stack-based &quot;registers&quot; */)
  284 
  285 // Integer Register Classes
  286 reg_class z_int_reg(
  287 /*Z_R0*/              // R0
  288 /*Z_R1*/
  289   Z_R2,
  290   Z_R3,
  291   Z_R4,
  292   Z_R5,
  293   Z_R6,
  294   Z_R7,
  295 /*Z_R8,*/             // Z_thread
  296   Z_R9,
  297   Z_R10,
  298   Z_R11,
  299   Z_R12,
  300   Z_R13
  301 /*Z_R14*/             // return_pc
  302 /*Z_R15*/             // SP
  303 );
  304 
  305 reg_class z_no_odd_int_reg(
  306 /*Z_R0*/              // R0
  307 /*Z_R1*/
  308   Z_R2,
  309   Z_R3,
  310   Z_R4,
  311 /*Z_R5,*/             // odd part of fix register pair
  312   Z_R6,
  313   Z_R7,
  314 /*Z_R8,*/             // Z_thread
  315   Z_R9,
  316   Z_R10,
  317   Z_R11,
  318   Z_R12,
  319   Z_R13
  320 /*Z_R14*/             // return_pc
  321 /*Z_R15*/             // SP
  322 );
  323 
  324 reg_class z_no_arg_int_reg(
  325 /*Z_R0*/              // R0
  326 /*Z_R1*/              // scratch
  327 /*Z_R2*/
  328 /*Z_R3*/
  329 /*Z_R4*/
  330 /*Z_R5*/
  331 /*Z_R6*/
  332   Z_R7,
  333 /*Z_R8*/              // Z_thread
  334   Z_R9,
  335   Z_R10,
  336   Z_R11,
  337   Z_R12,
  338   Z_R13
  339 /*Z_R14*/             // return_pc
  340 /*Z_R15*/             // SP
  341 );
  342 
  343 reg_class z_rarg1_int_reg(Z_R2);
  344 reg_class z_rarg2_int_reg(Z_R3);
  345 reg_class z_rarg3_int_reg(Z_R4);
  346 reg_class z_rarg4_int_reg(Z_R5);
  347 reg_class z_rarg5_int_reg(Z_R6);
  348 
  349 // Pointer Register Classes
  350 
  351 // 64-bit build means 64-bit pointers means hi/lo pairs.
  352 
  353 reg_class z_rarg5_ptrN_reg(Z_R6);
  354 
  355 reg_class z_rarg1_ptr_reg(Z_R2_H,Z_R2);
  356 reg_class z_rarg2_ptr_reg(Z_R3_H,Z_R3);
  357 reg_class z_rarg3_ptr_reg(Z_R4_H,Z_R4);
  358 reg_class z_rarg4_ptr_reg(Z_R5_H,Z_R5);
  359 reg_class z_rarg5_ptr_reg(Z_R6_H,Z_R6);
  360 reg_class z_thread_ptr_reg(Z_R8_H,Z_R8);
  361 
  362 reg_class z_ptr_reg(
  363 /*Z_R0_H,Z_R0*/     // R0
  364 /*Z_R1_H,Z_R1*/
  365   Z_R2_H,Z_R2,
  366   Z_R3_H,Z_R3,
  367   Z_R4_H,Z_R4,
  368   Z_R5_H,Z_R5,
  369   Z_R6_H,Z_R6,
  370   Z_R7_H,Z_R7,
  371 /*Z_R8_H,Z_R8,*/    // Z_thread
  372   Z_R9_H,Z_R9,
  373   Z_R10_H,Z_R10,
  374   Z_R11_H,Z_R11,
  375   Z_R12_H,Z_R12,
  376   Z_R13_H,Z_R13
  377 /*Z_R14_H,Z_R14*/   // return_pc
  378 /*Z_R15_H,Z_R15*/   // SP
  379 );
  380 
  381 reg_class z_lock_ptr_reg(
  382 /*Z_R0_H,Z_R0*/     // R0
  383 /*Z_R1_H,Z_R1*/
  384   Z_R2_H,Z_R2,
  385   Z_R3_H,Z_R3,
  386   Z_R4_H,Z_R4,
  387 /*Z_R5_H,Z_R5,*/
  388 /*Z_R6_H,Z_R6,*/
  389   Z_R7_H,Z_R7,
  390 /*Z_R8_H,Z_R8,*/    // Z_thread
  391   Z_R9_H,Z_R9,
  392   Z_R10_H,Z_R10,
  393   Z_R11_H,Z_R11,
  394   Z_R12_H,Z_R12,
  395   Z_R13_H,Z_R13
  396 /*Z_R14_H,Z_R14*/   // return_pc
  397 /*Z_R15_H,Z_R15*/   // SP
  398 );
  399 
  400 reg_class z_no_arg_ptr_reg(
  401 /*Z_R0_H,Z_R0*/        // R0
  402 /*Z_R1_H,Z_R1*/        // scratch
  403 /*Z_R2_H,Z_R2*/
  404 /*Z_R3_H,Z_R3*/
  405 /*Z_R4_H,Z_R4*/
  406 /*Z_R5_H,Z_R5*/
  407 /*Z_R6_H,Z_R6*/
  408   Z_R7_H, Z_R7,
  409 /*Z_R8_H,Z_R8*/        // Z_thread
  410   Z_R9_H,Z_R9,
  411   Z_R10_H,Z_R10,
  412   Z_R11_H,Z_R11,
  413   Z_R12_H,Z_R12,
  414   Z_R13_H,Z_R13
  415 /*Z_R14_H,Z_R14*/      // return_pc
  416 /*Z_R15_H,Z_R15*/      // SP
  417 );
  418 
  419 // Special class for storeP instructions, which can store SP or RPC to
  420 // TLS. (Note: Do not generalize this to &quot;any_reg&quot;. If you add
  421 // another register, such as FP, to this mask, the allocator may try
  422 // to put a temp in it.)
  423 // Register class for memory access base registers,
  424 // This class is a superset of z_ptr_reg including Z_thread.
  425 reg_class z_memory_ptr_reg(
  426 /*Z_R0_H,Z_R0*/     // R0
  427 /*Z_R1_H,Z_R1*/
  428   Z_R2_H,Z_R2,
  429   Z_R3_H,Z_R3,
  430   Z_R4_H,Z_R4,
  431   Z_R5_H,Z_R5,
  432   Z_R6_H,Z_R6,
  433   Z_R7_H,Z_R7,
  434   Z_R8_H,Z_R8,      // Z_thread
  435   Z_R9_H,Z_R9,
  436   Z_R10_H,Z_R10,
  437   Z_R11_H,Z_R11,
  438   Z_R12_H,Z_R12,
  439   Z_R13_H,Z_R13
  440 /*Z_R14_H,Z_R14*/   // return_pc
  441 /*Z_R15_H,Z_R15*/   // SP
  442 );
  443 
  444 // Other special pointer regs.
  445 reg_class z_r1_regP(Z_R1_H,Z_R1);
  446 reg_class z_r9_regP(Z_R9_H,Z_R9);
  447 
  448 
  449 // Long Register Classes
  450 
  451 reg_class z_rarg1_long_reg(Z_R2_H,Z_R2);
  452 reg_class z_rarg2_long_reg(Z_R3_H,Z_R3);
  453 reg_class z_rarg3_long_reg(Z_R4_H,Z_R4);
  454 reg_class z_rarg4_long_reg(Z_R5_H,Z_R5);
  455 reg_class z_rarg5_long_reg(Z_R6_H,Z_R6);
  456 
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
  477 // z_long_reg without even registers
  478 reg_class z_long_odd_reg(
  479 /*Z_R0_H,Z_R0*/     // R0
  480 /*Z_R1_H,Z_R1*/
  481   Z_R3_H,Z_R3,
  482   Z_R5_H,Z_R5,
  483   Z_R7_H,Z_R7,
  484   Z_R9_H,Z_R9,
  485   Z_R11_H,Z_R11,
  486   Z_R13_H,Z_R13
  487 /*Z_R14_H,Z_R14,*/  // return_pc
  488 /*Z_R15_H,Z_R15*/   // SP
  489 );
  490 
  491 // Special Class for Condition Code Flags Register
  492 
  493 reg_class z_condition_reg(
  494   Z_CR
  495 );
  496 
  497 // Scratch register for late profiling. Callee saved.
  498 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  499 
  500 
  501 // Float Register Classes
  502 
  503 reg_class z_flt_reg(
  504   Z_F0,
  505 /*Z_F1,*/ // scratch
  506   Z_F2,
  507   Z_F3,
  508   Z_F4,
  509   Z_F5,
  510   Z_F6,
  511   Z_F7,
  512   Z_F8,
  513   Z_F9,
  514   Z_F10,
  515   Z_F11,
  516   Z_F12,
  517   Z_F13,
  518   Z_F14,
  519   Z_F15
  520 );
  521 reg_class z_rscratch1_flt_reg(Z_F1);
  522 
  523 // Double precision float registers have virtual `high halves&#39; that
  524 // are needed by the allocator.
  525 reg_class z_dbl_reg(
  526   Z_F0,Z_F0_H,
  527 /*Z_F1,Z_F1_H,*/ // scratch
  528   Z_F2,Z_F2_H,
  529   Z_F3,Z_F3_H,
  530   Z_F4,Z_F4_H,
  531   Z_F5,Z_F5_H,
  532   Z_F6,Z_F6_H,
  533   Z_F7,Z_F7_H,
  534   Z_F8,Z_F8_H,
  535   Z_F9,Z_F9_H,
  536   Z_F10,Z_F10_H,
  537   Z_F11,Z_F11_H,
  538   Z_F12,Z_F12_H,
  539   Z_F13,Z_F13_H,
  540   Z_F14,Z_F14_H,
  541   Z_F15,Z_F15_H
  542 );
  543 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
  544 
  545 %}
  546 
  547 //----------DEFINITION BLOCK---------------------------------------------------
  548 // Define &#39;name --&gt; value&#39; mappings to inform the ADLC of an integer valued name.
  549 // Current support includes integer values in the range [0, 0x7FFFFFFF].
  550 // Format:
  551 //        int_def  &lt;name&gt;         (&lt;int_value&gt;, &lt;expression&gt;);
  552 // Generated Code in ad_&lt;arch&gt;.hpp
  553 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  554 //        // value == &lt;int_value&gt;
  555 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  556 //        assert(&lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  557 //
  558 definitions %{
  559   // The default cost (of an ALU instruction).
  560   int_def DEFAULT_COST      (   100,     100);
  561   int_def DEFAULT_COST_LOW  (    80,      80);
  562   int_def DEFAULT_COST_HIGH (   120,     120);
  563   int_def HUGE_COST         (1000000, 1000000);
  564 
  565   // Put an advantage on REG_MEM vs. MEM+REG_REG operations.
  566   int_def ALU_REG_COST      (   100, DEFAULT_COST);
  567   int_def ALU_MEMORY_COST   (   150,          150);
  568 
  569   // Memory refs are twice as expensive as run-of-the-mill.
  570   int_def MEMORY_REF_COST_HI (   220, 2 * DEFAULT_COST+20);
  571   int_def MEMORY_REF_COST    (   200, 2 * DEFAULT_COST);
  572   int_def MEMORY_REF_COST_LO (   180, 2 * DEFAULT_COST-20);
  573 
  574   // Branches are even more expensive.
  575   int_def BRANCH_COST       (   300, DEFAULT_COST * 3);
  576   int_def CALL_COST         (   300, DEFAULT_COST * 3);
  577 %}
  578 
  579 source %{
  580 
  581 #ifdef PRODUCT
  582 #define BLOCK_COMMENT(str)
  583 #define BIND(label)        __ bind(label)
  584 #else
  585 #define BLOCK_COMMENT(str) __ block_comment(str)
  586 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  587 #endif
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 
  608 void PhaseOutput::pd_perform_mach_node_analysis() {
  609 }
  610 
  611 int MachNode::pd_alignment_required() const {
  612   return 1;
  613 }
  614 
  615 int MachNode::compute_padding(int current_offset) const {
  616   return 0;
  617 }
  618 
  619 int MachCallStaticJavaNode::ret_addr_offset() {
  620   if (_method) {
  621     return 8;
  622   } else {
  623     return MacroAssembler::call_far_patchable_ret_addr_offset();
  624   }
  625 }
  626 
  627 int MachCallDynamicJavaNode::ret_addr_offset() {
  628   // Consider size of receiver type profiling (C2 tiers).
  629   int profile_receiver_type_size = 0;
  630 
  631   int vtable_index = this-&gt;_vtable_index;
  632   if (vtable_index == -4) {
  633     return 14 + profile_receiver_type_size;
  634   } else {
  635     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  636     return 36 + profile_receiver_type_size;
  637   }
  638 }
  639 
  640 int MachCallRuntimeNode::ret_addr_offset() {
  641   return 12 + MacroAssembler::call_far_patchable_ret_addr_offset();
  642 }
  643 
  644 // Compute padding required for nodes which need alignment
  645 //
  646 // The addresses of the call instructions needs to be 4-byte aligned to
  647 // ensure that they don&#39;t span a cache line so that they are atomically patchable.
  648 // The actual calls get emitted at different offsets within the node emitters.
  649 // ins_alignment needs to be set to 2 which means that up to 1 nop may get inserted.
  650 
  651 int CallStaticJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  652   return (0 - current_offset) &amp; 2;
  653 }
  654 
  655 int CallDynamicJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  656   return (6 - current_offset) &amp; 2;
  657 }
  658 
  659 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  660   return (12 - current_offset) &amp; 2;
  661 }
  662 
  663 int CallLeafDirectNode::compute_padding(int current_offset) const {
  664   return (12 - current_offset) &amp; 2;
  665 }
  666 
  667 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  668   return (12 - current_offset) &amp; 2;
  669 }
  670 
  671 // Indicate if the safepoint node needs the polling page as an input.
  672 // Since z/Architecture does not have absolute addressing, it does.
  673 bool SafePointNode::needs_polling_address_input() {
  674   return true;
  675 }
  676 
  677 void emit_nop(CodeBuffer &amp;cbuf) {
  678   C2_MacroAssembler _masm(&amp;cbuf);
  679   __ z_nop();
  680 }
  681 
  682 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  683 void emit_break(CodeBuffer &amp;cbuf) {
  684   C2_MacroAssembler _masm(&amp;cbuf);
  685   __ z_illtrap();
  686 }
  687 
  688 #if !defined(PRODUCT)
  689 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  690   os-&gt;print(&quot;TA&quot;);
  691 }
  692 #endif
  693 
  694 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  695   emit_break(cbuf);
  696 }
  697 
  698 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  699   return MachNode::size(ra_);
  700 }
  701 
  702 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  703   // 32bit instructions may become sign extended.
  704   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  705   assert(value &lt; (1L &lt;&lt; 16), &quot;instruction too large&quot;);
  706   *((unsigned short*)(cbuf.insts_end())) = (unsigned short)value;
  707   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned short));
  708 }
  709 
  710 static inline void z_emit32(CodeBuffer &amp;cbuf, long value) {
  711   // 32bit instructions may become sign extended.
  712   assert(value &lt; (1L &lt;&lt; 32), &quot;instruction too large&quot;);
  713   *((unsigned int*)(cbuf.insts_end())) = (unsigned int)value;
  714   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned int));
  715 }
  716 
  717 static inline void z_emit48(CodeBuffer &amp;cbuf, long value) {
  718   // 32bit instructions may become sign extended.
  719   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  720   assert(value &lt; (1L &lt;&lt; 48), &quot;instruction too large&quot;);
  721   value = value&lt;&lt;16;
  722   memcpy(cbuf.insts_end(), (unsigned char*)&amp;value, 6);
  723   cbuf.set_insts_end(cbuf.insts_end() + 6);
  724 }
  725 
  726 static inline unsigned int z_emit_inst(CodeBuffer &amp;cbuf, long value) {
  727   if (value &lt; 0) {
  728     // There obviously has been an unintended sign extension (int-&gt;long). Revert it.
  729     value = (long)((unsigned long)((unsigned int)value));
  730   }
  731 
  732   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  733     z_emit16(cbuf, value);
  734     return 2;
  735   }
  736 
  737   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  738     z_emit32(cbuf, value);
  739     return 4;
  740   }
  741 
  742   // 6-byte instruction, probably unaligned store.
  743   z_emit48(cbuf, value);
  744   return 6;
  745 }
  746 
  747 // Check effective address (at runtime) for required alignment.
  748 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
  749   C2_MacroAssembler _masm(&amp;cbuf);
  750 
  751   __ z_lay(Z_R0, disp, index, base);
  752   __ z_nill(Z_R0, alignment-1);
  753   __ z_brc(Assembler::bcondEqual, +3);
  754   __ z_illtrap();
  755 }
  756 
  757 int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,
  758                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  759   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  760   address old_mark = __ inst_mark();
  761   unsigned int start_off = __ offset();
  762 
  763   if (is_native_call) {
  764     ShouldNotReachHere();
  765   }
  766 
  767   if (rtype == relocInfo::runtime_call_w_cp_type) {
  768     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  769     address call_addr = __ call_c_opt((address)entry_point);
  770     if (call_addr == NULL) {
  771       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  772       return -1;
  773     }
  774   } else {
  775     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  776            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  777     __ relocate(rtype);
  778     // BRASL must be prepended with a nop to identify it in the instruction stream.
  779     __ z_nop();
  780     __ z_brasl(Z_R14, (address)entry_point);
  781   }
  782 
  783   unsigned int ret_off = __ offset();
  784 
  785   return (ret_off - start_off);
  786 }
  787 
  788 static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {
  789   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  790   address old_mark = __ inst_mark();
  791   unsigned int start_off = __ offset();
  792 
  793   relocInfo::relocType rtype = rspec.type();
  794   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  795          &quot;unexpected rtype&quot;);
  796 
  797   __ relocate(rspec);
  798   __ z_nop();
  799   __ z_brasl(Z_R14, (address)entry_point);
  800 
  801   unsigned int ret_off = __ offset();
  802 
  803   return (ret_off - start_off);
  804 }
  805 
  806 //=============================================================================
  807 
  808 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
  809 int ConstantTable::calculate_table_base_offset() const {
  810   return 0;  // absolute addressing, no offset
  811 }
  812 
  813 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  814 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  815   ShouldNotReachHere();
  816 }
  817 
  818 // Even with PC-relative TOC addressing, we still need this node.
  819 // Float loads/stores do not support PC-relative addresses.
  820 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  821   C2_MacroAssembler _masm(&amp;cbuf);
  822   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  823   __ load_toc(Rtoc);
  824 }
  825 
  826 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  827   // PCrelative TOC access.
  828   return 6;   // sizeof(LARL)
  829 }
  830 
  831 #if !defined(PRODUCT)
  832 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  833   Register r = as_Register(ra_-&gt;get_encode(this));
  834   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  835 }
  836 #endif
  837 
  838 //=============================================================================
  839 
  840 #if !defined(PRODUCT)
  841 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  842   Compile* C = ra_-&gt;C;
  843   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  844   st-&gt;print(&quot;\t&quot;);
  845   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  846     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  847   }
  848 
  849   if (VerifyThread) {
  850     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  851     st-&gt;print(&quot;\t&quot;);
  852   }
  853 
  854   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  855   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();
  856 
  857   // Calls to C2R adapters often do not accept exceptional returns.
  858   // We require that their callers must bang for them. But be
  859   // careful, because some VM calls (such as call site linkage) can
  860   // use several kilobytes of stack. But the stack safety zone should
  861   // account for that. See bugs 4446381, 4468289, 4497237.
  862   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  863     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  864   }
  865   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  866   st-&gt;print(&quot;\t&quot;);
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   C2_MacroAssembler _masm(&amp;cbuf);
  873 
  874   __ verify_thread();
  875 
  876   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  877   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();
  878 
  879   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  880 
  881   if (C-&gt;clinit_barrier_on_entry()) {
  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  883 
  884     Label L_skip_barrier;
  885     Register klass = Z_R1_scratch;
  886 
  887     // Notify OOP recorder (don&#39;t need the relocation)
  888     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  889     __ load_const_optimized(klass, md.value());
  890     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  891 
  892     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  893     __ z_br(klass);
  894 
  895     __ bind(L_skip_barrier);
  896   }
  897 
  898   // Calls to C2R adapters often do not accept exceptional returns.
  899   // We require that their callers must bang for them. But be
  900   // careful, because some VM calls (such as call site linkage) can
  901   // use several kilobytes of stack. But the stack safety zone should
  902   // account for that. See bugs 4446381, 4468289, 4497237.
  903   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  904     __ generate_stack_overflow_check(bangsize);
  905   }
  906 
  907   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  908   __ save_return_pc();
  909 
  910   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  911   // &#39;out_preserve_stack_slots&#39; declaration.
  912   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  913 
  914   if (C-&gt;has_mach_constant_base_node()) {
  915     // NOTE: We set the table base offset here because users might be
  916     // emitted before MachConstantBaseNode.
  917     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  918     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  919   }
  920 }
  921 
  922 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  923   // Variable size. Determine dynamically.
  924   return MachNode::size(ra_);
  925 }
  926 
  927 int MachPrologNode::reloc() const {
  928   // Return number of relocatable values contained in this instruction.
  929   return 1; // One reloc entry for load_const(toc).
  930 }
  931 
  932 //=============================================================================
  933 
  934 #if !defined(PRODUCT)
  935 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  936   os-&gt;print_cr(&quot;epilog&quot;);
  937   os-&gt;print(&quot;\t&quot;);
  938   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  939     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  940     os-&gt;print(&quot;\t&quot;);
  941   }
  942 }
  943 #endif
  944 
  945 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  946   C2_MacroAssembler _masm(&amp;cbuf);
  947   Compile* C = ra_-&gt;C;
  948   __ verify_thread();
  949 
  950   // If this does safepoint polling, then do it here.
  951   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  952 
  953   // Pop frame, restore return_pc, and all stuff needed by interpreter.
  954   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);
  955   __ pop_frame_restore_retPC(frame_size_in_bytes);
  956 
  957   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  958     __ reserved_stack_check(Z_R14);
  959   }
  960 
  961   // Touch the polling page.
  962   if (need_polling) {
  963     __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  964     // We need to mark the code position where the load from the safepoint
  965     // polling page was emitted as relocInfo::poll_return_type here.
  966     __ relocate(relocInfo::poll_return_type);
  967     __ load_from_polling_page(Z_R1_scratch);
  968   }
  969 }
  970 
  971 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  972   // Variable size. determine dynamically.
  973   return MachNode::size(ra_);
  974 }
  975 
  976 int MachEpilogNode::reloc() const {
  977   // Return number of relocatable values contained in this instruction.
  978   return 1; // One for load_from_polling_page.
  979 }
  980 
  981 const Pipeline * MachEpilogNode::pipeline() const {
  982   return MachNode::pipeline_class();
  983 }
  984 
  985 //=============================================================================
  986 
  987 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  988 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  989 
  990 static enum RC rc_class(OptoReg::Name reg) {
  991   // Return the register class for the given register. The given register
  992   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  993   // enumeration in adGlobals_s390.hpp.
  994 
  995   if (reg == OptoReg::Bad) {
  996     return rc_bad;
  997   }
  998 
  999   // We have 32 integer register halves, starting at index 0.
 1000   if (reg &lt; 32) {
 1001     return rc_int;
 1002   }
 1003 
 1004   // We have 32 floating-point register halves, starting at index 32.
 1005   if (reg &lt; 32+32) {
 1006     return rc_float;
 1007   }
 1008 
 1009   // Between float regs &amp; stack are the flags regs.
 1010   assert(reg &gt;= OptoReg::stack0(), &quot;blow up if spilling flags&quot;);
 1011   return rc_stack;
 1012 }
 1013 
 1014 // Returns size as obtained from z_emit_instr.
 1015 static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,
 1016                                    int reg, int offset, bool do_print, outputStream *os) {
 1017 
 1018   if (cbuf) {
 1019     if (opcode &gt; (1L&lt;&lt;32)) {
 1020       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1021                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1022     } else {
 1023       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1024                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1025     }
 1026   }
 1027 
 1028 #if !defined(PRODUCT)
 1029   if (do_print) {
 1030     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1031   }
 1032 #endif
 1033   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1034 }
 1035 
 1036 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1037   if (cbuf) {
 1038     C2_MacroAssembler _masm(cbuf);
 1039     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1040   }
 1041 
 1042 #if !defined(PRODUCT)
 1043   else if (do_print) {
 1044     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1045   }
 1046 #endif
 1047 
 1048   return 6;
 1049 }
 1050 
 1051 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1052   // Get registers to move.
 1053   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1054   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1055   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1056   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1057 
 1058   enum RC src_hi_rc = rc_class(src_hi);
 1059   enum RC src_lo_rc = rc_class(src_lo);
 1060   enum RC dst_hi_rc = rc_class(dst_hi);
 1061   enum RC dst_lo_rc = rc_class(dst_lo);
 1062 
 1063   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1064   bool is64 = (src_hi_rc != rc_bad);
 1065   assert(!is64 ||
 1066          ((src_lo&amp;1) == 0 &amp;&amp; src_lo+1 == src_hi &amp;&amp; (dst_lo&amp;1) == 0 &amp;&amp; dst_lo+1 == dst_hi),
 1067          &quot;expected aligned-adjacent pairs&quot;);
 1068 
 1069   // Generate spill code!
 1070 
 1071   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi) {
 1072     return 0;            // Self copy, no move.
 1073   }
 1074 
 1075   int  src_offset = ra_-&gt;reg2offset(src_lo);
 1076   int  dst_offset = ra_-&gt;reg2offset(dst_lo);
 1077   bool print = !do_size;
 1078   bool src12 = Immediate::is_uimm12(src_offset);
 1079   bool dst12 = Immediate::is_uimm12(dst_offset);
 1080 
 1081   const char   *mnemo = NULL;
 1082   unsigned long opc = 0;
 1083 
 1084   // Memory-&gt;Memory Spill. Use Z_R0 to hold the value.
 1085   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1086 
 1087     assert(!is64 || (src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack),
 1088            &quot;expected same type of move for high parts&quot;);
 1089 
 1090     if (src12 &amp;&amp; dst12) {
 1091       return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);
 1092     }
 1093 
 1094     int r0 = Z_R0_num;
 1095     if (is64) {
 1096       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1097              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1098     }
 1099 
 1100     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1101            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1102   }
 1103 
 1104   // Check for float-&gt;int copy. Requires a trip through memory.
 1105   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1106     Unimplemented();  // Unsafe, do not remove!
 1107   }
 1108 
 1109   // Check for integer reg-reg copy.
 1110   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1111     if (cbuf) {
 1112       C2_MacroAssembler _masm(cbuf);
 1113       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1114       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1115       __ z_lgr(Rdst, Rsrc);
 1116       return 4;
 1117     }
 1118 #if !defined(PRODUCT)
 1119     // else
 1120     if (print) {
 1121       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1122     }
 1123 #endif
 1124     return 4;
 1125   }
 1126 
 1127   // Check for integer store.
 1128   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1129     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1130            &quot;expected same type of move for high parts&quot;);
 1131 
 1132     if (is64) {
 1133       return z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, src_lo, dst_offset, print, os);
 1134     }
 1135 
 1136     // else
 1137     mnemo = dst12 ? &quot;ST  &quot; : &quot;STY &quot;;
 1138     opc = dst12 ? ST_ZOPC : STY_ZOPC;
 1139 
 1140     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1141   }
 1142 
 1143   // Check for integer load
 1144   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1145   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1146 
 1147     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1148            &quot;expected same type of move for high parts&quot;);
 1149 
 1150     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1151     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1152 
 1153     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1154   }
 1155 
 1156   // Check for float reg-reg copy.
 1157   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1158     if (cbuf) {
 1159       C2_MacroAssembler _masm(cbuf);
 1160       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1161       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1162       __ z_ldr(Rdst, Rsrc);
 1163       return 2;
 1164     }
 1165 #if !defined(PRODUCT)
 1166     // else
 1167     if (print) {
 1168       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1169     }
 1170 #endif
 1171     return 2;
 1172   }
 1173 
 1174   // Check for float store.
 1175   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1176     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1177            &quot;expected same type of move for high parts&quot;);
 1178 
 1179     if (is64) {
 1180       mnemo = dst12 ? &quot;STD  &quot; : &quot;STDY &quot;;
 1181       opc = dst12 ? STD_ZOPC : STDY_ZOPC;
 1182       return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1183     }
 1184     // else
 1185 
 1186     mnemo = dst12 ? &quot;STE  &quot; : &quot;STEY &quot;;
 1187     opc = dst12 ? STE_ZOPC : STEY_ZOPC;
 1188     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1189   }
 1190 
 1191   // Check for float load.
 1192   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1193     assert(!is64 || (dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack),
 1194            &quot;expected same type of move for high parts&quot;);
 1195 
 1196     if (is64) {
 1197       mnemo = src12 ? &quot;LD   &quot; : &quot;LDY  &quot;;
 1198       opc = src12 ? LD_ZOPC : LDY_ZOPC;
 1199       return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1200     }
 1201     // else
 1202 
 1203     mnemo = src12 ? &quot;LE   &quot; : &quot;LEY  &quot;;
 1204     opc = src12 ? LE_ZOPC : LEY_ZOPC;
 1205     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1206   }
 1207 
 1208   // --------------------------------------------------------------------
 1209   // Check for hi bits still needing moving. Only happens for misaligned
 1210   // arguments to native calls.
 1211   if (src_hi == dst_hi) {
 1212     return 0;               // Self copy, no move.
 1213   }
 1214 
 1215   assert(is64 &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1216   Unimplemented();  // Unsafe, do not remove!
 1217 
 1218   return 0; // never reached, but make the compiler shut up!
 1219 }
 1220 
 1221 #if !defined(PRODUCT)
 1222 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1223   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1224     implementation(NULL, ra_, false, os);
 1225   } else {
 1226     if (req() == 2 &amp;&amp; in(1)) {
 1227       os-&gt;print(&quot;N%d = N%d\n&quot;, _idx, in(1)-&gt;_idx);
 1228     } else {
 1229       const char *c = &quot;(&quot;;
 1230       os-&gt;print(&quot;N%d = &quot;, _idx);
 1231       for (uint i = 1; i &lt; req(); ++i) {
 1232         os-&gt;print(&quot;%sN%d&quot;, c, in(i)-&gt;_idx);
 1233         c = &quot;, &quot;;
 1234       }
 1235       os-&gt;print(&quot;)&quot;);
 1236     }
 1237   }
 1238 }
 1239 #endif
 1240 
 1241 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1242   implementation(&amp;cbuf, ra_, false, NULL);
 1243 }
 1244 
 1245 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1246   return implementation(NULL, ra_, true, NULL);
 1247 }
 1248 
 1249 //=============================================================================
 1250 
 1251 #if !defined(PRODUCT)
 1252 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1253   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1254 }
 1255 #endif
 1256 
 1257 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
 1258   C2_MacroAssembler _masm(&amp;cbuf);
 1259 
 1260   int rem_space = 0;
 1261   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1262     rem_space = cbuf.insts()-&gt;remaining();
 1263     if (rem_space &lt;= _count*2 + 8) {
 1264       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1265     }
 1266   }
 1267 
 1268   for (int i = 0; i &lt; _count; i++) {
 1269     __ z_nop();
 1270   }
 1271 
 1272   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1273     if (rem_space &lt;= _count*2 + 8) {
 1274       int rem_space2 = cbuf.insts()-&gt;remaining();
 1275       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1276     }
 1277   }
 1278 }
 1279 
 1280 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1281    return 2 * _count;
 1282 }
 1283 
 1284 #if !defined(PRODUCT)
 1285 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1286   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1287   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1288     int reg = ra_-&gt;get_reg_first(this);
 1289     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1290   } else {
 1291     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1292   }
 1293 }
 1294 #endif
 1295 
 1296 // Take care of the size function, if you make changes here!
 1297 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1298   C2_MacroAssembler _masm(&amp;cbuf);
 1299 
 1300   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1301   int reg = ra_-&gt;get_encode(this);
 1302   __ z_lay(as_Register(reg), offset, Z_SP);
 1303 }
 1304 
 1305 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1306   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1307   return 6;
 1308 }
 1309 
 1310  %} // end source section
 1311 
 1312 //----------SOURCE BLOCK-------------------------------------------------------
 1313 // This is a block of C++ code which provides values, functions, and
 1314 // definitions necessary in the rest of the architecture description
 1315 
 1316 source_hpp %{
 1317 
 1318 // Header information of the source block.
 1319 // Method declarations/definitions which are used outside
 1320 // the ad-scope can conveniently be defined here.
 1321 //
 1322 // To keep related declarations/definitions/uses close together,
 1323 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 1324 
 1325 //--------------------------------------------------------------
 1326 // Used for optimization in Compile::Shorten_branches
 1327 //--------------------------------------------------------------
 1328 
 1329 class CallStubImpl {
 1330  public:
 1331 
 1332   // call trampolines
 1333   // Size of call trampoline stub. For add&#39;l comments, see size_java_to_interp().
 1334   static uint size_call_trampoline() {
 1335     return 0; // no call trampolines on this platform
 1336   }
 1337 
 1338   // call trampolines
 1339   // Number of relocations needed by a call trampoline stub.
 1340   static uint reloc_call_trampoline() {
 1341     return 0; // No call trampolines on this platform.
 1342   }
 1343 };
 1344 
 1345 %} // end source_hpp section
 1346 
 1347 source %{
 1348 
 1349 #if !defined(PRODUCT)
 1350 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1351   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1352   os-&gt;print_cr(&quot;\tTA&quot;);
 1353   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1354   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1355   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1356   os-&gt;print_cr(&quot;\t...&quot;);
 1357   os-&gt;print_cr(&quot;\tTA&quot;);
 1358   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1359   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1360 }
 1361 #endif
 1362 
 1363 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1364   C2_MacroAssembler _masm(&amp;cbuf);
 1365   const int ic_miss_offset = 2;
 1366 
 1367   // Inline_cache contains a klass.
 1368   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1369   // ARG1 is the receiver oop.
 1370   Register R2_receiver = Z_ARG1;
 1371   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1372   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1373   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1374 
 1375   // Null check of receiver.
 1376   // This is the null check of the receiver that actually should be
 1377   // done in the caller. It&#39;s here because in case of implicit null
 1378   // checks we get it for free.
 1379   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1380          &quot;second word in oop should not require explicit null check.&quot;);
 1381   if (!ImplicitNullChecks) {
 1382     Label valid;
 1383     if (VM_Version::has_CompareBranch()) {
 1384       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
 1385     } else {
 1386       __ z_ltgr(R2_receiver, R2_receiver);
 1387       __ z_bre(valid);
 1388     }
 1389     // The ic_miss_stub will handle the null pointer exception.
 1390     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1391     __ z_br(R1_ic_miss_stub_addr);
 1392     __ bind(valid);
 1393   }
 1394 
 1395   // Check whether this method is the proper implementation for the class of
 1396   // the receiver (ic miss check).
 1397   {
 1398     Label valid;
 1399     // Compare cached class against klass from receiver.
 1400     // This also does an implicit null check!
 1401     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1402     __ z_bre(valid);
 1403     // The inline cache points to the wrong method. Call the
 1404     // ic_miss_stub to find the proper method.
 1405     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1406     __ z_br(R1_ic_miss_stub_addr);
 1407     __ bind(valid);
 1408   }
 1409 }
 1410 
 1411 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1412   // Determine size dynamically.
 1413   return MachNode::size(ra_);
 1414 }
 1415 
 1416 //=============================================================================
 1417 
 1418 %} // interrupt source section
 1419 
 1420 source_hpp %{ // Header information of the source block.
 1421 
 1422 class HandlerImpl {
 1423  public:
 1424 
 1425   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1426   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1427 
 1428   static uint size_exception_handler() {
 1429     return NativeJump::max_instruction_size();
 1430   }
 1431 
 1432   static uint size_deopt_handler() {
 1433     return NativeCall::max_instruction_size();
 1434   }
 1435 };
 1436 
 1437 class Node::PD {
 1438 public:
 1439   enum NodeFlags {
 1440     _last_flag = Node::_last_flag
 1441   };
 1442 };
 1443 
 1444 %} // end source_hpp section
 1445 
 1446 source %{
 1447 
 1448 // This exception handler code snippet is placed after the method&#39;s
 1449 // code. It is the return point if an exception occurred. it jumps to
 1450 // the exception blob.
 1451 //
 1452 // If the method gets deoptimized, the method and this code snippet
 1453 // get patched.
 1454 //
 1455 // 1) Trampoline code gets patched into the end of this exception
 1456 //   handler. the trampoline code jumps to the deoptimization blob.
 1457 //
 1458 // 2) The return address in the method&#39;s code will get patched such
 1459 //   that it jumps to the trampoline.
 1460 //
 1461 // 3) The handler will get patched such that it does not jump to the
 1462 //   exception blob, but to an entry in the deoptimization blob being
 1463 //   aware of the exception.
 1464 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1465   Register temp_reg = Z_R1;
 1466   C2_MacroAssembler _masm(&amp;cbuf);
 1467 
 1468   address base = __ start_a_stub(size_exception_handler());
 1469   if (base == NULL) {
 1470     return 0;          // CodeBuffer::expand failed
 1471   }
 1472 
 1473   int offset = __ offset();
 1474   // Use unconditional pc-relative jump with 32-bit range here.
 1475   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1476   __ z_br(temp_reg);
 1477 
 1478   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1479 
 1480   __ end_a_stub();
 1481 
 1482   return offset;
 1483 }
 1484 
 1485 // Emit deopt handler code.
 1486 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1487   C2_MacroAssembler _masm(&amp;cbuf);
 1488   address        base = __ start_a_stub(size_deopt_handler());
 1489 
 1490   if (base == NULL) {
 1491     return 0;  // CodeBuffer::expand failed
 1492   }
 1493 
 1494   int offset = __ offset();
 1495 
 1496   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1497   // we do not use load_const_opt here.
 1498   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1499   __ call(Z_R1);
 1500   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1501 
 1502   __ end_a_stub();
 1503   return offset;
 1504 }
 1505 
 1506 //=============================================================================
 1507 
 1508 
 1509 // Given a register encoding, produce an Integer Register object.
 1510 static Register reg_to_register_object(int register_encoding) {
 1511   assert(Z_R12-&gt;encoding() == Z_R12_enc, &quot;wrong coding&quot;);
 1512   return as_Register(register_encoding);
 1513 }
 1514 
 1515 const bool Matcher::match_rule_supported(int opcode) {
 1516   if (!has_match_rule(opcode)) return false;
 1517 
 1518   switch (opcode) {
 1519     case Op_CountLeadingZerosI:
 1520     case Op_CountLeadingZerosL:
 1521     case Op_CountTrailingZerosI:
 1522     case Op_CountTrailingZerosL:
 1523       // Implementation requires FLOGR instruction, which is available since z9.
 1524       return true;
 1525 
 1526     case Op_ReverseBytesI:
 1527     case Op_ReverseBytesL:
 1528       return UseByteReverseInstruction;
 1529 
 1530     // PopCount supported by H/W from z/Architecture G5 (z196) on.
 1531     case Op_PopCountI:
 1532     case Op_PopCountL:
 1533       return UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount();
 1534 
 1535     case Op_StrComp:
 1536       return SpecialStringCompareTo;
 1537     case Op_StrEquals:
 1538       return SpecialStringEquals;
 1539     case Op_StrIndexOf:
 1540     case Op_StrIndexOfChar:
 1541       return SpecialStringIndexOf;
 1542 
 1543     case Op_GetAndAddI:
 1544     case Op_GetAndAddL:
 1545       return true;
 1546       // return VM_Version::has_AtomicMemWithImmALUOps();
 1547     case Op_GetAndSetI:
 1548     case Op_GetAndSetL:
 1549     case Op_GetAndSetP:
 1550     case Op_GetAndSetN:
 1551       return true;  // General CAS implementation, always available.
 1552 
 1553     default:
 1554       return true;  // Per default match rules are supported.
 1555                     // BUT: make sure match rule is not disabled by a false predicate!
 1556   }
 1557 
 1558   return true;  // Per default match rules are supported.
 1559                 // BUT: make sure match rule is not disabled by a false predicate!
 1560 }
 1561 
 1562 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1563   // TODO
 1564   // Identify extra cases that we might want to provide match rules for
 1565   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1566   bool ret_value = match_rule_supported(opcode);
 1567   // Add rules here.
 1568 
 1569   return ret_value;  // Per default match rules are supported.
 1570 }
 1571 
 1572 int Matcher::regnum_to_fpu_offset(int regnum) {
 1573   ShouldNotReachHere();
 1574   return regnum - 32; // The FP registers are in the second chunk.
 1575 }
 1576 
 1577 const bool Matcher::has_predicated_vectors(void) {
 1578   return false;
 1579 }
 1580 
 1581 const int Matcher::float_pressure(int default_pressure_threshold) {
 1582   return default_pressure_threshold;
 1583 }
 1584 
 1585 const bool Matcher::convL2FSupported(void) {
 1586   return true; // False means that conversion is done by runtime call.
 1587 }
 1588 
 1589 //----------SUPERWORD HELPERS----------------------------------------
 1590 
 1591 // Vector width in bytes.
 1592 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1593   assert(MaxVectorSize == 8, &quot;&quot;);
 1594   return 8;
 1595 }
 1596 
 1597 // Vector ideal reg.
 1598 const uint Matcher::vector_ideal_reg(int size) {
 1599   assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 1600   return Op_RegL;
 1601 }
 1602 
 1603 // Limits on vector size (number of elements) loaded into vector.
 1604 const int Matcher::max_vector_size(const BasicType bt) {
 1605   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1606   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1607 }
 1608 
 1609 const int Matcher::min_vector_size(const BasicType bt) {
 1610   return max_vector_size(bt); // Same as max.
 1611 }
 1612 
 1613 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1614   fatal(&quot;vector shift is not supported&quot;);
 1615   return Node::NotAMachineReg;
 1616 }
 1617 
 1618 // z/Architecture does support misaligned store/load at minimal extra cost.
 1619 const bool Matcher::misaligned_vectors_ok() {
 1620   return true;
 1621 }
 1622 
 1623 // Not yet ported to z/Architecture.
 1624 const bool Matcher::pass_original_key_for_aes() {
 1625   return false;
 1626 }
 1627 
 1628 // RETURNS: whether this branch offset is short enough that a short
 1629 // branch can be used.
 1630 //
 1631 // If the platform does not provide any short branch variants, then
 1632 // this method should return `false&#39; for offset 0.
 1633 //
 1634 // `Compile::Fill_buffer&#39; will decide on basis of this information
 1635 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 1636 //
 1637 // And `Compile::Shorten_branches&#39; will decide on basis of this
 1638 // information whether to replace particular branch sites by short
 1639 // ones.
 1640 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1641   // On zarch short branches use a 16 bit signed immediate that
 1642   // is the pc-relative offset in halfword (= 2 bytes) units.
 1643   return Assembler::is_within_range_of_RelAddr16((address)((long)offset), (address)0);
 1644 }
 1645 
 1646 const bool Matcher::isSimpleConstant64(jlong value) {
 1647   // Probably always true, even if a temp register is required.
 1648   return true;
 1649 }
 1650 
 1651 // Should correspond to setting above
 1652 const bool Matcher::init_array_count_is_in_bytes = false;
 1653 
 1654 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1655 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1656 
 1657 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1658 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1659 
 1660 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1661 const bool Matcher::require_postalloc_expand = false;
 1662 
 1663 // Do we need to mask the count passed to shift instructions or does
 1664 // the cpu only look at the lower 5/6 bits anyway?
 1665 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1666 // Constant shift counts are handled in Ideal phase.
 1667 const bool Matcher::need_masked_shift_count = false;
 1668 
 1669 // No support for generic vector operands.
 1670 const bool Matcher::supports_generic_vector_operands  = false;
 1671 
 1672 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1673   ShouldNotReachHere(); // generic vector operands not supported
 1674   return NULL;
 1675 }
 1676 
 1677 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1678   ShouldNotReachHere();  // generic vector operands not supported
 1679   return false;
 1680 }
 1681 
 1682 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1683   ShouldNotReachHere();  // generic vector operands not supported
 1684   return false;
 1685 }
 1686 
 1687 // Set this as clone_shift_expressions.
 1688 bool Matcher::narrow_oop_use_complex_address() {
 1689   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;
 1690   return false;
 1691 }
 1692 
 1693 bool Matcher::narrow_klass_use_complex_address() {
 1694   NOT_LP64(ShouldNotCallThis());
 1695   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1696   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1697   return false;
 1698 }
 1699 
 1700 bool Matcher::const_oop_prefer_decode() {
 1701   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1702   return CompressedOops::base() == NULL;
 1703 }
 1704 
 1705 bool Matcher::const_klass_prefer_decode() {
 1706   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1707   return CompressedKlassPointers::base() == NULL;
 1708 }
 1709 
 1710 // Is it better to copy float constants, or load them directly from memory?
 1711 // Most RISCs will have to materialize an address into a
 1712 // register first, so they would do better to copy the constant from stack.
 1713 const bool Matcher::rematerialize_float_constants = false;
 1714 
 1715 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1716 // needed. Else we split the double into 2 integer pieces and move it
 1717 // piece-by-piece. Only happens when passing doubles into C code as the
 1718 // Java calling convention forces doubles to be aligned.
 1719 const bool Matcher::misaligned_doubles_ok = true;
 1720 
 1721 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1722 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1723 
 1724 // Do floats take an entire double register or just half?
 1725 //
 1726 // A float in resides in a zarch double register. When storing it by
 1727 // z_std, it cannot be restored in C-code by reloading it as a double
 1728 // and casting it into a float afterwards.
 1729 bool Matcher::float_in_double() { return false; }
 1730 
 1731 // Do ints take an entire long register or just half?
 1732 // The relevant question is how the int is callee-saved:
 1733 // the whole long is written but de-opt&#39;ing will have to extract
 1734 // the relevant 32 bits.
 1735 const bool Matcher::int_in_long = true;
 1736 
 1737 // Constants for c2c and c calling conventions.
 1738 
 1739 const MachRegisterNumbers z_iarg_reg[5] = {
 1740   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1741 };
 1742 
 1743 const MachRegisterNumbers z_farg_reg[4] = {
 1744   Z_F0_num, Z_F2_num, Z_F4_num, Z_F6_num
 1745 };
 1746 
 1747 const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 1748 
 1749 const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 1750 
 1751 // Return whether or not this register is ever used as an argument. This
 1752 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1753 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1754 // arguments in those registers not be available to the callee.
 1755 bool Matcher::can_be_java_arg(int reg) {
 1756   // We return true for all registers contained in z_iarg_reg[] and
 1757   // z_farg_reg[] and their virtual halves.
 1758   // We must include the virtual halves in order to get STDs and LDs
 1759   // instead of STWs and LWs in the trampoline stubs.
 1760 
 1761   if (reg == Z_R2_num || reg == Z_R2_H_num ||
 1762       reg == Z_R3_num || reg == Z_R3_H_num ||
 1763       reg == Z_R4_num || reg == Z_R4_H_num ||
 1764       reg == Z_R5_num || reg == Z_R5_H_num ||
 1765       reg == Z_R6_num || reg == Z_R6_H_num) {
 1766     return true;
 1767   }
 1768 
 1769   if (reg == Z_F0_num || reg == Z_F0_H_num ||
 1770       reg == Z_F2_num || reg == Z_F2_H_num ||
 1771       reg == Z_F4_num || reg == Z_F4_H_num ||
 1772       reg == Z_F6_num || reg == Z_F6_H_num) {
 1773     return true;
 1774   }
 1775 
 1776   return false;
 1777 }
 1778 
 1779 bool Matcher::is_spillable_arg(int reg) {
 1780   return can_be_java_arg(reg);
 1781 }
 1782 
 1783 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 1784   return false;
 1785 }
 1786 
 1787 // Register for DIVI projection of divmodI
 1788 RegMask Matcher::divI_proj_mask() {
 1789   return _Z_RARG4_INT_REG_mask;
 1790 }
 1791 
 1792 // Register for MODI projection of divmodI
 1793 RegMask Matcher::modI_proj_mask() {
 1794   return _Z_RARG3_INT_REG_mask;
 1795 }
 1796 
 1797 // Register for DIVL projection of divmodL
 1798 RegMask Matcher::divL_proj_mask() {
 1799   return _Z_RARG4_LONG_REG_mask;
 1800 }
 1801 
 1802 // Register for MODL projection of divmodL
 1803 RegMask Matcher::modL_proj_mask() {
 1804   return _Z_RARG3_LONG_REG_mask;
 1805 }
 1806 
 1807 // Copied from sparc.
 1808 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1809   return RegMask();
 1810 }
 1811 
 1812 const bool Matcher::convi2l_type_required = true;
 1813 
 1814 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?
 1815 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {
 1816   return false;
 1817 }
 1818 
 1819 // Should the Matcher clone shifts on addressing modes, expecting them
 1820 // to be subsumed into complex addressing expressions or compute them
 1821 // into registers?
 1822 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1823   return clone_base_plus_offset_address(m, mstack, address_visited);
 1824 }
 1825 
 1826 void Compile::reshape_address(AddPNode* addp) {
 1827 }
 1828 
 1829 %} // source
 1830 
 1831 //----------ENCODING BLOCK-----------------------------------------------------
 1832 // This block specifies the encoding classes used by the compiler to output
 1833 // byte streams. Encoding classes are parameterized macros used by
 1834 // Machine Instruction Nodes in order to generate the bit encoding of the
 1835 // instruction. Operands specify their base encoding interface with the
 1836 // interface keyword. There are currently supported four interfaces,
 1837 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1838 // operand to generate a function which returns its register number when
 1839 // queried. CONST_INTER causes an operand to generate a function which
 1840 // returns the value of the constant when queried. MEMORY_INTER causes an
 1841 // operand to generate four functions which return the Base Register, the
 1842 // Index Register, the Scale Value, and the Offset Value of the operand when
 1843 // queried. COND_INTER causes an operand to generate six functions which
 1844 // return the encoding code (ie - encoding bits for the instruction)
 1845 // associated with each basic boolean condition for a conditional instruction.
 1846 //
 1847 // Instructions specify two basic values for encoding. Again, a function
 1848 // is available to check if the constant displacement is an oop. They use the
 1849 // ins_encode keyword to specify their encoding classes (which must be
 1850 // a sequence of enc_class names, and their parameters, specified in
 1851 // the encoding block), and they use the
 1852 // opcode keyword to specify, in order, their primary, secondary, and
 1853 // tertiary opcode. Only the opcode sections which a particular instruction
 1854 // needs for encoding need to be specified.
 1855 encode %{
 1856   enc_class enc_unimplemented %{
 1857     C2_MacroAssembler _masm(&amp;cbuf);
 1858     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1859   %}
 1860 
 1861   enc_class enc_untested %{
 1862 #ifdef ASSERT
 1863     C2_MacroAssembler _masm(&amp;cbuf);
 1864     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1865 #endif
 1866   %}
 1867 
 1868   enc_class z_rrform(iRegI dst, iRegI src) %{
 1869     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1870     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1871     z_emit16(cbuf, $primary |
 1872              Assembler::reg($dst$$reg,8,16) |
 1873              Assembler::reg($src$$reg,12,16));
 1874   %}
 1875 
 1876   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1877     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1878     z_emit32(cbuf, $primary |
 1879              Assembler::reg($dst1$$reg,24,32) |
 1880              Assembler::reg($src2$$reg,28,32));
 1881   %}
 1882 
 1883   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
 1884     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1885     z_emit32(cbuf, $primary |
 1886              Assembler::reg($dst1$$reg,24,32) |
 1887              Assembler::reg($src2$$reg,28,32) |
 1888              Assembler::reg($src3$$reg,16,32));
 1889   %}
 1890 
 1891   enc_class z_riform_signed(iRegI dst, immI16 src) %{
 1892     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1893     z_emit32(cbuf, $primary |
 1894              Assembler::reg($dst$$reg,8,32) |
 1895              Assembler::simm16($src$$constant,16,32));
 1896   %}
 1897 
 1898   enc_class z_riform_unsigned(iRegI dst, uimmI16 src) %{
 1899     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1900     z_emit32(cbuf, $primary |
 1901              Assembler::reg($dst$$reg,8,32) |
 1902              Assembler::uimm16($src$$constant,16,32));
 1903   %}
 1904 
 1905   enc_class z_rieform_d(iRegI dst1, iRegI src3, immI src2) %{
 1906     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1907     z_emit48(cbuf, $primary |
 1908              Assembler::reg($dst1$$reg,8,48) |
 1909              Assembler::reg($src3$$reg,12,48) |
 1910              Assembler::simm16($src2$$constant,16,48));
 1911   %}
 1912 
 1913   enc_class z_rilform_signed(iRegI dst, immL32 src) %{
 1914     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1915     z_emit48(cbuf, $primary |
 1916              Assembler::reg($dst$$reg,8,48) |
 1917              Assembler::simm32($src$$constant,16,48));
 1918   %}
 1919 
 1920   enc_class z_rilform_unsigned(iRegI dst, uimmL32 src) %{
 1921     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1922     z_emit48(cbuf, $primary |
 1923              Assembler::reg($dst$$reg,8,48) |
 1924              Assembler::uimm32($src$$constant,16,48));
 1925   %}
 1926 
 1927   enc_class z_rsyform_const(iRegI dst, iRegI src1, immI src2) %{
 1928     z_emit48(cbuf, $primary |
 1929              Assembler::reg($dst$$reg,8,48) |
 1930              Assembler::reg($src1$$reg,12,48) |
 1931              Assembler::simm20($src2$$constant));
 1932   %}
 1933 
 1934   enc_class z_rsyform_reg_reg(iRegI dst, iRegI src, iRegI shft) %{
 1935     z_emit48(cbuf, $primary |
 1936              Assembler::reg($dst$$reg,8,48) |
 1937              Assembler::reg($src$$reg,12,48) |
 1938              Assembler::reg($shft$$reg,16,48) |
 1939              Assembler::simm20(0));
 1940   %}
 1941 
 1942   enc_class z_rxform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1943     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1944     z_emit32(cbuf, $primary |
 1945              Assembler::reg($dst$$reg,8,32) |
 1946              Assembler::reg($src1$$reg,12,32) |
 1947              Assembler::reg($src2$$reg,16,32) |
 1948              Assembler::uimm12($con$$constant,20,32));
 1949   %}
 1950 
 1951   enc_class z_rxform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1952     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1953     z_emit32(cbuf, $primary |
 1954              Assembler::reg($dst$$reg,8,32) |
 1955              Assembler::reg($src$$reg,16,32) |
 1956              Assembler::uimm12($con$$constant,20,32));
 1957   %}
 1958 
 1959   enc_class z_rxyform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1960     z_emit48(cbuf, $primary |
 1961              Assembler::reg($dst$$reg,8,48) |
 1962              Assembler::reg($src1$$reg,12,48) |
 1963              Assembler::reg($src2$$reg,16,48) |
 1964              Assembler::simm20($con$$constant));
 1965   %}
 1966 
 1967   enc_class z_rxyform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1968     z_emit48(cbuf, $primary |
 1969              Assembler::reg($dst$$reg,8,48) |
 1970              Assembler::reg($src$$reg,16,48) |
 1971              Assembler::simm20($con$$constant));
 1972   %}
 1973 
 1974   // Direct memory arithmetic.
 1975   enc_class z_siyform(memoryRSY mem, immI8 src) %{
 1976     int      disp = $mem$$disp;
 1977     Register base = reg_to_register_object($mem$$base);
 1978     int      con  = $src$$constant;
 1979 
 1980     assert(VM_Version::has_MemWithImmALUOps(), &quot;unsupported CPU&quot;);
 1981     z_emit_inst(cbuf, $primary |
 1982                 Assembler::regz(base,16,48) |
 1983                 Assembler::simm20(disp) |
 1984                 Assembler::simm8(con,8,48));
 1985   %}
 1986 
 1987   enc_class z_silform(memoryRS mem, immI16 src) %{
 1988     z_emit_inst(cbuf, $primary |
 1989                 Assembler::regz(reg_to_register_object($mem$$base),16,48) |
 1990                 Assembler::uimm12($mem$$disp,20,48) |
 1991                 Assembler::simm16($src$$constant,32,48));
 1992   %}
 1993 
 1994   // Encoder for FP ALU reg/mem instructions (support only short displacements).
 1995   enc_class z_form_rt_memFP(RegF dst, memoryRX mem) %{
 1996     Register Ridx = $mem$$index$$Register;
 1997     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1998     if ($primary &gt; (1L &lt;&lt; 32)) {
 1999       z_emit_inst(cbuf, $primary |
 2000                   Assembler::reg($dst$$reg, 8, 48) |
 2001                   Assembler::uimm12($mem$$disp, 20, 48) |
 2002                   Assembler::reg(Ridx, 12, 48) |
 2003                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2004     } else {
 2005       z_emit_inst(cbuf, $primary |
 2006                   Assembler::reg($dst$$reg, 8, 32) |
 2007                   Assembler::uimm12($mem$$disp, 20, 32) |
 2008                   Assembler::reg(Ridx, 12, 32) |
 2009                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2010     }
 2011   %}
 2012 
 2013   enc_class z_form_rt_mem(iRegI dst, memory mem) %{
 2014     Register Ridx = $mem$$index$$Register;
 2015     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2016     if ($primary &gt; (1L&lt;&lt;32)) {
 2017       z_emit_inst(cbuf, $primary |
 2018                   Assembler::reg($dst$$reg, 8, 48) |
 2019                   Assembler::simm20($mem$$disp) |
 2020                   Assembler::reg(Ridx, 12, 48) |
 2021                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2022     } else {
 2023       z_emit_inst(cbuf, $primary |
 2024                   Assembler::reg($dst$$reg, 8, 32) |
 2025                   Assembler::uimm12($mem$$disp, 20, 32) |
 2026                   Assembler::reg(Ridx, 12, 32) |
 2027                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2028     }
 2029   %}
 2030 
 2031   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2032     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2033     Register Ridx = $mem$$index$$Register;
 2034     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2035 
 2036     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2037       z_emit_inst(cbuf, $secondary |
 2038                   Assembler::reg($dst$$reg, 8, isize) |
 2039                   Assembler::uimm12($mem$$disp, 20, isize) |
 2040                   Assembler::reg(Ridx, 12, isize) |
 2041                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2042     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2043       z_emit_inst(cbuf, $primary |
 2044                   Assembler::reg($dst$$reg, 8, 48) |
 2045                   Assembler::simm20($mem$$disp) |
 2046                   Assembler::reg(Ridx, 12, 48) |
 2047                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2048     } else {
 2049         C2_MacroAssembler _masm(&amp;cbuf);
 2050         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2051         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2052         z_emit_inst(cbuf, $secondary |
 2053                     Assembler::reg($dst$$reg, 8, isize) |
 2054                     Assembler::uimm12(0, 20, isize) |
 2055                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2056                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2057     }
 2058   %}
 2059 
 2060   enc_class z_enc_brul(Label lbl) %{
 2061     C2_MacroAssembler _masm(&amp;cbuf);
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_brul(l);
 2071   %}
 2072 
 2073   enc_class z_enc_bru(Label lbl) %{
 2074     C2_MacroAssembler _masm(&amp;cbuf);
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_bru(l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
 2087     C2_MacroAssembler _masm(&amp;cbuf);
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
 2100     C2_MacroAssembler _masm(&amp;cbuf);
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2110   %}
 2111 
 2112   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2113     C2_MacroAssembler _masm(&amp;cbuf);
 2114     Label* p = $lbl$$label;
 2115 
 2116     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2117     // determine the size of the encoded instruction.
 2118     // Use a bound dummy label in that case.
 2119     Label d;
 2120     __ bind(d);
 2121     Label&amp; l = (NULL == p) ? d : *(p);
 2122     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2123     unsigned long instr = $primary;
 2124     if (instr == CRJ_ZOPC) {
 2125       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2126     } else if (instr == CLRJ_ZOPC) {
 2127       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2128     } else if (instr == CGRJ_ZOPC) {
 2129       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2130     } else {
 2131       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2132       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2133     }
 2134   %}
 2135 
 2136   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2137     C2_MacroAssembler _masm(&amp;cbuf);
 2138     Label* p = $lbl$$label;
 2139 
 2140     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2141     // determine the size of the encoded instruction.
 2142     // Use a bound dummy label in that case.
 2143     Label d;
 2144     __ bind(d);
 2145     Label&amp; l = (NULL == p) ? d : *(p);
 2146 
 2147     unsigned long instr = $primary;
 2148     if (instr == CR_ZOPC) {
 2149       __ z_cr($src1$$Register, $src2$$Register);
 2150     } else if (instr == CLR_ZOPC) {
 2151       __ z_clr($src1$$Register, $src2$$Register);
 2152     } else if (instr == CGR_ZOPC) {
 2153       __ z_cgr($src1$$Register, $src2$$Register);
 2154     } else {
 2155       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2156       __ z_clgr($src1$$Register, $src2$$Register);
 2157     }
 2158 
 2159     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2160   %}
 2161 
 2162   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2163     C2_MacroAssembler _masm(&amp;cbuf);
 2164     Label* p = $lbl$$label;
 2165 
 2166     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2167     // determine the size of the encoded instruction.
 2168     // Use a bound dummy label in that case.
 2169     Label d;
 2170     __ bind(d);
 2171     Label&amp; l = (NULL == p) ? d : *(p);
 2172 
 2173     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2174     unsigned long instr = $primary;
 2175     if (instr == CIJ_ZOPC) {
 2176       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2177     } else if (instr == CLIJ_ZOPC) {
 2178       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2179     } else if (instr == CGIJ_ZOPC) {
 2180       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2181     } else {
 2182       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2183       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2184     }
 2185   %}
 2186 
 2187   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2188     C2_MacroAssembler _masm(&amp;cbuf);
 2189     Label* p = $lbl$$label;
 2190 
 2191     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2192     // determine the size of the encoded instruction.
 2193     // Use a bound dummy label in that case.
 2194     Label d;
 2195     __ bind(d);
 2196     Label&amp; l = (NULL == p) ? d : *(p);
 2197 
 2198     unsigned long instr = $primary;
 2199     if (instr == CHI_ZOPC) {
 2200       __ z_chi($src1$$Register, $src2$$constant);
 2201     } else if (instr == CLFI_ZOPC) {
 2202       __ z_clfi($src1$$Register, $src2$$constant);
 2203     } else if (instr == CGHI_ZOPC) {
 2204       __ z_cghi($src1$$Register, $src2$$constant);
 2205     } else {
 2206       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2207       __ z_clgfi($src1$$Register, $src2$$constant);
 2208     }
 2209 
 2210     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2211   %}
 2212 
 2213   // Call from Java to runtime.
 2214   enc_class z_enc_java_to_runtime_call(method meth) %{
 2215     C2_MacroAssembler _masm(&amp;cbuf);
 2216 
 2217     // Save return pc before call to the place where we need it, since
 2218     // callee doesn&#39;t.
 2219     unsigned int start_off = __ offset();
 2220     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2221     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2222     __ get_PC(Z_R14, size_of_code);
 2223     __ save_return_pc();
 2224     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2225 
 2226     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2227     address call_addr = __ call_c_opt((address)$meth$$method);
 2228     if (call_addr == NULL) {
 2229       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2230       return;
 2231     }
 2232 
 2233 #ifdef ASSERT
 2234     // Plausibility check for size_of_code assumptions.
 2235     unsigned int actual_ret_off = __ offset();
 2236     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2237 #endif
 2238   %}
 2239 
 2240   enc_class z_enc_java_static_call(method meth) %{
 2241     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2242     // whom we intended to call.
 2243     C2_MacroAssembler _masm(&amp;cbuf);
 2244     int ret_offset = 0;
 2245 
 2246     if (!_method) {
 2247       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2248                                    relocInfo::runtime_call_w_cp_type, ra_);
 2249     } else {
 2250       int method_index = resolved_method_index(cbuf);
 2251       if (_optimized_virtual) {
 2252         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2253                                      opt_virtual_call_Relocation::spec(method_index));
 2254       } else {
 2255         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2256                                      static_call_Relocation::spec(method_index));
 2257       }
 2258     }
 2259     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2260 
 2261     if (_method) { // Emit stub for static call.
 2262       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2263       if (stub == NULL) {
 2264         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2265         return;
 2266       }
 2267     }
 2268   %}
 2269 
 2270   // Java dynamic call
 2271   enc_class z_enc_java_dynamic_call(method meth) %{
 2272     C2_MacroAssembler _masm(&amp;cbuf);
 2273     unsigned int start_off = __ offset();
 2274 
 2275     int vtable_index = this-&gt;_vtable_index;
 2276     if (vtable_index == -4) {
 2277       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2278       address virtual_call_oop_addr = NULL;
 2279 
 2280       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2281       virtual_call_oop_addr = __ pc();
 2282       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2283       if (!success) {
 2284         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2285         return;
 2286       }
 2287 
 2288       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2289       // to determine who we intended to call.
 2290       int method_index = resolved_method_index(cbuf);
 2291       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2292       unsigned int ret_off = __ offset();
 2293       assert(__ offset() - start_off == 6, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2294       ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);
 2295       assert(_method, &quot;lazy_constant may be wrong when _method==null&quot;);
 2296     } else {
 2297       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2298       // Go through the vtable. Get receiver klass. Receiver already
 2299       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 2300       // interpreter expects method in Z_method.
 2301       // Use Z_method to temporarily hold the klass oop.
 2302       // Z_R1_scratch is destroyed.
 2303       __ load_klass(Z_method, Z_R2);
 2304 
 2305       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index * vtableEntry::size_in_bytes();
 2306       int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 2307 
 2308       if (Displacement::is_validDisp(v_off) ) {
 2309         // Can use load instruction with large offset.
 2310         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2311       } else {
 2312         // Worse case, must load offset into register.
 2313         __ load_const(Z_R1_scratch, v_off);
 2314         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2315       }
 2316       // NOTE: for vtable dispatches, the vtable entry will never be
 2317       // null. However it may very well end up in handle_wrong_method
 2318       // if the method is abstract for the particular class.
 2319       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2320       // Call target. Either compiled code or C2I adapter.
 2321       __ z_basr(Z_R14, Z_R1_scratch);
 2322       unsigned int ret_off = __ offset();
 2323     }
 2324   %}
 2325 
 2326   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
 2327     C2_MacroAssembler _masm(&amp;cbuf);
 2328     Register Rdst = reg_to_register_object($dst$$reg);
 2329     Register Rsrc = reg_to_register_object($src$$reg);
 2330 
 2331     // Don&#39;t emit code if operands are identical (same register).
 2332     if (Rsrc != Rdst) {
 2333       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2334 
 2335       if (VM_Version::has_LoadStoreConditional()) {
 2336         __ z_locgr(Rdst, Rsrc, cc);
 2337       } else {
 2338         // Branch if not (cmp cr).
 2339         Label done;
 2340         __ z_brc(Assembler::inverse_condition(cc), done);
 2341         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2342         __ bind(done);
 2343       }
 2344     }
 2345   %}
 2346 
 2347   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
 2348     C2_MacroAssembler _masm(&amp;cbuf);
 2349     Register Rdst = reg_to_register_object($dst$$reg);
 2350     int      Csrc = $src$$constant;
 2351     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2352     Label done;
 2353     // Branch if not (cmp cr).
 2354     __ z_brc(Assembler::inverse_condition(cc), done);
 2355     if (Csrc == 0) {
 2356       // Don&#39;t set CC.
 2357       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2358     } else {
 2359       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2360     }
 2361     __ bind(done);
 2362   %}
 2363 
 2364   enc_class z_enc_cctobool(iRegI res) %{
 2365     C2_MacroAssembler _masm(&amp;cbuf);
 2366     Register Rres = reg_to_register_object($res$$reg);
 2367 
 2368     if (VM_Version::has_LoadStoreConditional()) {
 2369       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2370       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2371       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2372     } else {
 2373       Label done;
 2374       __ load_const_optimized(Rres, 0L); // false (failed)
 2375       __ z_brne(done);                   // Assume true to be the common case.
 2376       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2377       __ bind(done);
 2378     }
 2379   %}
 2380 
 2381   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
 2382     C2_MacroAssembler _masm(&amp;cbuf);
 2383     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2384     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2385     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2386 
 2387     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2388   %}
 2389 
 2390   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
 2391     C2_MacroAssembler _masm(&amp;cbuf);
 2392     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2393     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2394     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2395 
 2396     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2397   %}
 2398 
 2399   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
 2400     C2_MacroAssembler _masm(&amp;cbuf);
 2401     Register Rdst = reg_to_register_object($dst$$reg);
 2402     Register Rtmp = reg_to_register_object($tmp$$reg);
 2403     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2404     Label    retry;
 2405 
 2406     // Iterate until swap succeeds.
 2407     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2408     __ bind(retry);
 2409       // Calculate incremented value.
 2410       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2411       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2412     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2413   %}
 2414 
 2415   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
 2416     C2_MacroAssembler _masm(&amp;cbuf);
 2417     Register Rdst = reg_to_register_object($dst$$reg);
 2418     Register Rtmp = reg_to_register_object($tmp$$reg);
 2419     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2420     Label    retry;
 2421 
 2422     // Iterate until swap succeeds.
 2423     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2424     __ bind(retry);
 2425       // Calculate incremented value.
 2426       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2427       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2428     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2429   %}
 2430 
 2431 %} // encode
 2432 
 2433 source %{
 2434 
 2435   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2436   // 32 bits after encoding.
 2437   static bool all_outs_are_Stores(const Node *n) {
 2438     for (DUIterator_Fast imax, k = n-&gt;fast_outs(imax); k &lt; imax; k++) {
 2439       Node *out = n-&gt;fast_out(k);
 2440       if (!out-&gt;is_Mach() || out-&gt;as_Mach()-&gt;ideal_Opcode() != Op_StoreN) {
 2441         // Most other outs are SpillCopy, but there are various other.
 2442         // jvm98 has arond 9% Encodes where we return false.
 2443         return false;
 2444       }
 2445     }
 2446     return true;
 2447   }
 2448 
 2449 %} // source
 2450 
 2451 
 2452 //----------FRAME--------------------------------------------------------------
 2453 // Definition of frame structure and management information.
 2454 
 2455 frame %{
 2456   // What direction does stack grow in (assumed to be same for native &amp; Java).
 2457   stack_direction(TOWARDS_LOW);
 2458 
 2459   // These two registers define part of the calling convention between
 2460   // compiled code and the interpreter.
 2461 
 2462   // Inline Cache Register
 2463   inline_cache_reg(Z_R9); // Z_inline_cache
 2464 
 2465   // Argument pointer for I2C adapters
 2466   //
 2467   // Tos is loaded in run_compiled_code to Z_ARG5=Z_R6.
 2468   // interpreter_arg_ptr_reg(Z_R6);
 2469 
 2470   // Temporary in compiled entry-points
 2471   // compiler_method_oop_reg(Z_R1);//Z_R1_scratch
 2472 
 2473   // Method Oop Register when calling interpreter
 2474   interpreter_method_oop_reg(Z_R9);//Z_method
 2475 
 2476   // Optional: name the operand used by cisc-spilling to access
 2477   // [stack_pointer + offset].
 2478   cisc_spilling_operand_name(indOffset12);
 2479 
 2480   // Number of stack slots consumed by a Monitor enter.
 2481   sync_stack_slots(frame::jit_monitor_size_in_4_byte_units);
 2482 
 2483   // Compiled code&#39;s Frame Pointer
 2484   //
 2485   // z/Architecture stack pointer
 2486   frame_pointer(Z_R15); // Z_SP
 2487 
 2488   // Interpreter stores its frame pointer in a register which is
 2489   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 2490   // interpreted java to compiled java.
 2491   //
 2492   // Z_state holds pointer to caller&#39;s cInterpreter.
 2493   interpreter_frame_pointer(Z_R7); // Z_state
 2494 
 2495   // Use alignment_in_bytes instead of log_2_of_alignment_in_bits.
 2496   stack_alignment(frame::alignment_in_bytes);
 2497 
 2498   in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);
 2499 
 2500   // A `slot&#39; is assumed 4 bytes here!
 2501   // out_preserve_stack_slots(frame::jit_out_preserve_size_in_4_byte_units);
 2502 
 2503   // Number of outgoing stack slots killed above the
 2504   // out_preserve_stack_slots for calls to C. Supports the var-args
 2505   // backing area for register parms.
 2506   varargs_C_out_slots_killed(((frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 2507 
 2508   // The after-PROLOG location of the return address. Location of
 2509   // return address specifies a type (REG or STACK) and a number
 2510   // representing the register number (i.e. - use a register name) or
 2511   // stack slot.
 2512   return_addr(REG Z_R14);
 2513 
 2514   // This is the body of the function
 2515   //
 2516   // void Matcher::calling_convention(OptoRegPair* sig /* array of ideal regs */,
 2517   //                                  uint length      /* length of array */,
 2518   //                                  bool is_outgoing)
 2519   //
 2520   // The `sig&#39; array is to be updated. Sig[j] represents the location
 2521   // of the j-th argument, either a register or a stack slot.
 2522 
 2523   // Body of function which returns an integer array locating
 2524   // arguments either in registers or in stack slots. Passed an array
 2525   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2526   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2527   // arguments for a CALLEE. Incoming stack arguments are
 2528   // automatically biased by the preserve_stack_slots field above.
 2529   calling_convention %{
 2530     // No difference between ingoing/outgoing just pass false.
 2531     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2532   %}
 2533 
 2534   // Body of function which returns an integer array locating
 2535   // arguments either in registers or in stack slots. Passed an array
 2536   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2537   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2538   // arguments for a CALLEE. Incoming stack arguments are
 2539   // automatically biased by the preserve_stack_slots field above.
 2540   c_calling_convention %{
 2541     // This is obviously always outgoing.
 2542     // C argument must be in register AND stack slot.
 2543     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2544   %}
 2545 
 2546   // Location of native (C/C++) and interpreter return values. This
 2547   // is specified to be the same as Java. In the 32-bit VM, long
 2548   // values are actually returned from native calls in O0:O1 and
 2549   // returned to the interpreter in I0:I1. The copying to and from
 2550   // the register pairs is done by the appropriate call and epilog
 2551   // opcodes. This simplifies the register allocator.
 2552   //
 2553   // Use register pair for c return value.
 2554   c_return_value %{
 2555     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2556     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2557     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2558     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2559   %}
 2560 
 2561   // Use register pair for return value.
 2562   // Location of compiled Java return values. Same as C
 2563   return_value %{
 2564     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2565     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2566     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2567     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2568   %}
 2569 %}
 2570 
 2571 
 2572 //----------ATTRIBUTES---------------------------------------------------------
 2573 
 2574 //----------Operand Attributes-------------------------------------------------
 2575 op_attrib op_cost(1);          // Required cost attribute
 2576 
 2577 //----------Instruction Attributes---------------------------------------------
 2578 
 2579 // Cost attribute. required.
 2580 ins_attrib ins_cost(DEFAULT_COST);
 2581 
 2582 // Is this instruction a non-matching short branch variant of some
 2583 // long branch? Not required.
 2584 ins_attrib ins_short_branch(0);
 2585 
 2586 // Indicates this is a trap based check node and final control-flow fixup
 2587 // must generate a proper fall through.
 2588 ins_attrib ins_is_TrapBasedCheckNode(true);
 2589 
 2590 // Attribute of instruction to tell how many constants the instruction will generate.
 2591 // (optional attribute). Default: 0.
 2592 ins_attrib ins_num_consts(0);
 2593 
 2594 // Required alignment attribute (must be a power of 2)
 2595 // specifies the alignment that some part of the instruction (not
 2596 // necessarily the start) requires. If &gt; 1, a compute_padding()
 2597 // function must be provided for the instruction.
 2598 //
 2599 // WARNING: Don&#39;t use size(FIXED_SIZE) or size(VARIABLE_SIZE) in
 2600 // instructions which depend on the proper alignment, because the
 2601 // desired alignment isn&#39;t guaranteed for the call to &quot;emit()&quot; during
 2602 // the size computation.
 2603 ins_attrib ins_alignment(1);
 2604 
 2605 // Enforce/prohibit rematerializations.
 2606 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 2607 //   then rematerialization of that instruction is prohibited and the
 2608 //   instruction&#39;s value will be spilled if necessary.
 2609 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 2610 //   then rematerialization is enforced and the instruction&#39;s value will
 2611 //   never get spilled. a copy of the instruction will be inserted if
 2612 //   necessary.
 2613 //   Note: this may result in rematerializations in front of every use.
 2614 // (optional attribute)
 2615 ins_attrib ins_cannot_rematerialize(false);
 2616 ins_attrib ins_should_rematerialize(false);
 2617 
 2618 //----------OPERANDS-----------------------------------------------------------
 2619 // Operand definitions must precede instruction definitions for correct
 2620 // parsing in the ADLC because operands constitute user defined types
 2621 // which are used in instruction definitions.
 2622 
 2623 //----------Simple Operands----------------------------------------------------
 2624 // Immediate Operands
 2625 // Please note:
 2626 // Formats are generated automatically for constants and base registers.
 2627 
 2628 //----------------------------------------------
 2629 // SIGNED (shorter than INT) immediate operands
 2630 //----------------------------------------------
 2631 
 2632 // Byte Immediate: constant &#39;int -1&#39;
 2633 operand immB_minus1() %{
 2634   //         sign-ext constant      zero-ext constant
 2635   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x000000ff) == 0x000000ff));
 2636   match(ConI);
 2637   op_cost(1);
 2638   format %{ %}
 2639   interface(CONST_INTER);
 2640 %}
 2641 
 2642 // Byte Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2643 operand immB_n0m1() %{
 2644   //                             sign-ext constant     zero-ext constant
 2645   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x000000ff) != 0x000000ff);
 2646   match(ConI);
 2647   op_cost(1);
 2648   format %{ %}
 2649   interface(CONST_INTER);
 2650 %}
 2651 
 2652 // Short Immediate: constant &#39;int -1&#39;
 2653 operand immS_minus1() %{
 2654   //         sign-ext constant      zero-ext constant
 2655   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x0000ffff) == 0x0000ffff));
 2656   match(ConI);
 2657   op_cost(1);
 2658   format %{ %}
 2659   interface(CONST_INTER);
 2660 %}
 2661 
 2662 // Short Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2663 operand immS_n0m1() %{
 2664   //                             sign-ext constant     zero-ext constant
 2665   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x0000ffff) != 0x0000ffff);
 2666   match(ConI);
 2667   op_cost(1);
 2668   format %{ %}
 2669   interface(CONST_INTER);
 2670 %}
 2671 
 2672 //-----------------------------------------
 2673 //  SIGNED INT immediate operands
 2674 //-----------------------------------------
 2675 
 2676 // Integer Immediate: 32-bit
 2677 operand immI() %{
 2678   match(ConI);
 2679   op_cost(1);
 2680   format %{ %}
 2681   interface(CONST_INTER);
 2682 %}
 2683 
 2684 // Int Immediate: 20-bit
 2685 operand immI20() %{
 2686   predicate(Immediate::is_simm20(n-&gt;get_int()));
 2687   match(ConI);
 2688   op_cost(1);
 2689   format %{ %}
 2690   interface(CONST_INTER);
 2691 %}
 2692 
 2693 // Integer Immediate: 16-bit
 2694 operand immI16() %{
 2695   predicate(Immediate::is_simm16(n-&gt;get_int()));
 2696   match(ConI);
 2697   op_cost(1);
 2698   format %{ %}
 2699   interface(CONST_INTER);
 2700 %}
 2701 
 2702 // Integer Immediate: 8-bit
 2703 operand immI8() %{
 2704   predicate(Immediate::is_simm8(n-&gt;get_int()));
 2705   match(ConI);
 2706   op_cost(1);
 2707   format %{ %}
 2708   interface(CONST_INTER);
 2709 %}
 2710 
 2711 // Integer Immediate: constant &#39;int 0&#39;
 2712 operand immI_0() %{
 2713   predicate(n-&gt;get_int() == 0);
 2714   match(ConI);
 2715   op_cost(1);
 2716   format %{ %}
 2717   interface(CONST_INTER);
 2718 %}
 2719 
 2720 // Integer Immediate: constant &#39;int -1&#39;
 2721 operand immI_minus1() %{
 2722   predicate(n-&gt;get_int() == -1);
 2723   match(ConI);
 2724   op_cost(1);
 2725   format %{ %}
 2726   interface(CONST_INTER);
 2727 %}
 2728 
 2729 // Integer Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2730 operand immI_n0m1() %{
 2731   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1);
 2732   match(ConI);
 2733   op_cost(1);
 2734   format %{ %}
 2735   interface(CONST_INTER);
 2736 %}
 2737 
 2738 //-------------------------------------------
 2739 // UNSIGNED INT immediate operands
 2740 //-------------------------------------------
 2741 
 2742 // Unsigned Integer Immediate: 32-bit
 2743 operand uimmI() %{
 2744   match(ConI);
 2745   op_cost(1);
 2746   format %{ %}
 2747   interface(CONST_INTER);
 2748 %}
 2749 
 2750 // Unsigned Integer Immediate: 16-bit
 2751 operand uimmI16() %{
 2752   predicate(Immediate::is_uimm16(n-&gt;get_int()));
 2753   match(ConI);
 2754   op_cost(1);
 2755   format %{ %}
 2756   interface(CONST_INTER);
 2757 %}
 2758 
 2759 // Unsigned Integer Immediate: 12-bit
 2760 operand uimmI12() %{
 2761   predicate(Immediate::is_uimm12(n-&gt;get_int()));
 2762   match(ConI);
 2763   op_cost(1);
 2764   format %{ %}
 2765   interface(CONST_INTER);
 2766 %}
 2767 
 2768 // Unsigned Integer Immediate: 12-bit
 2769 operand uimmI8() %{
 2770   predicate(Immediate::is_uimm8(n-&gt;get_int()));
 2771   match(ConI);
 2772   op_cost(1);
 2773   format %{ %}
 2774   interface(CONST_INTER);
 2775 %}
 2776 
 2777 // Integer Immediate: 6-bit
 2778 operand uimmI6() %{
 2779   predicate(Immediate::is_uimm(n-&gt;get_int(), 6));
 2780   match(ConI);
 2781   op_cost(1);
 2782   format %{ %}
 2783   interface(CONST_INTER);
 2784 %}
 2785 
 2786 // Integer Immediate: 5-bit
 2787 operand uimmI5() %{
 2788   predicate(Immediate::is_uimm(n-&gt;get_int(), 5));
 2789   match(ConI);
 2790   op_cost(1);
 2791   format %{ %}
 2792   interface(CONST_INTER);
 2793 %}
 2794 
 2795 // Length for SS instructions, given in DWs,
 2796 //   possible range [1..512], i.e. [8..4096] Bytes
 2797 //   used     range [1..256], i.e. [8..2048] Bytes
 2798 //   operand type int
 2799 // Unsigned Integer Immediate: 9-bit
 2800 operand SSlenDW() %{
 2801   predicate(Immediate::is_uimm8(n-&gt;get_long()-1));
 2802   match(ConL);
 2803   op_cost(1);
 2804   format %{ %}
 2805   interface(CONST_INTER);
 2806 %}
 2807 
 2808 //------------------------------------------
 2809 // (UN)SIGNED INT specific values
 2810 //------------------------------------------
 2811 
 2812 // Integer Immediate: the value 1
 2813 operand immI_1() %{
 2814   predicate(n-&gt;get_int() == 1);
 2815   match(ConI);
 2816   op_cost(1);
 2817   format %{ %}
 2818   interface(CONST_INTER);
 2819 %}
 2820 
 2821 // Integer Immediate: the value 16.
 2822 operand immI_16() %{
 2823   predicate(n-&gt;get_int() == 16);
 2824   match(ConI);
 2825   op_cost(1);
 2826   format %{ %}
 2827   interface(CONST_INTER);
 2828 %}
 2829 
 2830 // Integer Immediate: the value 24.
 2831 operand immI_24() %{
 2832   predicate(n-&gt;get_int() == 24);
 2833   match(ConI);
 2834   op_cost(1);
 2835   format %{ %}
 2836   interface(CONST_INTER);
 2837 %}
 2838 
 2839 // Integer Immediate: the value 255
 2840 operand immI_255() %{
 2841   predicate(n-&gt;get_int() == 255);
 2842   match(ConI);
 2843   op_cost(1);
 2844   format %{ %}
 2845   interface(CONST_INTER);
 2846 %}
 2847 
 2848 // Integer Immediate: the values 32-63
 2849 operand immI_32_63() %{
 2850   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 2851   match(ConI);
 2852   op_cost(1);
 2853   format %{ %}
 2854   interface(CONST_INTER);
 2855 %}
 2856 
 2857 // Unsigned Integer Immediate: LL-part, extended by 1s.
 2858 operand uimmI_LL1() %{
 2859   predicate((n-&gt;get_int() &amp; 0xFFFF0000) == 0xFFFF0000);
 2860   match(ConI);
 2861   op_cost(1);
 2862   format %{ %}
 2863   interface(CONST_INTER);
 2864 %}
 2865 
 2866 // Unsigned Integer Immediate: LH-part, extended by 1s.
 2867 operand uimmI_LH1() %{
 2868   predicate((n-&gt;get_int() &amp; 0xFFFF) == 0xFFFF);
 2869   match(ConI);
 2870   op_cost(1);
 2871   format %{ %}
 2872   interface(CONST_INTER);
 2873 %}
 2874 
 2875 //------------------------------------------
 2876 // SIGNED LONG immediate operands
 2877 //------------------------------------------
 2878 
 2879 operand immL() %{
 2880   match(ConL);
 2881   op_cost(1);
 2882   format %{ %}
 2883   interface(CONST_INTER);
 2884 %}
 2885 
 2886 // Long Immediate: 32-bit
 2887 operand immL32() %{
 2888   predicate(Immediate::is_simm32(n-&gt;get_long()));
 2889   match(ConL);
 2890   op_cost(1);
 2891   format %{ %}
 2892   interface(CONST_INTER);
 2893 %}
 2894 
 2895 // Long Immediate: 20-bit
 2896 operand immL20() %{
 2897   predicate(Immediate::is_simm20(n-&gt;get_long()));
 2898   match(ConL);
 2899   op_cost(1);
 2900   format %{ %}
 2901   interface(CONST_INTER);
 2902 %}
 2903 
 2904 // Long Immediate: 16-bit
 2905 operand immL16() %{
 2906   predicate(Immediate::is_simm16(n-&gt;get_long()));
 2907   match(ConL);
 2908   op_cost(1);
 2909   format %{ %}
 2910   interface(CONST_INTER);
 2911 %}
 2912 
 2913 // Long Immediate: 8-bit
 2914 operand immL8() %{
 2915   predicate(Immediate::is_simm8(n-&gt;get_long()));
 2916   match(ConL);
 2917   op_cost(1);
 2918   format %{ %}
 2919   interface(CONST_INTER);
 2920 %}
 2921 
 2922 //--------------------------------------------
 2923 // UNSIGNED LONG immediate operands
 2924 //--------------------------------------------
 2925 
 2926 operand uimmL32() %{
 2927   predicate(Immediate::is_uimm32(n-&gt;get_long()));
 2928   match(ConL);
 2929   op_cost(1);
 2930   format %{ %}
 2931   interface(CONST_INTER);
 2932 %}
 2933 
 2934 // Unsigned Long Immediate: 16-bit
 2935 operand uimmL16() %{
 2936   predicate(Immediate::is_uimm16(n-&gt;get_long()));
 2937   match(ConL);
 2938   op_cost(1);
 2939   format %{ %}
 2940   interface(CONST_INTER);
 2941 %}
 2942 
 2943 // Unsigned Long Immediate: 12-bit
 2944 operand uimmL12() %{
 2945   predicate(Immediate::is_uimm12(n-&gt;get_long()));
 2946   match(ConL);
 2947   op_cost(1);
 2948   format %{ %}
 2949   interface(CONST_INTER);
 2950 %}
 2951 
 2952 // Unsigned Long Immediate: 8-bit
 2953 operand uimmL8() %{
 2954   predicate(Immediate::is_uimm8(n-&gt;get_long()));
 2955   match(ConL);
 2956   op_cost(1);
 2957   format %{ %}
 2958   interface(CONST_INTER);
 2959 %}
 2960 
 2961 //-------------------------------------------
 2962 // (UN)SIGNED LONG specific values
 2963 //-------------------------------------------
 2964 
 2965 // Long Immediate: the value FF
 2966 operand immL_FF() %{
 2967   predicate(n-&gt;get_long() == 0xFFL);
 2968   match(ConL);
 2969   op_cost(1);
 2970   format %{ %}
 2971   interface(CONST_INTER);
 2972 %}
 2973 
 2974 // Long Immediate: the value FFFF
 2975 operand immL_FFFF() %{
 2976   predicate(n-&gt;get_long() == 0xFFFFL);
 2977   match(ConL);
 2978   op_cost(1);
 2979   format %{ %}
 2980   interface(CONST_INTER);
 2981 %}
 2982 
 2983 // Long Immediate: the value FFFFFFFF
 2984 operand immL_FFFFFFFF() %{
 2985   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2986   match(ConL);
 2987   op_cost(1);
 2988   format %{ %}
 2989   interface(CONST_INTER);
 2990 %}
 2991 
 2992 operand immL_0() %{
 2993   predicate(n-&gt;get_long() == 0L);
 2994   match(ConL);
 2995   op_cost(1);
 2996   format %{ %}
 2997   interface(CONST_INTER);
 2998 %}
 2999 
 3000 // Unsigned Long Immediate: LL-part, extended by 1s.
 3001 operand uimmL_LL1() %{
 3002   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFF0000L) == 0xFFFFFFFFFFFF0000L);
 3003   match(ConL);
 3004   op_cost(1);
 3005   format %{ %}
 3006   interface(CONST_INTER);
 3007 %}
 3008 
 3009 // Unsigned Long Immediate: LH-part, extended by 1s.
 3010 operand uimmL_LH1() %{
 3011   predicate((n-&gt;get_long() &amp; 0xFFFFFFFF0000FFFFL) == 0xFFFFFFFF0000FFFFL);
 3012   match(ConL);
 3013   op_cost(1);
 3014   format %{ %}
 3015   interface(CONST_INTER);
 3016 %}
 3017 
 3018 // Unsigned Long Immediate: HL-part, extended by 1s.
 3019 operand uimmL_HL1() %{
 3020   predicate((n-&gt;get_long() &amp; 0xFFFF0000FFFFFFFFL) == 0xFFFF0000FFFFFFFFL);
 3021   match(ConL);
 3022   op_cost(1);
 3023   format %{ %}
 3024   interface(CONST_INTER);
 3025 %}
 3026 
 3027 // Unsigned Long Immediate: HH-part, extended by 1s.
 3028 operand uimmL_HH1() %{
 3029   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFFL) == 0xFFFFFFFFFFFFL);
 3030   match(ConL);
 3031   op_cost(1);
 3032   format %{ %}
 3033   interface(CONST_INTER);
 3034 %}
 3035 
 3036 // Long Immediate: low 32-bit mask
 3037 operand immL_32bits() %{
 3038   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3039   match(ConL);
 3040   op_cost(1);
 3041   format %{ %}
 3042   interface(CONST_INTER);
 3043 %}
 3044 
 3045 //--------------------------------------
 3046 //  POINTER immediate operands
 3047 //--------------------------------------
 3048 
 3049 // Pointer Immediate: 64-bit
 3050 operand immP() %{
 3051   match(ConP);
 3052   op_cost(1);
 3053   format %{ %}
 3054   interface(CONST_INTER);
 3055 %}
 3056 
 3057 // Pointer Immediate: 32-bit
 3058 operand immP32() %{
 3059   predicate(Immediate::is_uimm32(n-&gt;get_ptr()));
 3060   match(ConP);
 3061   op_cost(1);
 3062   format %{ %}
 3063   interface(CONST_INTER);
 3064 %}
 3065 
 3066 // Pointer Immediate: 16-bit
 3067 operand immP16() %{
 3068   predicate(Immediate::is_uimm16(n-&gt;get_ptr()));
 3069   match(ConP);
 3070   op_cost(1);
 3071   format %{ %}
 3072   interface(CONST_INTER);
 3073 %}
 3074 
 3075 // Pointer Immediate: 8-bit
 3076 operand immP8() %{
 3077   predicate(Immediate::is_uimm8(n-&gt;get_ptr()));
 3078   match(ConP);
 3079   op_cost(1);
 3080   format %{ %}
 3081   interface(CONST_INTER);
 3082 %}
 3083 
 3084 //-----------------------------------
 3085 // POINTER specific values
 3086 //-----------------------------------
 3087 
 3088 // Pointer Immediate: NULL
 3089 operand immP0() %{
 3090   predicate(n-&gt;get_ptr() == 0);
 3091   match(ConP);
 3092   op_cost(1);
 3093   format %{ %}
 3094   interface(CONST_INTER);
 3095 %}
 3096 
 3097 //---------------------------------------------
 3098 // NARROW POINTER immediate operands
 3099 //---------------------------------------------
 3100 
 3101 // Narrow Pointer Immediate
 3102 operand immN() %{
 3103   match(ConN);
 3104   op_cost(1);
 3105   format %{ %}
 3106   interface(CONST_INTER);
 3107 %}
 3108 
 3109 operand immNKlass() %{
 3110   match(ConNKlass);
 3111   op_cost(1);
 3112   format %{ %}
 3113   interface(CONST_INTER);
 3114 %}
 3115 
 3116 // Narrow Pointer Immediate
 3117 operand immN8() %{
 3118   predicate(Immediate::is_uimm8(n-&gt;get_narrowcon()));
 3119   match(ConN);
 3120   op_cost(1);
 3121   format %{ %}
 3122   interface(CONST_INTER);
 3123 %}
 3124 
 3125 // Narrow NULL Pointer Immediate
 3126 operand immN0() %{
 3127   predicate(n-&gt;get_narrowcon() == 0);
 3128   match(ConN);
 3129   op_cost(1);
 3130   format %{ %}
 3131   interface(CONST_INTER);
 3132 %}
 3133 
 3134 // FLOAT and DOUBLE immediate operands
 3135 
 3136 // Double Immediate
 3137 operand immD() %{
 3138   match(ConD);
 3139   op_cost(1);
 3140   format %{ %}
 3141   interface(CONST_INTER);
 3142 %}
 3143 
 3144 // Double Immediate: +-0
 3145 operand immDpm0() %{
 3146   predicate(n-&gt;getd() == 0);
 3147   match(ConD);
 3148   op_cost(1);
 3149   format %{ %}
 3150   interface(CONST_INTER);
 3151 %}
 3152 
 3153 // Double Immediate: +0
 3154 operand immDp0() %{
 3155   predicate(jlong_cast(n-&gt;getd()) == 0);
 3156   match(ConD);
 3157   op_cost(1);
 3158   format %{ %}
 3159   interface(CONST_INTER);
 3160 %}
 3161 
 3162 // Float Immediate
 3163 operand immF() %{
 3164   match(ConF);
 3165   op_cost(1);
 3166   format %{ %}
 3167   interface(CONST_INTER);
 3168 %}
 3169 
 3170 // Float Immediate: +-0
 3171 operand immFpm0() %{
 3172   predicate(n-&gt;getf() == 0);
 3173   match(ConF);
 3174   op_cost(1);
 3175   format %{ %}
 3176   interface(CONST_INTER);
 3177 %}
 3178 
 3179 // Float Immediate: +0
 3180 operand immFp0() %{
 3181   predicate(jint_cast(n-&gt;getf()) == 0);
 3182   match(ConF);
 3183   op_cost(1);
 3184   format %{ %}
 3185   interface(CONST_INTER);
 3186 %}
 3187 
 3188 // End of Immediate Operands
 3189 
 3190 // Integer Register Operands
 3191 // Integer Register
 3192 operand iRegI() %{
 3193   constraint(ALLOC_IN_RC(z_int_reg));
 3194   match(RegI);
 3195   match(noArg_iRegI);
 3196   match(rarg1RegI);
 3197   match(rarg2RegI);
 3198   match(rarg3RegI);
 3199   match(rarg4RegI);
 3200   match(rarg5RegI);
 3201   match(noOdd_iRegI);
 3202   match(revenRegI);
 3203   match(roddRegI);
 3204   format %{ %}
 3205   interface(REG_INTER);
 3206 %}
 3207 
 3208 operand noArg_iRegI() %{
 3209   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3210   match(RegI);
 3211   format %{ %}
 3212   interface(REG_INTER);
 3213 %}
 3214 
 3215 // revenRegI and roddRegI constitute and even-odd-pair.
 3216 operand revenRegI() %{
 3217   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3218   match(iRegI);
 3219   format %{ %}
 3220   interface(REG_INTER);
 3221 %}
 3222 
 3223 // revenRegI and roddRegI constitute and even-odd-pair.
 3224 operand roddRegI() %{
 3225   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3226   match(iRegI);
 3227   format %{ %}
 3228   interface(REG_INTER);
 3229 %}
 3230 
 3231 operand rarg1RegI() %{
 3232   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3233   match(iRegI);
 3234   format %{ %}
 3235   interface(REG_INTER);
 3236 %}
 3237 
 3238 operand rarg2RegI() %{
 3239   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3240   match(iRegI);
 3241   format %{ %}
 3242   interface(REG_INTER);
 3243 %}
 3244 
 3245 operand rarg3RegI() %{
 3246   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3247   match(iRegI);
 3248   format %{ %}
 3249   interface(REG_INTER);
 3250 %}
 3251 
 3252 operand rarg4RegI() %{
 3253   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3254   match(iRegI);
 3255   format %{ %}
 3256   interface(REG_INTER);
 3257 %}
 3258 
 3259 operand rarg5RegI() %{
 3260   constraint(ALLOC_IN_RC(z_rarg5_int_reg));
 3261   match(iRegI);
 3262   format %{ %}
 3263   interface(REG_INTER);
 3264 %}
 3265 
 3266 operand noOdd_iRegI() %{
 3267   constraint(ALLOC_IN_RC(z_no_odd_int_reg));
 3268   match(RegI);
 3269   match(revenRegI);
 3270   format %{ %}
 3271   interface(REG_INTER);
 3272 %}
 3273 
 3274 // Pointer Register
 3275 operand iRegP() %{
 3276   constraint(ALLOC_IN_RC(z_ptr_reg));
 3277   match(RegP);
 3278   match(noArg_iRegP);
 3279   match(rarg1RegP);
 3280   match(rarg2RegP);
 3281   match(rarg3RegP);
 3282   match(rarg4RegP);
 3283   match(rarg5RegP);
 3284   match(revenRegP);
 3285   match(roddRegP);
 3286   format %{ %}
 3287   interface(REG_INTER);
 3288 %}
 3289 
 3290 // thread operand
 3291 operand threadRegP() %{
 3292   constraint(ALLOC_IN_RC(z_thread_ptr_reg));
 3293   match(RegP);
 3294   format %{ &quot;Z_THREAD&quot; %}
 3295   interface(REG_INTER);
 3296 %}
 3297 
 3298 operand noArg_iRegP() %{
 3299   constraint(ALLOC_IN_RC(z_no_arg_ptr_reg));
 3300   match(iRegP);
 3301   format %{ %}
 3302   interface(REG_INTER);
 3303 %}
 3304 
 3305 operand rarg1RegP() %{
 3306   constraint(ALLOC_IN_RC(z_rarg1_ptr_reg));
 3307   match(iRegP);
 3308   format %{ %}
 3309   interface(REG_INTER);
 3310 %}
 3311 
 3312 operand rarg2RegP() %{
 3313   constraint(ALLOC_IN_RC(z_rarg2_ptr_reg));
 3314   match(iRegP);
 3315   format %{ %}
 3316   interface(REG_INTER);
 3317 %}
 3318 
 3319 operand rarg3RegP() %{
 3320   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3321   match(iRegP);
 3322   format %{ %}
 3323   interface(REG_INTER);
 3324 %}
 3325 
 3326 operand rarg4RegP() %{
 3327   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3328   match(iRegP);
 3329   format %{ %}
 3330   interface(REG_INTER);
 3331 %}
 3332 
 3333 operand rarg5RegP() %{
 3334   constraint(ALLOC_IN_RC(z_rarg5_ptr_reg));
 3335   match(iRegP);
 3336   format %{ %}
 3337   interface(REG_INTER);
 3338 %}
 3339 
 3340 operand memoryRegP() %{
 3341   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3342   match(RegP);
 3343   match(iRegP);
 3344   match(threadRegP);
 3345   format %{ %}
 3346   interface(REG_INTER);
 3347 %}
 3348 
 3349 // revenRegP and roddRegP constitute and even-odd-pair.
 3350 operand revenRegP() %{
 3351   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3352   match(iRegP);
 3353   format %{ %}
 3354   interface(REG_INTER);
 3355 %}
 3356 
 3357 // revenRegP and roddRegP constitute and even-odd-pair.
 3358 operand roddRegP() %{
 3359   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3360   match(iRegP);
 3361   format %{ %}
 3362   interface(REG_INTER);
 3363 %}
 3364 
 3365 operand lock_ptr_RegP() %{
 3366   constraint(ALLOC_IN_RC(z_lock_ptr_reg));
 3367   match(RegP);
 3368   format %{ %}
 3369   interface(REG_INTER);
 3370 %}
 3371 
 3372 operand rscratch2RegP() %{
 3373   constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));
 3374   match(RegP);
 3375   format %{ %}
 3376   interface(REG_INTER);
 3377 %}
 3378 
 3379 operand iRegN() %{
 3380   constraint(ALLOC_IN_RC(z_int_reg));
 3381   match(RegN);
 3382   match(noArg_iRegN);
 3383   match(rarg1RegN);
 3384   match(rarg2RegN);
 3385   match(rarg3RegN);
 3386   match(rarg4RegN);
 3387   match(rarg5RegN);
 3388   format %{ %}
 3389   interface(REG_INTER);
 3390 %}
 3391 
 3392 operand noArg_iRegN() %{
 3393   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3394   match(iRegN);
 3395   format %{ %}
 3396   interface(REG_INTER);
 3397 %}
 3398 
 3399 operand rarg1RegN() %{
 3400   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3401   match(iRegN);
 3402   format %{ %}
 3403   interface(REG_INTER);
 3404 %}
 3405 
 3406 operand rarg2RegN() %{
 3407   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3408   match(iRegN);
 3409   format %{ %}
 3410   interface(REG_INTER);
 3411 %}
 3412 
 3413 operand rarg3RegN() %{
 3414   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3415   match(iRegN);
 3416   format %{ %}
 3417   interface(REG_INTER);
 3418 %}
 3419 
 3420 operand rarg4RegN() %{
 3421   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3422   match(iRegN);
 3423   format %{ %}
 3424   interface(REG_INTER);
 3425 %}
 3426 
 3427 operand rarg5RegN() %{
 3428   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3429   match(iRegN);
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 // Long Register
 3435 operand iRegL() %{
 3436   constraint(ALLOC_IN_RC(z_long_reg));
 3437   match(RegL);
 3438   match(revenRegL);
 3439   match(roddRegL);
 3440   match(allRoddRegL);
 3441   match(rarg1RegL);
 3442   match(rarg5RegL);
 3443   format %{ %}
 3444   interface(REG_INTER);
 3445 %}
 3446 
 3447 // revenRegL and roddRegL constitute and even-odd-pair.
 3448 operand revenRegL() %{
 3449   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3450   match(iRegL);
 3451   format %{ %}
 3452   interface(REG_INTER);
 3453 %}
 3454 
 3455 // revenRegL and roddRegL constitute and even-odd-pair.
 3456 operand roddRegL() %{
 3457   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3458   match(iRegL);
 3459   format %{ %}
 3460   interface(REG_INTER);
 3461 %}
 3462 
 3463 // available odd registers for iRegL
 3464 operand allRoddRegL() %{
 3465   constraint(ALLOC_IN_RC(z_long_odd_reg));
 3466   match(iRegL);
 3467   format %{ %}
 3468   interface(REG_INTER);
 3469 %}
 3470 
 3471 operand rarg1RegL() %{
 3472   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3473   match(iRegL);
 3474   format %{ %}
 3475   interface(REG_INTER);
 3476 %}
 3477 
 3478 operand rarg5RegL() %{
 3479   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3480   match(iRegL);
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 // Condition Code Flag Registers
 3486 operand flagsReg() %{
 3487   constraint(ALLOC_IN_RC(z_condition_reg));
 3488   match(RegFlags);
 3489   format %{ &quot;CR&quot; %}
 3490   interface(REG_INTER);
 3491 %}
 3492 
 3493 // Condition Code Flag Registers for rules with result tuples
 3494 operand TD_flagsReg() %{
 3495   constraint(ALLOC_IN_RC(z_condition_reg));
 3496   match(RegFlags);
 3497   format %{ &quot;CR&quot; %}
 3498   interface(REG_TUPLE_DEST_INTER);
 3499 %}
 3500 
 3501 operand regD() %{
 3502   constraint(ALLOC_IN_RC(z_dbl_reg));
 3503   match(RegD);
 3504   format %{ %}
 3505   interface(REG_INTER);
 3506 %}
 3507 
 3508 operand rscratchRegD() %{
 3509   constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));
 3510   match(RegD);
 3511   format %{ %}
 3512   interface(REG_INTER);
 3513 %}
 3514 
 3515 operand regF() %{
 3516   constraint(ALLOC_IN_RC(z_flt_reg));
 3517   match(RegF);
 3518   format %{ %}
 3519   interface(REG_INTER);
 3520 %}
 3521 
 3522 operand rscratchRegF() %{
 3523   constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));
 3524   match(RegF);
 3525   format %{ %}
 3526   interface(REG_INTER);
 3527 %}
 3528 
 3529 // Special Registers
 3530 
 3531 // Method Register
 3532 operand inline_cache_regP(iRegP reg) %{
 3533   constraint(ALLOC_IN_RC(z_r9_regP)); // inline_cache_reg
 3534   match(reg);
 3535   format %{ %}
 3536   interface(REG_INTER);
 3537 %}
 3538 
 3539 operand compiler_method_oop_regP(iRegP reg) %{
 3540   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3541   match(reg);
 3542   format %{ %}
 3543   interface(REG_INTER);
 3544 %}
 3545 
 3546 operand interpreter_method_oop_regP(iRegP reg) %{
 3547   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3548   match(reg);
 3549   format %{ %}
 3550   interface(REG_INTER);
 3551 %}
 3552 
 3553 // Operands to remove register moves in unscaled mode.
 3554 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3555 operand iRegP2N(iRegP reg) %{
 3556   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);
 3557   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3558   match(EncodeP reg);
 3559   format %{ &quot;$reg&quot; %}
 3560   interface(REG_INTER)
 3561 %}
 3562 
 3563 operand iRegN2P(iRegN reg) %{
 3564   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;
 3565             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3566   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3567   match(DecodeN reg);
 3568   format %{ &quot;$reg&quot; %}
 3569   interface(REG_INTER)
 3570 %}
 3571 
 3572 
 3573 //----------Complex Operands---------------------------------------------------
 3574 
 3575 // Indirect Memory Reference
 3576 operand indirect(memoryRegP base) %{
 3577   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3578   match(base);
 3579   op_cost(1);
 3580   format %{ &quot;#0[,$base]&quot; %}
 3581   interface(MEMORY_INTER) %{
 3582     base($base);
 3583     index(0xffffFFFF); // noreg
 3584     scale(0x0);
 3585     disp(0x0);
 3586   %}
 3587 %}
 3588 
 3589 // Indirect with Offset (long)
 3590 operand indOffset20(memoryRegP base, immL20 offset) %{
 3591   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3592   match(AddP base offset);
 3593   op_cost(1);
 3594   format %{ &quot;$offset[,$base]&quot; %}
 3595   interface(MEMORY_INTER) %{
 3596     base($base);
 3597     index(0xffffFFFF); // noreg
 3598     scale(0x0);
 3599     disp($offset);
 3600   %}
 3601 %}
 3602 
 3603 operand indOffset20Narrow(iRegN base, immL20 offset) %{
 3604   predicate(Matcher::narrow_oop_use_complex_address());
 3605   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3606   match(AddP (DecodeN base) offset);
 3607   op_cost(1);
 3608   format %{ &quot;$offset[,$base]&quot; %}
 3609   interface(MEMORY_INTER) %{
 3610     base($base);
 3611     index(0xffffFFFF); // noreg
 3612     scale(0x0);
 3613     disp($offset);
 3614   %}
 3615 %}
 3616 
 3617 // Indirect with Offset (short)
 3618 operand indOffset12(memoryRegP base, uimmL12 offset) %{
 3619   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3620   match(AddP base offset);
 3621   op_cost(1);
 3622   format %{ &quot;$offset[[,$base]]&quot; %}
 3623   interface(MEMORY_INTER) %{
 3624     base($base);
 3625     index(0xffffFFFF); // noreg
 3626     scale(0x0);
 3627     disp($offset);
 3628   %}
 3629 %}
 3630 
 3631 operand indOffset12Narrow(iRegN base, uimmL12 offset) %{
 3632   predicate(Matcher::narrow_oop_use_complex_address());
 3633   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3634   match(AddP (DecodeN base) offset);
 3635   op_cost(1);
 3636   format %{ &quot;$offset[[,$base]]&quot; %}
 3637   interface(MEMORY_INTER) %{
 3638     base($base);
 3639     index(0xffffFFFF); // noreg
 3640     scale(0x0);
 3641     disp($offset);
 3642   %}
 3643 %}
 3644 
 3645 // Indirect with Register Index
 3646 operand indIndex(memoryRegP base, iRegL index) %{
 3647   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3648   match(AddP base index);
 3649   op_cost(1);
 3650   format %{ &quot;#0[($index,$base)]&quot; %}
 3651   interface(MEMORY_INTER) %{
 3652     base($base);
 3653     index($index);
 3654     scale(0x0);
 3655     disp(0x0);
 3656   %}
 3657 %}
 3658 
 3659 // Indirect with Offset (long) and index
 3660 operand indOffset20index(memoryRegP base, immL20 offset, iRegL index) %{
 3661   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3662   match(AddP (AddP base index) offset);
 3663   op_cost(1);
 3664   format %{ &quot;$offset[($index,$base)]&quot; %}
 3665   interface(MEMORY_INTER) %{
 3666     base($base);
 3667     index($index);
 3668     scale(0x0);
 3669     disp($offset);
 3670   %}
 3671 %}
 3672 
 3673 operand indOffset20indexNarrow(iRegN base, immL20 offset, iRegL index) %{
 3674   predicate(Matcher::narrow_oop_use_complex_address());
 3675   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3676   match(AddP (AddP (DecodeN base) index) offset);
 3677   op_cost(1);
 3678   format %{ &quot;$offset[($index,$base)]&quot; %}
 3679   interface(MEMORY_INTER) %{
 3680     base($base);
 3681     index($index);
 3682     scale(0x0);
 3683     disp($offset);
 3684   %}
 3685 %}
 3686 
 3687 // Indirect with Offset (short) and index
 3688 operand indOffset12index(memoryRegP base, uimmL12 offset, iRegL index) %{
 3689   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3690   match(AddP (AddP base index) offset);
 3691   op_cost(1);
 3692   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3693   interface(MEMORY_INTER) %{
 3694     base($base);
 3695     index($index);
 3696     scale(0x0);
 3697     disp($offset);
 3698   %}
 3699 %}
 3700 
 3701 operand indOffset12indexNarrow(iRegN base, uimmL12 offset, iRegL index) %{
 3702   predicate(Matcher::narrow_oop_use_complex_address());
 3703   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3704   match(AddP (AddP (DecodeN base) index) offset);
 3705   op_cost(1);
 3706   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3707   interface(MEMORY_INTER) %{
 3708     base($base);
 3709     index($index);
 3710     scale(0x0);
 3711     disp($offset);
 3712   %}
 3713 %}
 3714 
 3715 //----------Special Memory Operands--------------------------------------------
 3716 
 3717 // Stack Slot Operand
 3718 // This operand is used for loading and storing temporary values on
 3719 // the stack where a match requires a value to flow through memory.
 3720 operand stackSlotI(sRegI reg) %{
 3721   constraint(ALLOC_IN_RC(stack_slots));
 3722   op_cost(1);
 3723   format %{ &quot;[$reg(stackSlotI)]&quot; %}
 3724   interface(MEMORY_INTER) %{
 3725     base(0xf);   // Z_SP
 3726     index(0xffffFFFF); // noreg
 3727     scale(0x0);
 3728     disp($reg);  // stack offset
 3729   %}
 3730 %}
 3731 
 3732 operand stackSlotP(sRegP reg) %{
 3733   constraint(ALLOC_IN_RC(stack_slots));
 3734   op_cost(1);
 3735   format %{ &quot;[$reg(stackSlotP)]&quot; %}
 3736   interface(MEMORY_INTER) %{
 3737     base(0xf);   // Z_SP
 3738     index(0xffffFFFF); // noreg
 3739     scale(0x0);
 3740     disp($reg);  // Stack Offset
 3741   %}
 3742 %}
 3743 
 3744 operand stackSlotF(sRegF reg) %{
 3745   constraint(ALLOC_IN_RC(stack_slots));
 3746   op_cost(1);
 3747   format %{ &quot;[$reg(stackSlotF)]&quot; %}
 3748   interface(MEMORY_INTER) %{
 3749     base(0xf);   // Z_SP
 3750     index(0xffffFFFF); // noreg
 3751     scale(0x0);
 3752     disp($reg);  // Stack Offset
 3753   %}
 3754 %}
 3755 
 3756 operand stackSlotD(sRegD reg) %{
 3757   constraint(ALLOC_IN_RC(stack_slots));
 3758   op_cost(1);
 3759   //match(RegD);
 3760   format %{ &quot;[$reg(stackSlotD)]&quot; %}
 3761   interface(MEMORY_INTER) %{
 3762     base(0xf);   // Z_SP
 3763     index(0xffffFFFF); // noreg
 3764     scale(0x0);
 3765     disp($reg);  // Stack Offset
 3766   %}
 3767 %}
 3768 
 3769 operand stackSlotL(sRegL reg) %{
 3770   constraint(ALLOC_IN_RC(stack_slots));
 3771   op_cost(1);  //match(RegL);
 3772   format %{ &quot;[$reg(stackSlotL)]&quot; %}
 3773   interface(MEMORY_INTER) %{
 3774     base(0xf);   // Z_SP
 3775     index(0xffffFFFF); // noreg
 3776     scale(0x0);
 3777     disp($reg);  // Stack Offset
 3778   %}
 3779 %}
 3780 
 3781 // Operands for expressing Control Flow
 3782 // NOTE: Label is a predefined operand which should not be redefined in
 3783 // the AD file. It is generically handled within the ADLC.
 3784 
 3785 //----------Conditional Branch Operands----------------------------------------
 3786 // Comparison Op  - This is the operation of the comparison, and is limited to
 3787 //                  the following set of codes:
 3788 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 3789 //
 3790 // Other attributes of the comparison, such as unsignedness, are specified
 3791 // by the comparison instruction that sets a condition code flags register.
 3792 // That result is represented by a flags operand whose subtype is appropriate
 3793 // to the unsignedness (etc.) of the comparison.
 3794 //
 3795 // Later, the instruction which matches both the Comparison Op (a Bool) and
 3796 // the flags (produced by the Cmp) specifies the coding of the comparison op
 3797 // by matching a specific subtype of Bool operand below.
 3798 
 3799 // INT cmpOps for CompareAndBranch and CompareAndTrap instructions should not
 3800 // have mask bit #3 set.
 3801 operand cmpOpT() %{
 3802   match(Bool);
 3803   format %{ &quot;&quot; %}
 3804   interface(COND_INTER) %{
 3805     equal(0x8);         // Assembler::bcondEqual
 3806     not_equal(0x6);     // Assembler::bcondNotEqual
 3807     less(0x4);          // Assembler::bcondLow
 3808     greater_equal(0xa); // Assembler::bcondNotLow
 3809     less_equal(0xc);    // Assembler::bcondNotHigh
 3810     greater(0x2);       // Assembler::bcondHigh
 3811     overflow(0x1);      // Assembler::bcondOverflow
 3812     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3813   %}
 3814 %}
 3815 
 3816 // When used for floating point comparisons: unordered is treated as less.
 3817 operand cmpOpF() %{
 3818   match(Bool);
 3819   format %{ &quot;&quot; %}
 3820   interface(COND_INTER) %{
 3821     equal(0x8);
 3822     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3823     less(0x5);          // Includes &#39;unordered&#39;.
 3824     greater_equal(0xa);
 3825     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3826     greater(0x2);
 3827     overflow(0x0);      // Not meaningful on z/Architecture.
 3828     no_overflow(0x0);   // leave unchanged (zero) therefore
 3829   %}
 3830 %}
 3831 
 3832 // &quot;Regular&quot; cmpOp for int comparisons, includes bit #3 (overflow).
 3833 operand cmpOp() %{
 3834   match(Bool);
 3835   format %{ &quot;&quot; %}
 3836   interface(COND_INTER) %{
 3837     equal(0x8);
 3838     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3839     less(0x5);          // Includes &#39;unordered&#39;.
 3840     greater_equal(0xa);
 3841     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3842     greater(0x2);
 3843     overflow(0x1);      // Assembler::bcondOverflow
 3844     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3845   %}
 3846 %}
 3847 
 3848 //----------OPERAND CLASSES----------------------------------------------------
 3849 // Operand Classes are groups of operands that are used to simplify
 3850 // instruction definitions by not requiring the AD writer to specify
 3851 // seperate instructions for every form of operand when the
 3852 // instruction accepts multiple operand types with the same basic
 3853 // encoding and format.  The classic case of this is memory operands.
 3854 // Indirect is not included since its use is limited to Compare &amp; Swap
 3855 
 3856 // Most general memory operand, allows base, index, and long displacement.
 3857 opclass memory(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3858 opclass memoryRXY(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3859 
 3860 // General memory operand, allows base, index, and short displacement.
 3861 opclass memoryRX(indirect, indIndex, indOffset12, indOffset12Narrow, indOffset12index, indOffset12indexNarrow);
 3862 
 3863 // Memory operand, allows only base and long displacement.
 3864 opclass memoryRSY(indirect, indOffset20, indOffset20Narrow);
 3865 
 3866 // Memory operand, allows only base and short displacement.
 3867 opclass memoryRS(indirect, indOffset12, indOffset12Narrow);
 3868 
 3869 // Operand classes to match encode and decode.
 3870 opclass iRegN_P2N(iRegN);
 3871 opclass iRegP_N2P(iRegP);
 3872 
 3873 
 3874 //----------PIPELINE-----------------------------------------------------------
 3875 pipeline %{
 3876 
 3877 //----------ATTRIBUTES---------------------------------------------------------
 3878 attributes %{
 3879   // z/Architecture instructions are of length 2, 4, or 6 bytes.
 3880   variable_size_instructions;
 3881   instruction_unit_size = 2;
 3882 
 3883   // Meaningless on z/Architecture.
 3884   max_instructions_per_bundle = 1;
 3885 
 3886   // The z/Architecture processor fetches 64 bytes...
 3887   instruction_fetch_unit_size = 64;
 3888 
 3889   // ...in one line.
 3890   instruction_fetch_units = 1
 3891 %}
 3892 
 3893 //----------RESOURCES----------------------------------------------------------
 3894 // Resources are the functional units available to the machine.
 3895 resources(
 3896    Z_BR,     // branch unit
 3897    Z_CR,     // condition unit
 3898    Z_FX1,    // integer arithmetic unit 1
 3899    Z_FX2,    // integer arithmetic unit 2
 3900    Z_LDST1,  // load/store unit 1
 3901    Z_LDST2,  // load/store unit 2
 3902    Z_FP1,    // float arithmetic unit 1
 3903    Z_FP2,    // float arithmetic unit 2
 3904    Z_LDST = Z_LDST1 | Z_LDST2,
 3905    Z_FX   = Z_FX1 | Z_FX2,
 3906    Z_FP   = Z_FP1 | Z_FP2
 3907   );
 3908 
 3909 //----------PIPELINE DESCRIPTION-----------------------------------------------
 3910 // Pipeline Description specifies the stages in the machine&#39;s pipeline.
 3911 pipe_desc(
 3912    // TODO: adapt
 3913    Z_IF,  // instruction fetch
 3914    Z_IC,
 3915    Z_D0,  // decode
 3916    Z_D1,  // decode
 3917    Z_D2,  // decode
 3918    Z_D3,  // decode
 3919    Z_Xfer1,
 3920    Z_GD,  // group definition
 3921    Z_MP,  // map
 3922    Z_ISS, // issue
 3923    Z_RF,  // resource fetch
 3924    Z_EX1, // execute (all units)
 3925    Z_EX2, // execute (FP, LDST)
 3926    Z_EX3, // execute (FP, LDST)
 3927    Z_EX4, // execute (FP)
 3928    Z_EX5, // execute (FP)
 3929    Z_EX6, // execute (FP)
 3930    Z_WB,  // write back
 3931    Z_Xfer2,
 3932    Z_CP
 3933   );
 3934 
 3935 //----------PIPELINE CLASSES---------------------------------------------------
 3936 // Pipeline Classes describe the stages in which input and output are
 3937 // referenced by the hardware pipeline.
 3938 
 3939 // Providing the `ins_pipe&#39; declarations in the instruction
 3940 // specifications seems to be of little use. So we use
 3941 // `pipe_class_dummy&#39; for all our instructions at present.
 3942 pipe_class pipe_class_dummy() %{
 3943   single_instruction;
 3944   fixed_latency(4);
 3945 %}
 3946 
 3947 // SIGTRAP based implicit range checks in compiled code.
 3948 // Currently, no pipe classes are used on z/Architecture.
 3949 pipe_class pipe_class_trap() %{
 3950   single_instruction;
 3951 %}
 3952 
 3953 pipe_class pipe_class_fx_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3954   single_instruction;
 3955   dst  : Z_EX1(write);
 3956   src1 : Z_RF(read);
 3957   src2 : Z_RF(read);
 3958   Z_FX : Z_RF;
 3959 %}
 3960 
 3961 pipe_class pipe_class_ldst(iRegP dst, memory mem) %{
 3962   single_instruction;
 3963   mem : Z_RF(read);
 3964   dst : Z_WB(write);
 3965   Z_LDST : Z_RF;
 3966 %}
 3967 
 3968 define %{
 3969   MachNop = pipe_class_dummy;
 3970 %}
 3971 
 3972 %}
 3973 
 3974 //----------INSTRUCTIONS-------------------------------------------------------
 3975 
 3976 //---------- Chain stack slots between similar types --------
 3977 
 3978 // Load integer from stack slot.
 3979 instruct stkI_to_regI(iRegI dst, stackSlotI src) %{
 3980   match(Set dst src);
 3981   ins_cost(MEMORY_REF_COST);
 3982   // TODO: s390 port size(FIXED_SIZE);
 3983   format %{ &quot;L       $dst,$src\t # stk reload int&quot; %}
 3984   opcode(L_ZOPC);
 3985   ins_encode(z_form_rt_mem(dst, src));
 3986   ins_pipe(pipe_class_dummy);
 3987 %}
 3988 
 3989 // Store integer to stack slot.
 3990 instruct regI_to_stkI(stackSlotI dst, iRegI src) %{
 3991   match(Set dst src);
 3992   ins_cost(MEMORY_REF_COST);
 3993   // TODO: s390 port size(FIXED_SIZE);
 3994   format %{ &quot;ST      $src,$dst\t # stk spill int&quot; %}
 3995   opcode(ST_ZOPC);
 3996   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3997   ins_pipe(pipe_class_dummy);
 3998 %}
 3999 
 4000 // Load long from stack slot.
 4001 instruct stkL_to_regL(iRegL dst, stackSlotL src) %{
 4002   match(Set dst src);
 4003   ins_cost(MEMORY_REF_COST);
 4004   // TODO: s390 port size(FIXED_SIZE);
 4005   format %{ &quot;LG      $dst,$src\t # stk reload long&quot; %}
 4006   opcode(LG_ZOPC);
 4007   ins_encode(z_form_rt_mem(dst, src));
 4008   ins_pipe(pipe_class_dummy);
 4009 %}
 4010 
 4011 // Store long to stack slot.
 4012 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 4013   match(Set dst src);
 4014   ins_cost(MEMORY_REF_COST);
 4015   size(6);
 4016   format %{ &quot;STG     $src,$dst\t # stk spill long&quot; %}
 4017   opcode(STG_ZOPC);
 4018   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4019   ins_pipe(pipe_class_dummy);
 4020 %}
 4021 
 4022 // Load pointer from stack slot, 64-bit encoding.
 4023 instruct stkP_to_regP(iRegP dst, stackSlotP src) %{
 4024   match(Set dst src);
 4025   ins_cost(MEMORY_REF_COST);
 4026   // TODO: s390 port size(FIXED_SIZE);
 4027   format %{ &quot;LG      $dst,$src\t # stk reload ptr&quot; %}
 4028   opcode(LG_ZOPC);
 4029   ins_encode(z_form_rt_mem(dst, src));
 4030   ins_pipe(pipe_class_dummy);
 4031 %}
 4032 
 4033 // Store pointer to stack slot.
 4034 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 4035   match(Set dst src);
 4036   ins_cost(MEMORY_REF_COST);
 4037   // TODO: s390 port size(FIXED_SIZE);
 4038   format %{ &quot;STG     $src,$dst\t # stk spill ptr&quot; %}
 4039   opcode(STG_ZOPC);
 4040   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4041   ins_pipe(pipe_class_dummy);
 4042 %}
 4043 
 4044 //  Float types
 4045 
 4046 // Load float value from stack slot.
 4047 instruct stkF_to_regF(regF dst, stackSlotF src) %{
 4048   match(Set dst src);
 4049   ins_cost(MEMORY_REF_COST);
 4050   size(4);
 4051   format %{ &quot;LE(Y)   $dst,$src\t # stk reload float&quot; %}
 4052   opcode(LE_ZOPC);
 4053   ins_encode(z_form_rt_mem(dst, src));
 4054   ins_pipe(pipe_class_dummy);
 4055 %}
 4056 
 4057 // Store float value to stack slot.
 4058 instruct regF_to_stkF(stackSlotF dst, regF src) %{
 4059   match(Set dst src);
 4060   ins_cost(MEMORY_REF_COST);
 4061   size(4);
 4062   format %{ &quot;STE(Y)  $src,$dst\t # stk spill float&quot; %}
 4063   opcode(STE_ZOPC);
 4064   ins_encode(z_form_rt_mem(src, dst));
 4065   ins_pipe(pipe_class_dummy);
 4066 %}
 4067 
 4068 // Load double value from stack slot.
 4069 instruct stkD_to_regD(regD dst, stackSlotD src) %{
 4070   match(Set dst src);
 4071   ins_cost(MEMORY_REF_COST);
 4072   // TODO: s390 port size(FIXED_SIZE);
 4073   format %{ &quot;LD(Y)   $dst,$src\t # stk reload double&quot; %}
 4074   opcode(LD_ZOPC);
 4075   ins_encode(z_form_rt_mem(dst, src));
 4076   ins_pipe(pipe_class_dummy);
 4077 %}
 4078 
 4079 // Store double value to stack slot.
 4080 instruct regD_to_stkD(stackSlotD dst, regD src) %{
 4081   match(Set dst src);
 4082   ins_cost(MEMORY_REF_COST);
 4083   size(4);
 4084   format %{ &quot;STD(Y)  $src,$dst\t # stk spill double&quot; %}
 4085   opcode(STD_ZOPC);
 4086   ins_encode(z_form_rt_mem(src, dst));
 4087   ins_pipe(pipe_class_dummy);
 4088 %}
 4089 
 4090 //----------Load/Store/Move Instructions---------------------------------------
 4091 
 4092 //----------Load Instructions--------------------------------------------------
 4093 
 4094 //------------------
 4095 //  MEMORY
 4096 //------------------
 4097 
 4098 //  BYTE
 4099 // Load Byte (8bit signed)
 4100 instruct loadB(iRegI dst, memory mem) %{
 4101   match(Set dst (LoadB mem));
 4102   ins_cost(MEMORY_REF_COST);
 4103   size(Z_DISP3_SIZE);
 4104   format %{ &quot;LB      $dst, $mem\t # sign-extend byte to int&quot; %}
 4105   opcode(LB_ZOPC, LB_ZOPC);
 4106   ins_encode(z_form_rt_mem_opt(dst, mem));
 4107   ins_pipe(pipe_class_dummy);
 4108 %}
 4109 
 4110 // Load Byte (8bit signed)
 4111 instruct loadB2L(iRegL dst, memory mem) %{
 4112   match(Set dst (ConvI2L (LoadB mem)));
 4113   ins_cost(MEMORY_REF_COST);
 4114   size(Z_DISP3_SIZE);
 4115   format %{ &quot;LGB     $dst, $mem\t # sign-extend byte to long&quot; %}
 4116   opcode(LGB_ZOPC, LGB_ZOPC);
 4117   ins_encode(z_form_rt_mem_opt(dst, mem));
 4118   ins_pipe(pipe_class_dummy);
 4119 %}
 4120 
 4121 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 4122 instruct loadUB(iRegI dst, memory mem) %{
 4123   match(Set dst (LoadUB mem));
 4124   ins_cost(MEMORY_REF_COST);
 4125   size(Z_DISP3_SIZE);
 4126   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to int&quot; %}
 4127   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4128   ins_encode(z_form_rt_mem_opt(dst, mem));
 4129   ins_pipe(pipe_class_dummy);
 4130 %}
 4131 
 4132 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 4133 instruct loadUB2L(iRegL dst, memory mem) %{
 4134   match(Set dst (ConvI2L (LoadUB mem)));
 4135   ins_cost(MEMORY_REF_COST);
 4136   size(Z_DISP3_SIZE);
 4137   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to long&quot; %}
 4138   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4139   ins_encode(z_form_rt_mem_opt(dst, mem));
 4140   ins_pipe(pipe_class_dummy);
 4141 %}
 4142 
 4143 // CHAR/SHORT
 4144 
 4145 // Load Short (16bit signed)
 4146 instruct loadS(iRegI dst, memory mem) %{
 4147   match(Set dst (LoadS mem));
 4148   ins_cost(MEMORY_REF_COST);
 4149   size(Z_DISP_SIZE);
 4150   format %{ &quot;LH(Y)   $dst,$mem\t # sign-extend short to int&quot; %}
 4151   opcode(LHY_ZOPC, LH_ZOPC);
 4152   ins_encode(z_form_rt_mem_opt(dst, mem));
 4153   ins_pipe(pipe_class_dummy);
 4154 %}
 4155 
 4156 // Load Short (16bit signed)
 4157 instruct loadS2L(iRegL dst, memory mem) %{
 4158   match(Set dst (ConvI2L (LoadS mem)));
 4159   ins_cost(MEMORY_REF_COST);
 4160   size(Z_DISP3_SIZE);
 4161   format %{ &quot;LGH     $dst,$mem\t # sign-extend short to long&quot; %}
 4162   opcode(LGH_ZOPC, LGH_ZOPC);
 4163   ins_encode(z_form_rt_mem_opt(dst, mem));
 4164   ins_pipe(pipe_class_dummy);
 4165 %}
 4166 
 4167 // Load Char (16bit Unsigned)
 4168 instruct loadUS(iRegI dst, memory mem) %{
 4169   match(Set dst (LoadUS mem));
 4170   ins_cost(MEMORY_REF_COST);
 4171   size(Z_DISP3_SIZE);
 4172   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to int&quot; %}
 4173   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4174   ins_encode(z_form_rt_mem_opt(dst, mem));
 4175   ins_pipe(pipe_class_dummy);
 4176 %}
 4177 
 4178 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 4179 instruct loadUS2L(iRegL dst, memory mem) %{
 4180   match(Set dst (ConvI2L (LoadUS mem)));
 4181   ins_cost(MEMORY_REF_COST);
 4182   size(Z_DISP3_SIZE);
 4183   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to long&quot; %}
 4184   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4185   ins_encode(z_form_rt_mem_opt(dst, mem));
 4186   ins_pipe(pipe_class_dummy);
 4187 %}
 4188 
 4189 // INT
 4190 
 4191 // Load Integer
 4192 instruct loadI(iRegI dst, memory mem) %{
 4193   match(Set dst (LoadI mem));
 4194   ins_cost(MEMORY_REF_COST);
 4195   size(Z_DISP_SIZE);
 4196   format %{ &quot;L(Y)    $dst,$mem\t #&quot; %}
 4197   opcode(LY_ZOPC, L_ZOPC);
 4198   ins_encode(z_form_rt_mem_opt(dst, mem));
 4199   ins_pipe(pipe_class_dummy);
 4200 %}
 4201 
 4202 // Load and convert to long.
 4203 instruct loadI2L(iRegL dst, memory mem) %{
 4204   match(Set dst (ConvI2L (LoadI mem)));
 4205   ins_cost(MEMORY_REF_COST);
 4206   size(Z_DISP3_SIZE);
 4207   format %{ &quot;LGF     $dst,$mem\t #&quot; %}
 4208   opcode(LGF_ZOPC, LGF_ZOPC);
 4209   ins_encode(z_form_rt_mem_opt(dst, mem));
 4210   ins_pipe(pipe_class_dummy);
 4211 %}
 4212 
 4213 // Load Unsigned Integer into a Long Register
 4214 instruct loadUI2L(iRegL dst, memory mem, immL_FFFFFFFF mask) %{
 4215   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 4216   ins_cost(MEMORY_REF_COST);
 4217   size(Z_DISP3_SIZE);
 4218   format %{ &quot;LLGF    $dst,$mem\t # zero-extend int to long&quot; %}
 4219   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4220   ins_encode(z_form_rt_mem_opt(dst, mem));
 4221   ins_pipe(pipe_class_dummy);
 4222 %}
 4223 
 4224 // range = array length (=jint)
 4225 // Load Range
 4226 instruct loadRange(iRegI dst, memory mem) %{
 4227   match(Set dst (LoadRange mem));
 4228   ins_cost(MEMORY_REF_COST);
 4229   size(Z_DISP_SIZE);
 4230   format %{ &quot;L(Y)    $dst,$mem\t # range&quot; %}
 4231   opcode(LY_ZOPC, L_ZOPC);
 4232   ins_encode(z_form_rt_mem_opt(dst, mem));
 4233   ins_pipe(pipe_class_dummy);
 4234 %}
 4235 
 4236 // LONG
 4237 
 4238 // Load Long - aligned
 4239 instruct loadL(iRegL dst, memory mem) %{
 4240   match(Set dst (LoadL mem));
 4241   ins_cost(MEMORY_REF_COST);
 4242   size(Z_DISP3_SIZE);
 4243   format %{ &quot;LG      $dst,$mem\t # long&quot; %}
 4244   opcode(LG_ZOPC, LG_ZOPC);
 4245   ins_encode(z_form_rt_mem_opt(dst, mem));
 4246   ins_pipe(pipe_class_dummy);
 4247 %}
 4248 
 4249 // Load Long - UNaligned
 4250 instruct loadL_unaligned(iRegL dst, memory mem) %{
 4251   match(Set dst (LoadL_unaligned mem));
 4252   ins_cost(MEMORY_REF_COST);
 4253   size(Z_DISP3_SIZE);
 4254   format %{ &quot;LG      $dst,$mem\t # unaligned long&quot; %}
 4255   opcode(LG_ZOPC, LG_ZOPC);
 4256   ins_encode(z_form_rt_mem_opt(dst, mem));
 4257   ins_pipe(pipe_class_dummy);
 4258 %}
 4259 
 4260 
 4261 // PTR
 4262 
 4263 // Load Pointer
 4264 instruct loadP(iRegP dst, memory mem) %{
 4265   match(Set dst (LoadP mem));
 4266   ins_cost(MEMORY_REF_COST);
 4267   size(Z_DISP3_SIZE);
 4268   format %{ &quot;LG      $dst,$mem\t # ptr&quot; %}
 4269   opcode(LG_ZOPC, LG_ZOPC);
 4270   ins_encode(z_form_rt_mem_opt(dst, mem));
 4271   ins_pipe(pipe_class_dummy);
 4272 %}
 4273 
 4274 // LoadP + CastP2L
 4275 instruct castP2X_loadP(iRegL dst, memory mem) %{
 4276   match(Set dst (CastP2X (LoadP mem)));
 4277   ins_cost(MEMORY_REF_COST);
 4278   size(Z_DISP3_SIZE);
 4279   format %{ &quot;LG      $dst,$mem\t # ptr + p2x&quot; %}
 4280   opcode(LG_ZOPC, LG_ZOPC);
 4281   ins_encode(z_form_rt_mem_opt(dst, mem));
 4282   ins_pipe(pipe_class_dummy);
 4283 %}
 4284 
 4285 // Load Klass Pointer
 4286 instruct loadKlass(iRegP dst, memory mem) %{
 4287   match(Set dst (LoadKlass mem));
 4288   ins_cost(MEMORY_REF_COST);
 4289   size(Z_DISP3_SIZE);
 4290   format %{ &quot;LG      $dst,$mem\t # klass ptr&quot; %}
 4291   opcode(LG_ZOPC, LG_ZOPC);
 4292   ins_encode(z_form_rt_mem_opt(dst, mem));
 4293   ins_pipe(pipe_class_dummy);
 4294 %}
 4295 
 4296 instruct loadTOC(iRegL dst) %{
 4297   effect(DEF dst);
 4298   ins_cost(DEFAULT_COST);
 4299   // TODO: s390 port size(FIXED_SIZE);
 4300   // TODO: check why this attribute causes many unnecessary rematerializations.
 4301   //
 4302   // The graphs I saw just had high register pressure. Further the
 4303   // register TOC is loaded to is overwritten by the constant short
 4304   // after. Here something as round robin register allocation might
 4305   // help. But rematerializing seems not to hurt, jack even seems to
 4306   // improve slightly.
 4307   //
 4308   // Without this flag we get spill-split recycle sanity check
 4309   // failures in
 4310   // spec.benchmarks._228_jack.NfaState::GenerateCode. This happens in
 4311   // a block with three loadConP_dynTOC nodes and a tlsLoadP. The
 4312   // tlsLoadP has a huge amount of outs and forces the TOC down to the
 4313   // stack. Later tlsLoadP is rematerialized, leaving the register
 4314   // allocator with TOC on the stack and a badly placed reload.
 4315   ins_should_rematerialize(true);
 4316   format %{ &quot;LARL    $dst, &amp;constant_pool\t; load dynTOC&quot; %}
 4317   ins_encode %{ __ load_toc($dst$$Register); %}
 4318   ins_pipe(pipe_class_dummy);
 4319 %}
 4320 
 4321 // FLOAT
 4322 
 4323 // Load Float
 4324 instruct loadF(regF dst, memory mem) %{
 4325   match(Set dst (LoadF mem));
 4326   ins_cost(MEMORY_REF_COST);
 4327   size(Z_DISP_SIZE);
 4328   format %{ &quot;LE(Y)    $dst,$mem&quot; %}
 4329   opcode(LEY_ZOPC, LE_ZOPC);
 4330   ins_encode(z_form_rt_mem_opt(dst, mem));
 4331   ins_pipe(pipe_class_dummy);
 4332 %}
 4333 
 4334 // DOUBLE
 4335 
 4336 // Load Double
 4337 instruct loadD(regD dst, memory mem) %{
 4338   match(Set dst (LoadD mem));
 4339   ins_cost(MEMORY_REF_COST);
 4340   size(Z_DISP_SIZE);
 4341   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4342   opcode(LDY_ZOPC, LD_ZOPC);
 4343   ins_encode(z_form_rt_mem_opt(dst, mem));
 4344   ins_pipe(pipe_class_dummy);
 4345 %}
 4346 
 4347 // Load Double - UNaligned
 4348 instruct loadD_unaligned(regD dst, memory mem) %{
 4349   match(Set dst (LoadD_unaligned mem));
 4350   ins_cost(MEMORY_REF_COST);
 4351   size(Z_DISP_SIZE);
 4352   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4353   opcode(LDY_ZOPC, LD_ZOPC);
 4354   ins_encode(z_form_rt_mem_opt(dst, mem));
 4355   ins_pipe(pipe_class_dummy);
 4356 %}
 4357 
 4358 
 4359 //----------------------
 4360 //  IMMEDIATES
 4361 //----------------------
 4362 
 4363 instruct loadConI(iRegI dst, immI src) %{
 4364   match(Set dst src);
 4365   ins_cost(DEFAULT_COST);
 4366   size(6);
 4367   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}
 4368   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4369   ins_pipe(pipe_class_dummy);
 4370 %}
 4371 
 4372 instruct loadConI16(iRegI dst, immI16 src) %{
 4373   match(Set dst src);
 4374   ins_cost(DEFAULT_COST_LOW);
 4375   size(4);
 4376   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}
 4377   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4378   ins_pipe(pipe_class_dummy);
 4379 %}
 4380 
 4381 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4382   match(Set dst src);
 4383   effect(KILL cr);
 4384   ins_cost(DEFAULT_COST_LOW);
 4385   size(4);
 4386   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4387   opcode(XGR_ZOPC);
 4388   ins_encode(z_rreform(dst, dst));
 4389   ins_pipe(pipe_class_dummy);
 4390 %}
 4391 
 4392 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4393   match(Set dst src);
 4394   // TODO: s390 port size(FIXED_SIZE);
 4395   format %{ &quot;LLILL    $dst,$src&quot; %}
 4396   opcode(LLILL_ZOPC);
 4397   ins_encode(z_riform_unsigned(dst, src) );
 4398   ins_pipe(pipe_class_dummy);
 4399 %}
 4400 
 4401 // Load long constant from TOC with pcrelative address.
 4402 instruct loadConL_pcrelTOC(iRegL dst, immL src) %{
 4403   match(Set dst src);
 4404   ins_cost(MEMORY_REF_COST_LO);
 4405   size(6);
 4406   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load long $src from table&quot; %}
 4407   ins_encode %{
 4408     address long_address = __ long_constant($src$$constant);
 4409     if (long_address == NULL) {
 4410       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4411       return;
 4412     }
 4413     __ load_long_pcrelative($dst$$Register, long_address);
 4414   %}
 4415   ins_pipe(pipe_class_dummy);
 4416 %}
 4417 
 4418 instruct loadConL32(iRegL dst, immL32 src) %{
 4419   match(Set dst src);
 4420   ins_cost(DEFAULT_COST);
 4421   size(6);
 4422   format %{ &quot;LGFI     $dst,$src\t # (long)&quot; %}
 4423   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4424   ins_pipe(pipe_class_dummy);
 4425 %}
 4426 
 4427 instruct loadConL16(iRegL dst, immL16 src) %{
 4428   match(Set dst src);
 4429   ins_cost(DEFAULT_COST_LOW);
 4430   size(4);
 4431   format %{ &quot;LGHI     $dst,$src\t # (long)&quot; %}
 4432   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4433   ins_pipe(pipe_class_dummy);
 4434 %}
 4435 
 4436 instruct loadConL_0(iRegL dst, immL_0 src, flagsReg cr) %{
 4437   match(Set dst src);
 4438   effect(KILL cr);
 4439   ins_cost(DEFAULT_COST_LOW);
 4440   format %{ &quot;LoadConL    $dst,$src\t # (long) XGR because ZERO is loaded&quot; %}
 4441   opcode(XGR_ZOPC);
 4442   ins_encode(z_rreform(dst, dst));
 4443   ins_pipe(pipe_class_dummy);
 4444 %}
 4445 
 4446 // Load ptr constant from TOC with pc relative address.
 4447 // Special handling for oop constants required.
 4448 instruct loadConP_pcrelTOC(iRegP dst, immP src) %{
 4449   match(Set dst src);
 4450   ins_cost(MEMORY_REF_COST_LO);
 4451   size(6);
 4452   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load ptr $src from table&quot; %}
 4453   ins_encode %{
 4454     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();
 4455     if (constant_reloc == relocInfo::oop_type) {
 4456       AddressLiteral a = __ allocate_oop_address((jobject)$src$$constant);
 4457       bool success = __ load_oop_from_toc($dst$$Register, a);
 4458       if (!success) {
 4459         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4460         return;
 4461       }
 4462     } else if (constant_reloc == relocInfo::metadata_type) {
 4463       AddressLiteral a = __ constant_metadata_address((Metadata *)$src$$constant);
 4464       address const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 4465       if (const_toc_addr == NULL) {
 4466         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4467         return;
 4468       }
 4469       __ load_long_pcrelative($dst$$Register, const_toc_addr);
 4470     } else {          // Non-oop pointers, e.g. card mark base, heap top.
 4471       address long_address = __ long_constant((jlong)$src$$constant);
 4472       if (long_address == NULL) {
 4473         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4474         return;
 4475       }
 4476       __ load_long_pcrelative($dst$$Register, long_address);
 4477     }
 4478   %}
 4479   ins_pipe(pipe_class_dummy);
 4480 %}
 4481 
 4482 // We don&#39;t use immP16 to avoid problems with oops.
 4483 instruct loadConP0(iRegP dst, immP0 src, flagsReg cr) %{
 4484   match(Set dst src);
 4485   effect(KILL cr);
 4486   size(4);
 4487   format %{ &quot;XGR     $dst,$dst\t # NULL ptr&quot; %}
 4488   opcode(XGR_ZOPC);
 4489   ins_encode(z_rreform(dst, dst));
 4490   ins_pipe(pipe_class_dummy);
 4491 %}
 4492 
 4493 //----------Load Float Constant Instructions-------------------------------------------------
 4494 
 4495 // We may not specify this instruction via an `expand&#39; rule. If we do,
 4496 // code selection will forget that this instruction needs a floating
 4497 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4498 // will fail.
 4499 instruct loadConF_dynTOC(regF dst, immF src, flagsReg cr) %{
 4500   match(Set dst src);
 4501   effect(KILL cr);
 4502   ins_cost(MEMORY_REF_COST);
 4503   size(6);
 4504   // If this instruction rematerializes, it prolongs the live range
 4505   // of the toc node, causing illegal graphs.
 4506   ins_cannot_rematerialize(true);
 4507   format %{ &quot;LE(Y)    $dst,$constantoffset[,$constanttablebase]\t # load FLOAT $src from table&quot; %}
 4508   ins_encode %{
 4509     __ load_float_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4510   %}
 4511   ins_pipe(pipe_class_dummy);
 4512 %}
 4513 
 4514 // E may not specify this instruction via an `expand&#39; rule. If we do,
 4515 // code selection will forget that this instruction needs a floating
 4516 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4517 // will fail.
 4518 instruct loadConD_dynTOC(regD dst, immD src, flagsReg cr) %{
 4519   match(Set dst src);
 4520   effect(KILL cr);
 4521   ins_cost(MEMORY_REF_COST);
 4522   size(6);
 4523   // If this instruction rematerializes, it prolongs the live range
 4524   // of the toc node, causing illegal graphs.
 4525   ins_cannot_rematerialize(true);
 4526   format %{ &quot;LD(Y)    $dst,$constantoffset[,$constanttablebase]\t # load DOUBLE $src from table&quot; %}
 4527   ins_encode %{
 4528     __ load_double_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4529   %}
 4530   ins_pipe(pipe_class_dummy);
 4531 %}
 4532 
 4533 // Special case: Load Const 0.0F
 4534 
 4535 // There&#39;s a special instr to clear a FP register.
 4536 instruct loadConF0(regF dst, immFp0 src) %{
 4537   match(Set dst src);
 4538   ins_cost(DEFAULT_COST_LOW);
 4539   size(4);
 4540   format %{ &quot;LZER     $dst,$src\t # clear to zero&quot; %}
 4541   opcode(LZER_ZOPC);
 4542   ins_encode(z_rreform(dst, Z_F0));
 4543   ins_pipe(pipe_class_dummy);
 4544 %}
 4545 
 4546 // There&#39;s a special instr to clear a FP register.
 4547 instruct loadConD0(regD dst, immDp0 src) %{
 4548   match(Set dst src);
 4549   ins_cost(DEFAULT_COST_LOW);
 4550   size(4);
 4551   format %{ &quot;LZDR     $dst,$src\t # clear to zero&quot; %}
 4552   opcode(LZDR_ZOPC);
 4553   ins_encode(z_rreform(dst, Z_F0));
 4554   ins_pipe(pipe_class_dummy);
 4555 %}
 4556 
 4557 
 4558 //----------Store Instructions-------------------------------------------------
 4559 
 4560 // BYTE
 4561 
 4562 // Store Byte
 4563 instruct storeB(memory mem, iRegI src) %{
 4564   match(Set mem (StoreB mem src));
 4565   ins_cost(MEMORY_REF_COST);
 4566   size(Z_DISP_SIZE);
 4567   format %{ &quot;STC(Y)  $src,$mem\t # byte&quot; %}
 4568   opcode(STCY_ZOPC, STC_ZOPC);
 4569   ins_encode(z_form_rt_mem_opt(src, mem));
 4570   ins_pipe(pipe_class_dummy);
 4571 %}
 4572 
 4573 instruct storeCM(memory mem, immI_0 src) %{
 4574   match(Set mem (StoreCM mem src));
 4575   ins_cost(MEMORY_REF_COST);
 4576   // TODO: s390 port size(VARIABLE_SIZE);
 4577   format %{ &quot;STC(Y)  $src,$mem\t # CMS card-mark byte (must be 0!)&quot; %}
 4578   ins_encode %{
 4579     guarantee($mem$$index$$Register != Z_R0, &quot;content will not be used.&quot;);
 4580     if ($mem$$index$$Register != noreg) {
 4581       // Can&#39;t use clear_mem --&gt; load const zero and store character.
 4582       __ load_const_optimized(Z_R0_scratch, (long)0);
 4583       if (Immediate::is_uimm12($mem$$disp)) {
 4584         __ z_stc(Z_R0_scratch, $mem$$Address);
 4585       } else {
 4586         __ z_stcy(Z_R0_scratch, $mem$$Address);
 4587       }
 4588     } else {
 4589       __ clear_mem(Address($mem$$Address), 1);
 4590     }
 4591   %}
 4592   ins_pipe(pipe_class_dummy);
 4593 %}
 4594 
 4595 // CHAR/SHORT
 4596 
 4597 // Store Char/Short
 4598 instruct storeC(memory mem, iRegI src) %{
 4599   match(Set mem (StoreC mem src));
 4600   ins_cost(MEMORY_REF_COST);
 4601   size(Z_DISP_SIZE);
 4602   format %{ &quot;STH(Y)  $src,$mem\t # short&quot; %}
 4603   opcode(STHY_ZOPC, STH_ZOPC);
 4604   ins_encode(z_form_rt_mem_opt(src, mem));
 4605   ins_pipe(pipe_class_dummy);
 4606 %}
 4607 
 4608 // INT
 4609 
 4610 // Store Integer
 4611 instruct storeI(memory mem, iRegI src) %{
 4612   match(Set mem (StoreI mem src));
 4613   ins_cost(MEMORY_REF_COST);
 4614   size(Z_DISP_SIZE);
 4615   format %{ &quot;ST(Y)   $src,$mem\t # int&quot; %}
 4616   opcode(STY_ZOPC, ST_ZOPC);
 4617   ins_encode(z_form_rt_mem_opt(src, mem));
 4618   ins_pipe(pipe_class_dummy);
 4619 %}
 4620 
 4621 // LONG
 4622 
 4623 // Store Long
 4624 instruct storeL(memory mem, iRegL src) %{
 4625   match(Set mem (StoreL mem src));
 4626   ins_cost(MEMORY_REF_COST);
 4627   size(Z_DISP3_SIZE);
 4628   format %{ &quot;STG     $src,$mem\t # long&quot; %}
 4629   opcode(STG_ZOPC, STG_ZOPC);
 4630   ins_encode(z_form_rt_mem_opt(src, mem));
 4631   ins_pipe(pipe_class_dummy);
 4632 %}
 4633 
 4634 // PTR
 4635 
 4636 // Store Pointer
 4637 instruct storeP(memory dst, memoryRegP src) %{
 4638   match(Set dst (StoreP dst src));
 4639   ins_cost(MEMORY_REF_COST);
 4640   size(Z_DISP3_SIZE);
 4641   format %{ &quot;STG     $src,$dst\t # ptr&quot; %}
 4642   opcode(STG_ZOPC, STG_ZOPC);
 4643   ins_encode(z_form_rt_mem_opt(src, dst));
 4644   ins_pipe(pipe_class_dummy);
 4645 %}
 4646 
 4647 // FLOAT
 4648 
 4649 // Store Float
 4650 instruct storeF(memory mem, regF src) %{
 4651   match(Set mem (StoreF mem src));
 4652   ins_cost(MEMORY_REF_COST);
 4653   size(Z_DISP_SIZE);
 4654   format %{ &quot;STE(Y)   $src,$mem\t # float&quot; %}
 4655   opcode(STEY_ZOPC, STE_ZOPC);
 4656   ins_encode(z_form_rt_mem_opt(src, mem));
 4657   ins_pipe(pipe_class_dummy);
 4658 %}
 4659 
 4660 // DOUBLE
 4661 
 4662 // Store Double
 4663 instruct storeD(memory mem, regD src) %{
 4664   match(Set mem (StoreD mem src));
 4665   ins_cost(MEMORY_REF_COST);
 4666   size(Z_DISP_SIZE);
 4667   format %{ &quot;STD(Y)   $src,$mem\t # double&quot; %}
 4668   opcode(STDY_ZOPC, STD_ZOPC);
 4669   ins_encode(z_form_rt_mem_opt(src, mem));
 4670   ins_pipe(pipe_class_dummy);
 4671 %}
 4672 
 4673 // Prefetch instructions. Must be safe to execute with invalid address (cannot fault).
 4674 
 4675 // Should support match rule for PrefetchAllocation.
 4676 // Still needed after 8068977 for PrefetchAllocate.
 4677 instruct prefetchAlloc(memory mem) %{
 4678   match(PrefetchAllocation mem);
 4679   predicate(VM_Version::has_Prefetch());
 4680   ins_cost(DEFAULT_COST);
 4681   format %{ &quot;PREFETCH 2, $mem\t # Prefetch allocation, z10 only&quot; %}
 4682   ins_encode %{ __ z_pfd(0x02, $mem$$Address); %}
 4683   ins_pipe(pipe_class_dummy);
 4684 %}
 4685 
 4686 //----------Memory init instructions------------------------------------------
 4687 
 4688 // Move Immediate to 1-byte memory.
 4689 instruct memInitB(memoryRSY mem, immI8 src) %{
 4690   match(Set mem (StoreB mem src));
 4691   ins_cost(MEMORY_REF_COST);
 4692   // TODO: s390 port size(VARIABLE_SIZE);
 4693   format %{ &quot;MVI     $mem,$src\t # direct mem init 1&quot; %}
 4694   ins_encode %{
 4695     if (Immediate::is_uimm12((long)$mem$$disp)) {
 4696       __ z_mvi($mem$$Address, $src$$constant);
 4697     } else {
 4698       __ z_mviy($mem$$Address, $src$$constant);
 4699     }
 4700   %}
 4701   ins_pipe(pipe_class_dummy);
 4702 %}
 4703 
 4704 // Move Immediate to 2-byte memory.
 4705 instruct memInitC(memoryRS mem, immI16 src) %{
 4706   match(Set mem (StoreC mem src));
 4707   ins_cost(MEMORY_REF_COST);
 4708   size(6);
 4709   format %{ &quot;MVHHI   $mem,$src\t # direct mem init 2&quot; %}
 4710   opcode(MVHHI_ZOPC);
 4711   ins_encode(z_silform(mem, src));
 4712   ins_pipe(pipe_class_dummy);
 4713 %}
 4714 
 4715 // Move Immediate to 4-byte memory.
 4716 instruct memInitI(memoryRS mem, immI16 src) %{
 4717   match(Set mem (StoreI mem src));
 4718   ins_cost(MEMORY_REF_COST);
 4719   size(6);
 4720   format %{ &quot;MVHI    $mem,$src\t # direct mem init 4&quot; %}
 4721   opcode(MVHI_ZOPC);
 4722   ins_encode(z_silform(mem, src));
 4723   ins_pipe(pipe_class_dummy);
 4724 %}
 4725 
 4726 
 4727 // Move Immediate to 8-byte memory.
 4728 instruct memInitL(memoryRS mem, immL16 src) %{
 4729   match(Set mem (StoreL mem src));
 4730   ins_cost(MEMORY_REF_COST);
 4731   size(6);
 4732   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4733   opcode(MVGHI_ZOPC);
 4734   ins_encode(z_silform(mem, src));
 4735   ins_pipe(pipe_class_dummy);
 4736 %}
 4737 
 4738 // Move Immediate to 8-byte memory.
 4739 instruct memInitP(memoryRS mem, immP16 src) %{
 4740   match(Set mem (StoreP mem src));
 4741   ins_cost(MEMORY_REF_COST);
 4742   size(6);
 4743   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4744   opcode(MVGHI_ZOPC);
 4745   ins_encode(z_silform(mem, src));
 4746   ins_pipe(pipe_class_dummy);
 4747 %}
 4748 
 4749 
 4750 //----------Instructions for compressed pointers (cOop and NKlass)-------------
 4751 
 4752 // See cOop encoding classes for elaborate comment.
 4753 
 4754 // Moved here because it is needed in expand rules for encode.
 4755 // Long negation.
 4756 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4757   match(Set dst (SubL zero src));
 4758   effect(KILL cr);
 4759   size(4);
 4760   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4761   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4762   ins_pipe(pipe_class_dummy);
 4763 %}
 4764 
 4765 // Load Compressed Pointer
 4766 
 4767 // Load narrow oop
 4768 instruct loadN(iRegN dst, memory mem) %{
 4769   match(Set dst (LoadN mem));
 4770   ins_cost(MEMORY_REF_COST);
 4771   size(Z_DISP3_SIZE);
 4772   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}
 4773   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4774   ins_encode(z_form_rt_mem_opt(dst, mem));
 4775   ins_pipe(pipe_class_dummy);
 4776 %}
 4777 
 4778 // Load narrow Klass Pointer
 4779 instruct loadNKlass(iRegN dst, memory mem) %{
 4780   match(Set dst (LoadNKlass mem));
 4781   ins_cost(MEMORY_REF_COST);
 4782   size(Z_DISP3_SIZE);
 4783   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}
 4784   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4785   ins_encode(z_form_rt_mem_opt(dst, mem));
 4786   ins_pipe(pipe_class_dummy);
 4787 %}
 4788 
 4789 // Load constant Compressed Pointer
 4790 
 4791 instruct loadConN(iRegN dst, immN src) %{
 4792   match(Set dst src);
 4793   ins_cost(DEFAULT_COST);
 4794   size(6);
 4795   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4796   ins_encode %{
 4797     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4798     __ relocate(cOop.rspec(), 1);
 4799     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4800   %}
 4801   ins_pipe(pipe_class_dummy);
 4802 %}
 4803 
 4804 instruct loadConN0(iRegN dst, immN0 src, flagsReg cr) %{
 4805   match(Set dst src);
 4806   effect(KILL cr);
 4807   ins_cost(DEFAULT_COST_LOW);
 4808   size(4);
 4809   format %{ &quot;loadConN    $dst,$src\t # (cOop) XGR because ZERO is loaded&quot; %}
 4810   opcode(XGR_ZOPC);
 4811   ins_encode(z_rreform(dst, dst));
 4812   ins_pipe(pipe_class_dummy);
 4813 %}
 4814 
 4815 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4816   match(Set dst src);
 4817   ins_cost(DEFAULT_COST);
 4818   size(6);
 4819   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4820   ins_encode %{
 4821     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4822     __ relocate(NKlass.rspec(), 1);
 4823     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4824   %}
 4825   ins_pipe(pipe_class_dummy);
 4826 %}
 4827 
 4828 // Load and Decode Compressed Pointer
 4829 // optimized variants for Unscaled cOops
 4830 
 4831 instruct decodeLoadN(iRegP dst, memory mem) %{
 4832   match(Set dst (DecodeN (LoadN mem)));
 4833   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));
 4834   ins_cost(MEMORY_REF_COST);
 4835   size(Z_DISP3_SIZE);
 4836   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}
 4837   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4838   ins_encode(z_form_rt_mem_opt(dst, mem));
 4839   ins_pipe(pipe_class_dummy);
 4840 %}
 4841 
 4842 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4843   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 4844   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));
 4845   ins_cost(MEMORY_REF_COST);
 4846   size(Z_DISP3_SIZE);
 4847   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}
 4848   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4849   ins_encode(z_form_rt_mem_opt(dst, mem));
 4850   ins_pipe(pipe_class_dummy);
 4851 %}
 4852 
 4853 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4854   match(Set dst (DecodeNKlass src));
 4855   ins_cost(3 * DEFAULT_COST);
 4856   size(12);
 4857   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4858   ins_encode %{
 4859     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4860     __ relocate(NKlass.rspec(), 1);
 4861     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4862   %}
 4863   ins_pipe(pipe_class_dummy);
 4864 %}
 4865 
 4866 // Decode Compressed Pointer
 4867 
 4868 // General decoder
 4869 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4870   match(Set dst (DecodeN src));
 4871   effect(KILL cr);
 4872   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);
 4873   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4874   // TODO: s390 port size(VARIABLE_SIZE);
 4875   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}
 4876   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4877   ins_pipe(pipe_class_dummy);
 4878 %}
 4879 
 4880 // General Klass decoder
 4881 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4882   match(Set dst (DecodeNKlass src));
 4883   effect(KILL cr);
 4884   ins_cost(3 * DEFAULT_COST);
 4885   format %{ &quot;decode_klass $dst,$src&quot; %}
 4886   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4887   ins_pipe(pipe_class_dummy);
 4888 %}
 4889 
 4890 // General decoder
 4891 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4892   match(Set dst (DecodeN src));
 4893   effect(KILL cr);
 4894   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4895              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4896             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));
 4897   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4898   // TODO: s390 port size(VARIABLE_SIZE);
 4899   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}
 4900   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4901   ins_pipe(pipe_class_dummy);
 4902 %}
 4903 
 4904   instruct loadBase(iRegL dst, immL baseImm) %{
 4905     effect(DEF dst, USE baseImm);
 4906     predicate(false);
 4907     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4908     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4909     ins_pipe(pipe_class_dummy);
 4910   %}
 4911 
 4912   // Decoder for heapbased mode peeling off loading the base.
 4913   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4914     match(Set dst (DecodeN src base));
 4915     // Note: Effect TEMP dst was used with the intention to get
 4916     // different regs for dst and base, but this has caused ADLC to
 4917     // generate wrong code. Oop_decoder generates additional lgr when
 4918     // dst==base.
 4919     effect(KILL cr);
 4920     predicate(false);
 4921     // TODO: s390 port size(VARIABLE_SIZE);
 4922     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4923     ins_encode %{
 4924       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
 4925                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4926     %}
 4927     ins_pipe(pipe_class_dummy);
 4928   %}
 4929 
 4930   // Decoder for heapbased mode peeling off loading the base.
 4931   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4932     match(Set dst (DecodeN src base));
 4933     effect(KILL cr);
 4934     predicate(false);
 4935     // TODO: s390 port size(VARIABLE_SIZE);
 4936     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4937     ins_encode %{
 4938       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
 4939                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4940     %}
 4941     ins_pipe(pipe_class_dummy);
 4942   %}
 4943 
 4944 // Decoder for heapbased mode peeling off loading the base.
 4945 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4946   match(Set dst (DecodeN src));
 4947   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);
 4948   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4949   // TODO: s390 port size(VARIABLE_SIZE);
 4950   expand %{
 4951     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4952     iRegL base;
 4953     loadBase(base, baseImm);
 4954     decodeN_base(dst, src, base, cr);
 4955   %}
 4956 %}
 4957 
 4958 // Decoder for heapbased mode peeling off loading the base.
 4959 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4960   match(Set dst (DecodeN src));
 4961   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4962              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4963             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);
 4964   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4965   // TODO: s390 port size(VARIABLE_SIZE);
 4966   expand %{
 4967     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4968     iRegL base;
 4969     loadBase(base, baseImm);
 4970     decodeN_NN_base(dst, src, base, cr);
 4971   %}
 4972 %}
 4973 
 4974 //  Encode Compressed Pointer
 4975 
 4976 // General encoder
 4977 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4978   match(Set dst (EncodeP src));
 4979   effect(KILL cr);
 4980   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4981             (CompressedOops::base() == 0 ||
 4982              CompressedOops::base_disjoint() ||
 4983              !ExpandLoadingBaseEncode));
 4984   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4985   // TODO: s390 port size(VARIABLE_SIZE);
 4986   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4987   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4988   ins_pipe(pipe_class_dummy);
 4989 %}
 4990 
 4991 // General class encoder
 4992 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4993   match(Set dst (EncodePKlass src));
 4994   effect(KILL cr);
 4995   format %{ &quot;encode_klass $dst,$src&quot; %}
 4996   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4997   ins_pipe(pipe_class_dummy);
 4998 %}
 4999 
 5000 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 5001   match(Set dst (EncodeP src));
 5002   effect(KILL cr);
 5003   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 5004             (CompressedOops::base() == 0 ||
 5005              CompressedOops::base_disjoint() ||
 5006              !ExpandLoadingBaseEncode_NN));
 5007   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5008   // TODO: s390 port size(VARIABLE_SIZE);
 5009   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 5010   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 5011   ins_pipe(pipe_class_dummy);
 5012 %}
 5013 
 5014   // Encoder for heapbased mode peeling off loading the base.
 5015   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 5016     match(Set dst (EncodeP src (Binary base dst)));
 5017     effect(TEMP_DEF dst);
 5018     predicate(false);
 5019     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5020     // TODO: s390 port size(VARIABLE_SIZE);
 5021     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}
 5022     ins_encode %{
 5023       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
 5024         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());
 5025       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 5026     %}
 5027     ins_pipe(pipe_class_dummy);
 5028   %}
 5029 
 5030   // Encoder for heapbased mode peeling off loading the base.
 5031   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 5032     match(Set dst (EncodeP src base));
 5033     effect(USE pow2_offset);
 5034     predicate(false);
 5035     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5036     // TODO: s390 port size(VARIABLE_SIZE);
 5037     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}
 5038     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 5039     ins_pipe(pipe_class_dummy);
 5040   %}
 5041 
 5042 // Encoder for heapbased mode peeling off loading the base.
 5043 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5044   match(Set dst (EncodeP src));
 5045   effect(KILL cr);
 5046   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 5047             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));
 5048   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5049   // TODO: s390 port size(VARIABLE_SIZE);
 5050   expand %{
 5051     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}
 5052     immL_0 zero %{ (0) %}
 5053     flagsReg ccr;
 5054     iRegL base;
 5055     iRegL negBase;
 5056     loadBase(base, baseImm);
 5057     negL_reg_reg(negBase, zero, base, ccr);
 5058     encodeP_base(dst, src, negBase);
 5059   %}
 5060 %}
 5061 
 5062 // Encoder for heapbased mode peeling off loading the base.
 5063 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5064   match(Set dst (EncodeP src));
 5065   effect(KILL cr);
 5066   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 5067             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));
 5068   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5069   // TODO: s390 port size(VARIABLE_SIZE);
 5070   expand %{
 5071     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 5072     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}
 5073     immL_0 zero %{ 0 %}
 5074     flagsReg ccr;
 5075     iRegL base;
 5076     iRegL negBase;
 5077     loadBase(base, baseImm);
 5078     negL_reg_reg(negBase, zero, base, ccr);
 5079     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5080   %}
 5081 %}
 5082 
 5083 //  Store Compressed Pointer
 5084 
 5085 // Store Compressed Pointer
 5086 instruct storeN(memory mem, iRegN_P2N src) %{
 5087   match(Set mem (StoreN mem src));
 5088   ins_cost(MEMORY_REF_COST);
 5089   size(Z_DISP_SIZE);
 5090   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}
 5091   opcode(STY_ZOPC, ST_ZOPC);
 5092   ins_encode(z_form_rt_mem_opt(src, mem));
 5093   ins_pipe(pipe_class_dummy);
 5094 %}
 5095 
 5096 // Store Compressed Klass pointer
 5097 instruct storeNKlass(memory mem, iRegN src) %{
 5098   match(Set mem (StoreNKlass mem src));
 5099   ins_cost(MEMORY_REF_COST);
 5100   size(Z_DISP_SIZE);
 5101   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}
 5102   opcode(STY_ZOPC, ST_ZOPC);
 5103   ins_encode(z_form_rt_mem_opt(src, mem));
 5104   ins_pipe(pipe_class_dummy);
 5105 %}
 5106 
 5107 // Compare Compressed Pointers
 5108 
 5109 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5110   match(Set cr (CmpN src1 src2));
 5111   ins_cost(DEFAULT_COST);
 5112   size(2);
 5113   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}
 5114   opcode(CLR_ZOPC);
 5115   ins_encode(z_rrform(src1, src2));
 5116   ins_pipe(pipe_class_dummy);
 5117 %}
 5118 
 5119 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5120   match(Set cr (CmpN src1 src2));
 5121   ins_cost(DEFAULT_COST);
 5122   size(6);
 5123   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}
 5124   ins_encode %{
 5125     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5126     __ relocate(cOop.rspec(), 1);
 5127     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5128   %}
 5129   ins_pipe(pipe_class_dummy);
 5130 %}
 5131 
 5132 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5133   match(Set cr (CmpN src1 src2));
 5134   ins_cost(DEFAULT_COST);
 5135   size(6);
 5136   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}
 5137   ins_encode %{
 5138     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5139     __ relocate(NKlass.rspec(), 1);
 5140     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5141   %}
 5142   ins_pipe(pipe_class_dummy);
 5143 %}
 5144 
 5145 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5146   match(Set cr (CmpN src1 src2));
 5147   ins_cost(DEFAULT_COST);
 5148   size(2);
 5149   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}
 5150   opcode(LTR_ZOPC);
 5151   ins_encode(z_rrform(src1, src1));
 5152   ins_pipe(pipe_class_dummy);
 5153 %}
 5154 
 5155 
 5156 //----------MemBar Instructions-----------------------------------------------
 5157 
 5158 // Memory barrier flavors
 5159 
 5160 instruct membar_acquire() %{
 5161   match(MemBarAcquire);
 5162   match(LoadFence);
 5163   ins_cost(4*MEMORY_REF_COST);
 5164   size(0);
 5165   format %{ &quot;MEMBAR-acquire&quot; %}
 5166   ins_encode %{ __ z_acquire(); %}
 5167   ins_pipe(pipe_class_dummy);
 5168 %}
 5169 
 5170 instruct membar_acquire_lock() %{
 5171   match(MemBarAcquireLock);
 5172   ins_cost(0);
 5173   size(0);
 5174   format %{ &quot;MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 5175   ins_encode(/*empty*/);
 5176   ins_pipe(pipe_class_dummy);
 5177 %}
 5178 
 5179 instruct membar_release() %{
 5180   match(MemBarRelease);
 5181   match(StoreFence);
 5182   ins_cost(4 * MEMORY_REF_COST);
 5183   size(0);
 5184   format %{ &quot;MEMBAR-release&quot; %}
 5185   ins_encode %{ __ z_release(); %}
 5186   ins_pipe(pipe_class_dummy);
 5187 %}
 5188 
 5189 instruct membar_release_lock() %{
 5190   match(MemBarReleaseLock);
 5191   ins_cost(0);
 5192   size(0);
 5193   format %{ &quot;MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 5194   ins_encode(/*empty*/);
 5195   ins_pipe(pipe_class_dummy);
 5196 %}
 5197 
 5198 instruct membar_volatile() %{
 5199   match(MemBarVolatile);
 5200   ins_cost(4 * MEMORY_REF_COST);
 5201   size(2);
 5202   format %{ &quot;MEMBAR-volatile&quot; %}
 5203   ins_encode %{ __ z_fence(); %}
 5204   ins_pipe(pipe_class_dummy);
 5205 %}
 5206 
 5207 instruct unnecessary_membar_volatile() %{
 5208   match(MemBarVolatile);
 5209   predicate(Matcher::post_store_load_barrier(n));
 5210   ins_cost(0);
 5211   size(0);
 5212   format %{ &quot;# MEMBAR-volatile (empty)&quot; %}
 5213   ins_encode(/*empty*/);
 5214   ins_pipe(pipe_class_dummy);
 5215 %}
 5216 
 5217 instruct membar_CPUOrder() %{
 5218   match(MemBarCPUOrder);
 5219   ins_cost(0);
 5220   // TODO: s390 port size(FIXED_SIZE);
 5221   format %{ &quot;MEMBAR-CPUOrder (empty)&quot; %}
 5222   ins_encode(/*empty*/);
 5223   ins_pipe(pipe_class_dummy);
 5224 %}
 5225 
 5226 instruct membar_storestore() %{
 5227   match(MemBarStoreStore);
 5228   ins_cost(0);
 5229   size(0);
 5230   format %{ &quot;MEMBAR-storestore (empty)&quot; %}
 5231   ins_encode();
 5232   ins_pipe(pipe_class_dummy);
 5233 %}
 5234 
 5235 
 5236 //----------Register Move Instructions-----------------------------------------
 5237 instruct roundDouble_nop(regD dst) %{
 5238   match(Set dst (RoundDouble dst));
 5239   ins_cost(0);
 5240   // TODO: s390 port size(FIXED_SIZE);
 5241   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5242   ins_encode();
 5243   ins_pipe(pipe_class_dummy);
 5244 %}
 5245 
 5246 instruct roundFloat_nop(regF dst) %{
 5247   match(Set dst (RoundFloat dst));
 5248   ins_cost(0);
 5249   // TODO: s390 port size(FIXED_SIZE);
 5250   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5251   ins_encode();
 5252   ins_pipe(pipe_class_dummy);
 5253 %}
 5254 
 5255 // Cast Long to Pointer for unsafe natives.
 5256 instruct castX2P(iRegP dst, iRegL src) %{
 5257   match(Set dst (CastX2P src));
 5258   // TODO: s390 port size(VARIABLE_SIZE);
 5259   format %{ &quot;LGR     $dst,$src\t # CastX2P&quot; %}
 5260   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5261   ins_pipe(pipe_class_dummy);
 5262 %}
 5263 
 5264 // Cast Pointer to Long for unsafe natives.
 5265 instruct castP2X(iRegL dst, iRegP_N2P src) %{
 5266   match(Set dst (CastP2X src));
 5267   // TODO: s390 port size(VARIABLE_SIZE);
 5268   format %{ &quot;LGR     $dst,$src\t # CastP2X&quot; %}
 5269   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5270   ins_pipe(pipe_class_dummy);
 5271 %}
 5272 
 5273 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 5274   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5275   match(Set stkSlot src);   // chain rule
 5276   ins_cost(MEMORY_REF_COST);
 5277   // TODO: s390 port size(FIXED_SIZE);
 5278   format %{ &quot; STD   $src,$stkSlot\t # stk&quot; %}
 5279   opcode(STD_ZOPC);
 5280   ins_encode(z_form_rt_mem(src, stkSlot));
 5281   ins_pipe(pipe_class_dummy);
 5282 %}
 5283 
 5284 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 5285   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5286   match(Set stkSlot src);   // chain rule
 5287   ins_cost(MEMORY_REF_COST);
 5288   // TODO: s390 port size(FIXED_SIZE);
 5289   format %{ &quot;STE   $src,$stkSlot\t # stk&quot; %}
 5290   opcode(STE_ZOPC);
 5291   ins_encode(z_form_rt_mem(src, stkSlot));
 5292   ins_pipe(pipe_class_dummy);
 5293 %}
 5294 
 5295 //----------Conditional Move---------------------------------------------------
 5296 
 5297 instruct cmovN_reg(cmpOp cmp, flagsReg cr, iRegN dst, iRegN_P2N src) %{
 5298   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5299   ins_cost(DEFAULT_COST + BRANCH_COST);
 5300   // TODO: s390 port size(VARIABLE_SIZE);
 5301   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5302   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5303   ins_pipe(pipe_class_dummy);
 5304 %}
 5305 
 5306 instruct cmovN_imm(cmpOp cmp, flagsReg cr, iRegN dst, immN0 src) %{
 5307   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5308   ins_cost(DEFAULT_COST + BRANCH_COST);
 5309   // TODO: s390 port size(VARIABLE_SIZE);
 5310   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5311   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5312   ins_pipe(pipe_class_dummy);
 5313 %}
 5314 
 5315 instruct cmovI_reg(cmpOp cmp, flagsReg cr, iRegI dst, iRegI src) %{
 5316   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5317   ins_cost(DEFAULT_COST + BRANCH_COST);
 5318   // TODO: s390 port size(VARIABLE_SIZE);
 5319   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5320   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5321   ins_pipe(pipe_class_dummy);
 5322 %}
 5323 
 5324 instruct cmovI_imm(cmpOp cmp, flagsReg cr, iRegI dst, immI16 src) %{
 5325   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5326   ins_cost(DEFAULT_COST + BRANCH_COST);
 5327   // TODO: s390 port size(VARIABLE_SIZE);
 5328   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5329   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5330   ins_pipe(pipe_class_dummy);
 5331 %}
 5332 
 5333 instruct cmovP_reg(cmpOp cmp, flagsReg cr, iRegP dst, iRegP_N2P src) %{
 5334   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5335   ins_cost(DEFAULT_COST + BRANCH_COST);
 5336   // TODO: s390 port size(VARIABLE_SIZE);
 5337   format %{ &quot;CMoveP,$cmp    $dst,$src&quot; %}
 5338   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5339   ins_pipe(pipe_class_dummy);
 5340 %}
 5341 
 5342 instruct cmovP_imm(cmpOp cmp, flagsReg cr, iRegP dst, immP0 src) %{
 5343   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5344   ins_cost(DEFAULT_COST + BRANCH_COST);
 5345   // TODO: s390 port size(VARIABLE_SIZE);
 5346   format %{ &quot;CMoveP,$cmp  $dst,$src&quot; %}
 5347   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5348   ins_pipe(pipe_class_dummy);
 5349 %}
 5350 
 5351 instruct cmovF_reg(cmpOpF cmp, flagsReg cr, regF dst, regF src) %{
 5352   match(Set dst (CMoveF (Binary cmp cr) (Binary dst src)));
 5353   ins_cost(DEFAULT_COST + BRANCH_COST);
 5354   // TODO: s390 port size(VARIABLE_SIZE);
 5355   format %{ &quot;CMoveF,$cmp   $dst,$src&quot; %}
 5356   ins_encode %{
 5357     // Don&#39;t emit code if operands are identical (same register).
 5358     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5359       Label done;
 5360       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5361       __ z_ler($dst$$FloatRegister, $src$$FloatRegister);
 5362       __ bind(done);
 5363     }
 5364   %}
 5365   ins_pipe(pipe_class_dummy);
 5366 %}
 5367 
 5368 instruct cmovD_reg(cmpOpF cmp, flagsReg cr, regD dst, regD src) %{
 5369   match(Set dst (CMoveD (Binary cmp cr) (Binary dst src)));
 5370   ins_cost(DEFAULT_COST + BRANCH_COST);
 5371   // TODO: s390 port size(VARIABLE_SIZE);
 5372   format %{ &quot;CMoveD,$cmp   $dst,$src&quot; %}
 5373   ins_encode %{
 5374     // Don&#39;t emit code if operands are identical (same register).
 5375     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5376       Label done;
 5377       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5378       __ z_ldr($dst$$FloatRegister, $src$$FloatRegister);
 5379       __ bind(done);
 5380     }
 5381   %}
 5382   ins_pipe(pipe_class_dummy);
 5383 %}
 5384 
 5385 instruct cmovL_reg(cmpOp cmp, flagsReg cr, iRegL dst, iRegL src) %{
 5386   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5387   ins_cost(DEFAULT_COST + BRANCH_COST);
 5388   // TODO: s390 port size(VARIABLE_SIZE);
 5389   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5390   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5391   ins_pipe(pipe_class_dummy);
 5392 %}
 5393 
 5394 instruct cmovL_imm(cmpOp cmp, flagsReg cr, iRegL dst, immL16 src) %{
 5395   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5396   ins_cost(DEFAULT_COST + BRANCH_COST);
 5397   // TODO: s390 port size(VARIABLE_SIZE);
 5398   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5399   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5400   ins_pipe(pipe_class_dummy);
 5401 %}
 5402 
 5403 //----------OS and Locking Instructions----------------------------------------
 5404 
 5405 // This name is KNOWN by the ADLC and cannot be changed.
 5406 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5407 // for this guy.
 5408 instruct tlsLoadP(threadRegP dst) %{
 5409   match(Set dst (ThreadLocal));
 5410   ins_cost(0);
 5411   size(0);
 5412   ins_should_rematerialize(true);
 5413   format %{ &quot;# $dst=ThreadLocal&quot; %}
 5414   ins_encode(/* empty */);
 5415   ins_pipe(pipe_class_dummy);
 5416 %}
 5417 
 5418 instruct checkCastPP(iRegP dst) %{
 5419   match(Set dst (CheckCastPP dst));
 5420   size(0);
 5421   format %{ &quot;# checkcastPP of $dst&quot; %}
 5422   ins_encode(/*empty*/);
 5423   ins_pipe(pipe_class_dummy);
 5424 %}
 5425 
 5426 instruct castPP(iRegP dst) %{
 5427   match(Set dst (CastPP dst));
 5428   size(0);
 5429   format %{ &quot;# castPP of $dst&quot; %}
 5430   ins_encode(/*empty*/);
 5431   ins_pipe(pipe_class_dummy);
 5432 %}
 5433 
 5434 instruct castII(iRegI dst) %{
 5435   match(Set dst (CastII dst));
 5436   size(0);
 5437   format %{ &quot;# castII of $dst&quot; %}
 5438   ins_encode(/*empty*/);
 5439   ins_pipe(pipe_class_dummy);
 5440 %}
 5441 
 5442 instruct castLL(iRegL dst) %{
 5443   match(Set dst (CastLL dst));
 5444   size(0);
 5445   format %{ &quot;# castLL of $dst&quot; %}
 5446   ins_encode(/*empty*/);
 5447   ins_pipe(pipe_class_dummy);
 5448 %}
 5449 
 5450 
 5451 //----------Conditional_store--------------------------------------------------
 5452 // Conditional-store of the updated heap-top.
 5453 // Used during allocation of the shared heap.
 5454 // Sets flags (EQ) on success.
 5455 
 5456 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5457 // by storePConditional.
 5458 // Don&#39;t know whether this is ever used.
 5459 instruct loadPLocked(iRegP dst, memory mem) %{
 5460   match(Set dst (LoadPLocked mem));
 5461   ins_cost(MEMORY_REF_COST);
 5462   size(Z_DISP3_SIZE);
 5463   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5464   opcode(LG_ZOPC, LG_ZOPC);
 5465   ins_encode(z_form_rt_mem_opt(dst, mem));
 5466   ins_pipe(pipe_class_dummy);
 5467 %}
 5468 
 5469 // As compareAndSwapP, but return flag register instead of boolean value in
 5470 // int register.
 5471 // This instruction is matched if UseTLAB is off. Needed to pass
 5472 // option tests.  Mem_ptr must be a memory operand, else this node
 5473 // does not get Flag_needs_anti_dependence_check set by adlc. If this
 5474 // is not set this node can be rematerialized which leads to errors.
 5475 instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{
 5476   match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));
 5477   effect(KILL oldval);
 5478   // TODO: s390 port size(FIXED_SIZE);
 5479   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5480   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5481   ins_pipe(pipe_class_dummy);
 5482 %}
 5483 
 5484 // As compareAndSwapL, but return flag register instead of boolean value in
 5485 // int register.
 5486 // Used by sun/misc/AtomicLongCSImpl.java. Mem_ptr must be a memory
 5487 // operand, else this node does not get
 5488 // Flag_needs_anti_dependence_check set by adlc. If this is not set
 5489 // this node can be rematerialized which leads to errors.
 5490 instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{
 5491   match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));
 5492   effect(KILL oldval);
 5493   // TODO: s390 port size(FIXED_SIZE);
 5494   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5495   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5496   ins_pipe(pipe_class_dummy);
 5497 %}
 5498 
 5499 // No flag versions for CompareAndSwap{P,I,L,N} because matcher can&#39;t match them.
 5500 
 5501 instruct compareAndSwapI_bool(iRegP mem_ptr, rarg5RegI oldval, iRegI newval, iRegI res, flagsReg cr) %{
 5502   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 5503   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5504   size(16);
 5505   format %{ &quot;$res = CompareAndSwapI $oldval,$newval,$mem_ptr&quot; %}
 5506   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5507              z_enc_cctobool(res));
 5508   ins_pipe(pipe_class_dummy);
 5509 %}
 5510 
 5511 instruct compareAndSwapL_bool(iRegP mem_ptr, rarg5RegL oldval, iRegL newval, iRegI res, flagsReg cr) %{
 5512   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 5513   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5514   size(18);
 5515   format %{ &quot;$res = CompareAndSwapL $oldval,$newval,$mem_ptr&quot; %}
 5516   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5517              z_enc_cctobool(res));
 5518   ins_pipe(pipe_class_dummy);
 5519 %}
 5520 
 5521 instruct compareAndSwapP_bool(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, flagsReg cr) %{
 5522   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 5523   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5524   size(18);
 5525   format %{ &quot;$res = CompareAndSwapP $oldval,$newval,$mem_ptr&quot; %}
 5526   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5527              z_enc_cctobool(res));
 5528   ins_pipe(pipe_class_dummy);
 5529 %}
 5530 
 5531 instruct compareAndSwapN_bool(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, flagsReg cr) %{
 5532   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 5533   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5534   size(16);
 5535   format %{ &quot;$res = CompareAndSwapN $oldval,$newval,$mem_ptr&quot; %}
 5536   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5537              z_enc_cctobool(res));
 5538   ins_pipe(pipe_class_dummy);
 5539 %}
 5540 
 5541 //----------Atomic operations on memory (GetAndSet*, GetAndAdd*)---------------
 5542 
 5543 // Exploit: direct memory arithmetic
 5544 // Prereqs: - instructions available
 5545 //          - instructions guarantee atomicity
 5546 //          - immediate operand to be added
 5547 //          - immediate operand is small enough (8-bit signed).
 5548 //          - result of instruction is not used
 5549 instruct addI_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immI8 src, flagsReg cr) %{
 5550   match(Set dummy (GetAndAddI mem src));
 5551   effect(KILL cr);
 5552   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5553   ins_cost(MEMORY_REF_COST);
 5554   size(6);
 5555   format %{ &quot;ASI     [$mem],$src\t # GetAndAddI (atomic)&quot; %}
 5556   opcode(ASI_ZOPC);
 5557   ins_encode(z_siyform(mem, src));
 5558   ins_pipe(pipe_class_dummy);
 5559 %}
 5560 
 5561 // Fallback: direct memory arithmetic not available
 5562 // Disadvantages: - CS-Loop required, very expensive.
 5563 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5564 instruct addI_mem_imm16_atomic(memoryRSY mem, iRegI dst, immI16 src, iRegI tmp, flagsReg cr) %{
 5565   match(Set dst (GetAndAddI mem src));
 5566   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5567   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5568   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5569             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5570             &quot;  AHIK    $tmp,$dst,$src\n\t&quot;
 5571             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5572             &quot;  retry if failed\n\t&quot;
 5573             &quot;} END ATOMIC&quot;
 5574          %}
 5575   ins_encode %{
 5576     Register Rdst = $dst$$Register;
 5577     Register Rtmp = $tmp$$Register;
 5578     int      Isrc = $src$$constant;
 5579     Label    retry;
 5580 
 5581     // Iterate until update with incremented value succeeds.
 5582     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5583     __ bind(retry);
 5584       // Calculate incremented value.
 5585       if (VM_Version::has_DistinctOpnds()) {
 5586         __ z_ahik(Rtmp, Rdst, Isrc);
 5587       } else {
 5588         __ z_lr(Rtmp, Rdst);
 5589         __ z_ahi(Rtmp, Isrc);
 5590       }
 5591       // Swap into memory location.
 5592       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5593     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5594   %}
 5595   ins_pipe(pipe_class_dummy);
 5596 %}
 5597 
 5598 instruct addI_mem_imm32_atomic(memoryRSY mem, iRegI dst, immI src, iRegI tmp, flagsReg cr) %{
 5599   match(Set dst (GetAndAddI mem src));
 5600   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5601   ins_cost(MEMORY_REF_COST+200*DEFAULT_COST);
 5602   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5603             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5604             &quot;  LGR     $tmp,$dst\n\t&quot;
 5605             &quot;  AFI     $tmp,$src\n\t&quot;
 5606             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5607             &quot;  retry if failed\n\t&quot;
 5608             &quot;} END ATOMIC&quot;
 5609          %}
 5610   ins_encode %{
 5611     Register Rdst = $dst$$Register;
 5612     Register Rtmp = $tmp$$Register;
 5613     int      Isrc = $src$$constant;
 5614     Label    retry;
 5615 
 5616     // Iterate until update with incremented value succeeds.
 5617     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5618     __ bind(retry);
 5619       // Calculate incremented value.
 5620       __ z_lr(Rtmp, Rdst);
 5621       __ z_afi(Rtmp, Isrc);
 5622       // Swap into memory location.
 5623       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5624     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5625   %}
 5626   ins_pipe(pipe_class_dummy);
 5627 %}
 5628 
 5629 instruct addI_mem_reg_atomic(memoryRSY mem, iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
 5630   match(Set dst (GetAndAddI mem src));
 5631   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5632   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5633   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5634             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5635             &quot;  ARK     $tmp,$dst,$src\n\t&quot;
 5636             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5637             &quot;  retry if failed\n\t&quot;
 5638             &quot;} END ATOMIC&quot;
 5639          %}
 5640   ins_encode %{
 5641     Register Rsrc = $src$$Register;
 5642     Register Rdst = $dst$$Register;
 5643     Register Rtmp = $tmp$$Register;
 5644     Label    retry;
 5645 
 5646     // Iterate until update with incremented value succeeds.
 5647     __ z_lgf(Rdst, $mem$$Address);  // current contents
 5648     __ bind(retry);
 5649       // Calculate incremented value.
 5650       if (VM_Version::has_DistinctOpnds()) {
 5651         __ z_ark(Rtmp, Rdst, Rsrc);
 5652       } else {
 5653         __ z_lr(Rtmp, Rdst);
 5654         __ z_ar(Rtmp, Rsrc);
 5655       }
 5656       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5657     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5658   %}
 5659   ins_pipe(pipe_class_dummy);
 5660 %}
 5661 
 5662 
 5663 // Exploit: direct memory arithmetic
 5664 // Prereqs: - instructions available
 5665 //          - instructions guarantee atomicity
 5666 //          - immediate operand to be added
 5667 //          - immediate operand is small enough (8-bit signed).
 5668 //          - result of instruction is not used
 5669 instruct addL_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immL8 src, flagsReg cr) %{
 5670   match(Set dummy (GetAndAddL mem src));
 5671   effect(KILL cr);
 5672   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5673   ins_cost(MEMORY_REF_COST);
 5674   size(6);
 5675   format %{ &quot;AGSI    [$mem],$src\t # GetAndAddL (atomic)&quot; %}
 5676   opcode(AGSI_ZOPC);
 5677   ins_encode(z_siyform(mem, src));
 5678   ins_pipe(pipe_class_dummy);
 5679 %}
 5680 
 5681 // Fallback: direct memory arithmetic not available
 5682 // Disadvantages: - CS-Loop required, very expensive.
 5683 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5684 instruct addL_mem_imm16_atomic(memoryRSY mem, iRegL dst, immL16 src, iRegL tmp, flagsReg cr) %{
 5685   match(Set dst (GetAndAddL mem src));
 5686   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5687   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5688   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5689             &quot;  LG      $dst,[$mem]\n\t&quot;
 5690             &quot;  AGHIK   $tmp,$dst,$src\n\t&quot;
 5691             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5692             &quot;  retry if failed\n\t&quot;
 5693             &quot;} END ATOMIC&quot;
 5694          %}
 5695   ins_encode %{
 5696     Register Rdst = $dst$$Register;
 5697     Register Rtmp = $tmp$$Register;
 5698     int      Isrc = $src$$constant;
 5699     Label    retry;
 5700 
 5701     // Iterate until update with incremented value succeeds.
 5702     __ z_lg(Rdst, $mem$$Address);  // current contents
 5703     __ bind(retry);
 5704       // Calculate incremented value.
 5705       if (VM_Version::has_DistinctOpnds()) {
 5706         __ z_aghik(Rtmp, Rdst, Isrc);
 5707       } else {
 5708         __ z_lgr(Rtmp, Rdst);
 5709         __ z_aghi(Rtmp, Isrc);
 5710       }
 5711       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5712     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5713   %}
 5714   ins_pipe(pipe_class_dummy);
 5715 %}
 5716 
 5717 instruct addL_mem_imm32_atomic(memoryRSY mem, iRegL dst, immL32 src, iRegL tmp, flagsReg cr) %{
 5718   match(Set dst (GetAndAddL mem src));
 5719   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5720   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5721   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5722             &quot;  LG      $dst,[$mem]\n\t&quot;
 5723             &quot;  LGR     $tmp,$dst\n\t&quot;
 5724             &quot;  AGFI    $tmp,$src\n\t&quot;
 5725             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5726             &quot;  retry if failed\n\t&quot;
 5727             &quot;} END ATOMIC&quot;
 5728          %}
 5729   ins_encode %{
 5730     Register Rdst = $dst$$Register;
 5731     Register Rtmp = $tmp$$Register;
 5732     int      Isrc = $src$$constant;
 5733     Label    retry;
 5734 
 5735     // Iterate until update with incremented value succeeds.
 5736     __ z_lg(Rdst, $mem$$Address);  // current contents
 5737     __ bind(retry);
 5738       // Calculate incremented value.
 5739       __ z_lgr(Rtmp, Rdst);
 5740       __ z_agfi(Rtmp, Isrc);
 5741       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5742     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5743   %}
 5744   ins_pipe(pipe_class_dummy);
 5745 %}
 5746 
 5747 instruct addL_mem_reg_atomic(memoryRSY mem, iRegL dst, iRegL src, iRegL tmp, flagsReg cr) %{
 5748   match(Set dst (GetAndAddL mem src));
 5749   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5750   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5751   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5752             &quot;  LG      $dst,[$mem]\n\t&quot;
 5753             &quot;  AGRK    $tmp,$dst,$src\n\t&quot;
 5754             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5755             &quot;  retry if failed\n\t&quot;
 5756             &quot;} END ATOMIC&quot;
 5757          %}
 5758   ins_encode %{
 5759     Register Rsrc = $src$$Register;
 5760     Register Rdst = $dst$$Register;
 5761     Register Rtmp = $tmp$$Register;
 5762     Label    retry;
 5763 
 5764     // Iterate until update with incremented value succeeds.
 5765     __ z_lg(Rdst, $mem$$Address);  // current contents
 5766     __ bind(retry);
 5767       // Calculate incremented value.
 5768       if (VM_Version::has_DistinctOpnds()) {
 5769         __ z_agrk(Rtmp, Rdst, Rsrc);
 5770       } else {
 5771         __ z_lgr(Rtmp, Rdst);
 5772         __ z_agr(Rtmp, Rsrc);
 5773       }
 5774       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5775     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5776   %}
 5777   ins_pipe(pipe_class_dummy);
 5778 %}
 5779 
 5780 // Increment value in memory, save old value in dst.
 5781 instruct addI_mem_reg_atomic_z196(memoryRSY mem, iRegI dst, iRegI src) %{
 5782   match(Set dst (GetAndAddI mem src));
 5783   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5784   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5785   size(6);
 5786   format %{ &quot;LAA     $dst,$src,[$mem]&quot; %}
 5787   ins_encode %{ __ z_laa($dst$$Register, $src$$Register, $mem$$Address); %}
 5788   ins_pipe(pipe_class_dummy);
 5789 %}
 5790 
 5791 // Increment value in memory, save old value in dst.
 5792 instruct addL_mem_reg_atomic_z196(memoryRSY mem, iRegL dst, iRegL src) %{
 5793   match(Set dst (GetAndAddL mem src));
 5794   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5795   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5796   size(6);
 5797   format %{ &quot;LAAG    $dst,$src,[$mem]&quot; %}
 5798   ins_encode %{ __ z_laag($dst$$Register, $src$$Register, $mem$$Address); %}
 5799   ins_pipe(pipe_class_dummy);
 5800 %}
 5801 
 5802 
 5803 instruct xchgI_reg_mem(memoryRSY mem, iRegI dst, iRegI tmp, flagsReg cr) %{
 5804   match(Set dst (GetAndSetI mem dst));
 5805   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5806   format %{ &quot;XCHGI   $dst,[$mem]\t # EXCHANGE (int, atomic), temp $tmp&quot; %}
 5807   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5808   ins_pipe(pipe_class_dummy);
 5809 %}
 5810 
 5811 instruct xchgL_reg_mem(memoryRSY mem, iRegL dst, iRegL tmp, flagsReg cr) %{
 5812   match(Set dst (GetAndSetL mem dst));
 5813   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5814   format %{ &quot;XCHGL   $dst,[$mem]\t # EXCHANGE (long, atomic), temp $tmp&quot; %}
 5815   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5816   ins_pipe(pipe_class_dummy);
 5817 %}
 5818 
 5819 instruct xchgN_reg_mem(memoryRSY mem, iRegN dst, iRegI tmp, flagsReg cr) %{
 5820   match(Set dst (GetAndSetN mem dst));
 5821   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5822   format %{ &quot;XCHGN   $dst,[$mem]\t # EXCHANGE (coop, atomic), temp $tmp&quot; %}
 5823   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5824   ins_pipe(pipe_class_dummy);
 5825 %}
 5826 
 5827 instruct xchgP_reg_mem(memoryRSY mem, iRegP dst, iRegL tmp, flagsReg cr) %{
 5828   match(Set dst (GetAndSetP mem dst));
 5829   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5830   format %{ &quot;XCHGP   $dst,[$mem]\t # EXCHANGE (oop, atomic), temp $tmp&quot; %}
 5831   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5832   ins_pipe(pipe_class_dummy);
 5833 %}
 5834 
 5835 
 5836 //----------Arithmetic Instructions--------------------------------------------
 5837 
 5838 // The rules are sorted by right operand type and operand length. Please keep
 5839 // it that way.
 5840 // Left operand type is always reg. Left operand len is I, L, P
 5841 // Right operand type is reg, imm, mem. Right operand len is S, I, L, P
 5842 // Special instruction formats, e.g. multi-operand, are inserted at the end.
 5843 
 5844 // ADD
 5845 
 5846 // REG = REG + REG
 5847 
 5848 // Register Addition
 5849 instruct addI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 5850   match(Set dst (AddI dst src));
 5851   effect(KILL cr);
 5852   // TODO: s390 port size(FIXED_SIZE);
 5853   format %{ &quot;AR      $dst,$src\t # int  CISC ALU&quot; %}
 5854   opcode(AR_ZOPC);
 5855   ins_encode(z_rrform(dst, src));
 5856   ins_pipe(pipe_class_dummy);
 5857 %}
 5858 
 5859 // Avoid use of LA(Y) for general ALU operation.
 5860 instruct addI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 5861   match(Set dst (AddI src1 src2));
 5862   effect(KILL cr);
 5863   predicate(VM_Version::has_DistinctOpnds());
 5864   ins_cost(DEFAULT_COST);
 5865   size(4);
 5866   format %{ &quot;ARK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 5867   opcode(ARK_ZOPC);
 5868   ins_encode(z_rrfform(dst, src1, src2));
 5869   ins_pipe(pipe_class_dummy);
 5870 %}
 5871 
 5872 // REG = REG + IMM
 5873 
 5874 // Avoid use of LA(Y) for general ALU operation.
 5875 // Immediate Addition
 5876 instruct addI_reg_imm16_CISC(iRegI dst, immI16 con, flagsReg cr) %{
 5877   match(Set dst (AddI dst con));
 5878   effect(KILL cr);
 5879   ins_cost(DEFAULT_COST);
 5880   // TODO: s390 port size(FIXED_SIZE);
 5881   format %{ &quot;AHI     $dst,$con\t # int  CISC ALU&quot; %}
 5882   opcode(AHI_ZOPC);
 5883   ins_encode(z_riform_signed(dst, con));
 5884   ins_pipe(pipe_class_dummy);
 5885 %}
 5886 
 5887 // Avoid use of LA(Y) for general ALU operation.
 5888 // Immediate Addition
 5889 instruct addI_reg_imm16_RISC(iRegI dst, iRegI src, immI16 con, flagsReg cr) %{
 5890   match(Set dst (AddI src con));
 5891   effect(KILL cr);
 5892   predicate( VM_Version::has_DistinctOpnds());
 5893   ins_cost(DEFAULT_COST);
 5894   // TODO: s390 port size(FIXED_SIZE);
 5895   format %{ &quot;AHIK    $dst,$src,$con\t # int  RISC ALU&quot; %}
 5896   opcode(AHIK_ZOPC);
 5897   ins_encode(z_rieform_d(dst, src, con));
 5898   ins_pipe(pipe_class_dummy);
 5899 %}
 5900 
 5901 // Immediate Addition
 5902 instruct addI_reg_imm32(iRegI dst, immI src, flagsReg cr) %{
 5903   match(Set dst (AddI dst src));
 5904   effect(KILL cr);
 5905   ins_cost(DEFAULT_COST_HIGH);
 5906   size(6);
 5907   format %{ &quot;AFI     $dst,$src&quot; %}
 5908   opcode(AFI_ZOPC);
 5909   ins_encode(z_rilform_signed(dst, src));
 5910   ins_pipe(pipe_class_dummy);
 5911 %}
 5912 
 5913 // Immediate Addition
 5914 instruct addI_reg_imm12(iRegI dst, iRegI src, uimmI12 con) %{
 5915   match(Set dst (AddI src con));
 5916   predicate(PreferLAoverADD);
 5917   ins_cost(DEFAULT_COST_LOW);
 5918   size(4);
 5919   format %{ &quot;LA      $dst,$con(,$src)\t # int d12(,b)&quot; %}
 5920   opcode(LA_ZOPC);
 5921   ins_encode(z_rxform_imm_reg(dst, con, src));
 5922   ins_pipe(pipe_class_dummy);
 5923 %}
 5924 
 5925 // Immediate Addition
 5926 instruct addI_reg_imm20(iRegI dst, iRegI src, immI20 con) %{
 5927   match(Set dst (AddI src con));
 5928   predicate(PreferLAoverADD);
 5929   ins_cost(DEFAULT_COST);
 5930   size(6);
 5931   format %{ &quot;LAY     $dst,$con(,$src)\t # int d20(,b)&quot; %}
 5932   opcode(LAY_ZOPC);
 5933   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5934   ins_pipe(pipe_class_dummy);
 5935 %}
 5936 
 5937 instruct addI_reg_reg_imm12(iRegI dst, iRegI src1, iRegI src2, uimmI12 con) %{
 5938   match(Set dst (AddI (AddI src1 src2) con));
 5939   predicate( PreferLAoverADD);
 5940   ins_cost(DEFAULT_COST_LOW);
 5941   size(4);
 5942   format %{ &quot;LA      $dst,$con($src1,$src2)\t # int d12(x,b)&quot; %}
 5943   opcode(LA_ZOPC);
 5944   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 5945   ins_pipe(pipe_class_dummy);
 5946 %}
 5947 
 5948 instruct addI_reg_reg_imm20(iRegI dst, iRegI src1, iRegI src2, immI20 con) %{
 5949   match(Set dst (AddI (AddI src1 src2) con));
 5950   predicate(PreferLAoverADD);
 5951   ins_cost(DEFAULT_COST);
 5952   size(6);
 5953   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # int d20(x,b)&quot; %}
 5954   opcode(LAY_ZOPC);
 5955   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 5956   ins_pipe(pipe_class_dummy);
 5957 %}
 5958 
 5959 // REG = REG + MEM
 5960 
 5961 instruct addI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 5962   match(Set dst (AddI dst (LoadI src)));
 5963   effect(KILL cr);
 5964   ins_cost(MEMORY_REF_COST);
 5965   // TODO: s390 port size(VARIABLE_SIZE);
 5966   format %{ &quot;A(Y)    $dst, $src\t # int&quot; %}
 5967   opcode(AY_ZOPC, A_ZOPC);
 5968   ins_encode(z_form_rt_mem_opt(dst, src));
 5969   ins_pipe(pipe_class_dummy);
 5970 %}
 5971 
 5972 // MEM = MEM + IMM
 5973 
 5974 // Add Immediate to 4-byte memory operand and result
 5975 instruct addI_mem_imm(memoryRSY mem, immI8 src, flagsReg cr) %{
 5976   match(Set mem (StoreI mem (AddI (LoadI mem) src)));
 5977   effect(KILL cr);
 5978   predicate(VM_Version::has_MemWithImmALUOps());
 5979   ins_cost(MEMORY_REF_COST);
 5980   size(6);
 5981   format %{ &quot;ASI     $mem,$src\t # direct mem add 4&quot; %}
 5982   opcode(ASI_ZOPC);
 5983   ins_encode(z_siyform(mem, src));
 5984   ins_pipe(pipe_class_dummy);
 5985 %}
 5986 
 5987 
 5988 //
 5989 
 5990 // REG = REG + REG
 5991 
 5992 instruct addL_reg_regI(iRegL dst, iRegI src, flagsReg cr) %{
 5993   match(Set dst (AddL dst (ConvI2L src)));
 5994   effect(KILL cr);
 5995   size(4);
 5996   format %{ &quot;AGFR    $dst,$src\t # long&lt;-int CISC ALU&quot; %}
 5997   opcode(AGFR_ZOPC);
 5998   ins_encode(z_rreform(dst, src));
 5999   ins_pipe(pipe_class_dummy);
 6000 %}
 6001 
 6002 instruct addL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6003   match(Set dst (AddL dst src));
 6004   effect(KILL cr);
 6005   // TODO: s390 port size(FIXED_SIZE);
 6006   format %{ &quot;AGR     $dst, $src\t # long CISC ALU&quot; %}
 6007   opcode(AGR_ZOPC);
 6008   ins_encode(z_rreform(dst, src));
 6009   ins_pipe(pipe_class_dummy);
 6010 %}
 6011 
 6012 // Avoid use of LA(Y) for general ALU operation.
 6013 instruct addL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6014   match(Set dst (AddL src1 src2));
 6015   effect(KILL cr);
 6016   predicate(VM_Version::has_DistinctOpnds());
 6017   ins_cost(DEFAULT_COST);
 6018   size(4);
 6019   format %{ &quot;AGRK    $dst,$src1,$src2\t # long RISC ALU&quot; %}
 6020   opcode(AGRK_ZOPC);
 6021   ins_encode(z_rrfform(dst, src1, src2));
 6022   ins_pipe(pipe_class_dummy);
 6023 %}
 6024 
 6025 // REG = REG + IMM
 6026 
 6027 instruct addL_reg_imm12(iRegL dst, iRegL src, uimmL12 con) %{
 6028   match(Set dst (AddL src con));
 6029   predicate( PreferLAoverADD);
 6030   ins_cost(DEFAULT_COST_LOW);
 6031   size(4);
 6032   format %{ &quot;LA      $dst,$con(,$src)\t # long d12(,b)&quot; %}
 6033   opcode(LA_ZOPC);
 6034   ins_encode(z_rxform_imm_reg(dst, con, src));
 6035   ins_pipe(pipe_class_dummy);
 6036 %}
 6037 
 6038 instruct addL_reg_imm20(iRegL dst, iRegL src, immL20 con) %{
 6039   match(Set dst (AddL src con));
 6040   predicate(PreferLAoverADD);
 6041   ins_cost(DEFAULT_COST);
 6042   size(6);
 6043   format %{ &quot;LAY     $dst,$con(,$src)\t # long d20(,b)&quot; %}
 6044   opcode(LAY_ZOPC);
 6045   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6046   ins_pipe(pipe_class_dummy);
 6047 %}
 6048 
 6049 instruct addL_reg_imm32(iRegL dst, immL32 con, flagsReg cr) %{
 6050   match(Set dst (AddL dst con));
 6051   effect(KILL cr);
 6052   ins_cost(DEFAULT_COST_HIGH);
 6053   size(6);
 6054   format %{ &quot;AGFI    $dst,$con\t # long CISC ALU&quot; %}
 6055   opcode(AGFI_ZOPC);
 6056   ins_encode(z_rilform_signed(dst, con));
 6057   ins_pipe(pipe_class_dummy);
 6058 %}
 6059 
 6060 // Avoid use of LA(Y) for general ALU operation.
 6061 instruct addL_reg_imm16_CISC(iRegL dst, immL16 con, flagsReg cr) %{
 6062   match(Set dst (AddL dst con));
 6063   effect(KILL cr);
 6064   ins_cost(DEFAULT_COST);
 6065   // TODO: s390 port size(FIXED_SIZE);
 6066   format %{ &quot;AGHI    $dst,$con\t # long CISC ALU&quot; %}
 6067   opcode(AGHI_ZOPC);
 6068   ins_encode(z_riform_signed(dst, con));
 6069   ins_pipe(pipe_class_dummy);
 6070 %}
 6071 
 6072 // Avoid use of LA(Y) for general ALU operation.
 6073 instruct addL_reg_imm16_RISC(iRegL dst, iRegL src, immL16 con, flagsReg cr) %{
 6074   match(Set dst (AddL src con));
 6075   effect(KILL cr);
 6076   predicate( VM_Version::has_DistinctOpnds());
 6077   ins_cost(DEFAULT_COST);
 6078   size(6);
 6079   format %{ &quot;AGHIK   $dst,$src,$con\t # long RISC ALU&quot; %}
 6080   opcode(AGHIK_ZOPC);
 6081   ins_encode(z_rieform_d(dst, src, con));
 6082   ins_pipe(pipe_class_dummy);
 6083 %}
 6084 
 6085 // REG = REG + MEM
 6086 
 6087 instruct addL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6088   match(Set dst (AddL dst (ConvI2L (LoadI src))));
 6089   effect(KILL cr);
 6090   ins_cost(MEMORY_REF_COST);
 6091   size(Z_DISP3_SIZE);
 6092   format %{ &quot;AGF     $dst, $src\t # long/int&quot; %}
 6093   opcode(AGF_ZOPC, AGF_ZOPC);
 6094   ins_encode(z_form_rt_mem_opt(dst, src));
 6095   ins_pipe(pipe_class_dummy);
 6096 %}
 6097 
 6098 instruct addL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6099   match(Set dst (AddL dst (LoadL src)));
 6100   effect(KILL cr);
 6101   ins_cost(MEMORY_REF_COST);
 6102   size(Z_DISP3_SIZE);
 6103   format %{ &quot;AG      $dst, $src\t # long&quot; %}
 6104   opcode(AG_ZOPC, AG_ZOPC);
 6105   ins_encode(z_form_rt_mem_opt(dst, src));
 6106   ins_pipe(pipe_class_dummy);
 6107 %}
 6108 
 6109 instruct addL_reg_reg_imm12(iRegL dst, iRegL src1, iRegL src2, uimmL12 con) %{
 6110   match(Set dst (AddL (AddL src1 src2) con));
 6111   predicate( PreferLAoverADD);
 6112   ins_cost(DEFAULT_COST_LOW);
 6113   size(4);
 6114   format %{ &quot;LA     $dst,$con($src1,$src2)\t # long d12(x,b)&quot; %}
 6115   opcode(LA_ZOPC);
 6116   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6117   ins_pipe(pipe_class_dummy);
 6118 %}
 6119 
 6120 instruct addL_reg_reg_imm20(iRegL dst, iRegL src1, iRegL src2, immL20 con) %{
 6121   match(Set dst (AddL (AddL src1 src2) con));
 6122   predicate(PreferLAoverADD);
 6123   ins_cost(DEFAULT_COST);
 6124   size(6);
 6125   format %{ &quot;LAY    $dst,$con($src1,$src2)\t # long d20(x,b)&quot; %}
 6126   opcode(LAY_ZOPC);
 6127   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6128   ins_pipe(pipe_class_dummy);
 6129 %}
 6130 
 6131 // MEM = MEM + IMM
 6132 
 6133 // Add Immediate to 8-byte memory operand and result.
 6134 instruct addL_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6135   match(Set mem (StoreL mem (AddL (LoadL mem) src)));
 6136   effect(KILL cr);
 6137   predicate(VM_Version::has_MemWithImmALUOps());
 6138   ins_cost(MEMORY_REF_COST);
 6139   size(6);
 6140   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8&quot; %}
 6141   opcode(AGSI_ZOPC);
 6142   ins_encode(z_siyform(mem, src));
 6143   ins_pipe(pipe_class_dummy);
 6144 %}
 6145 
 6146 
 6147 // REG = REG + REG
 6148 
 6149 // Ptr Addition
 6150 instruct addP_reg_reg_LA(iRegP dst, iRegP_N2P src1, iRegL src2) %{
 6151   match(Set dst (AddP src1 src2));
 6152   predicate( PreferLAoverADD);
 6153   ins_cost(DEFAULT_COST);
 6154   size(4);
 6155   format %{ &quot;LA      $dst,#0($src1,$src2)\t # ptr 0(x,b)&quot; %}
 6156   opcode(LA_ZOPC);
 6157   ins_encode(z_rxform_imm_reg_reg(dst, 0x0, src1, src2));
 6158   ins_pipe(pipe_class_dummy);
 6159 %}
 6160 
 6161 // Ptr Addition
 6162 // Avoid use of LA(Y) for general ALU operation.
 6163 instruct addP_reg_reg_CISC(iRegP dst, iRegL src, flagsReg cr) %{
 6164   match(Set dst (AddP dst src));
 6165   effect(KILL cr);
 6166   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6167   ins_cost(DEFAULT_COST);
 6168   // TODO: s390 port size(FIXED_SIZE);
 6169   format %{ &quot;ALGR    $dst,$src\t # ptr CICS ALU&quot; %}
 6170   opcode(ALGR_ZOPC);
 6171   ins_encode(z_rreform(dst, src));
 6172   ins_pipe(pipe_class_dummy);
 6173 %}
 6174 
 6175 // Ptr Addition
 6176 // Avoid use of LA(Y) for general ALU operation.
 6177 instruct addP_reg_reg_RISC(iRegP dst, iRegP_N2P src1, iRegL src2, flagsReg cr) %{
 6178   match(Set dst (AddP src1 src2));
 6179   effect(KILL cr);
 6180   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6181   ins_cost(DEFAULT_COST);
 6182   // TODO: s390 port size(FIXED_SIZE);
 6183   format %{ &quot;ALGRK   $dst,$src1,$src2\t # ptr RISC ALU&quot; %}
 6184   opcode(ALGRK_ZOPC);
 6185   ins_encode(z_rrfform(dst, src1, src2));
 6186   ins_pipe(pipe_class_dummy);
 6187 %}
 6188 
 6189 // REG = REG + IMM
 6190 
 6191 instruct addP_reg_imm12(iRegP dst, iRegP_N2P src, uimmL12 con) %{
 6192   match(Set dst (AddP src con));
 6193   predicate( PreferLAoverADD);
 6194   ins_cost(DEFAULT_COST_LOW);
 6195   size(4);
 6196   format %{ &quot;LA      $dst,$con(,$src)\t # ptr d12(,b)&quot; %}
 6197   opcode(LA_ZOPC);
 6198   ins_encode(z_rxform_imm_reg(dst, con, src));
 6199   ins_pipe(pipe_class_dummy);
 6200 %}
 6201 
 6202 // Avoid use of LA(Y) for general ALU operation.
 6203 instruct addP_reg_imm16_CISC(iRegP dst, immL16 src, flagsReg cr) %{
 6204   match(Set dst (AddP dst src));
 6205   effect(KILL cr);
 6206   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6207   ins_cost(DEFAULT_COST);
 6208   // TODO: s390 port size(FIXED_SIZE);
 6209   format %{ &quot;AGHI    $dst,$src\t # ptr CISC ALU&quot; %}
 6210   opcode(AGHI_ZOPC);
 6211   ins_encode(z_riform_signed(dst, src));
 6212   ins_pipe(pipe_class_dummy);
 6213 %}
 6214 
 6215 // Avoid use of LA(Y) for general ALU operation.
 6216 instruct addP_reg_imm16_RISC(iRegP dst, iRegP_N2P src, immL16 con, flagsReg cr) %{
 6217   match(Set dst (AddP src con));
 6218   effect(KILL cr);
 6219   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6220   ins_cost(DEFAULT_COST);
 6221   // TODO: s390 port size(FIXED_SIZE);
 6222   format %{ &quot;ALGHSIK $dst,$src,$con\t # ptr RISC ALU&quot; %}
 6223   opcode(ALGHSIK_ZOPC);
 6224   ins_encode(z_rieform_d(dst, src, con));
 6225   ins_pipe(pipe_class_dummy);
 6226 %}
 6227 
 6228 instruct addP_reg_imm20(iRegP dst, memoryRegP src, immL20 con) %{
 6229   match(Set dst (AddP src con));
 6230   predicate(PreferLAoverADD);
 6231   ins_cost(DEFAULT_COST);
 6232   size(6);
 6233   format %{ &quot;LAY     $dst,$con(,$src)\t # ptr d20(,b)&quot; %}
 6234   opcode(LAY_ZOPC);
 6235   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6236   ins_pipe(pipe_class_dummy);
 6237 %}
 6238 
 6239 // Pointer Immediate Addition
 6240 instruct addP_reg_imm32(iRegP dst, immL32 src, flagsReg cr) %{
 6241   match(Set dst (AddP dst src));
 6242   effect(KILL cr);
 6243   ins_cost(DEFAULT_COST_HIGH);
 6244   // TODO: s390 port size(FIXED_SIZE);
 6245   format %{ &quot;AGFI    $dst,$src\t # ptr&quot; %}
 6246   opcode(AGFI_ZOPC);
 6247   ins_encode(z_rilform_signed(dst, src));
 6248   ins_pipe(pipe_class_dummy);
 6249 %}
 6250 
 6251 // REG = REG1 + REG2 + IMM
 6252 
 6253 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6254   match(Set dst (AddP (AddP src1 src2) con));
 6255   predicate( PreferLAoverADD);
 6256   ins_cost(DEFAULT_COST_LOW);
 6257   size(4);
 6258   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6259   opcode(LA_ZOPC);
 6260   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6261   ins_pipe(pipe_class_dummy);
 6262 %}
 6263 
 6264 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6265   match(Set dst (AddP (AddP src1 src2) con));
 6266   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6267   ins_cost(DEFAULT_COST_LOW);
 6268   size(4);
 6269   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6270   opcode(LA_ZOPC);
 6271   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6272   ins_pipe(pipe_class_dummy);
 6273 %}
 6274 
 6275 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6276   match(Set dst (AddP (AddP src1 src2) con));
 6277   predicate(PreferLAoverADD);
 6278   ins_cost(DEFAULT_COST);
 6279   // TODO: s390 port size(FIXED_SIZE);
 6280   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6281   opcode(LAY_ZOPC);
 6282   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6283   ins_pipe(pipe_class_dummy);
 6284 %}
 6285 
 6286 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6287   match(Set dst (AddP (AddP src1 src2) con));
 6288   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6289   ins_cost(DEFAULT_COST);
 6290   // TODO: s390 port size(FIXED_SIZE);
 6291   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6292   opcode(LAY_ZOPC);
 6293   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6294   ins_pipe(pipe_class_dummy);
 6295 %}
 6296 
 6297 // MEM = MEM + IMM
 6298 
 6299 // Add Immediate to 8-byte memory operand and result
 6300 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6301   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6302   effect(KILL cr);
 6303   predicate(VM_Version::has_MemWithImmALUOps());
 6304   ins_cost(MEMORY_REF_COST);
 6305   size(6);
 6306   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6307   opcode(AGSI_ZOPC);
 6308   ins_encode(z_siyform(mem, src));
 6309   ins_pipe(pipe_class_dummy);
 6310 %}
 6311 
 6312 // SUB
 6313 
 6314 // Register Subtraction
 6315 instruct subI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 6316   match(Set dst (SubI dst src));
 6317   effect(KILL cr);
 6318   // TODO: s390 port size(FIXED_SIZE);
 6319   format %{ &quot;SR      $dst,$src\t # int  CISC ALU&quot; %}
 6320   opcode(SR_ZOPC);
 6321   ins_encode(z_rrform(dst, src));
 6322   ins_pipe(pipe_class_dummy);
 6323 %}
 6324 
 6325 instruct subI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 6326   match(Set dst (SubI src1 src2));
 6327   effect(KILL cr);
 6328   predicate(VM_Version::has_DistinctOpnds());
 6329   ins_cost(DEFAULT_COST);
 6330   size(4);
 6331   format %{ &quot;SRK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6332   opcode(SRK_ZOPC);
 6333   ins_encode(z_rrfform(dst, src1, src2));
 6334   ins_pipe(pipe_class_dummy);
 6335 %}
 6336 
 6337 instruct subI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 6338   match(Set dst (SubI dst (LoadI src)));
 6339   effect(KILL cr);
 6340   ins_cost(MEMORY_REF_COST);
 6341   // TODO: s390 port size(VARIABLE_SIZE);
 6342   format %{ &quot;S(Y)    $dst, $src\t # int&quot; %}
 6343   opcode(SY_ZOPC, S_ZOPC);
 6344   ins_encode(z_form_rt_mem_opt(dst, src));
 6345   ins_pipe(pipe_class_dummy);
 6346 %}
 6347 
 6348 instruct subI_zero_reg(iRegI dst, immI_0 zero, iRegI src, flagsReg cr) %{
 6349   match(Set dst (SubI zero src));
 6350   effect(KILL cr);
 6351   size(2);
 6352   format %{ &quot;NEG     $dst, $src&quot; %}
 6353   ins_encode %{ __ z_lcr($dst$$Register, $src$$Register); %}
 6354   ins_pipe(pipe_class_dummy);
 6355 %}
 6356 
 6357 //
 6358 
 6359 // Long subtraction
 6360 instruct subL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6361   match(Set dst (SubL dst src));
 6362   effect(KILL cr);
 6363   // TODO: s390 port size(FIXED_SIZE);
 6364   format %{ &quot;SGR     $dst,$src\t # int  CISC ALU&quot; %}
 6365   opcode(SGR_ZOPC);
 6366   ins_encode(z_rreform(dst, src));
 6367   ins_pipe(pipe_class_dummy);
 6368 %}
 6369 
 6370 // Avoid use of LA(Y) for general ALU operation.
 6371 instruct subL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6372   match(Set dst (SubL src1 src2));
 6373   effect(KILL cr);
 6374   predicate(VM_Version::has_DistinctOpnds());
 6375   ins_cost(DEFAULT_COST);
 6376   size(4);
 6377   format %{ &quot;SGRK    $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6378   opcode(SGRK_ZOPC);
 6379   ins_encode(z_rrfform(dst, src1, src2));
 6380   ins_pipe(pipe_class_dummy);
 6381 %}
 6382 
 6383 instruct subL_reg_regI_CISC(iRegL dst, iRegI src, flagsReg cr) %{
 6384   match(Set dst (SubL dst (ConvI2L src)));
 6385   effect(KILL cr);
 6386   size(4);
 6387   format %{ &quot;SGFR    $dst, $src\t # int  CISC ALU&quot; %}
 6388   opcode(SGFR_ZOPC);
 6389   ins_encode(z_rreform(dst, src));
 6390   ins_pipe(pipe_class_dummy);
 6391 %}
 6392 
 6393 instruct subL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6394   match(Set dst (SubL dst (ConvI2L (LoadI src))));
 6395   effect(KILL cr);
 6396   ins_cost(MEMORY_REF_COST);
 6397   size(Z_DISP3_SIZE);
 6398   format %{ &quot;SGF     $dst, $src\t # long/int&quot; %}
 6399   opcode(SGF_ZOPC, SGF_ZOPC);
 6400   ins_encode(z_form_rt_mem_opt(dst, src));
 6401   ins_pipe(pipe_class_dummy);
 6402 %}
 6403 
 6404 instruct subL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6405   match(Set dst (SubL dst (LoadL src)));
 6406   effect(KILL cr);
 6407   ins_cost(MEMORY_REF_COST);
 6408   size(Z_DISP3_SIZE);
 6409   format %{ &quot;SG      $dst, $src\t # long&quot; %}
 6410   opcode(SG_ZOPC, SG_ZOPC);
 6411   ins_encode(z_form_rt_mem_opt(dst, src));
 6412   ins_pipe(pipe_class_dummy);
 6413 %}
 6414 
 6415 // Moved declaration of negL_reg_reg before encode nodes, where it is used.
 6416 
 6417 //  MUL
 6418 
 6419 // Register Multiplication
 6420 instruct mulI_reg_reg(iRegI dst, iRegI src) %{
 6421   match(Set dst (MulI dst src));
 6422   ins_cost(DEFAULT_COST);
 6423   size(4);
 6424   format %{ &quot;MSR     $dst, $src&quot; %}
 6425   opcode(MSR_ZOPC);
 6426   ins_encode(z_rreform(dst, src));
 6427   ins_pipe(pipe_class_dummy);
 6428 %}
 6429 
 6430 // Immediate Multiplication
 6431 instruct mulI_reg_imm16(iRegI dst, immI16 con) %{
 6432   match(Set dst (MulI dst con));
 6433   ins_cost(DEFAULT_COST);
 6434   // TODO: s390 port size(FIXED_SIZE);
 6435   format %{ &quot;MHI     $dst,$con&quot; %}
 6436   opcode(MHI_ZOPC);
 6437   ins_encode(z_riform_signed(dst,con));
 6438   ins_pipe(pipe_class_dummy);
 6439 %}
 6440 
 6441 // Immediate (32bit) Multiplication
 6442 instruct mulI_reg_imm32(iRegI dst, immI con) %{
 6443   match(Set dst (MulI dst con));
 6444   ins_cost(DEFAULT_COST);
 6445   size(6);
 6446   format %{ &quot;MSFI    $dst,$con&quot; %}
 6447   opcode(MSFI_ZOPC);
 6448   ins_encode(z_rilform_signed(dst,con));
 6449   ins_pipe(pipe_class_dummy);
 6450 %}
 6451 
 6452 instruct mulI_Reg_mem(iRegI dst, memory src)%{
 6453   match(Set dst (MulI dst (LoadI src)));
 6454   ins_cost(MEMORY_REF_COST);
 6455   // TODO: s390 port size(VARIABLE_SIZE);
 6456   format %{ &quot;MS(Y)   $dst, $src\t # int&quot; %}
 6457   opcode(MSY_ZOPC, MS_ZOPC);
 6458   ins_encode(z_form_rt_mem_opt(dst, src));
 6459   ins_pipe(pipe_class_dummy);
 6460 %}
 6461 
 6462 //
 6463 
 6464 instruct mulL_reg_regI(iRegL dst, iRegI src) %{
 6465   match(Set dst (MulL dst (ConvI2L src)));
 6466   ins_cost(DEFAULT_COST);
 6467   // TODO: s390 port size(FIXED_SIZE);
 6468   format %{ &quot;MSGFR   $dst $src\t # long/int&quot; %}
 6469   opcode(MSGFR_ZOPC);
 6470   ins_encode(z_rreform(dst, src));
 6471   ins_pipe(pipe_class_dummy);
 6472 %}
 6473 
 6474 instruct mulL_reg_reg(iRegL dst, iRegL src) %{
 6475   match(Set dst (MulL dst src));
 6476   ins_cost(DEFAULT_COST);
 6477   size(4);
 6478   format %{ &quot;MSGR    $dst $src\t # long&quot; %}
 6479   opcode(MSGR_ZOPC);
 6480   ins_encode(z_rreform(dst, src));
 6481   ins_pipe(pipe_class_dummy);
 6482 %}
 6483 
 6484 // Immediate Multiplication
 6485 instruct mulL_reg_imm16(iRegL dst, immL16 src) %{
 6486   match(Set dst (MulL dst src));
 6487   ins_cost(DEFAULT_COST);
 6488   // TODO: s390 port size(FIXED_SIZE);
 6489   format %{ &quot;MGHI    $dst,$src\t # long&quot; %}
 6490   opcode(MGHI_ZOPC);
 6491   ins_encode(z_riform_signed(dst, src));
 6492   ins_pipe(pipe_class_dummy);
 6493 %}
 6494 
 6495 // Immediate (32bit) Multiplication
 6496 instruct mulL_reg_imm32(iRegL dst, immL32 con) %{
 6497   match(Set dst (MulL dst con));
 6498   ins_cost(DEFAULT_COST);
 6499   size(6);
 6500   format %{ &quot;MSGFI   $dst,$con&quot; %}
 6501   opcode(MSGFI_ZOPC);
 6502   ins_encode(z_rilform_signed(dst,con));
 6503   ins_pipe(pipe_class_dummy);
 6504 %}
 6505 
 6506 instruct mulL_Reg_memI(iRegL dst, memory src)%{
 6507   match(Set dst (MulL dst (ConvI2L (LoadI src))));
 6508   ins_cost(MEMORY_REF_COST);
 6509   size(Z_DISP3_SIZE);
 6510   format %{ &quot;MSGF    $dst, $src\t # long&quot; %}
 6511   opcode(MSGF_ZOPC, MSGF_ZOPC);
 6512   ins_encode(z_form_rt_mem_opt(dst, src));
 6513   ins_pipe(pipe_class_dummy);
 6514 %}
 6515 
 6516 instruct mulL_Reg_mem(iRegL dst, memory src)%{
 6517   match(Set dst (MulL dst (LoadL src)));
 6518   ins_cost(MEMORY_REF_COST);
 6519   size(Z_DISP3_SIZE);
 6520   format %{ &quot;MSG     $dst, $src\t # long&quot; %}
 6521   opcode(MSG_ZOPC, MSG_ZOPC);
 6522   ins_encode(z_form_rt_mem_opt(dst, src));
 6523   ins_pipe(pipe_class_dummy);
 6524 %}
 6525 
 6526 instruct mulHiL_reg_reg(revenRegL Rdst, roddRegL Rsrc1, iRegL Rsrc2, iRegL Rtmp1, flagsReg cr)%{
 6527   match(Set Rdst (MulHiL Rsrc1 Rsrc2));
 6528   effect(TEMP_DEF Rdst, USE_KILL Rsrc1, TEMP Rtmp1, KILL cr);
 6529   ins_cost(7*DEFAULT_COST);
 6530   // TODO: s390 port size(VARIABLE_SIZE);
 6531   format %{ &quot;MulHiL  $Rdst, $Rsrc1, $Rsrc2\t # Multiply High Long&quot; %}
 6532   ins_encode%{
 6533     Register dst  = $Rdst$$Register;
 6534     Register src1 = $Rsrc1$$Register;
 6535     Register src2 = $Rsrc2$$Register;
 6536     Register tmp1 = $Rtmp1$$Register;
 6537     Register tmp2 = $Rdst$$Register;
 6538     // z/Architecture has only unsigned multiply (64 * 64 -&gt; 128).
 6539     // implementing mulhs(a,b) = mulhu(a,b)  (a &amp; (b&gt;&gt;63))  (b &amp; (a&gt;&gt;63))
 6540     __ z_srag(tmp2, src1, 63);  // a&gt;&gt;63
 6541     __ z_srag(tmp1, src2, 63);  // b&gt;&gt;63
 6542     __ z_ngr(tmp2, src2);       // b &amp; (a&gt;&gt;63)
 6543     __ z_ngr(tmp1, src1);       // a &amp; (b&gt;&gt;63)
 6544     __ z_agr(tmp1, tmp2);       // ((a &amp; (b&gt;&gt;63)) + (b &amp; (a&gt;&gt;63)))
 6545     __ z_mlgr(dst, src2);       // tricky: 128-bit product is written to even/odd pair (dst,src1),
 6546                                 //         multiplicand is taken from oddReg (src1), multiplier in src2.
 6547     __ z_sgr(dst, tmp1);
 6548   %}
 6549   ins_pipe(pipe_class_dummy);
 6550 %}
 6551 
 6552 //  DIV
 6553 
 6554 // Integer DIVMOD with Register, both quotient and mod results
 6555 instruct divModI_reg_divmod(roddRegI dst1src1, revenRegI dst2, noOdd_iRegI src2, flagsReg cr) %{
 6556   match(DivModI dst1src1 src2);
 6557   effect(KILL cr);
 6558   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6559   size((VM_Version::has_CompareBranch() ? 24 : 26));
 6560   format %{ &quot;DIVMODI ($dst1src1, $dst2) $src2&quot; %}
 6561   ins_encode %{
 6562     Register d1s1 = $dst1src1$$Register;
 6563     Register d2   = $dst2$$Register;
 6564     Register s2   = $src2$$Register;
 6565 
 6566     assert_different_registers(d1s1, s2);
 6567 
 6568     Label do_div, done_div;
 6569     if (VM_Version::has_CompareBranch()) {
 6570       __ z_cij(s2, -1, Assembler::bcondNotEqual, do_div);
 6571     } else {
 6572       __ z_chi(s2, -1);
 6573       __ z_brne(do_div);
 6574     }
 6575     __ z_lcr(d1s1, d1s1);
 6576     __ clear_reg(d2, false, false);
 6577     __ z_bru(done_div);
 6578     __ bind(do_div);
 6579     __ z_lgfr(d1s1, d1s1);
 6580     __ z_dsgfr(d2, s2);
 6581     __ bind(done_div);
 6582   %}
 6583   ins_pipe(pipe_class_dummy);
 6584 %}
 6585 
 6586 
 6587 // Register Division
 6588 instruct divI_reg_reg(roddRegI dst, iRegI src1, noOdd_iRegI src2, revenRegI tmp, flagsReg cr) %{
 6589   match(Set dst (DivI src1 src2));
 6590   effect(KILL tmp, KILL cr);
 6591   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6592   size((VM_Version::has_CompareBranch() ? 20 : 22));
 6593   format %{ &quot;DIV_checked $dst, $src1,$src2\t # treats special case 0x80../-1&quot; %}
 6594   ins_encode %{
 6595     Register a = $src1$$Register;
 6596     Register b = $src2$$Register;
 6597     Register t = $dst$$Register;
 6598 
 6599     assert_different_registers(t, b);
 6600 
 6601     Label do_div, done_div;
 6602     if (VM_Version::has_CompareBranch()) {
 6603       __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6604     } else {
 6605       __ z_chi(b, -1);
 6606       __ z_brne(do_div);
 6607     }
 6608     __ z_lcr(t, a);
 6609     __ z_bru(done_div);
 6610     __ bind(do_div);
 6611     __ z_lgfr(t, a);
 6612     __ z_dsgfr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6613     __ bind(done_div);
 6614   %}
 6615   ins_pipe(pipe_class_dummy);
 6616 %}
 6617 
 6618 // Immediate Division
 6619 instruct divI_reg_imm16(roddRegI dst, iRegI src1, immI16 src2, revenRegI tmp, flagsReg cr) %{
 6620   match(Set dst (DivI src1 src2));
 6621   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6622   ins_cost(2 * DEFAULT_COST);
 6623   // TODO: s390 port size(VARIABLE_SIZE);
 6624   format %{ &quot;DIV_const  $dst,$src1,$src2&quot; %}
 6625   ins_encode %{
 6626     // No sign extension of Rdividend needed here.
 6627     if ($src2$$constant != -1) {
 6628       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6629       __ z_lgfr($dst$$Register, $src1$$Register);
 6630       __ z_dsgfr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6631     } else {
 6632       __ z_lcr($dst$$Register, $src1$$Register);
 6633     }
 6634   %}
 6635   ins_pipe(pipe_class_dummy);
 6636 %}
 6637 
 6638 // Long DIVMOD with Register, both quotient and mod results
 6639 instruct divModL_reg_divmod(roddRegL dst1src1, revenRegL dst2, iRegL src2, flagsReg cr) %{
 6640   match(DivModL dst1src1 src2);
 6641   effect(KILL cr);
 6642   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6643   size((VM_Version::has_CompareBranch() ? 22 : 24));
 6644   format %{ &quot;DIVMODL ($dst1src1, $dst2) $src2&quot; %}
 6645   ins_encode %{
 6646     Register d1s1 = $dst1src1$$Register;
 6647     Register d2   = $dst2$$Register;
 6648     Register s2   = $src2$$Register;
 6649 
 6650     Label do_div, done_div;
 6651     if (VM_Version::has_CompareBranch()) {
 6652       __ z_cgij(s2, -1, Assembler::bcondNotEqual, do_div);
 6653     } else {
 6654       __ z_cghi(s2, -1);
 6655       __ z_brne(do_div);
 6656     }
 6657     __ z_lcgr(d1s1, d1s1);
 6658     // indicate unused result
 6659     (void) __ clear_reg(d2, true, false);
 6660     __ z_bru(done_div);
 6661     __ bind(do_div);
 6662     __ z_dsgr(d2, s2);
 6663     __ bind(done_div);
 6664   %}
 6665   ins_pipe(pipe_class_dummy);
 6666 %}
 6667 
 6668 // Register Long Division
 6669 instruct divL_reg_reg(roddRegL dst, iRegL src, revenRegL tmp, flagsReg cr) %{
 6670   match(Set dst (DivL dst src));
 6671   effect(KILL tmp, KILL cr);
 6672   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6673   size((VM_Version::has_CompareBranch() ? 18 : 20));
 6674   format %{ &quot;DIVG_checked  $dst, $src\t # long, treats special case 0x80../-1&quot; %}
 6675   ins_encode %{
 6676     Register b = $src$$Register;
 6677     Register t = $dst$$Register;
 6678 
 6679     Label done_div;
 6680     __ z_lcgr(t, t);    // Does no harm. divisor is in other register.
 6681     if (VM_Version::has_CompareBranch()) {
 6682       __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6683     } else {
 6684       __ z_cghi(b, -1);
 6685       __ z_bre(done_div);
 6686     }
 6687     __ z_lcgr(t, t);    // Restore sign.
 6688     __ z_dsgr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6689     __ bind(done_div);
 6690   %}
 6691   ins_pipe(pipe_class_dummy);
 6692 %}
 6693 
 6694 // Immediate Long Division
 6695 instruct divL_reg_imm16(roddRegL dst, iRegL src1, immL16 src2, revenRegL tmp, flagsReg cr) %{
 6696   match(Set dst (DivL src1 src2));
 6697   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6698   ins_cost(2 * DEFAULT_COST);
 6699   // TODO: s390 port size(VARIABLE_SIZE);
 6700   format %{ &quot;DIVG_const  $dst,$src1,$src2\t # long&quot; %}
 6701   ins_encode %{
 6702     if ($src2$$constant != -1) {
 6703       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6704       __ lgr_if_needed($dst$$Register, $src1$$Register);
 6705       __ z_dsgr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6706     } else {
 6707       __ z_lcgr($dst$$Register, $src1$$Register);
 6708     }
 6709   %}
 6710   ins_pipe(pipe_class_dummy);
 6711 %}
 6712 
 6713 // REM
 6714 
 6715 // Integer Remainder
 6716 // Register Remainder
 6717 instruct modI_reg_reg(revenRegI dst, iRegI src1, noOdd_iRegI src2, roddRegI tmp, flagsReg cr) %{
 6718   match(Set dst (ModI src1 src2));
 6719   effect(KILL tmp, KILL cr);
 6720   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6721   // TODO: s390 port size(VARIABLE_SIZE);
 6722   format %{ &quot;MOD_checked   $dst,$src1,$src2&quot; %}
 6723   ins_encode %{
 6724     Register a = $src1$$Register;
 6725     Register b = $src2$$Register;
 6726     Register t = $dst$$Register;
 6727     assert_different_registers(t-&gt;successor(), b);
 6728 
 6729     Label do_div, done_div;
 6730 
 6731     if ((t-&gt;encoding() != b-&gt;encoding()) &amp;&amp; (t-&gt;encoding() != a-&gt;encoding())) {
 6732       (void) __ clear_reg(t, true, false);  // Does no harm. Operands are in other regs.
 6733       if (VM_Version::has_CompareBranch()) {
 6734         __ z_cij(b, -1, Assembler::bcondEqual, done_div);
 6735       } else {
 6736         __ z_chi(b, -1);
 6737         __ z_bre(done_div);
 6738       }
 6739       __ z_lgfr(t-&gt;successor(), a);
 6740       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6741     } else {
 6742       if (VM_Version::has_CompareBranch()) {
 6743         __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6744       } else {
 6745         __ z_chi(b, -1);
 6746         __ z_brne(do_div);
 6747       }
 6748       __ clear_reg(t, true, false);
 6749       __ z_bru(done_div);
 6750       __ bind(do_div);
 6751       __ z_lgfr(t-&gt;successor(), a);
 6752       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6753     }
 6754     __ bind(done_div);
 6755   %}
 6756   ins_pipe(pipe_class_dummy);
 6757 %}
 6758 
 6759 // Immediate Remainder
 6760 instruct modI_reg_imm16(revenRegI dst, iRegI src1, immI16 src2, roddRegI tmp, flagsReg cr) %{
 6761   match(Set dst (ModI src1 src2));
 6762   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6763   ins_cost(3 * DEFAULT_COST);
 6764   // TODO: s390 port size(VARIABLE_SIZE);
 6765   format %{ &quot;MOD_const  $dst,src1,$src2&quot; %}
 6766   ins_encode %{
 6767     assert_different_registers($dst$$Register, $src1$$Register);
 6768     assert_different_registers($dst$$Register-&gt;successor(), $src1$$Register);
 6769     int divisor = $src2$$constant;
 6770 
 6771     if (divisor != -1) {
 6772       __ z_lghi(Z_R0_scratch, divisor);
 6773       __ z_lgfr($dst$$Register-&gt;successor(), $src1$$Register);
 6774       __ z_dsgfr($dst$$Register/* Dst is even part of a register pair. */, Z_R0_scratch); // Instruction kills tmp.
 6775     } else {
 6776       __ clear_reg($dst$$Register, true, false);
 6777     }
 6778   %}
 6779   ins_pipe(pipe_class_dummy);
 6780 %}
 6781 
 6782 // Register Long Remainder
 6783 instruct modL_reg_reg(revenRegL dst, roddRegL src1, iRegL src2, flagsReg cr) %{
 6784   match(Set dst (ModL src1 src2));
 6785   effect(KILL src1, KILL cr); // R0 is killed, too.
 6786   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6787   // TODO: s390 port size(VARIABLE_SIZE);
 6788   format %{ &quot;MODG_checked   $dst,$src1,$src2&quot; %}
 6789   ins_encode %{
 6790     Register a = $src1$$Register;
 6791     Register b = $src2$$Register;
 6792     Register t = $dst$$Register;
 6793     assert(t-&gt;successor() == a, &quot;(t,a) is an even-odd pair&quot; );
 6794 
 6795     Label do_div, done_div;
 6796     if (t-&gt;encoding() != b-&gt;encoding()) {
 6797       (void) __ clear_reg(t, true, false); // Does no harm. Dividend is in successor.
 6798       if (VM_Version::has_CompareBranch()) {
 6799         __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6800       } else {
 6801         __ z_cghi(b, -1);
 6802         __ z_bre(done_div);
 6803       }
 6804       __ z_dsgr(t, b);
 6805     } else {
 6806       if (VM_Version::has_CompareBranch()) {
 6807         __ z_cgij(b, -1, Assembler::bcondNotEqual, do_div);
 6808       } else {
 6809         __ z_cghi(b, -1);
 6810         __ z_brne(do_div);
 6811       }
 6812       __ clear_reg(t, true, false);
 6813       __ z_bru(done_div);
 6814       __ bind(do_div);
 6815       __ z_dsgr(t, b);
 6816     }
 6817     __ bind(done_div);
 6818   %}
 6819   ins_pipe(pipe_class_dummy);
 6820 %}
 6821 
 6822 // Register Long Remainder
 6823 instruct modL_reg_imm16(revenRegL dst, iRegL src1, immL16 src2, roddRegL tmp, flagsReg cr) %{
 6824   match(Set dst (ModL src1 src2));
 6825   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6826   ins_cost(3 * DEFAULT_COST);
 6827   // TODO: s390 port size(VARIABLE_SIZE);
 6828   format %{ &quot;MODG_const  $dst,src1,$src2\t # long&quot; %}
 6829   ins_encode %{
 6830     int divisor = $src2$$constant;
 6831     if (divisor != -1) {
 6832       __ z_lghi(Z_R0_scratch, divisor);
 6833       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6834       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6835     } else {
 6836       __ clear_reg($dst$$Register, true, false);
 6837     }
 6838   %}
 6839   ins_pipe(pipe_class_dummy);
 6840 %}
 6841 
 6842 // SHIFT
 6843 
 6844 // Shift left logical
 6845 
 6846 // Register Shift Left variable
 6847 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6848   match(Set dst (LShiftI src nbits));
 6849   effect(KILL cr); // R1 is killed, too.
 6850   ins_cost(3 * DEFAULT_COST);
 6851   size(14);
 6852   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}
 6853   ins_encode %{
 6854     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6855     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6856     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6857   %}
 6858   ins_pipe(pipe_class_dummy);
 6859 %}
 6860 
 6861 // Register Shift Left Immediate
 6862 // Constant shift count is masked in ideal graph already.
 6863 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6864   match(Set dst (LShiftI src nbits));
 6865   size(6);
 6866   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}
 6867   ins_encode %{
 6868     int Nbit = $nbits$$constant;
 6869     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6870     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6871   %}
 6872   ins_pipe(pipe_class_dummy);
 6873 %}
 6874 
 6875 // Register Shift Left Immediate by 1bit
 6876 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6877   match(Set dst (LShiftI src nbits));
 6878   predicate(PreferLAoverADD);
 6879   ins_cost(DEFAULT_COST_LOW);
 6880   size(4);
 6881   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6882   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6883   ins_pipe(pipe_class_dummy);
 6884 %}
 6885 
 6886 // Register Shift Left Long
 6887 instruct sllL_reg_reg(iRegL dst, iRegL src1, iRegI nbits) %{
 6888   match(Set dst (LShiftL src1 nbits));
 6889   size(6);
 6890   format %{ &quot;SLLG    $dst,$src1,[$nbits]&quot; %}
 6891   opcode(SLLG_ZOPC);
 6892   ins_encode(z_rsyform_reg_reg(dst, src1, nbits));
 6893   ins_pipe(pipe_class_dummy);
 6894 %}
 6895 
 6896 // Register Shift Left Long Immediate
 6897 instruct sllL_reg_imm(iRegL dst, iRegL src1, immI nbits) %{
 6898   match(Set dst (LShiftL src1 nbits));
 6899   size(6);
 6900   format %{ &quot;SLLG    $dst,$src1,$nbits&quot; %}
 6901   opcode(SLLG_ZOPC);
 6902   ins_encode(z_rsyform_const(dst, src1, nbits));
 6903   ins_pipe(pipe_class_dummy);
 6904 %}
 6905 
 6906 // Register Shift Left Long Immediate by 1bit
 6907 instruct sllL_reg_imm_1(iRegL dst, iRegL src1, immI_1 nbits) %{
 6908   match(Set dst (LShiftL src1 nbits));
 6909   predicate(PreferLAoverADD);
 6910   ins_cost(DEFAULT_COST_LOW);
 6911   size(4);
 6912   format %{ &quot;LA      $dst,#0($src1,$src1)\t # SLLG by 1 (long)&quot; %}
 6913   ins_encode %{ __ z_la($dst$$Register, 0, $src1$$Register, $src1$$Register); %}
 6914   ins_pipe(pipe_class_dummy);
 6915 %}
 6916 
 6917 // Shift right arithmetic
 6918 
 6919 // Register Arithmetic Shift Right
 6920 instruct sraI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6921   match(Set dst (RShiftI dst src));
 6922   effect(KILL cr); // R1 is killed, too.
 6923   ins_cost(3 * DEFAULT_COST);
 6924   size(12);
 6925   format %{ &quot;SRA     $dst,[$src] &amp; 31&quot; %}
 6926   ins_encode %{
 6927     __ z_lgr(Z_R1_scratch, $src$$Register);
 6928     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6929     __ z_sra($dst$$Register, 0, Z_R1_scratch);
 6930   %}
 6931   ins_pipe(pipe_class_dummy);
 6932 %}
 6933 
 6934 // Register Arithmetic Shift Right Immediate
 6935 // Constant shift count is masked in ideal graph already.
 6936 instruct sraI_reg_imm(iRegI dst, immI src, flagsReg cr) %{
 6937   match(Set dst (RShiftI dst src));
 6938   effect(KILL cr);
 6939   size(4);
 6940   format %{ &quot;SRA     $dst,$src&quot; %}
 6941   ins_encode %{
 6942     int Nbit = $src$$constant;
 6943     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6944     __ z_sra($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6945   %}
 6946   ins_pipe(pipe_class_dummy);
 6947 %}
 6948 
 6949 // Register Arithmetic Shift Right Long
 6950 instruct sraL_reg_reg(iRegL dst, iRegL src1, iRegI src2, flagsReg cr) %{
 6951   match(Set dst (RShiftL src1 src2));
 6952   effect(KILL cr);
 6953   size(6);
 6954   format %{ &quot;SRAG    $dst,$src1,[$src2]&quot; %}
 6955   opcode(SRAG_ZOPC);
 6956   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6957   ins_pipe(pipe_class_dummy);
 6958 %}
 6959 
 6960 // Register Arithmetic Shift Right Long Immediate
 6961 instruct sraL_reg_imm(iRegL dst, iRegL src1, immI src2, flagsReg cr) %{
 6962   match(Set dst (RShiftL src1 src2));
 6963   effect(KILL cr);
 6964   size(6);
 6965   format %{ &quot;SRAG    $dst,$src1,$src2&quot; %}
 6966   opcode(SRAG_ZOPC);
 6967   ins_encode(z_rsyform_const(dst, src1, src2));
 6968   ins_pipe(pipe_class_dummy);
 6969 %}
 6970 
 6971 //  Shift right logical
 6972 
 6973 // Register Shift Right
 6974 instruct srlI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6975   match(Set dst (URShiftI dst src));
 6976   effect(KILL cr); // R1 is killed, too.
 6977   ins_cost(3 * DEFAULT_COST);
 6978   size(12);
 6979   format %{ &quot;SRL     $dst,[$src] &amp; 31&quot; %}
 6980   ins_encode %{
 6981     __ z_lgr(Z_R1_scratch, $src$$Register);
 6982     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6983     __ z_srl($dst$$Register, 0, Z_R1_scratch);
 6984   %}
 6985   ins_pipe(pipe_class_dummy);
 6986 %}
 6987 
 6988 // Register Shift Right Immediate
 6989 // Constant shift count is masked in ideal graph already.
 6990 instruct srlI_reg_imm(iRegI dst, immI src) %{
 6991   match(Set dst (URShiftI dst src));
 6992   size(4);
 6993   format %{ &quot;SRL     $dst,$src&quot; %}
 6994   ins_encode %{
 6995     int Nbit = $src$$constant;
 6996     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6997     __ z_srl($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6998   %}
 6999   ins_pipe(pipe_class_dummy);
 7000 %}
 7001 
 7002 // Register Shift Right Long
 7003 instruct srlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7004   match(Set dst (URShiftL src1 src2));
 7005   size(6);
 7006   format %{ &quot;SRLG    $dst,$src1,[$src2]&quot; %}
 7007   opcode(SRLG_ZOPC);
 7008   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 7009   ins_pipe(pipe_class_dummy);
 7010 %}
 7011 
 7012 // Register Shift Right Long Immediate
 7013 instruct srlL_reg_imm(iRegL dst, iRegL src1, immI src2) %{
 7014   match(Set dst (URShiftL src1 src2));
 7015   size(6);
 7016   format %{ &quot;SRLG    $dst,$src1,$src2&quot; %}
 7017   opcode(SRLG_ZOPC);
 7018   ins_encode(z_rsyform_const(dst, src1, src2));
 7019   ins_pipe(pipe_class_dummy);
 7020 %}
 7021 
 7022 // Register Shift Right Immediate with a CastP2X
 7023 instruct srlP_reg_imm(iRegL dst, iRegP_N2P src1, immI src2) %{
 7024   match(Set dst (URShiftL (CastP2X src1) src2));
 7025   size(6);
 7026   format %{ &quot;SRLG    $dst,$src1,$src2\t # Cast ptr $src1 to long and shift&quot; %}
 7027   opcode(SRLG_ZOPC);
 7028   ins_encode(z_rsyform_const(dst, src1, src2));
 7029   ins_pipe(pipe_class_dummy);
 7030 %}
 7031 
 7032 //----------Rotate Instructions------------------------------------------------
 7033 
 7034 // Rotate left 32bit.
 7035 instruct rotlI_reg_immI8(iRegI dst, iRegI src, immI8 lshift, immI8 rshift) %{
 7036   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 7037   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7038   size(6);
 7039   format %{ &quot;RLL     $dst,$src,$lshift\t # ROTL32&quot; %}
 7040   opcode(RLL_ZOPC);
 7041   ins_encode(z_rsyform_const(dst, src, lshift));
 7042   ins_pipe(pipe_class_dummy);
 7043 %}
 7044 
 7045 // Rotate left 64bit.
 7046 instruct rotlL_reg_immI8(iRegL dst, iRegL src, immI8 lshift, immI8 rshift) %{
 7047   match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));
 7048   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7049   size(6);
 7050   format %{ &quot;RLLG    $dst,$src,$lshift\t # ROTL64&quot; %}
 7051   opcode(RLLG_ZOPC);
 7052   ins_encode(z_rsyform_const(dst, src, lshift));
 7053   ins_pipe(pipe_class_dummy);
 7054 %}
 7055 
 7056 // Rotate right 32bit.
 7057 instruct rotrI_reg_immI8(iRegI dst, iRegI src, immI8 rshift, immI8 lshift) %{
 7058   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 7059   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7060   // TODO: s390 port size(FIXED_SIZE);
 7061   format %{ &quot;RLL     $dst,$src,$rshift\t # ROTR32&quot; %}
 7062   opcode(RLL_ZOPC);
 7063   ins_encode(z_rsyform_const(dst, src, rshift));
 7064   ins_pipe(pipe_class_dummy);
 7065 %}
 7066 
 7067 // Rotate right 64bit.
 7068 instruct rotrL_reg_immI8(iRegL dst, iRegL src, immI8 rshift, immI8 lshift) %{
 7069   match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));
 7070   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7071   // TODO: s390 port size(FIXED_SIZE);
 7072   format %{ &quot;RLLG    $dst,$src,$rshift\t # ROTR64&quot; %}
 7073   opcode(RLLG_ZOPC);
 7074   ins_encode(z_rsyform_const(dst, src, rshift));
 7075   ins_pipe(pipe_class_dummy);
 7076 %}
 7077 
 7078 
 7079 //----------Overflow Math Instructions-----------------------------------------
 7080 
 7081 instruct overflowAddI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7082   match(Set cr (OverflowAddI op1 op2));
 7083   effect(DEF cr, USE op1, USE op2);
 7084   // TODO: s390 port size(FIXED_SIZE);
 7085   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7086   ins_encode %{
 7087     __ z_lr(Z_R0_scratch, $op1$$Register);
 7088     __ z_ar(Z_R0_scratch, $op2$$Register);
 7089   %}
 7090   ins_pipe(pipe_class_dummy);
 7091 %}
 7092 
 7093 instruct overflowAddI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7094   match(Set cr (OverflowAddI op1 op2));
 7095   effect(DEF cr, USE op1, USE op2);
 7096   // TODO: s390 port size(VARIABLE_SIZE);
 7097   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7098   ins_encode %{
 7099     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7100     __ z_ar(Z_R0_scratch, $op1$$Register);
 7101   %}
 7102   ins_pipe(pipe_class_dummy);
 7103 %}
 7104 
 7105 instruct overflowAddL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7106   match(Set cr (OverflowAddL op1 op2));
 7107   effect(DEF cr, USE op1, USE op2);
 7108   // TODO: s390 port size(FIXED_SIZE);
 7109   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7110   ins_encode %{
 7111     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7112     __ z_agr(Z_R0_scratch, $op2$$Register);
 7113   %}
 7114   ins_pipe(pipe_class_dummy);
 7115 %}
 7116 
 7117 instruct overflowAddL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7118   match(Set cr (OverflowAddL op1 op2));
 7119   effect(DEF cr, USE op1, USE op2);
 7120   // TODO: s390 port size(VARIABLE_SIZE);
 7121   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7122   ins_encode %{
 7123     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7124     __ z_agr(Z_R0_scratch, $op1$$Register);
 7125   %}
 7126   ins_pipe(pipe_class_dummy);
 7127 %}
 7128 
 7129 instruct overflowSubI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7130   match(Set cr (OverflowSubI op1 op2));
 7131   effect(DEF cr, USE op1, USE op2);
 7132   // TODO: s390 port size(FIXED_SIZE);
 7133   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7134   ins_encode %{
 7135     __ z_lr(Z_R0_scratch, $op1$$Register);
 7136     __ z_sr(Z_R0_scratch, $op2$$Register);
 7137   %}
 7138   ins_pipe(pipe_class_dummy);
 7139 %}
 7140 
 7141 instruct overflowSubI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7142   match(Set cr (OverflowSubI op1 op2));
 7143   effect(DEF cr, USE op1, USE op2);
 7144   // TODO: s390 port size(VARIABLE_SIZE);
 7145   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7146   ins_encode %{
 7147     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7148     __ z_lr(Z_R0_scratch, $op1$$Register);
 7149     __ z_sr(Z_R0_scratch, Z_R1_scratch);
 7150   %}
 7151   ins_pipe(pipe_class_dummy);
 7152 %}
 7153 
 7154 instruct overflowSubL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7155   match(Set cr (OverflowSubL op1 op2));
 7156   effect(DEF cr, USE op1, USE op2);
 7157   // TODO: s390 port size(FIXED_SIZE);
 7158   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7159   ins_encode %{
 7160     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7161     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7162   %}
 7163   ins_pipe(pipe_class_dummy);
 7164 %}
 7165 
 7166 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7167   match(Set cr (OverflowSubL op1 op2));
 7168   effect(DEF cr, USE op1, USE op2);
 7169   // TODO: s390 port size(VARIABLE_SIZE);
 7170   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7171   ins_encode %{
 7172     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7173     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7174     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7175   %}
 7176   ins_pipe(pipe_class_dummy);
 7177 %}
 7178 
 7179 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7180   match(Set cr (OverflowSubI zero op2));
 7181   effect(DEF cr, USE op2);
 7182   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}
 7183   ins_encode %{
 7184     __ clear_reg(Z_R0_scratch, false, false);
 7185     __ z_sr(Z_R0_scratch, $op2$$Register);
 7186   %}
 7187   ins_pipe(pipe_class_dummy);
 7188 %}
 7189 
 7190 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7191   match(Set cr (OverflowSubL zero op2));
 7192   effect(DEF cr, USE op2);
 7193   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}
 7194   ins_encode %{
 7195     __ clear_reg(Z_R0_scratch, true, false);
 7196     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7197   %}
 7198   ins_pipe(pipe_class_dummy);
 7199 %}
 7200 
 7201 // No intrinsics for multiplication, since there is no easy way
 7202 // to check for overflow.
 7203 
 7204 
 7205 //----------Floating Point Arithmetic Instructions-----------------------------
 7206 
 7207 //  ADD
 7208 
 7209 //  Add float single precision
 7210 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7211   match(Set dst (AddF dst src));
 7212   effect(KILL cr);
 7213   ins_cost(ALU_REG_COST);
 7214   size(4);
 7215   format %{ &quot;AEBR     $dst,$src&quot; %}
 7216   opcode(AEBR_ZOPC);
 7217   ins_encode(z_rreform(dst, src));
 7218   ins_pipe(pipe_class_dummy);
 7219 %}
 7220 
 7221 instruct addF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7222   match(Set dst (AddF dst (LoadF src)));
 7223   effect(KILL cr);
 7224   ins_cost(ALU_MEMORY_COST);
 7225   size(6);
 7226   format %{ &quot;AEB      $dst,$src\t # floatMemory&quot; %}
 7227   opcode(AEB_ZOPC);
 7228   ins_encode(z_form_rt_memFP(dst, src));
 7229   ins_pipe(pipe_class_dummy);
 7230 %}
 7231 
 7232 // Add float double precision
 7233 instruct addD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7234   match(Set dst (AddD dst src));
 7235   effect(KILL cr);
 7236   ins_cost(ALU_REG_COST);
 7237   size(4);
 7238   format %{ &quot;ADBR     $dst,$src&quot; %}
 7239   opcode(ADBR_ZOPC);
 7240   ins_encode(z_rreform(dst, src));
 7241   ins_pipe(pipe_class_dummy);
 7242 %}
 7243 
 7244 instruct addD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7245   match(Set dst (AddD dst (LoadD src)));
 7246   effect(KILL cr);
 7247   ins_cost(ALU_MEMORY_COST);
 7248   size(6);
 7249   format %{ &quot;ADB      $dst,$src\t # doubleMemory&quot; %}
 7250   opcode(ADB_ZOPC);
 7251   ins_encode(z_form_rt_memFP(dst, src));
 7252   ins_pipe(pipe_class_dummy);
 7253 %}
 7254 
 7255 // SUB
 7256 
 7257 // Sub float single precision
 7258 instruct subF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7259   match(Set dst (SubF dst src));
 7260   effect(KILL cr);
 7261   ins_cost(ALU_REG_COST);
 7262   size(4);
 7263   format %{ &quot;SEBR     $dst,$src&quot; %}
 7264   opcode(SEBR_ZOPC);
 7265   ins_encode(z_rreform(dst, src));
 7266   ins_pipe(pipe_class_dummy);
 7267 %}
 7268 
 7269 instruct subF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7270   match(Set dst (SubF dst (LoadF src)));
 7271   effect(KILL cr);
 7272   ins_cost(ALU_MEMORY_COST);
 7273   size(6);
 7274   format %{ &quot;SEB      $dst,$src\t # floatMemory&quot; %}
 7275   opcode(SEB_ZOPC);
 7276   ins_encode(z_form_rt_memFP(dst, src));
 7277   ins_pipe(pipe_class_dummy);
 7278 %}
 7279 
 7280 //  Sub float double precision
 7281 instruct subD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7282   match(Set dst (SubD dst src));
 7283   effect(KILL cr);
 7284   ins_cost(ALU_REG_COST);
 7285   size(4);
 7286   format %{ &quot;SDBR     $dst,$src&quot; %}
 7287   opcode(SDBR_ZOPC);
 7288   ins_encode(z_rreform(dst, src));
 7289   ins_pipe(pipe_class_dummy);
 7290 %}
 7291 
 7292 instruct subD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7293   match(Set dst (SubD dst (LoadD src)));
 7294   effect(KILL cr);
 7295   ins_cost(ALU_MEMORY_COST);
 7296   size(6);
 7297   format %{ &quot;SDB      $dst,$src\t # doubleMemory&quot; %}
 7298   opcode(SDB_ZOPC);
 7299   ins_encode(z_form_rt_memFP(dst, src));
 7300   ins_pipe(pipe_class_dummy);
 7301 %}
 7302 
 7303 // MUL
 7304 
 7305 // Mul float single precision
 7306 instruct mulF_reg_reg(regF dst, regF src) %{
 7307   match(Set dst (MulF dst src));
 7308   // CC unchanged by MUL.
 7309   ins_cost(ALU_REG_COST);
 7310   size(4);
 7311   format %{ &quot;MEEBR    $dst,$src&quot; %}
 7312   opcode(MEEBR_ZOPC);
 7313   ins_encode(z_rreform(dst, src));
 7314   ins_pipe(pipe_class_dummy);
 7315 %}
 7316 
 7317 instruct mulF_reg_mem(regF dst, memoryRX src)%{
 7318   match(Set dst (MulF dst (LoadF src)));
 7319   // CC unchanged by MUL.
 7320   ins_cost(ALU_MEMORY_COST);
 7321   size(6);
 7322   format %{ &quot;MEEB     $dst,$src\t # floatMemory&quot; %}
 7323   opcode(MEEB_ZOPC);
 7324   ins_encode(z_form_rt_memFP(dst, src));
 7325   ins_pipe(pipe_class_dummy);
 7326 %}
 7327 
 7328 //  Mul float double precision
 7329 instruct mulD_reg_reg(regD dst, regD src) %{
 7330   match(Set dst (MulD dst src));
 7331   // CC unchanged by MUL.
 7332   ins_cost(ALU_REG_COST);
 7333   size(4);
 7334   format %{ &quot;MDBR     $dst,$src&quot; %}
 7335   opcode(MDBR_ZOPC);
 7336   ins_encode(z_rreform(dst, src));
 7337   ins_pipe(pipe_class_dummy);
 7338 %}
 7339 
 7340 instruct mulD_reg_mem(regD dst, memoryRX src)%{
 7341   match(Set dst (MulD dst (LoadD src)));
 7342   // CC unchanged by MUL.
 7343   ins_cost(ALU_MEMORY_COST);
 7344   size(6);
 7345   format %{ &quot;MDB      $dst,$src\t # doubleMemory&quot; %}
 7346   opcode(MDB_ZOPC);
 7347   ins_encode(z_form_rt_memFP(dst, src));
 7348   ins_pipe(pipe_class_dummy);
 7349 %}
 7350 
 7351 // Multiply-Accumulate
 7352 // src1 * src2 + dst
 7353 instruct maddF_reg_reg(regF dst, regF src1, regF src2) %{
 7354   match(Set dst (FmaF dst (Binary src1 src2)));
 7355   // CC unchanged by MUL-ADD.
 7356   ins_cost(ALU_REG_COST);
 7357   size(4);
 7358   format %{ &quot;MAEBR    $dst, $src1, $src2&quot; %}
 7359   ins_encode %{
 7360     __ z_maebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7361   %}
 7362   ins_pipe(pipe_class_dummy);
 7363 %}
 7364 
 7365 // src1 * src2 + dst
 7366 instruct maddD_reg_reg(regD dst, regD src1, regD src2) %{
 7367   match(Set dst (FmaD dst (Binary src1 src2)));
 7368   // CC unchanged by MUL-ADD.
 7369   ins_cost(ALU_REG_COST);
 7370   size(4);
 7371   format %{ &quot;MADBR    $dst, $src1, $src2&quot; %}
 7372   ins_encode %{
 7373     __ z_madbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7374   %}
 7375   ins_pipe(pipe_class_dummy);
 7376 %}
 7377 
 7378 // src1 * src2 - dst
 7379 instruct msubF_reg_reg(regF dst, regF src1, regF src2) %{
 7380   match(Set dst (FmaF (NegF dst) (Binary src1 src2)));
 7381   // CC unchanged by MUL-SUB.
 7382   ins_cost(ALU_REG_COST);
 7383   size(4);
 7384   format %{ &quot;MSEBR    $dst, $src1, $src2&quot; %}
 7385   ins_encode %{
 7386     __ z_msebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7387   %}
 7388   ins_pipe(pipe_class_dummy);
 7389 %}
 7390 
 7391 // src1 * src2 - dst
 7392 instruct msubD_reg_reg(regD dst, regD src1, regD src2) %{
 7393   match(Set dst (FmaD (NegD dst) (Binary src1 src2)));
 7394   // CC unchanged by MUL-SUB.
 7395   ins_cost(ALU_REG_COST);
 7396   size(4);
 7397   format %{ &quot;MSDBR    $dst, $src1, $src2&quot; %}
 7398   ins_encode %{
 7399     __ z_msdbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7400   %}
 7401   ins_pipe(pipe_class_dummy);
 7402 %}
 7403 
 7404 // src1 * src2 + dst
 7405 instruct maddF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7406   match(Set dst (FmaF dst (Binary src1 (LoadF src2))));
 7407   // CC unchanged by MUL-ADD.
 7408   ins_cost(ALU_MEMORY_COST);
 7409   size(6);
 7410   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7411   ins_encode %{
 7412     __ z_maeb($dst$$FloatRegister, $src1$$FloatRegister,
 7413               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7414   %}
 7415   ins_pipe(pipe_class_dummy);
 7416 %}
 7417 
 7418 // src1 * src2 + dst
 7419 instruct maddD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7420   match(Set dst (FmaD dst (Binary src1 (LoadD src2))));
 7421   // CC unchanged by MUL-ADD.
 7422   ins_cost(ALU_MEMORY_COST);
 7423   size(6);
 7424   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7425   ins_encode %{
 7426     __ z_madb($dst$$FloatRegister, $src1$$FloatRegister,
 7427               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7428   %}
 7429   ins_pipe(pipe_class_dummy);
 7430 %}
 7431 
 7432 // src1 * src2 - dst
 7433 instruct msubF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7434   match(Set dst (FmaF (NegF dst) (Binary src1 (LoadF src2))));
 7435   // CC unchanged by MUL-SUB.
 7436   ins_cost(ALU_MEMORY_COST);
 7437   size(6);
 7438   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7439   ins_encode %{
 7440     __ z_mseb($dst$$FloatRegister, $src1$$FloatRegister,
 7441               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7442   %}
 7443   ins_pipe(pipe_class_dummy);
 7444 %}
 7445 
 7446 // src1 * src2 - dst
 7447 instruct msubD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7448   match(Set dst (FmaD (NegD dst) (Binary src1 (LoadD src2))));
 7449   // CC unchanged by MUL-SUB.
 7450   ins_cost(ALU_MEMORY_COST);
 7451   size(6);
 7452   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7453   ins_encode %{
 7454     __ z_msdb($dst$$FloatRegister, $src1$$FloatRegister,
 7455               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7456   %}
 7457   ins_pipe(pipe_class_dummy);
 7458 %}
 7459 
 7460 // src1 * src2 + dst
 7461 instruct maddF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7462   match(Set dst (FmaF dst (Binary (LoadF src1) src2)));
 7463   // CC unchanged by MUL-ADD.
 7464   ins_cost(ALU_MEMORY_COST);
 7465   size(6);
 7466   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7467   ins_encode %{
 7468     __ z_maeb($dst$$FloatRegister, $src2$$FloatRegister,
 7469               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7470   %}
 7471   ins_pipe(pipe_class_dummy);
 7472 %}
 7473 
 7474 // src1 * src2 + dst
 7475 instruct maddD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7476   match(Set dst (FmaD dst (Binary (LoadD src1) src2)));
 7477   // CC unchanged by MUL-ADD.
 7478   ins_cost(ALU_MEMORY_COST);
 7479   size(6);
 7480   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7481   ins_encode %{
 7482     __ z_madb($dst$$FloatRegister, $src2$$FloatRegister,
 7483               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7484   %}
 7485   ins_pipe(pipe_class_dummy);
 7486 %}
 7487 
 7488 // src1 * src2 - dst
 7489 instruct msubF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7490   match(Set dst (FmaF (NegF dst) (Binary (LoadF src1) src2)));
 7491   // CC unchanged by MUL-SUB.
 7492   ins_cost(ALU_MEMORY_COST);
 7493   size(6);
 7494   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7495   ins_encode %{
 7496     __ z_mseb($dst$$FloatRegister, $src2$$FloatRegister,
 7497               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7498   %}
 7499   ins_pipe(pipe_class_dummy);
 7500 %}
 7501 
 7502 // src1 * src2 - dst
 7503 instruct msubD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7504   match(Set dst (FmaD (NegD dst) (Binary (LoadD src1) src2)));
 7505   // CC unchanged by MUL-SUB.
 7506   ins_cost(ALU_MEMORY_COST);
 7507   size(6);
 7508   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7509   ins_encode %{
 7510     __ z_msdb($dst$$FloatRegister, $src2$$FloatRegister,
 7511               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7512   %}
 7513   ins_pipe(pipe_class_dummy);
 7514 %}
 7515 
 7516 //  DIV
 7517 
 7518 //  Div float single precision
 7519 instruct divF_reg_reg(regF dst, regF src) %{
 7520   match(Set dst (DivF dst src));
 7521   // CC unchanged by DIV.
 7522   ins_cost(ALU_REG_COST);
 7523   size(4);
 7524   format %{ &quot;DEBR     $dst,$src&quot; %}
 7525   opcode(DEBR_ZOPC);
 7526   ins_encode(z_rreform(dst, src));
 7527   ins_pipe(pipe_class_dummy);
 7528 %}
 7529 
 7530 instruct divF_reg_mem(regF dst, memoryRX src)%{
 7531   match(Set dst (DivF dst (LoadF src)));
 7532   // CC unchanged by DIV.
 7533   ins_cost(ALU_MEMORY_COST);
 7534   size(6);
 7535   format %{ &quot;DEB      $dst,$src\t # floatMemory&quot; %}
 7536   opcode(DEB_ZOPC);
 7537   ins_encode(z_form_rt_memFP(dst, src));
 7538   ins_pipe(pipe_class_dummy);
 7539 %}
 7540 
 7541 //  Div float double precision
 7542 instruct divD_reg_reg(regD dst, regD src) %{
 7543   match(Set dst (DivD dst src));
 7544   // CC unchanged by DIV.
 7545   ins_cost(ALU_REG_COST);
 7546   size(4);
 7547   format %{ &quot;DDBR     $dst,$src&quot; %}
 7548   opcode(DDBR_ZOPC);
 7549   ins_encode(z_rreform(dst, src));
 7550   ins_pipe(pipe_class_dummy);
 7551 %}
 7552 
 7553 instruct divD_reg_mem(regD dst, memoryRX src)%{
 7554   match(Set dst (DivD dst (LoadD src)));
 7555   // CC unchanged by DIV.
 7556   ins_cost(ALU_MEMORY_COST);
 7557   size(6);
 7558   format %{ &quot;DDB      $dst,$src\t # doubleMemory&quot; %}
 7559   opcode(DDB_ZOPC);
 7560   ins_encode(z_form_rt_memFP(dst, src));
 7561   ins_pipe(pipe_class_dummy);
 7562 %}
 7563 
 7564 // ABS
 7565 
 7566 // Absolute float single precision
 7567 instruct absF_reg(regF dst, regF src, flagsReg cr) %{
 7568   match(Set dst (AbsF src));
 7569   effect(KILL cr);
 7570   size(4);
 7571   format %{ &quot;LPEBR    $dst,$src\t float&quot; %}
 7572   opcode(LPEBR_ZOPC);
 7573   ins_encode(z_rreform(dst, src));
 7574   ins_pipe(pipe_class_dummy);
 7575 %}
 7576 
 7577 // Absolute float double precision
 7578 instruct absD_reg(regD dst, regD src, flagsReg cr) %{
 7579   match(Set dst (AbsD src));
 7580   effect(KILL cr);
 7581   size(4);
 7582   format %{ &quot;LPDBR    $dst,$src\t double&quot; %}
 7583   opcode(LPDBR_ZOPC);
 7584   ins_encode(z_rreform(dst, src));
 7585   ins_pipe(pipe_class_dummy);
 7586 %}
 7587 
 7588 //  NEG(ABS)
 7589 
 7590 // Negative absolute float single precision
 7591 instruct nabsF_reg(regF dst, regF src, flagsReg cr) %{
 7592   match(Set dst (NegF (AbsF src)));
 7593   effect(KILL cr);
 7594   size(4);
 7595   format %{ &quot;LNEBR    $dst,$src\t float&quot; %}
 7596   opcode(LNEBR_ZOPC);
 7597   ins_encode(z_rreform(dst, src));
 7598   ins_pipe(pipe_class_dummy);
 7599 %}
 7600 
 7601 // Negative absolute float double precision
 7602 instruct nabsD_reg(regD dst, regD src, flagsReg cr) %{
 7603   match(Set dst (NegD (AbsD src)));
 7604   effect(KILL cr);
 7605   size(4);
 7606   format %{ &quot;LNDBR    $dst,$src\t double&quot; %}
 7607   opcode(LNDBR_ZOPC);
 7608   ins_encode(z_rreform(dst, src));
 7609   ins_pipe(pipe_class_dummy);
 7610 %}
 7611 
 7612 // NEG
 7613 
 7614 instruct negF_reg(regF dst, regF src, flagsReg cr) %{
 7615   match(Set dst (NegF src));
 7616   effect(KILL cr);
 7617   size(4);
 7618   format %{ &quot;NegF     $dst,$src\t float&quot; %}
 7619   ins_encode %{ __ z_lcebr($dst$$FloatRegister, $src$$FloatRegister); %}
 7620   ins_pipe(pipe_class_dummy);
 7621 %}
 7622 
 7623 instruct negD_reg(regD dst, regD src, flagsReg cr) %{
 7624   match(Set dst (NegD src));
 7625   effect(KILL cr);
 7626   size(4);
 7627   format %{ &quot;NegD     $dst,$src\t double&quot; %}
 7628   ins_encode %{ __ z_lcdbr($dst$$FloatRegister, $src$$FloatRegister); %}
 7629   ins_pipe(pipe_class_dummy);
 7630 %}
 7631 
 7632 // SQRT
 7633 
 7634 // Sqrt float precision
 7635 instruct sqrtF_reg(regF dst, regF src) %{
 7636   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7637   // CC remains unchanged.
 7638   ins_cost(ALU_REG_COST);
 7639   size(4);
 7640   format %{ &quot;SQEBR    $dst,$src&quot; %}
 7641   opcode(SQEBR_ZOPC);
 7642   ins_encode(z_rreform(dst, src));
 7643   ins_pipe(pipe_class_dummy);
 7644 %}
 7645 
 7646 // Sqrt double precision
 7647 instruct sqrtD_reg(regD dst, regD src) %{
 7648   match(Set dst (SqrtD src));
 7649   // CC remains unchanged.
 7650   ins_cost(ALU_REG_COST);
 7651   size(4);
 7652   format %{ &quot;SQDBR    $dst,$src&quot; %}
 7653   opcode(SQDBR_ZOPC);
 7654   ins_encode(z_rreform(dst, src));
 7655   ins_pipe(pipe_class_dummy);
 7656 %}
 7657 
 7658 instruct sqrtF_mem(regF dst, memoryRX src) %{
 7659   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7660   // CC remains unchanged.
 7661   ins_cost(ALU_MEMORY_COST);
 7662   size(6);
 7663   format %{ &quot;SQEB     $dst,$src\t # floatMemory&quot; %}
 7664   opcode(SQEB_ZOPC);
 7665   ins_encode(z_form_rt_memFP(dst, src));
 7666   ins_pipe(pipe_class_dummy);
 7667 %}
 7668 
 7669 instruct sqrtD_mem(regD dst, memoryRX src) %{
 7670   match(Set dst (SqrtD src));
 7671   // CC remains unchanged.
 7672   ins_cost(ALU_MEMORY_COST);
 7673   // TODO: s390 port size(FIXED_SIZE);
 7674   format %{ &quot;SQDB     $dst,$src\t # doubleMemory&quot; %}
 7675   opcode(SQDB_ZOPC);
 7676   ins_encode(z_form_rt_memFP(dst, src));
 7677   ins_pipe(pipe_class_dummy);
 7678 %}
 7679 
 7680 //----------Logical Instructions-----------------------------------------------
 7681 
 7682 // Register And
 7683 instruct andI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7684   match(Set dst (AndI dst src));
 7685   effect(KILL cr);
 7686   ins_cost(DEFAULT_COST_LOW);
 7687   size(2);
 7688   format %{ &quot;NR      $dst,$src\t # int&quot; %}
 7689   opcode(NR_ZOPC);
 7690   ins_encode(z_rrform(dst, src));
 7691   ins_pipe(pipe_class_dummy);
 7692 %}
 7693 
 7694 instruct andI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7695   match(Set dst (AndI dst (LoadI src)));
 7696   effect(KILL cr);
 7697   ins_cost(MEMORY_REF_COST);
 7698   // TODO: s390 port size(VARIABLE_SIZE);
 7699   format %{ &quot;N(Y)    $dst, $src\t # int&quot; %}
 7700   opcode(NY_ZOPC, N_ZOPC);
 7701   ins_encode(z_form_rt_mem_opt(dst, src));
 7702   ins_pipe(pipe_class_dummy);
 7703 %}
 7704 
 7705 // Immediate And
 7706 instruct andI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7707   match(Set dst (AndI dst src));
 7708   effect(KILL cr);
 7709   ins_cost(DEFAULT_COST_HIGH);
 7710   size(6);
 7711   format %{ &quot;NILF    $dst,$src&quot; %}
 7712   opcode(NILF_ZOPC);
 7713   ins_encode(z_rilform_unsigned(dst, src));
 7714   ins_pipe(pipe_class_dummy);
 7715 %}
 7716 
 7717 instruct andI_reg_uimmI_LH1(iRegI dst, uimmI_LH1 src, flagsReg cr) %{
 7718   match(Set dst (AndI dst src));
 7719   effect(KILL cr);
 7720   ins_cost(DEFAULT_COST);
 7721   size(4);
 7722   format %{ &quot;NILH    $dst,$src&quot; %}
 7723   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7724   ins_pipe(pipe_class_dummy);
 7725 %}
 7726 
 7727 instruct andI_reg_uimmI_LL1(iRegI dst, uimmI_LL1 src, flagsReg cr) %{
 7728   match(Set dst (AndI dst src));
 7729   effect(KILL cr);
 7730   ins_cost(DEFAULT_COST);
 7731   size(4);
 7732   format %{ &quot;NILL    $dst,$src&quot; %}
 7733   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7734   ins_pipe(pipe_class_dummy);
 7735 %}
 7736 
 7737 // Register And Long
 7738 instruct andL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7739   match(Set dst (AndL dst src));
 7740   effect(KILL cr);
 7741   ins_cost(DEFAULT_COST);
 7742   size(4);
 7743   format %{ &quot;NGR     $dst,$src\t # long&quot; %}
 7744   opcode(NGR_ZOPC);
 7745   ins_encode(z_rreform(dst, src));
 7746   ins_pipe(pipe_class_dummy);
 7747 %}
 7748 
 7749 instruct andL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7750   match(Set dst (AndL dst (LoadL src)));
 7751   effect(KILL cr);
 7752   ins_cost(MEMORY_REF_COST);
 7753   size(Z_DISP3_SIZE);
 7754   format %{ &quot;NG      $dst, $src\t # long&quot; %}
 7755   opcode(NG_ZOPC, NG_ZOPC);
 7756   ins_encode(z_form_rt_mem_opt(dst, src));
 7757   ins_pipe(pipe_class_dummy);
 7758 %}
 7759 
 7760 instruct andL_reg_uimmL_LL1(iRegL dst, uimmL_LL1 src, flagsReg cr) %{
 7761   match(Set dst (AndL dst src));
 7762   effect(KILL cr);
 7763   ins_cost(DEFAULT_COST);
 7764   size(4);
 7765   format %{ &quot;NILL    $dst,$src\t # long&quot; %}
 7766   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7767   ins_pipe(pipe_class_dummy);
 7768 %}
 7769 
 7770 instruct andL_reg_uimmL_LH1(iRegL dst, uimmL_LH1 src, flagsReg cr) %{
 7771   match(Set dst (AndL dst src));
 7772   effect(KILL cr);
 7773   ins_cost(DEFAULT_COST);
 7774   size(4);
 7775   format %{ &quot;NILH    $dst,$src\t # long&quot; %}
 7776   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7777   ins_pipe(pipe_class_dummy);
 7778 %}
 7779 
 7780 instruct andL_reg_uimmL_HL1(iRegL dst, uimmL_HL1 src, flagsReg cr) %{
 7781   match(Set dst (AndL dst src));
 7782   effect(KILL cr);
 7783   ins_cost(DEFAULT_COST);
 7784   size(4);
 7785   format %{ &quot;NIHL    $dst,$src\t # long&quot; %}
 7786   ins_encode %{ __ z_nihl($dst$$Register, ($src$$constant &gt;&gt; 32) &amp; 0xFFFF); %}
 7787   ins_pipe(pipe_class_dummy);
 7788 %}
 7789 
 7790 instruct andL_reg_uimmL_HH1(iRegL dst, uimmL_HH1 src, flagsReg cr) %{
 7791   match(Set dst (AndL dst src));
 7792   effect(KILL cr);
 7793   ins_cost(DEFAULT_COST);
 7794   size(4);
 7795   format %{ &quot;NIHH    $dst,$src\t # long&quot; %}
 7796   ins_encode %{ __ z_nihh($dst$$Register, ($src$$constant &gt;&gt; 48) &amp; 0xFFFF); %}
 7797   ins_pipe(pipe_class_dummy);
 7798 %}
 7799 
 7800 //  OR
 7801 
 7802 // Or Instructions
 7803 // Register Or
 7804 instruct orI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7805   match(Set dst (OrI dst src));
 7806   effect(KILL cr);
 7807   size(2);
 7808   format %{ &quot;OR      $dst,$src&quot; %}
 7809   opcode(OR_ZOPC);
 7810   ins_encode(z_rrform(dst, src));
 7811   ins_pipe(pipe_class_dummy);
 7812 %}
 7813 
 7814 instruct orI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7815   match(Set dst (OrI dst (LoadI src)));
 7816   effect(KILL cr);
 7817   ins_cost(MEMORY_REF_COST);
 7818   // TODO: s390 port size(VARIABLE_SIZE);
 7819   format %{ &quot;O(Y)    $dst, $src\t # int&quot; %}
 7820   opcode(OY_ZOPC, O_ZOPC);
 7821   ins_encode(z_form_rt_mem_opt(dst, src));
 7822   ins_pipe(pipe_class_dummy);
 7823 %}
 7824 
 7825 // Immediate Or
 7826 instruct orI_reg_uimm16(iRegI dst, uimmI16 con, flagsReg cr) %{
 7827   match(Set dst (OrI dst con));
 7828   effect(KILL cr);
 7829   size(4);
 7830   format %{ &quot;OILL    $dst,$con&quot; %}
 7831   opcode(OILL_ZOPC);
 7832   ins_encode(z_riform_unsigned(dst,con));
 7833   ins_pipe(pipe_class_dummy);
 7834 %}
 7835 
 7836 instruct orI_reg_uimm32(iRegI dst, uimmI con, flagsReg cr) %{
 7837   match(Set dst (OrI dst con));
 7838   effect(KILL cr);
 7839   ins_cost(DEFAULT_COST_HIGH);
 7840   size(6);
 7841   format %{ &quot;OILF    $dst,$con&quot; %}
 7842   opcode(OILF_ZOPC);
 7843   ins_encode(z_rilform_unsigned(dst,con));
 7844   ins_pipe(pipe_class_dummy);
 7845 %}
 7846 
 7847 // Register Or Long
 7848 instruct orL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7849   match(Set dst (OrL dst src));
 7850   effect(KILL cr);
 7851   ins_cost(DEFAULT_COST);
 7852   size(4);
 7853   format %{ &quot;OGR      $dst,$src\t # long&quot; %}
 7854   opcode(OGR_ZOPC);
 7855   ins_encode(z_rreform(dst, src));
 7856   ins_pipe(pipe_class_dummy);
 7857 %}
 7858 
 7859 instruct orL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7860   match(Set dst (OrL dst (LoadL src)));
 7861   effect(KILL cr);
 7862   ins_cost(MEMORY_REF_COST);
 7863   size(Z_DISP3_SIZE);
 7864   format %{ &quot;OG      $dst, $src\t # long&quot; %}
 7865   opcode(OG_ZOPC, OG_ZOPC);
 7866   ins_encode(z_form_rt_mem_opt(dst, src));
 7867   ins_pipe(pipe_class_dummy);
 7868 %}
 7869 
 7870 // Immediate Or long
 7871 instruct orL_reg_uimm16(iRegL dst, uimmL16 con, flagsReg cr) %{
 7872   match(Set dst (OrL dst con));
 7873   effect(KILL cr);
 7874   ins_cost(DEFAULT_COST);
 7875   size(4);
 7876   format %{ &quot;OILL    $dst,$con\t # long&quot; %}
 7877   opcode(OILL_ZOPC);
 7878   ins_encode(z_riform_unsigned(dst,con));
 7879   ins_pipe(pipe_class_dummy);
 7880 %}
 7881 
 7882 instruct orL_reg_uimm32(iRegI dst, uimmL32 con, flagsReg cr) %{
 7883   match(Set dst (OrI dst con));
 7884   effect(KILL cr);
 7885   ins_cost(DEFAULT_COST_HIGH);
 7886   // TODO: s390 port size(FIXED_SIZE);
 7887   format %{ &quot;OILF    $dst,$con\t # long&quot; %}
 7888   opcode(OILF_ZOPC);
 7889   ins_encode(z_rilform_unsigned(dst,con));
 7890   ins_pipe(pipe_class_dummy);
 7891 %}
 7892 
 7893 // XOR
 7894 
 7895 // Register Xor
 7896 instruct xorI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7897   match(Set dst (XorI dst src));
 7898   effect(KILL cr);
 7899   size(2);
 7900   format %{ &quot;XR      $dst,$src&quot; %}
 7901   opcode(XR_ZOPC);
 7902   ins_encode(z_rrform(dst, src));
 7903   ins_pipe(pipe_class_dummy);
 7904 %}
 7905 
 7906 instruct xorI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7907   match(Set dst (XorI dst (LoadI src)));
 7908   effect(KILL cr);
 7909   ins_cost(MEMORY_REF_COST);
 7910   // TODO: s390 port size(VARIABLE_SIZE);
 7911   format %{ &quot;X(Y)    $dst, $src\t # int&quot; %}
 7912   opcode(XY_ZOPC, X_ZOPC);
 7913   ins_encode(z_form_rt_mem_opt(dst, src));
 7914   ins_pipe(pipe_class_dummy);
 7915 %}
 7916 
 7917 // Immediate Xor
 7918 instruct xorI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7919   match(Set dst (XorI dst src));
 7920   effect(KILL cr);
 7921   ins_cost(DEFAULT_COST_HIGH);
 7922   size(6);
 7923   format %{ &quot;XILF    $dst,$src&quot; %}
 7924   opcode(XILF_ZOPC);
 7925   ins_encode(z_rilform_unsigned(dst, src));
 7926   ins_pipe(pipe_class_dummy);
 7927 %}
 7928 
 7929 // Register Xor Long
 7930 instruct xorL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7931   match(Set dst (XorL dst src));
 7932   effect(KILL cr);
 7933   ins_cost(DEFAULT_COST);
 7934   size(4);
 7935   format %{ &quot;XGR     $dst,$src\t # long&quot; %}
 7936   opcode(XGR_ZOPC);
 7937   ins_encode(z_rreform(dst, src));
 7938   ins_pipe(pipe_class_dummy);
 7939 %}
 7940 
 7941 instruct xorL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7942   match(Set dst (XorL dst (LoadL src)));
 7943   effect(KILL cr);
 7944   ins_cost(MEMORY_REF_COST);
 7945   size(Z_DISP3_SIZE);
 7946   format %{ &quot;XG      $dst, $src\t # long&quot; %}
 7947   opcode(XG_ZOPC, XG_ZOPC);
 7948   ins_encode(z_form_rt_mem_opt(dst, src));
 7949   ins_pipe(pipe_class_dummy);
 7950 %}
 7951 
 7952 // Immediate Xor Long
 7953 instruct xorL_reg_uimm32(iRegL dst, uimmL32 con, flagsReg cr) %{
 7954   match(Set dst (XorL dst con));
 7955   effect(KILL cr);
 7956   ins_cost(DEFAULT_COST_HIGH);
 7957   size(6);
 7958   format %{ &quot;XILF    $dst,$con\t # long&quot; %}
 7959   opcode(XILF_ZOPC);
 7960   ins_encode(z_rilform_unsigned(dst,con));
 7961   ins_pipe(pipe_class_dummy);
 7962 %}
 7963 
 7964 //----------Convert to Boolean-------------------------------------------------
 7965 
 7966 // Convert integer to boolean.
 7967 instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{
 7968   match(Set dst (Conv2B src));
 7969   effect(KILL cr);
 7970   ins_cost(3 * DEFAULT_COST);
 7971   size(6);
 7972   format %{ &quot;convI2B $dst,$src&quot; %}
 7973   ins_encode %{
 7974     __ z_lnr($dst$$Register, $src$$Register);  // Rdst := -|Rsrc|, i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7975     __ z_srl($dst$$Register, 31);              // Rdst := sign(Rdest)
 7976   %}
 7977   ins_pipe(pipe_class_dummy);
 7978 %}
 7979 
 7980 instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{
 7981   match(Set dst (Conv2B src));
 7982   effect(KILL cr);
 7983   ins_cost(3 * DEFAULT_COST);
 7984   size(10);
 7985   format %{ &quot;convP2B $dst,$src&quot; %}
 7986   ins_encode %{
 7987     __ z_lngr($dst$$Register, $src$$Register);     // Rdst := -|Rsrc| i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7988     __ z_srlg($dst$$Register, $dst$$Register, 63); // Rdst := sign(Rdest)
 7989   %}
 7990   ins_pipe(pipe_class_dummy);
 7991 %}
 7992 
 7993 instruct cmpLTMask_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7994   match(Set dst (CmpLTMask dst src));
 7995   effect(KILL cr);
 7996   ins_cost(2 * DEFAULT_COST);
 7997   size(18);
 7998   format %{ &quot;Set $dst CmpLTMask $dst,$src&quot; %}
 7999   ins_encode %{
 8000     // Avoid signed 32 bit overflow: Do sign extend and sub 64 bit.
 8001     __ z_lgfr(Z_R0_scratch, $src$$Register);
 8002     __ z_lgfr($dst$$Register, $dst$$Register);
 8003     __ z_sgr($dst$$Register, Z_R0_scratch);
 8004     __ z_srag($dst$$Register, $dst$$Register, 63);
 8005   %}
 8006   ins_pipe(pipe_class_dummy);
 8007 %}
 8008 
 8009 instruct cmpLTMask_reg_zero(iRegI dst, immI_0 zero, flagsReg cr) %{
 8010   match(Set dst (CmpLTMask dst zero));
 8011   effect(KILL cr);
 8012   ins_cost(DEFAULT_COST);
 8013   size(4);
 8014   format %{ &quot;Set $dst CmpLTMask $dst,$zero&quot; %}
 8015   ins_encode %{ __ z_sra($dst$$Register, 31); %}
 8016   ins_pipe(pipe_class_dummy);
 8017 %}
 8018 
 8019 
 8020 //----------Arithmetic Conversion Instructions---------------------------------
 8021 // The conversions operations are all Alpha sorted. Please keep it that way!
 8022 
 8023 instruct convD2F_reg(regF dst, regD src) %{
 8024   match(Set dst (ConvD2F src));
 8025   // CC remains unchanged.
 8026   size(4);
 8027   format %{ &quot;LEDBR   $dst,$src&quot; %}
 8028   opcode(LEDBR_ZOPC);
 8029   ins_encode(z_rreform(dst, src));
 8030   ins_pipe(pipe_class_dummy);
 8031 %}
 8032 
 8033 instruct convF2I_reg(iRegI dst, regF src, flagsReg cr) %{
 8034   match(Set dst (ConvF2I src));
 8035   effect(KILL cr);
 8036   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8037   size(16);
 8038   format %{ &quot;convF2I  $dst,$src&quot; %}
 8039   ins_encode %{
 8040     Label done;
 8041     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8042     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8043     __ z_brno(done);                             // Result is zero if unordered argument.
 8044     __ z_cfebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8045     __ bind(done);
 8046   %}
 8047   ins_pipe(pipe_class_dummy);
 8048 %}
 8049 
 8050 instruct convD2I_reg(iRegI dst, regD src, flagsReg cr) %{
 8051   match(Set dst (ConvD2I src));
 8052   effect(KILL cr);
 8053   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8054   size(16);
 8055   format %{ &quot;convD2I  $dst,$src&quot; %}
 8056   ins_encode %{
 8057     Label done;
 8058     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8059     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8060     __ z_brno(done);                             // Result is zero if unordered argument.
 8061     __ z_cfdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8062     __ bind(done);
 8063   %}
 8064   ins_pipe(pipe_class_dummy);
 8065 %}
 8066 
 8067 instruct convF2L_reg(iRegL dst, regF src, flagsReg cr) %{
 8068   match(Set dst (ConvF2L src));
 8069   effect(KILL cr);
 8070   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8071   size(16);
 8072   format %{ &quot;convF2L  $dst,$src&quot; %}
 8073   ins_encode %{
 8074     Label done;
 8075     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8076     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8077     __ z_brno(done);                             // Result is zero if unordered argument.
 8078     __ z_cgebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8079     __ bind(done);
 8080   %}
 8081   ins_pipe(pipe_class_dummy);
 8082 %}
 8083 
 8084 instruct convD2L_reg(iRegL dst, regD src, flagsReg cr) %{
 8085   match(Set dst (ConvD2L src));
 8086   effect(KILL cr);
 8087   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8088   size(16);
 8089   format %{ &quot;convD2L  $dst,$src&quot; %}
 8090   ins_encode %{
 8091     Label done;
 8092     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8093     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8094     __ z_brno(done);                             // Result is zero if unordered argument.
 8095     __ z_cgdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8096     __ bind(done);
 8097   %}
 8098   ins_pipe(pipe_class_dummy);
 8099 %}
 8100 
 8101 instruct convF2D_reg(regD dst, regF src) %{
 8102   match(Set dst (ConvF2D src));
 8103   // CC remains unchanged.
 8104   size(4);
 8105   format %{ &quot;LDEBR   $dst,$src&quot; %}
 8106   opcode(LDEBR_ZOPC);
 8107   ins_encode(z_rreform(dst, src));
 8108   ins_pipe(pipe_class_dummy);
 8109 %}
 8110 
 8111 instruct convF2D_mem(regD dst, memoryRX src) %{
 8112   match(Set dst (ConvF2D src));
 8113   // CC remains unchanged.
 8114   size(6);
 8115   format %{ &quot;LDEB    $dst,$src&quot; %}
 8116   opcode(LDEB_ZOPC);
 8117   ins_encode(z_form_rt_memFP(dst, src));
 8118   ins_pipe(pipe_class_dummy);
 8119 %}
 8120 
 8121 instruct convI2D_reg(regD dst, iRegI src) %{
 8122   match(Set dst (ConvI2D src));
 8123   // CC remains unchanged.
 8124   ins_cost(DEFAULT_COST);
 8125   size(4);
 8126   format %{ &quot;CDFBR   $dst,$src&quot; %}
 8127   opcode(CDFBR_ZOPC);
 8128   ins_encode(z_rreform(dst, src));
 8129   ins_pipe(pipe_class_dummy);
 8130 %}
 8131 
 8132 // Optimization that saves up to two memory operations for each conversion.
 8133 instruct convI2F_ireg(regF dst, iRegI src) %{
 8134   match(Set dst (ConvI2F src));
 8135   // CC remains unchanged.
 8136   ins_cost(DEFAULT_COST);
 8137   size(4);
 8138   format %{ &quot;CEFBR   $dst,$src\t # convert int to float&quot; %}
 8139   opcode(CEFBR_ZOPC);
 8140   ins_encode(z_rreform(dst, src));
 8141   ins_pipe(pipe_class_dummy);
 8142 %}
 8143 
 8144 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8145   match(Set dst (ConvI2L src));
 8146   size(4);
 8147   format %{ &quot;LGFR    $dst,$src\t # int-&gt;long&quot; %}
 8148   opcode(LGFR_ZOPC);
 8149   ins_encode(z_rreform(dst, src));
 8150   ins_pipe(pipe_class_dummy);
 8151 %}
 8152 
 8153 // Zero-extend convert int to long.
 8154 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask) %{
 8155   match(Set dst (AndL (ConvI2L src) mask));
 8156   size(4);
 8157   format %{ &quot;LLGFR   $dst, $src \t # zero-extend int to long&quot; %}
 8158   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8159   ins_pipe(pipe_class_dummy);
 8160 %}
 8161 
 8162 // Zero-extend convert int to long.
 8163 instruct convI2L_mem_zex(iRegL dst, memory src, immL_32bits mask) %{
 8164   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
 8165   // Uses load_const_optmized, so size can vary.
 8166   // TODO: s390 port size(VARIABLE_SIZE);
 8167   format %{ &quot;LLGF    $dst, $src \t # zero-extend int to long&quot; %}
 8168   opcode(LLGF_ZOPC, LLGF_ZOPC);
 8169   ins_encode(z_form_rt_mem_opt(dst, src));
 8170   ins_pipe(pipe_class_dummy);
 8171 %}
 8172 
 8173 // Zero-extend long
 8174 instruct zeroExtend_long(iRegL dst, iRegL src, immL_32bits mask) %{
 8175   match(Set dst (AndL src mask));
 8176   size(4);
 8177   format %{ &quot;LLGFR   $dst, $src \t # zero-extend long to long&quot; %}
 8178   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8179   ins_pipe(pipe_class_dummy);
 8180 %}
 8181 
 8182 instruct rShiftI16_lShiftI16_reg(iRegI dst, iRegI src, immI_16 amount) %{
 8183   match(Set dst (RShiftI (LShiftI src amount) amount));
 8184   size(4);
 8185   format %{ &quot;LHR     $dst,$src\t short-&gt;int&quot; %}
 8186   opcode(LHR_ZOPC);
 8187   ins_encode(z_rreform(dst, src));
 8188   ins_pipe(pipe_class_dummy);
 8189 %}
 8190 
 8191 instruct rShiftI24_lShiftI24_reg(iRegI dst, iRegI src, immI_24 amount) %{
 8192   match(Set dst (RShiftI (LShiftI src amount) amount));
 8193   size(4);
 8194   format %{ &quot;LBR     $dst,$src\t byte-&gt;int&quot; %}
 8195   opcode(LBR_ZOPC);
 8196   ins_encode(z_rreform(dst, src));
 8197   ins_pipe(pipe_class_dummy);
 8198 %}
 8199 
 8200 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8201   match(Set dst (MoveF2I src));
 8202   ins_cost(MEMORY_REF_COST);
 8203   size(4);
 8204   format %{ &quot;L       $dst,$src\t # MoveF2I&quot; %}
 8205   opcode(L_ZOPC);
 8206   ins_encode(z_form_rt_mem(dst, src));
 8207   ins_pipe(pipe_class_dummy);
 8208 %}
 8209 
 8210 // javax.imageio.stream.ImageInputStreamImpl.toFloats([B[FII)
 8211 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8212   match(Set dst (MoveI2F src));
 8213   ins_cost(MEMORY_REF_COST);
 8214   // TODO: s390 port size(FIXED_SIZE);
 8215   format %{ &quot;LE      $dst,$src\t # MoveI2F&quot; %}
 8216   opcode(LE_ZOPC);
 8217   ins_encode(z_form_rt_mem(dst, src));
 8218   ins_pipe(pipe_class_dummy);
 8219 %}
 8220 
 8221 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8222   match(Set dst (MoveD2L src));
 8223   ins_cost(MEMORY_REF_COST);
 8224   size(6);
 8225   format %{ &quot;LG      $src,$dst\t # MoveD2L&quot; %}
 8226   opcode(LG_ZOPC);
 8227   ins_encode(z_form_rt_mem(dst, src));
 8228   ins_pipe(pipe_class_dummy);
 8229 %}
 8230 
 8231 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8232   match(Set dst (MoveL2D src));
 8233   ins_cost(MEMORY_REF_COST);
 8234   size(4);
 8235   format %{ &quot;LD      $dst,$src\t # MoveL2D&quot; %}
 8236   opcode(LD_ZOPC);
 8237   ins_encode(z_form_rt_mem(dst, src));
 8238   ins_pipe(pipe_class_dummy);
 8239 %}
 8240 
 8241 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8242   match(Set dst (MoveI2F src));
 8243   ins_cost(MEMORY_REF_COST);
 8244   size(4);
 8245   format %{ &quot;ST      $src,$dst\t # MoveI2F&quot; %}
 8246   opcode(ST_ZOPC);
 8247   ins_encode(z_form_rt_mem(src, dst));
 8248   ins_pipe(pipe_class_dummy);
 8249 %}
 8250 
 8251 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8252   match(Set dst (MoveD2L src));
 8253   effect(DEF dst, USE src);
 8254   ins_cost(MEMORY_REF_COST);
 8255   size(4);
 8256   format %{ &quot;STD     $src,$dst\t # MoveD2L&quot; %}
 8257   opcode(STD_ZOPC);
 8258   ins_encode(z_form_rt_mem(src,dst));
 8259   ins_pipe(pipe_class_dummy);
 8260 %}
 8261 
 8262 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8263   match(Set dst (MoveL2D src));
 8264   ins_cost(MEMORY_REF_COST);
 8265   size(6);
 8266   format %{ &quot;STG     $src,$dst\t # MoveL2D&quot; %}
 8267   opcode(STG_ZOPC);
 8268   ins_encode(z_form_rt_mem(src,dst));
 8269   ins_pipe(pipe_class_dummy);
 8270 %}
 8271 
 8272 instruct convL2F_reg(regF dst, iRegL src) %{
 8273   match(Set dst (ConvL2F src));
 8274   // CC remains unchanged.
 8275   ins_cost(DEFAULT_COST);
 8276   size(4);
 8277   format %{ &quot;CEGBR   $dst,$src&quot; %}
 8278   opcode(CEGBR_ZOPC);
 8279   ins_encode(z_rreform(dst, src));
 8280   ins_pipe(pipe_class_dummy);
 8281 %}
 8282 
 8283 instruct convL2D_reg(regD dst, iRegL src) %{
 8284   match(Set dst (ConvL2D src));
 8285   // CC remains unchanged.
 8286   ins_cost(DEFAULT_COST);
 8287   size(4);
 8288   format %{ &quot;CDGBR   $dst,$src&quot; %}
 8289   opcode(CDGBR_ZOPC);
 8290   ins_encode(z_rreform(dst, src));
 8291   ins_pipe(pipe_class_dummy);
 8292 %}
 8293 
 8294 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8295   match(Set dst (ConvL2I src));
 8296   // TODO: s390 port size(VARIABLE_SIZE);
 8297   format %{ &quot;LR      $dst,$src\t # long-&gt;int (if needed)&quot; %}
 8298   ins_encode %{ __ lr_if_needed($dst$$Register, $src$$Register); %}
 8299   ins_pipe(pipe_class_dummy);
 8300 %}
 8301 
 8302 // Register Shift Right Immediate
 8303 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt, flagsReg cr) %{
 8304   match(Set dst (ConvL2I (RShiftL src cnt)));
 8305   effect(KILL cr);
 8306   size(6);
 8307   format %{ &quot;SRAG    $dst,$src,$cnt&quot; %}
 8308   opcode(SRAG_ZOPC);
 8309   ins_encode(z_rsyform_const(dst, src, cnt));
 8310   ins_pipe(pipe_class_dummy);
 8311 %}
 8312 
 8313 //----------TRAP based zero checks and range checks----------------------------
 8314 
 8315 // SIGTRAP based implicit range checks in compiled code.
 8316 // A range check in the ideal world has one of the following shapes:
 8317 //   - (If le (CmpU length index)), (IfTrue  throw exception)
 8318 //   - (If lt (CmpU index length)), (IfFalse throw exception)
 8319 //
 8320 // Match range check &#39;If le (CmpU length index)&#39;
 8321 instruct rangeCheck_iReg_uimmI16(cmpOpT cmp, iRegI length, uimmI16 index, label labl) %{
 8322   match(If cmp (CmpU length index));
 8323   effect(USE labl);
 8324   predicate(TrapBasedRangeChecks &amp;&amp;
 8325             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
 8326             PROB_UNLIKELY(_leaf-&gt;as_If ()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
 8327             Matcher::branches_to_uncommon_trap(_leaf));
 8328   ins_cost(1);
 8329   // TODO: s390 port size(FIXED_SIZE);
 8330 
 8331   ins_is_TrapBasedCheckNode(true);
 8332 
 8333   format %{ &quot;RangeCheck len=$length cmp=$cmp idx=$index =&gt; trap $labl&quot; %}
 8334   ins_encode %{ __ z_clfit($length$$Register, $index$$constant, $cmp$$cmpcode); %}
 8335   ins_pipe(pipe_class_trap);
 8336 %}
 8337 
 8338 // Match range check &#39;If lt (CmpU index length)&#39;
 8339 instruct rangeCheck_iReg_iReg(cmpOpT cmp, iRegI index, iRegI length, label labl, flagsReg cr) %{
 8340   match(If cmp (CmpU index length));
 8341   effect(USE labl, KILL cr);
 8342   predicate(TrapBasedRangeChecks &amp;&amp;
 8343             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8344             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8345             Matcher::branches_to_uncommon_trap(_leaf));
 8346   ins_cost(1);
 8347   // TODO: s390 port size(FIXED_SIZE);
 8348 
 8349   ins_is_TrapBasedCheckNode(true);
 8350 
 8351   format %{ &quot;RangeCheck idx=$index cmp=$cmp len=$length =&gt; trap $labl&quot; %}
 8352   ins_encode %{ __ z_clrt($index$$Register, $length$$Register, $cmp$$cmpcode); %}
 8353   ins_pipe(pipe_class_trap);
 8354 %}
 8355 
 8356 // Match range check &#39;If lt (CmpU index length)&#39;
 8357 instruct rangeCheck_uimmI16_iReg(cmpOpT cmp, iRegI index, uimmI16 length, label labl) %{
 8358   match(If cmp (CmpU index length));
 8359   effect(USE labl);
 8360   predicate(TrapBasedRangeChecks &amp;&amp;
 8361             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8362             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8363             Matcher::branches_to_uncommon_trap(_leaf));
 8364   ins_cost(1);
 8365   // TODO: s390 port size(FIXED_SIZE);
 8366 
 8367   ins_is_TrapBasedCheckNode(true);
 8368 
 8369   format %{ &quot;RangeCheck idx=$index cmp=$cmp len= $length =&gt; trap $labl&quot; %}
 8370   ins_encode %{ __ z_clfit($index$$Register, $length$$constant, $cmp$$cmpcode); %}
 8371   ins_pipe(pipe_class_trap);
 8372 %}
 8373 
 8374 // Implicit zero checks (more implicit null checks).
 8375 instruct zeroCheckP_iReg_imm0(cmpOpT cmp, iRegP_N2P value, immP0 zero, label labl) %{
 8376   match(If cmp (CmpP value zero));
 8377   effect(USE labl);
 8378   predicate(TrapBasedNullChecks &amp;&amp;
 8379             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8380             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8381             Matcher::branches_to_uncommon_trap(_leaf));
 8382   size(6);
 8383 
 8384   ins_is_TrapBasedCheckNode(true);
 8385 
 8386   format %{ &quot;ZeroCheckP value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8387   ins_encode %{ __ z_cgit($value$$Register, 0, $cmp$$cmpcode); %}
 8388   ins_pipe(pipe_class_trap);
 8389 %}
 8390 
 8391 // Implicit zero checks (more implicit null checks).
 8392 instruct zeroCheckN_iReg_imm0(cmpOpT cmp, iRegN_P2N value, immN0 zero, label labl) %{
 8393   match(If cmp (CmpN value zero));
 8394   effect(USE labl);
 8395   predicate(TrapBasedNullChecks &amp;&amp;
 8396             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8397             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8398             Matcher::branches_to_uncommon_trap(_leaf));
 8399   size(6);
 8400 
 8401   ins_is_TrapBasedCheckNode(true);
 8402 
 8403   format %{ &quot;ZeroCheckN value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8404   ins_encode %{ __ z_cit($value$$Register, 0, $cmp$$cmpcode); %}
 8405   ins_pipe(pipe_class_trap);
 8406 %}
 8407 
 8408 //----------Compare instructions-----------------------------------------------
 8409 
 8410 // INT signed
 8411 
 8412 // Compare Integers
 8413 instruct compI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8414   match(Set cr (CmpI op1 op2));
 8415   size(2);
 8416   format %{ &quot;CR      $op1,$op2&quot; %}
 8417   opcode(CR_ZOPC);
 8418   ins_encode(z_rrform(op1, op2));
 8419   ins_pipe(pipe_class_dummy);
 8420 %}
 8421 
 8422 instruct compI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 8423   match(Set cr (CmpI op1 op2));
 8424   size(6);
 8425   format %{ &quot;CFI     $op1,$op2&quot; %}
 8426   opcode(CFI_ZOPC);
 8427   ins_encode(z_rilform_signed(op1, op2));
 8428   ins_pipe(pipe_class_dummy);
 8429 %}
 8430 
 8431 instruct compI_reg_imm16(flagsReg cr, iRegI op1, immI16 op2) %{
 8432   match(Set cr (CmpI op1 op2));
 8433   size(4);
 8434   format %{ &quot;CHI     $op1,$op2&quot; %}
 8435   opcode(CHI_ZOPC);
 8436   ins_encode(z_riform_signed(op1, op2));
 8437   ins_pipe(pipe_class_dummy);
 8438 %}
 8439 
 8440 instruct compI_reg_imm0(flagsReg cr, iRegI op1, immI_0 zero) %{
 8441   match(Set cr (CmpI op1 zero));
 8442   ins_cost(DEFAULT_COST_LOW);
 8443   size(2);
 8444   format %{ &quot;LTR     $op1,$op1&quot; %}
 8445   opcode(LTR_ZOPC);
 8446   ins_encode(z_rrform(op1, op1));
 8447   ins_pipe(pipe_class_dummy);
 8448 %}
 8449 
 8450 instruct compI_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8451   match(Set cr (CmpI op1 (LoadI op2)));
 8452   ins_cost(MEMORY_REF_COST);
 8453   // TODO: s390 port size(VARIABLE_SIZE);
 8454   format %{ &quot;C(Y)    $op1, $op2\t # int&quot; %}
 8455   opcode(CY_ZOPC, C_ZOPC);
 8456   ins_encode(z_form_rt_mem_opt(op1, op2));
 8457   ins_pipe(pipe_class_dummy);
 8458 %}
 8459 
 8460 // INT unsigned
 8461 
 8462 instruct compU_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8463   match(Set cr (CmpU op1 op2));
 8464   size(2);
 8465   format %{ &quot;CLR     $op1,$op2\t # unsigned&quot; %}
 8466   opcode(CLR_ZOPC);
 8467   ins_encode(z_rrform(op1, op2));
 8468   ins_pipe(pipe_class_dummy);
 8469 %}
 8470 
 8471 instruct compU_reg_uimm(flagsReg cr, iRegI op1, uimmI op2) %{
 8472   match(Set cr (CmpU op1 op2));
 8473   size(6);
 8474   format %{ &quot;CLFI    $op1,$op2\t # unsigned&quot; %}
 8475   opcode(CLFI_ZOPC);
 8476   ins_encode(z_rilform_unsigned(op1, op2));
 8477   ins_pipe(pipe_class_dummy);
 8478 %}
 8479 
 8480 instruct compU_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8481   match(Set cr (CmpU op1 (LoadI op2)));
 8482   ins_cost(MEMORY_REF_COST);
 8483   // TODO: s390 port size(VARIABLE_SIZE);
 8484   format %{ &quot;CL(Y)   $op1, $op2\t # unsigned&quot; %}
 8485   opcode(CLY_ZOPC, CL_ZOPC);
 8486   ins_encode(z_form_rt_mem_opt(op1, op2));
 8487   ins_pipe(pipe_class_dummy);
 8488 %}
 8489 
 8490 // LONG signed
 8491 
 8492 instruct compL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8493   match(Set cr (CmpL op1 op2));
 8494   size(4);
 8495   format %{ &quot;CGR     $op1,$op2\t # long&quot; %}
 8496   opcode(CGR_ZOPC);
 8497   ins_encode(z_rreform(op1, op2));
 8498   ins_pipe(pipe_class_dummy);
 8499 %}
 8500 
 8501 instruct compL_reg_regI(flagsReg cr, iRegL op1, iRegI op2) %{
 8502   match(Set cr (CmpL op1 (ConvI2L op2)));
 8503   size(4);
 8504   format %{ &quot;CGFR    $op1,$op2\t # long/int&quot; %}
 8505   opcode(CGFR_ZOPC);
 8506   ins_encode(z_rreform(op1, op2));
 8507   ins_pipe(pipe_class_dummy);
 8508 %}
 8509 
 8510 instruct compL_reg_imm32(flagsReg cr, iRegL op1, immL32 con) %{
 8511   match(Set cr (CmpL op1 con));
 8512   size(6);
 8513   format %{ &quot;CGFI    $op1,$con&quot; %}
 8514   opcode(CGFI_ZOPC);
 8515   ins_encode(z_rilform_signed(op1, con));
 8516   ins_pipe(pipe_class_dummy);
 8517 %}
 8518 
 8519 instruct compL_reg_imm16(flagsReg cr, iRegL op1, immL16 con) %{
 8520   match(Set cr (CmpL op1 con));
 8521   size(4);
 8522   format %{ &quot;CGHI    $op1,$con&quot; %}
 8523   opcode(CGHI_ZOPC);
 8524   ins_encode(z_riform_signed(op1, con));
 8525   ins_pipe(pipe_class_dummy);
 8526 %}
 8527 
 8528 instruct compL_reg_imm0(flagsReg cr, iRegL op1, immL_0 con) %{
 8529   match(Set cr (CmpL op1 con));
 8530   ins_cost(DEFAULT_COST_LOW);
 8531   size(4);
 8532   format %{ &quot;LTGR    $op1,$op1&quot; %}
 8533   opcode(LTGR_ZOPC);
 8534   ins_encode(z_rreform(op1, op1));
 8535   ins_pipe(pipe_class_dummy);
 8536 %}
 8537 
 8538 instruct compL_conv_reg_imm0(flagsReg cr, iRegI op1, immL_0 con) %{
 8539   match(Set cr (CmpL (ConvI2L op1) con));
 8540   ins_cost(DEFAULT_COST_LOW);
 8541   size(4);
 8542   format %{ &quot;LTGFR    $op1,$op1&quot; %}
 8543   opcode(LTGFR_ZOPC);
 8544   ins_encode(z_rreform(op1, op1));
 8545   ins_pipe(pipe_class_dummy);
 8546 %}
 8547 
 8548 instruct compL_reg_mem(iRegL dst, memory src, flagsReg cr)%{
 8549   match(Set cr (CmpL dst (LoadL src)));
 8550   ins_cost(MEMORY_REF_COST);
 8551   size(Z_DISP3_SIZE);
 8552   format %{ &quot;CG      $dst, $src\t # long&quot; %}
 8553   opcode(CG_ZOPC, CG_ZOPC);
 8554   ins_encode(z_form_rt_mem_opt(dst, src));
 8555   ins_pipe(pipe_class_dummy);
 8556 %}
 8557 
 8558 instruct compL_reg_memI(iRegL dst, memory src, flagsReg cr)%{
 8559   match(Set cr (CmpL dst (ConvI2L (LoadI src))));
 8560   ins_cost(MEMORY_REF_COST);
 8561   size(Z_DISP3_SIZE);
 8562   format %{ &quot;CGF     $dst, $src\t # long/int&quot; %}
 8563   opcode(CGF_ZOPC, CGF_ZOPC);
 8564   ins_encode(z_form_rt_mem_opt(dst, src));
 8565   ins_pipe(pipe_class_dummy);
 8566 %}
 8567 
 8568 //  LONG unsigned
 8569 // Added CmpUL for LoopPredicate.
 8570 instruct compUL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8571   match(Set cr (CmpUL op1 op2));
 8572   size(4);
 8573   format %{ &quot;CLGR    $op1,$op2\t # long&quot; %}
 8574   opcode(CLGR_ZOPC);
 8575   ins_encode(z_rreform(op1, op2));
 8576   ins_pipe(pipe_class_dummy);
 8577 %}
 8578 
 8579 instruct compUL_reg_imm32(flagsReg cr, iRegL op1, uimmL32 con) %{
 8580   match(Set cr (CmpUL op1 con));
 8581   size(6);
 8582   format %{ &quot;CLGFI   $op1,$con&quot; %}
 8583   opcode(CLGFI_ZOPC);
 8584   ins_encode(z_rilform_unsigned(op1, con));
 8585   ins_pipe(pipe_class_dummy);
 8586 %}
 8587 
 8588 //  PTR unsigned
 8589 
 8590 instruct compP_reg_reg(flagsReg cr, iRegP_N2P op1, iRegP_N2P op2) %{
 8591   match(Set cr (CmpP op1 op2));
 8592   size(4);
 8593   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8594   opcode(CLGR_ZOPC);
 8595   ins_encode(z_rreform(op1, op2));
 8596   ins_pipe(pipe_class_dummy);
 8597 %}
 8598 
 8599 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8600   match(Set cr (CmpP op1 op2));
 8601   ins_cost(DEFAULT_COST_LOW);
 8602   size(4);
 8603   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8604   opcode(LTGR_ZOPC);
 8605   ins_encode(z_rreform(op1, op1));
 8606   ins_pipe(pipe_class_dummy);
 8607 %}
 8608 
 8609 // Don&#39;t use LTGFR which performs sign extend.
 8610 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8611   match(Set cr (CmpP (DecodeN op1) op2));
 8612   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 8613   ins_cost(DEFAULT_COST_LOW);
 8614   size(2);
 8615   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8616   opcode(LTR_ZOPC);
 8617   ins_encode(z_rrform(op1, op1));
 8618   ins_pipe(pipe_class_dummy);
 8619 %}
 8620 
 8621 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8622   match(Set cr (CmpP dst (LoadP src)));
 8623   ins_cost(MEMORY_REF_COST);
 8624   size(Z_DISP3_SIZE);
 8625   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8626   opcode(CLG_ZOPC, CLG_ZOPC);
 8627   ins_encode(z_form_rt_mem_opt(dst, src));
 8628   ins_pipe(pipe_class_dummy);
 8629 %}
 8630 
 8631 //----------Max and Min--------------------------------------------------------
 8632 
 8633 // Max Register with Register
 8634 instruct z196_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8635   match(Set dst (MinI src1 src2));
 8636   effect(KILL cr);
 8637   predicate(VM_Version::has_LoadStoreConditional());
 8638   ins_cost(3 * DEFAULT_COST);
 8639   // TODO: s390 port size(VARIABLE_SIZE);
 8640   format %{ &quot;MinI $dst $src1,$src2\t MinI (z196 only)&quot; %}
 8641   ins_encode %{
 8642     Register Rdst = $dst$$Register;
 8643     Register Rsrc1 = $src1$$Register;
 8644     Register Rsrc2 = $src2$$Register;
 8645 
 8646     if (Rsrc1 == Rsrc2) {
 8647       if (Rdst != Rsrc1) {
 8648         __ z_lgfr(Rdst, Rsrc1);
 8649       }
 8650     } else if (Rdst == Rsrc1) {   // Rdst preset with src1.
 8651       __ z_cr(Rsrc1, Rsrc2);      // Move src2 only if src1 is NotLow.
 8652       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8653     } else if (Rdst == Rsrc2) {   // Rdst preset with src2.
 8654       __ z_cr(Rsrc2, Rsrc1);      // Move src1 only if src2 is NotLow.
 8655       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotLow);
 8656     } else {
 8657       // Rdst is disjoint from operands, move in either case.
 8658       __ z_cr(Rsrc1, Rsrc2);
 8659       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8660       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8661     }
 8662   %}
 8663   ins_pipe(pipe_class_dummy);
 8664 %}
 8665 
 8666 // Min Register with Register.
 8667 instruct z10_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8668   match(Set dst (MinI src1 src2));
 8669   effect(KILL cr);
 8670   predicate(VM_Version::has_CompareBranch());
 8671   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8672   // TODO: s390 port size(VARIABLE_SIZE);
 8673   format %{ &quot;MinI $dst $src1,$src2\t MinI (z10 only)&quot; %}
 8674   ins_encode %{
 8675     Register Rdst = $dst$$Register;
 8676     Register Rsrc1 = $src1$$Register;
 8677     Register Rsrc2 = $src2$$Register;
 8678     Label done;
 8679 
 8680     if (Rsrc1 == Rsrc2) {
 8681       if (Rdst != Rsrc1) {
 8682         __ z_lgfr(Rdst, Rsrc1);
 8683       }
 8684     } else if (Rdst == Rsrc1) {
 8685       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8686       __ z_lgfr(Rdst, Rsrc2);
 8687     } else if (Rdst == Rsrc2) {
 8688       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondLow, done);
 8689       __ z_lgfr(Rdst, Rsrc1);
 8690     } else {
 8691       __ z_lgfr(Rdst, Rsrc1);
 8692       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8693       __ z_lgfr(Rdst, Rsrc2);
 8694     }
 8695     __ bind(done);
 8696   %}
 8697   ins_pipe(pipe_class_dummy);
 8698 %}
 8699 
 8700 instruct minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8701   match(Set dst (MinI src1 src2));
 8702   effect(KILL cr);
 8703   predicate(!VM_Version::has_CompareBranch());
 8704   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8705   // TODO: s390 port size(VARIABLE_SIZE);
 8706   format %{ &quot;MinI $dst $src1,$src2\t MinI&quot; %}
 8707   ins_encode %{
 8708     Register Rdst = $dst$$Register;
 8709     Register Rsrc1 = $src1$$Register;
 8710     Register Rsrc2 = $src2$$Register;
 8711     Label done;
 8712 
 8713     if (Rsrc1 == Rsrc2) {
 8714       if (Rdst != Rsrc1) {
 8715         __ z_lgfr(Rdst, Rsrc1);
 8716       }
 8717     } else if (Rdst == Rsrc1) {
 8718       __ z_cr(Rsrc1, Rsrc2);
 8719       __ z_brl(done);
 8720       __ z_lgfr(Rdst, Rsrc2);
 8721     } else if (Rdst == Rsrc2) {
 8722       __ z_cr(Rsrc2, Rsrc1);
 8723       __ z_brl(done);
 8724       __ z_lgfr(Rdst, Rsrc1);
 8725     } else {
 8726       __ z_lgfr(Rdst, Rsrc1);
 8727       __ z_cr(Rsrc1, Rsrc2);
 8728       __ z_brl(done);
 8729       __ z_lgfr(Rdst, Rsrc2);
 8730     }
 8731     __ bind(done);
 8732   %}
 8733   ins_pipe(pipe_class_dummy);
 8734 %}
 8735 
 8736 instruct z196_minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8737   match(Set dst (MinI src1 src2));
 8738   effect(KILL cr);
 8739   predicate(VM_Version::has_LoadStoreConditional());
 8740   ins_cost(3 * DEFAULT_COST);
 8741   // TODO: s390 port size(VARIABLE_SIZE);
 8742   format %{ &quot;MinI $dst $src1,$src2\t MinI const32 (z196 only)&quot; %}
 8743   ins_encode %{
 8744     Register Rdst = $dst$$Register;
 8745     Register Rsrc1 = $src1$$Register;
 8746     int      Isrc2 = $src2$$constant;
 8747 
 8748     if (Rdst == Rsrc1) {
 8749       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8750       __ z_cfi(Rsrc1, Isrc2);
 8751       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8752     } else {
 8753       __ load_const_optimized(Rdst, Isrc2);
 8754       __ z_cfi(Rsrc1, Isrc2);
 8755       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8756     }
 8757   %}
 8758   ins_pipe(pipe_class_dummy);
 8759 %}
 8760 
 8761 instruct minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8762   match(Set dst (MinI src1 src2));
 8763   effect(KILL cr);
 8764   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8765   // TODO: s390 port size(VARIABLE_SIZE);
 8766   format %{ &quot;MinI $dst $src1,$src2\t MinI const32&quot; %}
 8767   ins_encode %{
 8768     Label done;
 8769     if ($dst$$Register != $src1$$Register) {
 8770       __ z_lgfr($dst$$Register, $src1$$Register);
 8771     }
 8772     __ z_cfi($src1$$Register, $src2$$constant);
 8773     __ z_brl(done);
 8774     __ z_lgfi($dst$$Register, $src2$$constant);
 8775     __ bind(done);
 8776   %}
 8777   ins_pipe(pipe_class_dummy);
 8778 %}
 8779 
 8780 instruct z196_minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8781   match(Set dst (MinI src1 src2));
 8782   effect(KILL cr);
 8783   predicate(VM_Version::has_LoadStoreConditional());
 8784   ins_cost(3 * DEFAULT_COST);
 8785   // TODO: s390 port size(VARIABLE_SIZE);
 8786   format %{ &quot;MinI $dst $src1,$src2\t MinI const16 (z196 only)&quot; %}
 8787   ins_encode %{
 8788     Register Rdst = $dst$$Register;
 8789     Register Rsrc1 = $src1$$Register;
 8790     int      Isrc2 = $src2$$constant;
 8791 
 8792     if (Rdst == Rsrc1) {
 8793       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8794       __ z_chi(Rsrc1, Isrc2);
 8795       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8796     } else {
 8797       __ load_const_optimized(Rdst, Isrc2);
 8798       __ z_chi(Rsrc1, Isrc2);
 8799       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8800     }
 8801   %}
 8802   ins_pipe(pipe_class_dummy);
 8803 %}
 8804 
 8805 instruct minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8806   match(Set dst (MinI src1 src2));
 8807   effect(KILL cr);
 8808   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8809   // TODO: s390 port size(VARIABLE_SIZE);
 8810   format %{ &quot;MinI $dst $src1,$src2\t MinI const16&quot; %}
 8811   ins_encode %{
 8812     Label done;
 8813     if ($dst$$Register != $src1$$Register) {
 8814       __ z_lgfr($dst$$Register, $src1$$Register);
 8815     }
 8816     __ z_chi($src1$$Register, $src2$$constant);
 8817     __ z_brl(done);
 8818     __ z_lghi($dst$$Register, $src2$$constant);
 8819     __ bind(done);
 8820   %}
 8821   ins_pipe(pipe_class_dummy);
 8822 %}
 8823 
 8824 instruct z10_minI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8825   match(Set dst (MinI src1 src2));
 8826   effect(KILL cr);
 8827   predicate(VM_Version::has_CompareBranch());
 8828   ins_cost(DEFAULT_COST + BRANCH_COST);
 8829   // TODO: s390 port size(VARIABLE_SIZE);
 8830   format %{ &quot;MinI $dst $src1,$src2\t MinI const8 (z10 only)&quot; %}
 8831   ins_encode %{
 8832     Label done;
 8833     if ($dst$$Register != $src1$$Register) {
 8834       __ z_lgfr($dst$$Register, $src1$$Register);
 8835     }
 8836     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondLow, done);
 8837     __ z_lghi($dst$$Register, $src2$$constant);
 8838     __ bind(done);
 8839   %}
 8840   ins_pipe(pipe_class_dummy);
 8841 %}
 8842 
 8843 // Max Register with Register
 8844 instruct z196_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8845   match(Set dst (MaxI src1 src2));
 8846   effect(KILL cr);
 8847   predicate(VM_Version::has_LoadStoreConditional());
 8848   ins_cost(3 * DEFAULT_COST);
 8849   // TODO: s390 port size(VARIABLE_SIZE);
 8850   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z196 only)&quot; %}
 8851   ins_encode %{
 8852     Register Rdst = $dst$$Register;
 8853     Register Rsrc1 = $src1$$Register;
 8854     Register Rsrc2 = $src2$$Register;
 8855 
 8856     if (Rsrc1 == Rsrc2) {
 8857       if (Rdst != Rsrc1) {
 8858         __ z_lgfr(Rdst, Rsrc1);
 8859       }
 8860     } else if (Rdst == Rsrc1) { // Rdst preset with src1.
 8861       __ z_cr(Rsrc1, Rsrc2);    // Move src2 only if src1 is NotHigh.
 8862       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8863     } else if (Rdst == Rsrc2) { // Rdst preset with src2.
 8864       __ z_cr(Rsrc2, Rsrc1);    // Move src1 only if src2 is NotHigh.
 8865       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotHigh);
 8866     } else {                    // Rdst is disjoint from operands, move in either case.
 8867       __ z_cr(Rsrc1, Rsrc2);
 8868       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8869       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8870     }
 8871   %}
 8872   ins_pipe(pipe_class_dummy);
 8873 %}
 8874 
 8875 // Max Register with Register
 8876 instruct z10_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8877   match(Set dst (MaxI src1 src2));
 8878   effect(KILL cr);
 8879   predicate(VM_Version::has_CompareBranch());
 8880   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8881   // TODO: s390 port size(VARIABLE_SIZE);
 8882   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z10 only)&quot; %}
 8883   ins_encode %{
 8884     Register Rdst = $dst$$Register;
 8885     Register Rsrc1 = $src1$$Register;
 8886     Register Rsrc2 = $src2$$Register;
 8887     Label done;
 8888 
 8889     if (Rsrc1 == Rsrc2) {
 8890       if (Rdst != Rsrc1) {
 8891         __ z_lgfr(Rdst, Rsrc1);
 8892       }
 8893     } else if (Rdst == Rsrc1) {
 8894       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8895       __ z_lgfr(Rdst, Rsrc2);
 8896     } else if (Rdst == Rsrc2) {
 8897       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondHigh, done);
 8898       __ z_lgfr(Rdst, Rsrc1);
 8899     } else {
 8900       __ z_lgfr(Rdst, Rsrc1);
 8901       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8902       __ z_lgfr(Rdst, Rsrc2);
 8903     }
 8904     __ bind(done);
 8905   %}
 8906   ins_pipe(pipe_class_dummy);
 8907 %}
 8908 
 8909 instruct maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8910   match(Set dst (MaxI src1 src2));
 8911   effect(KILL cr);
 8912   predicate(!VM_Version::has_CompareBranch());
 8913   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8914   // TODO: s390 port size(VARIABLE_SIZE);
 8915   format %{ &quot;MaxI $dst $src1,$src2\t MaxI&quot; %}
 8916   ins_encode %{
 8917     Register Rdst = $dst$$Register;
 8918     Register Rsrc1 = $src1$$Register;
 8919     Register Rsrc2 = $src2$$Register;
 8920     Label done;
 8921 
 8922     if (Rsrc1 == Rsrc2) {
 8923       if (Rdst != Rsrc1) {
 8924         __ z_lgfr(Rdst, Rsrc1);
 8925       }
 8926     } else if (Rdst == Rsrc1) {
 8927       __ z_cr(Rsrc1, Rsrc2);
 8928       __ z_brh(done);
 8929       __ z_lgfr(Rdst, Rsrc2);
 8930     } else if (Rdst == Rsrc2) {
 8931       __ z_cr(Rsrc2, Rsrc1);
 8932       __ z_brh(done);
 8933       __ z_lgfr(Rdst, Rsrc1);
 8934     } else {
 8935       __ z_lgfr(Rdst, Rsrc1);
 8936       __ z_cr(Rsrc1, Rsrc2);
 8937       __ z_brh(done);
 8938       __ z_lgfr(Rdst, Rsrc2);
 8939     }
 8940 
 8941     __ bind(done);
 8942   %}
 8943 
 8944   ins_pipe(pipe_class_dummy);
 8945 %}
 8946 
 8947 instruct z196_maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8948   match(Set dst (MaxI src1 src2));
 8949   effect(KILL cr);
 8950   predicate(VM_Version::has_LoadStoreConditional());
 8951   ins_cost(3 * DEFAULT_COST);
 8952   // TODO: s390 port size(VARIABLE_SIZE);
 8953   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32 (z196 only)&quot; %}
 8954   ins_encode %{
 8955     Register Rdst = $dst$$Register;
 8956     Register Rsrc1 = $src1$$Register;
 8957     int      Isrc2 = $src2$$constant;
 8958 
 8959     if (Rdst == Rsrc1) {
 8960       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8961       __ z_cfi(Rsrc1, Isrc2);
 8962       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8963     } else {
 8964       __ load_const_optimized(Rdst, Isrc2);
 8965       __ z_cfi(Rsrc1, Isrc2);
 8966       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8967     }
 8968   %}
 8969   ins_pipe(pipe_class_dummy);
 8970 %}
 8971 
 8972 instruct maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8973   match(Set dst (MaxI src1 src2));
 8974   effect(KILL cr);
 8975   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8976   // TODO: s390 port size(VARIABLE_SIZE);
 8977   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32&quot; %}
 8978   ins_encode %{
 8979     Label done;
 8980     if ($dst$$Register != $src1$$Register) {
 8981       __ z_lgfr($dst$$Register, $src1$$Register);
 8982     }
 8983     __ z_cfi($src1$$Register, $src2$$constant);
 8984     __ z_brh(done);
 8985     __ z_lgfi($dst$$Register, $src2$$constant);
 8986     __ bind(done);
 8987   %}
 8988   ins_pipe(pipe_class_dummy);
 8989 %}
 8990 
 8991 instruct z196_maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8992   match(Set dst (MaxI src1 src2));
 8993   effect(KILL cr);
 8994   predicate(VM_Version::has_LoadStoreConditional());
 8995   ins_cost(3 * DEFAULT_COST);
 8996   // TODO: s390 port size(VARIABLE_SIZE);
 8997   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16 (z196 only)&quot; %}
 8998   ins_encode %{
 8999     Register Rdst = $dst$$Register;
 9000     Register Rsrc1 = $src1$$Register;
 9001     int      Isrc2 = $src2$$constant;
 9002     if (Rdst == Rsrc1) {
 9003       __ load_const_optimized(Z_R0_scratch, Isrc2);
 9004       __ z_chi(Rsrc1, Isrc2);
 9005       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 9006     } else {
 9007       __ load_const_optimized(Rdst, Isrc2);
 9008       __ z_chi(Rsrc1, Isrc2);
 9009       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 9010     }
 9011   %}
 9012   ins_pipe(pipe_class_dummy);
 9013 %}
 9014 
 9015 instruct maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 9016   match(Set dst (MaxI src1 src2));
 9017   effect(KILL cr);
 9018   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 9019   // TODO: s390 port size(VARIABLE_SIZE);
 9020   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16&quot; %}
 9021   ins_encode %{
 9022     Label done;
 9023     if ($dst$$Register != $src1$$Register) {
 9024       __ z_lgfr($dst$$Register, $src1$$Register);
 9025     }
 9026     __ z_chi($src1$$Register, $src2$$constant);
 9027     __ z_brh(done);
 9028     __ z_lghi($dst$$Register, $src2$$constant);
 9029     __ bind(done);
 9030   %}
 9031   ins_pipe(pipe_class_dummy);
 9032 %}
 9033 
 9034 instruct z10_maxI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 9035   match(Set dst (MaxI src1 src2));
 9036   effect(KILL cr);
 9037   predicate(VM_Version::has_CompareBranch());
 9038   ins_cost(DEFAULT_COST + BRANCH_COST);
 9039   // TODO: s390 port size(VARIABLE_SIZE);
 9040   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const8&quot; %}
 9041   ins_encode %{
 9042     Label done;
 9043     if ($dst$$Register != $src1$$Register) {
 9044       __ z_lgfr($dst$$Register, $src1$$Register);
 9045     }
 9046     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondHigh, done);
 9047     __ z_lghi($dst$$Register, $src2$$constant);
 9048     __ bind(done);
 9049   %}
 9050   ins_pipe(pipe_class_dummy);
 9051 %}
 9052 
 9053 //----------Abs---------------------------------------------------------------
 9054 
 9055 instruct absI_reg(iRegI dst, iRegI src, flagsReg cr) %{
 9056   match(Set dst (AbsI src));
 9057   effect(KILL cr);
 9058   ins_cost(DEFAULT_COST_LOW);
 9059   // TODO: s390 port size(FIXED_SIZE);
 9060   format %{ &quot;LPR     $dst, $src&quot; %}
 9061   opcode(LPR_ZOPC);
 9062   ins_encode(z_rrform(dst, src));
 9063   ins_pipe(pipe_class_dummy);
 9064 %}
 9065 
 9066 instruct negabsI_reg(iRegI dst, iRegI src, immI_0 zero, flagsReg cr) %{
 9067   match(Set dst (SubI zero (AbsI src)));
 9068   effect(KILL cr);
 9069   ins_cost(DEFAULT_COST_LOW);
 9070   // TODO: s390 port size(FIXED_SIZE);
 9071   format %{ &quot;LNR     $dst, $src&quot; %}
 9072   opcode(LNR_ZOPC);
 9073   ins_encode(z_rrform(dst, src));
 9074   ins_pipe(pipe_class_dummy);
 9075 %}
 9076 
 9077 //----------Float Compares----------------------------------------------------
 9078 
 9079 // Compare floating, generate condition code.
 9080 instruct cmpF_cc(flagsReg cr, regF src1, regF src2) %{
 9081   match(Set cr (CmpF src1 src2));
 9082   ins_cost(ALU_REG_COST);
 9083   size(4);
 9084   format %{ &quot;FCMPcc   $src1,$src2\t # float&quot; %}
 9085   ins_encode %{ __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9086   ins_pipe(pipe_class_dummy);
 9087 %}
 9088 
 9089 instruct cmpD_cc(flagsReg cr, regD src1, regD src2) %{
 9090   match(Set cr (CmpD src1 src2));
 9091   ins_cost(ALU_REG_COST);
 9092   size(4);
 9093   format %{ &quot;FCMPcc   $src1,$src2 \t # double&quot; %}
 9094   ins_encode %{ __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9095   ins_pipe(pipe_class_dummy);
 9096 %}
 9097 
 9098 instruct cmpF_cc_mem(flagsReg cr, regF src1, memoryRX src2) %{
 9099   match(Set cr (CmpF src1 (LoadF src2)));
 9100   ins_cost(ALU_MEMORY_COST);
 9101   size(6);
 9102   format %{ &quot;FCMPcc_mem $src1,$src2\t # floatMemory&quot; %}
 9103   opcode(CEB_ZOPC);
 9104   ins_encode(z_form_rt_memFP(src1, src2));
 9105   ins_pipe(pipe_class_dummy);
 9106 %}
 9107 
 9108 instruct cmpD_cc_mem(flagsReg cr, regD src1, memoryRX src2) %{
 9109   match(Set cr (CmpD src1 (LoadD src2)));
 9110   ins_cost(ALU_MEMORY_COST);
 9111   size(6);
 9112   format %{ &quot;DCMPcc_mem $src1,$src2\t # doubleMemory&quot; %}
 9113   opcode(CDB_ZOPC);
 9114   ins_encode(z_form_rt_memFP(src1, src2));
 9115   ins_pipe(pipe_class_dummy);
 9116 %}
 9117 
 9118 // Compare floating, generate condition code
 9119 instruct cmpF0_cc(flagsReg cr, regF src1, immFpm0 src2) %{
 9120   match(Set cr (CmpF src1 src2));
 9121   ins_cost(DEFAULT_COST);
 9122   size(4);
 9123   format %{ &quot;LTEBR    $src1,$src1\t # float&quot; %}
 9124   opcode(LTEBR_ZOPC);
 9125   ins_encode(z_rreform(src1, src1));
 9126   ins_pipe(pipe_class_dummy);
 9127 %}
 9128 
 9129 instruct cmpD0_cc(flagsReg cr, regD src1, immDpm0 src2) %{
 9130   match(Set cr (CmpD src1 src2));
 9131   ins_cost(DEFAULT_COST);
 9132   size(4);
 9133   format %{ &quot;LTDBR    $src1,$src1 \t # double&quot; %}
 9134   opcode(LTDBR_ZOPC);
 9135   ins_encode(z_rreform(src1, src1));
 9136   ins_pipe(pipe_class_dummy);
 9137 %}
 9138 
 9139 // Compare floating, generate -1,0,1
 9140 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsReg cr) %{
 9141   match(Set dst (CmpF3 src1 src2));
 9142   effect(KILL cr);
 9143   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9144   size(24);
 9145   format %{ &quot;CmpF3    $dst,$src1,$src2&quot; %}
 9146   ins_encode %{
 9147     // compare registers
 9148     __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister);
 9149     // Convert condition code into -1,0,1, where
 9150     // -1 means unordered or less
 9151     //  0 means equal
 9152     //  1 means greater.
 9153     if (VM_Version::has_LoadStoreConditional()) {
 9154       Register one       = Z_R0_scratch;
 9155       Register minus_one = Z_R1_scratch;
 9156       __ z_lghi(minus_one, -1);
 9157       __ z_lghi(one, 1);
 9158       __ z_lghi( $dst$$Register, 0);
 9159       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9160       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9161     } else {
 9162       Label done;
 9163       __ clear_reg($dst$$Register, true, false);
 9164       __ z_bre(done);
 9165       __ z_lhi($dst$$Register, 1);
 9166       __ z_brh(done);
 9167       __ z_lhi($dst$$Register, -1);
 9168       __ bind(done);
 9169     }
 9170   %}
 9171   ins_pipe(pipe_class_dummy);
 9172 %}
 9173 
 9174 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsReg cr) %{
 9175   match(Set dst (CmpD3 src1 src2));
 9176   effect(KILL cr);
 9177   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9178   size(24);
 9179   format %{ &quot;CmpD3    $dst,$src1,$src2&quot; %}
 9180   ins_encode %{
 9181     // compare registers
 9182     __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister);
 9183     // Convert condition code into -1,0,1, where
 9184     // -1 means unordered or less
 9185     //  0 means equal
 9186     //  1 means greater.
 9187     if (VM_Version::has_LoadStoreConditional()) {
 9188       Register one       = Z_R0_scratch;
 9189       Register minus_one = Z_R1_scratch;
 9190       __ z_lghi(minus_one, -1);
 9191       __ z_lghi(one, 1);
 9192       __ z_lghi( $dst$$Register, 0);
 9193       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9194       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9195     } else {
 9196       Label done;
 9197       // indicate unused result
 9198       (void) __ clear_reg($dst$$Register, true, false);
 9199       __ z_bre(done);
 9200       __ z_lhi($dst$$Register, 1);
 9201       __ z_brh(done);
 9202       __ z_lhi($dst$$Register, -1);
 9203       __ bind(done);
 9204     }
 9205   %}
 9206   ins_pipe(pipe_class_dummy);
 9207 %}
 9208 
 9209 //----------Branches---------------------------------------------------------
 9210 // Jump
 9211 
 9212 // Direct Branch.
 9213 instruct branch(label labl) %{
 9214   match(Goto);
 9215   effect(USE labl);
 9216   ins_cost(BRANCH_COST);
 9217   size(4);
 9218   format %{ &quot;BRU     $labl&quot; %}
 9219   ins_encode(z_enc_bru(labl));
 9220   ins_pipe(pipe_class_dummy);
 9221   // If set to 1 this indicates that the current instruction is a
 9222   // short variant of a long branch. This avoids using this
 9223   // instruction in first-pass matching. It will then only be used in
 9224   // the `Shorten_branches&#39; pass.
 9225   ins_short_branch(1);
 9226 %}
 9227 
 9228 // Direct Branch.
 9229 instruct branchFar(label labl) %{
 9230   match(Goto);
 9231   effect(USE labl);
 9232   ins_cost(BRANCH_COST);
 9233   size(6);
 9234   format %{ &quot;BRUL   $labl&quot; %}
 9235   ins_encode(z_enc_brul(labl));
 9236   ins_pipe(pipe_class_dummy);
 9237   // This is not a short variant of a branch, but the long variant.
 9238   ins_short_branch(0);
 9239 %}
 9240 
 9241 // Conditional Near Branch
 9242 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9243   // Same match rule as `branchConFar&#39;.
 9244   match(If cmp cr);
 9245   effect(USE lbl);
 9246   ins_cost(BRANCH_COST);
 9247   size(4);
 9248   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}
 9249   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9250   ins_pipe(pipe_class_dummy);
 9251   // If set to 1 this indicates that the current instruction is a
 9252   // short variant of a long branch. This avoids using this
 9253   // instruction in first-pass matching. It will then only be used in
 9254   // the `Shorten_branches&#39; pass.
 9255   ins_short_branch(1);
 9256 %}
 9257 
 9258 // This is for cases when the z/Architecture conditional branch instruction
 9259 // does not reach far enough. So we emit a far branch here, which is
 9260 // more expensive.
 9261 //
 9262 // Conditional Far Branch
 9263 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9264   // Same match rule as `branchCon&#39;.
 9265   match(If cmp cr);
 9266   effect(USE cr, USE lbl);
 9267   // Make more expensive to prefer compare_and_branch over separate instructions.
 9268   ins_cost(2 * BRANCH_COST);
 9269   size(6);
 9270   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}
 9271   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9272   ins_pipe(pipe_class_dummy);
 9273   // This is not a short variant of a branch, but the long variant..
 9274   ins_short_branch(0);
 9275 %}
 9276 
 9277 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9278   match(CountedLoopEnd cmp cr);
 9279   effect(USE labl);
 9280   ins_cost(BRANCH_COST);
 9281   size(4);
 9282   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9283   ins_encode(z_enc_branch_con_short(cmp, labl));
 9284   ins_pipe(pipe_class_dummy);
 9285   // If set to 1 this indicates that the current instruction is a
 9286   // short variant of a long branch. This avoids using this
 9287   // instruction in first-pass matching. It will then only be used in
 9288   // the `Shorten_branches&#39; pass.
 9289   ins_short_branch(1);
 9290 %}
 9291 
 9292 instruct branchLoopEndFar(cmpOp cmp, flagsReg cr, label labl) %{
 9293   match(CountedLoopEnd cmp cr);
 9294   effect(USE labl);
 9295   ins_cost(BRANCH_COST);
 9296   size(6);
 9297   format %{ &quot;branch_con_far,$cmp   $labl\t # counted loop end&quot; %}
 9298   ins_encode(z_enc_branch_con_far(cmp, labl));
 9299   ins_pipe(pipe_class_dummy);
 9300   // This is not a short variant of a branch, but the long variant.
 9301   ins_short_branch(0);
 9302 %}
 9303 
 9304 //----------Compare and Branch (short distance)------------------------------
 9305 
 9306 // INT REG operands for loop counter processing.
 9307 instruct testAndBranchLoopEnd_Reg(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9308   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9309   effect(USE labl, KILL cr);
 9310   predicate(VM_Version::has_CompareBranch());
 9311   ins_cost(BRANCH_COST);
 9312   // TODO: s390 port size(FIXED_SIZE);
 9313   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9314   opcode(CRJ_ZOPC);
 9315   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9316   ins_pipe(pipe_class_dummy);
 9317   ins_short_branch(1);
 9318 %}
 9319 
 9320 // INT REG operands.
 9321 instruct cmpb_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9322   match(If boolnode (CmpI src1 src2));
 9323   effect(USE labl, KILL cr);
 9324   predicate(VM_Version::has_CompareBranch());
 9325   ins_cost(BRANCH_COST);
 9326   // TODO: s390 port size(FIXED_SIZE);
 9327   format %{ &quot;CRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9328   opcode(CRJ_ZOPC);
 9329   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9330   ins_pipe(pipe_class_dummy);
 9331   ins_short_branch(1);
 9332 %}
 9333 
 9334 // Unsigned INT REG operands
 9335 instruct cmpbU_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9336   match(If boolnode (CmpU src1 src2));
 9337   effect(USE labl, KILL cr);
 9338   predicate(VM_Version::has_CompareBranch());
 9339   ins_cost(BRANCH_COST);
 9340   // TODO: s390 port size(FIXED_SIZE);
 9341   format %{ &quot;CLRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9342   opcode(CLRJ_ZOPC);
 9343   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9344   ins_pipe(pipe_class_dummy);
 9345   ins_short_branch(1);
 9346 %}
 9347 
 9348 // LONG REG operands
 9349 instruct cmpb_RegL(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9350   match(If boolnode (CmpL src1 src2));
 9351   effect(USE labl, KILL cr);
 9352   predicate(VM_Version::has_CompareBranch());
 9353   ins_cost(BRANCH_COST);
 9354   // TODO: s390 port size(FIXED_SIZE);
 9355   format %{ &quot;CGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9356   opcode(CGRJ_ZOPC);
 9357   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9358   ins_pipe(pipe_class_dummy);
 9359   ins_short_branch(1);
 9360 %}
 9361 
 9362 //  PTR REG operands
 9363 
 9364 // Separate rules for regular and narrow oops.  ADLC can&#39;t recognize
 9365 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9366 // will not shorten.
 9367 
 9368 instruct cmpb_RegPP(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9369   match(If boolnode (CmpP src1 src2));
 9370   effect(USE labl, KILL cr);
 9371   predicate(VM_Version::has_CompareBranch());
 9372   ins_cost(BRANCH_COST);
 9373   // TODO: s390 port size(FIXED_SIZE);
 9374   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9375   opcode(CLGRJ_ZOPC);
 9376   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9377   ins_pipe(pipe_class_dummy);
 9378   ins_short_branch(1);
 9379 %}
 9380 
 9381 instruct cmpb_RegNN(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9382   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9383   effect(USE labl, KILL cr);
 9384   predicate(VM_Version::has_CompareBranch());
 9385   ins_cost(BRANCH_COST);
 9386   // TODO: s390 port size(FIXED_SIZE);
 9387   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9388   opcode(CLGRJ_ZOPC);
 9389   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9390   ins_pipe(pipe_class_dummy);
 9391   ins_short_branch(1);
 9392 %}
 9393 
 9394 // INT REG/IMM operands for loop counter processing
 9395 instruct testAndBranchLoopEnd_Imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9396   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9397   effect(USE labl, KILL cr);
 9398   predicate(VM_Version::has_CompareBranch());
 9399   ins_cost(BRANCH_COST);
 9400   // TODO: s390 port size(FIXED_SIZE);
 9401   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9402   opcode(CIJ_ZOPC);
 9403   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9404   ins_pipe(pipe_class_dummy);
 9405   ins_short_branch(1);
 9406 %}
 9407 
 9408 // INT REG/IMM operands
 9409 instruct cmpb_RegI_imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9410   match(If boolnode (CmpI src1 src2));
 9411   effect(USE labl, KILL cr);
 9412   predicate(VM_Version::has_CompareBranch());
 9413   ins_cost(BRANCH_COST);
 9414   // TODO: s390 port size(FIXED_SIZE);
 9415   format %{ &quot;CIJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9416   opcode(CIJ_ZOPC);
 9417   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9418   ins_pipe(pipe_class_dummy);
 9419   ins_short_branch(1);
 9420 %}
 9421 
 9422 // INT REG/IMM operands
 9423 instruct cmpbU_RegI_imm(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9424   match(If boolnode (CmpU src1 src2));
 9425   effect(USE labl, KILL cr);
 9426   predicate(VM_Version::has_CompareBranch());
 9427   ins_cost(BRANCH_COST);
 9428   // TODO: s390 port size(FIXED_SIZE);
 9429   format %{ &quot;CLIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9430   opcode(CLIJ_ZOPC);
 9431   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9432   ins_pipe(pipe_class_dummy);
 9433   ins_short_branch(1);
 9434 %}
 9435 
 9436 // LONG REG/IMM operands
 9437 instruct cmpb_RegL_imm(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9438   match(If boolnode (CmpL src1 src2));
 9439   effect(USE labl, KILL cr);
 9440   predicate(VM_Version::has_CompareBranch());
 9441   ins_cost(BRANCH_COST);
 9442   // TODO: s390 port size(FIXED_SIZE);
 9443   format %{ &quot;CGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9444   opcode(CGIJ_ZOPC);
 9445   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9446   ins_pipe(pipe_class_dummy);
 9447   ins_short_branch(1);
 9448 %}
 9449 
 9450 // PTR REG-imm operands
 9451 
 9452 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9453 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9454 // will not shorten.
 9455 
 9456 instruct cmpb_RegP_immP(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9457   match(If boolnode (CmpP src1 src2));
 9458   effect(USE labl, KILL cr);
 9459   predicate(VM_Version::has_CompareBranch());
 9460   ins_cost(BRANCH_COST);
 9461   // TODO: s390 port size(FIXED_SIZE);
 9462   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9463   opcode(CLGIJ_ZOPC);
 9464   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9465   ins_pipe(pipe_class_dummy);
 9466   ins_short_branch(1);
 9467 %}
 9468 
 9469 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9470 instruct cmpb_RegN_immP0(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9471   match(If boolnode (CmpP (DecodeN src1) src2));
 9472   effect(USE labl, KILL cr);
 9473   predicate(VM_Version::has_CompareBranch());
 9474   ins_cost(BRANCH_COST);
 9475   // TODO: s390 port size(FIXED_SIZE);
 9476   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9477   opcode(CLGIJ_ZOPC);
 9478   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9479   ins_pipe(pipe_class_dummy);
 9480   ins_short_branch(1);
 9481 %}
 9482 
 9483 instruct cmpb_RegN_imm(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9484   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9485   effect(USE labl, KILL cr);
 9486   predicate(VM_Version::has_CompareBranch());
 9487   ins_cost(BRANCH_COST);
 9488   // TODO: s390 port size(FIXED_SIZE);
 9489   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9490   opcode(CLGIJ_ZOPC);
 9491   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9492   ins_pipe(pipe_class_dummy);
 9493   ins_short_branch(1);
 9494 %}
 9495 
 9496 
 9497 //----------Compare and Branch (far distance)------------------------------
 9498 
 9499 // INT REG operands for loop counter processing
 9500 instruct testAndBranchLoopEnd_RegFar(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9501   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9502   effect(USE labl, KILL cr);
 9503   predicate(VM_Version::has_CompareBranch());
 9504   ins_cost(BRANCH_COST+DEFAULT_COST);
 9505   // TODO: s390 port size(FIXED_SIZE);
 9506   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9507   opcode(CR_ZOPC, BRCL_ZOPC);
 9508   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9509   ins_pipe(pipe_class_dummy);
 9510   ins_short_branch(0);
 9511 %}
 9512 
 9513 // INT REG operands
 9514 instruct cmpb_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9515   match(If boolnode (CmpI src1 src2));
 9516   effect(USE labl, KILL cr);
 9517   predicate(VM_Version::has_CompareBranch());
 9518   ins_cost(BRANCH_COST+DEFAULT_COST);
 9519   // TODO: s390 port size(FIXED_SIZE);
 9520   format %{ &quot;CRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9521   opcode(CR_ZOPC, BRCL_ZOPC);
 9522   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9523   ins_pipe(pipe_class_dummy);
 9524   ins_short_branch(0);
 9525 %}
 9526 
 9527 // INT REG operands
 9528 instruct cmpbU_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9529   match(If boolnode (CmpU src1 src2));
 9530   effect(USE labl, KILL cr);
 9531   predicate(VM_Version::has_CompareBranch());
 9532   ins_cost(BRANCH_COST+DEFAULT_COST);
 9533   // TODO: s390 port size(FIXED_SIZE);
 9534   format %{ &quot;CLRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9535   opcode(CLR_ZOPC, BRCL_ZOPC);
 9536   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9537   ins_pipe(pipe_class_dummy);
 9538   ins_short_branch(0);
 9539 %}
 9540 
 9541 // LONG REG operands
 9542 instruct cmpb_RegL_Far(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9543   match(If boolnode (CmpL src1 src2));
 9544   effect(USE labl, KILL cr);
 9545   predicate(VM_Version::has_CompareBranch());
 9546   ins_cost(BRANCH_COST+DEFAULT_COST);
 9547   // TODO: s390 port size(FIXED_SIZE);
 9548   format %{ &quot;CGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9549   opcode(CGR_ZOPC, BRCL_ZOPC);
 9550   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9551   ins_pipe(pipe_class_dummy);
 9552   ins_short_branch(0);
 9553 %}
 9554 
 9555 // PTR REG operands
 9556 
 9557 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9558 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9559 // will not shorten.
 9560 
 9561 instruct cmpb_RegPP_Far(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9562   match(If boolnode (CmpP src1 src2));
 9563   effect(USE labl, KILL cr);
 9564   predicate(VM_Version::has_CompareBranch());
 9565   ins_cost(BRANCH_COST+DEFAULT_COST);
 9566   // TODO: s390 port size(FIXED_SIZE);
 9567   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9568   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9569   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9570   ins_pipe(pipe_class_dummy);
 9571   ins_short_branch(0);
 9572 %}
 9573 
 9574 instruct cmpb_RegNN_Far(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9575   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9576   effect(USE labl, KILL cr);
 9577   predicate(VM_Version::has_CompareBranch());
 9578   ins_cost(BRANCH_COST+DEFAULT_COST);
 9579   // TODO: s390 port size(FIXED_SIZE);
 9580   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9581   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9582   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9583   ins_pipe(pipe_class_dummy);
 9584   ins_short_branch(0);
 9585 %}
 9586 
 9587 // INT REG/IMM operands for loop counter processing
 9588 instruct testAndBranchLoopEnd_ImmFar(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9589   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9590   effect(USE labl, KILL cr);
 9591   predicate(VM_Version::has_CompareBranch());
 9592   ins_cost(BRANCH_COST+DEFAULT_COST);
 9593   // TODO: s390 port size(FIXED_SIZE);
 9594   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9595   opcode(CHI_ZOPC, BRCL_ZOPC);
 9596   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9597   ins_pipe(pipe_class_dummy);
 9598   ins_short_branch(0);
 9599 %}
 9600 
 9601 // INT REG/IMM operands
 9602 instruct cmpb_RegI_imm_Far(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9603   match(If boolnode (CmpI src1 src2));
 9604   effect(USE labl, KILL cr);
 9605   predicate(VM_Version::has_CompareBranch());
 9606   ins_cost(BRANCH_COST+DEFAULT_COST);
 9607   // TODO: s390 port size(FIXED_SIZE);
 9608   format %{ &quot;CIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9609   opcode(CHI_ZOPC, BRCL_ZOPC);
 9610   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9611   ins_pipe(pipe_class_dummy);
 9612   ins_short_branch(0);
 9613 %}
 9614 
 9615 // INT REG/IMM operands
 9616 instruct cmpbU_RegI_imm_Far(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9617   match(If boolnode (CmpU src1 src2));
 9618   effect(USE labl, KILL cr);
 9619   predicate(VM_Version::has_CompareBranch());
 9620   ins_cost(BRANCH_COST+DEFAULT_COST);
 9621   // TODO: s390 port size(FIXED_SIZE);
 9622   format %{ &quot;CLIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9623   opcode(CLFI_ZOPC, BRCL_ZOPC);
 9624   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9625   ins_pipe(pipe_class_dummy);
 9626   ins_short_branch(0);
 9627 %}
 9628 
 9629 // LONG REG/IMM operands
 9630 instruct cmpb_RegL_imm_Far(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9631   match(If boolnode (CmpL src1 src2));
 9632   effect(USE labl, KILL cr);
 9633   predicate(VM_Version::has_CompareBranch());
 9634   ins_cost(BRANCH_COST+DEFAULT_COST);
 9635   // TODO: s390 port size(FIXED_SIZE);
 9636   format %{ &quot;CGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9637   opcode(CGHI_ZOPC, BRCL_ZOPC);
 9638   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9639   ins_pipe(pipe_class_dummy);
 9640   ins_short_branch(0);
 9641 %}
 9642 
 9643 // PTR REG-imm operands
 9644 
 9645 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9646 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9647 // will not shorten.
 9648 
 9649 instruct cmpb_RegP_immP_Far(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9650   match(If boolnode (CmpP src1 src2));
 9651   effect(USE labl, KILL cr);
 9652   predicate(VM_Version::has_CompareBranch());
 9653   ins_cost(BRANCH_COST+DEFAULT_COST);
 9654   // TODO: s390 port size(FIXED_SIZE);
 9655   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9656   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9657   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9658   ins_pipe(pipe_class_dummy);
 9659   ins_short_branch(0);
 9660 %}
 9661 
 9662 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9663 instruct cmpb_RegN_immP0_Far(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9664   match(If boolnode (CmpP (DecodeN src1) src2));
 9665   effect(USE labl, KILL cr);
 9666   predicate(VM_Version::has_CompareBranch());
 9667   ins_cost(BRANCH_COST+DEFAULT_COST);
 9668   // TODO: s390 port size(FIXED_SIZE);
 9669   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9670   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9671   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9672   ins_pipe(pipe_class_dummy);
 9673   ins_short_branch(0);
 9674 %}
 9675 
 9676 instruct cmpb_RegN_immN_Far(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9677   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9678   effect(USE labl, KILL cr);
 9679   predicate(VM_Version::has_CompareBranch());
 9680   ins_cost(BRANCH_COST+DEFAULT_COST);
 9681   // TODO: s390 port size(FIXED_SIZE);
 9682   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9683   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9684   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9685   ins_pipe(pipe_class_dummy);
 9686   ins_short_branch(0);
 9687 %}
 9688 
 9689 // ============================================================================
 9690 // Long Compare
 9691 
 9692 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9693 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)). Note the
 9694 // difference between &#39;Y&#39; and &#39;0L&#39;. The tree-matches for the CmpI sections
 9695 // are collapsed internally in the ADLC&#39;s dfa-gen code. The match for
 9696 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9697 // foo match ends up with the wrong leaf. One fix is to not match both
 9698 // reg-reg and reg-zero forms of long-compare. This is unfortunate because
 9699 // both forms beat the trinary form of long-compare and both are very useful
 9700 // on platforms which have few registers.
 9701 
 9702 // Manifest a CmpL3 result in an integer register. Very painful.
 9703 // This is the test to avoid.
 9704 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr) %{
 9705   match(Set dst (CmpL3 src1 src2));
 9706   effect(KILL cr);
 9707   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9708   size(24);
 9709   format %{ &quot;CmpL3 $dst,$src1,$src2&quot; %}
 9710   ins_encode %{
 9711     Label done;
 9712     // compare registers
 9713     __ z_cgr($src1$$Register, $src2$$Register);
 9714     // Convert condition code into -1,0,1, where
 9715     // -1 means less
 9716     //  0 means equal
 9717     //  1 means greater.
 9718     if (VM_Version::has_LoadStoreConditional()) {
 9719       Register one       = Z_R0_scratch;
 9720       Register minus_one = Z_R1_scratch;
 9721       __ z_lghi(minus_one, -1);
 9722       __ z_lghi(one, 1);
 9723       __ z_lghi( $dst$$Register, 0);
 9724       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9725       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLow);
 9726     } else {
 9727       __ clear_reg($dst$$Register, true, false);
 9728       __ z_bre(done);
 9729       __ z_lhi($dst$$Register, 1);
 9730       __ z_brh(done);
 9731       __ z_lhi($dst$$Register, -1);
 9732     }
 9733     __ bind(done);
 9734   %}
 9735   ins_pipe(pipe_class_dummy);
 9736 %}
 9737 
 9738 // ============================================================================
 9739 // Safepoint Instruction
 9740 
 9741 instruct safePoint() %{
 9742   match(SafePoint);
 9743   predicate(false);
 9744   // TODO: s390 port size(FIXED_SIZE);
 9745   format %{ &quot;UNIMPLEMENTED Safepoint_ &quot; %}
 9746   ins_encode(enc_unimplemented());
 9747   ins_pipe(pipe_class_dummy);
 9748 %}
 9749 
 9750 instruct safePoint_poll(iRegP poll, flagsReg cr) %{
 9751   match(SafePoint poll);
 9752   effect(USE poll, KILL cr); // R0 is killed, too.
 9753   // TODO: s390 port size(FIXED_SIZE);
 9754   format %{ &quot;TM      #0[,$poll],#111\t # Safepoint: poll for GC&quot; %}
 9755   ins_encode %{
 9756     // Mark the code position where the load from the safepoint
 9757     // polling page was emitted as relocInfo::poll_type.
 9758     __ relocate(relocInfo::poll_type);
 9759     __ load_from_polling_page($poll$$Register);
 9760   %}
 9761   ins_pipe(pipe_class_dummy);
 9762 %}
 9763 
 9764 // ============================================================================
 9765 
 9766 // Call Instructions
 9767 
 9768 // Call Java Static Instruction
 9769 instruct CallStaticJavaDirect_dynTOC(method meth) %{
 9770   match(CallStaticJava);
 9771   effect(USE meth);
 9772   ins_cost(CALL_COST);
 9773   // TODO: s390 port size(VARIABLE_SIZE);
 9774   format %{ &quot;CALL,static dynTOC $meth; ==&gt; &quot; %}
 9775   ins_encode( z_enc_java_static_call(meth) );
 9776   ins_pipe(pipe_class_dummy);
 9777   ins_alignment(2);
 9778 %}
 9779 
 9780 // Call Java Dynamic Instruction
 9781 instruct CallDynamicJavaDirect_dynTOC(method meth) %{
 9782   match(CallDynamicJava);
 9783   effect(USE meth);
 9784   ins_cost(CALL_COST);
 9785   // TODO: s390 port size(VARIABLE_SIZE);
 9786   format %{ &quot;CALL,dynamic dynTOC $meth; ==&gt; &quot; %}
 9787   ins_encode(z_enc_java_dynamic_call(meth));
 9788   ins_pipe(pipe_class_dummy);
 9789   ins_alignment(2);
 9790 %}
 9791 
 9792 // Call Runtime Instruction
 9793 instruct CallRuntimeDirect(method meth) %{
 9794   match(CallRuntime);
 9795   effect(USE meth);
 9796   ins_cost(CALL_COST);
 9797   // TODO: s390 port size(VARIABLE_SIZE);
 9798   ins_num_consts(1);
 9799   ins_alignment(2);
 9800   format %{ &quot;CALL,runtime&quot; %}
 9801   ins_encode( z_enc_java_to_runtime_call(meth) );
 9802   ins_pipe(pipe_class_dummy);
 9803 %}
 9804 
 9805 // Call runtime without safepoint - same as CallRuntime
 9806 instruct CallLeafDirect(method meth) %{
 9807   match(CallLeaf);
 9808   effect(USE meth);
 9809   ins_cost(CALL_COST);
 9810   // TODO: s390 port size(VARIABLE_SIZE);
 9811   ins_num_consts(1);
 9812   ins_alignment(2);
 9813   format %{ &quot;CALL,runtime leaf $meth&quot; %}
 9814   ins_encode( z_enc_java_to_runtime_call(meth) );
 9815   ins_pipe(pipe_class_dummy);
 9816 %}
 9817 
 9818 // Call runtime without safepoint - same as CallLeaf
 9819 instruct CallLeafNoFPDirect(method meth) %{
 9820   match(CallLeafNoFP);
 9821   effect(USE meth);
 9822   ins_cost(CALL_COST);
 9823   // TODO: s390 port size(VARIABLE_SIZE);
 9824   ins_num_consts(1);
 9825   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9826   ins_encode( z_enc_java_to_runtime_call(meth) );
 9827   ins_pipe(pipe_class_dummy);
 9828   ins_alignment(2);
 9829 %}
 9830 
 9831 // Tail Call; Jump from runtime stub to Java code.
 9832 // Also known as an &#39;interprocedural jump&#39;.
 9833 // Target of jump will eventually return to caller.
 9834 // TailJump below removes the return address.
 9835 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9836   match(TailCall jump_target method_oop);
 9837   ins_cost(CALL_COST);
 9838   size(2);
 9839   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}
 9840   ins_encode %{ __ z_br($jump_target$$Register); %}
 9841   ins_pipe(pipe_class_dummy);
 9842 %}
 9843 
 9844 // Return Instruction
 9845 instruct Ret() %{
 9846   match(Return);
 9847   size(2);
 9848   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9849   ins_encode %{ __ z_br(Z_R14); %}
 9850   ins_pipe(pipe_class_dummy);
 9851 %}
 9852 
 9853 // Tail Jump; remove the return address; jump to target.
 9854 // TailCall above leaves the return address around.
 9855 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9856 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9857 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9858 // in %i0.
 9859 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
 9860   match(TailJump jump_target ex_oop);
 9861   ins_cost(CALL_COST);
 9862   size(8);
 9863   format %{ &quot;TailJump $jump_target&quot; %}
 9864   ins_encode %{
 9865     __ z_lg(Z_ARG2/* issuing pc */, _z_abi(return_pc), Z_SP);
 9866     __ z_br($jump_target$$Register);
 9867   %}
 9868   ins_pipe(pipe_class_dummy);
 9869 %}
 9870 
 9871 // Create exception oop: created by stack-crawling runtime code.
 9872 // Created exception is now available to this handler, and is setup
 9873 // just prior to jumping to this handler. No code emitted.
 9874 instruct CreateException(rarg1RegP ex_oop) %{
 9875   match(Set ex_oop (CreateEx));
 9876   ins_cost(0);
 9877   size(0);
 9878   format %{ &quot;# exception oop; no code emitted&quot; %}
 9879   ins_encode(/*empty*/);
 9880   ins_pipe(pipe_class_dummy);
 9881 %}
 9882 
 9883 // Rethrow exception: The exception oop will come in the first
 9884 // argument position. Then JUMP (not call) to the rethrow stub code.
 9885 instruct RethrowException() %{
 9886   match(Rethrow);
 9887   ins_cost(CALL_COST);
 9888   // TODO: s390 port size(VARIABLE_SIZE);
 9889   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9890   ins_encode %{
 9891     cbuf.set_insts_mark();
 9892     __ load_const_optimized(Z_R1_scratch, (address)OptoRuntime::rethrow_stub());
 9893     __ z_br(Z_R1_scratch);
 9894   %}
 9895   ins_pipe(pipe_class_dummy);
 9896 %}
 9897 
 9898 // Die now.
 9899 instruct ShouldNotReachHere() %{
 9900   match(Halt);
 9901   ins_cost(CALL_COST);
 9902   size(2);
 9903   format %{ &quot;ILLTRAP; ShouldNotReachHere&quot; %}
 9904   ins_encode %{ __ z_illtrap(); %}
 9905   ins_pipe(pipe_class_dummy);
 9906 %}
 9907 
 9908 // ============================================================================
 9909 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
 9910 // array for an instance of the superklass. Set a hidden internal cache on a
 9911 // hit (cache is checked with exposed code in gen_subtype_check()). Return
 9912 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
 9913 instruct partialSubtypeCheck(rarg1RegP index, rarg2RegP sub, rarg3RegP super, flagsReg pcc,
 9914                              rarg4RegP scratch1, rarg5RegP scratch2) %{
 9915   match(Set index (PartialSubtypeCheck sub super));
 9916   effect(KILL pcc, KILL scratch1, KILL scratch2);
 9917   ins_cost(10 * DEFAULT_COST);
 9918   // TODO: s390 port size(FIXED_SIZE);
 9919   format %{ &quot;  CALL   PartialSubtypeCheck\n&quot; %}
 9920   ins_encode %{
 9921     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9922     __ load_const_optimized(Z_ARG4, stub_address);
 9923     __ z_basr(Z_R14, Z_ARG4);
 9924   %}
 9925   ins_pipe(pipe_class_dummy);
 9926 %}
 9927 
 9928 instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,
 9929                                      rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{
 9930   match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));
 9931   effect(KILL scratch1, KILL scratch2, KILL index);
 9932   ins_cost(10 * DEFAULT_COST);
 9933   // TODO: s390 port size(FIXED_SIZE);
 9934   format %{ &quot;CALL   PartialSubtypeCheck_vs_zero\n&quot; %}
 9935   ins_encode %{
 9936     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9937     __ load_const_optimized(Z_ARG4, stub_address);
 9938     __ z_basr(Z_R14, Z_ARG4);
 9939   %}
 9940   ins_pipe(pipe_class_dummy);
 9941 %}
 9942 
 9943 // ============================================================================
 9944 // inlined locking and unlocking
 9945 
 9946 instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9947   match(Set pcc (FastLock oop box));
 9948   effect(TEMP tmp1, TEMP tmp2);
 9949   ins_cost(100);
 9950   // TODO: s390 port size(VARIABLE_SIZE); // Uses load_const_optimized.
 9951   format %{ &quot;FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9952   ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9953                                              UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9954   ins_pipe(pipe_class_dummy);
 9955 %}
 9956 
 9957 instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9958   match(Set pcc (FastUnlock oop box));
 9959   effect(TEMP tmp1, TEMP tmp2);
 9960   ins_cost(100);
 9961   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9962   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9963   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9964                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9965   ins_pipe(pipe_class_dummy);
 9966 %}
 9967 
 9968 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9969   match(Set dummy (ClearArray cnt base));
 9970   effect(KILL cr);
 9971   ins_cost(100);
 9972   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9973   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9974   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9975   ins_pipe(pipe_class_dummy);
 9976 %}
 9977 
 9978 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9979   match(Set dummy (ClearArray cnt base));
 9980   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9981   ins_cost(200);
 9982   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9983   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
 9984   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}
 9985   ins_pipe(pipe_class_dummy);
 9986 %}
 9987 
 9988 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9989   match(Set dummy (ClearArray cnt base));
 9990   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9991   ins_cost(300);
 9992   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9993   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
 9994   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}
 9995   ins_pipe(pipe_class_dummy);
 9996 %}
 9997 
 9998 // ============================================================================
 9999 // CompactStrings
10000 
10001 // String equals
10002 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10003   match(Set result (StrEquals (Binary str1 str2) cnt));
10004   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10005   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10006   ins_cost(300);
10007   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10008   ins_encode %{
10009     __ array_equals(false, $str1$$Register, $str2$$Register,
10010                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10011                     $result$$Register, true /* byte */);
10012   %}
10013   ins_pipe(pipe_class_dummy);
10014 %}
10015 
10016 instruct string_equalsU(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10017   match(Set result (StrEquals (Binary str1 str2) cnt));
10018   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10019   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10020   ins_cost(300);
10021   format %{ &quot;String Equals char[] $str1,$str2,$cnt -&gt; $result&quot; %}
10022   ins_encode %{
10023     __ array_equals(false, $str1$$Register, $str2$$Register,
10024                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10025                     $result$$Register, false /* byte */);
10026   %}
10027   ins_pipe(pipe_class_dummy);
10028 %}
10029 
10030 instruct string_equals_imm(iRegP str1, iRegP str2, uimmI8 cnt, iRegI result, flagsReg cr) %{
10031   match(Set result (StrEquals (Binary str1 str2) cnt));
10032   effect(KILL cr); // R0 is killed, too.
10033   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10034   ins_cost(100);
10035   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10036   ins_encode %{
10037     const int cnt_imm = $cnt$$constant;
10038     if (cnt_imm) { __ z_clc(0, cnt_imm - 1, $str1$$Register, 0, $str2$$Register); }
10039     __ z_lhi($result$$Register, 1);
10040     if (cnt_imm) {
10041       if (VM_Version::has_LoadStoreConditional()) {
10042         __ z_lhi(Z_R0_scratch, 0);
10043         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10044       } else {
10045         Label Lskip;
10046         __ z_bre(Lskip);
10047         __ clear_reg($result$$Register);
10048         __ bind(Lskip);
10049       }
10050     }
10051   %}
10052   ins_pipe(pipe_class_dummy);
10053 %}
10054 
10055 instruct string_equalsC_imm(iRegP str1, iRegP str2, immI8 cnt, iRegI result, flagsReg cr) %{
10056   match(Set result (StrEquals (Binary str1 str2) cnt));
10057   effect(KILL cr); // R0 is killed, too.
10058   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10059   ins_cost(100);
10060   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result&quot; %}
10061   ins_encode %{
10062     const int cnt_imm = $cnt$$constant; // positive immI8 (7 bits used)
10063     if (cnt_imm) { __ z_clc(0, (cnt_imm &lt;&lt; 1) - 1, $str1$$Register, 0, $str2$$Register); }
10064     __ z_lhi($result$$Register, 1);
10065     if (cnt_imm) {
10066       if (VM_Version::has_LoadStoreConditional()) {
10067         __ z_lhi(Z_R0_scratch, 0);
10068         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10069       } else {
10070         Label Lskip;
10071         __ z_bre(Lskip);
10072         __ clear_reg($result$$Register);
10073         __ bind(Lskip);
10074       }
10075     }
10076   %}
10077   ins_pipe(pipe_class_dummy);
10078 %}
10079 
10080 // Array equals
10081 instruct array_equalsB(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10082   match(Set result (AryEq ary1 ary2));
10083   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10084   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10085   ins_cost(300);
10086   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10087   ins_encode %{
10088     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10089                     noreg, $oddReg$$Register, $evenReg$$Register,
10090                     $result$$Register, true /* byte */);
10091   %}
10092   ins_pipe(pipe_class_dummy);
10093 %}
10094 
10095 instruct array_equalsC(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10096   match(Set result (AryEq ary1 ary2));
10097   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10098   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10099   ins_cost(300);
10100   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10101   ins_encode %{
10102     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10103                     noreg, $oddReg$$Register, $evenReg$$Register,
10104                     $result$$Register, false /* byte */);
10105   %}
10106   ins_pipe(pipe_class_dummy);
10107 %}
10108 
10109 // String CompareTo
10110 instruct string_compareL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10111   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10112   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10113   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10114   ins_cost(300);
10115   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10116   ins_encode %{
10117     __ string_compare($str1$$Register, $str2$$Register,
10118                       $cnt1$$Register, $cnt2$$Register,
10119                       $oddReg$$Register, $evenReg$$Register,
10120                       $result$$Register, StrIntrinsicNode::LL);
10121   %}
10122   ins_pipe(pipe_class_dummy);
10123 %}
10124 
10125 instruct string_compareU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10126   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10127   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10128   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10129   ins_cost(300);
10130   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10131   ins_encode %{
10132     __ string_compare($str1$$Register, $str2$$Register,
10133                       $cnt1$$Register, $cnt2$$Register,
10134                       $oddReg$$Register, $evenReg$$Register,
10135                       $result$$Register, StrIntrinsicNode::UU);
10136   %}
10137   ins_pipe(pipe_class_dummy);
10138 %}
10139 
10140 instruct string_compareLU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10141   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10142   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10143   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10144   ins_cost(300);
10145   format %{ &quot;String Compare byte[],char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10146   ins_encode %{
10147     __ string_compare($str1$$Register, $str2$$Register,
10148                       $cnt1$$Register, $cnt2$$Register,
10149                       $oddReg$$Register, $evenReg$$Register,
10150                       $result$$Register, StrIntrinsicNode::LU);
10151   %}
10152   ins_pipe(pipe_class_dummy);
10153 %}
10154 
10155 instruct string_compareUL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10156   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10157   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10158   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10159   ins_cost(300);
10160   format %{ &quot;String Compare char[],byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10161   ins_encode %{
10162     __ string_compare($str2$$Register, $str1$$Register,
10163                       $cnt2$$Register, $cnt1$$Register,
10164                       $oddReg$$Register, $evenReg$$Register,
10165                       $result$$Register, StrIntrinsicNode::UL);
10166   %}
10167   ins_pipe(pipe_class_dummy);
10168 %}
10169 
10170 // String IndexOfChar
10171 instruct indexOfChar_U(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10172   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
10173   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10174   ins_cost(200);
10175   format %{ &quot;String IndexOfChar [0..$haycnt]($haystack), $ch -&gt; $result&quot; %}
10176   ins_encode %{
10177     __ string_indexof_char($result$$Register,
10178                            $haystack$$Register, $haycnt$$Register,
10179                            $ch$$Register, 0 /* unused, ch is in register */,
10180                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10181   %}
10182   ins_pipe(pipe_class_dummy);
10183 %}
10184 
10185 instruct indexOf_imm1_U(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10186   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10187   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10188   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10189   ins_cost(200);
10190   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10191   ins_encode %{
10192     immPOper *needleOper = (immPOper *)$needle;
10193     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10194     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10195     jchar chr;
10196 #ifdef VM_LITTLE_ENDIAN
10197     Unimplemented();
10198 #else
10199     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
10200            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
10201 #endif
10202     __ string_indexof_char($result$$Register,
10203                            $haystack$$Register, $haycnt$$Register,
10204                            noreg, chr,
10205                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10206   %}
10207   ins_pipe(pipe_class_dummy);
10208 %}
10209 
10210 instruct indexOf_imm1_L(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10211   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10212   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10213   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10214   ins_cost(200);
10215   format %{ &quot;String IndexOf L [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10216   ins_encode %{
10217     immPOper *needleOper = (immPOper *)$needle;
10218     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10219     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10220     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10221     __ string_indexof_char($result$$Register,
10222                            $haystack$$Register, $haycnt$$Register,
10223                            noreg, chr,
10224                            $oddReg$$Register, $evenReg$$Register, true /*is_byte*/);
10225   %}
10226   ins_pipe(pipe_class_dummy);
10227 %}
10228 
10229 instruct indexOf_imm1_UL(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10230   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10231   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10232   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10233   ins_cost(200);
10234   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10235   ins_encode %{
10236     immPOper *needleOper = (immPOper *)$needle;
10237     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10238     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10239     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10240     __ string_indexof_char($result$$Register,
10241                            $haystack$$Register, $haycnt$$Register,
10242                            noreg, chr,
10243                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10244   %}
10245   ins_pipe(pipe_class_dummy);
10246 %}
10247 
10248 // String IndexOf
10249 instruct indexOf_imm_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10250   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10251   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10252   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10253   ins_cost(250);
10254   format %{ &quot;String IndexOf U [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10255   ins_encode %{
10256     __ string_indexof($result$$Register,
10257                       $haystack$$Register, $haycnt$$Register,
10258                       $needle$$Register, noreg, $needlecntImm$$constant,
10259                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10260   %}
10261   ins_pipe(pipe_class_dummy);
10262 %}
10263 
10264 instruct indexOf_imm_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10265   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10266   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10267   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10268   ins_cost(250);
10269   format %{ &quot;String IndexOf L [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10270   ins_encode %{
10271     __ string_indexof($result$$Register,
10272                       $haystack$$Register, $haycnt$$Register,
10273                       $needle$$Register, noreg, $needlecntImm$$constant,
10274                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10275   %}
10276   ins_pipe(pipe_class_dummy);
10277 %}
10278 
10279 instruct indexOf_imm_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10280   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10281   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10282   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10283   ins_cost(250);
10284   format %{ &quot;String IndexOf UL [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10285   ins_encode %{
10286     __ string_indexof($result$$Register,
10287                       $haystack$$Register, $haycnt$$Register,
10288                       $needle$$Register, noreg, $needlecntImm$$constant,
10289                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10290   %}
10291   ins_pipe(pipe_class_dummy);
10292 %}
10293 
10294 instruct indexOf_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10295   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10296   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10297   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10298   ins_cost(300);
10299   format %{ &quot;String IndexOf U [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10300   ins_encode %{
10301     __ string_indexof($result$$Register,
10302                       $haystack$$Register, $haycnt$$Register,
10303                       $needle$$Register, $needlecnt$$Register, 0,
10304                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10305   %}
10306   ins_pipe(pipe_class_dummy);
10307 %}
10308 
10309 instruct indexOf_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10310   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10311   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10312   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10313   ins_cost(300);
10314   format %{ &quot;String IndexOf L [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10315   ins_encode %{
10316     __ string_indexof($result$$Register,
10317                       $haystack$$Register, $haycnt$$Register,
10318                       $needle$$Register, $needlecnt$$Register, 0,
10319                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10320   %}
10321   ins_pipe(pipe_class_dummy);
10322 %}
10323 
10324 instruct indexOf_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10325   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10326   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10327   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10328   ins_cost(300);
10329   format %{ &quot;String IndexOf UL [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10330   ins_encode %{
10331     __ string_indexof($result$$Register,
10332                       $haystack$$Register, $haycnt$$Register,
10333                       $needle$$Register, $needlecnt$$Register, 0,
10334                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10335   %}
10336   ins_pipe(pipe_class_dummy);
10337 %}
10338 
10339 // char[] to byte[] compression
10340 instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10341   match(Set result (StrCompressedCopy src (Binary dst len)));
10342   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10343   ins_cost(300);
10344   format %{ &quot;String Compress $src-&gt;$dst($len) -&gt; $result&quot; %}
10345   ins_encode %{
10346     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10347                        $tmp$$Register, false);
10348   %}
10349   ins_pipe(pipe_class_dummy);
10350 %}
10351 
10352 // byte[] to char[] inflation. trot implementation is shorter, but slower than the unrolled icm(h) loop.
10353 //instruct string_inflate_trot(Universe dummy, iRegP src, revenRegP dst, roddRegI len, iRegI tmp, flagsReg cr) %{
10354 //  match(Set dummy (StrInflatedCopy src (Binary dst len)));
10355 //  effect(USE_KILL dst, USE_KILL len, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10356 //  predicate(VM_Version::has_ETF2Enhancements());
10357 //  ins_cost(300);
10358 //  format %{ &quot;String Inflate (trot) $dst,$src($len)&quot; %}
10359 //  ins_encode %{
10360 //    __ string_inflate_trot($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10361 //  %}
10362 //  ins_pipe(pipe_class_dummy);
10363 //%}
10364 
10365 // byte[] to char[] inflation
10366 instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{
10367   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10368   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10369   ins_cost(300);
10370   format %{ &quot;String Inflate $src-&gt;$dst($len)&quot; %}
10371   ins_encode %{
10372     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10373   %}
10374   ins_pipe(pipe_class_dummy);
10375 %}
10376 
10377 // byte[] to char[] inflation
10378 instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{
10379   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10380   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10381   ins_cost(300);
10382   format %{ &quot;String Inflate (constLen) $src-&gt;$dst($len)&quot; %}
10383   ins_encode %{
10384     __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);
10385   %}
10386   ins_pipe(pipe_class_dummy);
10387 %}
10388 
10389 // StringCoding.java intrinsics
10390 instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{
10391   match(Set result (HasNegatives ary1 len));
10392   effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10393   ins_cost(300);
10394   format %{ &quot;has negatives byte[] $ary1($len) -&gt; $result&quot; %}
10395   ins_encode %{
10396     __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,
10397                      $oddReg$$Register, $evenReg$$Register, $tmp$$Register);
10398   %}
10399   ins_pipe(pipe_class_dummy);
10400 %}
10401 
10402 // encode char[] to byte[] in ISO_8859_1
10403 instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10404   match(Set result (EncodeISOArray src (Binary dst len)));
10405   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10406   ins_cost(300);
10407   format %{ &quot;Encode array $src-&gt;$dst($len) -&gt; $result&quot; %}
10408   ins_encode %{
10409     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10410                        $tmp$$Register, true);
10411   %}
10412   ins_pipe(pipe_class_dummy);
10413 %}
10414 
10415 
10416 //----------PEEPHOLE RULES-----------------------------------------------------
10417 // These must follow all instruction definitions as they use the names
10418 // defined in the instructions definitions.
10419 //
10420 // peepmatch (root_instr_name [preceeding_instruction]*);
10421 //
10422 // peepconstraint %{
10423 // (instruction_number.operand_name relational_op instruction_number.operand_name
10424 //  [, ...]);
10425 // // instruction numbers are zero-based using left to right order in peepmatch
10426 //
10427 // peepreplace (instr_name([instruction_number.operand_name]*));
10428 // // provide an instruction_number.operand_name for each operand that appears
10429 // // in the replacement instruction&#39;s match rule
10430 //
10431 // ---------VM FLAGS---------------------------------------------------------
10432 //
10433 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10434 //
10435 // Each peephole rule is given an identifying number starting with zero and
10436 // increasing by one in the order seen by the parser. An individual peephole
10437 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10438 // on the command-line.
10439 //
10440 // ---------CURRENT LIMITATIONS----------------------------------------------
10441 //
10442 // Only match adjacent instructions in same basic block
10443 // Only equality constraints
10444 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10445 // Only one replacement instruction
10446 //
10447 // ---------EXAMPLE----------------------------------------------------------
10448 //
10449 // // pertinent parts of existing instructions in architecture description
10450 // instruct movI(eRegI dst, eRegI src) %{
10451 //   match(Set dst (CopyI src));
10452 // %}
10453 //
10454 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10455 //   match(Set dst (AddI dst src));
10456 //   effect(KILL cr);
10457 // %}
10458 //
10459 // // Change (inc mov) to lea
10460 // peephole %{
10461 //   // increment preceeded by register-register move
10462 //   peepmatch (incI_eReg movI);
10463 //   // require that the destination register of the increment
10464 //   // match the destination register of the move
10465 //   peepconstraint (0.dst == 1.dst);
10466 //   // construct a replacement instruction that sets
10467 //   // the destination to (move&#39;s source register + one)
10468 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10469 // %}
10470 //
10471 // Implementation no longer uses movX instructions since
10472 // machine-independent system no longer uses CopyX nodes.
10473 //
10474 // peephole %{
10475 //   peepmatch (incI_eReg movI);
10476 //   peepconstraint (0.dst == 1.dst);
10477 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10478 // %}
10479 //
10480 // peephole %{
10481 //   peepmatch (decI_eReg movI);
10482 //   peepconstraint (0.dst == 1.dst);
10483 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10484 // %}
10485 //
10486 // peephole %{
10487 //   peepmatch (addI_eReg_imm movI);
10488 //   peepconstraint (0.dst == 1.dst);
10489 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10490 // %}
10491 //
10492 // peephole %{
10493 //   peepmatch (addP_eReg_imm movP);
10494 //   peepconstraint (0.dst == 1.dst);
10495 //   peepreplace (leaP_eReg_immI(0.dst 1.src 0.src));
10496 // %}
10497 
10498 
10499 //  This peephole rule does not work, probably because ADLC can&#39;t handle two effects:
10500 //  Effect 1 is defining 0.op1 and effect 2 is setting CC
10501 // condense a load from memory and subsequent test for zero
10502 // into a single, more efficient ICM instruction.
10503 // peephole %{
10504 //   peepmatch (compI_iReg_imm0 loadI);
10505 //   peepconstraint (1.dst == 0.op1);
10506 //   peepreplace (loadtest15_iReg_mem(0.op1 0.op1 1.mem));
10507 // %}
10508 
10509 // // Change load of spilled value to only a spill
10510 // instruct storeI(memory mem, eRegI src) %{
10511 //   match(Set mem (StoreI mem src));
10512 // %}
10513 //
10514 // instruct loadI(eRegI dst, memory mem) %{
10515 //   match(Set dst (LoadI mem));
10516 // %}
10517 //
10518 peephole %{
10519   peepmatch (loadI storeI);
10520   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10521   peepreplace (storeI(1.mem 1.mem 1.src));
10522 %}
10523 
10524 peephole %{
10525   peepmatch (loadL storeL);
10526   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10527   peepreplace (storeL(1.mem 1.mem 1.src));
10528 %}
10529 
10530 peephole %{
10531   peepmatch (loadP storeP);
10532   peepconstraint (1.src == 0.dst, 1.dst == 0.mem);
10533   peepreplace (storeP(1.dst 1.dst 1.src));
10534 %}
10535 
10536 //----------SUPERWORD RULES---------------------------------------------------
10537 
10538 //  Expand rules for special cases
10539 
10540 instruct expand_storeF(stackSlotF mem, regF src) %{
10541   // No match rule, false predicate, for expand only.
10542   effect(DEF mem, USE src);
10543   predicate(false);
10544   ins_cost(MEMORY_REF_COST);
10545   // TODO: s390 port size(FIXED_SIZE);
10546   format %{ &quot;STE      $src,$mem\t # replicate(float2stack)&quot; %}
10547   opcode(STE_ZOPC, STE_ZOPC);
10548   ins_encode(z_form_rt_mem(src, mem));
10549   ins_pipe(pipe_class_dummy);
10550 %}
10551 
10552 instruct expand_LoadLogical_I2L(iRegL dst, stackSlotF mem) %{
10553   // No match rule, false predicate, for expand only.
10554   effect(DEF dst, USE mem);
10555   predicate(false);
10556   ins_cost(MEMORY_REF_COST);
10557   // TODO: s390 port size(FIXED_SIZE);
10558   format %{ &quot;LLGF     $dst,$mem\t # replicate(stack2reg(unsigned))&quot; %}
10559   opcode(LLGF_ZOPC, LLGF_ZOPC);
10560   ins_encode(z_form_rt_mem(dst, mem));
10561   ins_pipe(pipe_class_dummy);
10562 %}
10563 
10564 // Replicate scalar int to packed int values (8 Bytes)
10565 instruct expand_Repl2I_reg(iRegL dst, iRegL src) %{
10566   // Dummy match rule, false predicate, for expand only.
10567   match(Set dst (ConvI2L src));
10568   predicate(false);
10569   ins_cost(DEFAULT_COST);
10570   // TODO: s390 port size(FIXED_SIZE);
10571   format %{ &quot;REPLIC2F $dst,$src\t # replicate(pack2F)&quot; %}
10572   ins_encode %{
10573     if ($dst$$Register == $src$$Register) {
10574       __ z_sllg(Z_R0_scratch, $src$$Register, 64-32);
10575       __ z_ogr($dst$$Register, Z_R0_scratch);
10576     }  else {
10577       __ z_sllg($dst$$Register, $src$$Register, 64-32);
10578       __ z_ogr( $dst$$Register, $src$$Register);
10579     }
10580   %}
10581   ins_pipe(pipe_class_dummy);
10582 %}
10583 
10584 // Replication
10585 
10586 // Exploit rotate_then_insert, if available
10587 // Replicate scalar byte to packed byte values (8 Bytes).
10588 instruct Repl8B_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10589   match(Set dst (ReplicateB src));
10590   effect(KILL cr);
10591   predicate((n-&gt;as_Vector()-&gt;length() == 8));
10592   format %{ &quot;REPLIC8B $dst,$src\t # pack8B&quot; %}
10593   ins_encode %{
10594     if ($dst$$Register != $src$$Register) {
10595       __ z_lgr($dst$$Register, $src$$Register);
10596     }
10597     __ rotate_then_insert($dst$$Register, $dst$$Register, 48, 55,  8, false);
10598     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10599     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10600   %}
10601   ins_pipe(pipe_class_dummy);
10602 %}
10603 
10604 // Replicate scalar byte to packed byte values (8 Bytes).
10605 instruct Repl8B_imm(iRegL dst, immB_n0m1 src) %{
10606   match(Set dst (ReplicateB src));
10607   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10608   ins_should_rematerialize(true);
10609   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm&quot; %}
10610   ins_encode %{
10611     int64_t  Isrc8 = $src$$constant &amp; 0x000000ff;
10612     int64_t Isrc16 =  Isrc8 &lt;&lt;  8 |  Isrc8;
10613     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10614     assert(Isrc8 != 0x000000ff &amp;&amp; Isrc8 != 0, &quot;should be handled by other match rules.&quot;);
10615 
10616     __ z_llilf($dst$$Register, Isrc32);
10617     __ z_iihf($dst$$Register, Isrc32);
10618   %}
10619   ins_pipe(pipe_class_dummy);
10620 %}
10621 
10622 // Replicate scalar byte to packed byte values (8 Bytes).
10623 instruct Repl8B_imm0(iRegL dst, immI_0 src) %{
10624   match(Set dst (ReplicateB src));
10625   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10626   ins_should_rematerialize(true);
10627   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm0&quot; %}
10628   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10629   ins_pipe(pipe_class_dummy);
10630 %}
10631 
10632 // Replicate scalar byte to packed byte values (8 Bytes).
10633 instruct Repl8B_immm1(iRegL dst, immB_minus1 src) %{
10634   match(Set dst (ReplicateB src));
10635   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10636   ins_should_rematerialize(true);
10637   format %{ &quot;REPLIC8B $dst,$src\t # pack8B immm1&quot; %}
10638   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10639   ins_pipe(pipe_class_dummy);
10640 %}
10641 
10642 // Exploit rotate_then_insert, if available
10643 // Replicate scalar short to packed short values (8 Bytes).
10644 instruct Repl4S_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10645   match(Set dst (ReplicateS src));
10646   effect(KILL cr);
10647   predicate((n-&gt;as_Vector()-&gt;length() == 4));
10648   format %{ &quot;REPLIC4S $dst,$src\t # pack4S&quot; %}
10649   ins_encode %{
10650     if ($dst$$Register != $src$$Register) {
10651       __ z_lgr($dst$$Register, $src$$Register);
10652     }
10653     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10654     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10655   %}
10656   ins_pipe(pipe_class_dummy);
10657 %}
10658 
10659 // Replicate scalar short to packed short values (8 Bytes).
10660 instruct Repl4S_imm(iRegL dst, immS_n0m1 src) %{
10661   match(Set dst (ReplicateS src));
10662   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10663   ins_should_rematerialize(true);
10664   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm&quot; %}
10665   ins_encode %{
10666     int64_t Isrc16 = $src$$constant &amp; 0x0000ffff;
10667     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10668     assert(Isrc16 != 0x0000ffff &amp;&amp; Isrc16 != 0, &quot;Repl4S_imm: (src == &quot; INT64_FORMAT
10669            &quot;) should be handled by other match rules.&quot;, $src$$constant);
10670 
10671     __ z_llilf($dst$$Register, Isrc32);
10672     __ z_iihf($dst$$Register, Isrc32);
10673   %}
10674   ins_pipe(pipe_class_dummy);
10675 %}
10676 
10677 // Replicate scalar short to packed short values (8 Bytes).
10678 instruct Repl4S_imm0(iRegL dst, immI_0 src) %{
10679   match(Set dst (ReplicateS src));
10680   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10681   ins_should_rematerialize(true);
10682   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm0&quot; %}
10683   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10684   ins_pipe(pipe_class_dummy);
10685 %}
10686 
10687 // Replicate scalar short to packed short values (8 Bytes).
10688 instruct Repl4S_immm1(iRegL dst, immS_minus1 src) %{
10689   match(Set dst (ReplicateS src));
10690   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10691   ins_should_rematerialize(true);
10692   format %{ &quot;REPLIC4S $dst,$src\t # pack4S immm1&quot; %}
10693   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10694   ins_pipe(pipe_class_dummy);
10695 %}
10696 
10697 // Exploit rotate_then_insert, if available.
10698 // Replicate scalar int to packed int values (8 Bytes).
10699 instruct Repl2I_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10700   match(Set dst (ReplicateI src));
10701   effect(KILL cr);
10702   predicate((n-&gt;as_Vector()-&gt;length() == 2));
10703   format %{ &quot;REPLIC2I $dst,$src\t # pack2I&quot; %}
10704   ins_encode %{
10705     if ($dst$$Register != $src$$Register) {
10706       __ z_lgr($dst$$Register, $src$$Register);
10707     }
10708     __ rotate_then_insert($dst$$Register, $dst$$Register, 0, 31, 32, false);
10709   %}
10710   ins_pipe(pipe_class_dummy);
10711 %}
10712 
10713 // Replicate scalar int to packed int values (8 Bytes).
10714 instruct Repl2I_imm(iRegL dst, immI_n0m1 src) %{
10715   match(Set dst (ReplicateI src));
10716   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10717   ins_should_rematerialize(true);
10718   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm&quot; %}
10719   ins_encode %{
10720     int64_t Isrc32 = $src$$constant;
10721     assert(Isrc32 != -1 &amp;&amp; Isrc32 != 0, &quot;should be handled by other match rules.&quot;);
10722 
10723     __ z_llilf($dst$$Register, Isrc32);
10724     __ z_iihf($dst$$Register, Isrc32);
10725   %}
10726   ins_pipe(pipe_class_dummy);
10727 %}
10728 
10729 // Replicate scalar int to packed int values (8 Bytes).
10730 instruct Repl2I_imm0(iRegL dst, immI_0 src) %{
10731   match(Set dst (ReplicateI src));
10732   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10733   ins_should_rematerialize(true);
10734   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm0&quot; %}
10735   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10736   ins_pipe(pipe_class_dummy);
10737 %}
10738 
10739 // Replicate scalar int to packed int values (8 Bytes).
10740 instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
10741   match(Set dst (ReplicateI src));
10742   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10743   ins_should_rematerialize(true);
10744   format %{ &quot;REPLIC2I $dst,$src\t # pack2I immm1&quot; %}
10745   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10746   ins_pipe(pipe_class_dummy);
10747 %}
10748 
10749 //
10750 
10751 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
10752   match(Set dst (ReplicateF src));
10753   effect(KILL cr);
10754   predicate(!VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10755   format %{ &quot;REPLIC2F $dst,$src\t # pack2F indirect&quot; %}
10756   expand %{
10757     stackSlotF tmp;
10758     iRegL      tmp2;
10759     expand_storeF(tmp, src);
10760     expand_LoadLogical_I2L(tmp2, tmp);
10761     expand_Repl2I_reg(dst, tmp2);
10762   %}
10763 %}
10764 
10765 // Replicate scalar float to packed float values in GREG (8 Bytes).
10766 instruct Repl2F_reg_direct(iRegL dst, regF src, flagsReg cr) %{
10767   match(Set dst (ReplicateF src));
10768   effect(KILL cr);
10769   predicate(VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10770   format %{ &quot;REPLIC2F $dst,$src\t # pack2F direct&quot; %}
10771   ins_encode %{
10772     assert(VM_Version::has_FPSupportEnhancements(), &quot;encoder should never be called on old H/W&quot;);
10773     __ z_lgdr($dst$$Register, $src$$FloatRegister);
10774 
10775     __ z_srlg(Z_R0_scratch, $dst$$Register, 32);  // Floats are left-justified in 64bit reg.
10776     __ z_iilf($dst$$Register, 0);                 // Save a &quot;result not ready&quot; stall.
10777     __ z_ogr($dst$$Register, Z_R0_scratch);
10778   %}
10779   ins_pipe(pipe_class_dummy);
10780 %}
10781 
10782 // Replicate scalar float immediate to packed float values in GREG (8 Bytes).
10783 instruct Repl2F_imm(iRegL dst, immF src) %{
10784   match(Set dst (ReplicateF src));
10785   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10786   ins_should_rematerialize(true);
10787   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm&quot; %}
10788   ins_encode %{
10789     union {
10790       int   Isrc32;
10791       float Fsrc32;
10792     };
10793     Fsrc32 = $src$$constant;
10794     __ z_llilf($dst$$Register, Isrc32);
10795     __ z_iihf($dst$$Register, Isrc32);
10796   %}
10797   ins_pipe(pipe_class_dummy);
10798 %}
10799 
10800 // Replicate scalar float immediate zeroes to packed float values in GREG (8 Bytes).
10801 // Do this only for &#39;real&#39; zeroes, especially don&#39;t loose sign of negative zeroes.
10802 instruct Repl2F_imm0(iRegL dst, immFp0 src) %{
10803   match(Set dst (ReplicateF src));
10804   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10805   ins_should_rematerialize(true);
10806   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm0&quot; %}
10807   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10808   ins_pipe(pipe_class_dummy);
10809 %}
10810 
10811 // Store
10812 
10813 // Store Aligned Packed Byte register to memory (8 Bytes).
10814 instruct storeA8B(memory mem, iRegL src) %{
10815   match(Set mem (StoreVector mem src));
10816   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10817   ins_cost(MEMORY_REF_COST);
10818   // TODO: s390 port size(VARIABLE_SIZE);
10819   format %{ &quot;STG     $src,$mem\t # ST(packed8B)&quot; %}
10820   opcode(STG_ZOPC, STG_ZOPC);
10821   ins_encode(z_form_rt_mem_opt(src, mem));
10822   ins_pipe(pipe_class_dummy);
10823 %}
10824 
10825 // Load
10826 
10827 instruct loadV8(iRegL dst, memory mem) %{
10828   match(Set dst (LoadVector mem));
10829   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10830   ins_cost(MEMORY_REF_COST);
10831   // TODO: s390 port size(VARIABLE_SIZE);
10832   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10833   opcode(LG_ZOPC, LG_ZOPC);
10834   ins_encode(z_form_rt_mem_opt(dst, mem));
10835   ins_pipe(pipe_class_dummy);
10836 %}
10837 
10838 //----------POPULATION COUNT RULES--------------------------------------------
10839 
10840 // Byte reverse
10841 
10842 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10843   match(Set dst (ReverseBytesI src));
10844   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10845   ins_cost(DEFAULT_COST);
10846   size(4);
10847   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}
10848   opcode(LRVR_ZOPC);
10849   ins_encode(z_rreform(dst, src));
10850   ins_pipe(pipe_class_dummy);
10851 %}
10852 
10853 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10854   match(Set dst (ReverseBytesL src));
10855   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10856   ins_cost(DEFAULT_COST);
10857   // TODO: s390 port size(FIXED_SIZE);
10858   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}
10859   opcode(LRVGR_ZOPC);
10860   ins_encode(z_rreform(dst, src));
10861   ins_pipe(pipe_class_dummy);
10862 %}
10863 
10864 // Leading zeroes
10865 
10866 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10867 // returns the bit position of the leftmost 1 in the 64bit source register.
10868 // As the bits are numbered from left to right (0..63), the returned
10869 // position index is equivalent to the number of leading zeroes.
10870 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10871 // returns position 64. That&#39;s exactly what we need.
10872 
10873 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10874   match(Set dst (CountLeadingZerosI src));
10875   effect(KILL tmp, KILL cr);
10876   ins_cost(3 * DEFAULT_COST);
10877   size(14);
10878   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;
10879             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;
10880             &quot;FLOGR   $dst,$dst&quot;
10881          %}
10882   ins_encode %{
10883     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10884     // iteration to find the leftmost &quot;1&quot; bit.
10885     //
10886     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10887     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10888     // We could gain measurable speedup in micro benchmark:
10889     //
10890     //               leading   trailing
10891     //   z10:   int     2.04       1.68
10892     //         long     1.00       1.02
10893     //   z196:  int     0.99       1.23
10894     //         long     1.00       1.11
10895     //
10896     // By shifting the argument into the high-word instead of zero-extending it.
10897     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10898     // good prediction) is well compensated for by the savings.
10899     //
10900     // We leave the previous implementation in for some time in the future when
10901     // the &quot;FLOGR&quot; instruction may become less iterative.
10902 
10903     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10904     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10905     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10906     __ z_flogr($dst$$Register, $dst$$Register);
10907   %}
10908   ins_pipe(pipe_class_dummy);
10909 %}
10910 
10911 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10912   match(Set dst (CountLeadingZerosL src));
10913   effect(KILL tmp, KILL cr);
10914   ins_cost(DEFAULT_COST);
10915   size(4);
10916   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}
10917   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10918   ins_pipe(pipe_class_dummy);
10919 %}
10920 
10921 // trailing zeroes
10922 
10923 // We transform the trailing zeroes problem to a leading zeroes problem
10924 // such that can use the FLOGR instruction to our advantage.
10925 
10926 // With
10927 //   tmp1 = src - 1
10928 // we flip all trailing zeroes to ones and the rightmost one to zero.
10929 // All other bits remain unchanged.
10930 // With the complement
10931 //   tmp2 = ~src
10932 // we get all ones in the trailing zeroes positions. Thus,
10933 //   tmp3 = tmp1 &amp; tmp2
10934 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10935 // Now we can apply FLOGR and get 64-(trailing zeroes).
10936 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10937   match(Set dst (CountTrailingZerosI src));
10938   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10939   ins_cost(8 * DEFAULT_COST);
10940   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10941   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;
10942             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;
10943             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10944             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;
10945             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;
10946             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;
10947             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10948             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;
10949          %}
10950   ins_encode %{
10951     Register Rdst = $dst$$Register;
10952     Register Rsrc = $src$$Register;
10953     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10954     // match rule Rsrc = roddReg would be possible, saving one register.
10955     Register Rtmp = $tmp$$Register;
10956 
10957     assert_different_registers(Rdst, Rsrc, Rtmp);
10958 
10959     // Algorithm:
10960     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10961     //   All other bits in the result are zero.
10962     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10963     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10964 
10965     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10966     Label done;
10967     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10968     __ z_lcgfr(Rtmp, Rsrc);
10969     __ z_bre(done);                    // Taken very infrequently, good prediction, no BHT entry.
10970 
10971     __ z_nr(Rtmp, Rsrc);               // (src) &amp; (-src) leaves nothing but least significant bit.
10972     __ z_ahi(Rtmp,  -1);               // Subtract one to fill all trailing zero positions with ones.
10973                                        // Use 32bit op to prevent borrow propagation (case Rdst = 0x80000000)
10974                                        // into upper half of reg. Not relevant with sllg below.
10975     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10976     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10977                                        // Depends on CC set by ahi above.
10978                                        // Taken very infrequently, good prediction, no BHT entry.
10979                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10980                                        // after SLLG Rdst == 0(64bit)).
10981     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10982     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10983     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10984     __ bind(done);
10985   %}
10986   ins_pipe(pipe_class_dummy);
10987 %}
10988 
10989 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10990   match(Set dst (CountTrailingZerosL src));
10991   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10992   ins_cost(8 * DEFAULT_COST);
10993   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10994   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;
10995             &quot;NGR     $dst,$src  \t #\n\t&quot;
10996             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10997             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;
10998             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10999             &quot;LCR     $dst,$dst  \t #&quot;
11000          %}
11001   ins_encode %{
11002     Register Rdst = $dst$$Register;
11003     Register Rsrc = $src$$Register;
11004     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
11005 
11006     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
11007     __ z_lcgr(Rdst, Rsrc);
11008     __ z_ngr(Rdst, Rsrc);
11009     __ add2reg(Rdst,   -1);
11010     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
11011     __ add2reg(Rdst,  -64);
11012     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
11013   %}
11014   ins_pipe(pipe_class_dummy);
11015 %}
11016 
11017 
11018 // bit count
11019 
11020 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
11021   match(Set dst (PopCountI src));
11022   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11023   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11024   ins_cost(DEFAULT_COST);
11025   size(24);
11026   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}
11027   ins_encode %{
11028     Register Rdst = $dst$$Register;
11029     Register Rsrc = $src$$Register;
11030     Register Rtmp = $tmp$$Register;
11031 
11032     // Prefer compile-time assertion over run-time SIGILL.
11033     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11034     assert_different_registers(Rdst, Rtmp);
11035 
11036     // Version 2: shows 10%(z196) improvement over original.
11037     __ z_popcnt(Rdst, Rsrc);
11038     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
11039     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
11040     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
11041     __ z_alr(Rdst, Rtmp);      //   into byte7
11042     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
11043   %}
11044   ins_pipe(pipe_class_dummy);
11045 %}
11046 
11047 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
11048   match(Set dst (PopCountL src));
11049   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11050   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11051   ins_cost(DEFAULT_COST);
11052   // TODO: s390 port size(FIXED_SIZE);
11053   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}
11054   ins_encode %{
11055     Register Rdst = $dst$$Register;
11056     Register Rsrc = $src$$Register;
11057     Register Rtmp = $tmp$$Register;
11058 
11059     // Prefer compile-time assertion over run-time SIGILL.
11060     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11061     assert_different_registers(Rdst, Rtmp);
11062 
11063     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
11064     __ z_popcnt(Rdst, Rsrc);
11065     __ z_ahhlr(Rdst, Rdst, Rdst);
11066     __ z_sllg(Rtmp, Rdst, 16);
11067     __ z_algr(Rdst, Rtmp);
11068     __ z_sllg(Rtmp, Rdst,  8);
11069     __ z_algr(Rdst, Rtmp);
11070     __ z_srlg(Rdst, Rdst, 56);
11071   %}
11072   ins_pipe(pipe_class_dummy);
11073 %}
11074 
11075 //----------SMARTSPILL RULES---------------------------------------------------
11076 // These must follow all instruction definitions as they use the names
11077 // defined in the instructions definitions.
11078 
11079 // ============================================================================
11080 // TYPE PROFILING RULES
    </pre>
  </body>
</html>