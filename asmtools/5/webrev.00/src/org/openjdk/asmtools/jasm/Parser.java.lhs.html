<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/org/openjdk/asmtools/jasm/Parser.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.asmtools.jasm;
  24 
  25 import org.openjdk.asmtools.common.Module;
  26 
  27 import java.io.IOException;
  28 import java.util.ArrayList;
  29 import java.util.HashSet;
  30 import java.util.Set;
  31 import java.util.function.BiConsumer;
  32 import java.util.function.Consumer;
  33 
  34 import static org.openjdk.asmtools.jasm.ConstantPool.*;
  35 import static org.openjdk.asmtools.jasm.JasmTokens.Token;
  36 import static org.openjdk.asmtools.jasm.JasmTokens.Token.COMMA;
  37 import static org.openjdk.asmtools.jasm.JasmTokens.Token.SEMICOLON;
  38 import static org.openjdk.asmtools.jasm.RuntimeConstants.*;
  39 import static org.openjdk.asmtools.jasm.Tables.*;
  40 
  41 /**
  42  * This class is used to parse Jasm statements and expressions.
  43  * The result is a parse tree.&lt;p&gt;
  44  * &lt;p&gt;
  45  * This class implements an operator precedence parser. Errors are
  46  * reported to the Environment object, if the error can&#39;t be
  47  * resolved immediately, a SyntaxError exception is thrown.&lt;p&gt;
  48  * &lt;p&gt;
  49  * Error recovery is implemented by catching Scanner.SyntaxError exceptions
  50  * and discarding input scanner.tokens until an input token is reached that
  51  * is possibly a legal continuation.&lt;p&gt;
  52  * &lt;p&gt;
  53  * The parse tree that is constructed represents the input
  54  * exactly (no rewrites to simpler forms). This is important
  55  * if the resulting tree is to be used for code formatting in
  56  * a programming environment. Currently only documentation comments
  57  * are retained.&lt;p&gt;
  58  * &lt;p&gt;
  59  * A parser owns several components (scanner, constant-parser,
  60  * instruction-parser, annotations-parser) to which it delegates certain
  61  * parsing responsibilities.  This parser contains functions to parse the
  62  * overall form of a class, and any members (fields, methods, inner-classes).
  63  * &lt;p&gt;
  64  * &lt;p&gt;
  65  * Syntax errors, should always be caught inside the
  66  * parser for error recovery.
  67  */
  68 class Parser extends ParseBase {
  69 
  70     /* Parser Fields */
  71     protected ConstantPool pool = null;
  72 
  73     ClassData cd = null;
  74 
  75     CodeAttr curCode;
  76 
  77     private ArrayList&lt;ClassData&gt; clsDataList = new ArrayList&lt;&gt;();
  78     private String pkg = null;
  79     private String pkgPrefix = &quot;&quot;;
  80     private ArrayList&lt;AnnotationData&gt; pkgAnnttns = null;
  81     private ArrayList&lt;AnnotationData&gt; clsAnnttns = null;
  82     private ArrayList&lt;AnnotationData&gt; memberAnnttns = null;
  83     private boolean explicitcp = false;
  84     private ModuleAttr moduleAttribute;
  85     private CFVersion currentCFV;
  86     /**
  87      * other parser components
  88      */
  89     private ParserAnnotation annotParser;       // For parsing Annotations
  90     private ParserCP cpParser;                  // for parsing Constants
  91     private ParserInstr instrParser;            // for parsing Instructions
  92 
  93 
  94     /**
  95      * Create a parser
  96      */
  97     protected Parser(Environment sf, CFVersion cfVersion) throws IOException {
  98         super.init(new Scanner(sf), this, sf);
  99         this.currentCFV = cfVersion;
 100         this.annotParser = new ParserAnnotation(scanner, this, env);
 101         this.cpParser = new ParserCP(scanner, this, env);
 102         this.instrParser = new ParserInstr(scanner, this, cpParser, env);
 103     }
 104 
 105     void setDebugFlags(boolean debugScanner, boolean debugMembers,
 106                        boolean debugCP, boolean debugAnnot, boolean debugInstr) {
 107 
 108         enableDebug(debugMembers);
 109         scanner.enableDebug(debugScanner);
 110         cpParser.enableDebug(debugCP);
 111         annotParser.enableDebug(debugAnnot);
 112         instrParser.enableDebug(debugInstr);
 113     }
 114 
 115     String encodeClassString(String classname) {
 116         return &quot;L&quot; + classname + &quot;;&quot;;
 117     }
 118 
 119 
 120     /*-------------------------------------------------------- */
 121 
 122     /**
 123      * Parses version in package statements
 124      */
 125 
 126     private void parseVersionPkg() throws IOException {
 127         if (scanner.token == SEMICOLON) {
 128             return;
 129         }
 130         parse_ver:
 131         {
 132             if (scanner.token != Token.VERSION) {
 133                 break parse_ver;
 134             }
 135             scanner.scan();
 136             if (scanner.token != Token.INTVAL) {
 137                 break parse_ver;
 138             }
 139             currentCFV.setMajorVersion((short) scanner.intValue);
 140             scanner.scan();
 141             if (scanner.token != Token.COLON) {
 142                 break parse_ver;
 143             }
 144             scanner.scan();
 145             if (scanner.token != Token.INTVAL) {
 146                 break parse_ver;
 147             }
 148             currentCFV.setMinorVersion((short) scanner.intValue);
 149             scanner.scan();
 150             debugScan(&quot;     [Parser.parseVersionPkg]: &quot; + currentCFV.asString());
 151             return;
 152         }
 153         env.error(scanner.pos, &quot;version.expected&quot;);
 154         throw new Scanner.SyntaxError();
 155     }
 156 
 157     private void parseVersion() throws IOException {
 158         if (scanner.token == Token.LBRACE) {
 159             return;
 160         }
 161         parse_ver:
 162         {
 163             if (scanner.token != Token.VERSION) {
 164                 break parse_ver;
 165             }
 166             scanner.scan();
 167             if (scanner.token != Token.INTVAL) {
 168                 break parse_ver;
 169             }
 170             cd.cfv.setMajorVersion((short) scanner.intValue);
 171             scanner.scan();
 172             if (scanner.token != Token.COLON) {
 173                 break parse_ver;
 174             }
 175             scanner.scan();
 176             if (scanner.token != Token.INTVAL) {
 177                 break parse_ver;
 178             }
 179             cd.cfv.setMinorVersion((short) scanner.intValue);
 180             scanner.scan();
 181             debugStr(&quot;parseVersion: &quot; + cd.cfv.asString());
 182             return;
 183         }
 184         env.error(scanner.pos, &quot;version.expected&quot;);
 185         throw new Scanner.SyntaxError();
 186     }
 187 
 188 
 189     /*---------------------------------------------*/
 190 
 191     /**
 192      * Parse an internal name: identifier.
 193      */
 194     String parseIdent() throws Scanner.SyntaxError, IOException {
 195         String v = scanner.idValue;
 196         scanner.expect(Token.IDENT);
 197         return v;
 198     }
 199 
 200     /**
 201      * Parse a local variable
 202      */
 203     void parseLocVarDef() throws Scanner.SyntaxError, IOException {
 204         if (scanner.token == Token.INTVAL) {
 205             int v = scanner.intValue;
 206             scanner.scan();
 207             curCode.LocVarDataDef(v);
 208         } else {
 209             String name = scanner.stringValue, type;
 210             scanner.expect(Token.IDENT);
 211             if (scanner.token == Token.COLON) {
 212                 scanner.scan();
 213                 type = parseIdent();
 214             } else {
 215                 type = &quot;I&quot;;                  // TBD
 216             }
 217             curCode.LocVarDataDef(name, pool.FindCellAsciz(type));
 218         }
 219     }
 220 
 221     Argument parseLocVarRef() throws Scanner.SyntaxError, IOException {
 222         if (scanner.token == Token.INTVAL) {
 223             int v = scanner.intValue;
 224             scanner.scan();
 225             return new Argument(v);
 226         } else {
 227             String name = scanner.stringValue;
 228             scanner.expect(Token.IDENT);
 229             return curCode.LocVarDataRef(name);
 230         }
 231     }
 232 
 233     void parseLocVarEnd() throws Scanner.SyntaxError, IOException {
 234         if (scanner.token == Token.INTVAL) {
 235             int v = scanner.intValue;
 236             scanner.scan();
 237             curCode.LocVarDataEnd(v);
 238         } else {
 239             String name = scanner.stringValue;
 240             scanner.expect(Token.IDENT);
 241             curCode.LocVarDataEnd(name);
 242         }
 243     }
 244 
 245     void parseMapItem(DataVector map) throws Scanner.SyntaxError, IOException {
 246         StackMapType itemType = stackMapType(scanner.intValue, null);
 247         ConstType tag = null;
 248         Argument arg = null;
 249         Token ptoken = scanner.token;
 250         int iValue = scanner.intValue;
 251         String sValue = scanner.stringValue;
 252         scanner.scan();
 253         resolve:
 254         {
 255             switch (ptoken) {
 256                 case INTVAL:
 257                     break resolve;
 258                 case CLASS:
 259                     itemType = StackMapType.ITEM_Object;
 260                     tag = ConstType.CONSTANT_CLASS;
 261                     break resolve;
 262                 case CPINDEX:
 263                     itemType = StackMapType.ITEM_Object;
 264                     arg = pool.getCell(iValue);
 265                     break resolve;
 266                 case IDENT:
 267                     itemType = stackMapType(sValue);
 268                     tag = Tables.tag(sValue);
 269                     if (itemType != null) { // itemType OK
 270                         if ((tag != null) // ambiguity: &quot;int,&quot; or &quot;int 77,&quot;?
 271                                 &amp;&amp; (scanner.token != SEMICOLON)
 272                                 &amp;&amp; (scanner.token != COMMA)) {
 273                             itemType = StackMapType.ITEM_Object;
 274                         }
 275                         break resolve;
 276                     } else if (tag != null) { // tag OK
 277                         itemType = StackMapType.ITEM_Object;
 278                         break resolve;
 279                     }
 280             }
 281             // resolution failed:
 282             itemType = StackMapType.ITEM_Bogus;
 283             env.error(&quot;itemtype.expected&quot;, &quot;&lt;&quot; + ptoken.printValue() + &quot;&gt;&quot;);
 284         }
 285         switch (itemType) {
 286             case ITEM_Object:  // followed by CP index
 287                 if (arg == null) {
 288                     arg = pool.FindCell(cpParser.parseConstValue(tag));
 289                 }
 290                 map.addElement(new StackMapData.StackMapItem2(itemType, arg));
 291                 break;
 292             case ITEM_NewObject:  // followed by label
 293                 arg = instrParser.parseLabelRef();
 294                 map.addElement(new StackMapData.StackMapItem2(itemType, arg));
 295                 break;
 296             default:
 297                 map.addElement(new StackMapData.StackMapItem1(itemType));
 298         }
 299     }
 300 
 301     /**
 302      * Parse an external name: CPINDEX, string, or identifier.
 303      */
 304     ConstCell parseName() throws Scanner.SyntaxError, IOException {
 305         debugScan(&quot;------- [Parser.parseName]: &quot;);
 306         String v;
 307         switch (scanner.token) {
 308             case CPINDEX: {
 309                 int cpx = scanner.intValue;
 310                 scanner.scan();
 311                 return pool.getCell(cpx);
 312             }
 313             case STRINGVAL:
 314                 v = scanner.stringValue;
 315                 scanner.scan();
 316                 return pool.FindCellAsciz(v);
 317 
 318             // In many cases, Identifiers can correctly have the same
 319             // names as keywords.  We need to allow these.
 320             case OPEN:
 321             case MODULE:
 322             case VARARGS:
 323             case REQUIRES:
 324             case EXPORTS:
 325             case TO:
 326             case USES:
 327             case PROVIDES:
 328             case WITH:
 329             case OPENS:
 330 
 331             case ARRAY_TYPEPATH:
 332             case INNER_TYPE_TYPEPATH:
 333             case WILDCARD_TYPEPATH:
 334             case TYPE_ARGUMENT_TYPEPATH:
 335             case PERMITTEDSUBTYPES:
 336             case INF:
 337             case NAN:
 338             case COMPONENT:
 339 
 340             case SYNTHETIC:
 341             case DEPRECATED:
 342             case VERSION:
 343             case BITS:
 344             case STACK:
 345             case LOCAL:
 346             case OF:
 347             case INNERCLASS:
 348             case STRICT:
 349             case FIELDREF:
 350             case METHODREF:
 351             case IDENT:
 352             case BRIDGE:
 353                 v = scanner.idValue;
 354                 scanner.scan();
 355                 return pool.FindCellAsciz(v);
 356             default:
 357                 env.error(scanner.pos, &quot;name.expected&quot;, scanner.token);
 358                 throw new Scanner.SyntaxError();
 359         }
 360     }
 361 
 362     /**
 363      * Parses a field or method reference for method handle.
 364      */
 365     ConstCell parseMethodHandle(SubTag subtag) throws Scanner.SyntaxError, IOException {
 366         ConstCell refCell;
 367         switch (subtag) {
 368             // If the value of the reference_kind item is
 369             // 1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField)  or 4 (REF_putStatic),
<a name="1" id="anc1"></a><span class="line-modified"> 370             // then the constant_pool entry at that index must be a CONSTANT_Fieldref_info structure (ยง4.4.2)</span>
 371             // representing a field for which a method handle is to be created. jvms-4.4.8-200-C-A
 372             case REF_GETFIELD:
 373             case REF_GETSTATIC:
 374             case REF_PUTFIELD:
 375             case REF_PUTSTATIC:
 376                 refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_FIELD));
 377                 break;
 378             //  If the value of the reference_kind item is
 379             //  5 (REF_invokeVirtual) or 8 (REF_newInvokeSpecial),
<a name="2" id="anc2"></a><span class="line-modified"> 380             //  then the constant_pool entry at that index must be a CONSTANT_Methodref_info structure (ยง4.4.2)</span>
<span class="line-modified"> 381             //  representing a class&#39;s method or constructor (ยง2.9.1) for which a method handle is to be created.</span>
 382             //  jvms-4.4.8-200-C-B
 383             case REF_INVOKEVIRTUAL:
 384             case REF_NEWINVOKESPECIAL:
 385                 refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_METHOD));
 386                 break;
 387             case REF_INVOKESTATIC:
 388             case REF_INVOKESPECIAL:
 389                 // CODETOOLS-7902333
 390                 // 4.4.8. The CONSTANT_MethodHandle_info Structure
 391                 // reference_index
 392                 // The value of the reference_index item must be a valid index into the constant_pool table.
 393                 // The constant_pool entry at that index must be as follows:
 394                 // If the value of the reference_kind item is 6 (REF_invokeStatic) or 7 (REF_invokeSpecial),
 395                 // then if the class file version number is less than 52.0, the constant_pool entry at that index must be
 396                 // a CONSTANT_Methodref_info structure representing a class&#39;s method for which a method handle is to be created;
 397                 // if the class file version number is 52.0 or above, the constant_pool entry at that index must be
<a name="3" id="anc3"></a><span class="line-modified"> 398                 // either a CONSTANT_Methodref_info structure or a CONSTANT_InterfaceMethodref_info structure (ยง4.4.2)</span>
 399                 // representing a class&#39;s or interface&#39;s method for which a method handle is to be created.
 400                 ConstType ctype01 = ConstType.CONSTANT_METHOD;
 401                 ConstType ctype02 = ConstType.CONSTANT_INTERFACEMETHOD;
 402                 if (this.cd.cfv.major_version() &gt;= 52 &amp;&amp; Modifiers.isInterface(this.cd.access)) {
 403                     ctype01 = ConstType.CONSTANT_INTERFACEMETHOD;
 404                     ctype02 = ConstType.CONSTANT_METHOD;
 405                 }
 406                 refCell = cpParser.parseConstRef(ctype01, ctype02);
 407                 break;
 408             case REF_INVOKEINTERFACE:
 409                 refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_INTERFACEMETHOD));
 410                 break;
 411             default:
 412                 // should not reach
 413                 throw new Scanner.SyntaxError();
 414         }
 415         return refCell;
 416     }
 417 
 418     /**
 419      * Parses a sub-tag value in method handle.
 420      */
 421     SubTag parseSubtag() throws Scanner.SyntaxError, IOException {
 422         SubTag subtag = null;
 423         switch (scanner.token) {
 424             case IDENT:
 425                 subtag = subtag(scanner.stringValue);
 426                 break;
 427             case INTVAL:
 428                 subtag = subtag(scanner.intValue);
 429                 break;
 430         }
 431         if (subtag == null) {
 432             env.error(&quot;subtag.expected&quot;);
 433             throw new Scanner.SyntaxError();
 434         }
 435         scanner.scan();
 436         return subtag;
 437     }
 438 
 439     ConstCell parseClassName(boolean uncond) throws Scanner.SyntaxError, IOException {
 440         String v;
 441         switch (scanner.token) {
 442             case CPINDEX: {
 443                 int cpx = scanner.intValue;
 444                 scanner.scan();
 445                 return pool.getCell(cpx);
 446             }
 447             case STRINGVAL:
 448                 v = scanner.stringValue;
 449                 scanner.scan();
 450                 v = prependPackage(v, uncond);
 451                 return pool.FindCellAsciz(v);
 452             // Some identifiers might coincide with token names.
 453             // these should be OK to use as identifier names.
 454             case OPEN:
 455             case MODULE:
 456             case VARARGS:
 457             case REQUIRES:
 458             case EXPORTS:
 459             case TO:
 460             case USES:
 461             case PROVIDES:
 462             case WITH:
 463             case OPENS:
 464 
 465             case ARRAY_TYPEPATH:
 466             case INNER_TYPE_TYPEPATH:
 467             case WILDCARD_TYPEPATH:
 468             case TYPE_ARGUMENT_TYPEPATH:
 469             case PERMITTEDSUBTYPES:
 470             case INF:
 471             case NAN:
 472             case COMPONENT:
 473 
 474             case SYNTHETIC:
 475             case DEPRECATED:
 476             case VERSION:
 477             case BITS:
 478             case STACK:
 479             case LOCAL:
 480             case OF:
 481             case INNERCLASS:
 482             case STRICT:
 483             case FIELDREF:
 484             case METHODREF:
 485             case BRIDGE:
 486             case IDENT:
 487                 v = scanner.idValue;
 488                 scanner.scan();
 489                 v = prependPackage(v, uncond);
 490                 return pool.FindCellAsciz(v);
 491             default:
 492                 ConstType key = Tables.tag(scanner.token.value());
 493                 env.traceln(&quot;%%%%% Unrecognized token [&quot; + scanner.token + &quot;]: &#39;&quot; + (key == null ? &quot;null&quot; : key.parseKey()) + &quot;&#39;.&quot;);
 494                 env.error(scanner.prevPos, &quot;name.expected&quot;, &quot;\&quot;&quot; + scanner.token.parseKey() + &quot;\&quot;&quot;);
 495                 throw new Scanner.SyntaxError();
 496         }
 497     }
 498 
 499     private String prependPackage(String className, boolean uncond) {
 500         if (uncond || (scanner.token == Token.FIELD)) {
 501             if ((!className.contains(&quot;/&quot;))             // class identifier doesn&#39;t contain &quot;/&quot;
 502                     &amp;&amp; (!className.contains(&quot;[&quot;))) {    // class identifier doesn&#39;t contain &quot;[&quot;
 503                 className = pkgPrefix + className; // add package
 504             }
 505         }
 506         return className;
 507     }
 508 
 509     /**
 510      * Parse a signed integer of size bytes long.
 511      * size = 1 or 2
 512      */
 513     Argument parseInt(int size) throws Scanner.SyntaxError, IOException {
 514         if (scanner.token == Token.BITS) {
 515             scanner.scan();
 516         }
 517         if (scanner.token != Token.INTVAL) {
 518             env.error(scanner.pos, &quot;int.expected&quot;);
 519             throw new Scanner.SyntaxError();
 520         }
 521         int arg = scanner.intValue * scanner.sign;
 522         switch (size) {
 523             case 1:
 524 //                if ((arg&gt;127)||(arg&lt;-128)) { // 0xFF not allowed
 525                 if ((arg &gt; 255) || (arg &lt; -128)) { // to allow 0xFF
 526                     env.error(scanner.pos, &quot;value.large&quot;, &quot;1 byte&quot;);
 527                     throw new Scanner.SyntaxError();
 528                 }
 529                 break;
 530             case 2:
 531 //                if ((arg &gt; 32767) || (arg &lt; -32768)) { //this seems
 532 // natural but is not backward compatible. Some tests contain
 533 // expressions like:
 534 //                sipush    0x8765;
 535 
 536                 if ((arg &gt; 65535) || (arg &lt; -32768)) {
 537                     env.error(scanner.pos, &quot;value.large&quot;, &quot;2 bytes&quot;);
 538                     throw new Scanner.SyntaxError();
 539                 }
 540                 break;
 541             default:
 542                 throw new InternalError(&quot;parseInt(&quot; + size + &quot;)&quot;);
 543         }
 544         scanner.scan();
 545         return new Argument(arg);
 546     }
 547 
 548     /**
 549      * Parse an unsigned integer of size bytes long.
 550      * size = 1 or 2
 551      */
 552     Argument parseUInt(int size) throws Scanner.SyntaxError, IOException {
 553         if (scanner.token != Token.INTVAL) {
 554             env.error(scanner.pos, &quot;int.expected&quot;);
 555             throw new Scanner.SyntaxError();
 556         }
 557         if (scanner.sign == -1) {
 558             env.error(scanner.pos, &quot;neg.forbidden&quot;);
 559             throw new Scanner.SyntaxError();
 560         }
 561         int arg = scanner.intValue;
 562         switch (size) {
 563             case 1:
 564                 if (arg &gt; 255) {
 565                     env.error(scanner.pos, &quot;value.large&quot;, &quot;1 byte&quot;);
 566                     throw new Scanner.SyntaxError();
 567                 }
 568                 break;
 569             case 2:
 570                 if (arg &gt; 65535) {
 571                     env.error(scanner.pos, &quot;value.large&quot;, &quot;2 bytes&quot;);
 572                     throw new Scanner.SyntaxError();
 573                 }
 574                 break;
 575             default:
 576                 throw new InternalError(&quot;parseUInt(&quot; + size + &quot;)&quot;);
 577         }
 578         scanner.scan();
 579         return new Argument(arg);
 580     }
 581 
 582     /**
 583      * Parse constant declaration
 584      */
 585     private void parseConstDef() throws IOException {
 586         for (; ; ) {
 587             if (scanner.token == Token.CPINDEX) {
 588                 int cpx = scanner.intValue;
 589                 scanner.scan();
 590                 scanner.expect(Token.ASSIGN);
 591                 env.traceln(&quot;parseConstDef:&quot; + cpx);
 592                 pool.setCell(cpx, cpParser.parseConstRef(null));
 593             } else {
 594                 env.error(&quot;const.def.expected&quot;);
 595                 throw new Scanner.SyntaxError();
 596             }
 597             if (scanner.token != COMMA) {
 598                 scanner.expect(SEMICOLON);
 599                 return;
 600             }
 601             scanner.scan(); // COMMA
 602         }
 603     }
 604 
 605     /**
 606      * Parse the modifiers
 607      */
 608     private int scanModifier(int mod) throws IOException {
 609         int nextmod, prevpos;
 610 
 611         while (true) {
 612             nextmod = 0;
 613             switch (scanner.token) {
 614                 case PUBLIC:
 615                     nextmod = ACC_PUBLIC;
 616                     break;
 617                 case PRIVATE:
 618                     nextmod = ACC_PRIVATE;
 619                     break;
 620                 case PROTECTED:
 621                     nextmod = ACC_PROTECTED;
 622                     break;
 623                 case STATIC:
 624                     nextmod = ACC_STATIC;
 625                     break;
 626                 case FINAL:
 627                     nextmod = ACC_FINAL;
 628                     break;
 629                 case SYNCHRONIZED:
 630                     nextmod = ACC_SYNCHRONIZED;
 631                     break;
 632                 case SUPER:
 633                     nextmod = ACC_SUPER;
 634                     break;
 635                 case VOLATILE:
 636                     nextmod = ACC_VOLATILE;
 637                     break;
 638                 case BRIDGE:
 639                     nextmod = ACC_BRIDGE;
 640                     break;
 641                 case TRANSIENT:
 642                     nextmod = ACC_TRANSIENT;
 643                     break;
 644                 case VARARGS:
 645                     nextmod = ACC_VARARGS;
 646                     break;
 647                 case NATIVE:
 648                     nextmod = ACC_NATIVE;
 649                     break;
 650                 case INTERFACE:
 651                     nextmod = ACC_INTERFACE;
 652                     break;
 653                 case ABSTRACT:
 654                     nextmod = ACC_ABSTRACT;
 655                     break;
 656                 case STRICT:
 657                     nextmod = ACC_STRICT;
 658                     break;
 659                 case ENUM:
 660                     nextmod = ACC_ENUM;
 661                     break;
 662                 case SYNTHETIC:
 663                     nextmod = ACC_SYNTHETIC;
 664                     break;
 665                 case ANNOTATION_ACCESS:
 666                     nextmod = ACC_ANNOTATION;
 667                     break;
 668 
 669                 case DEPRECATED:
 670                     nextmod = DEPRECATED_ATTRIBUTE;
 671                     break;
 672                 case MANDATED:
 673                     nextmod = ACC_MANDATED;
 674                     break;
 675                 default:
 676                     return nextmod;
 677             }
 678             prevpos = scanner.pos;
 679             scanner.scan();
 680             if ((mod &amp; nextmod) == 0) {
 681                 return nextmod;
 682             }
 683             env.error(prevpos, &quot;warn.repeated.modifier&quot;);
 684         }
 685     }
 686 
 687     int scanModifiers() throws IOException {
 688         int mod = 0, nextmod;
 689 
 690         while (true) {
 691             nextmod = scanModifier(mod);
 692             if (nextmod == 0) {
 693                 return mod;
 694             }
 695             mod = mod | nextmod;
 696         }
 697     }
 698 
 699     /**
 700      * Parse a field.
 701      */
 702     private void parseField(int mod) throws Scanner.SyntaxError, IOException {
 703         debugStr(&quot;  [Parser.parseField]: &lt;&lt;&lt;Begin&gt;&gt;&gt;&quot;);
 704         // check access modifiers:
 705         Modifiers.checkFieldModifiers(cd, mod, scanner.pos);
 706 
 707         while (true) {
 708             ConstCell nameCell = parseName();
 709             scanner.expect(Token.COLON);
 710             ConstCell typeCell = parseName();
 711 
 712             // Define the variable
 713             FieldData fld = cd.addField(mod, nameCell, typeCell);
 714 
 715             if (memberAnnttns != null) {
 716                 fld.addAnnotations(memberAnnttns);
 717             }
 718 
 719             // Parse the optional attribute: signature
 720             if (scanner.token == Token.COLON) {
 721                 scanner.scan();
 722                 ConstCell signatureCell = parseName();
 723                 fld.setSignatureAttr(signatureCell);
 724             }
 725 
 726             // Parse the optional initializer
 727             if (scanner.token == Token.ASSIGN) {
 728                 scanner.scan();
 729                 fld.SetValue(cpParser.parseConstRef(null));
 730             }
 731 
 732             // If the next scanner.token is a comma, then there is more
 733             debugScan(&quot;  [Parser.parseField]: Field: &quot; + fld + &quot; &quot;);
 734 
 735             if (scanner.token != COMMA) {
 736                 scanner.expect(SEMICOLON);
 737                 return;
 738             }
 739             scanner.scan();
 740         }  // end while
 741     }  // end parseField
 742 
 743     /**
 744      * Scan method&#39;s signature to determine size of parameters.
 745      */
 746     private int countParams(ConstCell sigCell) throws Scanner.SyntaxError {
 747         String sig;
 748         try {
 749             ConstValue_String strConst = (ConstValue_String) sigCell.ref;
 750             sig = strConst.value;
 751         } catch (NullPointerException | ClassCastException e) {
 752             return 0; // ??? TBD
 753         }
 754         int siglen = sig.length(), k = 0, loccnt = 0, errparam = 0;
 755         boolean arraytype = false;
 756         scan:
 757         {
 758             if (k &gt;= siglen) {
 759                 break scan;
 760             }
 761             if (sig.charAt(k) != &#39;(&#39;) {
 762                 errparam = 1;
 763                 break scan;
 764             }
 765             for (k = 1; k &lt; siglen; k++) {
 766                 switch (sig.charAt(k)) {
 767                     case &#39;)&#39;:
 768                         if (arraytype) {
 769                             errparam = 2;
 770                             break scan;
 771                         }
 772                         return loccnt;
 773                     case &#39;[&#39;:
 774                         arraytype = true;
 775                         break;
 776                     case &#39;B&#39;:
 777                     case &#39;C&#39;:
 778                     case &#39;F&#39;:
 779                     case &#39;I&#39;:
 780                     case &#39;S&#39;:
 781                     case &#39;Z&#39;:
 782                         loccnt++;
 783                         arraytype = false;
 784                         break;
 785                     case &#39;D&#39;:
 786                     case &#39;J&#39;:
 787                         loccnt++;
 788                         if (arraytype) {
 789                             arraytype = false;
 790                         } else {
 791                             loccnt++;
 792                         }
 793                         break;
 794                     case &#39;L&#39;:
 795                         for (; ; k++) {
 796                             if (k &gt;= siglen) {
 797                                 errparam = 3;
 798                                 break scan;
 799                             }
 800                             if (sig.charAt(k) == &#39;;&#39;) {
 801                                 break;
 802                             }
 803                         }
 804                         loccnt++;
 805                         arraytype = false;
 806                         break;
 807                     default:
 808                         errparam = 4;
 809                         break scan;
 810                 }
 811             }
 812         }
 813         env.error(scanner.pos, &quot;msig.malformed&quot;, Integer.toString(k), Integer.toString(errparam));
 814         return loccnt;
 815     }
 816 
 817     /**
 818      * Parse a method.
 819      */
 820     private void parseMethod(int mod) throws Scanner.SyntaxError, IOException {
 821 
 822         // The start of the method
 823         int posa = scanner.pos;
 824         debugStr(&quot;  [Parser.parseMethod]: &lt;&lt;&lt;Begin&gt;&gt;&gt;&quot;);
 825 
 826         ConstCell nameCell = parseName();
 827         ConstValue_String strConst = (ConstValue_String) nameCell.ref;
 828         String name = strConst.value;
 829         boolean is_clinit = name.equals(&quot;&lt;clinit&gt;&quot;);
 830         boolean is_init = name.equals(&quot;&lt;init&gt;&quot;);
 831         DefaultAnnotationAttr defAnnot = null;
 832 
 833         // check access modifiers:
 834         Modifiers.checkMethodModifiers(cd, mod, posa, is_init, is_clinit);
 835 
 836         scanner.expect(Token.COLON);
 837         ConstCell typeCell = parseName();
 838         int paramcnt = countParams(typeCell);
 839         if ((!Modifiers.isStatic(mod)) &amp;&amp; !is_clinit) {
 840             paramcnt++;
 841         }
 842         if (paramcnt &gt; 255) {
 843             env.error(scanner.pos, &quot;warn.msig.more255&quot;, Integer.toString(paramcnt));
 844         }
 845         // Parse throws clause
 846         ArrayList&lt;ConstCell&gt; exc_table = null;
 847         if (scanner.token == Token.THROWS) {
 848             scanner.scan();
 849             exc_table = new ArrayList&lt;&gt;();
 850             for (; ; ) {
 851                 posa = scanner.pos;
 852                 ConstCell exc = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
 853                 if (exc_table.contains(exc)) {
 854                     env.error(posa, &quot;warn.exc.repeated&quot;);
 855                 } else {
 856                     exc_table.add(exc);
 857                     env.traceln(&quot;THROWS:&quot; + exc.arg);
 858                 }
 859                 if (scanner.token != COMMA) {
 860                     break;
 861                 }
 862                 scanner.scan();
 863             }
 864         }
 865         if (scanner.token == Token.DEFAULT) {
 866             // need to scan the annotation value
 867             defAnnot = annotParser.parseDefaultAnnotation();
 868         }
 869 
 870         MethodData curMethod = cd.StartMethod(mod, nameCell, typeCell, exc_table);
 871         Argument max_stack = null, max_locals = null;
 872 
 873         if (scanner.token == Token.STACK) {
 874             scanner.scan();
 875             max_stack = parseUInt(2);
 876         }
 877         if (scanner.token == Token.LOCAL) {
 878             scanner.scan();
 879             max_locals = parseUInt(2);
 880         }
 881         if (scanner.token == Token.INTVAL) {
 882             annotParser.parseParamAnnots(paramcnt, curMethod);
 883         }
 884 
 885         if (scanner.token == SEMICOLON) {
 886             if ((max_stack != null) || (max_locals != null)) {
 887                 env.error(&quot;token.expected&quot;, &quot;{&quot;);
 888             }
 889             scanner.scan();
 890         } else {
 891             scanner.expect(Token.LBRACE);
 892             curCode = curMethod.startCode(posa, paramcnt, max_stack, max_locals);
 893             while ((scanner.token != Token.EOF) &amp;&amp; (scanner.token != Token.RBRACE)) {
 894                 instrParser.parseInstr();
 895                 if (scanner.token == Token.RBRACE) {
 896                     break;
 897                 }
 898                 // code&#39;s type annotation(s)
 899                 if (scanner.token == Token.ANNOTATION) {
 900                     curCode.addAnnotations(annotParser.scanAnnotations());
 901                     break;
 902                 }
 903                 scanner.expect(SEMICOLON);
 904             }
 905             curCode.endCode();
 906             scanner.expect(Token.RBRACE);
 907         }
 908 
 909         if (defAnnot != null) {
 910             curMethod.addDefaultAnnotation(defAnnot);
 911         }
 912         if (memberAnnttns != null) {
 913             curMethod.addAnnotations(memberAnnttns);
 914         }
 915         cd.EndMethod();
 916         debugStr(&quot;  [Parser.parseMethod]: Method: &quot; + curMethod);
 917 
 918     }  // end parseMethod
 919 
 920     /**
 921      * Parse a (CPX based) BootstrapMethod entry.
 922      */
 923     private void parseCPXBootstrapMethod() throws Scanner.SyntaxError, IOException {
 924         // Parses in the form:
 925         // BOOTSTRAPMETHOD CPX_MethodHandle (CPX_Arg)* ;
 926         if (scanner.token == Token.CPINDEX) {
 927             // CPX can be a CPX to an MethodHandle constant,
 928             int cpx = scanner.intValue;
 929             ConstCell MHCell = pool.getCell(cpx);
 930             scanner.scan();
 931             ArrayList&lt;ConstCell&gt; bsm_args = new ArrayList&lt;&gt;(256);
 932 
 933             while (scanner.token != SEMICOLON) {
 934                 if (scanner.token == Token.CPINDEX) {
 935                     bsm_args.add(pool.getCell(scanner.intValue));
 936 
 937                 } else {
 938                     // throw error, bootstrap method is not recognizable
 939                     env.error(scanner.pos, &quot;invalid.bootstrapmethod&quot;);
 940                     throw new Scanner.SyntaxError();
 941                 }
 942                 scanner.scan();
 943             }
 944             BootstrapMethodData bsmData = new BootstrapMethodData(MHCell, bsm_args);
 945             cd.addBootstrapMethod(bsmData);
 946         } else {
 947             // throw error, bootstrap method is not recognizable
 948             env.error(scanner.pos, &quot;invalid.bootstrapmethod&quot;);
 949             throw new Scanner.SyntaxError();
 950         }
 951     }
 952 
 953     /**
 954      * Parse a NestHost entry
 955      */
 956     private void parseNestHost() throws Scanner.SyntaxError, IOException {
 957         // Parses in the form:
 958         // NESTHOST IDENT;
 959         debugStr(&quot;  [Parser.parseNestHost]: &lt;&lt;&lt;Begin&gt;&gt;&gt;&quot;);
 960         String className = prependPackage(parseIdent(), true);
 961         ConstCell hostClass = pool.FindCellClassByName(className);
 962         debugScan(&quot;  [Parser.parseNestHost]: NestHost: class &quot; + className);
 963         scanner.expect(SEMICOLON);
 964         cd.addNestHost(hostClass);
 965     }
 966 
 967     /**
 968      * Parse a list of classes belonging to the [NestMembers | PermittedSubtypes]  entry
 969      */
 970     private void parseClasses(Consumer&lt;ArrayList&lt;ConstCell&gt;&gt; classesConsumer)
 971             throws Scanner.SyntaxError, IOException {
 972         ArrayList&lt;ConstCell&gt; classes = new ArrayList&lt;&gt;();
 973         // Parses in the form:
 974         // (NESTMEMBERS|PERMITTEDSUBTYPES)? IDENT(, IDENT)*;
 975         debugStr(&quot;  [Parser.parseClasses]: &lt;&lt;&lt;Begin&gt;&gt;&gt;&quot;);
 976         while (true) {
 977             String className = prependPackage(parseIdent(), true);
 978             classes.add(pool.FindCellClassByName(className));
 979             debugScan(&quot;  [Parser.parseClasses]: class &quot; + className);
 980             if (scanner.token != COMMA) {
 981                 scanner.expect(SEMICOLON);
 982                 classesConsumer.accept(classes);
 983                 return;
 984             }
 985             scanner.scan();
 986         }
 987     }
 988 
 989     /**
 990      * Parse the Record entry
 991      */
 992     private void parseRecord() throws Scanner.SyntaxError, IOException {
 993         // Parses in the form:
 994         // RECORD { (COMPONENT)+ }
 995         // where
 996         // COMPONENT Component (ANNOTATION)* NAME:DESCRIPTOR(:SIGNATURE)? (,|;)
 997         // NAME = (CPINDEX | IDENT)
 998         // DESCRIPTOR = (CPINDEX | STRING)
 999         // SIGNATURE  = (CPINDEX | STRING)
1000         debugScan(&quot;[Parser.parseRecord]:  Begin&quot;);
1001         scanner.expect(Token.LBRACE);
1002 
1003         ArrayList&lt;AnnotationData&gt; componentAnntts = null;
1004         boolean grouped = false;
1005         RecordData rd = cd.setRecord(scanner.pos);
1006 
1007         while (true) {
1008             if (scanner.token == Token.RBRACE) {
1009                 if (rd.isEmpty()) {
1010                     env.error(scanner.pos, &quot;warn.no.components.in.record.attribute&quot;);
1011                     cd.rejectRecord();
1012                 } else if (grouped) {
1013                     env.error(scanner.pos, &quot;grouped.component.expected&quot;);
1014                 }
1015                 scanner.scan();
1016                 break;
1017             }
1018 
1019             ConstCell nameCell, descCell, signatureCell = null;
1020             if (scanner.token == Token.ANNOTATION) {
1021                 componentAnntts = annotParser.scanAnnotations();
1022             }
1023 
1024             scanner.expect(Token.COMPONENT);
1025 
1026             nameCell = parseName();
1027             scanner.expect(Token.COLON);
1028             descCell = parseName();
1029             // Parse the optional attribute: signature
1030             if (scanner.token == Token.COLON) {
1031                 scanner.scan();
1032                 signatureCell = parseName();
1033             }
1034 
1035             rd.addComponent(nameCell, descCell, signatureCell, componentAnntts);
1036 
1037             switch (scanner.token) {
1038                 case COMMA:
1039                     grouped = true;
1040                     break;
1041                 case SEMICOLON:
1042                     grouped = false;
1043                     componentAnntts = null;
1044                     break;
1045                 default:
1046                     env.error(scanner.pos, &quot;one.of.two.token.expected&quot;,
1047                             &quot;&lt;&quot; + SEMICOLON.printValue() + &quot;&gt;&quot;,
1048                             &quot;&lt;&quot; + COMMA.printValue() + &quot;&gt;&quot;);
1049                     break;
1050             }
1051             // next component
1052             scanner.scan();
1053         }  // end while
1054         debugScan(&quot;[Parser.parseRecord]:  End&quot;);
1055     }
1056 
1057     /**
1058      * Parse an inner class.
1059      */
1060     private void parseInnerClass(int mod) throws Scanner.SyntaxError, IOException {
1061         // Parses in the form:
1062         // MODIFIERS (INNERCLASSNAME =)? (INNERCLASS) (OF OUTERCLASS)? ;
1063         //
1064         // where
1065         //    INNERCLASSNAME = (IDENT | CPX_IN-CL-NM)
1066         //    INNERCLASS = (CLASS IDENT | CPX_IN-CL) (S2)
1067         //    OUTERCLASS = (CLASS IDENT | CPX_OT-CL) (S3)
1068         //
1069         // Note:
1070         //    If a class reference cannot be identified using IDENT, CPX indexes must be used.
1071 
1072         // check access modifiers:
1073         debugScan(&quot;[Parser.parseInnerClass]:  Begin &quot;);
1074         Modifiers.checkInnerClassModifiers(cd, mod, scanner.pos);
1075 
1076         ConstCell nameCell;
1077         ConstCell innerClass = null;
1078         ConstCell outerClass = null;
1079 
1080 
1081         if (scanner.token == Token.CLASS) {
1082             nameCell = pool.getCell(0);  // no NameIndex
1083             parseInnerClass_s2(mod, nameCell, innerClass, outerClass);
1084         } else {
1085             if ((scanner.token == Token.IDENT) || scanner.checkTokenIdent()) {
1086                 // Got a Class Name
1087                 nameCell = parseName();
1088                 parseInnerClass_s1(mod, nameCell, innerClass, outerClass);
1089             } else if (scanner.token == Token.CPINDEX) {
1090                 // CPX can be either a CPX to an InnerClassName,
1091                 // or a CPX to an InnerClassInfo
1092                 int cpx = scanner.intValue;
1093                 nameCell = pool.getCell(cpx);
1094                 ConstValue nameCellValue = nameCell.ref;
1095 
1096                 if (nameCellValue instanceof ConstValue_String) {
1097                     // got a name cell
1098                     scanner.scan();
1099                     parseInnerClass_s1(mod, nameCell, innerClass, outerClass);
1100                 } else {
1101                     // got a CPRef cell
1102                     nameCell = pool.getCell(0);  // no NameIndex
1103                     parseInnerClass_s2(mod, nameCell, innerClass, outerClass);
1104                 }
1105             } else {
1106                 pic_error();
1107             }
1108 
1109         }
1110     }
1111 
1112     private void parseInnerClass_s1(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {
1113         // next scanner.token must be &#39;=&#39;
1114         if (scanner.token == Token.ASSIGN) {
1115             scanner.scan();
1116             parseInnerClass_s2(mod, nameCell, innerClass, outerClass);
1117         } else {
1118             pic_error();
1119         }
1120 
1121     }
1122 
1123     private void parseInnerClass_s2(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {
1124         // scanner.token is either &quot;CLASS IDENT&quot; or &quot;CPX_Class&quot;
1125         if ((scanner.token == Token.CPINDEX) || (scanner.token == Token.CLASS)) {
1126             if (scanner.token == Token.CPINDEX) {
1127                 innerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1128             }
1129 
1130             if (scanner.token == Token.CLASS) {
1131                 // next symbol needs to be InnerClass
1132                 scanner.scan();
1133                 innerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1134             }
1135 
1136             // See if declaration is terminated
1137             if (scanner.token == SEMICOLON) {
1138                 // InnerClass is complete, no OUTERINFO;
1139                 outerClass = pool.getCell(0);
1140                 pic_tracecreate(mod, nameCell, innerClass, outerClass);
1141                 cd.addInnerClass(mod, nameCell, innerClass, outerClass);
1142             } else if (scanner.token == Token.OF) {
1143                 // got an outer class reference
1144                 parseInnerClass_s3(mod, nameCell, innerClass, outerClass);
1145             } else {
1146                 pic_error();
1147             }
1148 
1149         } else {
1150             pic_error();
1151         }
1152 
1153     }
1154 
1155     private void parseInnerClass_s3(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) throws IOException {
1156         scanner.scan();
1157         if ((scanner.token == Token.CLASS) || (scanner.token == Token.CPINDEX)) {
1158             if (scanner.token == Token.CLASS) {
1159                 // next symbol needs to be InnerClass
1160                 scanner.scan();
1161                 outerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1162             }
1163             if (scanner.token == Token.CPINDEX) {
1164                 outerClass = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1165             }
1166 
1167             if (scanner.token == SEMICOLON) {
1168                 pic_tracecreate(mod, nameCell, innerClass, outerClass);
1169                 cd.addInnerClass(mod, nameCell, innerClass, outerClass);
1170             } else {
1171                 pic_error();
1172             }
1173         } else {
1174             pic_error();
1175         }
1176     }
1177 
1178     private void pic_tracecreate(int mod, ConstCell nameCell, ConstCell innerClass, ConstCell outerClass) {
1179         // throw error, IC is not recognizable
1180         env.trace(&quot; Creating InnerClass: [&quot; + Modifiers.toString(mod, CF_Context.CTX_INNERCLASS) + &quot;], &quot;);
1181 
1182         if (nameCell != pool.getCell(0)) {
1183             ConstValue value = nameCell.ref;
1184             if (value != null) {
1185                 env.trace(value.toString() + &quot; = &quot;);
1186             }
1187         }
1188 
1189         ConstValue_Cell ici_val = (ConstValue_Cell) innerClass.ref;
1190         ConstCell ici_ascii = ici_val.cell;
1191         // Constant pool may not be numberized yet.
1192         //
1193         // check values before dereference on a trace.
1194         if (ici_ascii.ref == null) {
1195             env.trace(&quot;&lt;#cpx-unresolved&gt; &quot;);
1196         } else {
1197             ConstValue_String cval = (ConstValue_String) ici_ascii.ref;
1198             if (cval.value == null) {
1199                 env.trace(&quot;&lt;#cpx-0&gt; &quot;);
1200             } else {
1201                 env.trace(cval.value + &quot; &quot;);
1202             }
1203         }
1204 
1205         if (outerClass != pool.getCell(0)) {
1206             if (outerClass.arg != 0) {
1207                 ConstValue_Cell oci_val = (ConstValue_Cell) outerClass.ref;
1208                 ConstCell oci_ascii = oci_val.cell;
1209                 if (oci_ascii.ref == null) {
1210                     env.trace(&quot; of &lt;#cpx-unresolved&gt;  &quot;);
1211                 } else {
1212                     ConstValue_String cval = (ConstValue_String) oci_ascii.ref;
1213                     if (cval.value == null) {
1214                         env.trace(&quot; of &lt;#cpx-0&gt;  &quot;);
1215                     } else {
1216                         env.trace(&quot; of &quot; + cval.value);
1217                     }
1218                 }
1219             }
1220         }
1221 
1222         env.traceln(&quot;&quot;);
1223     }
1224 
1225     private void pic_error() {
1226         // throw error, IC is not recognizable
1227         env.error(scanner.pos, &quot;invalid.innerclass&quot;);
1228         throw new Scanner.SyntaxError();
1229     }
1230 
1231     /**
1232      * The match() method is used to quickly match opening
1233      * brackets (ie: &#39;(&#39;, &#39;{&#39;, or &#39;[&#39;) with their closing
1234      * counter part. This is useful during error recovery.&lt;p&gt;
1235      * &lt;p&gt;
1236      * Scan to a matching &#39;}&#39;, &#39;]&#39; or &#39;)&#39;. The current scanner.token must be
1237      * a &#39;{&#39;, &#39;[&#39; or &#39;(&#39;;
1238      */
1239     private void match(Token open, Token close) throws IOException {
1240         int depth = 1;
1241 
1242         while (true) {
1243             scanner.scan();
1244             if (scanner.token == open) {
1245                 depth++;
1246             } else if (scanner.token == close) {
1247                 if (--depth == 0) {
1248                     return;
1249                 }
1250             } else if (scanner.token == Token.EOF) {
1251                 env.error(scanner.pos, &quot;unbalanced.paren&quot;);
1252                 return;
1253             }
1254         }
1255     }
1256 
1257     /**
1258      * Recover after a syntax error in a field. This involves
1259      * discarding scanner.tokens until an EOF or a possible legal
1260      * continuation is encountered.
1261      */
1262     private void recoverField() throws Scanner.SyntaxError, IOException {
1263         while (true) {
1264             switch (scanner.token) {
1265                 case EOF:
1266                 case STATIC:
1267                 case FINAL:
1268                 case PUBLIC:
1269                 case PRIVATE:
1270                 case SYNCHRONIZED:
1271                 case TRANSIENT:
1272                 case PROTECTED:
1273                 case VOLATILE:
1274                 case NATIVE:
1275 //                case INTERFACE: see below
1276                 case ABSTRACT:
1277                 case ANNOTATION_ACCESS:
1278                     // possible begin of a field, continue
1279                     return;
1280 
1281                 case LBRACE:
1282                     match(Token.LBRACE, Token.RBRACE);
1283                     scanner.scan();
1284                     break;
1285 
1286                 case LPAREN:
1287                     match(Token.LPAREN, Token.RPAREN);
1288                     scanner.scan();
1289                     break;
1290 
1291                 case LSQBRACKET:
1292                     match(Token.LSQBRACKET, Token.RSQBRACKET);
1293                     scanner.scan();
1294                     break;
1295 
1296                 case RBRACE:
1297                 case INTERFACE:
1298                 case CLASS:
1299                 case IMPORT:
1300                 case PACKAGE:
1301                     // begin of something outside a class, panic more
1302                     endClass();
1303                     scanner.debugStr(&quot;    [Parser.recoverField]: pos: [&quot; + scanner.pos + &quot;]: &quot;);
1304                     throw new Scanner.SyntaxError();
1305 
1306                 default:
1307                     // don&#39;t know what to do, skip
1308                     scanner.scan();
1309                     break;
1310             }
1311         }
1312     }
1313 
1314     /**
1315      * Parse a class or interface declaration.
1316      */
1317     private void parseClass(int mod) throws IOException {
1318         int posa = scanner.pos;
1319         debugStr(&quot;   [Parser.parseClass]:  Begin &quot;);
1320         // check access modifiers:
1321         Modifiers.checkClassModifiers(env, mod, scanner);
1322 
1323         if (cd == null) {
1324             cd = new ClassData(env, currentCFV.clone());
1325             pool = cd.pool;
1326         }
1327 
1328         if (clsAnnttns != null) {
1329             cd.addAnnotations(clsAnnttns);
1330         }
1331 
1332         // move the tokenizer to the identifier:
1333         if (scanner.token == Token.CLASS) {
1334             scanner.scan();
1335         } else if (scanner.token == Token.ANNOTATION) {
1336             scanner.scan();
1337             if (scanner.token == Token.INTERFACE) {
1338                 mod |= ACC_ANNOTATION | ACC_INTERFACE;
1339                 scanner.scan();
1340             } else {
1341                 env.error(scanner.prevPos, &quot;token.expected&quot;, Token.ANNOTATION.parseKey() + Token.INTERFACE.parseKey());
1342                 throw new Scanner.SyntaxError();
1343             }
1344         }
1345 
1346         // Parse the class name
1347         ConstCell nm = cpParser.parseConstRef(ConstType.CONSTANT_CLASS, null, true);
1348 
1349         if (scanner.token == Token.FIELD) { // DOT
1350             String fileExtension;
1351             scanner.scan();
1352             switch (scanner.token) {
1353                 case STRINGVAL:
1354                     fileExtension = scanner.stringValue;
1355                     break;
1356                 case IDENT:
1357                     fileExtension = scanner.idValue;
1358                     break;
1359                 default:
1360                     env.error(scanner.pos, &quot;name.expected&quot;);
1361                     throw new Scanner.SyntaxError();
1362             }
1363             scanner.scan();
1364             cd.fileExtension = &quot;.&quot; + fileExtension;
1365         } else if (scanner.token == Token.MODULE) {
1366             env.error(scanner.prevPos, &quot;token.expected&quot;, Token.OPEN.parseKey());
1367             throw new Scanner.SyntaxError();
1368         } else if (scanner.token == SEMICOLON) {
1369             // drop the semi-colon following a name
1370             scanner.scan();
1371         }
1372 
1373         // Parse extends clause
1374         ConstCell sup = null;
1375         if (scanner.token == Token.EXTENDS) {
1376             scanner.scan();
1377             sup = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1378             while (scanner.token == COMMA) {
1379                 scanner.scan();
1380                 env.error(posa, &quot;multiple.inherit&quot;);
1381                 cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1382             }
1383         }
1384 
1385         // Parse implements clause
1386         ArrayList&lt;Argument&gt; impl = new ArrayList&lt;&gt;();
1387         if (scanner.token == Token.IMPLEMENTS) {
1388             do {
1389                 scanner.scan();
1390                 Argument intf = cpParser.parseConstRef(ConstType.CONSTANT_CLASS);
1391                 if (impl.contains(intf)) {
1392                     env.error(posa, &quot;warn.intf.repeated&quot;, intf);
1393                 } else {
1394                     impl.add(intf);
1395                 }
1396             } while (scanner.token == COMMA);
1397         }
1398         parseVersion();
1399         scanner.expect(Token.LBRACE);
1400 
1401         // Begin a new class
1402         cd.init(mod, nm, sup, impl);
1403 
1404         // Parse constant declarations
1405 
1406         // Parse class members
1407         while ((scanner.token != Token.EOF) &amp;&amp; (scanner.token != Token.RBRACE)) {
1408             switch (scanner.token) {
1409                 case SEMICOLON:
1410                     // Empty fields are allowed
1411                     scanner.scan();
1412                     break;
1413                 case CONST:
1414                     scanner.scan();
1415                     parseConstDef();
1416                     explicitcp = true;
1417                     break;
1418                 default:   // scanner.token is some member.
1419                     parseClassMembers();
1420             }  // end switch
1421         } // while
1422         scanner.expect(Token.RBRACE);
1423         // End the class
1424         endClass();
1425     } // end parseClass
1426 
1427     /**
1428      * Parses a package or type name in a module statement(s)
1429      */
1430     private String parseTypeName() throws IOException {
1431         String name = &quot;&quot;, field = &quot;&quot;;
1432         while (true) {
1433             if (scanner.token.possibleModuleName()) {
1434                 name = name + field + scanner.idValue;
1435                 scanner.scan();
1436             } else {
1437                 env.error(scanner.pos, &quot;name.expected&quot;, &quot;\&quot;&quot; + scanner.token.parseKey() + &quot;\&quot;&quot;);
1438                 throw new Scanner.SyntaxError();
1439             }
1440             if (scanner.token == Token.FIELD) {
1441                 env.error(scanner.pos, &quot;warn.dot.will.be.converted&quot;);
1442                 field = &quot;/&quot;;
1443                 scanner.scan();
1444             } else {
1445                 break;
1446             }
1447         }
1448         return name;
1449     }
1450 
1451     /**
1452      * Parses a module name in a module statement(s)
1453      */
1454     private String parseModuleName() throws IOException {
1455         String name = &quot;&quot;, field = &quot;&quot;;
1456         while (true) {
1457             if (scanner.token.possibleModuleName()) {
1458                 name = name + field + scanner.idValue;
1459                 scanner.scanModuleStatement();
1460             } else {
1461                 env.error(scanner.pos, &quot;module.name.expected&quot;, &quot;\&quot;&quot; + scanner.token.parseKey() + &quot;\&quot;&quot;);
1462                 throw new Scanner.SyntaxError().Fatal();
1463             }
1464             if (scanner.token == Token.FIELD) {
1465                 field = Character.toString((char) scanner.token.value());
1466                 scanner.scanModuleStatement();
1467             } else {
1468                 break;
1469             }
1470         }
1471         return name;
1472     }
1473 
1474     /**
1475      * Parse a module declaration.
1476      */
1477     private void parseModule() throws IOException {
1478         debugStr(&quot;   [Parser.parseModule]:  Begin &quot;);
1479         if (cd == null) {
1480             cd = new ClassData(env, currentCFV.clone());
1481             pool = cd.pool;
1482         }
1483         if (clsAnnttns != null) {
1484             cd.addAnnotations(clsAnnttns);
1485         }
1486         moduleAttribute = new ModuleAttr(cd);
1487 
1488         if (scanner.token == Token.OPEN) {
1489             moduleAttribute.openModule();
1490             scanner.scan();
1491         }
1492 
1493         // move the tokenizer to the identifier:
1494         if (scanner.token == Token.MODULE) {
1495             scanner.scanModuleStatement();
1496             // scanner.scan();
1497         } else {
1498             env.error(scanner.pos, &quot;token.expected&quot;, Token.MODULE.parseKey());
1499             throw new Scanner.SyntaxError().Fatal();
1500         }
1501         // Parse the module name
1502         String moduleName = parseModuleName();
1503         if (moduleName.isEmpty()) {
1504             env.error(scanner.pos, &quot;name.expected&quot;);
1505             throw new Scanner.SyntaxError().Fatal();
1506         }
1507         moduleAttribute.setModuleName(moduleName);
1508 
1509         parseVersion();
1510         scanner.expect(Token.LBRACE);
1511 
1512         // Begin a new class as module
1513         cd.initAsModule();
1514 
1515         // Parse module statement(s)
1516         while ((scanner.token != Token.EOF) &amp;&amp; (scanner.token != Token.RBRACE)) {
1517             switch (scanner.token) {
1518                 case REQUIRES:
1519                     scanRequires(moduleAttribute.requires);
1520                     break;
1521                 case EXPORTS:
1522                     scanStatement(moduleAttribute.exports,
1523                             this::parseTypeName,
1524                             this::parseModuleName,
1525                             Token.TO,
1526                             true,
1527                             &quot;exports.expected&quot;);
1528                     break;
1529                 case OPENS:
1530                     scanStatement(moduleAttribute.opens,
1531                             this::parseTypeName,
1532                             this::parseModuleName,
1533                             Token.TO, true, &quot;opens.expected&quot;);
1534                     break;
1535                 case USES:
1536                     scanStatement(moduleAttribute.uses, &quot;uses.expected&quot;);
1537                     break;
1538                 case PROVIDES:
1539                     scanStatement(moduleAttribute.provides,
1540                             this::parseTypeName,
1541                             this::parseTypeName,
1542                             Token.WITH,
1543                             false,
1544                             &quot;provides.expected&quot;);
1545                     break;
1546                 case SEMICOLON:
1547                     // Empty fields are allowed
1548                     scanner.scan();
1549                     break;
1550                 default:
1551                     env.error(scanner.pos, &quot;module.statement.expected&quot;);
1552                     throw new Scanner.SyntaxError().Fatal();
1553             }  // end switch
1554         } // while
1555         scanner.expect(Token.RBRACE);
1556         // End the module
1557         endModule();
1558     } // end parseModule
1559 
1560     /**
1561      * Scans  ModuleStatement: requires [transitive] [static] ModuleName ;
1562      */
1563     private void scanRequires(BiConsumer&lt;String, Integer&gt; action) throws IOException {
1564         int flags = 0;
1565         String mn = &quot;&quot;;
1566         scanner.scanModuleStatement();
1567         while (scanner.token != SEMICOLON) {
1568             switch (scanner.token) {
1569                 case STATIC:
1570                     if (((flags &amp; (1 &lt;&lt; Module.Modifier.ACC_STATIC_PHASE.asInt())) != 0) || !mn.isEmpty()) {
1571                         env.error(scanner.pos, &quot;requires.expected&quot;);
1572                         throw new Scanner.SyntaxError().Fatal();
1573                     }
1574                     flags |= Module.Modifier.ACC_STATIC_PHASE.asInt();
1575                     break;
1576                 case TRANSITIVE:
1577                     if (((flags &amp; (1 &lt;&lt; Module.Modifier.ACC_TRANSITIVE.asInt())) != 0) || !mn.isEmpty()) {
1578                         env.error(scanner.pos, &quot;requires.expected&quot;);
1579                         throw new Scanner.SyntaxError().Fatal();
1580                     }
1581                     flags |= Module.Modifier.ACC_TRANSITIVE.asInt();
1582                     break;
1583                 case IDENT:
1584                     if (!mn.isEmpty()) {
1585                         env.error(scanner.pos, &quot;requires.expected&quot;);
1586                         throw new Scanner.SyntaxError().Fatal();
1587                     }
1588                     mn = parseModuleName();
1589                     continue;
1590                 default:
1591                     if (mn.isEmpty() &amp;&amp; scanner.token.possibleModuleName()) {
1592                         mn = parseModuleName();
1593                         continue;
1594                     } else {
1595                         env.error(scanner.pos, &quot;requires.expected&quot;);
1596                         throw new Scanner.SyntaxError().Fatal();
1597                     }
1598             }
1599             scanner.scanModuleStatement();
1600         }
1601         // Token.SEMICOLON
1602         if (mn.isEmpty()) {
1603             env.error(scanner.pos, &quot;requires.expected&quot;);
1604             throw new Scanner.SyntaxError().Fatal();
1605         }
1606         action.accept(mn, flags);
1607         scanner.scanModuleStatement();
1608     }
1609 
1610     /**
1611      * Scans  ModuleStatement: uses TypeName;
1612      */
1613     private void scanStatement(Consumer&lt;Set&lt;String&gt;&gt; action, String err) throws IOException {
1614         HashSet&lt;String&gt; names = scanList(() -&gt; scanner.scan(), this::parseTypeName, err, true);
1615         // Token.SEMICOLON
1616         if (names.size() != 1) {
1617             env.error(scanner.pos, err);
1618             throw new Scanner.SyntaxError().Fatal();
1619         }
1620         action.accept(names);
1621         scanner.scan();
1622     }
1623 
1624     /**
1625      * Scans  Module Statement(s):
1626      * exports  packageName [to ModuleName {, ModuleName}] ;
1627      * opens    packageName [to ModuleName {, ModuleName}] ;
1628      * provides TypeName with TypeName [,typeName] ;
1629      */
1630     private void scanStatement(BiConsumer&lt;String, Set&lt;String&gt;&gt; action,
1631                                NameSupplier source,
1632                                NameSupplier target,
1633                                Token startList,
1634                                boolean emptyListAllowed,
1635                                String err) throws IOException {
1636         String typeName = &quot;&quot;;
1637         HashSet&lt;String&gt; names = new HashSet&lt;&gt;();
1638         scanner.scan();
1639         while (scanner.token != SEMICOLON) {
1640             if (scanner.token == Token.IDENT) {
1641                 if (typeName.isEmpty()) {
1642                     typeName = source.get();
1643                     continue;
1644                 }
1645                 env.error(scanner.pos, err);
1646                 throw new Scanner.SyntaxError().Fatal();
1647             }
1648             if (scanner.token == startList) {
1649                 if (typeName.isEmpty()) {
1650                     env.error(scanner.pos, err);
1651                     throw new Scanner.SyntaxError().Fatal();
1652                 }
1653                 names = scanList(scanner.token == Token.TO ? () -&gt; scanner.scanModuleStatement() : () -&gt; scanner.scan(), target, err, false);
1654                 break;
1655             } else {
1656                 env.error(scanner.pos, err);
1657                 throw new Scanner.SyntaxError().Fatal();
1658             }
1659         }
1660         // Token.SEMICOLON
1661         if (typeName.isEmpty() || (names.isEmpty() &amp;&amp; !emptyListAllowed)) {
1662             env.error(scanner.pos, err);
1663             throw new Scanner.SyntaxError().Fatal();
1664         }
1665         action.accept(typeName, names);
1666         scanner.scan();
1667     }
1668 
1669     /**
1670      * Scans the &quot;to&quot; or &quot;with&quot; part of ModuleStatement: exports PackageName  [to  ModuleName {, ModuleName}] ;,
1671      * opens  packageName   [to  ModuleName {, ModuleName}] ;
1672      * provides TypeName with TypeName [,typeName] ;
1673      * uses TypeName;
1674      * : [ModuleName {, ModuleName}]; , [TypeName [,typeName]]; or TypeName;
1675      */
1676     private HashSet&lt;String&gt; scanList(Method scanMethod, NameSupplier target, String err, boolean onlyOneElement) throws IOException {
1677         HashSet&lt;String&gt; names = new HashSet&lt;&gt;();
1678         boolean comma = false, first = true;
1679         scanMethod.call();
1680         while (scanner.token != SEMICOLON) {
1681             switch (scanner.token) {
1682                 case COMMA:
1683                     if (comma || first || onlyOneElement) {
1684                         env.error(scanner.pos, err);
1685                         throw new Scanner.SyntaxError().Fatal();
1686                     }
1687                     comma = true;
1688                     break;
1689                 case IDENT:
1690                     if (!first &amp;&amp; !comma) {
1691                         env.error(scanner.pos, err);
1692                         throw new Scanner.SyntaxError().Fatal();
1693                     }
1694                     names.add(target.get());
1695                     comma = false;
1696                     first = false;
1697                     continue;
1698                 default:
1699                     env.error(scanner.pos, err);
1700                     throw new Scanner.SyntaxError().Fatal();
1701             }
1702             scanner.scan();
1703         }
1704         // Token.SEMICOLON
1705         if (names.isEmpty() || comma) {
1706             env.error(scanner.pos, err);
1707             throw new Scanner.SyntaxError().Fatal();
1708         }
1709         return names;
1710     }
1711 
1712     private void parseClassMembers() throws IOException {
1713         debugScan(&quot;[Parser.parseClassMembers]:  Begin &quot;);
1714         // Parse annotations
1715         if (scanner.token == Token.ANNOTATION) {
1716             memberAnnttns = annotParser.scanAnnotations();
1717         }
1718         // Parse modifiers
1719         int mod = scanModifiers();
1720         try {
1721             switch (scanner.token) {
1722                 case FIELDREF:
1723                     scanner.scan();
1724                     parseField(mod);
1725                     break;
1726                 case METHODREF:
1727                     scanner.scan();
1728                     parseMethod(mod);
1729                     break;
1730                 case INNERCLASS:
1731                     scanner.scan();
1732                     parseInnerClass(mod);
1733                     break;
1734                 case BOOTSTRAPMETHOD:
1735                     scanner.scan();
1736                     parseCPXBootstrapMethod();
1737                     break;
1738                 case NESTHOST:
1739                     if (cd.nestHostAttributeExists()) {
1740                         env.error(scanner.pos, &quot;extra.nesthost.attribute&quot;);
1741                         throw new Scanner.SyntaxError();
1742                     } else if (cd.nestMembersAttributesExist()) {
1743                         env.error(scanner.pos, &quot;both.nesthost.nestmembers.found&quot;);
1744                         throw new Scanner.SyntaxError();
1745                     }
1746                     scanner.scan();
1747                     parseNestHost();
1748                     break;
1749                 case NESTMEMBERS:
1750                     if (cd.nestMembersAttributesExist()) {
1751                         env.error(scanner.pos, &quot;extra.nestmembers.attribute&quot;);
1752                         throw new Scanner.SyntaxError();
1753                     } else if (cd.nestHostAttributeExists()) {
1754                         env.error(scanner.pos, &quot;both.nesthost.nestmembers.found&quot;);
1755                         throw new Scanner.SyntaxError();
1756                     }
1757                     scanner.scan();
1758                     parseClasses(list -&gt; cd.addNestMembers(list));
1759                     break;
1760                 case PERMITTEDSUBTYPES:         // JEP 360
1761                     if (cd.nestMembersAttributesExist()) {
1762                         env.error(scanner.pos, &quot;extra.permittedsubtypes.attribute&quot;);
1763                         throw new Scanner.SyntaxError();
1764                     }
1765                     scanner.scan();
1766                     parseClasses(list -&gt; cd.addPermittedSubtypes(list));
1767                     break;
1768                 case RECORD:                    // JEP 359
1769                     if (cd.recordAttributeExists()) {
1770                         env.error(scanner.pos, &quot;extra.record.attribute&quot;);
1771                         throw new Scanner.SyntaxError();
1772                     }
1773                     scanner.scan();
1774                     parseRecord();
1775                     break;
1776                 default:
1777                     env.error(scanner.pos, &quot;field.expected&quot;);
1778                     throw new Scanner.SyntaxError();
1779             }  // end switch
1780         } catch (Scanner.SyntaxError e) {
1781             recoverField();
1782         }
1783         memberAnnttns = null;
1784     }
1785 
1786     /**
1787      * Recover after a syntax error in the file.
1788      * This involves discarding scanner.tokens until an EOF
1789      * or a possible legal continuation is encountered.
1790      */
1791     private void recoverFile() throws IOException {
1792         while (true) {
1793             env.traceln(&quot;recoverFile: scanner.token=&quot; + scanner.token);
1794             switch (scanner.token) {
1795                 case CLASS:
1796                 case INTERFACE:
1797                     // Start of a new source file statement, continue
1798                     return;
1799 
1800                 case LBRACE:
1801                     match(Token.LBRACE, Token.RBRACE);
1802                     scanner.scan();
1803                     break;
1804 
1805                 case LPAREN:
1806                     match(Token.LPAREN, Token.RPAREN);
1807                     scanner.scan();
1808                     break;
1809 
1810                 case LSQBRACKET:
1811                     match(Token.LSQBRACKET, Token.RSQBRACKET);
1812                     scanner.scan();
1813                     break;
1814 
1815                 case EOF:
1816                     return;
1817 
1818                 default:
1819                     // Don&#39;t know what to do, skip
1820                     scanner.scan();
1821                     break;
1822             }
1823         }
1824     }
1825 
1826     /**
1827      * End class
1828      */
1829     private void endClass() {
1830         if (explicitcp) {
1831             // Fix references in the constant pool (for explicitly coded CPs)
1832             pool.fixRefsInPool();
1833             // Fix any bootstrap Method references too
1834             cd.relinkBootstrapMethods();
1835         }
1836         cd.endClass();
1837         clsDataList.add(cd);
1838         cd = null;
1839     }
1840 
1841     /**
1842      * End module
1843      */
1844     private void endModule() {
1845         cd.endModule(moduleAttribute);
1846         clsDataList.add(cd);
1847         cd = null;
1848     }
1849 
1850     final ClassData[] getClassesData() {
1851         return ((ClassData[]) clsDataList.toArray(new ClassData[0]));
1852     }
1853 
1854     /**
1855      * Determines whether the JASM file is for a package-info class
1856      * or for a module-info class.
1857      * &lt;p&gt;
1858      * creates the correct kind of ClassData accordingly.
1859      *
1860      * @throws IOException
1861      */
1862     private void parseJasmPackages() throws IOException {
1863         try {
1864             // starting annotations could either be
1865             // a package annotation, or a class annotation
1866             if (scanner.token == Token.ANNOTATION) {
1867                 if (cd == null) {
1868                     cd = new ClassData(env, currentCFV.clone());
1869                     pool = cd.pool;
1870                 }
1871                 pkgAnnttns = annotParser.scanAnnotations();
1872             }
1873             if (scanner.token == Token.PACKAGE) {
1874                 // Package statement
1875                 scanner.scan();
1876                 int where = scanner.pos;
1877                 String id = parseIdent();
1878                 parseVersionPkg();
1879                 scanner.expect(SEMICOLON);
1880 
1881                 if (pkg == null) {
1882                     pkg = id;
1883                     pkgPrefix = id + &quot;/&quot;;
1884                 } else {
1885                     env.error(where, &quot;package.repeated&quot;);
1886                 }
1887                 debugScan(&quot;[Parser.parseJasmPackages] {PARSED} package-prefix: &quot; + pkgPrefix + &quot; &quot;);
1888             }
1889         } catch (Scanner.SyntaxError e) {
1890             recoverFile();
1891         }
1892         // skip bogus semi colons
1893         while (scanner.token == SEMICOLON) {
1894             scanner.scan();
1895         }
1896 
1897         // checks that we compile module or package compilation unit
1898         if (scanner.token == Token.EOF) {
1899             env.traceln(&quot;Scanner:  EOF&quot;);
1900             String sourceName = env.getSimpleInputFileName();
1901             int mod = ACC_INTERFACE | ACC_ABSTRACT;
1902 
1903             // package-info
1904             if (sourceName.endsWith(&quot;package-info.jasm&quot;)) {
1905                 env.traceln(&quot;Creating \&quot;package-info.jasm\&quot;: package: &quot; + pkg + &quot; &quot; + currentCFV.asString());
1906 
1907                 if (cd == null) {
1908                     cd = new ClassData(env, currentCFV.clone());
1909                     pool = cd.pool;
1910                 } else {
1911                     cd.cfv = currentCFV.clone();
1912                 }
1913                 ConstCell me = pool.FindCellClassByName(pkgPrefix + &quot;package-info&quot;);
1914 
1915                 // Interface package-info should be marked synthetic and abstract
1916                 if (currentCFV.major_version() &gt; 49) {
1917                     mod |= SYNTHETIC_ATTRIBUTE;
1918                 }
1919                 cd.init(mod, me, new ConstCell(0), null);
1920 
1921                 if (pkgAnnttns != null) {
1922                     cd.addAnnotations(pkgAnnttns);
1923                 }
1924 
1925                 endClass();
1926             }
1927             return;
1928         }
1929 
1930         if (pkg == null &amp;&amp; pkgAnnttns != null) { // RemoveModules
1931             clsAnnttns = pkgAnnttns;
1932             pkgAnnttns = null;
1933         }
1934     }
1935 
1936     /**
1937      * Parse an Jasm file.
1938      */
1939     void parseFile() {
1940         try {
1941             // First, parse any package identifiers (and associated package annotations)
1942             parseJasmPackages();
1943 
1944             while (scanner.token != Token.EOF) {
1945                 // Second, parse any class identifiers (and associated class annotations)
1946                 try {
1947                     // Parse annotations
1948                     if (scanner.token == Token.ANNOTATION) {
1949                         if (cd == null) {
1950                             cd = new ClassData(env, currentCFV.clone());
1951                             pool = cd.pool;
1952                         } else {
1953                             cd.cfv = currentCFV.clone();
1954                         }
1955                         clsAnnttns = annotParser.scanAnnotations();
1956                     }
1957 
1958                     // Parse class modifiers
1959                     int mod = scanModifiers();
1960                     if (mod == 0) {
1961                         switch (scanner.token) {
1962                             case OPEN:
1963                             case MODULE:
1964                             case CLASS:
1965                             case CPINDEX:
1966                             case STRINGVAL:
1967                             case IDENT:
1968                                 // this is a class declaration anyway
1969                                 break;
1970                             case SEMICOLON:
1971                                 // Bogus semi colon
1972                                 scanner.scan();
1973                                 continue;
1974                             default:
1975                                 // no class declaration found
1976                                 debugScan(&quot; [Parser.parseFile]: &quot;);
1977                                 env.error(scanner.pos, &quot;toplevel.expected&quot;);
1978                                 throw new Scanner.SyntaxError();
1979                         }
1980                     } else if (Modifiers.isInterface(mod) &amp;&amp; (scanner.token != Token.CLASS)) {
1981                         // rare syntactic sugar:
1982                         // interface &lt;ident&gt; == abstract interface class &lt;ident&gt;
1983                         mod |= ACC_ABSTRACT;
1984                     }
1985                     if (scanner.token == Token.MODULE || scanner.token == Token.OPEN)
1986                         parseModule();
1987                     else
1988                         parseClass(mod);
1989                     clsAnnttns = null;
1990 
1991                 } catch (Scanner.SyntaxError e) {
1992                     // KTL
1993                     env.traceln(&quot;^^^^^^^ Syntax Error ^^^^^^^^^^^^&quot;);
1994                     if (scanner.debugFlag)
1995                         e.printStackTrace();
1996                     if (e.isFatal()) {
1997                         break;
1998                     }
1999                     recoverFile();
2000                 }
2001             }
2002         } catch (IOException e) {
2003             env.error(scanner.pos, &quot;io.exception&quot;, env.getSimpleInputFileName());
2004         } catch (Error er) {
2005             er.printStackTrace();
2006         }
2007     } //end parseFile
2008 
2009     @FunctionalInterface
2010     interface NameSupplier {
2011         String get() throws IOException;
2012     }
2013 
2014     @FunctionalInterface
2015     interface Method {
2016         void call() throws IOException;
2017     }
2018 
2019     /**
2020      * The main compile error for the parser
2021      */
2022     static class CompilerError extends Error {
2023 
2024         CompilerError(String message) {
2025             super(message);
2026         }
2027     }
2028 }  //end Parser
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>