<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
  39 import com.sun.tools.javac.code.Types.UniqueType;
  40 import com.sun.tools.javac.comp.Infer.IncorporationAction;
  41 import com.sun.tools.javac.jvm.ClassFile;
  42 import com.sun.tools.javac.jvm.PoolConstant;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import static com.sun.tools.javac.code.BoundKind.*;
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
  49 import static com.sun.tools.javac.code.TypeTag.*;
  50 
  51 /** This class represents Java types. The class itself defines the behavior of
  52  *  the following types:
  53  *  &lt;pre&gt;
  54  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  55  *  type `void&#39; (tag: VOID),
  56  *  the bottom type (tag: BOT),
  57  *  the missing type (tag: NONE).
  58  *  &lt;/pre&gt;
  59  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  60  *  all static inner classes of this class:
  61  *  &lt;pre&gt;
  62  *  class types (tag: CLASS, class: ClassType),
  63  *  array types (tag: ARRAY, class: ArrayType),
  64  *  method types (tag: METHOD, class: MethodType),
  65  *  package types (tag: PACKAGE, class: PackageType),
  66  *  type variables (tag: TYPEVAR, class: TypeVar),
  67  *  type arguments (tag: WILDCARD, class: WildcardType),
  68  *  generic method types (tag: FORALL, class: ForAll),
  69  *  the error type (tag: ERROR, class: ErrorType).
  70  *  &lt;/pre&gt;
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  *
  77  *  @see TypeTag
  78  */
  79 public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {
  80 
  81     /**
  82      * Type metadata,  Should be {@code null} for the default value.
  83      *
  84      * Note: it is an invariant that for any {@code TypeMetadata}
  85      * class, a given {@code Type} may have at most one metadata array
  86      * entry of that class.
  87      */
  88     protected final TypeMetadata metadata;
  89 
  90     public TypeMetadata getMetadata() {
  91         return metadata;
  92     }
  93 
  94     public Entry getMetadataOfKind(final Entry.Kind kind) {
  95         return metadata != null ? metadata.get(kind) : null;
  96     }
  97 
  98     /** Constant type: no type at all. */
  99     public static final JCNoType noType = new JCNoType() {
 100         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 101         public String toString() {
 102             return &quot;none&quot;;
 103         }
 104     };
 105 
 106     /** Constant type: special type to be used during recovery of deferred expressions. */
 107     public static final JCNoType recoveryType = new JCNoType(){
 108         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 109         public String toString() {
 110             return &quot;recovery&quot;;
 111         }
 112     };
 113 
 114     /** Constant type: special type to be used for marking stuck trees. */
 115     public static final JCNoType stuckType = new JCNoType() {
 116         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 117         public String toString() {
 118             return &quot;stuck&quot;;
 119         }
 120     };
 121 
 122     /** If this switch is turned on, the names of type variables
 123      *  and anonymous classes are printed with hashcodes appended.
 124      */
 125     public static boolean moreInfo = false;
 126 
 127     /** The defining class / interface / package / type variable.
 128      */
 129     public TypeSymbol tsym;
 130 
 131     @Override
 132     public int poolTag() {
 133         throw new AssertionError(&quot;Invalid pool entry&quot;);
 134     }
 135 
 136     @Override
 137     public Object poolKey(Types types) {
 138         return new UniqueType(this, types);
 139     }
 140 
 141     /**
 142      * Checks if the current type tag is equal to the given tag.
 143      * @return true if tag is equal to the current type tag.
 144      */
 145     public boolean hasTag(TypeTag tag) {
 146         return tag == getTag();
 147     }
 148 
 149     /**
 150      * Returns the current type tag.
 151      * @return the value of the current type tag.
 152      */
 153     public abstract TypeTag getTag();
 154 
 155     public boolean isNumeric() {
 156         return false;
 157     }
 158 
 159     public boolean isIntegral() {
 160         return false;
 161     }
 162 
 163     public boolean isPrimitive() {
 164         return false;
 165     }
 166 
 167     public boolean isPrimitiveOrVoid() {
 168         return false;
 169     }
 170 
 171     public boolean isReference() {
 172         return false;
 173     }
 174 
 175     public boolean isNullOrReference() {
 176         return false;
 177     }
 178 
 179     public boolean isPartial() {
 180         return false;
 181     }
 182 
 183     /**
 184      * The constant value of this type, null if this type does not
 185      * have a constant value attribute. Only primitive types and
 186      * strings (ClassType) can have a constant value attribute.
 187      * @return the constant value attribute of this type
 188      */
 189     public Object constValue() {
 190         return null;
 191     }
 192 
 193     /** Is this a constant type whose value is false?
 194      */
 195     public boolean isFalse() {
 196         return false;
 197     }
 198 
 199     /** Is this a constant type whose value is true?
 200      */
 201     public boolean isTrue() {
 202         return false;
 203     }
 204 
 205     /**
 206      * Get the representation of this type used for modelling purposes.
 207      * By default, this is itself. For ErrorType, a different value
 208      * may be provided.
 209      */
 210     public Type getModelType() {
 211         return this;
 212     }
 213 
 214     public static List&lt;Type&gt; getModelTypes(List&lt;Type&gt; ts) {
 215         ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 216         for (Type t: ts)
 217             lb.append(t.getModelType());
 218         return lb.toList();
 219     }
 220 
 221     /**For ErrorType, returns the original type, otherwise returns the type itself.
 222      */
 223     public Type getOriginalType() {
 224         return this;
 225     }
 226 
 227     public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) { return v.visitType(this, s); }
 228 
 229     /** Define a type given its tag, type symbol, and type annotations
 230      */
 231 
 232     public Type(TypeSymbol tsym, TypeMetadata metadata) {
 233         Assert.checkNonNull(metadata);
 234         this.tsym = tsym;
 235         this.metadata = metadata;
 236     }
 237 
 238     public boolean isValue() {
 239         return false;
 240     }
 241 
 242     public boolean isReferenceProjection() {
 243         return false;
 244     }
 245 
 246     public Type valueProjection() {
 247         return null;
 248     }
 249 
 250     public Type referenceProjection() {
 251         return null;
 252     }
 253 
 254     /**
 255      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
 256      * of a given type expression. This mapping returns the original type is no changes occurred
 257      * when recursively mapping the original type&#39;s subterms.
 258      */
 259     public static abstract class StructuralTypeMapping&lt;S&gt; extends Types.TypeMapping&lt;S&gt; {
 260 
 261         @Override
 262         public Type visitClassType(ClassType t, S s) {
 263             Type outer = t.getEnclosingType();
 264             Type outer1 = visit(outer, s);
 265             List&lt;Type&gt; typarams = t.getTypeArguments();
 266             List&lt;Type&gt; typarams1 = visit(typarams, s);
 267             if (outer1 == outer &amp;&amp; typarams1 == typarams) return t;
 268             else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {
 269                 @Override
 270                 protected boolean needsStripping() {
 271                     return true;
 272                 }
 273             };
 274         }
 275 
 276         @Override
 277         public Type visitWildcardType(WildcardType wt, S s) {
 278             Type t = wt.type;
 279             if (t != null)
 280                 t = visit(t, s);
 281             if (t == wt.type)
 282                 return wt;
 283             else
 284                 return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata) {
 285                     @Override
 286                     protected boolean needsStripping() {
 287                         return true;
 288                     }
 289                 };
 290         }
 291 
 292         @Override
 293         public Type visitArrayType(ArrayType t, S s) {
 294             Type elemtype = t.elemtype;
 295             Type elemtype1 = visit(elemtype, s);
 296             if (elemtype1 == elemtype) return t;
 297             else return new ArrayType(elemtype1, t.tsym, t.metadata) {
 298                 @Override
 299                 protected boolean needsStripping() {
 300                     return true;
 301                 }
 302             };
 303         }
 304 
 305         @Override
 306         public Type visitMethodType(MethodType t, S s) {
 307             List&lt;Type&gt; argtypes = t.argtypes;
 308             Type restype = t.restype;
 309             List&lt;Type&gt; thrown = t.thrown;
 310             List&lt;Type&gt; argtypes1 = visit(argtypes, s);
 311             Type restype1 = visit(restype, s);
 312             List&lt;Type&gt; thrown1 = visit(thrown, s);
 313             if (argtypes1 == argtypes &amp;&amp;
 314                 restype1 == restype &amp;&amp;
 315                 thrown1 == thrown) return t;
 316             else return new MethodType(argtypes1, restype1, thrown1, t.tsym) {
 317                 @Override
 318                 protected boolean needsStripping() {
 319                     return true;
 320                 }
 321             };
 322         }
 323 
 324         @Override
 325         public Type visitForAll(ForAll t, S s) {
 326             return visit(t.qtype, s);
 327         }
 328     }
 329 
 330     /** map a type function over all immediate descendants of this type
 331      */
 332     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping, Z arg) {
 333         return mapping.visit(this, arg);
 334     }
 335 
 336     /** map a type function over all immediate descendants of this type (no arg version)
 337      */
 338     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping) {
 339         return mapping.visit(this, null);
 340     }
 341 
 342     /** Define a constant type, of the same kind as this type
 343      *  and with given constant value
 344      */
 345     public Type constType(Object constValue) {
 346         throw new AssertionError();
 347     }
 348 
 349     /**
 350      * If this is a constant type, return its underlying type.
 351      * Otherwise, return the type itself.
 352      */
 353     public Type baseType() {
 354         return this;
 355     }
 356 
 357     /**
 358      * Returns the original version of this type, before metadata were added. This routine is meant
 359      * for internal use only (i.e. {@link Type#equalsIgnoreMetadata(Type)}, {@link Type#stripMetadata});
 360      * it should not be used outside this class.
 361      */
 362     protected Type typeNoMetadata() {
 363         return metadata == TypeMetadata.EMPTY ? this : baseType();
 364     }
 365 
 366     /**
 367      * Create a new copy of this type but with the specified TypeMetadata.
 368      */
 369     public abstract Type cloneWithMetadata(TypeMetadata metadata);
 370 
 371     /**
 372      * Does this type require annotation stripping for API clients?
 373      */
 374     protected boolean needsStripping() {
 375         return false;
 376     }
 377 
 378     /**
 379      * Strip all metadata associated with this type - this could return a new clone of the type.
 380      * This routine is only used to present the correct annotated types back to the users when types
 381      * are accessed through compiler APIs; it should not be used anywhere in the compiler internals
 382      * as doing so might result in performance penalties.
 383      */
 384     public Type stripMetadataIfNeeded() {
 385         return needsStripping() ?
 386                 accept(stripMetadata, null) :
 387                 this;
 388     }
 389 
 390     public Type stripMetadata() {
 391         return accept(stripMetadata, null);
 392     }
 393     //where
 394         private final static TypeMapping&lt;Void&gt; stripMetadata = new StructuralTypeMapping&lt;Void&gt;() {
 395             @Override
 396             public Type visitClassType(ClassType t, Void aVoid) {
 397                 return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);
 398             }
 399 
 400             @Override
 401             public Type visitArrayType(ArrayType t, Void aVoid) {
 402                 return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);
 403             }
 404 
 405             @Override
 406             public Type visitTypeVar(TypeVar t, Void aVoid) {
 407                 return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);
 408             }
 409 
 410             @Override
 411             public Type visitWildcardType(WildcardType wt, Void aVoid) {
 412                 return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);
 413             }
 414         };
 415 
 416     public Type annotatedType(final List&lt;Attribute.TypeCompound&gt; annos) {
 417         final Entry annoMetadata = new TypeMetadata.Annotations(annos);
 418         return cloneWithMetadata(metadata.combine(annoMetadata));
 419     }
 420 
 421     public boolean isAnnotated() {
 422         final TypeMetadata.Annotations metadata =
 423             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 424 
 425         return null != metadata &amp;&amp; !metadata.getAnnotations().isEmpty();
 426     }
 427 
 428     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 429     public List&lt;Attribute.TypeCompound&gt; getAnnotationMirrors() {
 430         final TypeMetadata.Annotations metadata =
 431             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 432 
 433         return metadata == null ? List.nil() : metadata.getAnnotations();
 434     }
 435 
 436 
 437     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 438     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
 439         return null;
 440     }
 441 
 442 
 443     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 444     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType) {
 445         @SuppressWarnings(&quot;unchecked&quot;)
 446         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);
 447         return tmp;
 448     }
 449 
 450     /** Return the base types of a list of types.
 451      */
 452     public static List&lt;Type&gt; baseTypes(List&lt;Type&gt; ts) {
 453         if (ts.nonEmpty()) {
 454             Type t = ts.head.baseType();
 455             List&lt;Type&gt; baseTypes = baseTypes(ts.tail);
 456             if (t != ts.head || baseTypes != ts.tail)
 457                 return baseTypes.prepend(t);
 458         }
 459         return ts;
 460     }
 461 
 462     protected void appendAnnotationsString(StringBuilder sb,
 463                                          boolean prefix) {
 464         if (isAnnotated()) {
 465             if (prefix) {
 466                 sb.append(&quot; &quot;);
 467             }
 468             sb.append(getAnnotationMirrors());
 469             sb.append(&quot; &quot;);
 470         }
 471     }
 472 
 473     protected void appendAnnotationsString(StringBuilder sb) {
 474         appendAnnotationsString(sb, false);
 475     }
 476 
 477     /** The Java source which this type represents.
 478      */
 479     @DefinedBy(Api.LANGUAGE_MODEL)
 480     public String toString() {
 481         StringBuilder sb = new StringBuilder();
 482         appendAnnotationsString(sb);
 483         if (tsym == null || tsym.name == null) {
 484             sb.append(&quot;&lt;none&gt;&quot;);
 485         } else {
 486             sb.append(tsym.name);
 487         }
 488         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 489             sb.append(hashCode());
 490         }
 491         return sb.toString();
 492     }
 493 
 494     /**
 495      * The Java source which this type list represents.  A List is
 496      * represented as a comma-separated listing of the elements in
 497      * that list.
 498      */
 499     public static String toString(List&lt;Type&gt; ts) {
 500         if (ts.isEmpty()) {
 501             return &quot;&quot;;
 502         } else {
 503             StringBuilder buf = new StringBuilder();
 504             buf.append(ts.head.toString());
 505             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 506                 buf.append(&quot;,&quot;).append(l.head.toString());
 507             return buf.toString();
 508         }
 509     }
 510 
 511     /**
 512      * The constant value of this type, converted to String
 513      */
 514     public String stringValue() {
 515         Object cv = Assert.checkNonNull(constValue());
 516         return cv.toString();
 517     }
 518 
 519     /**
 520      * Override this method with care. For most Type instances this should behave as ==.
 521      */
 522     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 523     public boolean equals(Object t) {
 524         return this == t;
 525     }
 526 
 527     public boolean equalsIgnoreMetadata(Type t) {
 528         return typeNoMetadata().equals(t.typeNoMetadata());
 529     }
 530 
 531     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 532     public int hashCode() {
 533         return super.hashCode();
 534     }
 535 
 536     public String argtypes(boolean varargs) {
 537         List&lt;Type&gt; args = getParameterTypes();
 538         if (!varargs) return args.toString();
 539         StringBuilder buf = new StringBuilder();
 540         while (args.tail.nonEmpty()) {
 541             buf.append(args.head);
 542             args = args.tail;
 543             buf.append(&#39;,&#39;);
 544         }
 545         if (args.head.hasTag(ARRAY)) {
 546             buf.append(((ArrayType)args.head).elemtype);
 547             if (args.head.getAnnotationMirrors().nonEmpty()) {
 548                 buf.append(args.head.getAnnotationMirrors());
 549             }
 550             buf.append(&quot;...&quot;);
 551         } else {
 552             buf.append(args.head);
 553         }
 554         return buf.toString();
 555     }
 556 
 557     /** Access methods.
 558      */
 559     public List&lt;Type&gt;        getTypeArguments()  { return List.nil(); }
 560     public Type              getEnclosingType()  { return null; }
 561     public List&lt;Type&gt;        getParameterTypes() { return List.nil(); }
 562     public Type              getReturnType()     { return null; }
 563     public Type              getReceiverType()   { return null; }
 564     public List&lt;Type&gt;        getThrownTypes()    { return List.nil(); }
 565     public Type              getUpperBound()     { return null; }
 566     public Type              getLowerBound()     { return null; }
 567 
 568     /** Navigation methods, these will work for classes, type variables,
 569      *  foralls, but will return null for arrays and methods.
 570      */
 571 
 572    /** Return all parameters of this type and all its outer types in order
 573     *  outer (first) to inner (last).
 574     */
 575     public List&lt;Type&gt; allparams() { return List.nil(); }
 576 
 577     /** Does this type contain &quot;error&quot; elements?
 578      */
 579     public boolean isErroneous() {
 580         return false;
 581     }
 582 
 583     public static boolean isErroneous(List&lt;Type&gt; ts) {
 584         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 585             if (l.head.isErroneous()) return true;
 586         return false;
 587     }
 588 
 589     /** Is this type parameterized?
 590      *  A class type is parameterized if it has some parameters.
 591      *  An array type is parameterized if its element type is parameterized.
 592      *  All other types are not parameterized.
 593      */
 594     public boolean isParameterized() {
 595         return false;
 596     }
 597 
 598     /** Is this type a raw type?
 599      *  A class type is a raw type if it misses some of its parameters.
 600      *  An array type is a raw type if its element type is raw.
 601      *  All other types are not raw.
 602      *  Type validation will ensure that the only raw types
 603      *  in a program are types that miss all their type variables.
 604      */
 605     public boolean isRaw() {
 606         return false;
 607     }
 608 
 609     /**
 610      * A compound type is a special class type whose supertypes are used to store a list
 611      * of component types. There are two kinds of compound types: (i) intersection types
 612      * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.
 613      */
 614     public boolean isCompound() {
 615         return false;
 616     }
 617 
 618     public boolean isIntersection() {
 619         return false;
 620     }
 621 
 622     public boolean isUnion() {
 623         return false;
 624     }
 625 
 626     public boolean isInterface() {
 627         return (tsym.flags() &amp; INTERFACE) != 0;
 628     }
 629 
 630     public boolean isFinal() {
 631         return (tsym.flags() &amp; FINAL) != 0;
 632     }
 633 
 634     /**
 635      * Does this type contain occurrences of type t?
 636      */
 637     public boolean contains(Type t) {
 638         return t.equalsIgnoreMetadata(this);
 639     }
 640 
 641     public static boolean contains(List&lt;Type&gt; ts, Type t) {
 642         for (List&lt;Type&gt; l = ts;
 643              l.tail != null /*inlined: l.nonEmpty()*/;
 644              l = l.tail)
 645             if (l.head.contains(t)) return true;
 646         return false;
 647     }
 648 
 649     /** Does this type contain an occurrence of some type in &#39;ts&#39;?
 650      */
 651     public boolean containsAny(List&lt;Type&gt; ts) {
 652         for (Type t : ts)
 653             if (this.contains(t)) return true;
 654         return false;
 655     }
 656 
 657     public static boolean containsAny(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
 658         for (Type t : ts1)
 659             if (t.containsAny(ts2)) return true;
 660         return false;
 661     }
 662 
 663     public static List&lt;Type&gt; filter(List&lt;Type&gt; ts, Filter&lt;Type&gt; tf) {
 664         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 665         for (Type t : ts) {
 666             if (tf.accepts(t)) {
 667                 buf.append(t);
 668             }
 669         }
 670         return buf.toList();
 671     }
 672 
 673     public boolean isSuperBound() { return false; }
 674     public boolean isExtendsBound() { return false; }
 675     public boolean isUnbound() { return false; }
 676     public Type withTypeVar(Type t) { return this; }
 677 
 678     /** The underlying method type of this type.
 679      */
 680     public MethodType asMethodType() { throw new AssertionError(); }
 681 
 682     /** Complete loading all classes in this type.
 683      */
 684     public void complete() {}
 685 
 686     public TypeSymbol asElement() {
 687         return tsym;
 688     }
 689 
 690     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 691     public TypeKind getKind() {
 692         return TypeKind.OTHER;
 693     }
 694 
 695     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 696     public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 697         throw new AssertionError();
 698     }
 699 
 700     public static class JCPrimitiveType extends Type
 701             implements javax.lang.model.type.PrimitiveType {
 702 
 703         TypeTag tag;
 704 
 705         public JCPrimitiveType(TypeTag tag, TypeSymbol tsym) {
 706             this(tag, tsym, TypeMetadata.EMPTY);
 707         }
 708 
 709         private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {
 710             super(tsym, metadata);
 711             this.tag = tag;
 712             Assert.check(tag.isPrimitive);
 713         }
 714 
 715         @Override
 716         public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {
 717             return new JCPrimitiveType(tag, tsym, md) {
 718                 @Override
 719                 public Type baseType() { return JCPrimitiveType.this.baseType(); }
 720             };
 721         }
 722 
 723         @Override
 724         public boolean isNumeric() {
 725             return tag != BOOLEAN;
 726         }
 727 
 728         @Override
 729         public boolean isIntegral() {
 730             switch (tag) {
 731                 case CHAR:
 732                 case BYTE:
 733                 case SHORT:
 734                 case INT:
 735                 case LONG:
 736                     return true;
 737                 default:
 738                     return false;
 739             }
 740         }
 741 
 742         @Override
 743         public boolean isPrimitive() {
 744             return true;
 745         }
 746 
 747         @Override
 748         public TypeTag getTag() {
 749             return tag;
 750         }
 751 
 752         @Override
 753         public boolean isPrimitiveOrVoid() {
 754             return true;
 755         }
 756 
 757         /** Define a constant type, of the same kind as this type
 758          *  and with given constant value
 759          */
 760         @Override
 761         public Type constType(Object constValue) {
 762             final Object value = constValue;
 763             return new JCPrimitiveType(tag, tsym, metadata) {
 764                     @Override
 765                     public Object constValue() {
 766                         return value;
 767                     }
 768                     @Override
 769                     public Type baseType() {
 770                         return tsym.type;
 771                     }
 772                 };
 773         }
 774 
 775         /**
 776          * The constant value of this type, converted to String
 777          */
 778         @Override
 779         public String stringValue() {
 780             Object cv = Assert.checkNonNull(constValue());
 781             if (tag == BOOLEAN) {
 782                 return ((Integer) cv).intValue() == 0 ? &quot;false&quot; : &quot;true&quot;;
 783             }
 784             else if (tag == CHAR) {
 785                 return String.valueOf((char) ((Integer) cv).intValue());
 786             }
 787             else {
 788                 return cv.toString();
 789             }
 790         }
 791 
 792         /** Is this a constant type whose value is false?
 793          */
 794         @Override
 795         public boolean isFalse() {
 796             return
 797                 tag == BOOLEAN &amp;&amp;
 798                 constValue() != null &amp;&amp;
 799                 ((Integer)constValue()).intValue() == 0;
 800         }
 801 
 802         /** Is this a constant type whose value is true?
 803          */
 804         @Override
 805         public boolean isTrue() {
 806             return
 807                 tag == BOOLEAN &amp;&amp;
 808                 constValue() != null &amp;&amp;
 809                 ((Integer)constValue()).intValue() != 0;
 810         }
 811 
 812         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 813         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 814             return v.visitPrimitive(this, p);
 815         }
 816 
 817         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 818         public TypeKind getKind() {
 819             switch (tag) {
 820                 case BYTE:      return TypeKind.BYTE;
 821                 case CHAR:      return TypeKind.CHAR;
 822                 case SHORT:     return TypeKind.SHORT;
 823                 case INT:       return TypeKind.INT;
 824                 case LONG:      return TypeKind.LONG;
 825                 case FLOAT:     return TypeKind.FLOAT;
 826                 case DOUBLE:    return TypeKind.DOUBLE;
 827                 case BOOLEAN:   return TypeKind.BOOLEAN;
 828             }
 829             throw new AssertionError();
 830         }
 831 
 832     }
 833 
 834     public static class WildcardType extends Type
 835             implements javax.lang.model.type.WildcardType {
 836 
 837         public Type type;
 838         public BoundKind kind;
 839         public TypeVar bound;
 840 
 841         @Override
 842         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 843             return v.visitWildcardType(this, s);
 844         }
 845 
 846         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym) {
 847             this(type, kind, tsym, null, TypeMetadata.EMPTY);
 848         }
 849 
 850         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 851                             TypeMetadata metadata) {
 852             this(type, kind, tsym, null, metadata);
 853         }
 854 
 855         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 856                             TypeVar bound) {
 857             this(type, kind, tsym, bound, TypeMetadata.EMPTY);
 858         }
 859 
 860         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 861                             TypeVar bound, TypeMetadata metadata) {
 862             super(tsym, metadata);
 863             this.type = Assert.checkNonNull(type);
 864             this.kind = kind;
 865             this.bound = bound;
 866         }
 867 
 868         @Override
 869         public WildcardType cloneWithMetadata(TypeMetadata md) {
 870             return new WildcardType(type, kind, tsym, bound, md) {
 871                 @Override
 872                 public Type baseType() { return WildcardType.this.baseType(); }
 873             };
 874         }
 875 
 876         @Override
 877         public TypeTag getTag() {
 878             return WILDCARD;
 879         }
 880 
 881         @Override
 882         public boolean contains(Type t) {
 883             return kind != UNBOUND &amp;&amp; type.contains(t);
 884         }
 885 
 886         public boolean isSuperBound() {
 887             return kind == SUPER ||
 888                 kind == UNBOUND;
 889         }
 890         public boolean isExtendsBound() {
 891             return kind == EXTENDS ||
 892                 kind == UNBOUND;
 893         }
 894         public boolean isUnbound() {
 895             return kind == UNBOUND;
 896         }
 897 
 898         @Override
 899         public boolean isReference() {
 900             return true;
 901         }
 902 
 903         @Override
 904         public boolean isNullOrReference() {
 905             return true;
 906         }
 907 
 908         @Override
 909         public Type withTypeVar(Type t) {
 910             //-System.err.println(this+&quot;.withTypeVar(&quot;+t+&quot;);&quot;);//DEBUG
 911             if (bound == t)
 912                 return this;
 913             bound = (TypeVar)t;
 914             return this;
 915         }
 916 
 917         boolean isPrintingBound = false;
 918         @DefinedBy(Api.LANGUAGE_MODEL)
 919         public String toString() {
 920             StringBuilder s = new StringBuilder();
 921             appendAnnotationsString(s);
 922             s.append(kind.toString());
 923             if (kind != UNBOUND)
 924                 s.append(type);
 925             if (moreInfo &amp;&amp; bound != null &amp;&amp; !isPrintingBound)
 926                 try {
 927                     isPrintingBound = true;
 928                     s.append(&quot;{:&quot;).append(bound.getUpperBound()).append(&quot;:}&quot;);
 929                 } finally {
 930                     isPrintingBound = false;
 931                 }
 932             return s.toString();
 933         }
 934 
 935         @DefinedBy(Api.LANGUAGE_MODEL)
 936         public Type getExtendsBound() {
 937             if (kind == EXTENDS)
 938                 return type;
 939             else
 940                 return null;
 941         }
 942 
 943         @DefinedBy(Api.LANGUAGE_MODEL)
 944         public Type getSuperBound() {
 945             if (kind == SUPER)
 946                 return type;
 947             else
 948                 return null;
 949         }
 950 
 951         @DefinedBy(Api.LANGUAGE_MODEL)
 952         public TypeKind getKind() {
 953             return TypeKind.WILDCARD;
 954         }
 955 
 956         @DefinedBy(Api.LANGUAGE_MODEL)
 957         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 958             return v.visitWildcard(this, p);
 959         }
 960     }
 961 
 962     public static class ConstantPoolQType implements PoolConstant {
 963 
 964         public final Type type;
 965         final Types types;
 966 
 967         public ConstantPoolQType(Type type, Types types) {
 968             this.type = type;
 969             this.types = types;
 970         }
 971 
 972         @Override
 973         public Object poolKey(Types types) {
 974             return this;
 975         }
 976 
 977         @Override
 978         public int poolTag() {
 979             return ClassFile.CONSTANT_Class;
 980         }
 981 
 982         public int hashCode() {
 983             return types.hashCode(type);
 984         }
 985 
 986         public boolean equals(Object obj) {
 987             return (obj instanceof ConstantPoolQType) &amp;&amp;
 988                     types.isSameType(type, ((ConstantPoolQType)obj).type);
 989         }
 990 
 991         public String toString() {
 992             return type.toString();
 993         }
 994     }
 995 
 996     public static class ClassType extends Type implements DeclaredType, LoadableConstant,
 997                                                           javax.lang.model.type.ErrorType {
 998 
 999         /** The enclosing type of this type. If this is the type of an inner
1000          *  class, outer_field refers to the type of its enclosing
1001          *  instance class, in all other cases it refers to noType.
1002          */
1003         private Type outer_field;
1004 
1005         /** The type parameters of this type (to be set once class is loaded).
1006          */
1007         public List&lt;Type&gt; typarams_field;
1008 
1009         /** A cache variable for the type parameters of this type,
1010          *  appended to all parameters of its enclosing class.
1011          *  @see #allparams
1012          */
1013         public List&lt;Type&gt; allparams_field;
1014 
1015         /** The supertype of this class (to be set once class is loaded).
1016          */
1017         public Type supertype_field;
1018 
1019         /** The interfaces of this class (to be set once class is loaded).
1020          */
1021         public List&lt;Type&gt; interfaces_field;
1022 
1023         /** All the interfaces of this class, including missing ones.
1024          */
1025         public List&lt;Type&gt; all_interfaces_field;
1026 
<a name="1" id="anc1"></a><span class="line-modified">1027         /* The &#39;other&#39; projection: If &#39;this&#39; is type of an inline class, then &#39;projection&#39; is the</span>
1028            its doppleganger in its referene projection world and vice versa.
1029         */
1030         public ClassType projection;
1031 
1032         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
1033             this(outer, typarams, tsym, TypeMetadata.EMPTY);
1034         }
1035 
1036         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
1037                          TypeMetadata metadata) {
1038             super(tsym, metadata);
1039             this.outer_field = outer;
1040             this.typarams_field = typarams;
1041             this.allparams_field = null;
1042             this.supertype_field = null;
1043             this.interfaces_field = null;
1044         }
1045 
1046         public int poolTag() {
1047             return ClassFile.CONSTANT_Class;
1048         }
1049 
1050         @Override
1051         public ClassType cloneWithMetadata(TypeMetadata md) {
1052             return new ClassType(outer_field, typarams_field, tsym, md) {
1053                 @Override
1054                 public Type baseType() { return ClassType.this.baseType(); }
1055             };
1056         }
1057 
1058         @Override
1059         public TypeTag getTag() {
1060             return CLASS;
1061         }
1062 
1063         @Override
1064         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1065             return v.visitClassType(this, s);
1066         }
1067 
1068         public Type constType(Object constValue) {
1069             final Object value = constValue;
1070             return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {
1071                     @Override
1072                     public Object constValue() {
1073                         return value;
1074                     }
1075                     @Override
1076                     public Type baseType() {
1077                         return tsym.type;
1078                     }
1079                 };
1080         }
1081 
1082         /** The Java source which this type represents.
1083          */
1084         @DefinedBy(Api.LANGUAGE_MODEL)
1085         public String toString() {
1086             StringBuilder buf = new StringBuilder();
1087             if (getEnclosingType().hasTag(CLASS) &amp;&amp; tsym.owner.kind == TYP) {
1088                 buf.append(getEnclosingType().toString());
1089                 buf.append(&quot;.&quot;);
1090                 appendAnnotationsString(buf);
1091                 buf.append(className(tsym, false));
1092             } else {
1093                 appendAnnotationsString(buf);
1094                 buf.append(className(tsym, true));
1095             }
1096 
1097             if (getTypeArguments().nonEmpty()) {
1098                 buf.append(&#39;&lt;&#39;);
1099                 buf.append(getTypeArguments().toString());
1100                 buf.append(&quot;&gt;&quot;);
1101             }
1102             return buf.toString();
1103         }
1104 //where
1105             private String className(Symbol sym, boolean longform) {
1106                 if (sym.name.isEmpty() &amp;&amp; (sym.flags() &amp; COMPOUND) != 0) {
1107                     StringBuilder s = new StringBuilder(supertype_field.toString());
1108                     for (List&lt;Type&gt; is=interfaces_field; is.nonEmpty(); is = is.tail) {
1109                         s.append(&quot;&amp;&quot;);
1110                         s.append(is.head.toString());
1111                     }
1112                     return s.toString();
1113                 } else if (sym.name.isEmpty()) {
1114                     String s;
1115                     ClassType norm = (ClassType) tsym.type;
1116                     if (norm == null) {
1117                         s = Log.getLocalizedString(&quot;anonymous.class&quot;, (Object)null);
1118                     } else if (norm.interfaces_field != null &amp;&amp; norm.interfaces_field.nonEmpty()) {
1119                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1120                                                    norm.interfaces_field.head);
1121                     } else {
1122                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1123                                                    norm.supertype_field);
1124                     }
1125                     if (moreInfo)
1126                         s += String.valueOf(sym.hashCode());
1127                     return s;
1128                 }
1129                 String s;
1130                 if (longform) {
1131                     s =  sym.getQualifiedName().toString();
1132                 } else {
1133                     s = sym.name.toString();
1134                 }
1135                 return s;
1136             }
1137 
1138         @DefinedBy(Api.LANGUAGE_MODEL)
1139         public List&lt;Type&gt; getTypeArguments() {
1140             if (typarams_field == null) {
1141                 complete();
1142                 if (typarams_field == null)
1143                     typarams_field = List.nil();
1144             }
1145             return typarams_field;
1146         }
1147 
1148         public boolean hasErasedSupertypes() {
1149             return isRaw();
1150         }
1151 
1152         @DefinedBy(Api.LANGUAGE_MODEL)
1153         public Type getEnclosingType() {
1154             return outer_field;
1155         }
1156 
1157         public void setEnclosingType(Type outer) {
1158             outer_field = outer;
1159         }
1160 
1161         public List&lt;Type&gt; allparams() {
1162             if (allparams_field == null) {
1163                 allparams_field = getTypeArguments().prependList(getEnclosingType().allparams());
1164             }
1165             return allparams_field;
1166         }
1167 
1168         public boolean isErroneous() {
1169             return
1170                 getEnclosingType().isErroneous() ||
1171                 isErroneous(getTypeArguments()) ||
1172                 this != tsym.type &amp;&amp; tsym.type.isErroneous();
1173         }
1174 
1175         public boolean isParameterized() {
1176             return allparams().tail != null;
1177             // optimization, was: allparams().nonEmpty();
1178         }
1179 
1180         @Override
1181         public boolean isReference() {
1182             return true;
1183         }
1184 
1185         @Override
1186         public boolean isValue() {
1187             return tsym != null &amp;&amp; tsym.isValue();
1188         }
1189 
1190         @Override
1191         public boolean isReferenceProjection() {
1192             return tsym != null &amp;&amp; tsym.isReferenceProjection();
1193         }
1194 
1195         @Override
1196         public Type valueProjection() {
1197             if (!isReferenceProjection() || projection !=  null)
1198                 return projection;
1199 
1200             // Make a best case effort to cache the other projection.
1201             ClassSymbol valueClass = (ClassSymbol) tsym.valueProjection();
1202 
1203             projection = new ClassType(outer_field, typarams_field, valueClass);
1204             projection.allparams_field = allparams_field;
1205             projection.supertype_field = supertype_field;
1206 
1207             projection.interfaces_field = interfaces_field;
1208             projection.all_interfaces_field = all_interfaces_field;
1209             projection.projection = this;
1210             return projection;
1211         }
1212 
1213         // return the reference projection type preserving parameterizations
1214         @Override
1215         public ClassType referenceProjection() {
1216 
1217             if (!isValue() || projection != null)
1218                 return projection;
1219 
1220             // make a best case effort to cache the other projection.
1221             ClassSymbol refClass = (ClassSymbol) tsym.referenceProjection();
1222 
1223             projection = new ClassType(outer_field, typarams_field, refClass);
1224             projection.allparams_field = allparams_field;
1225             projection.supertype_field = supertype_field;
1226 
1227             projection.interfaces_field = interfaces_field;
1228             projection.all_interfaces_field = all_interfaces_field;
1229             projection.projection = this;
1230             return projection;
1231         }
1232 
1233         @Override
1234         public boolean isNullOrReference() {
1235             return true;
1236         }
1237 
1238         /** A cache for the rank. */
1239         int rank_field = -1;
1240 
1241         /** A class type is raw if it misses some
1242          *  of its type parameter sections.
1243          *  After validation, this is equivalent to:
1244          *  {@code allparams.isEmpty() &amp;&amp; tsym.type.allparams.nonEmpty(); }
1245          */
1246         public boolean isRaw() {
1247             return
1248                 this != tsym.type &amp;&amp; // necessary, but not sufficient condition
1249                 tsym.type.allparams().nonEmpty() &amp;&amp;
1250                 allparams().isEmpty();
1251         }
1252 
1253         public boolean contains(Type elem) {
1254             return
1255                 elem.equalsIgnoreMetadata(this)
1256                 || (isParameterized()
1257                     &amp;&amp; (getEnclosingType().contains(elem) || contains(getTypeArguments(), elem)))
1258                 || (isCompound()
1259                     &amp;&amp; (supertype_field.contains(elem) || contains(interfaces_field, elem)));
1260         }
1261 
1262         public void complete() {
1263             tsym.complete();
1264         }
1265 
1266         @DefinedBy(Api.LANGUAGE_MODEL)
1267         public TypeKind getKind() {
1268             tsym.apiComplete();
1269             return tsym.kind == TYP ? TypeKind.DECLARED : TypeKind.ERROR;
1270         }
1271 
1272         @DefinedBy(Api.LANGUAGE_MODEL)
1273         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1274             return v.visitDeclared(this, p);
1275         }
1276     }
1277 
1278     public static class ErasedClassType extends ClassType {
1279         public ErasedClassType(Type outer, TypeSymbol tsym,
1280                                TypeMetadata metadata) {
1281             super(outer, List.nil(), tsym, metadata);
1282         }
1283 
1284         @Override
1285         public boolean hasErasedSupertypes() {
1286             return true;
1287         }
1288     }
1289 
1290     // a clone of a ClassType that knows about the alternatives of a union type.
1291     public static class UnionClassType extends ClassType implements UnionType {
1292         final List&lt;? extends Type&gt; alternatives_field;
1293 
1294         public UnionClassType(ClassType ct, List&lt;? extends Type&gt; alternatives) {
1295             // Presently no way to refer to this type directly, so we
1296             // cannot put annotations directly on it.
1297             super(ct.outer_field, ct.typarams_field, ct.tsym);
1298             allparams_field = ct.allparams_field;
1299             supertype_field = ct.supertype_field;
1300             interfaces_field = ct.interfaces_field;
1301             all_interfaces_field = ct.interfaces_field;
1302             alternatives_field = alternatives;
1303         }
1304 
1305         @Override
1306         public UnionClassType cloneWithMetadata(TypeMetadata md) {
1307             throw new AssertionError(&quot;Cannot add metadata to a union type&quot;);
1308         }
1309 
1310         public Type getLub() {
1311             return tsym.type;
1312         }
1313 
1314         @DefinedBy(Api.LANGUAGE_MODEL)
1315         public java.util.List&lt;? extends TypeMirror&gt; getAlternatives() {
1316             return Collections.unmodifiableList(alternatives_field);
1317         }
1318 
1319         @Override
1320         public boolean isUnion() {
1321             return true;
1322         }
1323 
1324         @Override
1325         public boolean isCompound() {
1326             return getLub().isCompound();
1327         }
1328 
1329         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1330         public TypeKind getKind() {
1331             return TypeKind.UNION;
1332         }
1333 
1334         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1335         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1336             return v.visitUnion(this, p);
1337         }
1338 
1339         public Iterable&lt;? extends Type&gt; getAlternativeTypes() {
1340             return alternatives_field;
1341         }
1342     }
1343 
1344     // a clone of a ClassType that knows about the bounds of an intersection type.
1345     public static class IntersectionClassType extends ClassType implements IntersectionType {
1346 
1347         public boolean allInterfaces;
1348 
1349         public IntersectionClassType(List&lt;Type&gt; bounds, ClassSymbol csym, boolean allInterfaces) {
1350             // Presently no way to refer to this type directly, so we
1351             // cannot put annotations directly on it.
1352             super(Type.noType, List.nil(), csym);
1353             this.allInterfaces = allInterfaces;
1354             Assert.check((csym.flags() &amp; COMPOUND) != 0);
1355             supertype_field = bounds.head;
1356             interfaces_field = bounds.tail;
1357             Assert.check(!supertype_field.tsym.isCompleted() ||
1358                     !supertype_field.isInterface(), supertype_field);
1359         }
1360 
1361         @Override
1362         public IntersectionClassType cloneWithMetadata(TypeMetadata md) {
1363             throw new AssertionError(&quot;Cannot add metadata to an intersection type&quot;);
1364         }
1365 
1366         @DefinedBy(Api.LANGUAGE_MODEL)
1367         public java.util.List&lt;? extends TypeMirror&gt; getBounds() {
1368             return Collections.unmodifiableList(getExplicitComponents());
1369         }
1370 
1371         @Override
1372         public boolean isCompound() {
1373             return true;
1374         }
1375 
1376         public List&lt;Type&gt; getComponents() {
1377             return interfaces_field.prepend(supertype_field);
1378         }
1379 
1380         @Override
1381         public boolean isIntersection() {
1382             return true;
1383         }
1384 
1385         public List&lt;Type&gt; getExplicitComponents() {
1386             return allInterfaces ?
1387                     interfaces_field :
1388                     getComponents();
1389         }
1390 
1391         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1392         public TypeKind getKind() {
1393             return TypeKind.INTERSECTION;
1394         }
1395 
1396         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1397         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1398             return v.visitIntersection(this, p);
1399         }
1400     }
1401 
1402     public static class ArrayType extends Type
1403             implements LoadableConstant, javax.lang.model.type.ArrayType {
1404 
1405         public Type elemtype;
1406 
1407         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1408             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1409         }
1410 
1411         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1412                          TypeMetadata metadata) {
1413             super(arrayClass, metadata);
1414             this.elemtype = elemtype;
1415         }
1416 
1417         public ArrayType(ArrayType that) {
1418             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1419             //processing to flow from original array to the cloned array.
1420             this(that.elemtype, that.tsym, that.getMetadata());
1421         }
1422 
1423         public int poolTag() {
1424             return ClassFile.CONSTANT_Class;
1425         }
1426 
1427         @Override
1428         public ArrayType cloneWithMetadata(TypeMetadata md) {
1429             return new ArrayType(elemtype, tsym, md) {
1430                 @Override
1431                 public Type baseType() { return ArrayType.this.baseType(); }
1432             };
1433         }
1434 
1435         @Override
1436         public TypeTag getTag() {
1437             return ARRAY;
1438         }
1439 
1440         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1441             return v.visitArrayType(this, s);
1442         }
1443 
1444         @DefinedBy(Api.LANGUAGE_MODEL)
1445         public String toString() {
1446             StringBuilder sb = new StringBuilder();
1447 
1448             // First append root component type
1449             Type t = elemtype;
1450             while (t.getKind() == TypeKind.ARRAY)
1451                 t = ((ArrayType) t).getComponentType();
1452             sb.append(t);
1453 
1454             // then append @Anno[] @Anno[] ... @Anno[]
1455             t = this;
1456             do {
1457                 t.appendAnnotationsString(sb, true);
1458                 sb.append(&quot;[]&quot;);
1459                 t = ((ArrayType) t).getComponentType();
1460             } while (t.getKind() == TypeKind.ARRAY);
1461 
1462             return sb.toString();
1463         }
1464 
1465         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1466         public boolean equals(Object obj) {
1467             if (obj instanceof ArrayType) {
1468                 ArrayType that = (ArrayType)obj;
1469                 return this == that ||
1470                         elemtype.equals(that.elemtype);
1471             }
1472 
1473             return false;
1474         }
1475 
1476         @DefinedBy(Api.LANGUAGE_MODEL)
1477         public int hashCode() {
1478             return (ARRAY.ordinal() &lt;&lt; 5) + elemtype.hashCode();
1479         }
1480 
1481         public boolean isVarargs() {
1482             return false;
1483         }
1484 
1485         public List&lt;Type&gt; allparams() { return elemtype.allparams(); }
1486 
1487         public boolean isErroneous() {
1488             return elemtype.isErroneous();
1489         }
1490 
1491         public boolean isParameterized() {
1492             return elemtype.isParameterized();
1493         }
1494 
1495         @Override
1496         public boolean isReference() {
1497             return true;
1498         }
1499 
1500         @Override
1501         public boolean isNullOrReference() {
1502             return true;
1503         }
1504 
1505         public boolean isRaw() {
1506             return elemtype.isRaw();
1507         }
1508 
1509         public ArrayType makeVarargs() {
1510             return new ArrayType(elemtype, tsym, metadata) {
1511                 @Override
1512                 public boolean isVarargs() {
1513                     return true;
1514                 }
1515             };
1516         }
1517 
1518         public boolean contains(Type elem) {
1519             return elem.equalsIgnoreMetadata(this) || elemtype.contains(elem);
1520         }
1521 
1522         public void complete() {
1523             elemtype.complete();
1524         }
1525 
1526         @DefinedBy(Api.LANGUAGE_MODEL)
1527         public Type getComponentType() {
1528             return elemtype;
1529         }
1530 
1531         @DefinedBy(Api.LANGUAGE_MODEL)
1532         public TypeKind getKind() {
1533             return TypeKind.ARRAY;
1534         }
1535 
1536         @DefinedBy(Api.LANGUAGE_MODEL)
1537         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1538             return v.visitArray(this, p);
1539         }
1540     }
1541 
1542     public static class MethodType extends Type implements ExecutableType, LoadableConstant {
1543 
1544         public List&lt;Type&gt; argtypes;
1545         public Type restype;
1546         public List&lt;Type&gt; thrown;
1547 
1548         /** The type annotations on the method receiver.
1549          */
1550         public Type recvtype;
1551 
1552         public MethodType(List&lt;Type&gt; argtypes,
1553                           Type restype,
1554                           List&lt;Type&gt; thrown,
1555                           TypeSymbol methodClass) {
1556             // Presently no way to refer to a method type directly, so
1557             // we cannot put type annotations on it.
1558             super(methodClass, TypeMetadata.EMPTY);
1559             this.argtypes = argtypes;
1560             this.restype = restype;
1561             this.thrown = thrown;
1562         }
1563 
1564         @Override
1565         public MethodType cloneWithMetadata(TypeMetadata md) {
1566             throw new AssertionError(&quot;Cannot add metadata to a method type&quot;);
1567         }
1568 
1569         @Override
1570         public TypeTag getTag() {
1571             return METHOD;
1572         }
1573 
1574         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1575             return v.visitMethodType(this, s);
1576         }
1577 
1578         /** The Java source which this type represents.
1579          *
1580          *  XXX 06/09/99 iris This isn&#39;t correct Java syntax, but it probably
1581          *  should be.
1582          */
1583         @DefinedBy(Api.LANGUAGE_MODEL)
1584         public String toString() {
1585             StringBuilder sb = new StringBuilder();
1586             appendAnnotationsString(sb);
1587             sb.append(&#39;(&#39;);
1588             sb.append(argtypes);
1589             sb.append(&#39;)&#39;);
1590             sb.append(restype);
1591             return sb.toString();
1592         }
1593 
1594         @DefinedBy(Api.LANGUAGE_MODEL)
1595         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1596         @DefinedBy(Api.LANGUAGE_MODEL)
1597         public Type              getReturnType()     { return restype; }
1598         @DefinedBy(Api.LANGUAGE_MODEL)
1599         public Type              getReceiverType()   { return recvtype; }
1600         @DefinedBy(Api.LANGUAGE_MODEL)
1601         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1602 
1603         public boolean isErroneous() {
1604             return
1605                 isErroneous(argtypes) ||
1606                 restype != null &amp;&amp; restype.isErroneous();
1607         }
1608 
1609         @Override
1610         public int poolTag() {
1611             return ClassFile.CONSTANT_MethodType;
1612         }
1613 
1614         public boolean contains(Type elem) {
1615             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1616         }
1617 
1618         public MethodType asMethodType() { return this; }
1619 
1620         public void complete() {
1621             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1622                 l.head.complete();
1623             restype.complete();
1624             recvtype.complete();
1625             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1626                 l.head.complete();
1627         }
1628 
1629         @DefinedBy(Api.LANGUAGE_MODEL)
1630         public List&lt;TypeVar&gt; getTypeVariables() {
1631             return List.nil();
1632         }
1633 
1634         public TypeSymbol asElement() {
1635             return null;
1636         }
1637 
1638         @DefinedBy(Api.LANGUAGE_MODEL)
1639         public TypeKind getKind() {
1640             return TypeKind.EXECUTABLE;
1641         }
1642 
1643         @DefinedBy(Api.LANGUAGE_MODEL)
1644         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1645             return v.visitExecutable(this, p);
1646         }
1647     }
1648 
1649     public static class PackageType extends Type implements NoType {
1650 
1651         PackageType(PackageSymbol tsym) {
1652             // Package types cannot be annotated
1653             super(tsym, TypeMetadata.EMPTY);
1654         }
1655 
1656         @Override
1657         public PackageType cloneWithMetadata(TypeMetadata md) {
1658             throw new AssertionError(&quot;Cannot add metadata to a package type&quot;);
1659         }
1660 
1661         @Override
1662         public TypeTag getTag() {
1663             return PACKAGE;
1664         }
1665 
1666         @Override
1667         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1668             return v.visitPackageType(this, s);
1669         }
1670 
1671         @DefinedBy(Api.LANGUAGE_MODEL)
1672         public String toString() {
1673             return tsym.getQualifiedName().toString();
1674         }
1675 
1676         @DefinedBy(Api.LANGUAGE_MODEL)
1677         public TypeKind getKind() {
1678             return TypeKind.PACKAGE;
1679         }
1680 
1681         @DefinedBy(Api.LANGUAGE_MODEL)
1682         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1683             return v.visitNoType(this, p);
1684         }
1685     }
1686 
1687     public static class ModuleType extends Type implements NoType {
1688 
1689         ModuleType(ModuleSymbol tsym) {
1690             // Module types cannot be annotated
1691             super(tsym, TypeMetadata.EMPTY);
1692         }
1693 
1694         @Override
1695         public ModuleType cloneWithMetadata(TypeMetadata md) {
1696             throw new AssertionError(&quot;Cannot add metadata to a module type&quot;);
1697         }
1698 
1699         @Override
1700         public ModuleType annotatedType(List&lt;Attribute.TypeCompound&gt; annos) {
1701             throw new AssertionError(&quot;Cannot annotate a module type&quot;);
1702         }
1703 
1704         @Override
1705         public TypeTag getTag() {
1706             return TypeTag.MODULE;
1707         }
1708 
1709         @Override
1710         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1711             return v.visitModuleType(this, s);
1712         }
1713 
1714         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1715         public String toString() {
1716             return tsym.getQualifiedName().toString();
1717         }
1718 
1719         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1720         public TypeKind getKind() {
1721             return TypeKind.MODULE;
1722         }
1723 
1724         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1725         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1726             return v.visitNoType(this, p);
1727         }
1728     }
1729 
1730     public static class TypeVar extends Type implements TypeVariable {
1731 
1732         /** The upper bound of this type variable; set from outside.
1733          *  Must be nonempty once it is set.
1734          *  For a bound, `bound&#39; is the bound type itself.
1735          *  Multiple bounds are expressed as a single class type which has the
1736          *  individual bounds as superclass, respectively interfaces.
1737          *  The class type then has as `tsym&#39; a compiler generated class `c&#39;,
1738          *  which has a flag COMPOUND and whose owner is the type variable
1739          *  itself. Furthermore, the erasure_field of the class
1740          *  points to the first class or interface bound.
1741          */
1742         private Type _bound = null;
1743 
1744         /** The lower bound of this type variable.
1745          *  TypeVars don&#39;t normally have a lower bound, so it is normally set
1746          *  to syms.botType.
1747          *  Subtypes, such as CapturedType, may provide a different value.
1748          */
1749         public Type lower;
1750 
1751         public TypeVar(Name name, Symbol owner, Type lower) {
1752             super(null, TypeMetadata.EMPTY);
1753             Assert.checkNonNull(lower);
1754             tsym = new TypeVariableSymbol(0, name, this, owner);
1755             this.setUpperBound(null);
1756             this.lower = lower;
1757         }
1758 
1759         public TypeVar(TypeSymbol tsym, Type bound, Type lower) {
1760             this(tsym, bound, lower, TypeMetadata.EMPTY);
1761         }
1762 
1763         public TypeVar(TypeSymbol tsym, Type bound, Type lower,
1764                        TypeMetadata metadata) {
1765             super(tsym, metadata);
1766             Assert.checkNonNull(lower);
1767             this.setUpperBound(bound);
1768             this.lower = lower;
1769         }
1770 
1771         @Override
1772         public TypeVar cloneWithMetadata(TypeMetadata md) {
1773             return new TypeVar(tsym, getUpperBound(), lower, md) {
1774                 @Override
1775                 public Type baseType() { return TypeVar.this.baseType(); }
1776 
1777                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1778                 public Type getUpperBound() { return TypeVar.this.getUpperBound(); }
1779 
1780                 public void setUpperBound(Type bound) { TypeVar.this.setUpperBound(bound); }
1781             };
1782         }
1783 
1784         @Override
1785         public TypeTag getTag() {
1786             return TYPEVAR;
1787         }
1788 
1789         @Override
1790         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1791             return v.visitTypeVar(this, s);
1792         }
1793 
1794         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1795         public Type getUpperBound() { return _bound; }
1796 
1797         public void setUpperBound(Type bound) { this._bound = bound; }
1798 
1799         int rank_field = -1;
1800 
1801         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1802         public Type getLowerBound() {
1803             return lower;
1804         }
1805 
1806         @DefinedBy(Api.LANGUAGE_MODEL)
1807         public TypeKind getKind() {
1808             return TypeKind.TYPEVAR;
1809         }
1810 
1811         public boolean isCaptured() {
1812             return false;
1813         }
1814 
1815         @Override
1816         public boolean isReference() {
1817             return true;
1818         }
1819 
1820         @Override
1821         public boolean isNullOrReference() {
1822             return true;
1823         }
1824 
1825         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1826         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1827             return v.visitTypeVariable(this, p);
1828         }
1829     }
1830 
1831     /** A captured type variable comes from wildcards which can have
1832      *  both upper and lower bound.  CapturedType extends TypeVar with
1833      *  a lower bound.
1834      */
1835     public static class CapturedType extends TypeVar {
1836 
1837         public WildcardType wildcard;
1838 
1839         public CapturedType(Name name,
1840                             Symbol owner,
1841                             Type upper,
1842                             Type lower,
1843                             WildcardType wildcard) {
1844             super(name, owner, lower);
1845             this.lower = Assert.checkNonNull(lower);
1846             this.setUpperBound(upper);
1847             this.wildcard = wildcard;
1848         }
1849 
1850         public CapturedType(TypeSymbol tsym,
1851                             Type bound,
1852                             Type upper,
1853                             Type lower,
1854                             WildcardType wildcard,
1855                             TypeMetadata metadata) {
1856             super(tsym, bound, lower, metadata);
1857             this.wildcard = wildcard;
1858         }
1859 
1860         @Override
1861         public CapturedType cloneWithMetadata(TypeMetadata md) {
1862             return new CapturedType(tsym, getUpperBound(), getUpperBound(), lower, wildcard, md) {
1863                 @Override
1864                 public Type baseType() { return CapturedType.this.baseType(); }
1865 
1866                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1867                 public Type getUpperBound() { return CapturedType.this.getUpperBound(); }
1868 
1869                 public void setUpperBound(Type bound) { CapturedType.this.setUpperBound(bound); }
1870             };
1871         }
1872 
1873         @Override
1874         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1875             return v.visitCapturedType(this, s);
1876         }
1877 
1878         @Override
1879         public boolean isCaptured() {
1880             return true;
1881         }
1882 
1883         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1884         public String toString() {
1885             StringBuilder sb = new StringBuilder();
1886             appendAnnotationsString(sb);
1887             sb.append(&quot;capture#&quot;);
1888             sb.append((hashCode() &amp; 0xFFFFFFFFL) % Printer.PRIME);
1889             sb.append(&quot; of &quot;);
1890             sb.append(wildcard);
1891             return sb.toString();
1892         }
1893     }
1894 
1895     public static abstract class DelegatedType extends Type {
1896         public Type qtype;
1897         public TypeTag tag;
1898 
1899         public DelegatedType(TypeTag tag, Type qtype) {
1900             this(tag, qtype, TypeMetadata.EMPTY);
1901         }
1902 
1903         public DelegatedType(TypeTag tag, Type qtype,
1904                              TypeMetadata metadata) {
1905             super(qtype.tsym, metadata);
1906             this.tag = tag;
1907             this.qtype = qtype;
1908         }
1909 
1910         public TypeTag getTag() { return tag; }
1911         @DefinedBy(Api.LANGUAGE_MODEL)
1912         public String toString() { return qtype.toString(); }
1913         public List&lt;Type&gt; getTypeArguments() { return qtype.getTypeArguments(); }
1914         public Type getEnclosingType() { return qtype.getEnclosingType(); }
1915         public List&lt;Type&gt; getParameterTypes() { return qtype.getParameterTypes(); }
1916         public Type getReturnType() { return qtype.getReturnType(); }
1917         public Type getReceiverType() { return qtype.getReceiverType(); }
1918         public List&lt;Type&gt; getThrownTypes() { return qtype.getThrownTypes(); }
1919         public List&lt;Type&gt; allparams() { return qtype.allparams(); }
1920         public Type getUpperBound() { return qtype.getUpperBound(); }
1921         public boolean isErroneous() { return qtype.isErroneous(); }
1922     }
1923 
1924     /**
1925      * The type of a generic method type. It consists of a method type and
1926      * a list of method type-parameters that are used within the method
1927      * type.
1928      */
1929     public static class ForAll extends DelegatedType implements ExecutableType {
1930         public List&lt;Type&gt; tvars;
1931 
1932         public ForAll(List&lt;Type&gt; tvars, Type qtype) {
1933             super(FORALL, (MethodType)qtype);
1934             this.tvars = tvars;
1935         }
1936 
1937         @Override
1938         public ForAll cloneWithMetadata(TypeMetadata md) {
1939             throw new AssertionError(&quot;Cannot add metadata to a forall type&quot;);
1940         }
1941 
1942         @Override
1943         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1944             return v.visitForAll(this, s);
1945         }
1946 
1947         @DefinedBy(Api.LANGUAGE_MODEL)
1948         public String toString() {
1949             StringBuilder sb = new StringBuilder();
1950             appendAnnotationsString(sb);
1951             sb.append(&#39;&lt;&#39;);
1952             sb.append(tvars);
1953             sb.append(&#39;&gt;&#39;);
1954             sb.append(qtype);
1955             return sb.toString();
1956         }
1957 
1958         public List&lt;Type&gt; getTypeArguments()   { return tvars; }
1959 
1960         public boolean isErroneous()  {
1961             return qtype.isErroneous();
1962         }
1963 
1964         public boolean contains(Type elem) {
1965             return qtype.contains(elem);
1966         }
1967 
1968         public MethodType asMethodType() {
1969             return (MethodType)qtype;
1970         }
1971 
1972         public void complete() {
1973             for (List&lt;Type&gt; l = tvars; l.nonEmpty(); l = l.tail) {
1974                 ((TypeVar)l.head).getUpperBound().complete();
1975             }
1976             qtype.complete();
1977         }
1978 
1979         @DefinedBy(Api.LANGUAGE_MODEL)
1980         public List&lt;TypeVar&gt; getTypeVariables() {
1981             return List.convert(TypeVar.class, getTypeArguments());
1982         }
1983 
1984         @DefinedBy(Api.LANGUAGE_MODEL)
1985         public TypeKind getKind() {
1986             return TypeKind.EXECUTABLE;
1987         }
1988 
1989         @DefinedBy(Api.LANGUAGE_MODEL)
1990         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1991             return v.visitExecutable(this, p);
1992         }
1993     }
1994 
1995     /** A class for inference variables, for use during method/diamond type
1996      *  inference. An inference variable has upper/lower bounds and a set
1997      *  of equality constraints. Such bounds are set during subtyping, type-containment,
1998      *  type-equality checks, when the types being tested contain inference variables.
1999      *  A change listener can be attached to an inference variable, to receive notifications
2000      *  whenever the bounds of an inference variable change.
2001      */
2002     public static class UndetVar extends DelegatedType {
2003 
2004         enum Kind {
2005             NORMAL,
2006             CAPTURED,
2007             THROWS;
2008         }
2009 
2010         /** Inference variable change listener. The listener method is called
2011          *  whenever a change to the inference variable&#39;s bounds occurs
2012          */
2013         public interface UndetVarListener {
2014             /** called when some inference variable bounds (of given kinds ibs) change */
2015             void varBoundChanged(UndetVar uv, InferenceBound ib, Type bound, boolean update);
2016             /** called when the inferred type is set on some inference variable */
2017             default void varInstantiated(UndetVar uv) { Assert.error(); }
2018         }
2019 
2020         /**
2021          * Inference variable bound kinds
2022          */
2023         public enum InferenceBound {
2024             /** lower bounds */
2025             LOWER {
2026                 public InferenceBound complement() { return UPPER; }
2027             },
2028             /** equality constraints */
2029             EQ {
2030                 public InferenceBound complement() { return EQ; }
2031             },
2032             /** upper bounds */
2033             UPPER {
2034                 public InferenceBound complement() { return LOWER; }
2035             };
2036 
2037             public abstract InferenceBound complement();
2038 
2039             public boolean lessThan(InferenceBound that) {
2040                 if (that == this) {
2041                     return false;
2042                 } else {
2043                     switch (that) {
2044                         case UPPER: return true;
2045                         case LOWER: return false;
2046                         case EQ: return (this != UPPER);
2047                         default:
2048                             Assert.error(&quot;Cannot get here!&quot;);
2049                             return false;
2050                     }
2051                 }
2052             }
2053         }
2054 
2055         /** list of incorporation actions (used by the incorporation engine). */
2056         public ArrayDeque&lt;IncorporationAction&gt; incorporationActions = new ArrayDeque&lt;&gt;();
2057 
2058         /** inference variable bounds */
2059         protected Map&lt;InferenceBound, List&lt;Type&gt;&gt; bounds;
2060 
2061         /** inference variable&#39;s inferred type (set from Infer.java) */
2062         private Type inst = null;
2063 
2064         /** number of declared (upper) bounds */
2065         public int declaredCount;
2066 
2067         /** inference variable&#39;s change listener */
2068         public UndetVarListener listener = null;
2069 
2070         Kind kind;
2071 
2072         @Override
2073         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2074             return v.visitUndetVar(this, s);
2075         }
2076 
2077         public UndetVar(TypeVar origin, UndetVarListener listener, Types types) {
2078             // This is a synthesized internal type, so we cannot annotate it.
2079             super(UNDETVAR, origin);
2080             this.kind = origin.isCaptured() ?
2081                     Kind.CAPTURED :
2082                     Kind.NORMAL;
2083             this.listener = listener;
2084             bounds = new EnumMap&lt;&gt;(InferenceBound.class);
2085             List&lt;Type&gt; declaredBounds = types.getBounds(origin);
2086             declaredCount = declaredBounds.length();
2087             bounds.put(InferenceBound.UPPER, List.nil());
2088             bounds.put(InferenceBound.LOWER, List.nil());
2089             bounds.put(InferenceBound.EQ, List.nil());
2090             for (Type t : declaredBounds.reverse()) {
2091                 //add bound works in reverse order
2092                 addBound(InferenceBound.UPPER, t, types, true);
2093             }
2094             if (origin.isCaptured() &amp;&amp; !origin.lower.hasTag(BOT)) {
2095                 //add lower bound if needed
2096                 addBound(InferenceBound.LOWER, origin.lower, types, true);
2097             }
2098         }
2099 
2100         @DefinedBy(Api.LANGUAGE_MODEL)
2101         public String toString() {
2102             StringBuilder sb = new StringBuilder();
2103             appendAnnotationsString(sb);
2104             if (inst == null) {
2105                 sb.append(qtype);
2106                 sb.append(&#39;?&#39;);
2107             } else {
2108                 sb.append(inst);
2109             }
2110             return sb.toString();
2111         }
2112 
2113         public String debugString() {
2114             String result = &quot;inference var = &quot; + qtype + &quot;\n&quot;;
2115             if (inst != null) {
2116                 result += &quot;inst = &quot; + inst + &#39;\n&#39;;
2117             }
2118             for (InferenceBound bound: InferenceBound.values()) {
2119                 List&lt;Type&gt; aboundList = bounds.get(bound);
2120                 if (aboundList != null &amp;&amp; aboundList.size() &gt; 0) {
2121                     result += bound + &quot; = &quot; + aboundList + &#39;\n&#39;;
2122                 }
2123             }
2124             return result;
2125         }
2126 
2127         public void setThrow() {
2128             if (this.kind == Kind.CAPTURED) {
2129                 //invalid state transition
2130                 throw new IllegalStateException();
2131             }
2132             this.kind = Kind.THROWS;
2133         }
2134 
2135         /**
2136          * Returns a new copy of this undet var.
2137          */
2138         public UndetVar dup(Types types) {
2139             UndetVar uv2 = new UndetVar((TypeVar)qtype, listener, types);
2140             dupTo(uv2, types);
2141             return uv2;
2142         }
2143 
2144         /**
2145          * Dumps the contents of this undet var on another undet var.
2146          */
2147         public void dupTo(UndetVar uv2, Types types) {
2148             uv2.listener = null;
2149             uv2.bounds.clear();
2150             for (InferenceBound ib : InferenceBound.values()) {
2151                 uv2.bounds.put(ib, List.nil());
2152                 for (Type t : getBounds(ib)) {
2153                     uv2.addBound(ib, t, types, true);
2154                 }
2155             }
2156             uv2.inst = inst;
2157             uv2.listener = listener;
2158             uv2.incorporationActions = new ArrayDeque&lt;&gt;();
2159             for (IncorporationAction action : incorporationActions) {
2160                 uv2.incorporationActions.add(action.dup(uv2));
2161             }
2162             uv2.kind = kind;
2163         }
2164 
2165         @Override
2166         public UndetVar cloneWithMetadata(TypeMetadata md) {
2167             throw new AssertionError(&quot;Cannot add metadata to an UndetVar type&quot;);
2168         }
2169 
2170         @Override
2171         public boolean isPartial() {
2172             return true;
2173         }
2174 
2175         @Override
2176         public Type baseType() {
2177             return (inst == null) ? this : inst.baseType();
2178         }
2179 
2180         public Type getInst() {
2181             return inst;
2182         }
2183 
2184         public void setInst(Type inst) {
2185             this.inst = inst;
2186             if (listener != null) {
2187                 listener.varInstantiated(this);
2188             }
2189         }
2190 
2191         /** get all bounds of a given kind */
2192         public List&lt;Type&gt; getBounds(InferenceBound... ibs) {
2193             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2194             for (InferenceBound ib : ibs) {
2195                 buf.appendList(bounds.get(ib));
2196             }
2197             return buf.toList();
2198         }
2199 
2200         /** get the list of declared (upper) bounds */
2201         public List&lt;Type&gt; getDeclaredBounds() {
2202             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2203             int count = 0;
2204             for (Type b : getBounds(InferenceBound.UPPER)) {
2205                 if (count++ == declaredCount) break;
2206                 buf.append(b);
2207             }
2208             return buf.toList();
2209         }
2210 
2211         /** internal method used to override an undetvar bounds */
2212         public void setBounds(InferenceBound ib, List&lt;Type&gt; newBounds) {
2213             bounds.put(ib, newBounds);
2214         }
2215 
2216         /** add a bound of a given kind - this might trigger listener notification */
2217         public final void addBound(InferenceBound ib, Type bound, Types types) {
2218             // Per JDK-8075793: in pre-8 sources, follow legacy javac behavior
2219             // when capture variables are inferred as bounds: for lower bounds,
2220             // map to the capture variable&#39;s upper bound; for upper bounds,
2221             // if the capture variable has a lower bound, map to that type
2222             if (types.mapCapturesToBounds) {
2223                 switch (ib) {
2224                     case LOWER:
2225                         bound = types.cvarUpperBound(bound);
2226                         break;
2227                     case UPPER:
2228                         Type altBound = types.cvarLowerBound(bound);
2229                         if (!altBound.hasTag(TypeTag.BOT)) bound = altBound;
2230                         break;
2231                 }
2232             }
2233             addBound(ib, bound, types, false);
2234         }
2235 
2236         @SuppressWarnings(&quot;fallthrough&quot;)
2237         private void addBound(InferenceBound ib, Type bound, Types types, boolean update) {
2238             if (kind == Kind.CAPTURED &amp;&amp; !update) {
2239                 //Captured inference variables bounds must not be updated during incorporation,
2240                 //except when some inference variable (beta) has been instantiated in the
2241                 //right-hand-side of a &#39;C&lt;alpha&gt; = capture(C&lt;? extends/super beta&gt;) constraint.
2242                 if (bound.hasTag(UNDETVAR) &amp;&amp; !((UndetVar)bound).isCaptured()) {
2243                     //If the new incoming bound is itself a (regular) inference variable,
2244                     //then we are allowed to propagate this inference variable bounds to it.
2245                     ((UndetVar)bound).addBound(ib.complement(), this, types, false);
2246                 }
2247             } else {
2248                 Type bound2 = bound.map(toTypeVarMap).baseType();
2249                 List&lt;Type&gt; prevBounds = bounds.get(ib);
2250                 if (bound == qtype) return;
2251                 for (Type b : prevBounds) {
2252                     //check for redundancy - do not add same bound twice
2253                     if (types.isSameType(b, bound2)) return;
2254                 }
2255                 bounds.put(ib, prevBounds.prepend(bound2));
2256                 notifyBoundChange(ib, bound2, false);
2257             }
2258         }
2259         //where
2260             TypeMapping&lt;Void&gt; toTypeVarMap = new StructuralTypeMapping&lt;Void&gt;() {
2261                 @Override
2262                 public Type visitUndetVar(UndetVar uv, Void _unused) {
2263                     return uv.inst != null ? uv.inst : uv.qtype;
2264                 }
2265             };
2266 
2267         /** replace types in all bounds - this might trigger listener notification */
2268         public void substBounds(List&lt;Type&gt; from, List&lt;Type&gt; to, Types types) {
2269             final ListBuffer&lt;Pair&lt;InferenceBound, Type&gt;&gt;  boundsChanged = new ListBuffer&lt;&gt;();
2270             UndetVarListener prevListener = listener;
2271             try {
2272                 //setup new listener for keeping track of changed bounds
2273                 listener = (uv, ib, t, _ignored) -&gt; {
2274                     Assert.check(uv == UndetVar.this);
2275                     boundsChanged.add(new Pair&lt;&gt;(ib, t));
2276                 };
2277                 for (Map.Entry&lt;InferenceBound, List&lt;Type&gt;&gt; _entry : bounds.entrySet()) {
2278                     InferenceBound ib = _entry.getKey();
2279                     List&lt;Type&gt; prevBounds = _entry.getValue();
2280                     ListBuffer&lt;Type&gt; newBounds = new ListBuffer&lt;&gt;();
2281                     ListBuffer&lt;Type&gt; deps = new ListBuffer&lt;&gt;();
2282                     //step 1 - re-add bounds that are not dependent on ivars
2283                     for (Type t : prevBounds) {
2284                         if (!t.containsAny(from)) {
2285                             newBounds.append(t);
2286                         } else {
2287                             deps.append(t);
2288                         }
2289                     }
2290                     //step 2 - replace bounds
2291                     bounds.put(ib, newBounds.toList());
2292                     //step 3 - for each dependency, add new replaced bound
2293                     for (Type dep : deps) {
2294                         addBound(ib, types.subst(dep, from, to), types, true);
2295                     }
2296                 }
2297             } finally {
2298                 listener = prevListener;
2299                 for (Pair&lt;InferenceBound, Type&gt; boundUpdate : boundsChanged) {
2300                     notifyBoundChange(boundUpdate.fst, boundUpdate.snd, true);
2301                 }
2302             }
2303         }
2304 
2305         private void notifyBoundChange(InferenceBound ib, Type bound, boolean update) {
2306             if (listener != null) {
2307                 listener.varBoundChanged(this, ib, bound, update);
2308             }
2309         }
2310 
2311         public final boolean isCaptured() {
2312             return kind == Kind.CAPTURED;
2313         }
2314 
2315         public final boolean isThrows() {
2316             return kind == Kind.THROWS;
2317         }
2318     }
2319 
2320     /** Represents NONE.
2321      */
2322     public static class JCNoType extends Type implements NoType {
2323         public JCNoType() {
2324             // Need to use List.nil(), because JCNoType constructor
2325             // gets called in static initializers in Type, where
2326             // noAnnotations is also defined.
2327             super(null, TypeMetadata.EMPTY);
2328         }
2329 
2330         @Override
2331         public JCNoType cloneWithMetadata(TypeMetadata md) {
2332             throw new AssertionError(&quot;Cannot add metadata to a JCNoType&quot;);
2333         }
2334 
2335         @Override
2336         public TypeTag getTag() {
2337             return NONE;
2338         }
2339 
2340         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2341         public TypeKind getKind() {
2342             return TypeKind.NONE;
2343         }
2344 
2345         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2346         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2347             return v.visitNoType(this, p);
2348         }
2349 
2350         @Override
2351         public boolean isCompound() { return false; }
2352     }
2353 
2354     /** Represents VOID.
2355      */
2356     public static class JCVoidType extends Type implements NoType {
2357 
2358         public JCVoidType() {
2359             // Void cannot be annotated
2360             super(null, TypeMetadata.EMPTY);
2361         }
2362 
2363         @Override
2364         public JCVoidType cloneWithMetadata(TypeMetadata md) {
2365             throw new AssertionError(&quot;Cannot add metadata to a void type&quot;);
2366         }
2367 
2368         @Override
2369         public TypeTag getTag() {
2370             return VOID;
2371         }
2372 
2373         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2374         public TypeKind getKind() {
2375             return TypeKind.VOID;
2376         }
2377 
2378         @Override
2379         public boolean isCompound() { return false; }
2380 
2381         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2382         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2383             return v.visitNoType(this, p);
2384         }
2385 
2386         @Override
2387         public boolean isPrimitiveOrVoid() {
2388             return true;
2389         }
2390     }
2391 
2392     static class BottomType extends Type implements NullType {
2393         public BottomType() {
2394             // Bottom is a synthesized internal type, so it cannot be annotated
2395             super(null, TypeMetadata.EMPTY);
2396         }
2397 
2398         @Override
2399         public BottomType cloneWithMetadata(TypeMetadata md) {
2400             throw new AssertionError(&quot;Cannot add metadata to a bottom type&quot;);
2401         }
2402 
2403         @Override
2404         public TypeTag getTag() {
2405             return BOT;
2406         }
2407 
2408         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2409         public TypeKind getKind() {
2410             return TypeKind.NULL;
2411         }
2412 
2413         @Override
2414         public boolean isCompound() { return false; }
2415 
2416         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2417         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2418             return v.visitNull(this, p);
2419         }
2420 
2421         @Override
2422         public Type constType(Object value) {
2423             return this;
2424         }
2425 
2426         @Override
2427         public String stringValue() {
2428             return &quot;null&quot;;
2429         }
2430 
2431         @Override
2432         public boolean isNullOrReference() {
2433             return true;
2434         }
2435 
2436     }
2437 
2438     public static class ErrorType extends ClassType
2439             implements javax.lang.model.type.ErrorType {
2440 
2441         private Type originalType = null;
2442 
2443         public ErrorType(ClassSymbol c, Type originalType) {
2444             this(originalType, c);
2445             c.type = this;
2446             c.kind = ERR;
2447             c.members_field = new Scope.ErrorScope(c);
2448         }
2449 
2450         public ErrorType(Type originalType, TypeSymbol tsym) {
2451             super(noType, List.nil(), null);
2452             this.tsym = tsym;
2453             this.originalType = (originalType == null ? noType : originalType);
2454         }
2455 
2456         private ErrorType(Type originalType, TypeSymbol tsym,
2457                           TypeMetadata metadata) {
2458             super(noType, List.nil(), null, metadata);
2459             this.tsym = tsym;
2460             this.originalType = (originalType == null ? noType : originalType);
2461         }
2462 
2463         @Override
2464         public ErrorType cloneWithMetadata(TypeMetadata md) {
2465             return new ErrorType(originalType, tsym, md) {
2466                 @Override
2467                 public Type baseType() { return ErrorType.this.baseType(); }
2468             };
2469         }
2470 
2471         @Override
2472         public TypeTag getTag() {
2473             return ERROR;
2474         }
2475 
2476         @Override
2477         public boolean isPartial() {
2478             return true;
2479         }
2480 
2481         @Override
2482         public boolean isReference() {
2483             return true;
2484         }
2485 
2486         @Override
2487         public boolean isNullOrReference() {
2488             return true;
2489         }
2490 
2491         public ErrorType(Name name, TypeSymbol container, Type originalType) {
2492             this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);
2493         }
2494 
2495         @Override
2496         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2497             return v.visitErrorType(this, s);
2498         }
2499 
2500         public Type constType(Object constValue) { return this; }
2501         @DefinedBy(Api.LANGUAGE_MODEL)
2502         public Type getEnclosingType()           { return Type.noType; }
2503         public Type getReturnType()              { return this; }
2504         public Type asSub(Symbol sym)            { return this; }
2505 
2506         public boolean isGenType(Type t)         { return true; }
2507         public boolean isErroneous()             { return true; }
2508         public boolean isCompound()              { return false; }
2509         public boolean isInterface()             { return false; }
2510 
2511         public List&lt;Type&gt; allparams()            { return List.nil(); }
2512         @DefinedBy(Api.LANGUAGE_MODEL)
2513         public List&lt;Type&gt; getTypeArguments()     { return List.nil(); }
2514 
2515         @DefinedBy(Api.LANGUAGE_MODEL)
2516         public TypeKind getKind() {
2517             return TypeKind.ERROR;
2518         }
2519 
2520         public Type getOriginalType() {
2521             return originalType;
2522         }
2523 
2524         @DefinedBy(Api.LANGUAGE_MODEL)
2525         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2526             return v.visitError(this, p);
2527         }
2528     }
2529 
2530     public static class UnknownType extends Type {
2531 
2532         public UnknownType() {
2533             // Unknown is a synthesized internal type, so it cannot be
2534             // annotated.
2535             super(null, TypeMetadata.EMPTY);
2536         }
2537 
2538         @Override
2539         public UnknownType cloneWithMetadata(TypeMetadata md) {
2540             throw new AssertionError(&quot;Cannot add metadata to an unknown type&quot;);
2541         }
2542 
2543         @Override
2544         public TypeTag getTag() {
2545             return UNKNOWN;
2546         }
2547 
2548         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2549         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2550             return v.visitUnknown(this, p);
2551         }
2552 
2553         @Override
2554         public boolean isPartial() {
2555             return true;
2556         }
2557     }
2558 
2559     /**
2560      * A visitor for types.  A visitor is used to implement operations
2561      * (or relations) on types.  Most common operations on types are
2562      * binary relations and this interface is designed for binary
2563      * relations, that is, operations of the form
2564      * Type&amp;nbsp;&amp;times;&amp;nbsp;S&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2565      * &lt;!-- In plain text: Type x S -&gt; R --&gt;
2566      *
2567      * @param &lt;R&gt; the return type of the operation implemented by this
2568      * visitor; use Void if no return type is needed.
2569      * @param &lt;S&gt; the type of the second argument (the first being the
2570      * type itself) of the operation implemented by this visitor; use
2571      * Void if a second argument is not needed.
2572      */
2573     public interface Visitor&lt;R,S&gt; {
2574         R visitClassType(ClassType t, S s);
2575         R visitWildcardType(WildcardType t, S s);
2576         R visitArrayType(ArrayType t, S s);
2577         R visitMethodType(MethodType t, S s);
2578         R visitPackageType(PackageType t, S s);
2579         R visitModuleType(ModuleType t, S s);
2580         R visitTypeVar(TypeVar t, S s);
2581         R visitCapturedType(CapturedType t, S s);
2582         R visitForAll(ForAll t, S s);
2583         R visitUndetVar(UndetVar t, S s);
2584         R visitErrorType(ErrorType t, S s);
2585         R visitType(Type t, S s);
2586     }
2587 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>