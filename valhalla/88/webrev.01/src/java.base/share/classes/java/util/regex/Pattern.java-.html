<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/regex/Pattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.regex;
  27 
  28 import java.text.Normalizer;
  29 import java.text.Normalizer.Form;
  30 import java.util.Locale;
  31 import java.util.Iterator;
  32 import java.util.Map;
  33 import java.util.ArrayList;
  34 import java.util.HashMap;
  35 import java.util.LinkedHashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 import java.util.Arrays;
  39 import java.util.NoSuchElementException;
  40 import java.util.Spliterator;
  41 import java.util.Spliterators;
  42 import java.util.function.Predicate;
  43 import java.util.stream.Stream;
  44 import java.util.stream.StreamSupport;
  45 
  46 import jdk.internal.util.ArraysSupport;
  47 
  48 /**
  49  * A compiled representation of a regular expression.
  50  *
  51  * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
  52  * an instance of this class.  The resulting pattern can then be used to create
  53  * a {@link Matcher} object that can match arbitrary {@linkplain
  54  * java.lang.CharSequence character sequences} against the regular
  55  * expression.  All of the state involved in performing a match resides in the
  56  * matcher, so many matchers can share the same pattern.
  57  *
  58  * &lt;p&gt; A typical invocation sequence is thus
  59  *
  60  * &lt;blockquote&gt;&lt;pre&gt;
  61  * Pattern p = Pattern.{@link #compile compile}(&quot;a*b&quot;);
  62  * Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
  63  * boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
  64  *
  65  * &lt;p&gt; A {@link #matches matches} method is defined by this class as a
  66  * convenience for when a regular expression is used just once.  This method
  67  * compiles an expression and matches an input sequence against it in a single
  68  * invocation.  The statement
  69  *
  70  * &lt;blockquote&gt;&lt;pre&gt;
  71  * boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
  72  *
  73  * is equivalent to the three statements above, though for repeated matches it
  74  * is less efficient since it does not allow the compiled pattern to be reused.
  75  *
  76  * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
  77  * concurrent threads.  Instances of the {@link Matcher} class are not safe for
  78  * such use.
  79  *
  80  *
  81  * &lt;h2&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h2&gt;
  82  *
  83  * &lt;table class=&quot;borderless&quot;&gt;
  84  * &lt;caption style=&quot;display:none&quot;&gt;Regular expression constructs, and what they match&lt;/caption&gt;
  85  * &lt;thead style=&quot;text-align:left&quot;&gt;
  86  * &lt;tr&gt;
  87  * &lt;th id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
  88  * &lt;th id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
  89  * &lt;/tr&gt;
  90  * &lt;/thead&gt;
  91  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  92  *
  93  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
  94  *
  95  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;x&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
  96  *     &lt;td headers=&quot;matches characters x&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  97  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;backslash&quot;&gt;{@code \\}&lt;/th&gt;
  98  *     &lt;td headers=&quot;matches characters backslash&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
  99  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_n&quot;&gt;{@code \0}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
 100  *     &lt;td headers=&quot;matches characters octal_n&quot;&gt;The character with octal value {@code 0}&lt;i&gt;n&lt;/i&gt;
 101  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 102  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_nn&quot;&gt;{@code \0}&lt;i&gt;nn&lt;/i&gt;&lt;/th&gt;
 103  *     &lt;td headers=&quot;matches characters octal_nn&quot;&gt;The character with octal value {@code 0}&lt;i&gt;nn&lt;/i&gt;
 104  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 105  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_nnn&quot;&gt;{@code \0}&lt;i&gt;mnn&lt;/i&gt;&lt;/th&gt;
 106  *     &lt;td headers=&quot;matches characters octal_nnn&quot;&gt;The character with octal value {@code 0}&lt;i&gt;mnn&lt;/i&gt;
 107  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;m&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;3,
 108  *         0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
 109  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_hh&quot;&gt;{@code \x}&lt;i&gt;hh&lt;/i&gt;&lt;/th&gt;
 110  *     &lt;td headers=&quot;matches characters hex_hh&quot;&gt;The character with hexadecimal value {@code 0x}&lt;i&gt;hh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 111  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_hhhh&quot;&gt;&lt;code&gt;&amp;#92;u&lt;/code&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;/th&gt;
 112  *     &lt;td headers=&quot;matches characters hex_hhhh&quot;&gt;The character with hexadecimal&amp;nbsp;value&amp;nbsp;{@code 0x}&lt;i&gt;hhhh&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 113  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;hex_h_h&quot;&gt;&lt;code&gt;&amp;#92;x&lt;/code&gt;&lt;i&gt;{h...h}&lt;/i&gt;&lt;/th&gt;
 114  *     &lt;td headers=&quot;matches characters hex_h_h&quot;&gt;The character with hexadecimal value {@code 0x}&lt;i&gt;h...h&lt;/i&gt;
 115  *         ({@link java.lang.Character#MIN_CODE_POINT Character.MIN_CODE_POINT}
 116  *         &amp;nbsp;&amp;lt;=&amp;nbsp;{@code 0x}&lt;i&gt;h...h&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;
 117  *          {@link java.lang.Character#MAX_CODE_POINT Character.MAX_CODE_POINT})&lt;/td&gt;&lt;/tr&gt;
 118  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;unicode_name&quot;&gt;&lt;code&gt;&amp;#92;N{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 119  *     &lt;td headers=&quot;matches characters unicode_name&quot;&gt;The character with Unicode character name &lt;i&gt;&#39;name&#39;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 120  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;tab&quot;&gt;{@code \t}&lt;/th&gt;
 121  *     &lt;td headers=&quot;matches characters tab&quot;&gt;The tab character (&lt;code&gt;&#39;&amp;#92;u0009&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 122  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;newline&quot;&gt;{@code \n}&lt;/th&gt;
 123  *     &lt;td headers=&quot;matches characters newline&quot;&gt;The newline (line feed) character (&lt;code&gt;&#39;&amp;#92;u000A&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 124  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;return&quot;&gt;{@code \r}&lt;/th&gt;
 125  *     &lt;td headers=&quot;matches characters return&quot;&gt;The carriage-return character (&lt;code&gt;&#39;&amp;#92;u000D&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 126  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;form_feed&quot;&gt;{@code \f}&lt;/th&gt;
 127  *     &lt;td headers=&quot;matches characters form_feed&quot;&gt;The form-feed character (&lt;code&gt;&#39;&amp;#92;u000C&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 128  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;bell&quot;&gt;{@code \a}&lt;/th&gt;
 129  *     &lt;td headers=&quot;matches characters bell&quot;&gt;The alert (bell) character (&lt;code&gt;&#39;&amp;#92;u0007&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 130  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;escape&quot;&gt;{@code \e}&lt;/th&gt;
 131  *     &lt;td headers=&quot;matches characters escape&quot;&gt;The escape character (&lt;code&gt;&#39;&amp;#92;u001B&#39;&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
 132  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;ctrl_x&quot;&gt;{@code \c}&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
 133  *     &lt;td headers=&quot;matches characters ctrl_x&quot;&gt;The control character corresponding to &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 134  *
 135  *  &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;classes&quot;&gt;Character classes&lt;/th&gt;&lt;/tr&gt;
 136  *
 137  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;simple&quot;&gt;{@code [abc]}&lt;/th&gt;
 138  *     &lt;td headers=&quot;matches classes simple&quot;&gt;{@code a}, {@code b}, or {@code c} (simple class)&lt;/td&gt;&lt;/tr&gt;
 139  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;negation&quot;&gt;{@code [^abc]}&lt;/th&gt;
 140  *     &lt;td headers=&quot;matches classes negation&quot;&gt;Any character except {@code a}, {@code b}, or {@code c} (negation)&lt;/td&gt;&lt;/tr&gt;
 141  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;range&quot;&gt;{@code [a-zA-Z]}&lt;/th&gt;
 142  *     &lt;td headers=&quot;matches classes range&quot;&gt;{@code a} through {@code z}
 143  *         or {@code A} through {@code Z}, inclusive (range)&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;union&quot;&gt;{@code [a-d[m-p]]}&lt;/th&gt;
 145  *     &lt;td headers=&quot;matches classes union&quot;&gt;{@code a} through {@code d},
 146  *      or {@code m} through {@code p}: {@code [a-dm-p]} (union)&lt;/td&gt;&lt;/tr&gt;
 147  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;intersection&quot;&gt;{@code [a-z&amp;&amp;[def]]}&lt;/th&gt;
 148  *     &lt;td headers=&quot;matches classes intersection&quot;&gt;{@code d}, {@code e}, or {@code f} (intersection)&lt;/tr&gt;
 149  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;subtraction1&quot;&gt;{@code [a-z&amp;&amp;[^bc]]}&lt;/th&gt;
 150  *     &lt;td headers=&quot;matches classes subtraction1&quot;&gt;{@code a} through {@code z},
 151  *         except for {@code b} and {@code c}: {@code [ad-z]} (subtraction)&lt;/td&gt;&lt;/tr&gt;
 152  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;subtraction2&quot;&gt;{@code [a-z&amp;&amp;[^m-p]]}&lt;/th&gt;
 153  *     &lt;td headers=&quot;matches classes subtraction2&quot;&gt;{@code a} through {@code z},
 154  *          and not {@code m} through {@code p}: {@code [a-lq-z]}(subtraction)&lt;/td&gt;&lt;/tr&gt;
 155  *
 156  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;predef&quot;&gt;Predefined character classes&lt;/th&gt;&lt;/tr&gt;
 157  *
 158  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;any&quot;&gt;{@code .}&lt;/th&gt;
 159  *     &lt;td headers=&quot;matches predef any&quot;&gt;Any character (may or may not match &lt;a href=&quot;#lt&quot;&gt;line terminators&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 160  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;digit&quot;&gt;{@code \d}&lt;/th&gt;
 161  *     &lt;td headers=&quot;matches predef digit&quot;&gt;A digit: {@code [0-9]}&lt;/td&gt;&lt;/tr&gt;
 162  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_digit&quot;&gt;{@code \D}&lt;/th&gt;
 163  *     &lt;td headers=&quot;matches predef non_digit&quot;&gt;A non-digit: {@code [^0-9]}&lt;/td&gt;&lt;/tr&gt;
 164  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;horiz_white&quot;&gt;{@code \h}&lt;/th&gt;
 165  *     &lt;td headers=&quot;matches predef horiz_white&quot;&gt;A horizontal whitespace character:
 166  *     &lt;code&gt;[ \t\xA0&amp;#92;u1680&amp;#92;u180e&amp;#92;u2000-&amp;#92;u200a&amp;#92;u202f&amp;#92;u205f&amp;#92;u3000]&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 167  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_horiz_white&quot;&gt;{@code \H}&lt;/th&gt;
 168  *     &lt;td headers=&quot;matches predef non_horiz_white&quot;&gt;A non-horizontal whitespace character: {@code [^\h]}&lt;/td&gt;&lt;/tr&gt;
 169  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;white&quot;&gt;{@code \s}&lt;/th&gt;
 170  *     &lt;td headers=&quot;matches predef white&quot;&gt;A whitespace character: {@code [ \t\n\x0B\f\r]}&lt;/td&gt;&lt;/tr&gt;
 171  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_white&quot;&gt;{@code \S}&lt;/th&gt;
 172  *     &lt;td headers=&quot;matches predef non_white&quot;&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 173  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;vert_white&quot;&gt;{@code \v}&lt;/th&gt;
 174  *     &lt;td headers=&quot;matches predef vert_white&quot;&gt;A vertical whitespace character: &lt;code&gt;[\n\x0B\f\r\x85&amp;#92;u2028&amp;#92;u2029]&lt;/code&gt;
 175  *     &lt;/td&gt;&lt;/tr&gt;
 176  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_vert_white&quot;&gt;{@code \V}&lt;/th&gt;
 177  *     &lt;td headers=&quot;matches predef non_vert_white&quot;&gt;A non-vertical whitespace character: {@code [^\v]}&lt;/td&gt;&lt;/tr&gt;
 178  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;word&quot;&gt;{@code \w}&lt;/th&gt;
 179  *     &lt;td headers=&quot;matches predef word&quot;&gt;A word character: {@code [a-zA-Z_0-9]}&lt;/td&gt;&lt;/tr&gt;
 180  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_word&quot;&gt;{@code \W}&lt;/th&gt;
 181  *     &lt;td headers=&quot;matches predef non_word&quot;&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 182  *
 183  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;posix&quot;&gt;&lt;b&gt;POSIX character classes (US-ASCII only)&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;
 184  *
 185  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Lower&quot;&gt;{@code \p{Lower}}&lt;/th&gt;
 186  *     &lt;td headers=&quot;matches posix Lower&quot;&gt;A lower-case alphabetic character: {@code [a-z]}&lt;/td&gt;&lt;/tr&gt;
 187  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Upper&quot;&gt;{@code \p{Upper}}&lt;/th&gt;
 188  *     &lt;td headers=&quot;matches posix Upper&quot;&gt;An upper-case alphabetic character:{@code [A-Z]}&lt;/td&gt;&lt;/tr&gt;
 189  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;ASCII&quot;&gt;{@code \p{ASCII}}&lt;/th&gt;
 190  *     &lt;td headers=&quot;matches posix ASCII&quot;&gt;All ASCII:{@code [\x00-\x7F]}&lt;/td&gt;&lt;/tr&gt;
 191  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Alpha&quot;&gt;{@code \p{Alpha}}&lt;/th&gt;
 192  *     &lt;td headers=&quot;matches posix Alpha&quot;&gt;An alphabetic character:{@code [\p{Lower}\p{Upper}]}&lt;/td&gt;&lt;/tr&gt;
 193  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Digit&quot;&gt;{@code \p{Digit}}&lt;/th&gt;
 194  *     &lt;td headers=&quot;matches posix Digit&quot;&gt;A decimal digit: {@code [0-9]}&lt;/td&gt;&lt;/tr&gt;
 195  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Alnum&quot;&gt;{@code \p{Alnum}}&lt;/th&gt;
 196  *     &lt;td headers=&quot;matches posix Alnum&quot;&gt;An alphanumeric character:{@code [\p{Alpha}\p{Digit}]}&lt;/td&gt;&lt;/tr&gt;
 197  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Punct&quot;&gt;{@code \p{Punct}}&lt;/th&gt;
 198  *     &lt;td headers=&quot;matches posix Punct&quot;&gt;Punctuation: One of {@code !&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~}&lt;/td&gt;&lt;/tr&gt;
 199  *     &lt;!-- {@code [\!&quot;#\$%&amp;&#39;\(\)\*\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]}
 200  *          {@code [\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]} --&gt;
 201  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Graph&quot;&gt;{@code \p{Graph}}&lt;/th&gt;
 202  *     &lt;td headers=&quot;matches posix Graph&quot;&gt;A visible character: {@code [\p{Alnum}\p{Punct}]}&lt;/td&gt;&lt;/tr&gt;
 203  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Print&quot;&gt;{@code \p{Print}}&lt;/th&gt;
 204  *     &lt;td headers=&quot;matches posix Print&quot;&gt;A printable character: {@code [\p{Graph}\x20]}&lt;/td&gt;&lt;/tr&gt;
 205  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Blank&quot;&gt;{@code \p{Blank}}&lt;/th&gt;
 206  *     &lt;td headers=&quot;matches posix Blank&quot;&gt;A space or a tab: {@code [ \t]}&lt;/td&gt;&lt;/tr&gt;
 207  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Cntrl&quot;&gt;{@code \p{Cntrl}}&lt;/th&gt;
 208  *     &lt;td headers=&quot;matches posix Cntrl&quot;&gt;A control character: {@code [\x00-\x1F\x7F]}&lt;/td&gt;&lt;/tr&gt;
 209  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;XDigit&quot;&gt;{@code \p{XDigit}}&lt;/th&gt;
 210  *     &lt;td headers=&quot;matches posix XDigit&quot;&gt;A hexadecimal digit: {@code [0-9a-fA-F]}&lt;/td&gt;&lt;/tr&gt;
 211  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Space&quot;&gt;{@code \p{Space}}&lt;/th&gt;
 212  *     &lt;td headers=&quot;matches posix Space&quot;&gt;A whitespace character: {@code [ \t\n\x0B\f\r]}&lt;/td&gt;&lt;/tr&gt;
 213  *
 214  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;java&quot;&gt;java.lang.Character classes (simple &lt;a href=&quot;#jcc&quot;&gt;java character type&lt;/a&gt;)&lt;/th&gt;&lt;/tr&gt;
 215  *
 216  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaLowerCase&quot;&gt;{@code \p{javaLowerCase}}&lt;/th&gt;
 217  *     &lt;td headers=&quot;matches java javaLowerCase&quot;&gt;Equivalent to java.lang.Character.isLowerCase()&lt;/td&gt;&lt;/tr&gt;
 218  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaUpperCase&quot;&gt;{@code \p{javaUpperCase}}&lt;/th&gt;
 219  *     &lt;td headers=&quot;matches java javaUpperCase&quot;&gt;Equivalent to java.lang.Character.isUpperCase()&lt;/td&gt;&lt;/tr&gt;
 220  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaWhitespace&quot;&gt;{@code \p{javaWhitespace}}&lt;/th&gt;
 221  *     &lt;td headers=&quot;matches java javaWhitespace&quot;&gt;Equivalent to java.lang.Character.isWhitespace()&lt;/td&gt;&lt;/tr&gt;
 222  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;javaMirrored&quot;&gt;{@code \p{javaMirrored}}&lt;/th&gt;
 223  *     &lt;td headers=&quot;matches java javaMirrored&quot;&gt;Equivalent to java.lang.Character.isMirrored()&lt;/td&gt;&lt;/tr&gt;
 224  *
 225  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot;  id=&quot;unicode&quot;&gt;Classes for Unicode scripts, blocks, categories and binary properties&lt;/th&gt;&lt;/tr&gt;
 226  *
 227  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;IsLatin&quot;&gt;{@code \p{IsLatin}}&lt;/th&gt;
 228  *     &lt;td headers=&quot;matches unicode IsLatin&quot;&gt;A Latin&amp;nbsp;script character (&lt;a href=&quot;#usc&quot;&gt;script&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 229  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;InGreek&quot;&gt;{@code \p{InGreek}}&lt;/th&gt;
 230  *     &lt;td headers=&quot;matches unicode InGreek&quot;&gt;A character in the Greek&amp;nbsp;block (&lt;a href=&quot;#ubc&quot;&gt;block&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 231  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Lu&quot;&gt;{@code \p{Lu}}&lt;/th&gt;
 232  *     &lt;td headers=&quot;matches unicode Lu&quot;&gt;An uppercase letter (&lt;a href=&quot;#ucc&quot;&gt;category&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 233  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;IsAlphabetic&quot;&gt;{@code \p{IsAlphabetic}}&lt;/th&gt;
 234  *     &lt;td headers=&quot;matches unicode IsAlphabetic&quot;&gt;An alphabetic character (&lt;a href=&quot;#ubpc&quot;&gt;binary property&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;
 235  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;Sc&quot;&gt;{@code \p{Sc}}&lt;/th&gt;
 236  *     &lt;td headers=&quot;matches unicode Sc&quot;&gt;A currency symbol&lt;/td&gt;&lt;/tr&gt;
 237  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;not_InGreek&quot;&gt;{@code \P{InGreek}}&lt;/th&gt;
 238  *     &lt;td headers=&quot;matches unicode not_InGreek&quot;&gt;Any character except one in the Greek block (negation)&lt;/td&gt;&lt;/tr&gt;
 239  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;not_uppercase&quot;&gt;{@code [\p{L}&amp;&amp;[^\p{Lu}]]}&lt;/th&gt;
 240  *     &lt;td headers=&quot;matches unicode not_uppercase&quot;&gt;Any letter except an uppercase letter (subtraction)&lt;/td&gt;&lt;/tr&gt;
 241  *
 242  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;bounds&quot;&gt;Boundary matchers&lt;/th&gt;&lt;/tr&gt;
 243  *
 244  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;begin_line&quot;&gt;{@code ^}&lt;/th&gt;
 245  *     &lt;td headers=&quot;matches bounds begin_line&quot;&gt;The beginning of a line&lt;/td&gt;&lt;/tr&gt;
 246  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_line&quot;&gt;{@code $}&lt;/th&gt;
 247  *     &lt;td headers=&quot;matches bounds end_line&quot;&gt;The end of a line&lt;/td&gt;&lt;/tr&gt;
 248  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;word_boundary&quot;&gt;{@code \b}&lt;/th&gt;
 249  *     &lt;td headers=&quot;matches bounds word_boundary&quot;&gt;A word boundary&lt;/td&gt;&lt;/tr&gt;
 250  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;grapheme_cluster_boundary&quot;&gt;{@code \b{g}}&lt;/th&gt;
 251  *     &lt;td headers=&quot;matches bounds grapheme_cluster_boundary&quot;&gt;A Unicode extended grapheme cluster boundary&lt;/td&gt;&lt;/tr&gt;
 252  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_word_boundary&quot;&gt;{@code \B}&lt;/th&gt;
 253  *     &lt;td headers=&quot;matches bounds non_word_boundary&quot;&gt;A non-word boundary&lt;/td&gt;&lt;/tr&gt;
 254  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;begin_input&quot;&gt;{@code \A}&lt;/th&gt;
 255  *     &lt;td headers=&quot;matches bounds begin_input&quot;&gt;The beginning of the input&lt;/td&gt;&lt;/tr&gt;
 256  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_prev_match&quot;&gt;{@code \G}&lt;/th&gt;
 257  *     &lt;td headers=&quot;matches bounds end_prev_match&quot;&gt;The end of the previous match&lt;/td&gt;&lt;/tr&gt;
 258  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_input_except_term&quot;&gt;{@code \Z}&lt;/th&gt;
 259  *     &lt;td headers=&quot;matches bounds end_input_except_term&quot;&gt;The end of the input but for the final
 260  *         &lt;a href=&quot;#lt&quot;&gt;terminator&lt;/a&gt;, if&amp;nbsp;any&lt;/td&gt;&lt;/tr&gt;
 261  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;end_input&quot;&gt;{@code \z}&lt;/th&gt;
 262  *     &lt;td headers=&quot;matches bounds end_input&quot;&gt;The end of the input&lt;/td&gt;&lt;/tr&gt;
 263  *
 264  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;linebreak&quot;&gt;Linebreak matcher&lt;/th&gt;&lt;/tr&gt;
 265  *
 266  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;any_unicode_linebreak&quot;&gt;{@code \R}&lt;/th&gt;
 267  *     &lt;td headers=&quot;matches linebreak any_unicode_linebreak&quot;&gt;Any Unicode linebreak sequence, is equivalent to
 268  *     &lt;code&gt;&amp;#92;u000D&amp;#92;u000A|[&amp;#92;u000A&amp;#92;u000B&amp;#92;u000C&amp;#92;u000D&amp;#92;u0085&amp;#92;u2028&amp;#92;u2029]
 269  *     &lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 270  *
 271  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;grapheme&quot;&gt;Unicode Extended Grapheme matcher&lt;/th&gt;&lt;/tr&gt;
 272  *
 273  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;grapheme_any&quot;&gt;{@code \X}&lt;/th&gt;
 274  *     &lt;td headers=&quot;matches grapheme grapheme_any&quot;&gt;Any Unicode extended grapheme cluster&lt;/td&gt;&lt;/tr&gt;
 275  *
 276  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;greedy&quot;&gt;Greedy quantifiers&lt;/th&gt;&lt;/tr&gt;
 277  *
 278  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ?}&lt;/th&gt;
 279  *     &lt;td headers=&quot;matches greedy greedy_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 280  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *}&lt;/th&gt;
 281  *     &lt;td headers=&quot;matches greedy greedy_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 282  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code +}&lt;/th&gt;
 283  *     &lt;td headers=&quot;matches greedy greedy_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 284  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 285  *     &lt;td headers=&quot;matches greedy greedy_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 286  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}}&lt;/th&gt;
 287  *     &lt;td headers=&quot;matches greedy greedy_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 288  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;greedy_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;&lt;/th&gt;
 289  *     &lt;td headers=&quot;matches greedy greedy_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 290  *
 291  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;reluc&quot;&gt;Reluctant quantifiers&lt;/th&gt;&lt;/tr&gt;
 292  *
 293  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ??}&lt;/th&gt;
 294  *     &lt;td headers=&quot;matches reluc reluc_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 295  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *?}&lt;/th&gt;
 296  *     &lt;td headers=&quot;matches reluc reluc_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 297  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code +?}&lt;/th&gt;
 298  *     &lt;td headers=&quot;matches reluc reluc_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 299  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}?&lt;/code&gt;&lt;/th&gt;
 300  *     &lt;td headers=&quot;matches reluc reluc_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 301  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;,}?&lt;/code&gt;&lt;/th&gt;
 302  *     &lt;td headers=&quot;matches reluc reluc_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 303  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;reluc_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}?&lt;/code&gt;&lt;/th&gt;
 304  *     &lt;td headers=&quot;matches reluc reluc_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 305  *
 306  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;poss&quot;&gt;Possessive quantifiers&lt;/th&gt;&lt;/tr&gt;
 307  *
 308  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ?+}&lt;/th&gt;
 309  *     &lt;td headers=&quot;matches poss poss_once_or_not&quot;&gt;&lt;i&gt;X&lt;/i&gt;, once or not at all&lt;/td&gt;&lt;/tr&gt;
 310  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code *+}&lt;/th&gt;
 311  *     &lt;td headers=&quot;matches poss poss_zero_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, zero or more times&lt;/td&gt;&lt;/tr&gt;
 312  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code ++}&lt;/th&gt;
 313  *     &lt;td headers=&quot;matches poss poss_one_or_more&quot;&gt;&lt;i&gt;X&lt;/i&gt;, one or more times&lt;/td&gt;&lt;/tr&gt;
 314  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}+&lt;/code&gt;&lt;/th&gt;
 315  *     &lt;td headers=&quot;matches poss poss_exactly&quot;&gt;&lt;i&gt;X&lt;/i&gt;, exactly &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 316  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;,}+&lt;/code&gt;&lt;/th&gt;
 317  *     &lt;td headers=&quot;matches poss poss_at_least&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 318  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;poss_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;&lt;code&gt;{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;{@code ,}&lt;i&gt;m&lt;/i&gt;&lt;code&gt;}+&lt;/code&gt;&lt;/th&gt;
 319  *     &lt;td headers=&quot;matches poss poss_at_least_up_to&quot;&gt;&lt;i&gt;X&lt;/i&gt;, at least &lt;i&gt;n&lt;/i&gt; but not more than &lt;i&gt;m&lt;/i&gt; times&lt;/td&gt;&lt;/tr&gt;
 320  *
 321  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;logical&quot;&gt;Logical operators&lt;/th&gt;&lt;/tr&gt;
 322  *
 323  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;concat&quot;&gt;&lt;i&gt;XY&lt;/i&gt;&lt;/th&gt;
 324  *     &lt;td headers=&quot;matches logical concat&quot;&gt;&lt;i&gt;X&lt;/i&gt; followed by &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 325  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;alternate&quot;&gt;&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;&lt;/th&gt;
 326  *     &lt;td headers=&quot;matches logical alternate&quot;&gt;Either &lt;i&gt;X&lt;/i&gt; or &lt;i&gt;Y&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 327  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;group&quot;&gt;{@code (}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 328  *     &lt;td headers=&quot;matches logical group&quot;&gt;X, as a &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
 329  *
 330  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;backref&quot;&gt;Back references&lt;/th&gt;&lt;/tr&gt;
 331  *
 332  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;back_nth&quot;&gt;{@code \}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
 333  *     &lt;td headers=&quot;matches backref back_nth&quot;&gt;Whatever the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;
 334  *     &lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; matched&lt;/td&gt;&lt;/tr&gt;
 335  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;back_named&quot;&gt;{@code \}&lt;i&gt;k&lt;/i&gt;&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/th&gt;
 336  *     &lt;td headers=&quot;matches backref back_named&quot;&gt;Whatever the
 337  *     &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched&lt;/td&gt;&lt;/tr&gt;
 338  *
 339  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;quote&quot;&gt;Quotation&lt;/th&gt;&lt;/tr&gt;
 340  *
 341  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_follow&quot;&gt;{@code \}&lt;/th&gt;
 342  *     &lt;td headers=&quot;matches quote quote_follow&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
 343  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_begin&quot;&gt;{@code \Q}&lt;/th&gt;
 344  *     &lt;td headers=&quot;matches quote quote_begin&quot;&gt;Nothing, but quotes all characters until {@code \E}&lt;/td&gt;&lt;/tr&gt;
 345  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_end&quot;&gt;{@code \E}&lt;/th&gt;
 346  *     &lt;td headers=&quot;matches quote quote_end&quot;&gt;Nothing, but ends quoting started by {@code \Q}&lt;/td&gt;&lt;/tr&gt;
 347  *     &lt;!-- Metachars: !$()*+.&lt;&gt;?[\]^{|} --&gt;
 348  *
 349  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
 350  *
 351  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;named_group&quot;&gt;&lt;code&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 352  *     &lt;td headers=&quot;matches special named_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
 353  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group&quot;&gt;{@code (?:}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 354  *     &lt;td headers=&quot;matches special non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
 355  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;flags&quot;&gt;&lt;code&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
 356  *     &lt;td headers=&quot;matches special flags&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
 357  * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
 358  * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
 359  * on - off&lt;/td&gt;&lt;/tr&gt;
 360  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;{@code (?idmsuxU-idmsuxU:}&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;
 361  *     &lt;td headers=&quot;matches special non_capture_group_flags&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
 362  *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
 363  * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
 364  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;
 365  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookahead&quot;&gt;{@code (?=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 366  *     &lt;td headers=&quot;matches special pos_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
 367  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookahead&quot;&gt;{@code (?!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 368  *     &lt;td headers=&quot;matches special neg_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
 369  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookbehind&quot;&gt;{@code (?&lt;=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 370  *     &lt;td headers=&quot;matches special pos_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
 371  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookbehind&quot;&gt;{@code (?&lt;!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 372  *     &lt;td headers=&quot;matches special neg_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
 373  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;indep_non_capture_group&quot;&gt;{@code (?&gt;}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 374  *     &lt;td headers=&quot;matches special indep_non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
 375  *
 376  * &lt;/tbody&gt;
 377  * &lt;/table&gt;
 378  *
 379  * &lt;hr&gt;
 380  *
 381  *
 382  * &lt;h2&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h2&gt;
 383  *
 384  * &lt;p&gt; The backslash character ({@code &#39;\&#39;}) serves to introduce escaped
 385  * constructs, as defined in the table above, as well as to quote characters
 386  * that otherwise would be interpreted as unescaped constructs.  Thus the
 387  * expression {@code \\} matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a
 388  * left brace.
 389  *
 390  * &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
 391  * does not denote an escaped construct; these are reserved for future
 392  * extensions to the regular-expression language.  A backslash may be used
 393  * prior to a non-alphabetic character regardless of whether that character is
 394  * part of an unescaped construct.
 395  *
 396  * &lt;p&gt; Backslashes within string literals in Java source code are interpreted
 397  * as required by
 398  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 399  * as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
 400  * It is therefore necessary to double backslashes in string
 401  * literals that represent regular expressions to protect them from
 402  * interpretation by the Java bytecode compiler.  The string literal
 403  * &lt;code&gt;&quot;&amp;#92;b&quot;&lt;/code&gt;, for example, matches a single backspace character when
 404  * interpreted as a regular expression, while {@code &quot;\\b&quot;} matches a
 405  * word boundary.  The string literal {@code &quot;\(hello\)&quot;} is illegal
 406  * and leads to a compile-time error; in order to match the string
 407  * {@code (hello)} the string literal {@code &quot;\\(hello\\)&quot;}
 408  * must be used.
 409  *
 410  * &lt;h2&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h2&gt;
 411  *
 412  *    &lt;p&gt; Character classes may appear within other character classes, and
 413  *    may be composed by the union operator (implicit) and the intersection
 414  *    operator ({@code &amp;&amp;}).
 415  *    The union operator denotes a class that contains every character that is
 416  *    in at least one of its operand classes.  The intersection operator
 417  *    denotes a class that contains every character that is in both of its
 418  *    operand classes.
 419  *
 420  *    &lt;p&gt; The precedence of character-class operators is as follows, from
 421  *    highest to lowest:
 422  *
 423  *    &lt;table class=&quot;striped&quot; style=&quot;margin-left: 2em;&quot;&gt;
 424  *      &lt;caption style=&quot;display:none&quot;&gt;Precedence of character class operators.&lt;/caption&gt;
 425  *      &lt;thead&gt;
 426  *      &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Precedence&lt;th scope=&quot;col&quot;&gt;Name&lt;th scope=&quot;col&quot;&gt;Example
 427  *      &lt;/thead&gt;
 428  *      &lt;tbody&gt;
 429  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
 430  *        &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
 431  *        &lt;td&gt;{@code \x}&lt;/td&gt;&lt;/tr&gt;
 432  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
 433  *        &lt;td&gt;Grouping&lt;/td&gt;
 434  *        &lt;td&gt;{@code [...]}&lt;/td&gt;&lt;/tr&gt;
 435  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
 436  *        &lt;td&gt;Range&lt;/td&gt;
 437  *        &lt;td&gt;{@code a-z}&lt;/td&gt;&lt;/tr&gt;
 438  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
 439  *        &lt;td&gt;Union&lt;/td&gt;
 440  *        &lt;td&gt;{@code [a-e][i-u]}&lt;/td&gt;&lt;/tr&gt;
 441  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
 442  *        &lt;td&gt;Intersection&lt;/td&gt;
 443  *        &lt;td&gt;{@code [a-z&amp;&amp;[aeiou]]}&lt;/td&gt;&lt;/tr&gt;
 444  *      &lt;/tbody&gt;
 445  *    &lt;/table&gt;
 446  *
 447  *    &lt;p&gt; Note that a different set of metacharacters are in effect inside
 448  *    a character class than outside a character class. For instance, the
 449  *    regular expression {@code .} loses its special meaning inside a
 450  *    character class, while the expression {@code -} becomes a range
 451  *    forming metacharacter.
 452  *
 453  * &lt;h2&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h2&gt;
 454  *
 455  * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
 456  * the end of a line of the input character sequence.  The following are
 457  * recognized as line terminators:
 458  *
 459  * &lt;ul&gt;
 460  *
 461  *   &lt;li&gt; A newline (line feed) character ({@code &#39;\n&#39;}),
 462  *
 463  *   &lt;li&gt; A carriage-return character followed immediately by a newline
 464  *   character ({@code &quot;\r\n&quot;}),
 465  *
 466  *   &lt;li&gt; A standalone carriage-return character ({@code &#39;\r&#39;}),
 467  *
 468  *   &lt;li&gt; A next-line character (&lt;code&gt;&#39;&amp;#92;u0085&#39;&lt;/code&gt;),
 469  *
 470  *   &lt;li&gt; A line-separator character (&lt;code&gt;&#39;&amp;#92;u2028&#39;&lt;/code&gt;), or
 471  *
 472  *   &lt;li&gt; A paragraph-separator character (&lt;code&gt;&#39;&amp;#92;u2029&#39;&lt;/code&gt;).
 473  *
 474  * &lt;/ul&gt;
 475  * &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
 476  * recognized are newline characters.
 477  *
 478  * &lt;p&gt; The regular expression {@code .} matches any character except a line
 479  * terminator unless the {@link #DOTALL} flag is specified.
 480  *
 481  * &lt;p&gt; By default, the regular expressions {@code ^} and {@code $} ignore
 482  * line terminators and only match at the beginning and the end, respectively,
 483  * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 484  * {@code ^} matches at the beginning of input and after any line terminator
 485  * except at the end of input. When in {@link #MULTILINE} mode {@code $}
 486  * matches just before a line terminator or the end of the input sequence.
 487  *
 488  * &lt;h2&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h2&gt;
 489  *
 490  * &lt;h3&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h3&gt;
 491  * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
 492  * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
 493  * are four such groups: &lt;/p&gt;
 494  *
 495  * &lt;ol style=&quot;margin-left:2em;&quot;&gt;
 496  *   &lt;li&gt; {@code ((A)(B(C)))}
 497  *   &lt;li&gt; {@code (A)}
 498  *   &lt;li&gt; {@code (B(C))}
 499  *   &lt;li&gt; {@code (C)}
 500  * &lt;/ol&gt;
 501  *
 502  * &lt;p&gt; Group zero always stands for the entire expression.
 503  *
 504  * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
 505  * of the input sequence that matches such a group is saved.  The captured
 506  * subsequence may be used later in the expression, via a back reference, and
 507  * may also be retrieved from the matcher once the match operation is complete.
 508  *
 509  * &lt;h3&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h3&gt;
 510  * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a {@code named-capturing group},
 511  * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
 512  * the following characters. The first character must be a {@code letter}.
 513  *
 514  * &lt;ul&gt;
 515  *   &lt;li&gt; The uppercase letters {@code &#39;A&#39;} through {@code &#39;Z&#39;}
 516  *        (&lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;),
 517  *   &lt;li&gt; The lowercase letters {@code &#39;a&#39;} through {@code &#39;z&#39;}
 518  *        (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;),
 519  *   &lt;li&gt; The digits {@code &#39;0&#39;} through {@code &#39;9&#39;}
 520  *        (&lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u0039&#39;&lt;/code&gt;),
 521  * &lt;/ul&gt;
 522  *
 523  * &lt;p&gt; A {@code named-capturing group} is still numbered as described in
 524  * &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
 525  *
 526  * &lt;p&gt; The captured input associated with a group is always the subsequence
 527  * that the group most recently matched.  If a group is evaluated a second time
 528  * because of quantification then its previously-captured value, if any, will
 529  * be retained if the second evaluation fails.  Matching the string
 530  * {@code &quot;aba&quot;} against the expression {@code (a(b)?)+}, for example, leaves
 531  * group two set to {@code &quot;b&quot;}.  All captured input is discarded at the
 532  * beginning of each match.
 533  *
 534  * &lt;p&gt; Groups beginning with {@code (?} are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
 535  * that do not capture text and do not count towards the group total, or
 536  * &lt;i&gt;named-capturing&lt;/i&gt; group.
 537  *
 538  * &lt;h2&gt; Unicode support &lt;/h2&gt;
 539  *
 540  * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
 541  * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 542  * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
 543  * Canonical Equivalents and RL2.2 Extended Grapheme Clusters.
 544  * &lt;p&gt;
 545  * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;code&gt;&amp;#92;u2014&lt;/code&gt; in Java source code
 546  * are processed as described in section 3.3 of
 547  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 548  * Such escape sequences are also implemented directly by the regular-expression
 549  * parser so that Unicode escapes can be used in expressions that are read from
 550  * files or from the keyboard.  Thus the strings &lt;code&gt;&quot;&amp;#92;u2014&quot;&lt;/code&gt; and
 551  * {@code &quot;\\u2014&quot;}, while not equal, compile into the same pattern, which
 552  * matches the character with hexadecimal value {@code 0x2014}.
 553  * &lt;p&gt;
 554  * A Unicode character can also be represented by using its &lt;b&gt;Hex notation&lt;/b&gt;
 555  * (hexadecimal code point value) directly as described in construct
 556  * &lt;code&gt;&amp;#92;x{...}&lt;/code&gt;, for example a supplementary character U+2011F can be
 557  * specified as &lt;code&gt;&amp;#92;x{2011F}&lt;/code&gt;, instead of two consecutive Unicode escape
 558  * sequences of the surrogate pair &lt;code&gt;&amp;#92;uD840&lt;/code&gt;&lt;code&gt;&amp;#92;uDD1F&lt;/code&gt;.
 559  * &lt;p&gt;
 560  * &lt;b&gt;Unicode character names&lt;/b&gt; are supported by the named character construct
 561  * &lt;code&gt;\N{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt;, for example, &lt;code&gt;\N{WHITE SMILING FACE}&lt;/code&gt;
 562  * specifies character &lt;code&gt;&amp;#92;u263A&lt;/code&gt;. The character names supported
 563  * by this class are the valid Unicode character names matched by
 564  * {@link java.lang.Character#codePointOf(String) Character.codePointOf(name)}.
 565  * &lt;p&gt;
 566  * &lt;a href=&quot;http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters&quot;&gt;
 567  * &lt;b&gt;Unicode extended grapheme clusters&lt;/b&gt;&lt;/a&gt; are supported by the grapheme
 568  * cluster matcher {@code \X} and the corresponding boundary matcher {@code \b{g}}.
 569  * &lt;p&gt;
 570  * Unicode scripts, blocks, categories and binary properties are written with
 571  * the {@code \p} and {@code \P} constructs as in Perl.
 572  * &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; matches if
 573  * the input has the property &lt;i&gt;prop&lt;/i&gt;, while &lt;code&gt;\P{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt;
 574  * does not match if the input has that property.
 575  * &lt;p&gt;
 576  * Scripts, blocks, categories and binary properties can be used both inside
 577  * and outside of a character class.
 578  *
 579  * &lt;p&gt;
 580  * &lt;b&gt;&lt;a id=&quot;usc&quot;&gt;Scripts&lt;/a&gt;&lt;/b&gt; are specified either with the prefix {@code Is}, as in
 581  * {@code IsHiragana}, or by using  the {@code script} keyword (or its short
 582  * form {@code sc}) as in {@code script=Hiragana} or {@code sc=Hiragana}.
 583  * &lt;p&gt;
 584  * The script names supported by {@code Pattern} are the valid script names
 585  * accepted and defined by
 586  * {@link java.lang.Character.UnicodeScript#forName(String) UnicodeScript.forName}.
 587  *
 588  * &lt;p&gt;
 589  * &lt;b&gt;&lt;a id=&quot;ubc&quot;&gt;Blocks&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code In}, as in
 590  * {@code InMongolian}, or by using the keyword {@code block} (or its short
 591  * form {@code blk}) as in {@code block=Mongolian} or {@code blk=Mongolian}.
 592  * &lt;p&gt;
 593  * The block names supported by {@code Pattern} are the valid block names
 594  * accepted and defined by
 595  * {@link java.lang.Character.UnicodeBlock#forName(String) UnicodeBlock.forName}.
 596  * &lt;p&gt;
 597  *
 598  * &lt;b&gt;&lt;a id=&quot;ucc&quot;&gt;Categories&lt;/a&gt;&lt;/b&gt; may be specified with the optional prefix {@code Is}:
 599  * Both {@code \p{L}} and {@code \p{IsL}} denote the category of Unicode
 600  * letters. Same as scripts and blocks, categories can also be specified
 601  * by using the keyword {@code general_category} (or its short form
 602  * {@code gc}) as in {@code general_category=Lu} or {@code gc=Lu}.
 603  * &lt;p&gt;
 604  * The supported categories are those of
 605  * &lt;a href=&quot;http://www.unicode.org/unicode/standard/standard.html&quot;&gt;
 606  * &lt;i&gt;The Unicode Standard&lt;/i&gt;&lt;/a&gt; in the version specified by the
 607  * {@link java.lang.Character Character} class. The category names are those
 608  * defined in the Standard, both normative and informative.
 609  * &lt;p&gt;
 610  *
 611  * &lt;b&gt;&lt;a id=&quot;ubpc&quot;&gt;Binary properties&lt;/a&gt;&lt;/b&gt; are specified with the prefix {@code Is}, as in
 612  * {@code IsAlphabetic}. The supported binary properties by {@code Pattern}
 613  * are
 614  * &lt;ul&gt;
 615  *   &lt;li&gt; Alphabetic
 616  *   &lt;li&gt; Ideographic
 617  *   &lt;li&gt; Letter
 618  *   &lt;li&gt; Lowercase
 619  *   &lt;li&gt; Uppercase
 620  *   &lt;li&gt; Titlecase
 621  *   &lt;li&gt; Punctuation
 622  *   &lt;Li&gt; Control
 623  *   &lt;li&gt; White_Space
 624  *   &lt;li&gt; Digit
 625  *   &lt;li&gt; Hex_Digit
 626  *   &lt;li&gt; Join_Control
 627  *   &lt;li&gt; Noncharacter_Code_Point
 628  *   &lt;li&gt; Assigned
 629  * &lt;/ul&gt;
 630  * &lt;p&gt;
 631  * The following &lt;b&gt;Predefined Character classes&lt;/b&gt; and &lt;b&gt;POSIX character classes&lt;/b&gt;
 632  * are in conformance with the recommendation of &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;
 633  * of &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Regular Expression
 634  * &lt;/i&gt;&lt;/a&gt;, when {@link #UNICODE_CHARACTER_CLASS} flag is specified.
 635  *
 636  * &lt;table class=&quot;striped&quot;&gt;
 637  * &lt;caption style=&quot;display:none&quot;&gt;predefined and posix character classes in Unicode mode&lt;/caption&gt;
 638  * &lt;thead&gt;
 639  * &lt;tr&gt;
 640  * &lt;th scope=&quot;col&quot; id=&quot;predef_classes&quot;&gt;Classes&lt;/th&gt;
 641  * &lt;th scope=&quot;col&quot; id=&quot;predef_matches&quot;&gt;Matches&lt;/th&gt;
 642  * &lt;/tr&gt;
 643  * &lt;/thead&gt;
 644  * &lt;tbody&gt;
 645  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Lower}}&lt;/th&gt;
 646  *     &lt;td&gt;A lowercase character:{@code \p{IsLowercase}}&lt;/td&gt;&lt;/tr&gt;
 647  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Upper}}&lt;/th&gt;
 648  *     &lt;td&gt;An uppercase character:{@code \p{IsUppercase}}&lt;/td&gt;&lt;/tr&gt;
 649  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{ASCII}}&lt;/th&gt;
 650  *     &lt;td&gt;All ASCII:{@code [\x00-\x7F]}&lt;/td&gt;&lt;/tr&gt;
 651  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Alpha}}&lt;/th&gt;
 652  *     &lt;td&gt;An alphabetic character:{@code \p{IsAlphabetic}}&lt;/td&gt;&lt;/tr&gt;
 653  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Digit}}&lt;/th&gt;
 654  *     &lt;td&gt;A decimal digit character:{@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 655  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Alnum}}&lt;/th&gt;
 656  *     &lt;td&gt;An alphanumeric character:{@code [\p{IsAlphabetic}\p{IsDigit}]}&lt;/td&gt;&lt;/tr&gt;
 657  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Punct}}&lt;/th&gt;
 658  *     &lt;td&gt;A punctuation character:{@code \p{IsPunctuation}}&lt;/td&gt;&lt;/tr&gt;
 659  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Graph}}&lt;/th&gt;
 660  *     &lt;td&gt;A visible character: {@code [^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]}&lt;/td&gt;&lt;/tr&gt;
 661  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Print}}&lt;/th&gt;
 662  *     &lt;td&gt;A printable character: {@code [\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]}&lt;/td&gt;&lt;/tr&gt;
 663  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Blank}}&lt;/th&gt;
 664  *     &lt;td&gt;A space or a tab: {@code [\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]}&lt;/td&gt;&lt;/tr&gt;
 665  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Cntrl}}&lt;/th&gt;
 666  *     &lt;td&gt;A control character: {@code \p{gc=Cc}}&lt;/td&gt;&lt;/tr&gt;
 667  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{XDigit}}&lt;/th&gt;
 668  *     &lt;td&gt;A hexadecimal digit: {@code [\p{gc=Nd}\p{IsHex_Digit}]}&lt;/td&gt;&lt;/tr&gt;
 669  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \p{Space}}&lt;/th&gt;
 670  *     &lt;td&gt;A whitespace character:{@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 671  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \d}&lt;/th&gt;
 672  *     &lt;td&gt;A digit: {@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 673  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \D}&lt;/th&gt;
 674  *     &lt;td&gt;A non-digit: {@code [^\d]}&lt;/td&gt;&lt;/tr&gt;
 675  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \s}&lt;/th&gt;
 676  *     &lt;td&gt;A whitespace character: {@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 677  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \S}&lt;/th&gt;
 678  *     &lt;td&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 679  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \w}&lt;/th&gt;
 680  *     &lt;td&gt;A word character: {@code [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]}&lt;/td&gt;&lt;/tr&gt;
 681  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \W}&lt;/th&gt;
 682  *     &lt;td&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 683  * &lt;/tbody&gt;
 684  * &lt;/table&gt;
 685  * &lt;p&gt;
 686  * &lt;a id=&quot;jcc&quot;&gt;
 687  * Categories that behave like the java.lang.Character
 688  * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
 689  * available through the same &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; syntax where
 690  * the specified property has the name &lt;code&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/code&gt;&lt;/a&gt;.
 691  *
 692  * &lt;h2&gt; Comparison to Perl 5 &lt;/h2&gt;
 693  *
 694  * &lt;p&gt;The {@code Pattern} engine performs traditional NFA-based matching
 695  * with ordered alternation as occurs in Perl 5.
 696  *
 697  * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
 698  *
 699  * &lt;ul&gt;
 700  *    &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 701  *    the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
 702  *    &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 703  *    &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
 704  *    &lt;/p&gt;&lt;/li&gt;
 705  *
 706  *    &lt;li&gt;&lt;p&gt; The conditional constructs
 707  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code )} and
 708  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;{@code )},
 709  *    &lt;/p&gt;&lt;/li&gt;
 710  *
 711  *    &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;code&gt;(?{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;
 712  *    and &lt;code&gt;(??{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
 713  *
 714  *    &lt;li&gt;&lt;p&gt; The embedded comment syntax {@code (?#comment)}, and &lt;/p&gt;&lt;/li&gt;
 715  *
 716  *    &lt;li&gt;&lt;p&gt; The preprocessing operations {@code \l} &lt;code&gt;&amp;#92;u&lt;/code&gt;,
 717  *    {@code \L}, and {@code \U}.  &lt;/p&gt;&lt;/li&gt;
 718  *
 719  * &lt;/ul&gt;
 720  *
 721  * &lt;p&gt; Constructs supported by this class but not by Perl: &lt;/p&gt;
 722  *
 723  * &lt;ul&gt;
 724  *
 725  *    &lt;li&gt;&lt;p&gt; Character-class union and intersection as described
 726  *    &lt;a href=&quot;#cc&quot;&gt;above&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 727  *
 728  * &lt;/ul&gt;
 729  *
 730  * &lt;p&gt; Notable differences from Perl: &lt;/p&gt;
 731  *
 732  * &lt;ul&gt;
 733  *
 734  *    &lt;li&gt;&lt;p&gt; In Perl, {@code \1} through {@code \9} are always interpreted
 735  *    as back references; a backslash-escaped number greater than {@code 9} is
 736  *    treated as a back reference if at least that many subexpressions exist,
 737  *    otherwise it is interpreted, if possible, as an octal escape.  In this
 738  *    class octal escapes must always begin with a zero. In this class,
 739  *    {@code \1} through {@code \9} are always interpreted as back
 740  *    references, and a larger number is accepted as a back reference if at
 741  *    least that many subexpressions exist at that point in the regular
 742  *    expression, otherwise the parser will drop digits until the number is
 743  *    smaller or equal to the existing number of groups or it is one digit.
 744  *    &lt;/p&gt;&lt;/li&gt;
 745  *
 746  *    &lt;li&gt;&lt;p&gt; Perl uses the {@code g} flag to request a match that resumes
 747  *    where the last match left off.  This functionality is provided implicitly
 748  *    by the {@link Matcher} class: Repeated invocations of the {@link
 749  *    Matcher#find find} method will resume where the last match left off,
 750  *    unless the matcher is reset.  &lt;/p&gt;&lt;/li&gt;
 751  *
 752  *    &lt;li&gt;&lt;p&gt; In Perl, embedded flags at the top level of an expression affect
 753  *    the whole expression.  In this class, embedded flags always take effect
 754  *    at the point at which they appear, whether they are at the top level or
 755  *    within a group; in the latter case, flags are restored at the end of the
 756  *    group just as in Perl.  &lt;/p&gt;&lt;/li&gt;
 757  *
 758  * &lt;/ul&gt;
 759  *
 760  *
 761  * &lt;p&gt; For a more precise description of the behavior of regular expression
 762  * constructs, please see &lt;a href=&quot;http://www.oreilly.com/catalog/regex3/&quot;&gt;
 763  * &lt;i&gt;Mastering Regular Expressions, 3rd Edition&lt;/i&gt;, Jeffrey E. F. Friedl,
 764  * O&#39;Reilly and Associates, 2006.&lt;/a&gt;
 765  * &lt;/p&gt;
 766  *
 767  * @see java.lang.String#split(String, int)
 768  * @see java.lang.String#split(String)
 769  *
 770  * @author      Mike McCloskey
 771  * @author      Mark Reinhold
 772  * @author      JSR-51 Expert Group
 773  * @since       1.4
 774  * @spec        JSR-51
 775  */
 776 
 777 public final class Pattern
 778     implements java.io.Serializable
 779 {
 780 
 781     /*
 782      * Regular expression modifier values.  Instead of being passed as
 783      * arguments, they can also be passed as inline modifiers.
 784      * For example, the following statements have the same effect.
 785      *
 786      *   Pattern p1 = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE|Pattern.MULTILINE);
 787      *   Pattern p2 = Pattern.compile(&quot;(?im)abc&quot;, 0);
 788      */
 789 
 790     /**
 791      * Enables Unix lines mode.
 792      *
 793      * &lt;p&gt; In this mode, only the {@code &#39;\n&#39;} line terminator is recognized
 794      * in the behavior of {@code .}, {@code ^}, and {@code $}.
 795      *
 796      * &lt;p&gt; Unix lines mode can also be enabled via the embedded flag
 797      * expression&amp;nbsp;{@code (?d)}.
 798      */
 799     public static final int UNIX_LINES = 0x01;
 800 
 801     /**
 802      * Enables case-insensitive matching.
 803      *
 804      * &lt;p&gt; By default, case-insensitive matching assumes that only characters
 805      * in the US-ASCII charset are being matched.  Unicode-aware
 806      * case-insensitive matching can be enabled by specifying the {@link
 807      * #UNICODE_CASE} flag in conjunction with this flag.
 808      *
 809      * &lt;p&gt; Case-insensitive matching can also be enabled via the embedded flag
 810      * expression&amp;nbsp;{@code (?i)}.
 811      *
 812      * &lt;p&gt; Specifying this flag may impose a slight performance penalty.  &lt;/p&gt;
 813      */
 814     public static final int CASE_INSENSITIVE = 0x02;
 815 
 816     /**
 817      * Permits whitespace and comments in pattern.
 818      *
 819      * &lt;p&gt; In this mode, whitespace is ignored, and embedded comments starting
 820      * with {@code #} are ignored until the end of a line.
 821      *
 822      * &lt;p&gt; Comments mode can also be enabled via the embedded flag
 823      * expression&amp;nbsp;{@code (?x)}.
 824      */
 825     public static final int COMMENTS = 0x04;
 826 
 827     /**
 828      * Enables multiline mode.
 829      *
 830      * &lt;p&gt; In multiline mode the expressions {@code ^} and {@code $} match
 831      * just after or just before, respectively, a line terminator or the end of
 832      * the input sequence.  By default these expressions only match at the
 833      * beginning and the end of the entire input sequence.
 834      *
 835      * &lt;p&gt; Multiline mode can also be enabled via the embedded flag
 836      * expression&amp;nbsp;{@code (?m)}.  &lt;/p&gt;
 837      */
 838     public static final int MULTILINE = 0x08;
 839 
 840     /**
 841      * Enables literal parsing of the pattern.
 842      *
 843      * &lt;p&gt; When this flag is specified then the input string that specifies
 844      * the pattern is treated as a sequence of literal characters.
 845      * Metacharacters or escape sequences in the input sequence will be
 846      * given no special meaning.
 847      *
 848      * &lt;p&gt;The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on
 849      * matching when used in conjunction with this flag. The other flags
 850      * become superfluous.
 851      *
 852      * &lt;p&gt; There is no embedded flag character for enabling literal parsing.
 853      * @since 1.5
 854      */
 855     public static final int LITERAL = 0x10;
 856 
 857     /**
 858      * Enables dotall mode.
 859      *
 860      * &lt;p&gt; In dotall mode, the expression {@code .} matches any character,
 861      * including a line terminator.  By default this expression does not match
 862      * line terminators.
 863      *
 864      * &lt;p&gt; Dotall mode can also be enabled via the embedded flag
 865      * expression&amp;nbsp;{@code (?s)}.  (The {@code s} is a mnemonic for
 866      * &quot;single-line&quot; mode, which is what this is called in Perl.)  &lt;/p&gt;
 867      */
 868     public static final int DOTALL = 0x20;
 869 
 870     /**
 871      * Enables Unicode-aware case folding.
 872      *
 873      * &lt;p&gt; When this flag is specified then case-insensitive matching, when
 874      * enabled by the {@link #CASE_INSENSITIVE} flag, is done in a manner
 875      * consistent with the Unicode Standard.  By default, case-insensitive
 876      * matching assumes that only characters in the US-ASCII charset are being
 877      * matched.
 878      *
 879      * &lt;p&gt; Unicode-aware case folding can also be enabled via the embedded flag
 880      * expression&amp;nbsp;{@code (?u)}.
 881      *
 882      * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 883      */
 884     public static final int UNICODE_CASE = 0x40;
 885 
 886     /**
 887      * Enables canonical equivalence.
 888      *
 889      * &lt;p&gt; When this flag is specified then two characters will be considered
 890      * to match if, and only if, their full canonical decompositions match.
 891      * The expression &lt;code&gt;&quot;a&amp;#92;u030A&quot;&lt;/code&gt;, for example, will match the
 892      * string &lt;code&gt;&quot;&amp;#92;u00E5&quot;&lt;/code&gt; when this flag is specified.  By default,
 893      * matching does not take canonical equivalence into account.
 894      *
 895      * &lt;p&gt; There is no embedded flag character for enabling canonical
 896      * equivalence.
 897      *
 898      * &lt;p&gt; Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 899      */
 900     public static final int CANON_EQ = 0x80;
 901 
 902     /**
 903      * Enables the Unicode version of &lt;i&gt;Predefined character classes&lt;/i&gt; and
 904      * &lt;i&gt;POSIX character classes&lt;/i&gt;.
 905      *
 906      * &lt;p&gt; When this flag is specified then the (US-ASCII only)
 907      * &lt;i&gt;Predefined character classes&lt;/i&gt; and &lt;i&gt;POSIX character classes&lt;/i&gt;
 908      * are in conformance with
 909      * &lt;a href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 910      * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;
 911      * &lt;i&gt;Annex C: Compatibility Properties&lt;/i&gt;.
 912      * &lt;p&gt;
 913      * The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded
 914      * flag expression&amp;nbsp;{@code (?U)}.
 915      * &lt;p&gt;
 916      * The flag implies UNICODE_CASE, that is, it enables Unicode-aware case
 917      * folding.
 918      * &lt;p&gt;
 919      * Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 920      * @since 1.7
 921      */
 922     public static final int UNICODE_CHARACTER_CLASS = 0x100;
 923 
 924     /**
 925      * Contains all possible flags for compile(regex, flags).
 926      */
 927     private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |
 928             DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |
 929             UNICODE_CHARACTER_CLASS | COMMENTS;
 930 
 931     /* Pattern has only two serialized components: The pattern string
 932      * and the flags, which are all that is needed to recompile the pattern
 933      * when it is deserialized.
 934      */
 935 
 936     /** use serialVersionUID from Merlin b59 for interoperability */
 937     @java.io.Serial
 938     private static final long serialVersionUID = 5073258162644648461L;
 939 
 940     /**
 941      * The original regular-expression pattern string.
 942      *
 943      * @serial
 944      */
 945     private String pattern;
 946 
 947     /**
 948      * The original pattern flags.
 949      *
 950      * @serial
 951      */
 952     private int flags;
 953 
 954     /**
 955      * The temporary pattern flags used during compiling. The flags might be turn
 956      * on and off by embedded flag.
 957      */
 958     private transient int flags0;
 959 
 960     /**
 961      * Boolean indicating this Pattern is compiled; this is necessary in order
 962      * to lazily compile deserialized Patterns.
 963      */
 964     private transient volatile boolean compiled;
 965 
 966     /**
 967      * The normalized pattern string.
 968      */
 969     private transient String normalizedPattern;
 970 
 971     /**
 972      * The starting point of state machine for the find operation.  This allows
 973      * a match to start anywhere in the input.
 974      */
 975     transient Node root;
 976 
 977     /**
 978      * The root of object tree for a match operation.  The pattern is matched
 979      * at the beginning.  This may include a find that uses BnM or a First
 980      * node.
 981      */
 982     transient Node matchRoot;
 983 
 984     /**
 985      * Temporary storage used by parsing pattern slice.
 986      */
 987     transient int[] buffer;
 988 
 989     /**
 990      * A temporary storage used for predicate for double return.
 991      */
 992     transient CharPredicate predicate;
 993 
 994     /**
 995      * Map the &quot;name&quot; of the &quot;named capturing group&quot; to its group id
 996      * node.
 997      */
 998     transient volatile Map&lt;String, Integer&gt; namedGroups;
 999 
1000     /**
1001      * Temporary storage used while parsing group references.
1002      */
1003     transient GroupHead[] groupNodes;
1004 
1005     /**
1006      * Temporary storage used to store the top level closure nodes.
1007      */
1008     transient List&lt;Node&gt; topClosureNodes;
1009 
1010     /**
1011      * The number of top greedy closure nodes in this Pattern. Used by
1012      * matchers to allocate storage needed for a IntHashSet to keep the
1013      * beginning pos {@code i} of all failed match.
1014      */
1015     transient int localTCNCount;
1016 
1017     /*
1018      * Turn off the stop-exponential-backtracking optimization if there
1019      * is a group ref in the pattern.
1020      */
1021     transient boolean hasGroupRef;
1022 
1023     /**
1024      * Temporary null terminated code point array used by pattern compiling.
1025      */
1026     private transient int[] temp;
1027 
1028     /**
1029      * The number of capturing groups in this Pattern. Used by matchers to
1030      * allocate storage needed to perform a match.
1031      */
1032     transient int capturingGroupCount;
1033 
1034     /**
1035      * The local variable count used by parsing tree. Used by matchers to
1036      * allocate storage needed to perform a match.
1037      */
1038     transient int localCount;
1039 
1040     /**
1041      * Index into the pattern string that keeps track of how much has been
1042      * parsed.
1043      */
1044     private transient int cursor;
1045 
1046     /**
1047      * Holds the length of the pattern string.
1048      */
1049     private transient int patternLength;
1050 
1051     /**
1052      * If the Start node might possibly match supplementary characters.
1053      * It is set to true during compiling if
1054      * (1) There is supplementary char in pattern, or
1055      * (2) There is complement node of a &quot;family&quot; CharProperty
1056      */
1057     private transient boolean hasSupplementary;
1058 
1059     /**
1060      * Compiles the given regular expression into a pattern.
1061      *
1062      * @param  regex
1063      *         The expression to be compiled
1064      * @return the given regular expression compiled into a pattern
1065      * @throws  PatternSyntaxException
1066      *          If the expression&#39;s syntax is invalid
1067      */
1068     public static Pattern compile(String regex) {
1069         return new Pattern(regex, 0);
1070     }
1071 
1072     /**
1073      * Compiles the given regular expression into a pattern with the given
1074      * flags.
1075      *
1076      * @param  regex
1077      *         The expression to be compiled
1078      *
1079      * @param  flags
1080      *         Match flags, a bit mask that may include
1081      *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},
1082      *         {@link #UNICODE_CASE}, {@link #CANON_EQ}, {@link #UNIX_LINES},
1083      *         {@link #LITERAL}, {@link #UNICODE_CHARACTER_CLASS}
1084      *         and {@link #COMMENTS}
1085      *
1086      * @return the given regular expression compiled into a pattern with the given flags
1087      * @throws  IllegalArgumentException
1088      *          If bit values other than those corresponding to the defined
1089      *          match flags are set in {@code flags}
1090      *
1091      * @throws  PatternSyntaxException
1092      *          If the expression&#39;s syntax is invalid
1093      */
1094     public static Pattern compile(String regex, int flags) {
1095         return new Pattern(regex, flags);
1096     }
1097 
1098     /**
1099      * Returns the regular expression from which this pattern was compiled.
1100      *
1101      * @return  The source of this pattern
1102      */
1103     public String pattern() {
1104         return pattern;
1105     }
1106 
1107     /**
1108      * &lt;p&gt;Returns the string representation of this pattern. This
1109      * is the regular expression from which this pattern was
1110      * compiled.&lt;/p&gt;
1111      *
1112      * @return  The string representation of this pattern
1113      * @since 1.5
1114      */
1115     public String toString() {
1116         return pattern;
1117     }
1118 
1119     /**
1120      * Creates a matcher that will match the given input against this pattern.
1121      *
1122      * @param  input
1123      *         The character sequence to be matched
1124      *
1125      * @return  A new matcher for this pattern
1126      */
1127     public Matcher matcher(CharSequence input) {
1128         if (!compiled) {
1129             synchronized(this) {
1130                 if (!compiled)
1131                     compile();
1132             }
1133         }
1134         Matcher m = new Matcher(this, input);
1135         return m;
1136     }
1137 
1138     /**
1139      * Returns this pattern&#39;s match flags.
1140      *
1141      * @return  The match flags specified when this pattern was compiled
1142      */
1143     public int flags() {
1144         return flags0;
1145     }
1146 
1147     /**
1148      * Compiles the given regular expression and attempts to match the given
1149      * input against it.
1150      *
1151      * &lt;p&gt; An invocation of this convenience method of the form
1152      *
1153      * &lt;blockquote&gt;&lt;pre&gt;
1154      * Pattern.matches(regex, input);&lt;/pre&gt;&lt;/blockquote&gt;
1155      *
1156      * behaves in exactly the same way as the expression
1157      *
1158      * &lt;blockquote&gt;&lt;pre&gt;
1159      * Pattern.compile(regex).matcher(input).matches()&lt;/pre&gt;&lt;/blockquote&gt;
1160      *
1161      * &lt;p&gt; If a pattern is to be used multiple times, compiling it once and reusing
1162      * it will be more efficient than invoking this method each time.  &lt;/p&gt;
1163      *
1164      * @param  regex
1165      *         The expression to be compiled
1166      *
1167      * @param  input
1168      *         The character sequence to be matched
1169      * @return whether or not the regular expression matches on the input
1170      * @throws  PatternSyntaxException
1171      *          If the expression&#39;s syntax is invalid
1172      */
1173     public static boolean matches(String regex, CharSequence input) {
1174         Pattern p = Pattern.compile(regex);
1175         Matcher m = p.matcher(input);
1176         return m.matches();
1177     }
1178 
1179     /**
1180      * Splits the given input sequence around matches of this pattern.
1181      *
1182      * &lt;p&gt; The array returned by this method contains each substring of the
1183      * input sequence that is terminated by another subsequence that matches
1184      * this pattern or is terminated by the end of the input sequence.  The
1185      * substrings in the array are in the order in which they occur in the
1186      * input. If this pattern does not match any subsequence of the input then
1187      * the resulting array has just one element, namely the input sequence in
1188      * string form.
1189      *
1190      * &lt;p&gt; When there is a positive-width match at the beginning of the input
1191      * sequence then an empty leading substring is included at the beginning
1192      * of the resulting array. A zero-width match at the beginning however
1193      * never produces such empty leading substring.
1194      *
1195      * &lt;p&gt; The {@code limit} parameter controls the number of times the
1196      * pattern is applied and therefore affects the length of the resulting
1197      * array.
1198      * &lt;ul&gt;
1199      *    &lt;li&gt;&lt;p&gt;
1200      *    If the &lt;i&gt;limit&lt;/i&gt; is positive then the pattern will be applied
1201      *    at most &lt;i&gt;limit&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1 times, the array&#39;s length will be
1202      *    no greater than &lt;i&gt;limit&lt;/i&gt;, and the array&#39;s last entry will contain
1203      *    all input beyond the last matched delimiter.&lt;/p&gt;&lt;/li&gt;
1204      *
1205      *    &lt;li&gt;&lt;p&gt;
1206      *    If the &lt;i&gt;limit&lt;/i&gt; is zero then the pattern will be applied as
1207      *    many times as possible, the array can have any length, and trailing
1208      *    empty strings will be discarded.&lt;/p&gt;&lt;/li&gt;
1209      *
1210      *    &lt;li&gt;&lt;p&gt;
1211      *    If the &lt;i&gt;limit&lt;/i&gt; is negative then the pattern will be applied
1212      *    as many times as possible and the array can have any length.&lt;/p&gt;&lt;/li&gt;
1213      * &lt;/ul&gt;
1214      *
1215      * &lt;p&gt; The input {@code &quot;boo:and:foo&quot;}, for example, yields the following
1216      * results with these parameters:
1217      *
1218      * &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em;&quot;&gt;
1219      * &lt;caption style=&quot;display:none&quot;&gt;Split example showing regex, limit, and result&lt;/caption&gt;
1220      * &lt;thead&gt;
1221      * &lt;tr&gt;
1222      *     &lt;th scope=&quot;col&quot;&gt;Regex&lt;/th&gt;
1223      *     &lt;th scope=&quot;col&quot;&gt;Limit&lt;/th&gt;
1224      *     &lt;th scope=&quot;col&quot;&gt;Result&lt;/th&gt;
1225      * &lt;/tr&gt;
1226      * &lt;/thead&gt;
1227      * &lt;tbody&gt;
1228      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;:&lt;/th&gt;
1229      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;2&lt;/th&gt;
1230      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and:foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1231      * &lt;tr&gt;&lt;!-- : --&gt;
1232      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
1233      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1234      * &lt;tr&gt;&lt;!-- : --&gt;
1235      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
1236      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1237      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;o&lt;/th&gt;
1238      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
1239      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
1240      * &lt;tr&gt;&lt;!-- o --&gt;
1241      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
1242      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
1243      * &lt;tr&gt;&lt;!-- o --&gt;
1244      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;0&lt;/th&gt;
1245      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
1246      * &lt;/tbody&gt;
1247      * &lt;/table&gt;
1248      *
1249      * @param  input
1250      *         The character sequence to be split
1251      *
1252      * @param  limit
1253      *         The result threshold, as described above
1254      *
1255      * @return  The array of strings computed by splitting the input
1256      *          around matches of this pattern
1257      */
1258     public String[] split(CharSequence input, int limit) {
1259         int index = 0;
1260         boolean matchLimited = limit &gt; 0;
1261         ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
1262         Matcher m = matcher(input);
1263 
1264         // Add segments before each match found
1265         while(m.find()) {
1266             if (!matchLimited || matchList.size() &lt; limit - 1) {
1267                 if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {
1268                     // no empty leading substring included for zero-width match
1269                     // at the beginning of the input char sequence.
1270                     continue;
1271                 }
1272                 String match = input.subSequence(index, m.start()).toString();
1273                 matchList.add(match);
1274                 index = m.end();
1275             } else if (matchList.size() == limit - 1) { // last one
1276                 String match = input.subSequence(index,
1277                                                  input.length()).toString();
1278                 matchList.add(match);
1279                 index = m.end();
1280             }
1281         }
1282 
1283         // If no match was found, return this
1284         if (index == 0)
1285             return new String[] {input.toString()};
1286 
1287         // Add remaining segment
1288         if (!matchLimited || matchList.size() &lt; limit)
1289             matchList.add(input.subSequence(index, input.length()).toString());
1290 
1291         // Construct result
1292         int resultSize = matchList.size();
1293         if (limit == 0)
1294             while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).isEmpty())
1295                 resultSize--;
1296         String[] result = new String[resultSize];
1297         return matchList.subList(0, resultSize).toArray(result);
1298     }
1299 
1300     /**
1301      * Splits the given input sequence around matches of this pattern.
1302      *
1303      * &lt;p&gt; This method works as if by invoking the two-argument {@link
1304      * #split(java.lang.CharSequence, int) split} method with the given input
1305      * sequence and a limit argument of zero.  Trailing empty strings are
1306      * therefore not included in the resulting array. &lt;/p&gt;
1307      *
1308      * &lt;p&gt; The input {@code &quot;boo:and:foo&quot;}, for example, yields the following
1309      * results with these expressions:
1310      *
1311      * &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em&quot;&gt;
1312      * &lt;caption style=&quot;display:none&quot;&gt;Split examples showing regex and result&lt;/caption&gt;
1313      * &lt;thead&gt;
1314      * &lt;tr&gt;
1315      *  &lt;th scope=&quot;col&quot;&gt;Regex&lt;/th&gt;
1316      *  &lt;th scope=&quot;col&quot;&gt;Result&lt;/th&gt;
1317      * &lt;/tr&gt;
1318      * &lt;/thead&gt;
1319      * &lt;tbody&gt;
1320      * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;text-weight:normal&quot;&gt;:&lt;/th&gt;
1321      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
1322      * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;text-weight:normal&quot;&gt;o&lt;/th&gt;
1323      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
1324      * &lt;/tbody&gt;
1325      * &lt;/table&gt;
1326      *
1327      *
1328      * @param  input
1329      *         The character sequence to be split
1330      *
1331      * @return  The array of strings computed by splitting the input
1332      *          around matches of this pattern
1333      */
1334     public String[] split(CharSequence input) {
1335         return split(input, 0);
1336     }
1337 
1338     /**
1339      * Returns a literal pattern {@code String} for the specified
1340      * {@code String}.
1341      *
1342      * &lt;p&gt;This method produces a {@code String} that can be used to
1343      * create a {@code Pattern} that would match the string
1344      * {@code s} as if it were a literal pattern.&lt;/p&gt; Metacharacters
1345      * or escape sequences in the input sequence will be given no special
1346      * meaning.
1347      *
1348      * @param  s The string to be literalized
1349      * @return  A literal string replacement
1350      * @since 1.5
1351      */
1352     public static String quote(String s) {
1353         int slashEIndex = s.indexOf(&quot;\\E&quot;);
1354         if (slashEIndex == -1)
1355             return &quot;\\Q&quot; + s + &quot;\\E&quot;;
1356 
1357         int lenHint = s.length();
1358         lenHint = (lenHint &lt; Integer.MAX_VALUE - 8 - lenHint) ?
1359                 (lenHint &lt;&lt; 1) : (Integer.MAX_VALUE - 8);
1360 
1361         StringBuilder sb = new StringBuilder(lenHint);
1362         sb.append(&quot;\\Q&quot;);
1363         int current = 0;
1364         do {
1365             sb.append(s, current, slashEIndex)
1366                     .append(&quot;\\E\\\\E\\Q&quot;);
1367             current = slashEIndex + 2;
1368         } while ((slashEIndex = s.indexOf(&quot;\\E&quot;, current)) != -1);
1369 
1370         return sb.append(s, current, s.length())
1371                 .append(&quot;\\E&quot;)
1372                 .toString();
1373     }
1374 
1375     /**
1376      * Recompile the Pattern instance from a stream.  The original pattern
1377      * string is read in and the object tree is recompiled from it.
1378      */
1379     @java.io.Serial
1380     private void readObject(java.io.ObjectInputStream s)
1381         throws java.io.IOException, ClassNotFoundException {
1382 
1383         // Read in all fields
1384         s.defaultReadObject();
1385 
1386         // reset the flags
1387         flags0 = flags;
1388 
1389         // Initialize counts
1390         capturingGroupCount = 1;
1391         localCount = 0;
1392         localTCNCount = 0;
1393 
1394         // if length &gt; 0, the Pattern is lazily compiled
1395         if (pattern.isEmpty()) {
1396             root = new Start(lastAccept);
1397             matchRoot = lastAccept;
1398             compiled = true;
1399         }
1400     }
1401 
1402     /**
1403      * This private constructor is used to create all Patterns. The pattern
1404      * string and match flags are all that is needed to completely describe
1405      * a Pattern. An empty pattern string results in an object tree with
1406      * only a Start node and a LastNode node.
1407      */
1408     private Pattern(String p, int f) {
1409         if ((f &amp; ~ALL_FLAGS) != 0) {
1410             throw new IllegalArgumentException(&quot;Unknown flag 0x&quot;
1411                                                + Integer.toHexString(f));
1412         }
1413         pattern = p;
1414         flags = f;
1415 
1416         // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
1417         if ((flags &amp; UNICODE_CHARACTER_CLASS) != 0)
1418             flags |= UNICODE_CASE;
1419 
1420         // &#39;flags&#39; for compiling
1421         flags0 = flags;
1422 
1423         // Reset group index count
1424         capturingGroupCount = 1;
1425         localCount = 0;
1426         localTCNCount = 0;
1427 
1428         if (!pattern.isEmpty()) {
1429             try {
1430                 compile();
1431             } catch (StackOverflowError soe) {
1432                 throw error(&quot;Stack overflow during pattern compilation&quot;);
1433             }
1434         } else {
1435             root = new Start(lastAccept);
1436             matchRoot = lastAccept;
1437         }
1438     }
1439 
1440     /**
1441      * The pattern is converted to normalized form ({@link
1442      * java.text.Normalizer.Form#NFC NFC}, canonical decomposition,
1443      * followed by canonical composition for the character class
1444      * part, and {@link java.text.Normalizer.Form#NFD NFD},
1445      * canonical decomposition for the rest), and then a pure
1446      * group is constructed to match canonical equivalences of the
1447      * characters.
1448      */
1449     private static String normalize(String pattern) {
1450         int plen = pattern.length();
1451         StringBuilder pbuf = new StringBuilder(plen);
1452         char last = 0;
1453         int lastStart = 0;
1454         char cc = 0;
1455         for (int i = 0; i &lt; plen;) {
1456             char c = pattern.charAt(i);
1457             if (cc == 0 &amp;&amp;    // top level
1458                 c == &#39;\\&#39; &amp;&amp; i + 1 &lt; plen &amp;&amp; pattern.charAt(i + 1) == &#39;\\&#39;) {
1459                 i += 2; last = 0;
1460                 continue;
1461             }
1462             if (c == &#39;[&#39; &amp;&amp; last != &#39;\\&#39;) {
1463                 if (cc == 0) {
1464                     if (lastStart &lt; i)
1465                         normalizeSlice(pattern, lastStart, i, pbuf);
1466                     lastStart = i;
1467                 }
1468                 cc++;
1469             } else if (c == &#39;]&#39; &amp;&amp; last != &#39;\\&#39;) {
1470                 cc--;
1471                 if (cc == 0) {
1472                     normalizeClazz(pattern, lastStart, i + 1, pbuf);
1473                     lastStart = i + 1;
1474                 }
1475             }
1476             last = c;
1477             i++;
1478         }
1479         assert (cc == 0);
1480         if (lastStart &lt; plen)
1481             normalizeSlice(pattern, lastStart, plen, pbuf);
1482         return pbuf.toString();
1483     }
1484 
1485     private static void normalizeSlice(String src, int off, int limit,
1486                                        StringBuilder dst)
1487     {
1488         int len = src.length();
1489         int off0 = off;
1490         while (off &lt; limit &amp;&amp; ASCII.isAscii(src.charAt(off))) {
1491             off++;
1492         }
1493         if (off == limit) {
1494             dst.append(src, off0, limit);
1495             return;
1496         }
1497         off--;
1498         if (off &lt; off0)
1499             off = off0;
1500         else
1501             dst.append(src, off0, off);
1502         while (off &lt; limit) {
1503             int ch0 = src.codePointAt(off);
1504             if (&quot;.$|()[]{}^?*+\\&quot;.indexOf(ch0) != -1) {
1505                 dst.append((char)ch0);
1506                 off++;
1507                 continue;
1508             }
1509             int j = Grapheme.nextBoundary(src, off, limit);
1510             int ch1;
1511             String seq = src.substring(off, j);
1512             String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
1513             off = j;
1514             if (nfd.codePointCount(0, nfd.length()) &gt; 1) {
1515                 ch0 = nfd.codePointAt(0);
1516                 ch1 = nfd.codePointAt(Character.charCount(ch0));
1517                 if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
1518                     Set&lt;String&gt; altns = new LinkedHashSet&lt;&gt;();
1519                     altns.add(seq);
1520                     produceEquivalentAlternation(nfd, altns);
1521                     dst.append(&quot;(?:&quot;);
1522                     altns.forEach( s -&gt; dst.append(s).append(&#39;|&#39;));
1523                     dst.delete(dst.length() - 1, dst.length());
1524                     dst.append(&quot;)&quot;);
1525                     continue;
1526                 }
1527             }
1528             String nfc = Normalizer.normalize(seq, Normalizer.Form.NFC);
1529             if (!seq.equals(nfc) &amp;&amp; !nfd.equals(nfc))
1530                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd  + &quot;|&quot; + nfc + &quot;)&quot;);
1531             else if (!seq.equals(nfd))
1532                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd + &quot;)&quot;);
1533             else
1534                 dst.append(seq);
1535         }
1536     }
1537 
1538     private static void normalizeClazz(String src, int off, int limit,
1539                                        StringBuilder dst)
1540     {
1541         dst.append(Normalizer.normalize(src.substring(off, limit), Form.NFC));
1542     }
1543 
1544     /**
1545      * Given a specific sequence composed of a regular character and
1546      * combining marks that follow it, produce the alternation that will
1547      * match all canonical equivalences of that sequence.
1548      */
1549     private static void produceEquivalentAlternation(String src,
1550                                                      Set&lt;String&gt; dst)
1551     {
1552         int len = countChars(src, 0, 1);
1553         if (src.length() == len) {
1554             dst.add(src);  // source has one character.
1555             return;
1556         }
1557         String base = src.substring(0,len);
1558         String combiningMarks = src.substring(len);
1559         String[] perms = producePermutations(combiningMarks);
1560         // Add combined permutations
1561         for(int x = 0; x &lt; perms.length; x++) {
1562             String next = base + perms[x];
1563             dst.add(next);
1564             next = composeOneStep(next);
1565             if (next != null) {
1566                 produceEquivalentAlternation(next, dst);
1567             }
1568         }
1569     }
1570 
1571     /**
1572      * Returns an array of strings that have all the possible
1573      * permutations of the characters in the input string.
1574      * This is used to get a list of all possible orderings
1575      * of a set of combining marks. Note that some of the permutations
1576      * are invalid because of combining class collisions, and these
1577      * possibilities must be removed because they are not canonically
1578      * equivalent.
1579      */
1580     private static String[] producePermutations(String input) {
1581         if (input.length() == countChars(input, 0, 1))
1582             return new String[] {input};
1583 
1584         if (input.length() == countChars(input, 0, 2)) {
1585             int c0 = Character.codePointAt(input, 0);
1586             int c1 = Character.codePointAt(input, Character.charCount(c0));
1587             if (getClass(c1) == getClass(c0)) {
1588                 return new String[] {input};
1589             }
1590             String[] result = new String[2];
1591             result[0] = input;
1592             StringBuilder sb = new StringBuilder(2);
1593             sb.appendCodePoint(c1);
1594             sb.appendCodePoint(c0);
1595             result[1] = sb.toString();
1596             return result;
1597         }
1598 
1599         int length = 1;
1600         int nCodePoints = countCodePoints(input);
1601         for(int x=1; x&lt;nCodePoints; x++)
1602             length = length * (x+1);
1603 
1604         String[] temp = new String[length];
1605 
1606         int combClass[] = new int[nCodePoints];
1607         for(int x=0, i=0; x&lt;nCodePoints; x++) {
1608             int c = Character.codePointAt(input, i);
1609             combClass[x] = getClass(c);
1610             i +=  Character.charCount(c);
1611         }
1612 
1613         // For each char, take it out and add the permutations
1614         // of the remaining chars
1615         int index = 0;
1616         int len;
1617         // offset maintains the index in code units.
1618 loop:   for(int x=0, offset=0; x&lt;nCodePoints; x++, offset+=len) {
1619             len = countChars(input, offset, 1);
1620             for(int y=x-1; y&gt;=0; y--) {
1621                 if (combClass[y] == combClass[x]) {
1622                     continue loop;
1623                 }
1624             }
1625             StringBuilder sb = new StringBuilder(input);
1626             String otherChars = sb.delete(offset, offset+len).toString();
1627             String[] subResult = producePermutations(otherChars);
1628 
1629             String prefix = input.substring(offset, offset+len);
1630             for (String sre : subResult)
1631                 temp[index++] = prefix + sre;
1632         }
1633         String[] result = new String[index];
1634         System.arraycopy(temp, 0, result, 0, index);
1635         return result;
1636     }
1637 
1638     private static int getClass(int c) {
1639         return sun.text.Normalizer.getCombiningClass(c);
1640     }
1641 
1642     /**
1643      * Attempts to compose input by combining the first character
1644      * with the first combining mark following it. Returns a String
1645      * that is the composition of the leading character with its first
1646      * combining mark followed by the remaining combining marks. Returns
1647      * null if the first two characters cannot be further composed.
1648      */
1649     private static String composeOneStep(String input) {
1650         int len = countChars(input, 0, 2);
1651         String firstTwoCharacters = input.substring(0, len);
1652         String result = Normalizer.normalize(firstTwoCharacters, Normalizer.Form.NFC);
1653         if (result.equals(firstTwoCharacters))
1654             return null;
1655         else {
1656             String remainder = input.substring(len);
1657             return result + remainder;
1658         }
1659     }
1660 
1661     /**
1662      * Preprocess any \Q...\E sequences in `temp&#39;, meta-quoting them.
1663      * See the description of `quotemeta&#39; in perlfunc(1).
1664      */
1665     private void RemoveQEQuoting() {
1666         final int pLen = patternLength;
1667         int i = 0;
1668         while (i &lt; pLen-1) {
1669             if (temp[i] != &#39;\\&#39;)
1670                 i += 1;
1671             else if (temp[i + 1] != &#39;Q&#39;)
1672                 i += 2;
1673             else
1674                 break;
1675         }
1676         if (i &gt;= pLen - 1)    // No \Q sequence found
1677             return;
1678         int j = i;
1679         i += 2;
1680         int newTempLen;
1681         try {
1682             newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));
1683         } catch (ArithmeticException ae) {
1684             throw new OutOfMemoryError();
1685         }
1686         int[] newtemp = new int[newTempLen];
1687         System.arraycopy(temp, 0, newtemp, 0, j);
1688 
1689         boolean inQuote = true;
1690         boolean beginQuote = true;
1691         while (i &lt; pLen) {
1692             int c = temp[i++];
1693             if (!ASCII.isAscii(c) || ASCII.isAlpha(c)) {
1694                 newtemp[j++] = c;
1695             } else if (ASCII.isDigit(c)) {
1696                 if (beginQuote) {
1697                     /*
1698                      * A unicode escape \[0xu] could be before this quote,
1699                      * and we don&#39;t want this numeric char to processed as
1700                      * part of the escape.
1701                      */
1702                     newtemp[j++] = &#39;\\&#39;;
1703                     newtemp[j++] = &#39;x&#39;;
1704                     newtemp[j++] = &#39;3&#39;;
1705                 }
1706                 newtemp[j++] = c;
1707             } else if (c != &#39;\\&#39;) {
1708                 if (inQuote) newtemp[j++] = &#39;\\&#39;;
1709                 newtemp[j++] = c;
1710             } else if (inQuote) {
1711                 if (temp[i] == &#39;E&#39;) {
1712                     i++;
1713                     inQuote = false;
1714                 } else {
1715                     newtemp[j++] = &#39;\\&#39;;
1716                     newtemp[j++] = &#39;\\&#39;;
1717                 }
1718             } else {
1719                 if (temp[i] == &#39;Q&#39;) {
1720                     i++;
1721                     inQuote = true;
1722                     beginQuote = true;
1723                     continue;
1724                 } else {
1725                     newtemp[j++] = c;
1726                     if (i != pLen)
1727                         newtemp[j++] = temp[i++];
1728                 }
1729             }
1730 
1731             beginQuote = false;
1732         }
1733 
1734         patternLength = j;
1735         temp = Arrays.copyOf(newtemp, j + 2); // double zero termination
1736     }
1737 
1738     /**
1739      * Copies regular expression to an int array and invokes the parsing
1740      * of the expression which will create the object tree.
1741      */
1742     private void compile() {
1743         // Handle canonical equivalences
1744         if (has(CANON_EQ) &amp;&amp; !has(LITERAL)) {
1745             normalizedPattern = normalize(pattern);
1746         } else {
1747             normalizedPattern = pattern;
1748         }
1749         patternLength = normalizedPattern.length();
1750 
1751         // Copy pattern to int array for convenience
1752         // Use double zero to terminate pattern
1753         temp = new int[patternLength + 2];
1754 
1755         hasSupplementary = false;
1756         int c, count = 0;
1757         // Convert all chars into code points
1758         for (int x = 0; x &lt; patternLength; x += Character.charCount(c)) {
1759             c = normalizedPattern.codePointAt(x);
1760             if (isSupplementary(c)) {
1761                 hasSupplementary = true;
1762             }
1763             temp[count++] = c;
1764         }
1765 
1766         patternLength = count;   // patternLength now in code points
1767 
1768         if (! has(LITERAL))
1769             RemoveQEQuoting();
1770 
1771         // Allocate all temporary objects here.
1772         buffer = new int[32];
1773         groupNodes = new GroupHead[10];
1774         namedGroups = null;
1775         topClosureNodes = new ArrayList&lt;&gt;(10);
1776 
1777         if (has(LITERAL)) {
1778             // Literal pattern handling
1779             matchRoot = newSlice(temp, patternLength, hasSupplementary);
1780             matchRoot.next = lastAccept;
1781         } else {
1782             // Start recursive descent parsing
1783             matchRoot = expr(lastAccept);
1784             // Check extra pattern characters
1785             if (patternLength != cursor) {
1786                 if (peek() == &#39;)&#39;) {
1787                     throw error(&quot;Unmatched closing &#39;)&#39;&quot;);
1788                 } else {
1789                     throw error(&quot;Unexpected internal error&quot;);
1790                 }
1791             }
1792         }
1793 
1794         // Peephole optimization
1795         if (matchRoot instanceof Slice) {
1796             root = BnM.optimize(matchRoot);
1797             if (root == matchRoot) {
1798                 root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
1799             }
1800         } else if (matchRoot instanceof Begin || matchRoot instanceof First) {
1801             root = matchRoot;
1802         } else {
1803             root = hasSupplementary ? new StartS(matchRoot) : new Start(matchRoot);
1804         }
1805 
1806         // Optimize the greedy Loop to prevent exponential backtracking, IF there
1807         // is no group ref in this pattern. With a non-negative localTCNCount value,
1808         // the greedy type Loop, Curly will skip the backtracking for any starting
1809         // position &quot;i&quot; that failed in the past.
1810         if (!hasGroupRef) {
1811             for (Node node : topClosureNodes) {
1812                 if (node instanceof Loop) {
1813                     // non-deterministic-greedy-group
1814                     ((Loop)node).posIndex = localTCNCount++;
1815                 }
1816             }
1817         }
1818 
1819         // Release temporary storage
1820         temp = null;
1821         buffer = null;
1822         groupNodes = null;
1823         patternLength = 0;
1824         compiled = true;
1825         topClosureNodes = null;
1826     }
1827 
1828     Map&lt;String, Integer&gt; namedGroups() {
1829         Map&lt;String, Integer&gt; groups = namedGroups;
1830         if (groups == null) {
1831             namedGroups = groups = new HashMap&lt;&gt;(2);
1832         }
1833         return groups;
1834     }
1835 
1836     /**
1837      * Used to accumulate information about a subtree of the object graph
1838      * so that optimizations can be applied to the subtree.
1839      */
1840     static final class TreeInfo {
1841         int minLength;
1842         int maxLength;
1843         boolean maxValid;
1844         boolean deterministic;
1845 
1846         TreeInfo() {
1847             reset();
1848         }
1849         void reset() {
1850             minLength = 0;
1851             maxLength = 0;
1852             maxValid = true;
1853             deterministic = true;
1854         }
1855     }
1856 
1857     /*
1858      * The following private methods are mainly used to improve the
1859      * readability of the code. In order to let the Java compiler easily
1860      * inline them, we should not put many assertions or error checks in them.
1861      */
1862 
1863     /**
1864      * Indicates whether a particular flag is set or not.
1865      */
1866     private boolean has(int f) {
1867         return (flags0 &amp; f) != 0;
1868     }
1869 
1870     /**
1871      * Match next character, signal error if failed.
1872      */
1873     private void accept(int ch, String s) {
1874         int testChar = temp[cursor++];
1875         if (has(COMMENTS))
1876             testChar = parsePastWhitespace(testChar);
1877         if (ch != testChar) {
1878             throw error(s);
1879         }
1880     }
1881 
1882     /**
1883      * Mark the end of pattern with a specific character.
1884      */
1885     private void mark(int c) {
1886         temp[patternLength] = c;
1887     }
1888 
1889     /**
1890      * Peek the next character, and do not advance the cursor.
1891      */
1892     private int peek() {
1893         int ch = temp[cursor];
1894         if (has(COMMENTS))
1895             ch = peekPastWhitespace(ch);
1896         return ch;
1897     }
1898 
1899     /**
1900      * Read the next character, and advance the cursor by one.
1901      */
1902     private int read() {
1903         int ch = temp[cursor++];
1904         if (has(COMMENTS))
1905             ch = parsePastWhitespace(ch);
1906         return ch;
1907     }
1908 
1909     /**
1910      * Read the next character, and advance the cursor by one,
1911      * ignoring the COMMENTS setting
1912      */
1913     private int readEscaped() {
1914         int ch = temp[cursor++];
1915         return ch;
1916     }
1917 
1918     /**
1919      * Advance the cursor by one, and peek the next character.
1920      */
1921     private int next() {
1922         int ch = temp[++cursor];
1923         if (has(COMMENTS))
1924             ch = peekPastWhitespace(ch);
1925         return ch;
1926     }
1927 
1928     /**
1929      * Advance the cursor by one, and peek the next character,
1930      * ignoring the COMMENTS setting
1931      */
1932     private int nextEscaped() {
1933         int ch = temp[++cursor];
1934         return ch;
1935     }
1936 
1937     /**
1938      * If in xmode peek past whitespace and comments.
1939      */
1940     private int peekPastWhitespace(int ch) {
1941         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1942             while (ASCII.isSpace(ch))
1943                 ch = temp[++cursor];
1944             if (ch == &#39;#&#39;) {
1945                 ch = peekPastLine();
1946             }
1947         }
1948         return ch;
1949     }
1950 
1951     /**
1952      * If in xmode parse past whitespace and comments.
1953      */
1954     private int parsePastWhitespace(int ch) {
1955         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1956             while (ASCII.isSpace(ch))
1957                 ch = temp[cursor++];
1958             if (ch == &#39;#&#39;)
1959                 ch = parsePastLine();
1960         }
1961         return ch;
1962     }
1963 
1964     /**
1965      * xmode parse past comment to end of line.
1966      */
1967     private int parsePastLine() {
1968         int ch = temp[cursor++];
1969         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1970             ch = temp[cursor++];
1971         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {
1972             cursor = patternLength;
1973             ch = temp[cursor++];
1974         }
1975         return ch;
1976     }
1977 
1978     /**
1979      * xmode peek past comment to end of line.
1980      */
1981     private int peekPastLine() {
1982         int ch = temp[++cursor];
1983         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1984             ch = temp[++cursor];
1985         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {
1986             cursor = patternLength;
1987             ch = temp[cursor];
1988         }
1989         return ch;
1990     }
1991 
1992     /**
1993      * Determines if character is a line separator in the current mode
1994      */
1995     private boolean isLineSeparator(int ch) {
1996         if (has(UNIX_LINES)) {
1997             return ch == &#39;\n&#39;;
1998         } else {
1999             return (ch == &#39;\n&#39; ||
2000                     ch == &#39;\r&#39; ||
2001                     (ch|1) == &#39;\u2029&#39; ||
2002                     ch == &#39;\u0085&#39;);
2003         }
2004     }
2005 
2006     /**
2007      * Read the character after the next one, and advance the cursor by two.
2008      */
2009     private int skip() {
2010         int i = cursor;
2011         int ch = temp[i+1];
2012         cursor = i + 2;
2013         return ch;
2014     }
2015 
2016     /**
2017      * Unread one next character, and retreat cursor by one.
2018      */
2019     private void unread() {
2020         cursor--;
2021     }
2022 
2023     /**
2024      * Internal method used for handling all syntax errors. The pattern is
2025      * displayed with a pointer to aid in locating the syntax error.
2026      */
2027     private PatternSyntaxException error(String s) {
2028         return new PatternSyntaxException(s, normalizedPattern,  cursor - 1);
2029     }
2030 
2031     /**
2032      * Determines if there is any supplementary character or unpaired
2033      * surrogate in the specified range.
2034      */
2035     private boolean findSupplementary(int start, int end) {
2036         for (int i = start; i &lt; end; i++) {
2037             if (isSupplementary(temp[i]))
2038                 return true;
2039         }
2040         return false;
2041     }
2042 
2043     /**
2044      * Determines if the specified code point is a supplementary
2045      * character or unpaired surrogate.
2046      */
2047     private static final boolean isSupplementary(int ch) {
2048         return ch &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT ||
2049                Character.isSurrogate((char)ch);
2050     }
2051 
2052     /**
2053      *  The following methods handle the main parsing. They are sorted
2054      *  according to their precedence order, the lowest one first.
2055      */
2056 
2057     /**
2058      * The expression is parsed with branch nodes added for alternations.
2059      * This may be called recursively to parse sub expressions that may
2060      * contain alternations.
2061      */
2062     private Node expr(Node end) {
2063         Node prev = null;
2064         Node firstTail = null;
2065         Branch branch = null;
2066         BranchConn branchConn = null;
2067 
2068         for (;;) {
2069             Node node = sequence(end);
2070             Node nodeTail = root;      //double return
2071             if (prev == null) {
2072                 prev = node;
2073                 firstTail = nodeTail;
2074             } else {
2075                 // Branch
2076                 if (branchConn == null) {
2077                     branchConn = new BranchConn();
2078                     branchConn.next = end;
2079                 }
2080                 if (node == end) {
2081                     // if the node returned from sequence() is &quot;end&quot;
2082                     // we have an empty expr, set a null atom into
2083                     // the branch to indicate to go &quot;next&quot; directly.
2084                     node = null;
2085                 } else {
2086                     // the &quot;tail.next&quot; of each atom goes to branchConn
2087                     nodeTail.next = branchConn;
2088                 }
2089                 if (prev == branch) {
2090                     branch.add(node);
2091                 } else {
2092                     if (prev == end) {
2093                         prev = null;
2094                     } else {
2095                         // replace the &quot;end&quot; with &quot;branchConn&quot; at its tail.next
2096                         // when put the &quot;prev&quot; into the branch as the first atom.
2097                         firstTail.next = branchConn;
2098                     }
2099                     prev = branch = new Branch(prev, node, branchConn);
2100                 }
2101             }
2102             if (peek() != &#39;|&#39;) {
2103                 return prev;
2104             }
2105             next();
2106         }
2107     }
2108 
2109     @SuppressWarnings(&quot;fallthrough&quot;)
2110     /**
2111      * Parsing of sequences between alternations.
2112      */
2113     private Node sequence(Node end) {
2114         Node head = null;
2115         Node tail = null;
2116         Node node;
2117     LOOP:
2118         for (;;) {
2119             int ch = peek();
2120             switch (ch) {
2121             case &#39;(&#39;:
2122                 // Because group handles its own closure,
2123                 // we need to treat it differently
2124                 node = group0();
2125                 // Check for comment or flag group
2126                 if (node == null)
2127                     continue;
2128                 if (head == null)
2129                     head = node;
2130                 else
2131                     tail.next = node;
2132                 // Double return: Tail was returned in root
2133                 tail = root;
2134                 continue;
2135             case &#39;[&#39;:
2136                 if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2137                     node = new NFCCharProperty(clazz(true));
2138                 else
2139                     node = newCharProperty(clazz(true));
2140                 break;
2141             case &#39;\\&#39;:
2142                 ch = nextEscaped();
2143                 if (ch == &#39;p&#39; || ch == &#39;P&#39;) {
2144                     boolean oneLetter = true;
2145                     boolean comp = (ch == &#39;P&#39;);
2146                     ch = next(); // Consume { if present
2147                     if (ch != &#39;{&#39;) {
2148                         unread();
2149                     } else {
2150                         oneLetter = false;
2151                     }
2152                     // node = newCharProperty(family(oneLetter, comp));
2153                     if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2154                         node = new NFCCharProperty(family(oneLetter, comp));
2155                     else
2156                         node = newCharProperty(family(oneLetter, comp));
2157                 } else {
2158                     unread();
2159                     node = atom();
2160                 }
2161                 break;
2162             case &#39;^&#39;:
2163                 next();
2164                 if (has(MULTILINE)) {
2165                     if (has(UNIX_LINES))
2166                         node = new UnixCaret();
2167                     else
2168                         node = new Caret();
2169                 } else {
2170                     node = new Begin();
2171                 }
2172                 break;
2173             case &#39;$&#39;:
2174                 next();
2175                 if (has(UNIX_LINES))
2176                     node = new UnixDollar(has(MULTILINE));
2177                 else
2178                     node = new Dollar(has(MULTILINE));
2179                 break;
2180             case &#39;.&#39;:
2181                 next();
2182                 if (has(DOTALL)) {
2183                     node = new CharProperty(ALL());
2184                 } else {
2185                     if (has(UNIX_LINES)) {
2186                         node = new CharProperty(UNIXDOT());
2187                     } else {
2188                         node = new CharProperty(DOT());
2189                     }
2190                 }
2191                 break;
2192             case &#39;|&#39;:
2193             case &#39;)&#39;:
2194                 break LOOP;
2195             case &#39;]&#39;: // Now interpreting dangling ] and } as literals
2196             case &#39;}&#39;:
2197                 node = atom();
2198                 break;
2199             case &#39;?&#39;:
2200             case &#39;*&#39;:
2201             case &#39;+&#39;:
2202                 next();
2203                 throw error(&quot;Dangling meta character &#39;&quot; + ((char)ch) + &quot;&#39;&quot;);
2204             case 0:
2205                 if (cursor &gt;= patternLength) {
2206                     break LOOP;
2207                 }
2208                 // Fall through
2209             default:
2210                 node = atom();
2211                 break;
2212             }
2213 
2214             if (node instanceof LineEnding) {
2215                 LineEnding le = (LineEnding)node;
2216                 node = closureOfLineEnding(le);
2217 
2218                 if (node != le) {
2219                     // LineEnding was replaced with an anonymous group
2220                     if (head == null)
2221                         head = node;
2222                     else
2223                         tail.next = node;
2224                     // Double return: Tail was returned in root
2225                     tail = root;
2226                     continue;
2227                 }
2228             } else {
2229                 node = closure(node);
2230             }
2231 
2232             /* save the top dot-greedy nodes (.*, .+) as well
2233             if (node instanceof GreedyCharProperty &amp;&amp;
2234                 ((GreedyCharProperty)node).cp instanceof Dot) {
2235                 topClosureNodes.add(node);
2236             }
2237             */
2238             if (head == null) {
2239                 head = tail = node;
2240             } else {
2241                 tail.next = node;
2242                 tail = node;
2243             }
2244         }
2245         if (head == null) {
2246             return end;
2247         }
2248         tail.next = end;
2249         root = tail;      //double return
2250         return head;
2251     }
2252 
2253     @SuppressWarnings(&quot;fallthrough&quot;)
2254     /**
2255      * Parse and add a new Single or Slice.
2256      */
2257     private Node atom() {
2258         int first = 0;
2259         int prev = -1;
2260         boolean hasSupplementary = false;
2261         int ch = peek();
2262         for (;;) {
2263             switch (ch) {
2264             case &#39;*&#39;:
2265             case &#39;+&#39;:
2266             case &#39;?&#39;:
2267             case &#39;{&#39;:
2268                 if (first &gt; 1) {
2269                     cursor = prev;    // Unwind one character
2270                     first--;
2271                 }
2272                 break;
2273             case &#39;$&#39;:
2274             case &#39;.&#39;:
2275             case &#39;^&#39;:
2276             case &#39;(&#39;:
2277             case &#39;[&#39;:
2278             case &#39;|&#39;:
2279             case &#39;)&#39;:
2280                 break;
2281             case &#39;\\&#39;:
2282                 ch = nextEscaped();
2283                 if (ch == &#39;p&#39; || ch == &#39;P&#39;) { // Property
2284                     if (first &gt; 0) { // Slice is waiting; handle it first
2285                         unread();
2286                         break;
2287                     } else { // No slice; just return the family node
2288                         boolean comp = (ch == &#39;P&#39;);
2289                         boolean oneLetter = true;
2290                         ch = next(); // Consume { if present
2291                         if (ch != &#39;{&#39;)
2292                             unread();
2293                         else
2294                             oneLetter = false;
2295                         if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
2296                             return new NFCCharProperty(family(oneLetter, comp));
2297                         else
2298                             return newCharProperty(family(oneLetter, comp));
2299                     }
2300                 }
2301                 unread();
2302                 prev = cursor;
2303                 ch = escape(false, first == 0, false);
2304                 if (ch &gt;= 0) {
2305                     append(ch, first);
2306                     first++;
2307                     if (isSupplementary(ch)) {
2308                         hasSupplementary = true;
2309                     }
2310                     ch = peek();
2311                     continue;
2312                 } else if (first == 0) {
2313                     return root;
2314                 }
2315                 // Unwind meta escape sequence
2316                 cursor = prev;
2317                 break;
2318             case 0:
2319                 if (cursor &gt;= patternLength) {
2320                     break;
2321                 }
2322                 // Fall through
2323             default:
2324                 prev = cursor;
2325                 append(ch, first);
2326                 first++;
2327                 if (isSupplementary(ch)) {
2328                     hasSupplementary = true;
2329                 }
2330                 ch = next();
2331                 continue;
2332             }
2333             break;
2334         }
2335         if (first == 1) {
2336             return newCharProperty(single(buffer[0]));
2337         } else {
2338             return newSlice(buffer, first, hasSupplementary);
2339         }
2340     }
2341 
2342     private void append(int ch, int index) {
2343         int len = buffer.length;
2344         if (index - len &gt;= 0) {
2345             len = ArraysSupport.newLength(len,
2346                     1 + index - len, /* minimum growth */
2347                     len              /* preferred growth */);
2348             buffer = Arrays.copyOf(buffer, len);
2349         }
2350         buffer[index] = ch;
2351     }
2352 
2353     /**
2354      * Parses a backref greedily, taking as many numbers as it
2355      * can. The first digit is always treated as a backref, but
2356      * multi digit numbers are only treated as a backref if at
2357      * least that many backrefs exist at this point in the regex.
2358      */
2359     private Node ref(int refNum) {
2360         boolean done = false;
2361         while(!done) {
2362             int ch = peek();
2363             switch(ch) {
2364             case &#39;0&#39;:
2365             case &#39;1&#39;:
2366             case &#39;2&#39;:
2367             case &#39;3&#39;:
2368             case &#39;4&#39;:
2369             case &#39;5&#39;:
2370             case &#39;6&#39;:
2371             case &#39;7&#39;:
2372             case &#39;8&#39;:
2373             case &#39;9&#39;:
2374                 int newRefNum = (refNum * 10) + (ch - &#39;0&#39;);
2375                 // Add another number if it doesn&#39;t make a group
2376                 // that doesn&#39;t exist
2377                 if (capturingGroupCount - 1 &lt; newRefNum) {
2378                     done = true;
2379                     break;
2380                 }
2381                 refNum = newRefNum;
2382                 read();
2383                 break;
2384             default:
2385                 done = true;
2386                 break;
2387             }
2388         }
2389         hasGroupRef = true;
2390         if (has(CASE_INSENSITIVE))
2391             return new CIBackRef(refNum, has(UNICODE_CASE));
2392         else
2393             return new BackRef(refNum);
2394     }
2395 
2396     /**
2397      * Parses an escape sequence to determine the actual value that needs
2398      * to be matched.
2399      * If -1 is returned and create was true a new object was added to the tree
2400      * to handle the escape sequence.
2401      * If the returned value is greater than zero, it is the value that
2402      * matches the escape sequence.
2403      */
2404     private int escape(boolean inclass, boolean create, boolean isrange) {
2405         int ch = skip();
2406         switch (ch) {
2407         case &#39;0&#39;:
2408             return o();
2409         case &#39;1&#39;:
2410         case &#39;2&#39;:
2411         case &#39;3&#39;:
2412         case &#39;4&#39;:
2413         case &#39;5&#39;:
2414         case &#39;6&#39;:
2415         case &#39;7&#39;:
2416         case &#39;8&#39;:
2417         case &#39;9&#39;:
2418             if (inclass) break;
2419             if (create) {
2420                 root = ref((ch - &#39;0&#39;));
2421             }
2422             return -1;
2423         case &#39;A&#39;:
2424             if (inclass) break;
2425             if (create) root = new Begin();
2426             return -1;
2427         case &#39;B&#39;:
2428             if (inclass) break;
2429             if (create) root = new Bound(Bound.NONE, has(UNICODE_CHARACTER_CLASS));
2430             return -1;
2431         case &#39;C&#39;:
2432             break;
2433         case &#39;D&#39;:
2434             if (create) {
2435                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2436                             CharPredicates.DIGIT() : CharPredicates.ASCII_DIGIT();
2437                 predicate = predicate.negate();
2438                 if (!inclass)
2439                     root = newCharProperty(predicate);
2440             }
2441             return -1;
2442         case &#39;E&#39;:
2443         case &#39;F&#39;:
2444             break;
2445         case &#39;G&#39;:
2446             if (inclass) break;
2447             if (create) root = new LastMatch();
2448             return -1;
2449         case &#39;H&#39;:
2450             if (create) {
2451                 predicate = HorizWS().negate();
2452                 if (!inclass)
2453                     root = newCharProperty(predicate);
2454             }
2455             return -1;
2456         case &#39;I&#39;:
2457         case &#39;J&#39;:
2458         case &#39;K&#39;:
2459         case &#39;L&#39;:
2460         case &#39;M&#39;:
2461             break;
2462         case &#39;N&#39;:
2463             return N();
2464         case &#39;O&#39;:
2465         case &#39;P&#39;:
2466         case &#39;Q&#39;:
2467             break;
2468         case &#39;R&#39;:
2469             if (inclass) break;
2470             if (create) root = new LineEnding();
2471             return -1;
2472         case &#39;S&#39;:
2473             if (create) {
2474                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2475                             CharPredicates.WHITE_SPACE() : CharPredicates.ASCII_SPACE();
2476                 predicate = predicate.negate();
2477                 if (!inclass)
2478                     root = newCharProperty(predicate);
2479             }
2480             return -1;
2481         case &#39;T&#39;:
2482         case &#39;U&#39;:
2483             break;
2484         case &#39;V&#39;:
2485             if (create) {
2486                 predicate = VertWS().negate();
2487                 if (!inclass)
2488                     root = newCharProperty(predicate);
2489             }
2490             return -1;
2491         case &#39;W&#39;:
2492             if (create) {
2493                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2494                             CharPredicates.WORD() : CharPredicates.ASCII_WORD();
2495                 predicate = predicate.negate();
2496                 if (!inclass)
2497                     root = newCharProperty(predicate);
2498             }
2499             return -1;
2500         case &#39;X&#39;:
2501             if (inclass) break;
2502             if (create) {
2503                 root = new XGrapheme();
2504             }
2505             return -1;
2506         case &#39;Y&#39;:
2507             break;
2508         case &#39;Z&#39;:
2509             if (inclass) break;
2510             if (create) {
2511                 if (has(UNIX_LINES))
2512                     root = new UnixDollar(false);
2513                 else
2514                     root = new Dollar(false);
2515             }
2516             return -1;
2517         case &#39;a&#39;:
2518             return &#39;\007&#39;;
2519         case &#39;b&#39;:
2520             if (inclass) break;
2521             if (create) {
2522                 if (peek() == &#39;{&#39;) {
2523                     if (skip() == &#39;g&#39;) {
2524                         if (read() == &#39;}&#39;) {
2525                             root = new GraphemeBound();
2526                             return -1;
2527                         }
2528                         break;  // error missing trailing }
2529                     }
2530                     unread(); unread();
2531                 }
2532                 root = new Bound(Bound.BOTH, has(UNICODE_CHARACTER_CLASS));
2533             }
2534             return -1;
2535         case &#39;c&#39;:
2536             return c();
2537         case &#39;d&#39;:
2538             if (create) {
2539                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2540                             CharPredicates.DIGIT() : CharPredicates.ASCII_DIGIT();
2541                 if (!inclass)
2542                     root = newCharProperty(predicate);
2543             }
2544             return -1;
2545         case &#39;e&#39;:
2546             return &#39;\033&#39;;
2547         case &#39;f&#39;:
2548             return &#39;\f&#39;;
2549         case &#39;g&#39;:
2550             break;
2551         case &#39;h&#39;:
2552             if (create) {
2553                 predicate = HorizWS();
2554                 if (!inclass)
2555                     root = newCharProperty(predicate);
2556             }
2557             return -1;
2558         case &#39;i&#39;:
2559         case &#39;j&#39;:
2560             break;
2561         case &#39;k&#39;:
2562             if (inclass)
2563                 break;
2564             if (read() != &#39;&lt;&#39;)
2565                 throw error(&quot;\\k is not followed by &#39;&lt;&#39; for named capturing group&quot;);
2566             String name = groupname(read());
2567             if (!namedGroups().containsKey(name))
2568                 throw error(&quot;named capturing group &lt;&quot; + name + &quot;&gt; does not exist&quot;);
2569             if (create) {
2570                 hasGroupRef = true;
2571                 if (has(CASE_INSENSITIVE))
2572                     root = new CIBackRef(namedGroups().get(name), has(UNICODE_CASE));
2573                 else
2574                     root = new BackRef(namedGroups().get(name));
2575             }
2576             return -1;
2577         case &#39;l&#39;:
2578         case &#39;m&#39;:
2579             break;
2580         case &#39;n&#39;:
2581             return &#39;\n&#39;;
2582         case &#39;o&#39;:
2583         case &#39;p&#39;:
2584         case &#39;q&#39;:
2585             break;
2586         case &#39;r&#39;:
2587             return &#39;\r&#39;;
2588         case &#39;s&#39;:
2589             if (create) {
2590                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2591                             CharPredicates.WHITE_SPACE() : CharPredicates.ASCII_SPACE();
2592                 if (!inclass)
2593                     root = newCharProperty(predicate);
2594             }
2595             return -1;
2596         case &#39;t&#39;:
2597             return &#39;\t&#39;;
2598         case &#39;u&#39;:
2599             return u();
2600         case &#39;v&#39;:
2601             // &#39;\v&#39; was implemented as VT/0x0B in releases &lt; 1.8 (though
2602             // undocumented). In JDK8 &#39;\v&#39; is specified as a predefined
2603             // character class for all vertical whitespace characters.
2604             // So [-1, root=VertWS node] pair is returned (instead of a
2605             // single 0x0B). This breaks the range if &#39;\v&#39; is used as
2606             // the start or end value, such as [\v-...] or [...-\v], in
2607             // which a single definite value (0x0B) is expected. For
2608             // compatibility concern &#39;\013&#39;/0x0B is returned if isrange.
2609             if (isrange)
2610                 return &#39;\013&#39;;
2611             if (create) {
2612                 predicate = VertWS();
2613                 if (!inclass)
2614                     root = newCharProperty(predicate);
2615             }
2616             return -1;
2617         case &#39;w&#39;:
2618             if (create) {
2619                 predicate = has(UNICODE_CHARACTER_CLASS) ?
2620                             CharPredicates.WORD() : CharPredicates.ASCII_WORD();
2621                 if (!inclass)
2622                     root = newCharProperty(predicate);
2623             }
2624             return -1;
2625         case &#39;x&#39;:
2626             return x();
2627         case &#39;y&#39;:
2628             break;
2629         case &#39;z&#39;:
2630             if (inclass) break;
2631             if (create) root = new End();
2632             return -1;
2633         default:
2634             return ch;
2635         }
2636         throw error(&quot;Illegal/unsupported escape sequence&quot;);
2637     }
2638 
2639     /**
2640      * Parse a character class, and return the node that matches it.
2641      *
2642      * Consumes a ] on the way out if consume is true. Usually consume
2643      * is true except for the case of [abc&amp;&amp;def] where def is a separate
2644      * right hand node with &quot;understood&quot; brackets.
2645      */
2646     private CharPredicate clazz(boolean consume) {
2647         CharPredicate prev = null;
2648         CharPredicate curr = null;
2649         BitClass bits = new BitClass();
2650 
2651         boolean isNeg = false;
2652         boolean hasBits = false;
2653         int ch = next();
2654 
2655         // Negates if first char in a class, otherwise literal
2656         if (ch == &#39;^&#39; &amp;&amp; temp[cursor-1] == &#39;[&#39;) {
2657             ch = next();
2658             isNeg = true;
2659         }
2660         for (;;) {
2661             switch (ch) {
2662                 case &#39;[&#39;:
2663                     curr = clazz(true);
2664                     if (prev == null)
2665                         prev = curr;
2666                     else
2667                         prev = prev.union(curr);
2668                     ch = peek();
2669                     continue;
2670                 case &#39;&amp;&#39;:
2671                     ch = next();
2672                     if (ch == &#39;&amp;&#39;) {
2673                         ch = next();
2674                         CharPredicate right = null;
2675                         while (ch != &#39;]&#39; &amp;&amp; ch != &#39;&amp;&#39;) {
2676                             if (ch == &#39;[&#39;) {
2677                                 if (right == null)
2678                                     right = clazz(true);
2679                                 else
2680                                     right = right.union(clazz(true));
2681                             } else { // abc&amp;&amp;def
2682                                 unread();
2683                                 right = clazz(false);
2684                             }
2685                             ch = peek();
2686                         }
2687                         if (hasBits) {
2688                             // bits used, union has high precedence
2689                             if (prev == null) {
2690                                 prev = curr = bits;
2691                             } else {
2692                                 prev = prev.union(bits);
2693                             }
2694                             hasBits = false;
2695                         }
2696                         if (right != null)
2697                             curr = right;
2698                         if (prev == null) {
2699                             if (right == null)
2700                                 throw error(&quot;Bad class syntax&quot;);
2701                             else
2702                                 prev = right;
2703                         } else {
2704                             prev = prev.and(curr);
2705                         }
2706                     } else {
2707                         // treat as a literal &amp;
2708                         unread();
2709                         break;
2710                     }
2711                     continue;
2712                 case 0:
2713                     if (cursor &gt;= patternLength)
2714                         throw error(&quot;Unclosed character class&quot;);
2715                     break;
2716                 case &#39;]&#39;:
2717                     if (prev != null || hasBits) {
2718                         if (consume)
2719                             next();
2720                         if (prev == null)
2721                             prev = bits;
2722                         else if (hasBits)
2723                             prev = prev.union(bits);
2724                         if (isNeg)
2725                             return prev.negate();
2726                         return prev;
2727                     }
2728                     break;
2729                 default:
2730                     break;
2731             }
2732             curr = range(bits);
2733             if (curr == null) {    // the bits used
2734                 hasBits = true;
2735             } else {
2736                 if (prev == null)
2737                     prev = curr;
2738                 else if (prev != curr)
2739                     prev = prev.union(curr);
2740             }
2741             ch = peek();
2742         }
2743     }
2744 
2745     private CharPredicate bitsOrSingle(BitClass bits, int ch) {
2746         /* Bits can only handle codepoints in [u+0000-u+00ff] range.
2747            Use &quot;single&quot; node instead of bits when dealing with unicode
2748            case folding for codepoints listed below.
2749            (1)Uppercase out of range: u+00ff, u+00b5
2750               toUpperCase(u+00ff) -&gt; u+0178
2751               toUpperCase(u+00b5) -&gt; u+039c
2752            (2)LatinSmallLetterLongS u+17f
2753               toUpperCase(u+017f) -&gt; u+0053
2754            (3)LatinSmallLetterDotlessI u+131
2755               toUpperCase(u+0131) -&gt; u+0049
2756            (4)LatinCapitalLetterIWithDotAbove u+0130
2757               toLowerCase(u+0130) -&gt; u+0069
2758            (5)KelvinSign u+212a
2759               toLowerCase(u+212a) ==&gt; u+006B
2760            (6)AngstromSign u+212b
2761               toLowerCase(u+212b) ==&gt; u+00e5
2762         */
2763         if (ch &lt; 256 &amp;&amp;
2764             !(has(CASE_INSENSITIVE) &amp;&amp; has(UNICODE_CASE) &amp;&amp;
2765               (ch == 0xff || ch == 0xb5 ||
2766                ch == 0x49 || ch == 0x69 ||    //I and i
2767                ch == 0x53 || ch == 0x73 ||    //S and s
2768                ch == 0x4b || ch == 0x6b ||    //K and k
2769                ch == 0xc5 || ch == 0xe5))) {  //A+ring
2770             bits.add(ch, flags0);
2771             return null;
2772         }
2773         return single(ch);
2774     }
2775 
2776     /**
2777      *  Returns a suitably optimized, single character predicate
2778      */
2779     private CharPredicate single(final int ch) {
2780         if (has(CASE_INSENSITIVE)) {
2781             int lower, upper;
2782             if (has(UNICODE_CASE)) {
2783                 upper = Character.toUpperCase(ch);
2784                 lower = Character.toLowerCase(upper);
2785                 // Unicode case insensitive matches
2786                 if (upper != lower)
2787                     return SingleU(lower);
2788             } else if (ASCII.isAscii(ch)) {
2789                 lower = ASCII.toLower(ch);
2790                 upper = ASCII.toUpper(ch);
2791                 // Case insensitive matches a given BMP character
2792                 if (lower != upper)
2793                     return SingleI(lower, upper);
2794             }
2795         }
2796         if (isSupplementary(ch))
2797             return SingleS(ch);
2798         return Single(ch);  // Match a given BMP character
2799     }
2800 
2801     /**
2802      * Parse a single character or a character range in a character class
2803      * and return its representative node.
2804      */
2805     private CharPredicate range(BitClass bits) {
2806         int ch = peek();
2807         if (ch == &#39;\\&#39;) {
2808             ch = nextEscaped();
2809             if (ch == &#39;p&#39; || ch == &#39;P&#39;) { // A property
2810                 boolean comp = (ch == &#39;P&#39;);
2811                 boolean oneLetter = true;
2812                 // Consume { if present
2813                 ch = next();
2814                 if (ch != &#39;{&#39;)
2815                     unread();
2816                 else
2817                     oneLetter = false;
2818                 return family(oneLetter, comp);
2819             } else { // ordinary escape
2820                 boolean isrange = temp[cursor+1] == &#39;-&#39;;
2821                 unread();
2822                 ch = escape(true, true, isrange);
2823                 if (ch == -1)
2824                     return predicate;
2825             }
2826         } else {
2827             next();
2828         }
2829         if (ch &gt;= 0) {
2830             if (peek() == &#39;-&#39;) {
2831                 int endRange = temp[cursor+1];
2832                 if (endRange == &#39;[&#39;) {
2833                     return bitsOrSingle(bits, ch);
2834                 }
2835                 if (endRange != &#39;]&#39;) {
2836                     next();
2837                     int m = peek();
2838                     if (m == &#39;\\&#39;) {
2839                         m = escape(true, false, true);
2840                     } else {
2841                         next();
2842                     }
2843                     if (m &lt; ch) {
2844                         throw error(&quot;Illegal character range&quot;);
2845                     }
2846                     if (has(CASE_INSENSITIVE)) {
2847                         if (has(UNICODE_CASE))
2848                             return CIRangeU(ch, m);
2849                         return CIRange(ch, m);
2850                     } else {
2851                         return Range(ch, m);
2852                     }
2853                 }
2854             }
2855             return bitsOrSingle(bits, ch);
2856         }
2857         throw error(&quot;Unexpected character &#39;&quot;+((char)ch)+&quot;&#39;&quot;);
2858     }
2859 
2860     /**
2861      * Parses a Unicode character family and returns its representative node.
2862      */
2863     private CharPredicate family(boolean singleLetter, boolean isComplement) {
2864         next();
2865         String name;
2866         CharPredicate p = null;
2867 
2868         if (singleLetter) {
2869             int c = temp[cursor];
2870             if (!Character.isSupplementaryCodePoint(c)) {
2871                 name = String.valueOf((char)c);
2872             } else {
2873                 name = new String(temp, cursor, 1);
2874             }
2875             read();
2876         } else {
2877             int i = cursor;
2878             mark(&#39;}&#39;);
2879             while(read() != &#39;}&#39;) {
2880             }
2881             mark(&#39;\000&#39;);
2882             int j = cursor;
2883             if (j &gt; patternLength)
2884                 throw error(&quot;Unclosed character family&quot;);
2885             if (i + 1 &gt;= j)
2886                 throw error(&quot;Empty character family&quot;);
2887             name = new String(temp, i, j-i-1);
2888         }
2889 
2890         int i = name.indexOf(&#39;=&#39;);
2891         if (i != -1) {
2892             // property construct \p{name=value}
2893             String value = name.substring(i + 1);
2894             name = name.substring(0, i).toLowerCase(Locale.ENGLISH);
2895             switch (name) {
2896                 case &quot;sc&quot;:
2897                 case &quot;script&quot;:
2898                     p = CharPredicates.forUnicodeScript(value);
2899                     break;
2900                 case &quot;blk&quot;:
2901                 case &quot;block&quot;:
2902                     p = CharPredicates.forUnicodeBlock(value);
2903                     break;
2904                 case &quot;gc&quot;:
2905                 case &quot;general_category&quot;:
2906                     p = CharPredicates.forProperty(value, has(CASE_INSENSITIVE));
2907                     break;
2908                 default:
2909                     break;
2910             }
2911             if (p == null)
2912                 throw error(&quot;Unknown Unicode property {name=&lt;&quot; + name + &quot;&gt;, &quot;
2913                              + &quot;value=&lt;&quot; + value + &quot;&gt;}&quot;);
2914 
2915         } else {
2916             if (name.startsWith(&quot;In&quot;)) {
2917                 // \p{InBlockName}
2918                 p = CharPredicates.forUnicodeBlock(name.substring(2));
2919             } else if (name.startsWith(&quot;Is&quot;)) {
2920                 // \p{IsGeneralCategory} and \p{IsScriptName}
2921                 String shortName = name.substring(2);
2922                 p = CharPredicates.forUnicodeProperty(shortName, has(CASE_INSENSITIVE));
2923                 if (p == null)
2924                     p = CharPredicates.forProperty(shortName, has(CASE_INSENSITIVE));
2925                 if (p == null)
2926                     p = CharPredicates.forUnicodeScript(shortName);
2927             } else {
2928                 if (has(UNICODE_CHARACTER_CLASS))
2929                     p = CharPredicates.forPOSIXName(name, has(CASE_INSENSITIVE));
2930                 if (p == null)
2931                     p = CharPredicates.forProperty(name, has(CASE_INSENSITIVE));
2932             }
2933             if (p == null)
2934                 throw error(&quot;Unknown character property name {&quot; + name + &quot;}&quot;);
2935         }
2936         if (isComplement) {
2937             // it might be too expensive to detect if a complement of
2938             // CharProperty can match &quot;certain&quot; supplementary. So just
2939             // go with StartS.
2940             hasSupplementary = true;
2941             p = p.negate();
2942         }
2943         return p;
2944     }
2945 
2946     private CharProperty newCharProperty(CharPredicate p) {
2947         if (p == null)
2948             return null;
2949         if (p instanceof BmpCharPredicate)
2950             return new BmpCharProperty((BmpCharPredicate)p);
2951         else
2952             return new CharProperty(p);
2953     }
2954 
2955     /**
2956      * Parses and returns the name of a &quot;named capturing group&quot;, the trailing
2957      * &quot;&gt;&quot; is consumed after parsing.
2958      */
2959     private String groupname(int ch) {
2960         StringBuilder sb = new StringBuilder();
2961         if (!ASCII.isAlpha(ch))
2962             throw error(&quot;capturing group name does not start with a Latin letter&quot;);
2963         do {
2964             sb.append((char) ch);
2965         } while (ASCII.isAlnum(ch=read()));
2966         if (ch != &#39;&gt;&#39;)
2967             throw error(&quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;);
2968         return sb.toString();
2969     }
2970 
2971     /**
2972      * Parses a group and returns the head node of a set of nodes that process
2973      * the group. Sometimes a double return system is used where the tail is
2974      * returned in root.
2975      */
2976     private Node group0() {
2977         boolean capturingGroup = false;
2978         Node head;
2979         Node tail;
2980         int save = flags0;
2981         int saveTCNCount = topClosureNodes.size();
2982         root = null;
2983         int ch = next();
2984         if (ch == &#39;?&#39;) {
2985             ch = skip();
2986             switch (ch) {
2987             case &#39;:&#39;:   //  (?:xxx) pure group
2988                 head = createGroup(true);
2989                 tail = root;
2990                 head.next = expr(tail);
2991                 break;
2992             case &#39;=&#39;:   // (?=xxx) and (?!xxx) lookahead
2993             case &#39;!&#39;:
2994                 head = createGroup(true);
2995                 tail = root;
2996                 head.next = expr(tail);
2997                 if (ch == &#39;=&#39;) {
2998                     head = tail = new Pos(head);
2999                 } else {
3000                     head = tail = new Neg(head);
3001                 }
3002                 break;
3003             case &#39;&gt;&#39;:   // (?&gt;xxx)  independent group
3004                 head = createGroup(true);
3005                 tail = root;
3006                 head.next = expr(tail);
3007                 head = tail = new Ques(head, Qtype.INDEPENDENT);
3008                 break;
3009             case &#39;&lt;&#39;:   // (?&lt;xxx)  look behind
3010                 ch = read();
3011                 if (ch != &#39;=&#39; &amp;&amp; ch != &#39;!&#39;) {
3012                     // named captured group
3013                     String name = groupname(ch);
3014                     if (namedGroups().containsKey(name))
3015                         throw error(&quot;Named capturing group &lt;&quot; + name
3016                                     + &quot;&gt; is already defined&quot;);
3017                     capturingGroup = true;
3018                     head = createGroup(false);
3019                     tail = root;
3020                     namedGroups().put(name, capturingGroupCount-1);
3021                     head.next = expr(tail);
3022                     break;
3023                 }
3024                 int start = cursor;
3025                 head = createGroup(true);
3026                 tail = root;
3027                 head.next = expr(tail);
3028                 tail.next = LookBehindEndNode.INSTANCE;
3029                 TreeInfo info = new TreeInfo();
3030                 head.study(info);
3031                 if (info.maxValid == false) {
3032                     throw error(&quot;Look-behind group does not have &quot;
3033                                 + &quot;an obvious maximum length&quot;);
3034                 }
3035                 boolean hasSupplementary = findSupplementary(start, patternLength);
3036                 if (ch == &#39;=&#39;) {
3037                     head = tail = (hasSupplementary ?
3038                                    new BehindS(head, info.maxLength,
3039                                                info.minLength) :
3040                                    new Behind(head, info.maxLength,
3041                                               info.minLength));
3042                 } else { // if (ch == &#39;!&#39;)
3043                     head = tail = (hasSupplementary ?
3044                                    new NotBehindS(head, info.maxLength,
3045                                                   info.minLength) :
3046                                    new NotBehind(head, info.maxLength,
3047                                                  info.minLength));
3048                 }
3049                 // clear all top-closure-nodes inside lookbehind
3050                 if (saveTCNCount &lt; topClosureNodes.size())
3051                     topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3052                 break;
3053             case &#39;$&#39;:
3054             case &#39;@&#39;:
3055                 throw error(&quot;Unknown group type&quot;);
3056             default:    // (?xxx:) inlined match flags
3057                 unread();
3058                 addFlag();
3059                 ch = read();
3060                 if (ch == &#39;)&#39;) {
3061                     return null;    // Inline modifier only
3062                 }
3063                 if (ch != &#39;:&#39;) {
3064                     throw error(&quot;Unknown inline modifier&quot;);
3065                 }
3066                 head = createGroup(true);
3067                 tail = root;
3068                 head.next = expr(tail);
3069                 break;
3070             }
3071         } else { // (xxx) a regular group
3072             capturingGroup = true;
3073             head = createGroup(false);
3074             tail = root;
3075             head.next = expr(tail);
3076         }
3077 
3078         accept(&#39;)&#39;, &quot;Unclosed group&quot;);
3079         flags0 = save;
3080 
3081         // Check for quantifiers
3082         Node node = closure(head);
3083         if (node == head) { // No closure
3084             root = tail;
3085             return node;    // Dual return
3086         }
3087         if (head == tail) { // Zero length assertion
3088             root = node;
3089             return node;    // Dual return
3090         }
3091 
3092         // have group closure, clear all inner closure nodes from the
3093         // top list (no backtracking stopper optimization for inner
3094         if (saveTCNCount &lt; topClosureNodes.size())
3095             topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3096 
3097         return groupWithClosure(node, head, tail, capturingGroup);
3098     }
3099 
3100     /**
3101      * Transforms a Group with quantifiers into some special constructs
3102      * (such as Branch or Loop/GroupCurly), if necessary.
3103      *
3104      * This method is applied either to actual groups or to the Unicode
3105      * linebreak (aka \\R) represented as an anonymous group.
3106      */
3107     private Node groupWithClosure(Node node, Node head, Node tail,
3108                                   boolean capturingGroup)
3109     {
3110         if (node instanceof Ques) {
3111             Ques ques = (Ques) node;
3112             if (ques.type == Qtype.POSSESSIVE) {
3113                 root = node;
3114                 return node;
3115             }
3116             BranchConn branchConn = new BranchConn();
3117             tail = tail.next = branchConn;
3118             if (ques.type == Qtype.GREEDY) {
3119                 head = new Branch(head, null, branchConn);
3120             } else { // Reluctant quantifier
3121                 head = new Branch(null, head, branchConn);
3122             }
3123             root = tail;
3124             return head;
3125         } else if (node instanceof Curly) {
3126             Curly curly = (Curly) node;
3127             if (curly.type == Qtype.POSSESSIVE) {
3128                 root = node;
3129                 return node;
3130             }
3131             // Discover if the group is deterministic
3132             TreeInfo info = new TreeInfo();
3133             if (head.study(info)) { // Deterministic
3134                 GroupTail temp = (GroupTail) tail;
3135                 head = root = new GroupCurly(head.next, curly.cmin,
3136                                    curly.cmax, curly.type,
3137                                    ((GroupTail)tail).localIndex,
3138                                    ((GroupTail)tail).groupIndex,
3139                                              capturingGroup);
3140                 return head;
3141             } else { // Non-deterministic
3142                 int temp = ((GroupHead) head).localIndex;
3143                 Loop loop;
3144                 if (curly.type == Qtype.GREEDY) {
3145                     loop = new Loop(this.localCount, temp);
3146                     // add the max_reps greedy to the top-closure-node list
3147                     if (curly.cmax == MAX_REPS)
3148                         topClosureNodes.add(loop);
3149                 } else {  // Reluctant Curly
3150                     loop = new LazyLoop(this.localCount, temp);
3151                 }
3152                 Prolog prolog = new Prolog(loop);
3153                 this.localCount += 1;
3154                 loop.cmin = curly.cmin;
3155                 loop.cmax = curly.cmax;
3156                 loop.body = head;
3157                 tail.next = loop;
3158                 root = loop;
3159                 return prolog; // Dual return
3160             }
3161         }
3162         throw error(&quot;Internal logic error&quot;);
3163     }
3164 
3165     /**
3166      * Create group head and tail nodes using double return. If the group is
3167      * created with anonymous true then it is a pure group and should not
3168      * affect group counting.
3169      */
3170     private Node createGroup(boolean anonymous) {
3171         int localIndex = localCount++;
3172         int groupIndex = 0;
3173         if (!anonymous)
3174             groupIndex = capturingGroupCount++;
3175         GroupHead head = new GroupHead(localIndex);
3176         root = new GroupTail(localIndex, groupIndex);
3177 
3178         // for debug/print only, head.match does NOT need the &quot;tail&quot; info
3179         head.tail = (GroupTail)root;
3180 
3181         if (!anonymous &amp;&amp; groupIndex &lt; 10)
3182             groupNodes[groupIndex] = head;
3183         return head;
3184     }
3185 
3186     @SuppressWarnings(&quot;fallthrough&quot;)
3187     /**
3188      * Parses inlined match flags and set them appropriately.
3189      */
3190     private void addFlag() {
3191         int ch = peek();
3192         for (;;) {
3193             switch (ch) {
3194             case &#39;i&#39;:
3195                 flags0 |= CASE_INSENSITIVE;
3196                 break;
3197             case &#39;m&#39;:
3198                 flags0 |= MULTILINE;
3199                 break;
3200             case &#39;s&#39;:
3201                 flags0 |= DOTALL;
3202                 break;
3203             case &#39;d&#39;:
3204                 flags0 |= UNIX_LINES;
3205                 break;
3206             case &#39;u&#39;:
3207                 flags0 |= UNICODE_CASE;
3208                 break;
3209             case &#39;c&#39;:
3210                 flags0 |= CANON_EQ;
3211                 break;
3212             case &#39;x&#39;:
3213                 flags0 |= COMMENTS;
3214                 break;
3215             case &#39;U&#39;:
3216                 flags0 |= (UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3217                 break;
3218             case &#39;-&#39;: // subFlag then fall through
3219                 ch = next();
3220                 subFlag();
3221             default:
3222                 return;
3223             }
3224             ch = next();
3225         }
3226     }
3227 
3228     @SuppressWarnings(&quot;fallthrough&quot;)
3229     /**
3230      * Parses the second part of inlined match flags and turns off
3231      * flags appropriately.
3232      */
3233     private void subFlag() {
3234         int ch = peek();
3235         for (;;) {
3236             switch (ch) {
3237             case &#39;i&#39;:
3238                 flags0 &amp;= ~CASE_INSENSITIVE;
3239                 break;
3240             case &#39;m&#39;:
3241                 flags0 &amp;= ~MULTILINE;
3242                 break;
3243             case &#39;s&#39;:
3244                 flags0 &amp;= ~DOTALL;
3245                 break;
3246             case &#39;d&#39;:
3247                 flags0 &amp;= ~UNIX_LINES;
3248                 break;
3249             case &#39;u&#39;:
3250                 flags0 &amp;= ~UNICODE_CASE;
3251                 break;
3252             case &#39;c&#39;:
3253                 flags0 &amp;= ~CANON_EQ;
3254                 break;
3255             case &#39;x&#39;:
3256                 flags0 &amp;= ~COMMENTS;
3257                 break;
3258             case &#39;U&#39;:
3259                 flags0 &amp;= ~(UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3260                 break;
3261             default:
3262                 return;
3263             }
3264             ch = next();
3265         }
3266     }
3267 
3268     static final int MAX_REPS   = 0x7FFFFFFF;
3269 
3270     static enum Qtype {
3271         GREEDY, LAZY, POSSESSIVE, INDEPENDENT
3272     }
3273 
3274     private Qtype qtype() {
3275         int ch = next();
3276         if (ch == &#39;?&#39;) {
3277             next();
3278             return Qtype.LAZY;
3279         } else if (ch == &#39;+&#39;) {
3280             next();
3281             return Qtype.POSSESSIVE;
3282         }
3283         return Qtype.GREEDY;
3284     }
3285 
3286     private Node curly(Node prev, int cmin) {
3287         Qtype qtype = qtype();
3288         if (qtype == Qtype.GREEDY) {
3289             if (prev instanceof BmpCharProperty) {
3290                 return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);
3291             } else if (prev instanceof CharProperty) {
3292                 return new CharPropertyGreedy((CharProperty)prev, cmin);
3293             }
3294         }
3295         return new Curly(prev, cmin, MAX_REPS, qtype);
3296     }
3297 
3298     /**
3299      * Processing repetition of a Unicode linebreak \\R.
3300      */
3301     private Node closureOfLineEnding(LineEnding le) {
3302         int ch = peek();
3303         if (ch != &#39;?&#39; &amp;&amp; ch != &#39;*&#39; &amp;&amp; ch != &#39;+&#39; &amp;&amp; ch != &#39;{&#39;) {
3304             return le;
3305         }
3306 
3307         // Replace the LineEnding with an anonymous group
3308         // (?:\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029])
3309         Node grHead = createGroup(true);
3310         Node grTail = root;
3311         BranchConn branchConn = new BranchConn();
3312         branchConn.next = grTail;
3313         Node slice = new Slice(new int[] {0x0D, 0x0A});
3314         slice.next = branchConn;
3315         Node chClass = newCharProperty(x -&gt; x == 0x0A || x == 0x0B ||
3316                 x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||
3317                 x == 0x2029);
3318         chClass.next = branchConn;
3319         grHead.next = new Branch(slice, chClass, branchConn);
3320         return groupWithClosure(closure(grHead), grHead, grTail, false);
3321     }
3322 
3323     /**
3324      * Processes repetition. If the next character peeked is a quantifier
3325      * then new nodes must be appended to handle the repetition.
3326      * Prev could be a single or a group, so it could be a chain of nodes.
3327      */
3328     private Node closure(Node prev) {
3329         int ch = peek();
3330         switch (ch) {
3331         case &#39;?&#39;:
3332             return new Ques(prev, qtype());
3333         case &#39;*&#39;:
3334             return curly(prev, 0);
3335         case &#39;+&#39;:
3336             return curly(prev, 1);
3337         case &#39;{&#39;:
3338             ch = skip();
3339             if (ASCII.isDigit(ch)) {
3340                 int cmin = 0, cmax;
3341                 try {
3342                     do {
3343                         cmin = Math.addExact(Math.multiplyExact(cmin, 10),
3344                                              ch - &#39;0&#39;);
3345                     } while (ASCII.isDigit(ch = read()));
3346                     if (ch == &#39;,&#39;) {
3347                         ch = read();
3348                         if (ch == &#39;}&#39;) {
3349                             unread();
3350                             return curly(prev, cmin);
3351                         } else {
3352                             cmax = 0;
3353                             while (ASCII.isDigit(ch)) {
3354                                 cmax = Math.addExact(Math.multiplyExact(cmax, 10),
3355                                                      ch - &#39;0&#39;);
3356                                 ch = read();
3357                             }
3358                         }
3359                     } else {
3360                         cmax = cmin;
3361                     }
3362                 } catch (ArithmeticException ae) {
3363                     throw error(&quot;Illegal repetition range&quot;);
3364                 }
3365                 if (ch != &#39;}&#39;)
3366                     throw error(&quot;Unclosed counted closure&quot;);
3367                 if (cmax &lt; cmin)
3368                     throw error(&quot;Illegal repetition range&quot;);
3369                 unread();
3370                 return (cmin == 0 &amp;&amp; cmax == 1)
3371                         ? new Ques(prev, qtype())
3372                         : new Curly(prev, cmin, cmax, qtype());
3373             } else {
3374                 throw error(&quot;Illegal repetition&quot;);
3375             }
3376         default:
3377             return prev;
3378         }
3379     }
3380 
3381     /**
3382      *  Utility method for parsing control escape sequences.
3383      */
3384     private int c() {
3385         if (cursor &lt; patternLength) {
3386             return read() ^ 64;
3387         }
3388         throw error(&quot;Illegal control escape sequence&quot;);
3389     }
3390 
3391     /**
3392      *  Utility method for parsing octal escape sequences.
3393      */
3394     private int o() {
3395         int n = read();
3396         if (((n-&#39;0&#39;)|(&#39;7&#39;-n)) &gt;= 0) {
3397             int m = read();
3398             if (((m-&#39;0&#39;)|(&#39;7&#39;-m)) &gt;= 0) {
3399                 int o = read();
3400                 if ((((o-&#39;0&#39;)|(&#39;7&#39;-o)) &gt;= 0) &amp;&amp; (((n-&#39;0&#39;)|(&#39;3&#39;-n)) &gt;= 0)) {
3401                     return (n - &#39;0&#39;) * 64 + (m - &#39;0&#39;) * 8 + (o - &#39;0&#39;);
3402                 }
3403                 unread();
3404                 return (n - &#39;0&#39;) * 8 + (m - &#39;0&#39;);
3405             }
3406             unread();
3407             return (n - &#39;0&#39;);
3408         }
3409         throw error(&quot;Illegal octal escape sequence&quot;);
3410     }
3411 
3412     /**
3413      *  Utility method for parsing hexadecimal escape sequences.
3414      */
3415     private int x() {
3416         int n = read();
3417         if (ASCII.isHexDigit(n)) {
3418             int m = read();
3419             if (ASCII.isHexDigit(m)) {
3420                 return ASCII.toDigit(n) * 16 + ASCII.toDigit(m);
3421             }
3422         } else if (n == &#39;{&#39; &amp;&amp; ASCII.isHexDigit(peek())) {
3423             int ch = 0;
3424             while (ASCII.isHexDigit(n = read())) {
3425                 ch = (ch &lt;&lt; 4) + ASCII.toDigit(n);
3426                 if (ch &gt; Character.MAX_CODE_POINT)
3427                     throw error(&quot;Hexadecimal codepoint is too big&quot;);
3428             }
3429             if (n != &#39;}&#39;)
3430                 throw error(&quot;Unclosed hexadecimal escape sequence&quot;);
3431             return ch;
3432         }
3433         throw error(&quot;Illegal hexadecimal escape sequence&quot;);
3434     }
3435 
3436     /**
3437      *  Utility method for parsing unicode escape sequences.
3438      */
3439     private int cursor() {
3440         return cursor;
3441     }
3442 
3443     private void setcursor(int pos) {
3444         cursor = pos;
3445     }
3446 
3447     private int uxxxx() {
3448         int n = 0;
3449         for (int i = 0; i &lt; 4; i++) {
3450             int ch = read();
3451             if (!ASCII.isHexDigit(ch)) {
3452                 throw error(&quot;Illegal Unicode escape sequence&quot;);
3453             }
3454             n = n * 16 + ASCII.toDigit(ch);
3455         }
3456         return n;
3457     }
3458 
3459     private int u() {
3460         int n = uxxxx();
3461         if (Character.isHighSurrogate((char)n)) {
3462             int cur = cursor();
3463             if (read() == &#39;\\&#39; &amp;&amp; read() == &#39;u&#39;) {
3464                 int n2 = uxxxx();
3465                 if (Character.isLowSurrogate((char)n2))
3466                     return Character.toCodePoint((char)n, (char)n2);
3467             }
3468             setcursor(cur);
3469         }
3470         return n;
3471     }
3472 
3473     private int N() {
3474         if (read() == &#39;{&#39;) {
3475             int i = cursor;
3476             while (read() != &#39;}&#39;) {
3477                 if (cursor &gt;= patternLength)
3478                     throw error(&quot;Unclosed character name escape sequence&quot;);
3479             }
3480             String name = new String(temp, i, cursor - i - 1);
3481             try {
3482                 return Character.codePointOf(name);
3483             } catch (IllegalArgumentException x) {
3484                 throw error(&quot;Unknown character name [&quot; + name + &quot;]&quot;);
3485             }
3486         }
3487         throw error(&quot;Illegal character name escape sequence&quot;);
3488     }
3489 
3490     //
3491     // Utility methods for code point support
3492     //
3493     private static final int countChars(CharSequence seq, int index,
3494                                         int lengthInCodePoints) {
3495         // optimization
3496         if (lengthInCodePoints == 1 &amp;&amp; !Character.isHighSurrogate(seq.charAt(index))) {
3497             assert (index &gt;= 0 &amp;&amp; index &lt; seq.length());
3498             return 1;
3499         }
3500         int length = seq.length();
3501         int x = index;
3502         if (lengthInCodePoints &gt;= 0) {
3503             assert (index &gt;= 0 &amp;&amp; index &lt; length);
3504             for (int i = 0; x &lt; length &amp;&amp; i &lt; lengthInCodePoints; i++) {
3505                 if (Character.isHighSurrogate(seq.charAt(x++))) {
3506                     if (x &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(x))) {
3507                         x++;
3508                     }
3509                 }
3510             }
3511             return x - index;
3512         }
3513 
3514         assert (index &gt;= 0 &amp;&amp; index &lt;= length);
3515         if (index == 0) {
3516             return 0;
3517         }
3518         int len = -lengthInCodePoints;
3519         for (int i = 0; x &gt; 0 &amp;&amp; i &lt; len; i++) {
3520             if (Character.isLowSurrogate(seq.charAt(--x))) {
3521                 if (x &gt; 0 &amp;&amp; Character.isHighSurrogate(seq.charAt(x-1))) {
3522                     x--;
3523                 }
3524             }
3525         }
3526         return index - x;
3527     }
3528 
3529     private static final int countCodePoints(CharSequence seq) {
3530         int length = seq.length();
3531         int n = 0;
3532         for (int i = 0; i &lt; length; ) {
3533             n++;
3534             if (Character.isHighSurrogate(seq.charAt(i++))) {
3535                 if (i &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(i))) {
3536                     i++;
3537                 }
3538             }
3539         }
3540         return n;
3541     }
3542 
3543     /**
3544      *  Creates a bit vector for matching Latin-1 values. A normal BitClass
3545      *  never matches values above Latin-1, and a complemented BitClass always
3546      *  matches values above Latin-1.
3547      */
3548     static final class BitClass implements BmpCharPredicate {
3549         final boolean[] bits;
3550         BitClass() {
3551             bits = new boolean[256];
3552         }
3553         BitClass add(int c, int flags) {
3554             assert c &gt;= 0 &amp;&amp; c &lt;= 255;
3555             if ((flags &amp; CASE_INSENSITIVE) != 0) {
3556                 if (ASCII.isAscii(c)) {
3557                     bits[ASCII.toUpper(c)] = true;
3558                     bits[ASCII.toLower(c)] = true;
3559                 } else if ((flags &amp; UNICODE_CASE) != 0) {
3560                     bits[Character.toLowerCase(c)] = true;
3561                     bits[Character.toUpperCase(c)] = true;
3562                 }
3563             }
3564             bits[c] = true;
3565             return this;
3566         }
3567         public boolean is(int ch) {
3568             return ch &lt; 256 &amp;&amp; bits[ch];
3569         }
3570     }
3571 
3572 
3573     /**
3574      *  Utility method for creating a string slice matcher.
3575      */
3576     private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
3577         int[] tmp = new int[count];
3578         if (has(CASE_INSENSITIVE)) {
3579             if (has(UNICODE_CASE)) {
3580                 for (int i = 0; i &lt; count; i++) {
3581                     tmp[i] = Character.toLowerCase(
3582                                  Character.toUpperCase(buf[i]));
3583                 }
3584                 return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);
3585             }
3586             for (int i = 0; i &lt; count; i++) {
3587                 tmp[i] = ASCII.toLower(buf[i]);
3588             }
3589             return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);
3590         }
3591         for (int i = 0; i &lt; count; i++) {
3592             tmp[i] = buf[i];
3593         }
3594         return hasSupplementary ? new SliceS(tmp) : new Slice(tmp);
3595     }
3596 
3597     /**
3598      * The following classes are the building components of the object
3599      * tree that represents a compiled regular expression. The object tree
3600      * is made of individual elements that handle constructs in the Pattern.
3601      * Each type of object knows how to match its equivalent construct with
3602      * the match() method.
3603      */
3604 
3605     /**
3606      * Base class for all node classes. Subclasses should override the match()
3607      * method as appropriate. This class is an accepting node, so its match()
3608      * always returns true.
3609      */
3610     static class Node extends Object {
3611         Node next;
3612         Node() {
3613             next = Pattern.accept;
3614         }
3615         /**
3616          * This method implements the classic accept node.
3617          */
3618         boolean match(Matcher matcher, int i, CharSequence seq) {
3619             matcher.last = i;
3620             matcher.groups[0] = matcher.first;
3621             matcher.groups[1] = matcher.last;
3622             return true;
3623         }
3624         /**
3625          * This method is good for all zero length assertions.
3626          */
3627         boolean study(TreeInfo info) {
3628             if (next != null) {
3629                 return next.study(info);
3630             } else {
3631                 return info.deterministic;
3632             }
3633         }
3634     }
3635 
3636     static class LastNode extends Node {
3637         /**
3638          * This method implements the classic accept node with
3639          * the addition of a check to see if the match occurred
3640          * using all of the input.
3641          */
3642         boolean match(Matcher matcher, int i, CharSequence seq) {
3643             if (matcher.acceptMode == Matcher.ENDANCHOR &amp;&amp; i != matcher.to)
3644                 return false;
3645             matcher.last = i;
3646             matcher.groups[0] = matcher.first;
3647             matcher.groups[1] = matcher.last;
3648             return true;
3649         }
3650     }
3651 
3652     /**
3653      * Used for REs that can start anywhere within the input string.
3654      * This basically tries to match repeatedly at each spot in the
3655      * input string, moving forward after each try. An anchored search
3656      * or a BnM will bypass this node completely.
3657      */
3658     static class Start extends Node {
3659         int minLength;
3660         Start(Node node) {
3661             this.next = node;
3662             TreeInfo info = new TreeInfo();
3663             next.study(info);
3664             minLength = info.minLength;
3665         }
3666         boolean match(Matcher matcher, int i, CharSequence seq) {
3667             if (i &gt; matcher.to - minLength) {
3668                 matcher.hitEnd = true;
3669                 return false;
3670             }
3671             int guard = matcher.to - minLength;
3672             for (; i &lt;= guard; i++) {
3673                 if (next.match(matcher, i, seq)) {
3674                     matcher.first = i;
3675                     matcher.groups[0] = matcher.first;
3676                     matcher.groups[1] = matcher.last;
3677                     return true;
3678                 }
3679             }
3680             matcher.hitEnd = true;
3681             return false;
3682         }
3683         boolean study(TreeInfo info) {
3684             next.study(info);
3685             info.maxValid = false;
3686             info.deterministic = false;
3687             return false;
3688         }
3689     }
3690 
3691     /*
3692      * StartS supports supplementary characters, including unpaired surrogates.
3693      */
3694     static final class StartS extends Start {
3695         StartS(Node node) {
3696             super(node);
3697         }
3698         boolean match(Matcher matcher, int i, CharSequence seq) {
3699             if (i &gt; matcher.to - minLength) {
3700                 matcher.hitEnd = true;
3701                 return false;
3702             }
3703             int guard = matcher.to - minLength;
3704             while (i &lt;= guard) {
3705                 //if ((ret = next.match(matcher, i, seq)) || i == guard)
3706                 if (next.match(matcher, i, seq)) {
3707                     matcher.first = i;
3708                     matcher.groups[0] = matcher.first;
3709                     matcher.groups[1] = matcher.last;
3710                     return true;
3711                 }
3712                 if (i == guard)
3713                     break;
3714                 // Optimization to move to the next character. This is
3715                 // faster than countChars(seq, i, 1).
3716                 if (Character.isHighSurrogate(seq.charAt(i++))) {
3717                     if (i &lt; seq.length() &amp;&amp;
3718                         Character.isLowSurrogate(seq.charAt(i))) {
3719                         i++;
3720                     }
3721                 }
3722             }
3723             matcher.hitEnd = true;
3724             return false;
3725         }
3726     }
3727 
3728     /**
3729      * Node to anchor at the beginning of input. This object implements the
3730      * match for a \A sequence, and the caret anchor will use this if not in
3731      * multiline mode.
3732      */
3733     static final class Begin extends Node {
3734         boolean match(Matcher matcher, int i, CharSequence seq) {
3735             int fromIndex = (matcher.anchoringBounds) ?
3736                 matcher.from : 0;
3737             if (i == fromIndex &amp;&amp; next.match(matcher, i, seq)) {
3738                 matcher.first = i;
3739                 matcher.groups[0] = i;
3740                 matcher.groups[1] = matcher.last;
3741                 return true;
3742             } else {
3743                 return false;
3744             }
3745         }
3746     }
3747 
3748     /**
3749      * Node to anchor at the end of input. This is the absolute end, so this
3750      * should not match at the last newline before the end as $ will.
3751      */
3752     static final class End extends Node {
3753         boolean match(Matcher matcher, int i, CharSequence seq) {
3754             int endIndex = (matcher.anchoringBounds) ?
3755                 matcher.to : matcher.getTextLength();
3756             if (i == endIndex) {
3757                 matcher.hitEnd = true;
3758                 return next.match(matcher, i, seq);
3759             }
3760             return false;
3761         }
3762     }
3763 
3764     /**
3765      * Node to anchor at the beginning of a line. This is essentially the
3766      * object to match for the multiline ^.
3767      */
3768     static final class Caret extends Node {
3769         boolean match(Matcher matcher, int i, CharSequence seq) {
3770             int startIndex = matcher.from;
3771             int endIndex = matcher.to;
3772             if (!matcher.anchoringBounds) {
3773                 startIndex = 0;
3774                 endIndex = matcher.getTextLength();
3775             }
3776             // Perl does not match ^ at end of input even after newline
3777             if (i == endIndex) {
3778                 matcher.hitEnd = true;
3779                 return false;
3780             }
3781             if (i &gt; startIndex) {
3782                 char ch = seq.charAt(i-1);
3783                 if (ch != &#39;\n&#39; &amp;&amp; ch != &#39;\r&#39;
3784                     &amp;&amp; (ch|1) != &#39;\u2029&#39;
3785                     &amp;&amp; ch != &#39;\u0085&#39; ) {
3786                     return false;
3787                 }
3788                 // Should treat /r/n as one newline
3789                 if (ch == &#39;\r&#39; &amp;&amp; seq.charAt(i) == &#39;\n&#39;)
3790                     return false;
3791             }
3792             return next.match(matcher, i, seq);
3793         }
3794     }
3795 
3796     /**
3797      * Node to anchor at the beginning of a line when in unixdot mode.
3798      */
3799     static final class UnixCaret extends Node {
3800         boolean match(Matcher matcher, int i, CharSequence seq) {
3801             int startIndex = matcher.from;
3802             int endIndex = matcher.to;
3803             if (!matcher.anchoringBounds) {
3804                 startIndex = 0;
3805                 endIndex = matcher.getTextLength();
3806             }
3807             // Perl does not match ^ at end of input even after newline
3808             if (i == endIndex) {
3809                 matcher.hitEnd = true;
3810                 return false;
3811             }
3812             if (i &gt; startIndex) {
3813                 char ch = seq.charAt(i-1);
3814                 if (ch != &#39;\n&#39;) {
3815                     return false;
3816                 }
3817             }
3818             return next.match(matcher, i, seq);
3819         }
3820     }
3821 
3822     /**
3823      * Node to match the location where the last match ended.
3824      * This is used for the \G construct.
3825      */
3826     static final class LastMatch extends Node {
3827         boolean match(Matcher matcher, int i, CharSequence seq) {
3828             if (i != matcher.oldLast)
3829                 return false;
3830             return next.match(matcher, i, seq);
3831         }
3832     }
3833 
3834     /**
3835      * Node to anchor at the end of a line or the end of input based on the
3836      * multiline mode.
3837      *
3838      * When not in multiline mode, the $ can only match at the very end
3839      * of the input, unless the input ends in a line terminator in which
3840      * it matches right before the last line terminator.
3841      *
3842      * Note that \r\n is considered an atomic line terminator.
3843      *
3844      * Like ^ the $ operator matches at a position, it does not match the
3845      * line terminators themselves.
3846      */
3847     static final class Dollar extends Node {
3848         boolean multiline;
3849         Dollar(boolean mul) {
3850             multiline = mul;
3851         }
3852         boolean match(Matcher matcher, int i, CharSequence seq) {
3853             int endIndex = (matcher.anchoringBounds) ?
3854                 matcher.to : matcher.getTextLength();
3855             if (!multiline) {
3856                 if (i &lt; endIndex - 2)
3857                     return false;
3858                 if (i == endIndex - 2) {
3859                     char ch = seq.charAt(i);
3860                     if (ch != &#39;\r&#39;)
3861                         return false;
3862                     ch = seq.charAt(i + 1);
3863                     if (ch != &#39;\n&#39;)
3864                         return false;
3865                 }
3866             }
3867             // Matches before any line terminator; also matches at the
3868             // end of input
3869             // Before line terminator:
3870             // If multiline, we match here no matter what
3871             // If not multiline, fall through so that the end
3872             // is marked as hit; this must be a /r/n or a /n
3873             // at the very end so the end was hit; more input
3874             // could make this not match here
3875             if (i &lt; endIndex) {
3876                 char ch = seq.charAt(i);
3877                  if (ch == &#39;\n&#39;) {
3878                      // No match between \r\n
3879                      if (i &gt; 0 &amp;&amp; seq.charAt(i-1) == &#39;\r&#39;)
3880                          return false;
3881                      if (multiline)
3882                          return next.match(matcher, i, seq);
3883                  } else if (ch == &#39;\r&#39; || ch == &#39;\u0085&#39; ||
3884                             (ch|1) == &#39;\u2029&#39;) {
3885                      if (multiline)
3886                          return next.match(matcher, i, seq);
3887                  } else { // No line terminator, no match
3888                      return false;
3889                  }
3890             }
3891             // Matched at current end so hit end
3892             matcher.hitEnd = true;
3893             // If a $ matches because of end of input, then more input
3894             // could cause it to fail!
3895             matcher.requireEnd = true;
3896             return next.match(matcher, i, seq);
3897         }
3898         boolean study(TreeInfo info) {
3899             next.study(info);
3900             return info.deterministic;
3901         }
3902     }
3903 
3904     /**
3905      * Node to anchor at the end of a line or the end of input based on the
3906      * multiline mode when in unix lines mode.
3907      */
3908     static final class UnixDollar extends Node {
3909         boolean multiline;
3910         UnixDollar(boolean mul) {
3911             multiline = mul;
3912         }
3913         boolean match(Matcher matcher, int i, CharSequence seq) {
3914             int endIndex = (matcher.anchoringBounds) ?
3915                 matcher.to : matcher.getTextLength();
3916             if (i &lt; endIndex) {
3917                 char ch = seq.charAt(i);
3918                 if (ch == &#39;\n&#39;) {
3919                     // If not multiline, then only possible to
3920                     // match at very end or one before end
3921                     if (multiline == false &amp;&amp; i != endIndex - 1)
3922                         return false;
3923                     // If multiline return next.match without setting
3924                     // matcher.hitEnd
3925                     if (multiline)
3926                         return next.match(matcher, i, seq);
3927                 } else {
3928                     return false;
3929                 }
3930             }
3931             // Matching because at the end or 1 before the end;
3932             // more input could change this so set hitEnd
3933             matcher.hitEnd = true;
3934             // If a $ matches because of end of input, then more input
3935             // could cause it to fail!
3936             matcher.requireEnd = true;
3937             return next.match(matcher, i, seq);
3938         }
3939         boolean study(TreeInfo info) {
3940             next.study(info);
3941             return info.deterministic;
3942         }
3943     }
3944 
3945     /**
3946      * Node class that matches a Unicode line ending &#39;\R&#39;
3947      */
3948     static final class LineEnding extends Node {
3949         boolean match(Matcher matcher, int i, CharSequence seq) {
3950             // (u+000Du+000A|[u+000Au+000Bu+000Cu+000Du+0085u+2028u+2029])
3951             if (i &lt; matcher.to) {
3952                 int ch = seq.charAt(i);
3953                 if (ch == 0x0A || ch == 0x0B || ch == 0x0C ||
3954                     ch == 0x85 || ch == 0x2028 || ch == 0x2029)
3955                     return next.match(matcher, i + 1, seq);
3956                 if (ch == 0x0D) {
3957                     i++;
3958                     if (i &lt; matcher.to) {
3959                         if (seq.charAt(i) == 0x0A &amp;&amp;
3960                             next.match(matcher, i + 1, seq)) {
3961                             return true;
3962                         }
3963                     } else {
3964                         matcher.hitEnd = true;
3965                     }
3966                     return next.match(matcher, i, seq);
3967                 }
3968             } else {
3969                 matcher.hitEnd = true;
3970             }
3971             return false;
3972         }
3973         boolean study(TreeInfo info) {
3974             info.minLength++;
3975             info.maxLength += 2;
3976             return next.study(info);
3977         }
3978     }
3979 
3980     /**
3981      * Abstract node class to match one character satisfying some
3982      * boolean property.
3983      */
3984     static class CharProperty extends Node {
3985         final CharPredicate predicate;
3986 
3987         CharProperty (CharPredicate predicate) {
3988             this.predicate = predicate;
3989         }
3990         boolean match(Matcher matcher, int i, CharSequence seq) {
3991             if (i &lt; matcher.to) {
3992                 int ch = Character.codePointAt(seq, i);
3993                 i += Character.charCount(ch);
3994                 if (i &lt;= matcher.to) {
3995                     return predicate.is(ch) &amp;&amp;
3996                            next.match(matcher, i, seq);
3997                 }
3998             }
3999             matcher.hitEnd = true;
4000             return false;
4001         }
4002         boolean study(TreeInfo info) {
4003             info.minLength++;
4004             info.maxLength++;
4005             return next.study(info);
4006         }
4007     }
4008 
4009     /**
4010      * Optimized version of CharProperty that works only for
4011      * properties never satisfied by Supplementary characters.
4012      */
4013     private static class BmpCharProperty extends CharProperty {
4014         BmpCharProperty (BmpCharPredicate predicate) {
4015             super(predicate);
4016         }
4017         boolean match(Matcher matcher, int i, CharSequence seq) {
4018             if (i &lt; matcher.to) {
4019                 return predicate.is(seq.charAt(i)) &amp;&amp;
4020                        next.match(matcher, i + 1, seq);
4021             } else {
4022                 matcher.hitEnd = true;
4023                 return false;
4024             }
4025         }
4026     }
4027 
4028     private static class NFCCharProperty extends Node {
4029         CharPredicate predicate;
4030         NFCCharProperty (CharPredicate predicate) {
4031             this.predicate = predicate;
4032         }
4033 
4034         boolean match(Matcher matcher, int i, CharSequence seq) {
4035             if (i &lt; matcher.to) {
4036                 int ch0 = Character.codePointAt(seq, i);
4037                 int n = Character.charCount(ch0);
4038                 int j = Grapheme.nextBoundary(seq, i, matcher.to);
4039                 if (i + n == j) { // single cp grapheme, assume nfc
4040                     if (predicate.is(ch0))
4041                         return next.match(matcher, j, seq);
4042                 } else {
4043                     while (i + n &lt; j) {
4044                         String nfc = Normalizer.normalize(
4045                             seq.toString().substring(i, j), Normalizer.Form.NFC);
4046                         if (nfc.codePointCount(0, nfc.length()) == 1) {
4047                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
4048                                 next.match(matcher, j, seq)) {
4049                                 return true;
4050                             }
4051                         }
4052 
4053                         ch0 = Character.codePointBefore(seq, j);
4054                         j -= Character.charCount(ch0);
4055                     }
4056                 }
4057                 if (j &lt; matcher.to)
4058                     return false;
4059             }
4060             matcher.hitEnd = true;
4061             return false;
4062         }
4063 
4064         boolean study(TreeInfo info) {
4065             info.minLength++;
4066             info.deterministic = false;
4067             return next.study(info);
4068         }
4069     }
4070 
4071     /**
4072      * Node class that matches an unicode extended grapheme cluster
4073      */
4074     static class XGrapheme extends Node {
4075         boolean match(Matcher matcher, int i, CharSequence seq) {
4076             if (i &lt; matcher.to) {
4077                 i = Grapheme.nextBoundary(seq, i, matcher.to);
4078                 return next.match(matcher, i, seq);
4079             }
4080             matcher.hitEnd = true;
4081             return false;
4082         }
4083 
4084         boolean study(TreeInfo info) {
4085             info.minLength++;
4086             info.deterministic = false;
4087             return next.study(info);
4088         }
4089     }
4090 
4091     /**
4092      * Node class that handles grapheme boundaries
4093      */
4094     static class GraphemeBound extends Node {
4095         boolean match(Matcher matcher, int i, CharSequence seq) {
4096             int startIndex = matcher.from;
4097             int endIndex = matcher.to;
4098             if (matcher.transparentBounds) {
4099                 startIndex = 0;
4100                 endIndex = matcher.getTextLength();
4101             }
4102             if (i == startIndex) {
4103                 // continue with return below
4104             } else if (i &lt; endIndex) {
4105                 if (Character.isSurrogatePair(seq.charAt(i - 1), seq.charAt(i))) {
4106                     return false;
4107                 }
4108                 if (Grapheme.nextBoundary(seq, matcher.last, endIndex) &gt; i) {
4109                     return false;
4110                 }
4111             } else {
4112                 matcher.hitEnd = true;
4113                 matcher.requireEnd = true;
4114             }
4115             return next.match(matcher, i, seq);
4116         }
4117     }
4118 
4119     /**
4120      * Base class for all Slice nodes
4121      */
4122     static class SliceNode extends Node {
4123         int[] buffer;
4124         SliceNode(int[] buf) {
4125             buffer = buf;
4126         }
4127         boolean study(TreeInfo info) {
4128             info.minLength += buffer.length;
4129             info.maxLength += buffer.length;
4130             return next.study(info);
4131         }
4132     }
4133 
4134     /**
4135      * Node class for a case sensitive/BMP-only sequence of literal
4136      * characters.
4137      */
4138     static class Slice extends SliceNode {
4139         Slice(int[] buf) {
4140             super(buf);
4141         }
4142         boolean match(Matcher matcher, int i, CharSequence seq) {
4143             int[] buf = buffer;
4144             int len = buf.length;
4145             for (int j=0; j&lt;len; j++) {
4146                 if ((i+j) &gt;= matcher.to) {
4147                     matcher.hitEnd = true;
4148                     return false;
4149                 }
4150                 if (buf[j] != seq.charAt(i+j))
4151                     return false;
4152             }
4153             return next.match(matcher, i+len, seq);
4154         }
4155     }
4156 
4157     /**
4158      * Node class for a case_insensitive/BMP-only sequence of literal
4159      * characters.
4160      */
4161     static class SliceI extends SliceNode {
4162         SliceI(int[] buf) {
4163             super(buf);
4164         }
4165         boolean match(Matcher matcher, int i, CharSequence seq) {
4166             int[] buf = buffer;
4167             int len = buf.length;
4168             for (int j=0; j&lt;len; j++) {
4169                 if ((i+j) &gt;= matcher.to) {
4170                     matcher.hitEnd = true;
4171                     return false;
4172                 }
4173                 int c = seq.charAt(i+j);
4174                 if (buf[j] != c &amp;&amp;
4175                     buf[j] != ASCII.toLower(c))
4176                     return false;
4177             }
4178             return next.match(matcher, i+len, seq);
4179         }
4180     }
4181 
4182     /**
4183      * Node class for a unicode_case_insensitive/BMP-only sequence of
4184      * literal characters. Uses unicode case folding.
4185      */
4186     static final class SliceU extends SliceNode {
4187         SliceU(int[] buf) {
4188             super(buf);
4189         }
4190         boolean match(Matcher matcher, int i, CharSequence seq) {
4191             int[] buf = buffer;
4192             int len = buf.length;
4193             for (int j=0; j&lt;len; j++) {
4194                 if ((i+j) &gt;= matcher.to) {
4195                     matcher.hitEnd = true;
4196                     return false;
4197                 }
4198                 int c = seq.charAt(i+j);
4199                 if (buf[j] != c &amp;&amp;
4200                     buf[j] != Character.toLowerCase(Character.toUpperCase(c)))
4201                     return false;
4202             }
4203             return next.match(matcher, i+len, seq);
4204         }
4205     }
4206 
4207     /**
4208      * Node class for a case sensitive sequence of literal characters
4209      * including supplementary characters.
4210      */
4211     static final class SliceS extends Slice {
4212         SliceS(int[] buf) {
4213             super(buf);
4214         }
4215         boolean match(Matcher matcher, int i, CharSequence seq) {
4216             int[] buf = buffer;
4217             int x = i;
4218             for (int j = 0; j &lt; buf.length; j++) {
4219                 if (x &gt;= matcher.to) {
4220                     matcher.hitEnd = true;
4221                     return false;
4222                 }
4223                 int c = Character.codePointAt(seq, x);
4224                 if (buf[j] != c)
4225                     return false;
4226                 x += Character.charCount(c);
4227                 if (x &gt; matcher.to) {
4228                     matcher.hitEnd = true;
4229                     return false;
4230                 }
4231             }
4232             return next.match(matcher, x, seq);
4233         }
4234     }
4235 
4236     /**
4237      * Node class for a case insensitive sequence of literal characters
4238      * including supplementary characters.
4239      */
4240     static class SliceIS extends SliceNode {
4241         SliceIS(int[] buf) {
4242             super(buf);
4243         }
4244         int toLower(int c) {
4245             return ASCII.toLower(c);
4246         }
4247         boolean match(Matcher matcher, int i, CharSequence seq) {
4248             int[] buf = buffer;
4249             int x = i;
4250             for (int j = 0; j &lt; buf.length; j++) {
4251                 if (x &gt;= matcher.to) {
4252                     matcher.hitEnd = true;
4253                     return false;
4254                 }
4255                 int c = Character.codePointAt(seq, x);
4256                 if (buf[j] != c &amp;&amp; buf[j] != toLower(c))
4257                     return false;
4258                 x += Character.charCount(c);
4259                 if (x &gt; matcher.to) {
4260                     matcher.hitEnd = true;
4261                     return false;
4262                 }
4263             }
4264             return next.match(matcher, x, seq);
4265         }
4266     }
4267 
4268     /**
4269      * Node class for a case insensitive sequence of literal characters.
4270      * Uses unicode case folding.
4271      */
4272     static final class SliceUS extends SliceIS {
4273         SliceUS(int[] buf) {
4274             super(buf);
4275         }
4276         int toLower(int c) {
4277             return Character.toLowerCase(Character.toUpperCase(c));
4278         }
4279     }
4280 
4281     /**
4282      * The 0 or 1 quantifier. This one class implements all three types.
4283      */
4284     static final class Ques extends Node {
4285         Node atom;
4286         Qtype type;
4287         Ques(Node node, Qtype type) {
4288             this.atom = node;
4289             this.type = type;
4290         }
4291         boolean match(Matcher matcher, int i, CharSequence seq) {
4292             switch (type) {
4293             case GREEDY:
4294                 return (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq))
4295                     || next.match(matcher, i, seq);
4296             case LAZY:
4297                 return next.match(matcher, i, seq)
4298                     || (atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq));
4299             case POSSESSIVE:
4300                 if (atom.match(matcher, i, seq)) i = matcher.last;
4301                 return next.match(matcher, i, seq);
4302             default:
4303                 return atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq);
4304             }
4305         }
4306         boolean study(TreeInfo info) {
4307             if (type != Qtype.INDEPENDENT) {
4308                 int minL = info.minLength;
4309                 atom.study(info);
4310                 info.minLength = minL;
4311                 info.deterministic = false;
4312                 return next.study(info);
4313             } else {
4314                 atom.study(info);
4315                 return next.study(info);
4316             }
4317         }
4318     }
4319 
4320     /**
4321      * Handles the greedy style repetition with the specified minimum
4322      * and the maximum equal to MAX_REPS, for *, + and {N,} quantifiers.
4323      */
4324     static class CharPropertyGreedy extends Node {
4325         final CharPredicate predicate;
4326         final int cmin;
4327 
4328         CharPropertyGreedy(CharProperty cp, int cmin) {
4329             this.predicate = cp.predicate;
4330             this.cmin = cmin;
4331         }
4332         boolean match(Matcher matcher, int i, CharSequence seq) {
4333             int starti = i;
4334             int n = 0;
4335             int to = matcher.to;
4336             // greedy, all the way down
4337             while (i &lt; to) {
4338                 int ch = Character.codePointAt(seq, i);
4339                 int len = Character.charCount(ch);
4340                 if (i + len &gt; to) {
4341                     // the region cut off the high half of a surrogate pair
4342                     matcher.hitEnd = true;
4343                     ch = seq.charAt(i);
4344                     len = 1;
4345                 }
4346                 if (!predicate.is(ch))
4347                     break;
4348                 i += len;
4349                 n++;
4350             }
4351             if (i &gt;= to) {
4352                 matcher.hitEnd = true;
4353             }
4354             while (n &gt;= cmin) {
4355                 if (next.match(matcher, i, seq))
4356                     return true;
4357                 if (n == cmin)
4358                     return false;
4359                 // backing off if match fails
4360                 int ch = Character.codePointBefore(seq, i);
4361                 // check if the region cut off the low half of a surrogate pair
4362                 i = Math.max(starti, i - Character.charCount(ch));
4363                 n--;
4364             }
4365             return false;
4366         }
4367 
4368         boolean study(TreeInfo info) {
4369             info.minLength += cmin;
4370             if (info.maxValid) {
4371                 info.maxLength += MAX_REPS;
4372             }
4373             info.deterministic = false;
4374             return next.study(info);
4375         }
4376     }
4377 
4378     static final class BmpCharPropertyGreedy extends CharPropertyGreedy {
4379 
4380         BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
4381             super(bcp, cmin);
4382         }
4383 
4384         boolean match(Matcher matcher, int i, CharSequence seq) {
4385             int n = 0;
4386             int to = matcher.to;
4387             while (i &lt; to &amp;&amp; predicate.is(seq.charAt(i))) {
4388                 i++; n++;
4389             }
4390             if (i &gt;= to) {
4391                 matcher.hitEnd = true;
4392             }
4393             while (n &gt;= cmin) {
4394                 if (next.match(matcher, i, seq))
4395                     return true;
4396                 i--; n--;  // backing off if match fails
4397             }
4398             return false;
4399         }
4400     }
4401 
4402     /**
4403      * Handles the curly-brace style repetition with a specified minimum and
4404      * maximum occurrences. The * quantifier is handled as a special case.
4405      * This class handles the three types.
4406      */
4407     static final class Curly extends Node {
4408         Node atom;
4409         Qtype type;
4410         int cmin;
4411         int cmax;
4412 
4413         Curly(Node node, int cmin, int cmax, Qtype type) {
4414             this.atom = node;
4415             this.type = type;
4416             this.cmin = cmin;
4417             this.cmax = cmax;
4418         }
4419         boolean match(Matcher matcher, int i, CharSequence seq) {
4420             int j;
4421             for (j = 0; j &lt; cmin; j++) {
4422                 if (atom.match(matcher, i, seq)) {
4423                     i = matcher.last;
4424                     continue;
4425                 }
4426                 return false;
4427             }
4428             if (type == Qtype.GREEDY)
4429                 return match0(matcher, i, j, seq);
4430             else if (type == Qtype.LAZY)
4431                 return match1(matcher, i, j, seq);
4432             else
4433                 return match2(matcher, i, j, seq);
4434         }
4435         // Greedy match.
4436         // i is the index to start matching at
4437         // j is the number of atoms that have matched
4438         boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
4439             if (j &gt;= cmax) {
4440                 // We have matched the maximum... continue with the rest of
4441                 // the regular expression
4442                 return next.match(matcher, i, seq);
4443             }
4444             int backLimit = j;
4445             while (atom.match(matcher, i, seq)) {
4446                 // k is the length of this match
4447                 int k = matcher.last - i;
4448                 if (k == 0) // Zero length match
4449                     break;
4450                 // Move up index and number matched
4451                 i = matcher.last;
4452                 j++;
4453                 // We are greedy so match as many as we can
4454                 while (j &lt; cmax) {
4455                     if (!atom.match(matcher, i, seq))
4456                         break;
4457                     if (i + k != matcher.last) {
4458                         if (match0(matcher, matcher.last, j+1, seq))
4459                             return true;
4460                         break;
4461                     }
4462                     i += k;
4463                     j++;
4464                 }
4465                 // Handle backing off if match fails
4466                 while (j &gt;= backLimit) {
4467                    if (next.match(matcher, i, seq))
4468                         return true;
4469                     i -= k;
4470                     j--;
4471                 }
4472                 return false;
4473             }
4474             return next.match(matcher, i, seq);
4475         }
4476         // Reluctant match. At this point, the minimum has been satisfied.
4477         // i is the index to start matching at
4478         // j is the number of atoms that have matched
4479         boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
4480             for (;;) {
4481                 // Try finishing match without consuming any more
4482                 if (next.match(matcher, i, seq))
4483                     return true;
4484                 // At the maximum, no match found
4485                 if (j &gt;= cmax)
4486                     return false;
4487                 // Okay, must try one more atom
4488                 if (!atom.match(matcher, i, seq))
4489                     return false;
4490                 // If we haven&#39;t moved forward then must break out
4491                 if (i == matcher.last)
4492                     return false;
4493                 // Move up index and number matched
4494                 i = matcher.last;
4495                 j++;
4496             }
4497         }
4498         boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
4499             for (; j &lt; cmax; j++) {
4500                 if (!atom.match(matcher, i, seq))
4501                     break;
4502                 if (i == matcher.last)
4503                     break;
4504                 i = matcher.last;
4505             }
4506             return next.match(matcher, i, seq);
4507         }
4508         boolean study(TreeInfo info) {
4509             // Save original info
4510             int minL = info.minLength;
4511             int maxL = info.maxLength;
4512             boolean maxV = info.maxValid;
4513             boolean detm = info.deterministic;
4514             info.reset();
4515 
4516             atom.study(info);
4517 
4518             int temp = info.minLength * cmin + minL;
4519             if (temp &lt; minL) {
4520                 temp = 0xFFFFFFF; // arbitrary large number
4521             }
4522             info.minLength = temp;
4523 
4524             if (maxV &amp; info.maxValid) {
4525                 temp = info.maxLength * cmax + maxL;
4526                 info.maxLength = temp;
4527                 if (temp &lt; maxL) {
4528                     info.maxValid = false;
4529                 }
4530             } else {
4531                 info.maxValid = false;
4532             }
4533 
4534             if (info.deterministic &amp;&amp; cmin == cmax)
4535                 info.deterministic = detm;
4536             else
4537                 info.deterministic = false;
4538             return next.study(info);
4539         }
4540     }
4541 
4542     /**
4543      * Handles the curly-brace style repetition with a specified minimum and
4544      * maximum occurrences in deterministic cases. This is an iterative
4545      * optimization over the Prolog and Loop system which would handle this
4546      * in a recursive way. The * quantifier is handled as a special case.
4547      * If capture is true then this class saves group settings and ensures
4548      * that groups are unset when backing off of a group match.
4549      */
4550     static final class GroupCurly extends Node {
4551         Node atom;
4552         Qtype type;
4553         int cmin;
4554         int cmax;
4555         int localIndex;
4556         int groupIndex;
4557         boolean capture;
4558 
4559         GroupCurly(Node node, int cmin, int cmax, Qtype type, int local,
4560                    int group, boolean capture) {
4561             this.atom = node;
4562             this.type = type;
4563             this.cmin = cmin;
4564             this.cmax = cmax;
4565             this.localIndex = local;
4566             this.groupIndex = group;
4567             this.capture = capture;
4568         }
4569         boolean match(Matcher matcher, int i, CharSequence seq) {
4570             int[] groups = matcher.groups;
4571             int[] locals = matcher.locals;
4572             int save0 = locals[localIndex];
4573             int save1 = 0;
4574             int save2 = 0;
4575 
4576             if (capture) {
4577                 save1 = groups[groupIndex];
4578                 save2 = groups[groupIndex+1];
4579             }
4580 
4581             // Notify GroupTail there is no need to setup group info
4582             // because it will be set here
4583             locals[localIndex] = -1;
4584 
4585             boolean ret = true;
4586             for (int j = 0; j &lt; cmin; j++) {
4587                 if (atom.match(matcher, i, seq)) {
4588                     if (capture) {
4589                         groups[groupIndex] = i;
4590                         groups[groupIndex+1] = matcher.last;
4591                     }
4592                     i = matcher.last;
4593                 } else {
4594                     ret = false;
4595                     break;
4596                 }
4597             }
4598             if (ret) {
4599                 if (type == Qtype.GREEDY) {
4600                     ret = match0(matcher, i, cmin, seq);
4601                 } else if (type == Qtype.LAZY) {
4602                     ret = match1(matcher, i, cmin, seq);
4603                 } else {
4604                     ret = match2(matcher, i, cmin, seq);
4605                 }
4606             }
4607             if (!ret) {
4608                 locals[localIndex] = save0;
4609                 if (capture) {
4610                     groups[groupIndex] = save1;
4611                     groups[groupIndex+1] = save2;
4612                 }
4613             }
4614             return ret;
4615         }
4616         // Aggressive group match
4617         boolean match0(Matcher matcher, int i, int j, CharSequence seq) {
4618             // don&#39;t back off passing the starting &quot;j&quot;
4619             int min = j;
4620             int[] groups = matcher.groups;
4621             int save0 = 0;
4622             int save1 = 0;
4623             if (capture) {
4624                 save0 = groups[groupIndex];
4625                 save1 = groups[groupIndex+1];
4626             }
4627             for (;;) {
4628                 if (j &gt;= cmax)
4629                     break;
4630                 if (!atom.match(matcher, i, seq))
4631                     break;
4632                 int k = matcher.last - i;
4633                 if (k &lt;= 0) {
4634                     if (capture) {
4635                         groups[groupIndex] = i;
4636                         groups[groupIndex+1] = i + k;
4637                     }
4638                     i = i + k;
4639                     break;
4640                 }
4641                 for (;;) {
4642                     if (capture) {
4643                         groups[groupIndex] = i;
4644                         groups[groupIndex+1] = i + k;
4645                     }
4646                     i = i + k;
4647                     if (++j &gt;= cmax)
4648                         break;
4649                     if (!atom.match(matcher, i, seq))
4650                         break;
4651                     if (i + k != matcher.last) {
4652                         if (match0(matcher, i, j, seq))
4653                             return true;
4654                         break;
4655                     }
4656                 }
4657                 while (j &gt; min) {
4658                     if (next.match(matcher, i, seq)) {
4659                         if (capture) {
4660                             groups[groupIndex+1] = i;
4661                             groups[groupIndex] = i - k;
4662                         }
4663                         return true;
4664                     }
4665                     // backing off
4666                     i = i - k;
4667                     if (capture) {
4668                         groups[groupIndex+1] = i;
4669                         groups[groupIndex] = i - k;
4670                     }
4671                     j--;
4672 
4673                 }
4674                 break;
4675             }
4676             if (capture) {
4677                 groups[groupIndex] = save0;
4678                 groups[groupIndex+1] = save1;
4679             }
4680             return next.match(matcher, i, seq);
4681         }
4682         // Reluctant matching
4683         boolean match1(Matcher matcher, int i, int j, CharSequence seq) {
4684             for (;;) {
4685                 if (next.match(matcher, i, seq))
4686                     return true;
4687                 if (j &gt;= cmax)
4688                     return false;
4689                 if (!atom.match(matcher, i, seq))
4690                     return false;
4691                 if (i == matcher.last)
4692                     return false;
4693                 if (capture) {
4694                     matcher.groups[groupIndex] = i;
4695                     matcher.groups[groupIndex+1] = matcher.last;
4696                 }
4697                 i = matcher.last;
4698                 j++;
4699             }
4700         }
4701         // Possessive matching
4702         boolean match2(Matcher matcher, int i, int j, CharSequence seq) {
4703             for (; j &lt; cmax; j++) {
4704                 if (!atom.match(matcher, i, seq)) {
4705                     break;
4706                 }
4707                 if (capture) {
4708                     matcher.groups[groupIndex] = i;
4709                     matcher.groups[groupIndex+1] = matcher.last;
4710                 }
4711                 if (i == matcher.last) {
4712                     break;
4713                 }
4714                 i = matcher.last;
4715             }
4716             return next.match(matcher, i, seq);
4717         }
4718         boolean study(TreeInfo info) {
4719             // Save original info
4720             int minL = info.minLength;
4721             int maxL = info.maxLength;
4722             boolean maxV = info.maxValid;
4723             boolean detm = info.deterministic;
4724             info.reset();
4725 
4726             atom.study(info);
4727 
4728             int temp = info.minLength * cmin + minL;
4729             if (temp &lt; minL) {
4730                 temp = 0xFFFFFFF; // Arbitrary large number
4731             }
4732             info.minLength = temp;
4733 
4734             if (maxV &amp; info.maxValid) {
4735                 temp = info.maxLength * cmax + maxL;
4736                 info.maxLength = temp;
4737                 if (temp &lt; maxL) {
4738                     info.maxValid = false;
4739                 }
4740             } else {
4741                 info.maxValid = false;
4742             }
4743 
4744             if (info.deterministic &amp;&amp; cmin == cmax) {
4745                 info.deterministic = detm;
4746             } else {
4747                 info.deterministic = false;
4748             }
4749             return next.study(info);
4750         }
4751     }
4752 
4753     /**
4754      * A Guard node at the end of each atom node in a Branch. It
4755      * serves the purpose of chaining the &quot;match&quot; operation to
4756      * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
4757      * of each atom node without including the TreeInfo of the
4758      * &quot;next&quot;.
4759      */
4760     static final class BranchConn extends Node {
4761         BranchConn() {}
4762         boolean match(Matcher matcher, int i, CharSequence seq) {
4763             return next.match(matcher, i, seq);
4764         }
4765         boolean study(TreeInfo info) {
4766             return info.deterministic;
4767         }
4768     }
4769 
4770     /**
4771      * Handles the branching of alternations. Note this is also used for
4772      * the ? quantifier to branch between the case where it matches once
4773      * and where it does not occur.
4774      */
4775     static final class Branch extends Node {
4776         Node[] atoms = new Node[2];
4777         int size = 2;
4778         BranchConn conn;
4779         Branch(Node first, Node second, BranchConn branchConn) {
4780             conn = branchConn;
4781             atoms[0] = first;
4782             atoms[1] = second;
4783         }
4784 
4785         void add(Node node) {
4786             if (size &gt;= atoms.length) {
4787                 int len = ArraysSupport.newLength(size,
4788                         1,    /* minimum growth */
4789                         size  /* preferred growth */);
4790                 atoms = Arrays.copyOf(atoms, len);
4791             }
4792             atoms[size++] = node;
4793         }
4794 
4795         boolean match(Matcher matcher, int i, CharSequence seq) {
4796             for (int n = 0; n &lt; size; n++) {
4797                 if (atoms[n] == null) {
4798                     if (conn.next.match(matcher, i, seq))
4799                         return true;
4800                 } else if (atoms[n].match(matcher, i, seq)) {
4801                     return true;
4802                 }
4803             }
4804             return false;
4805         }
4806 
4807         boolean study(TreeInfo info) {
4808             int minL = info.minLength;
4809             int maxL = info.maxLength;
4810             boolean maxV = info.maxValid;
4811 
4812             int minL2 = Integer.MAX_VALUE; //arbitrary large enough num
4813             int maxL2 = -1;
4814             for (int n = 0; n &lt; size; n++) {
4815                 info.reset();
4816                 if (atoms[n] != null)
4817                     atoms[n].study(info);
4818                 minL2 = Math.min(minL2, info.minLength);
4819                 maxL2 = Math.max(maxL2, info.maxLength);
4820                 maxV = (maxV &amp; info.maxValid);
4821             }
4822 
4823             minL += minL2;
4824             maxL += maxL2;
4825 
4826             info.reset();
4827             conn.next.study(info);
4828 
4829             info.minLength += minL;
4830             info.maxLength += maxL;
4831             info.maxValid &amp;= maxV;
4832             info.deterministic = false;
4833             return false;
4834         }
4835     }
4836 
4837     /**
4838      * The GroupHead saves the location where the group begins in the locals
4839      * and restores them when the match is done.
4840      *
4841      * The matchRef is used when a reference to this group is accessed later
4842      * in the expression. The locals will have a negative value in them to
4843      * indicate that we do not want to unset the group if the reference
4844      * doesn&#39;t match.
4845      */
4846     static final class GroupHead extends Node {
4847         int localIndex;
4848         GroupTail tail;    // for debug/print only, match does not need to know
4849         GroupHead(int localCount) {
4850             localIndex = localCount;
4851         }
4852         boolean match(Matcher matcher, int i, CharSequence seq) {
4853             int save = matcher.locals[localIndex];
4854             matcher.locals[localIndex] = i;
4855             boolean ret = next.match(matcher, i, seq);
4856             matcher.locals[localIndex] = save;
4857             return ret;
4858         }
4859     }
4860 
4861     /**
4862      * The GroupTail handles the setting of group beginning and ending
4863      * locations when groups are successfully matched. It must also be able to
4864      * unset groups that have to be backed off of.
4865      *
4866      * The GroupTail node is also used when a previous group is referenced,
4867      * and in that case no group information needs to be set.
4868      */
4869     static final class GroupTail extends Node {
4870         int localIndex;
4871         int groupIndex;
4872         GroupTail(int localCount, int groupCount) {
4873             localIndex = localCount;
4874             groupIndex = groupCount + groupCount;
4875         }
4876         boolean match(Matcher matcher, int i, CharSequence seq) {
4877             int tmp = matcher.locals[localIndex];
4878             if (tmp &gt;= 0) { // This is the normal group case.
4879                 // Save the group so we can unset it if it
4880                 // backs off of a match.
4881                 int groupStart = matcher.groups[groupIndex];
4882                 int groupEnd = matcher.groups[groupIndex+1];
4883 
4884                 matcher.groups[groupIndex] = tmp;
4885                 matcher.groups[groupIndex+1] = i;
4886                 if (next.match(matcher, i, seq)) {
4887                     return true;
4888                 }
4889                 matcher.groups[groupIndex] = groupStart;
4890                 matcher.groups[groupIndex+1] = groupEnd;
4891                 return false;
4892             } else {
4893                 // This is a group reference case. We don&#39;t need to save any
4894                 // group info because it isn&#39;t really a group.
4895                 matcher.last = i;
4896                 return true;
4897             }
4898         }
4899     }
4900 
4901     /**
4902      * This sets up a loop to handle a recursive quantifier structure.
4903      */
4904     static final class Prolog extends Node {
4905         Loop loop;
4906         Prolog(Loop loop) {
4907             this.loop = loop;
4908         }
4909         boolean match(Matcher matcher, int i, CharSequence seq) {
4910             return loop.matchInit(matcher, i, seq);
4911         }
4912         boolean study(TreeInfo info) {
4913             return loop.study(info);
4914         }
4915     }
4916 
4917     /**
4918      * Handles the repetition count for a greedy Curly. The matchInit
4919      * is called from the Prolog to save the index of where the group
4920      * beginning is stored. A zero length group check occurs in the
4921      * normal match but is skipped in the matchInit.
4922      */
4923     static class Loop extends Node {
4924         Node body;
4925         int countIndex; // local count index in matcher locals
4926         int beginIndex; // group beginning index
4927         int cmin, cmax;
4928         int posIndex;
4929         Loop(int countIndex, int beginIndex) {
4930             this.countIndex = countIndex;
4931             this.beginIndex = beginIndex;
4932             this.posIndex = -1;
4933         }
4934         boolean match(Matcher matcher, int i, CharSequence seq) {
4935             // Avoid infinite loop in zero-length case.
4936             if (i &gt; matcher.locals[beginIndex]) {
4937                 int count = matcher.locals[countIndex];
4938 
4939                 // This block is for before we reach the minimum
4940                 // iterations required for the loop to match
4941                 if (count &lt; cmin) {
4942                     matcher.locals[countIndex] = count + 1;
4943                     boolean b = body.match(matcher, i, seq);
4944                     // If match failed we must backtrack, so
4945                     // the loop count should NOT be incremented
4946                     if (!b)
4947                         matcher.locals[countIndex] = count;
4948                     // Return success or failure since we are under
4949                     // minimum
4950                     return b;
4951                 }
4952                 // This block is for after we have the minimum
4953                 // iterations required for the loop to match
4954                 if (count &lt; cmax) {
4955                     // Let&#39;s check if we have already tried and failed
4956                     // at this starting position &quot;i&quot; in the past.
4957                     // If yes, then just return false wihtout trying
4958                     // again, to stop the exponential backtracking.
4959                     if (posIndex != -1 &amp;&amp;
4960                         matcher.localsPos[posIndex].contains(i)) {
4961                         return next.match(matcher, i, seq);
4962                     }
4963                     matcher.locals[countIndex] = count + 1;
4964                     boolean b = body.match(matcher, i, seq);
4965                     // If match failed we must backtrack, so
4966                     // the loop count should NOT be incremented
4967                     if (b)
4968                         return true;
4969                     matcher.locals[countIndex] = count;
4970                     // save the failed position
4971                     if (posIndex != -1) {
4972                         matcher.localsPos[posIndex].add(i);
4973                     }
4974                 }
4975             }
4976             return next.match(matcher, i, seq);
4977         }
4978         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
4979             int save = matcher.locals[countIndex];
4980             boolean ret;
4981             if (posIndex != -1 &amp;&amp; matcher.localsPos[posIndex] == null) {
4982                 matcher.localsPos[posIndex] = new IntHashSet();
4983             }
4984             if (0 &lt; cmin) {
4985                 matcher.locals[countIndex] = 1;
4986                 ret = body.match(matcher, i, seq);
4987             } else if (0 &lt; cmax) {
4988                 matcher.locals[countIndex] = 1;
4989                 ret = body.match(matcher, i, seq);
4990                 if (ret == false)
4991                     ret = next.match(matcher, i, seq);
4992             } else {
4993                 ret = next.match(matcher, i, seq);
4994             }
4995             matcher.locals[countIndex] = save;
4996             return ret;
4997         }
4998         boolean study(TreeInfo info) {
4999             info.maxValid = false;
5000             info.deterministic = false;
5001             return false;
5002         }
5003     }
5004 
5005     /**
5006      * Handles the repetition count for a reluctant Curly. The matchInit
5007      * is called from the Prolog to save the index of where the group
5008      * beginning is stored. A zero length group check occurs in the
5009      * normal match but is skipped in the matchInit.
5010      */
5011     static final class LazyLoop extends Loop {
5012         LazyLoop(int countIndex, int beginIndex) {
5013             super(countIndex, beginIndex);
5014         }
5015         boolean match(Matcher matcher, int i, CharSequence seq) {
5016             // Check for zero length group
5017             if (i &gt; matcher.locals[beginIndex]) {
5018                 int count = matcher.locals[countIndex];
5019                 if (count &lt; cmin) {
5020                     matcher.locals[countIndex] = count + 1;
5021                     boolean result = body.match(matcher, i, seq);
5022                     // If match failed we must backtrack, so
5023                     // the loop count should NOT be incremented
5024                     if (!result)
5025                         matcher.locals[countIndex] = count;
5026                     return result;
5027                 }
5028                 if (next.match(matcher, i, seq))
5029                     return true;
5030                 if (count &lt; cmax) {
5031                     matcher.locals[countIndex] = count + 1;
5032                     boolean result = body.match(matcher, i, seq);
5033                     // If match failed we must backtrack, so
5034                     // the loop count should NOT be incremented
5035                     if (!result)
5036                         matcher.locals[countIndex] = count;
5037                     return result;
5038                 }
5039                 return false;
5040             }
5041             return next.match(matcher, i, seq);
5042         }
5043         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
5044             int save = matcher.locals[countIndex];
5045             boolean ret = false;
5046             if (0 &lt; cmin) {
5047                 matcher.locals[countIndex] = 1;
5048                 ret = body.match(matcher, i, seq);
5049             } else if (next.match(matcher, i, seq)) {
5050                 ret = true;
5051             } else if (0 &lt; cmax) {
5052                 matcher.locals[countIndex] = 1;
5053                 ret = body.match(matcher, i, seq);
5054             }
5055             matcher.locals[countIndex] = save;
5056             return ret;
5057         }
5058         boolean study(TreeInfo info) {
5059             info.maxValid = false;
5060             info.deterministic = false;
5061             return false;
5062         }
5063     }
5064 
5065     /**
5066      * Refers to a group in the regular expression. Attempts to match
5067      * whatever the group referred to last matched.
5068      */
5069     static class BackRef extends Node {
5070         int groupIndex;
5071         BackRef(int groupCount) {
5072             super();
5073             groupIndex = groupCount + groupCount;
5074         }
5075         boolean match(Matcher matcher, int i, CharSequence seq) {
5076             int j = matcher.groups[groupIndex];
5077             int k = matcher.groups[groupIndex+1];
5078 
5079             int groupSize = k - j;
5080             // If the referenced group didn&#39;t match, neither can this
5081             if (j &lt; 0)
5082                 return false;
5083 
5084             // If there isn&#39;t enough input left no match
5085             if (i + groupSize &gt; matcher.to) {
5086                 matcher.hitEnd = true;
5087                 return false;
5088             }
5089             // Check each new char to make sure it matches what the group
5090             // referenced matched last time around
5091             for (int index=0; index&lt;groupSize; index++)
5092                 if (seq.charAt(i+index) != seq.charAt(j+index))
5093                     return false;
5094 
5095             return next.match(matcher, i+groupSize, seq);
5096         }
5097         boolean study(TreeInfo info) {
5098             info.maxValid = false;
5099             return next.study(info);
5100         }
5101     }
5102 
5103     static class CIBackRef extends Node {
5104         int groupIndex;
5105         boolean doUnicodeCase;
5106         CIBackRef(int groupCount, boolean doUnicodeCase) {
5107             super();
5108             groupIndex = groupCount + groupCount;
5109             this.doUnicodeCase = doUnicodeCase;
5110         }
5111         boolean match(Matcher matcher, int i, CharSequence seq) {
5112             int j = matcher.groups[groupIndex];
5113             int k = matcher.groups[groupIndex+1];
5114 
5115             int groupSize = k - j;
5116 
5117             // If the referenced group didn&#39;t match, neither can this
5118             if (j &lt; 0)
5119                 return false;
5120 
5121             // If there isn&#39;t enough input left no match
5122             if (i + groupSize &gt; matcher.to) {
5123                 matcher.hitEnd = true;
5124                 return false;
5125             }
5126 
5127             // Check each new char to make sure it matches what the group
5128             // referenced matched last time around
5129             int x = i;
5130             for (int index=0; index&lt;groupSize; index++) {
5131                 int c1 = Character.codePointAt(seq, x);
5132                 int c2 = Character.codePointAt(seq, j);
5133                 if (c1 != c2) {
5134                     if (doUnicodeCase) {
5135                         int cc1 = Character.toUpperCase(c1);
5136                         int cc2 = Character.toUpperCase(c2);
5137                         if (cc1 != cc2 &amp;&amp;
5138                             Character.toLowerCase(cc1) !=
5139                             Character.toLowerCase(cc2))
5140                             return false;
5141                     } else {
5142                         if (ASCII.toLower(c1) != ASCII.toLower(c2))
5143                             return false;
5144                     }
5145                 }
5146                 x += Character.charCount(c1);
5147                 j += Character.charCount(c2);
5148             }
5149 
5150             return next.match(matcher, i+groupSize, seq);
5151         }
5152         boolean study(TreeInfo info) {
5153             info.maxValid = false;
5154             return next.study(info);
5155         }
5156     }
5157 
5158     /**
5159      * Searches until the next instance of its atom. This is useful for
5160      * finding the atom efficiently without passing an instance of it
5161      * (greedy problem) and without a lot of wasted search time (reluctant
5162      * problem).
5163      */
5164     static final class First extends Node {
5165         Node atom;
5166         First(Node node) {
5167             this.atom = BnM.optimize(node);
5168         }
5169         boolean match(Matcher matcher, int i, CharSequence seq) {
5170             if (atom instanceof BnM) {
5171                 return atom.match(matcher, i, seq)
5172                     &amp;&amp; next.match(matcher, matcher.last, seq);
5173             }
5174             for (;;) {
5175                 if (i &gt; matcher.to) {
5176                     matcher.hitEnd = true;
5177                     return false;
5178                 }
5179                 if (atom.match(matcher, i, seq)) {
5180                     return next.match(matcher, matcher.last, seq);
5181                 }
5182                 i += countChars(seq, i, 1);
5183                 matcher.first++;
5184             }
5185         }
5186         boolean study(TreeInfo info) {
5187             atom.study(info);
5188             info.maxValid = false;
5189             info.deterministic = false;
5190             return next.study(info);
5191         }
5192     }
5193 
5194     /**
5195      * Zero width positive lookahead.
5196      */
5197     static final class Pos extends Node {
5198         Node cond;
5199         Pos(Node cond) {
5200             this.cond = cond;
5201         }
5202         boolean match(Matcher matcher, int i, CharSequence seq) {
5203             int savedTo = matcher.to;
5204             boolean conditionMatched;
5205 
5206             // Relax transparent region boundaries for lookahead
5207             if (matcher.transparentBounds)
5208                 matcher.to = matcher.getTextLength();
5209             try {
5210                 conditionMatched = cond.match(matcher, i, seq);
5211             } finally {
5212                 // Reinstate region boundaries
5213                 matcher.to = savedTo;
5214             }
5215             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5216         }
5217     }
5218 
5219     /**
5220      * Zero width negative lookahead.
5221      */
5222     static final class Neg extends Node {
5223         Node cond;
5224         Neg(Node cond) {
5225             this.cond = cond;
5226         }
5227         boolean match(Matcher matcher, int i, CharSequence seq) {
5228             int savedTo = matcher.to;
5229             boolean conditionMatched;
5230 
5231             // Relax transparent region boundaries for lookahead
5232             if (matcher.transparentBounds)
5233                 matcher.to = matcher.getTextLength();
5234             try {
5235                 if (i &lt; matcher.to) {
5236                     conditionMatched = !cond.match(matcher, i, seq);
5237                 } else {
5238                     // If a negative lookahead succeeds then more input
5239                     // could cause it to fail!
5240                     matcher.requireEnd = true;
5241                     conditionMatched = !cond.match(matcher, i, seq);
5242                 }
5243             } finally {
5244                 // Reinstate region boundaries
5245                 matcher.to = savedTo;
5246             }
5247             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5248         }
5249     }
5250 
5251     /**
5252      * For use with lookbehinds; matches the position where the lookbehind
5253      * was encountered.
5254      */
5255     static class LookBehindEndNode extends Node {
5256         private LookBehindEndNode() {} // Singleton
5257 
5258         static LookBehindEndNode INSTANCE = new LookBehindEndNode();
5259 
5260         boolean match(Matcher matcher, int i, CharSequence seq) {
5261             return i == matcher.lookbehindTo;
5262         }
5263     }
5264 
5265     /**
5266      * Zero width positive lookbehind.
5267      */
5268     static class Behind extends Node {
5269         Node cond;
5270         int rmax, rmin;
5271         Behind(Node cond, int rmax, int rmin) {
5272             this.cond = cond;
5273             this.rmax = rmax;
5274             this.rmin = rmin;
5275         }
5276 
5277         boolean match(Matcher matcher, int i, CharSequence seq) {
5278             int savedFrom = matcher.from;
5279             boolean conditionMatched = false;
5280             int startIndex = (!matcher.transparentBounds) ?
5281                              matcher.from : 0;
5282             int from = Math.max(i - rmax, startIndex);
5283             // Set end boundary
5284             int savedLBT = matcher.lookbehindTo;
5285             matcher.lookbehindTo = i;
5286             // Relax transparent region boundaries for lookbehind
5287             if (matcher.transparentBounds)
5288                 matcher.from = 0;
5289             for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {
5290                 conditionMatched = cond.match(matcher, j, seq);
5291             }
5292             matcher.from = savedFrom;
5293             matcher.lookbehindTo = savedLBT;
5294             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5295         }
5296     }
5297 
5298     /**
5299      * Zero width positive lookbehind, including supplementary
5300      * characters or unpaired surrogates.
5301      */
5302     static final class BehindS extends Behind {
5303         BehindS(Node cond, int rmax, int rmin) {
5304             super(cond, rmax, rmin);
5305         }
5306         boolean match(Matcher matcher, int i, CharSequence seq) {
5307             int rmaxChars = countChars(seq, i, -rmax);
5308             int rminChars = countChars(seq, i, -rmin);
5309             int savedFrom = matcher.from;
5310             int startIndex = (!matcher.transparentBounds) ?
5311                              matcher.from : 0;
5312             boolean conditionMatched = false;
5313             int from = Math.max(i - rmaxChars, startIndex);
5314             // Set end boundary
5315             int savedLBT = matcher.lookbehindTo;
5316             matcher.lookbehindTo = i;
5317             // Relax transparent region boundaries for lookbehind
5318             if (matcher.transparentBounds)
5319                 matcher.from = 0;
5320 
5321             for (int j = i - rminChars;
5322                  !conditionMatched &amp;&amp; j &gt;= from;
5323                  j -= j&gt;from ? countChars(seq, j, -1) : 1) {
5324                 conditionMatched = cond.match(matcher, j, seq);
5325             }
5326             matcher.from = savedFrom;
5327             matcher.lookbehindTo = savedLBT;
5328             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5329         }
5330     }
5331 
5332     /**
5333      * Zero width negative lookbehind.
5334      */
5335     static class NotBehind extends Node {
5336         Node cond;
5337         int rmax, rmin;
5338         NotBehind(Node cond, int rmax, int rmin) {
5339             this.cond = cond;
5340             this.rmax = rmax;
5341             this.rmin = rmin;
5342         }
5343 
5344         boolean match(Matcher matcher, int i, CharSequence seq) {
5345             int savedLBT = matcher.lookbehindTo;
5346             int savedFrom = matcher.from;
5347             boolean conditionMatched = false;
5348             int startIndex = (!matcher.transparentBounds) ?
5349                              matcher.from : 0;
5350             int from = Math.max(i - rmax, startIndex);
5351             matcher.lookbehindTo = i;
5352             // Relax transparent region boundaries for lookbehind
5353             if (matcher.transparentBounds)
5354                 matcher.from = 0;
5355             for (int j = i - rmin; !conditionMatched &amp;&amp; j &gt;= from; j--) {
5356                 conditionMatched = cond.match(matcher, j, seq);
5357             }
5358             // Reinstate region boundaries
5359             matcher.from = savedFrom;
5360             matcher.lookbehindTo = savedLBT;
5361             return !conditionMatched &amp;&amp; next.match(matcher, i, seq);
5362         }
5363     }
5364 
5365     /**
5366      * Zero width negative lookbehind, including supplementary
5367      * characters or unpaired surrogates.
5368      */
5369     static final class NotBehindS extends NotBehind {
5370         NotBehindS(Node cond, int rmax, int rmin) {
5371             super(cond, rmax, rmin);
5372         }
5373         boolean match(Matcher matcher, int i, CharSequence seq) {
5374             int rmaxChars = countChars(seq, i, -rmax);
5375             int rminChars = countChars(seq, i, -rmin);
5376             int savedFrom = matcher.from;
5377             int savedLBT = matcher.lookbehindTo;
5378             boolean conditionMatched = false;
5379             int startIndex = (!matcher.transparentBounds) ?
5380                              matcher.from : 0;
5381             int from = Math.max(i - rmaxChars, startIndex);
5382             matcher.lookbehindTo = i;
5383             // Relax transparent region boundaries for lookbehind
5384             if (matcher.transparentBounds)
5385                 matcher.from = 0;
5386             for (int j = i - rminChars;
5387                  !conditionMatched &amp;&amp; j &gt;= from;
5388                  j -= j&gt;from ? countChars(seq, j, -1) : 1) {
5389                 conditionMatched = cond.match(matcher, j, seq);
5390             }
5391             //Reinstate region boundaries
5392             matcher.from = savedFrom;
5393             matcher.lookbehindTo = savedLBT;
5394             return !conditionMatched &amp;&amp; next.match(matcher, i, seq);
5395         }
5396     }
5397 
5398     /**
5399      * Handles word boundaries. Includes a field to allow this one class to
5400      * deal with the different types of word boundaries we can match. The word
5401      * characters include underscores, letters, and digits. Non spacing marks
5402      * can are also part of a word if they have a base character, otherwise
5403      * they are ignored for purposes of finding word boundaries.
5404      */
5405     static final class Bound extends Node {
5406         static int LEFT = 0x1;
5407         static int RIGHT= 0x2;
5408         static int BOTH = 0x3;
5409         static int NONE = 0x4;
5410         int type;
5411         boolean useUWORD;
5412         Bound(int n, boolean useUWORD) {
5413             type = n;
5414             this.useUWORD = useUWORD;
5415         }
5416 
5417         boolean isWord(int ch) {
5418             return useUWORD ? CharPredicates.WORD().is(ch)
5419                             : (ch == &#39;_&#39; || Character.isLetterOrDigit(ch));
5420         }
5421 
5422         int check(Matcher matcher, int i, CharSequence seq) {
5423             int ch;
5424             boolean left = false;
5425             int startIndex = matcher.from;
5426             int endIndex = matcher.to;
5427             if (matcher.transparentBounds) {
5428                 startIndex = 0;
5429                 endIndex = matcher.getTextLength();
5430             }
5431             if (i &gt; startIndex) {
5432                 ch = Character.codePointBefore(seq, i);
5433                 left = (isWord(ch) ||
5434                     ((Character.getType(ch) == Character.NON_SPACING_MARK)
5435                      &amp;&amp; hasBaseCharacter(matcher, i-1, seq)));
5436             }
5437             boolean right = false;
5438             if (i &lt; endIndex) {
5439                 ch = Character.codePointAt(seq, i);
5440                 right = (isWord(ch) ||
5441                     ((Character.getType(ch) == Character.NON_SPACING_MARK)
5442                      &amp;&amp; hasBaseCharacter(matcher, i, seq)));
5443             } else {
5444                 // Tried to access char past the end
5445                 matcher.hitEnd = true;
5446                 // The addition of another char could wreck a boundary
5447                 matcher.requireEnd = true;
5448             }
5449             return ((left ^ right) ? (right ? LEFT : RIGHT) : NONE);
5450         }
5451         boolean match(Matcher matcher, int i, CharSequence seq) {
5452             return (check(matcher, i, seq) &amp; type) &gt; 0
5453                 &amp;&amp; next.match(matcher, i, seq);
5454         }
5455     }
5456 
5457     /**
5458      * Non spacing marks only count as word characters in bounds calculations
5459      * if they have a base character.
5460      */
5461     private static boolean hasBaseCharacter(Matcher matcher, int i,
5462                                             CharSequence seq)
5463     {
5464         int start = (!matcher.transparentBounds) ?
5465             matcher.from : 0;
5466         for (int x=i; x &gt;= start; x--) {
5467             int ch = Character.codePointAt(seq, x);
5468             if (Character.isLetterOrDigit(ch))
5469                 return true;
5470             if (Character.getType(ch) == Character.NON_SPACING_MARK)
5471                 continue;
5472             return false;
5473         }
5474         return false;
5475     }
5476 
5477     /**
5478      * Attempts to match a slice in the input using the Boyer-Moore string
5479      * matching algorithm. The algorithm is based on the idea that the
5480      * pattern can be shifted farther ahead in the search text if it is
5481      * matched right to left.
5482      * &lt;p&gt;
5483      * The pattern is compared to the input one character at a time, from
5484      * the rightmost character in the pattern to the left. If the characters
5485      * all match the pattern has been found. If a character does not match,
5486      * the pattern is shifted right a distance that is the maximum of two
5487      * functions, the bad character shift and the good suffix shift. This
5488      * shift moves the attempted match position through the input more
5489      * quickly than a naive one position at a time check.
5490      * &lt;p&gt;
5491      * The bad character shift is based on the character from the text that
5492      * did not match. If the character does not appear in the pattern, the
5493      * pattern can be shifted completely beyond the bad character. If the
5494      * character does occur in the pattern, the pattern can be shifted to
5495      * line the pattern up with the next occurrence of that character.
5496      * &lt;p&gt;
5497      * The good suffix shift is based on the idea that some subset on the right
5498      * side of the pattern has matched. When a bad character is found, the
5499      * pattern can be shifted right by the pattern length if the subset does
5500      * not occur again in pattern, or by the amount of distance to the
5501      * next occurrence of the subset in the pattern.
5502      *
5503      * Boyer-Moore search methods adapted from code by Amy Yu.
5504      */
5505     static class BnM extends Node {
5506         int[] buffer;
5507         int[] lastOcc;
5508         int[] optoSft;
5509 
5510         /**
5511          * Pre calculates arrays needed to generate the bad character
5512          * shift and the good suffix shift. Only the last seven bits
5513          * are used to see if chars match; This keeps the tables small
5514          * and covers the heavily used ASCII range, but occasionally
5515          * results in an aliased match for the bad character shift.
5516          */
5517         static Node optimize(Node node) {
5518             if (!(node instanceof Slice)) {
5519                 return node;
5520             }
5521 
5522             int[] src = ((Slice) node).buffer;
5523             int patternLength = src.length;
5524             // The BM algorithm requires a bit of overhead;
5525             // If the pattern is short don&#39;t use it, since
5526             // a shift larger than the pattern length cannot
5527             // be used anyway.
5528             if (patternLength &lt; 4) {
5529                 return node;
5530             }
5531             int i, j;
5532             int[] lastOcc = new int[128];
5533             int[] optoSft = new int[patternLength];
5534             // Precalculate part of the bad character shift
5535             // It is a table for where in the pattern each
5536             // lower 7-bit value occurs
5537             for (i = 0; i &lt; patternLength; i++) {
5538                 lastOcc[src[i]&amp;0x7F] = i + 1;
5539             }
5540             // Precalculate the good suffix shift
5541             // i is the shift amount being considered
5542 NEXT:       for (i = patternLength; i &gt; 0; i--) {
5543                 // j is the beginning index of suffix being considered
5544                 for (j = patternLength - 1; j &gt;= i; j--) {
5545                     // Testing for good suffix
5546                     if (src[j] == src[j-i]) {
5547                         // src[j..len] is a good suffix
5548                         optoSft[j-1] = i;
5549                     } else {
5550                         // No match. The array has already been
5551                         // filled up with correct values before.
5552                         continue NEXT;
5553                     }
5554                 }
5555                 // This fills up the remaining of optoSft
5556                 // any suffix can not have larger shift amount
5557                 // then its sub-suffix. Why???
5558                 while (j &gt; 0) {
5559                     optoSft[--j] = i;
5560                 }
5561             }
5562             // Set the guard value because of unicode compression
5563             optoSft[patternLength-1] = 1;
5564             if (node instanceof SliceS)
5565                 return new BnMS(src, lastOcc, optoSft, node.next);
5566             return new BnM(src, lastOcc, optoSft, node.next);
5567         }
5568         BnM(int[] src, int[] lastOcc, int[] optoSft, Node next) {
5569             this.buffer = src;
5570             this.lastOcc = lastOcc;
5571             this.optoSft = optoSft;
5572             this.next = next;
5573         }
5574         boolean match(Matcher matcher, int i, CharSequence seq) {
5575             int[] src = buffer;
5576             int patternLength = src.length;
5577             int last = matcher.to - patternLength;
5578 
5579             // Loop over all possible match positions in text
5580 NEXT:       while (i &lt;= last) {
5581                 // Loop over pattern from right to left
5582                 for (int j = patternLength - 1; j &gt;= 0; j--) {
5583                     int ch = seq.charAt(i+j);
5584                     if (ch != src[j]) {
5585                         // Shift search to the right by the maximum of the
5586                         // bad character shift and the good suffix shift
5587                         i += Math.max(j + 1 - lastOcc[ch&amp;0x7F], optoSft[j]);
5588                         continue NEXT;
5589                     }
5590                 }
5591                 // Entire pattern matched starting at i
5592                 matcher.first = i;
5593                 boolean ret = next.match(matcher, i + patternLength, seq);
5594                 if (ret) {
5595                     matcher.first = i;
5596                     matcher.groups[0] = matcher.first;
5597                     matcher.groups[1] = matcher.last;
5598                     return true;
5599                 }
5600                 i++;
5601             }
5602             // BnM is only used as the leading node in the unanchored case,
5603             // and it replaced its Start() which always searches to the end
5604             // if it doesn&#39;t find what it&#39;s looking for, so hitEnd is true.
5605             matcher.hitEnd = true;
5606             return false;
5607         }
5608         boolean study(TreeInfo info) {
5609             info.minLength += buffer.length;
5610             info.maxValid = false;
5611             return next.study(info);
5612         }
5613     }
5614 
5615     /**
5616      * Supplementary support version of BnM(). Unpaired surrogates are
5617      * also handled by this class.
5618      */
5619     static final class BnMS extends BnM {
5620         int lengthInChars;
5621 
5622         BnMS(int[] src, int[] lastOcc, int[] optoSft, Node next) {
5623             super(src, lastOcc, optoSft, next);
5624             for (int cp : buffer) {
5625                 lengthInChars += Character.charCount(cp);
5626             }
5627         }
5628         boolean match(Matcher matcher, int i, CharSequence seq) {
5629             int[] src = buffer;
5630             int patternLength = src.length;
5631             int last = matcher.to - lengthInChars;
5632 
5633             // Loop over all possible match positions in text
5634 NEXT:       while (i &lt;= last) {
5635                 // Loop over pattern from right to left
5636                 int ch;
5637                 for (int j = countChars(seq, i, patternLength), x = patternLength - 1;
5638                      j &gt; 0; j -= Character.charCount(ch), x--) {
5639                     ch = Character.codePointBefore(seq, i+j);
5640                     if (ch != src[x]) {
5641                         // Shift search to the right by the maximum of the
5642                         // bad character shift and the good suffix shift
5643                         int n = Math.max(x + 1 - lastOcc[ch&amp;0x7F], optoSft[x]);
5644                         i += countChars(seq, i, n);
5645                         continue NEXT;
5646                     }
5647                 }
5648                 // Entire pattern matched starting at i
5649                 matcher.first = i;
5650                 boolean ret = next.match(matcher, i + lengthInChars, seq);
5651                 if (ret) {
5652                     matcher.first = i;
5653                     matcher.groups[0] = matcher.first;
5654                     matcher.groups[1] = matcher.last;
5655                     return true;
5656                 }
5657                 i += countChars(seq, i, 1);
5658             }
5659             matcher.hitEnd = true;
5660             return false;
5661         }
5662     }
5663 
5664     @FunctionalInterface
5665     static interface CharPredicate {
5666         boolean is(int ch);
5667 
5668         default CharPredicate and(CharPredicate p) {
5669             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5670         }
5671         default CharPredicate union(CharPredicate p) {
5672             return ch -&gt; is(ch) || p.is(ch);
5673         }
5674         default CharPredicate union(CharPredicate p1,
5675                                     CharPredicate p2) {
5676             return ch -&gt; is(ch) || p1.is(ch) || p2.is(ch);
5677         }
5678         default CharPredicate negate() {
5679             return ch -&gt; !is(ch);
5680         }
5681     }
5682 
5683     static interface BmpCharPredicate extends CharPredicate {
5684 
5685         default CharPredicate and(CharPredicate p) {
5686             if (p instanceof BmpCharPredicate)
5687                 return (BmpCharPredicate)(ch -&gt; is(ch) &amp;&amp; p.is(ch));
5688             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5689         }
5690         default CharPredicate union(CharPredicate p) {
5691             if (p instanceof BmpCharPredicate)
5692                 return (BmpCharPredicate)(ch -&gt; is(ch) || p.is(ch));
5693             return ch -&gt; is(ch) || p.is(ch);
5694         }
5695         static CharPredicate union(CharPredicate... predicates) {
5696             CharPredicate cp = ch -&gt; {
5697                 for (CharPredicate p : predicates) {
5698                     if (!p.is(ch))
5699                         return false;
5700                 }
5701                 return true;
5702             };
5703             for (CharPredicate p : predicates) {
5704                 if (! (p instanceof BmpCharPredicate))
5705                     return cp;
5706             }
5707             return (BmpCharPredicate)cp;
5708         }
5709     }
5710 
5711     /**
5712      * matches a Perl vertical whitespace
5713      */
5714     static BmpCharPredicate VertWS() {
5715         return cp -&gt; (cp &gt;= 0x0A &amp;&amp; cp &lt;= 0x0D) ||
5716             cp == 0x85 || cp == 0x2028 || cp == 0x2029;
5717     }
5718 
5719     /**
5720      * matches a Perl horizontal whitespace
5721      */
5722     static BmpCharPredicate HorizWS() {
5723         return cp -&gt;
5724             cp == 0x09 || cp == 0x20 || cp == 0xa0 || cp == 0x1680 ||
5725             cp == 0x180e || cp &gt;= 0x2000 &amp;&amp; cp &lt;= 0x200a ||  cp == 0x202f ||
5726             cp == 0x205f || cp == 0x3000;
5727     }
5728 
5729     /**
5730      *  for the Unicode category ALL and the dot metacharacter when
5731      *  in dotall mode.
5732      */
5733     static CharPredicate ALL() {
5734         return ch -&gt; true;
5735     }
5736 
5737     /**
5738      * for the dot metacharacter when dotall is not enabled.
5739      */
5740     static CharPredicate DOT() {
5741         return ch -&gt;
5742             (ch != &#39;\n&#39; &amp;&amp; ch != &#39;\r&#39;
5743             &amp;&amp; (ch|1) != &#39;\u2029&#39;
5744             &amp;&amp; ch != &#39;\u0085&#39;);
5745     }
5746 
5747     /**
5748      *  the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.
5749      */
5750     static CharPredicate UNIXDOT() {
5751         return ch -&gt;  ch != &#39;\n&#39;;
5752     }
5753 
5754     /**
5755      * Indicate that matches a Supplementary Unicode character
5756      */
5757     static CharPredicate SingleS(int c) {
5758         return ch -&gt; ch == c;
5759     }
5760 
5761     /**
5762      * A bmp/optimized predicate of single
5763      */
5764     static BmpCharPredicate Single(int c) {
5765         return ch -&gt; ch == c;
5766     }
5767 
5768     /**
5769      * Case insensitive matches a given BMP character
5770      */
5771     static BmpCharPredicate SingleI(int lower, int upper) {
5772         return ch -&gt; ch == lower || ch == upper;
5773     }
5774 
5775     /**
5776      * Unicode case insensitive matches a given Unicode character
5777      */
5778     static CharPredicate SingleU(int lower) {
5779         return ch -&gt; lower == ch ||
5780                      lower == Character.toLowerCase(Character.toUpperCase(ch));
5781     }
5782 
5783     private static boolean inRange(int lower, int ch, int upper) {
5784         return lower &lt;= ch &amp;&amp; ch &lt;= upper;
5785     }
5786 
5787     /**
5788      * Charactrs within a explicit value range
5789      */
5790     static CharPredicate Range(int lower, int upper) {
5791         if (upper &lt; Character.MIN_HIGH_SURROGATE ||
5792             lower &gt; Character.MAX_HIGH_SURROGATE &amp;&amp;
5793             upper &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT)
5794             return (BmpCharPredicate)(ch -&gt; inRange(lower, ch, upper));
5795         return ch -&gt; inRange(lower, ch, upper);
5796     }
5797 
5798    /**
5799     * Charactrs within a explicit value range in a case insensitive manner.
5800     */
5801     static CharPredicate CIRange(int lower, int upper) {
5802         return ch -&gt; inRange(lower, ch, upper) ||
5803                      ASCII.isAscii(ch) &amp;&amp;
5804                      (inRange(lower, ASCII.toUpper(ch), upper) ||
5805                       inRange(lower, ASCII.toLower(ch), upper));
5806     }
5807 
5808     static CharPredicate CIRangeU(int lower, int upper) {
5809         return ch -&gt; {
5810             if (inRange(lower, ch, upper))
5811                 return true;
5812             int up = Character.toUpperCase(ch);
5813             return inRange(lower, up, upper) ||
5814                    inRange(lower, Character.toLowerCase(up), upper);
5815         };
5816     }
5817 
5818     /**
5819      *  This must be the very first initializer.
5820      */
5821     static final Node accept = new Node();
5822 
5823     static final Node lastAccept = new LastNode();
5824 
5825     /**
5826      * Creates a predicate that tests if this pattern is found in a given input
5827      * string.
5828      *
5829      * @apiNote
5830      * This method creates a predicate that behaves as if it creates a matcher
5831      * from the input sequence and then calls {@code find}, for example a
5832      * predicate of the form:
5833      * &lt;pre&gt;{@code
5834      *   s -&gt; matcher(s).find();
5835      * }&lt;/pre&gt;
5836      *
5837      * @return  The predicate which can be used for finding a match on a
5838      *          subsequence of a string
5839      * @since   1.8
5840      * @see     Matcher#find
5841      */
5842     public Predicate&lt;String&gt; asPredicate() {
5843         return s -&gt; matcher(s).find();
5844     }
5845 
5846     /**
5847      * Creates a predicate that tests if this pattern matches a given input string.
5848      *
5849      * @apiNote
5850      * This method creates a predicate that behaves as if it creates a matcher
5851      * from the input sequence and then calls {@code matches}, for example a
5852      * predicate of the form:
5853      * &lt;pre&gt;{@code
5854      *   s -&gt; matcher(s).matches();
5855      * }&lt;/pre&gt;
5856      *
5857      * @return  The predicate which can be used for matching an input string
5858      *          against this pattern.
5859      * @since   11
5860      * @see     Matcher#matches
5861      */
5862     public Predicate&lt;String&gt; asMatchPredicate() {
5863         return s -&gt; matcher(s).matches();
5864     }
5865 
5866     /**
5867      * Creates a stream from the given input sequence around matches of this
5868      * pattern.
5869      *
5870      * &lt;p&gt; The stream returned by this method contains each substring of the
5871      * input sequence that is terminated by another subsequence that matches
5872      * this pattern or is terminated by the end of the input sequence.  The
5873      * substrings in the stream are in the order in which they occur in the
5874      * input. Trailing empty strings will be discarded and not encountered in
5875      * the stream.
5876      *
5877      * &lt;p&gt; If this pattern does not match any subsequence of the input then
5878      * the resulting stream has just one element, namely the input sequence in
5879      * string form.
5880      *
5881      * &lt;p&gt; When there is a positive-width match at the beginning of the input
5882      * sequence then an empty leading substring is included at the beginning
5883      * of the stream. A zero-width match at the beginning however never produces
5884      * such empty leading substring.
5885      *
5886      * &lt;p&gt; If the input sequence is mutable, it must remain constant during the
5887      * execution of the terminal stream operation.  Otherwise, the result of the
5888      * terminal stream operation is undefined.
5889      *
5890      * @param   input
5891      *          The character sequence to be split
5892      *
5893      * @return  The stream of strings computed by splitting the input
5894      *          around matches of this pattern
5895      * @see     #split(CharSequence)
5896      * @since   1.8
5897      */
5898     public Stream&lt;String&gt; splitAsStream(final CharSequence input) {
5899         class MatcherIterator implements Iterator&lt;String&gt; {
5900             private Matcher matcher;
5901             // The start position of the next sub-sequence of input
5902             // when current == input.length there are no more elements
5903             private int current;
5904             // null if the next element, if any, needs to obtained
5905             private String nextElement;
5906             // &gt; 0 if there are N next empty elements
5907             private int emptyElementCount;
5908 
5909             public String next() {
5910                 if (!hasNext())
5911                     throw new NoSuchElementException();
5912 
5913                 if (emptyElementCount == 0) {
5914                     String n = nextElement;
5915                     nextElement = null;
5916                     return n;
5917                 } else {
5918                     emptyElementCount--;
5919                     return &quot;&quot;;
5920                 }
5921             }
5922 
5923             public boolean hasNext() {
5924                 if (matcher == null) {
5925                     matcher = matcher(input);
5926                     // If the input is an empty string then the result can only be a
5927                     // stream of the input.  Induce that by setting the empty
5928                     // element count to 1
5929                     emptyElementCount = input.length() == 0 ? 1 : 0;
5930                 }
5931                 if (nextElement != null || emptyElementCount &gt; 0)
5932                     return true;
5933 
5934                 if (current == input.length())
5935                     return false;
5936 
5937                 // Consume the next matching element
5938                 // Count sequence of matching empty elements
5939                 while (matcher.find()) {
5940                     nextElement = input.subSequence(current, matcher.start()).toString();
5941                     current = matcher.end();
5942                     if (!nextElement.isEmpty()) {
5943                         return true;
5944                     } else if (current &gt; 0) { // no empty leading substring for zero-width
5945                                               // match at the beginning of the input
5946                         emptyElementCount++;
5947                     }
5948                 }
5949 
5950                 // Consume last matching element
5951                 nextElement = input.subSequence(current, input.length()).toString();
5952                 current = input.length();
5953                 if (!nextElement.isEmpty()) {
5954                     return true;
5955                 } else {
5956                     // Ignore a terminal sequence of matching empty elements
5957                     emptyElementCount = 0;
5958                     nextElement = null;
5959                     return false;
5960                 }
5961             }
5962         }
5963         return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
5964                 new MatcherIterator(), Spliterator.ORDERED | Spliterator.NONNULL), false);
5965     }
5966 }
    </pre>
  </body>
</html>