<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;compiler/oopMap.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/block.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/chaitin.hpp&quot;
  35 #include &quot;opto/coalesce.hpp&quot;
  36 #include &quot;opto/connode.hpp&quot;
  37 #include &quot;opto/idealGraphPrinter.hpp&quot;
  38 #include &quot;opto/indexSet.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;
  40 #include &quot;opto/memnode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 
  46 #ifndef PRODUCT
  47 void LRG::dump() const {
  48   ttyLocker ttyl;
  49   tty-&gt;print(&quot;%d &quot;,num_regs());
  50   _mask.dump();
  51   if( _msize_valid ) {
  52     if( mask_size() == compute_mask_size() ) tty-&gt;print(&quot;, #%d &quot;,_mask_size);
  53     else tty-&gt;print(&quot;, #!!!_%d_vs_%d &quot;,_mask_size,_mask.Size());
  54   } else {
  55     tty-&gt;print(&quot;, #?(%d) &quot;,_mask.Size());
  56   }
  57 
  58   tty-&gt;print(&quot;EffDeg: &quot;);
  59   if( _degree_valid ) tty-&gt;print( &quot;%d &quot;, _eff_degree );
  60   else tty-&gt;print(&quot;? &quot;);
  61 
  62   if( is_multidef() ) {
  63     tty-&gt;print(&quot;MultiDef &quot;);
  64     if (_defs != NULL) {
  65       tty-&gt;print(&quot;(&quot;);
  66       for (int i = 0; i &lt; _defs-&gt;length(); i++) {
  67         tty-&gt;print(&quot;N%d &quot;, _defs-&gt;at(i)-&gt;_idx);
  68       }
  69       tty-&gt;print(&quot;) &quot;);
  70     }
  71   }
  72   else if( _def == 0 ) tty-&gt;print(&quot;Dead &quot;);
  73   else tty-&gt;print(&quot;Def: N%d &quot;,_def-&gt;_idx);
  74 
  75   tty-&gt;print(&quot;Cost:%4.2g Area:%4.2g Score:%4.2g &quot;,_cost,_area, score());
  76   // Flags
  77   if( _is_oop ) tty-&gt;print(&quot;Oop &quot;);
  78   if( _is_float ) tty-&gt;print(&quot;Float &quot;);
  79   if( _is_vector ) tty-&gt;print(&quot;Vector &quot;);
  80   if( _was_spilled1 ) tty-&gt;print(&quot;Spilled &quot;);
  81   if( _was_spilled2 ) tty-&gt;print(&quot;Spilled2 &quot;);
  82   if( _direct_conflict ) tty-&gt;print(&quot;Direct_conflict &quot;);
  83   if( _fat_proj ) tty-&gt;print(&quot;Fat &quot;);
  84   if( _was_lo ) tty-&gt;print(&quot;Lo &quot;);
  85   if( _has_copy ) tty-&gt;print(&quot;Copy &quot;);
  86   if( _at_risk ) tty-&gt;print(&quot;Risk &quot;);
  87 
  88   if( _must_spill ) tty-&gt;print(&quot;Must_spill &quot;);
  89   if( _is_bound ) tty-&gt;print(&quot;Bound &quot;);
  90   if( _msize_valid ) {
  91     if( _degree_valid &amp;&amp; lo_degree() ) tty-&gt;print(&quot;Trivial &quot;);
  92   }
  93 
  94   tty-&gt;cr();
  95 }
  96 #endif
  97 
  98 // Compute score from cost and area.  Low score is best to spill.
  99 static double raw_score( double cost, double area ) {
 100   return cost - (area*RegisterCostAreaRatio) * 1.52588e-5;
 101 }
 102 
 103 double LRG::score() const {
 104   // Scale _area by RegisterCostAreaRatio/64K then subtract from cost.
 105   // Bigger area lowers score, encourages spilling this live range.
 106   // Bigger cost raise score, prevents spilling this live range.
 107   // (Note: 1/65536 is the magic constant below; I dont trust the C optimizer
 108   // to turn a divide by a constant into a multiply by the reciprical).
 109   double score = raw_score( _cost, _area);
 110 
 111   // Account for area.  Basically, LRGs covering large areas are better
 112   // to spill because more other LRGs get freed up.
 113   if( _area == 0.0 )            // No area?  Then no progress to spill
 114     return 1e35;
 115 
 116   if( _was_spilled2 )           // If spilled once before, we are unlikely
 117     return score + 1e30;        // to make progress again.
 118 
 119   if( _cost &gt;= _area*3.0 )      // Tiny area relative to cost
 120     return score + 1e17;        // Probably no progress to spill
 121 
 122   if( (_cost+_cost) &gt;= _area*3.0 ) // Small area relative to cost
 123     return score + 1e10;        // Likely no progress to spill
 124 
 125   return score;
 126 }
 127 
 128 #define NUMBUCKS 3
 129 
 130 // Straight out of Tarjan&#39;s union-find algorithm
 131 uint LiveRangeMap::find_compress(uint lrg) {
 132   uint cur = lrg;
 133   uint next = _uf_map.at(cur);
 134   while (next != cur) { // Scan chain of equivalences
 135     assert( next &lt; cur, &quot;always union smaller&quot;);
 136     cur = next; // until find a fixed-point
 137     next = _uf_map.at(cur);
 138   }
 139 
 140   // Core of union-find algorithm: update chain of
 141   // equivalences to be equal to the root.
 142   while (lrg != next) {
 143     uint tmp = _uf_map.at(lrg);
 144     _uf_map.at_put(lrg, next);
 145     lrg = tmp;
 146   }
 147   return lrg;
 148 }
 149 
 150 // Reset the Union-Find map to identity
 151 void LiveRangeMap::reset_uf_map(uint max_lrg_id) {
 152   _max_lrg_id= max_lrg_id;
 153   // Force the Union-Find mapping to be at least this large
 154   _uf_map.at_put_grow(_max_lrg_id, 0);
 155   // Initialize it to be the ID mapping.
 156   for (uint i = 0; i &lt; _max_lrg_id; ++i) {
 157     _uf_map.at_put(i, i);
 158   }
 159 }
 160 
 161 // Make all Nodes map directly to their final live range; no need for
 162 // the Union-Find mapping after this call.
 163 void LiveRangeMap::compress_uf_map_for_nodes() {
 164   // For all Nodes, compress mapping
 165   uint unique = _names.length();
 166   for (uint i = 0; i &lt; unique; ++i) {
 167     uint lrg = _names.at(i);
 168     uint compressed_lrg = find(lrg);
 169     if (lrg != compressed_lrg) {
 170       _names.at_put(i, compressed_lrg);
 171     }
 172   }
 173 }
 174 
 175 // Like Find above, but no path compress, so bad asymptotic behavior
 176 uint LiveRangeMap::find_const(uint lrg) const {
 177   if (!lrg) {
 178     return lrg; // Ignore the zero LRG
 179   }
 180 
 181   // Off the end?  This happens during debugging dumps when you got
 182   // brand new live ranges but have not told the allocator yet.
 183   if (lrg &gt;= _max_lrg_id) {
 184     return lrg;
 185   }
 186 
 187   uint next = _uf_map.at(lrg);
 188   while (next != lrg) { // Scan chain of equivalences
 189     assert(next &lt; lrg, &quot;always union smaller&quot;);
 190     lrg = next; // until find a fixed-point
 191     next = _uf_map.at(lrg);
 192   }
 193   return next;
 194 }
 195 
 196 PhaseChaitin::PhaseChaitin(uint unique, PhaseCFG &amp;cfg, Matcher &amp;matcher, bool scheduling_info_generated)
 197   : PhaseRegAlloc(unique, cfg, matcher,
 198 #ifndef PRODUCT
 199        print_chaitin_statistics
 200 #else
 201        NULL
 202 #endif
 203        )
 204   , _live(0)
 205   , _spilled_once(Thread::current()-&gt;resource_area())
 206   , _spilled_twice(Thread::current()-&gt;resource_area())
 207   , _lo_degree(0), _lo_stk_degree(0), _hi_degree(0), _simplified(0)
 208   , _oldphi(unique)
 209 #ifndef PRODUCT
 210   , _trace_spilling(C-&gt;directive()-&gt;TraceSpillingOption)
 211 #endif
 212   , _lrg_map(Thread::current()-&gt;resource_area(), unique)
 213   , _scheduling_info_generated(scheduling_info_generated)
 214   , _sched_int_pressure(0, INTPRESSURE)
 215   , _sched_float_pressure(0, FLOATPRESSURE)
 216   , _scratch_int_pressure(0, INTPRESSURE)
 217   , _scratch_float_pressure(0, FLOATPRESSURE)
 218 {
 219   Compile::TracePhase tp(&quot;ctorChaitin&quot;, &amp;timers[_t_ctorChaitin]);
 220 
 221   _high_frequency_lrg = MIN2(double(OPTO_LRG_HIGH_FREQ), _cfg.get_outer_loop_frequency());
 222 
 223   // Build a list of basic blocks, sorted by frequency
 224   _blks = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 225   // Experiment with sorting strategies to speed compilation
 226   double  cutoff = BLOCK_FREQUENCY(1.0); // Cutoff for high frequency bucket
 227   Block **buckets[NUMBUCKS];             // Array of buckets
 228   uint    buckcnt[NUMBUCKS];             // Array of bucket counters
 229   double  buckval[NUMBUCKS];             // Array of bucket value cutoffs
 230   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 231     buckets[i] = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());
 232     buckcnt[i] = 0;
 233     // Bump by three orders of magnitude each time
 234     cutoff *= 0.001;
 235     buckval[i] = cutoff;
 236     for (uint j = 0; j &lt; _cfg.number_of_blocks(); j++) {
 237       buckets[i][j] = NULL;
 238     }
 239   }
 240   // Sort blocks into buckets
 241   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 242     for (uint j = 0; j &lt; NUMBUCKS; j++) {
 243       if ((j == NUMBUCKS - 1) || (_cfg.get_block(i)-&gt;_freq &gt; buckval[j])) {
 244         // Assign block to end of list for appropriate bucket
 245         buckets[j][buckcnt[j]++] = _cfg.get_block(i);
 246         break; // kick out of inner loop
 247       }
 248     }
 249   }
 250   // Dump buckets into final block array
 251   uint blkcnt = 0;
 252   for (uint i = 0; i &lt; NUMBUCKS; i++) {
 253     for (uint j = 0; j &lt; buckcnt[i]; j++) {
 254       _blks[blkcnt++] = buckets[i][j];
 255     }
 256   }
 257 
 258   assert(blkcnt == _cfg.number_of_blocks(), &quot;Block array not totally filled&quot;);
 259 }
 260 
 261 // union 2 sets together.
 262 void PhaseChaitin::Union( const Node *src_n, const Node *dst_n ) {
 263   uint src = _lrg_map.find(src_n);
 264   uint dst = _lrg_map.find(dst_n);
 265   assert(src, &quot;&quot;);
 266   assert(dst, &quot;&quot;);
 267   assert(src &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 268   assert(dst &lt; _lrg_map.max_lrg_id(), &quot;oob&quot;);
 269   assert(src &lt; dst, &quot;always union smaller&quot;);
 270   _lrg_map.uf_map(dst, src);
 271 }
 272 
 273 void PhaseChaitin::new_lrg(const Node *x, uint lrg) {
 274   // Make the Node-&gt;LRG mapping
 275   _lrg_map.extend(x-&gt;_idx,lrg);
 276   // Make the Union-Find mapping an identity function
 277   _lrg_map.uf_extend(lrg, lrg);
 278 }
 279 
 280 
 281 int PhaseChaitin::clone_projs(Block* b, uint idx, Node* orig, Node* copy, uint&amp; max_lrg_id) {
 282   assert(b-&gt;find_node(copy) == (idx - 1), &quot;incorrect insert index for copy kill projections&quot;);
 283   DEBUG_ONLY( Block* borig = _cfg.get_block_for_node(orig); )
 284   int found_projs = 0;
 285   uint cnt = orig-&gt;outcnt();
 286   for (uint i = 0; i &lt; cnt; i++) {
 287     Node* proj = orig-&gt;raw_out(i);
 288     if (proj-&gt;is_MachProj()) {
 289       assert(proj-&gt;outcnt() == 0, &quot;only kill projections are expected here&quot;);
 290       assert(_cfg.get_block_for_node(proj) == borig, &quot;incorrect block for kill projections&quot;);
 291       found_projs++;
 292       // Copy kill projections after the cloned node
 293       Node* kills = proj-&gt;clone();
 294       kills-&gt;set_req(0, copy);
 295       b-&gt;insert_node(kills, idx++);
 296       _cfg.map_node_to_block(kills, b);
 297       new_lrg(kills, max_lrg_id++);
 298     }
 299   }
 300   return found_projs;
 301 }
 302 
 303 // Renumber the live ranges to compact them.  Makes the IFG smaller.
 304 void PhaseChaitin::compact() {
 305   Compile::TracePhase tp(&quot;chaitinCompact&quot;, &amp;timers[_t_chaitinCompact]);
 306 
 307   // Current the _uf_map contains a series of short chains which are headed
 308   // by a self-cycle.  All the chains run from big numbers to little numbers.
 309   // The Find() call chases the chains &amp; shortens them for the next Find call.
 310   // We are going to change this structure slightly.  Numbers above a moving
 311   // wave &#39;i&#39; are unchanged.  Numbers below &#39;j&#39; point directly to their
 312   // compacted live range with no further chaining.  There are no chains or
 313   // cycles below &#39;i&#39;, so the Find call no longer works.
 314   uint j=1;
 315   uint i;
 316   for (i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
 317     uint lr = _lrg_map.uf_live_range_id(i);
 318     // Ignore unallocated live ranges
 319     if (!lr) {
 320       continue;
 321     }
 322     assert(lr &lt;= i, &quot;&quot;);
 323     _lrg_map.uf_map(i, ( lr == i ) ? j++ : _lrg_map.uf_live_range_id(lr));
 324   }
 325   // Now change the Node-&gt;LR mapping to reflect the compacted names
 326   uint unique = _lrg_map.size();
 327   for (i = 0; i &lt; unique; i++) {
 328     uint lrg_id = _lrg_map.live_range_id(i);
 329     _lrg_map.map(i, _lrg_map.uf_live_range_id(lrg_id));
 330   }
 331 
 332   // Reset the Union-Find mapping
 333   _lrg_map.reset_uf_map(j);
 334 }
 335 
 336 void PhaseChaitin::Register_Allocate() {
 337 
 338   // Above the OLD FP (and in registers) are the incoming arguments.  Stack
 339   // slots in this area are called &quot;arg_slots&quot;.  Above the NEW FP (and in
 340   // registers) is the outgoing argument area; above that is the spill/temp
 341   // area.  These are all &quot;frame_slots&quot;.  Arg_slots start at the zero
 342   // stack_slots and count up to the known arg_size.  Frame_slots start at
 343   // the stack_slot #arg_size and go up.  After allocation I map stack
 344   // slots to actual offsets.  Stack-slots in the arg_slot area are biased
 345   // by the frame_size; stack-slots in the frame_slot area are biased by 0.
 346 
 347   _trip_cnt = 0;
 348   _alternate = 0;
 349   _matcher._allocation_started = true;
 350 
 351   ResourceArea split_arena(mtCompiler);     // Arena for Split local resources
 352   ResourceArea live_arena(mtCompiler);      // Arena for liveness &amp; IFG info
 353   ResourceMark rm(&amp;live_arena);
 354 
 355   // Need live-ness for the IFG; need the IFG for coalescing.  If the
 356   // liveness is JUST for coalescing, then I can get some mileage by renaming
 357   // all copy-related live ranges low and then using the max copy-related
 358   // live range as a cut-off for LIVE and the IFG.  In other words, I can
 359   // build a subset of LIVE and IFG just for copies.
 360   PhaseLive live(_cfg, _lrg_map.names(), &amp;live_arena, false);
 361 
 362   // Need IFG for coalescing and coloring
 363   PhaseIFG ifg(&amp;live_arena);
 364   _ifg = &amp;ifg;
 365 
 366   // Come out of SSA world to the Named world.  Assign (virtual) registers to
 367   // Nodes.  Use the same register for all inputs and the output of PhiNodes
 368   // - effectively ending SSA form.  This requires either coalescing live
 369   // ranges or inserting copies.  For the moment, we insert &quot;virtual copies&quot;
 370   // - we pretend there is a copy prior to each Phi in predecessor blocks.
 371   // We will attempt to coalesce such &quot;virtual copies&quot; before we manifest
 372   // them for real.
 373   de_ssa();
 374 
 375 #ifdef ASSERT
 376   // Veify the graph before RA.
 377   verify(&amp;live_arena);
 378 #endif
 379 
 380   {
 381     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 382     _live = NULL;                 // Mark live as being not available
 383     rm.reset_to_mark();           // Reclaim working storage
 384     IndexSet::reset_memory(C, &amp;live_arena);
 385     ifg.init(_lrg_map.max_lrg_id()); // Empty IFG
 386     gather_lrg_masks( false );    // Collect LRG masks
 387     live.compute(_lrg_map.max_lrg_id()); // Compute liveness
 388     _live = &amp;live;                // Mark LIVE as being available
 389   }
 390 
 391   // Base pointers are currently &quot;used&quot; by instructions which define new
 392   // derived pointers.  This makes base pointers live up to the where the
 393   // derived pointer is made, but not beyond.  Really, they need to be live
 394   // across any GC point where the derived value is live.  So this code looks
 395   // at all the GC points, and &quot;stretches&quot; the live range of any base pointer
 396   // to the GC point.
 397   if (stretch_base_pointer_live_ranges(&amp;live_arena)) {
 398     Compile::TracePhase tp(&quot;computeLive (sbplr)&quot;, &amp;timers[_t_computeLive]);
 399     // Since some live range stretched, I need to recompute live
 400     _live = NULL;
 401     rm.reset_to_mark();         // Reclaim working storage
 402     IndexSet::reset_memory(C, &amp;live_arena);
 403     ifg.init(_lrg_map.max_lrg_id());
 404     gather_lrg_masks(false);
 405     live.compute(_lrg_map.max_lrg_id());
 406     _live = &amp;live;
 407   }
 408   // Create the interference graph using virtual copies
 409   build_ifg_virtual();  // Include stack slots this time
 410 
 411   // The IFG is/was triangular.  I am &#39;squaring it up&#39; so Union can run
 412   // faster.  Union requires a &#39;for all&#39; operation which is slow on the
 413   // triangular adjacency matrix (quick reminder: the IFG is &#39;sparse&#39; -
 414   // meaning I can visit all the Nodes neighbors less than a Node in time
 415   // O(# of neighbors), but I have to visit all the Nodes greater than a
 416   // given Node and search them for an instance, i.e., time O(#MaxLRG)).
 417   _ifg-&gt;SquareUp();
 418 
 419   // Aggressive (but pessimistic) copy coalescing.
 420   // This pass works on virtual copies.  Any virtual copies which are not
 421   // coalesced get manifested as actual copies
 422   {
 423     Compile::TracePhase tp(&quot;chaitinCoalesce1&quot;, &amp;timers[_t_chaitinCoalesce1]);
 424 
 425     PhaseAggressiveCoalesce coalesce(*this);
 426     coalesce.coalesce_driver();
 427     // Insert un-coalesced copies.  Visit all Phis.  Where inputs to a Phi do
 428     // not match the Phi itself, insert a copy.
 429     coalesce.insert_copies(_matcher);
 430     if (C-&gt;failing()) {
 431       return;
 432     }
 433   }
 434 
 435   // After aggressive coalesce, attempt a first cut at coloring.
 436   // To color, we need the IFG and for that we need LIVE.
 437   {
 438     Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 439     _live = NULL;
 440     rm.reset_to_mark();           // Reclaim working storage
 441     IndexSet::reset_memory(C, &amp;live_arena);
 442     ifg.init(_lrg_map.max_lrg_id());
 443     gather_lrg_masks( true );
 444     live.compute(_lrg_map.max_lrg_id());
 445     _live = &amp;live;
 446   }
 447 
 448   // Build physical interference graph
 449   uint must_spill = 0;
 450   must_spill = build_ifg_physical(&amp;live_arena);
 451   // If we have a guaranteed spill, might as well spill now
 452   if (must_spill) {
 453     if(!_lrg_map.max_lrg_id()) {
 454       return;
 455     }
 456     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit)
 457     C-&gt;check_node_count(10*must_spill, &quot;out of nodes before split&quot;);
 458     if (C-&gt;failing()) {
 459       return;
 460     }
 461 
 462     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 463     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 464     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 465     // or we failed to split
 466     C-&gt;check_node_count(2*NodeLimitFudgeFactor, &quot;out of nodes after physical split&quot;);
 467     if (C-&gt;failing()) {
 468       return;
 469     }
 470 
 471     NOT_PRODUCT(C-&gt;verify_graph_edges();)
 472 
 473     compact();                  // Compact LRGs; return new lower max lrg
 474 
 475     {
 476       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 477       _live = NULL;
 478       rm.reset_to_mark();         // Reclaim working storage
 479       IndexSet::reset_memory(C, &amp;live_arena);
 480       ifg.init(_lrg_map.max_lrg_id()); // Build a new interference graph
 481       gather_lrg_masks( true );   // Collect intersect mask
 482       live.compute(_lrg_map.max_lrg_id()); // Compute LIVE
 483       _live = &amp;live;
 484     }
 485     build_ifg_physical(&amp;live_arena);
 486     _ifg-&gt;SquareUp();
 487     _ifg-&gt;Compute_Effective_Degree();
 488     // Only do conservative coalescing if requested
 489     if (OptoCoalesce) {
 490       Compile::TracePhase tp(&quot;chaitinCoalesce2&quot;, &amp;timers[_t_chaitinCoalesce2]);
 491       // Conservative (and pessimistic) copy coalescing of those spills
 492       PhaseConservativeCoalesce coalesce(*this);
 493       // If max live ranges greater than cutoff, don&#39;t color the stack.
 494       // This cutoff can be larger than below since it is only done once.
 495       coalesce.coalesce_driver();
 496     }
 497     _lrg_map.compress_uf_map_for_nodes();
 498 
 499 #ifdef ASSERT
 500     verify(&amp;live_arena, true);
 501 #endif
 502   } else {
 503     ifg.SquareUp();
 504     ifg.Compute_Effective_Degree();
 505 #ifdef ASSERT
 506     set_was_low();
 507 #endif
 508   }
 509 
 510   // Prepare for Simplify &amp; Select
 511   cache_lrg_info();           // Count degree of LRGs
 512 
 513   // Simplify the InterFerence Graph by removing LRGs of low degree.
 514   // LRGs of low degree are trivially colorable.
 515   Simplify();
 516 
 517   // Select colors by re-inserting LRGs back into the IFG in reverse order.
 518   // Return whether or not something spills.
 519   uint spills = Select( );
 520 
 521   // If we spill, split and recycle the entire thing
 522   while( spills ) {
 523     if( _trip_cnt++ &gt; 24 ) {
 524       DEBUG_ONLY( dump_for_spill_split_recycle(); )
 525       if( _trip_cnt &gt; 27 ) {
 526         C-&gt;record_method_not_compilable(&quot;failed spill-split-recycle sanity check&quot;);
 527         return;
 528       }
 529     }
 530 
 531     if (!_lrg_map.max_lrg_id()) {
 532       return;
 533     }
 534     uint new_max_lrg_id = Split(_lrg_map.max_lrg_id(), &amp;split_arena);  // Split spilling LRG everywhere
 535     _lrg_map.set_max_lrg_id(new_max_lrg_id);
 536     // Bail out if unique gets too large (ie - unique &gt; MaxNodeLimit - 2*NodeLimitFudgeFactor)
 537     C-&gt;check_node_count(2 * NodeLimitFudgeFactor, &quot;out of nodes after split&quot;);
 538     if (C-&gt;failing()) {
 539       return;
 540     }
 541 
 542     compact(); // Compact LRGs; return new lower max lrg
 543 
 544     // Nuke the live-ness and interference graph and LiveRanGe info
 545     {
 546       Compile::TracePhase tp(&quot;computeLive&quot;, &amp;timers[_t_computeLive]);
 547       _live = NULL;
 548       rm.reset_to_mark();         // Reclaim working storage
 549       IndexSet::reset_memory(C, &amp;live_arena);
 550       ifg.init(_lrg_map.max_lrg_id());
 551 
 552       // Create LiveRanGe array.
 553       // Intersect register masks for all USEs and DEFs
 554       gather_lrg_masks(true);
 555       live.compute(_lrg_map.max_lrg_id());
 556       _live = &amp;live;
 557     }
 558     must_spill = build_ifg_physical(&amp;live_arena);
 559     _ifg-&gt;SquareUp();
 560     _ifg-&gt;Compute_Effective_Degree();
 561 
 562     // Only do conservative coalescing if requested
 563     if (OptoCoalesce) {
 564       Compile::TracePhase tp(&quot;chaitinCoalesce3&quot;, &amp;timers[_t_chaitinCoalesce3]);
 565       // Conservative (and pessimistic) copy coalescing
 566       PhaseConservativeCoalesce coalesce(*this);
 567       // Check for few live ranges determines how aggressive coalesce is.
 568       coalesce.coalesce_driver();
 569     }
 570     _lrg_map.compress_uf_map_for_nodes();
 571 #ifdef ASSERT
 572     verify(&amp;live_arena, true);
 573 #endif
 574     cache_lrg_info();           // Count degree of LRGs
 575 
 576     // Simplify the InterFerence Graph by removing LRGs of low degree.
 577     // LRGs of low degree are trivially colorable.
 578     Simplify();
 579 
 580     // Select colors by re-inserting LRGs back into the IFG in reverse order.
 581     // Return whether or not something spills.
 582     spills = Select();
 583   }
 584 
 585   // Count number of Simplify-Select trips per coloring success.
 586   _allocator_attempts += _trip_cnt + 1;
 587   _allocator_successes += 1;
 588 
 589   // Peephole remove copies
 590   post_allocate_copy_removal();
 591 
 592   // Merge multidefs if multiple defs representing the same value are used in a single block.
 593   merge_multidefs();
 594 
 595 #ifdef ASSERT
 596   // Veify the graph after RA.
 597   verify(&amp;live_arena);
 598 #endif
 599 
 600   // max_reg is past the largest *register* used.
 601   // Convert that to a frame_slot number.
 602   if (_max_reg &lt;= _matcher._new_SP) {
 603     _framesize = C-&gt;out_preserve_stack_slots();
 604   }
 605   else {
 606     _framesize = _max_reg -_matcher._new_SP;
 607   }
 608   assert((int)(_matcher._new_SP+_framesize) &gt;= (int)_matcher._out_arg_limit, &quot;framesize must be large enough&quot;);
 609 
 610   // This frame must preserve the required fp alignment
 611   _framesize = align_up(_framesize, Matcher::stack_alignment_in_slots());
 612   assert(_framesize &lt;= 1000000, &quot;sanity check&quot;);
 613 #ifndef PRODUCT
 614   _total_framesize += _framesize;
 615   if ((int)_framesize &gt; _max_framesize) {
 616     _max_framesize = _framesize;
 617   }
 618 #endif
 619 
 620   // Convert CISC spills
 621   fixup_spills();
 622 
 623   // Log regalloc results
 624   CompileLog* log = Compile::current()-&gt;log();
 625   if (log != NULL) {
 626     log-&gt;elem(&quot;regalloc attempts=&#39;%d&#39; success=&#39;%d&#39;&quot;, _trip_cnt, !C-&gt;failing());
 627   }
 628 
 629   if (C-&gt;failing()) {
 630     return;
 631   }
 632 
 633   NOT_PRODUCT(C-&gt;verify_graph_edges();)
 634 
 635   // Move important info out of the live_arena to longer lasting storage.
 636   alloc_node_regs(_lrg_map.size());
 637   for (uint i=0; i &lt; _lrg_map.size(); i++) {
 638     if (_lrg_map.live_range_id(i)) { // Live range associated with Node?
 639       LRG &amp;lrg = lrgs(_lrg_map.live_range_id(i));
 640       if (!lrg.alive()) {
 641         set_bad(i);
 642       } else if (lrg.num_regs() == 1) {
 643         set1(i, lrg.reg());
 644       } else {                  // Must be a register-set
 645         if (!lrg._fat_proj) {   // Must be aligned adjacent register set
 646           // Live ranges record the highest register in their mask.
 647           // We want the low register for the AD file writer&#39;s convenience.
 648           OptoReg::Name hi = lrg.reg(); // Get hi register
 649           OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); // Find lo
 650           // We have to use pair [lo,lo+1] even for wide vectors because
 651           // the rest of code generation works only with pairs. It is safe
 652           // since for registers encoding only &#39;lo&#39; is used.
 653           // Second reg from pair is used in ScheduleAndBundle on SPARC where
 654           // vector max size is 8 which corresponds to registers pair.
 655           // It is also used in BuildOopMaps but oop operations are not
 656           // vectorized.
 657           set2(i, lo);
 658         } else {                // Misaligned; extract 2 bits
 659           OptoReg::Name hi = lrg.reg(); // Get hi register
 660           lrg.Remove(hi);       // Yank from mask
 661           int lo = lrg.mask().find_first_elem(); // Find lo
 662           set_pair(i, hi, lo);
 663         }
 664       }
 665       if( lrg._is_oop ) _node_oops.set(i);
 666     } else {
 667       set_bad(i);
 668     }
 669   }
 670 
 671   // Done!
 672   _live = NULL;
 673   _ifg = NULL;
 674   C-&gt;set_indexSet_arena(NULL);  // ResourceArea is at end of scope
 675 }
 676 
 677 void PhaseChaitin::de_ssa() {
 678   // Set initial Names for all Nodes.  Most Nodes get the virtual register
 679   // number.  A few get the ZERO live range number.  These do not
 680   // get allocated, but instead rely on correct scheduling to ensure that
 681   // only one instance is simultaneously live at a time.
 682   uint lr_counter = 1;
 683   for( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 684     Block* block = _cfg.get_block(i);
 685     uint cnt = block-&gt;number_of_nodes();
 686 
 687     // Handle all the normal Nodes in the block
 688     for( uint j = 0; j &lt; cnt; j++ ) {
 689       Node *n = block-&gt;get_node(j);
 690       // Pre-color to the zero live range, or pick virtual register
 691       const RegMask &amp;rm = n-&gt;out_RegMask();
 692       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? lr_counter++ : 0);
 693     }
 694   }
 695 
 696   // Reset the Union-Find mapping to be identity
 697   _lrg_map.reset_uf_map(lr_counter);
 698 }
 699 
 700 void PhaseChaitin::mark_ssa() {
 701   // Use ssa names to populate the live range maps or if no mask
 702   // is available, use the 0 entry.
 703   uint max_idx = 0;
 704   for ( uint i = 0; i &lt; _cfg.number_of_blocks(); i++ ) {
 705     Block* block = _cfg.get_block(i);
 706     uint cnt = block-&gt;number_of_nodes();
 707 
 708     // Handle all the normal Nodes in the block
 709     for ( uint j = 0; j &lt; cnt; j++ ) {
 710       Node *n = block-&gt;get_node(j);
 711       // Pre-color to the zero live range, or pick virtual register
 712       const RegMask &amp;rm = n-&gt;out_RegMask();
 713       _lrg_map.map(n-&gt;_idx, rm.is_NotEmpty() ? n-&gt;_idx : 0);
 714       max_idx = (n-&gt;_idx &gt; max_idx) ? n-&gt;_idx : max_idx;
 715     }
 716   }
 717   _lrg_map.set_max_lrg_id(max_idx+1);
 718 
 719   // Reset the Union-Find mapping to be identity
 720   _lrg_map.reset_uf_map(max_idx+1);
 721 }
 722 
 723 
 724 // Gather LiveRanGe information, including register masks.  Modification of
 725 // cisc spillable in_RegMasks should not be done before AggressiveCoalesce.
 726 void PhaseChaitin::gather_lrg_masks( bool after_aggressive ) {
 727 
 728   // Nail down the frame pointer live range
 729   uint fp_lrg = _lrg_map.live_range_id(_cfg.get_root_node()-&gt;in(1)-&gt;in(TypeFunc::FramePtr));
 730   lrgs(fp_lrg)._cost += 1e12;   // Cost is infinite
 731 
 732   // For all blocks
 733   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
 734     Block* block = _cfg.get_block(i);
 735 
 736     // For all instructions
 737     for (uint j = 1; j &lt; block-&gt;number_of_nodes(); j++) {
 738       Node* n = block-&gt;get_node(j);
 739       uint input_edge_start =1; // Skip control most nodes
 740       bool is_machine_node = false;
 741       if (n-&gt;is_Mach()) {
 742         is_machine_node = true;
 743         input_edge_start = n-&gt;as_Mach()-&gt;oper_input_base();
 744       }
 745       uint idx = n-&gt;is_Copy();
 746 
 747       // Get virtual register number, same as LiveRanGe index
 748       uint vreg = _lrg_map.live_range_id(n);
 749       LRG&amp; lrg = lrgs(vreg);
 750       if (vreg) {              // No vreg means un-allocable (e.g. memory)
 751 
 752         // Check for float-vs-int live range (used in register-pressure
 753         // calculations)
 754         const Type *n_type = n-&gt;bottom_type();
 755         if (n_type-&gt;is_floatingpoint()) {
 756           lrg._is_float = 1;
 757         }
 758 
 759         // Check for twice prior spilling.  Once prior spilling might have
 760         // spilled &#39;soft&#39;, 2nd prior spill should have spilled &#39;hard&#39; and
 761         // further spilling is unlikely to make progress.
 762         if (_spilled_once.test(n-&gt;_idx)) {
 763           lrg._was_spilled1 = 1;
 764           if (_spilled_twice.test(n-&gt;_idx)) {
 765             lrg._was_spilled2 = 1;
 766           }
 767         }
 768 
 769 #ifndef PRODUCT
 770         // Collect bits not used by product code, but which may be useful for
 771         // debugging.
 772 
 773         // Collect has-copy bit
 774         if (idx) {
 775           lrg._has_copy = 1;
 776           uint clidx = _lrg_map.live_range_id(n-&gt;in(idx));
 777           LRG&amp; copy_src = lrgs(clidx);
 778           copy_src._has_copy = 1;
 779         }
 780 
 781         if (trace_spilling() &amp;&amp; lrg._def != NULL) {
 782           // collect defs for MultiDef printing
 783           if (lrg._defs == NULL) {
 784             lrg._defs = new (_ifg-&gt;_arena) GrowableArray&lt;Node*&gt;(_ifg-&gt;_arena, 2, 0, NULL);
 785             lrg._defs-&gt;append(lrg._def);
 786           }
 787           lrg._defs-&gt;append(n);
 788         }
 789 #endif
 790 
 791         // Check for a single def LRG; these can spill nicely
 792         // via rematerialization.  Flag as NULL for no def found
 793         // yet, or &#39;n&#39; for single def or -1 for many defs.
 794         lrg._def = lrg._def ? NodeSentinel : n;
 795 
 796         // Limit result register mask to acceptable registers
 797         const RegMask &amp;rm = n-&gt;out_RegMask();
 798         lrg.AND( rm );
 799 
 800         uint ireg = n-&gt;ideal_reg();
 801         assert( !n-&gt;bottom_type()-&gt;isa_oop_ptr() || ireg == Op_RegP,
 802                 &quot;oops must be in Op_RegP&#39;s&quot; );
 803 
 804         // Check for vector live range (only if vector register is used).
 805         // On SPARC vector uses RegD which could be misaligned so it is not
 806         // processes as vector in RA.
 807         if (RegMask::is_vector(ireg))
 808           lrg._is_vector = 1;
 809         assert(n_type-&gt;isa_vect() == NULL || lrg._is_vector || ireg == Op_RegD || ireg == Op_RegL,
 810                &quot;vector must be in vector registers&quot;);
 811 
 812         // Check for bound register masks
 813         const RegMask &amp;lrgmask = lrg.mask();
 814         if (lrgmask.is_bound(ireg)) {
 815           lrg._is_bound = 1;
 816         }
 817 
 818         // Check for maximum frequency value
 819         if (lrg._maxfreq &lt; block-&gt;_freq) {
 820           lrg._maxfreq = block-&gt;_freq;
 821         }
 822 
 823         // Check for oop-iness, or long/double
 824         // Check for multi-kill projection
 825         switch (ireg) {
 826         case MachProjNode::fat_proj:
 827           // Fat projections have size equal to number of registers killed
 828           lrg.set_num_regs(rm.Size());
 829           lrg.set_reg_pressure(lrg.num_regs());
 830           lrg._fat_proj = 1;
 831           lrg._is_bound = 1;
 832           break;
 833         case Op_RegP:
 834 #ifdef _LP64
 835           lrg.set_num_regs(2);  // Size is 2 stack words
 836 #else
 837           lrg.set_num_regs(1);  // Size is 1 stack word
 838 #endif
 839           // Register pressure is tracked relative to the maximum values
 840           // suggested for that platform, INTPRESSURE and FLOATPRESSURE,
 841           // and relative to other types which compete for the same regs.
 842           //
 843           // The following table contains suggested values based on the
 844           // architectures as defined in each .ad file.
 845           // INTPRESSURE and FLOATPRESSURE may be tuned differently for
 846           // compile-speed or performance.
 847           // Note1:
 848           // SPARC and SPARCV9 reg_pressures are at 2 instead of 1
 849           // since .ad registers are defined as high and low halves.
 850           // These reg_pressure values remain compatible with the code
 851           // in is_high_pressure() which relates get_invalid_mask_size(),
 852           // Block::_reg_pressure and INTPRESSURE, FLOATPRESSURE.
 853           // Note2:
 854           // SPARC -d32 has 24 registers available for integral values,
 855           // but only 10 of these are safe for 64-bit longs.
 856           // Using set_reg_pressure(2) for both int and long means
 857           // the allocator will believe it can fit 26 longs into
 858           // registers.  Using 2 for longs and 1 for ints means the
 859           // allocator will attempt to put 52 integers into registers.
 860           // The settings below limit this problem to methods with
 861           // many long values which are being run on 32-bit SPARC.
 862           //
 863           // ------------------- reg_pressure --------------------
 864           // Each entry is reg_pressure_per_value,number_of_regs
 865           //         RegL  RegI  RegFlags   RegF RegD    INTPRESSURE  FLOATPRESSURE
 866           // IA32     2     1     1          1    1          6           6
 867           // IA64     1     1     1          1    1         50          41
 868           // SPARC    2     2     2          2    2         48 (24)     52 (26)
 869           // SPARCV9  2     2     2          2    2         48 (24)     52 (26)
 870           // AMD64    1     1     1          1    1         14          15
 871           // -----------------------------------------------------
 872           lrg.set_reg_pressure(1);  // normally one value per register
 873           if( n_type-&gt;isa_oop_ptr() ) {
 874             lrg._is_oop = 1;
 875           }
 876           break;
 877         case Op_RegL:           // Check for long or double
 878         case Op_RegD:
 879           lrg.set_num_regs(2);
 880           // Define platform specific register pressure
 881 #if defined(ARM32)
 882           lrg.set_reg_pressure(2);
 883 #elif defined(IA32)
 884           if( ireg == Op_RegL ) {
 885             lrg.set_reg_pressure(2);
 886           } else {
 887             lrg.set_reg_pressure(1);
 888           }
 889 #else
 890           lrg.set_reg_pressure(1);  // normally one value per register
 891 #endif
 892           // If this def of a double forces a mis-aligned double,
 893           // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
 894           // AND changes how we count interferences.  A mis-aligned
 895           // double can interfere with TWO aligned pairs, or effectively
 896           // FOUR registers!
 897           if (rm.is_misaligned_pair()) {
 898             lrg._fat_proj = 1;
 899             lrg._is_bound = 1;
 900           }
 901           break;
 902         case Op_RegF:
 903         case Op_RegI:
 904         case Op_RegN:
 905         case Op_RegFlags:
 906         case 0:                 // not an ideal register
 907           lrg.set_num_regs(1);
 908           lrg.set_reg_pressure(1);
 909           break;
 910         case Op_VecS:
 911           assert(Matcher::vector_size_supported(T_BYTE,4), &quot;sanity&quot;);
 912           assert(RegMask::num_registers(Op_VecS) == RegMask::SlotsPerVecS, &quot;sanity&quot;);
 913           lrg.set_num_regs(RegMask::SlotsPerVecS);
 914           lrg.set_reg_pressure(1);
 915           break;
 916         case Op_VecD:
 917           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecD), &quot;sanity&quot;);
 918           assert(RegMask::num_registers(Op_VecD) == RegMask::SlotsPerVecD, &quot;sanity&quot;);
 919           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecD), &quot;vector should be aligned&quot;);
 920           lrg.set_num_regs(RegMask::SlotsPerVecD);
 921           lrg.set_reg_pressure(1);
 922           break;
 923         case Op_VecX:
 924           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecX), &quot;sanity&quot;);
 925           assert(RegMask::num_registers(Op_VecX) == RegMask::SlotsPerVecX, &quot;sanity&quot;);
 926           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecX), &quot;vector should be aligned&quot;);
 927           lrg.set_num_regs(RegMask::SlotsPerVecX);
 928           lrg.set_reg_pressure(1);
 929           break;
 930         case Op_VecY:
 931           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecY), &quot;sanity&quot;);
 932           assert(RegMask::num_registers(Op_VecY) == RegMask::SlotsPerVecY, &quot;sanity&quot;);
 933           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecY), &quot;vector should be aligned&quot;);
 934           lrg.set_num_regs(RegMask::SlotsPerVecY);
 935           lrg.set_reg_pressure(1);
 936           break;
 937         case Op_VecZ:
 938           assert(Matcher::vector_size_supported(T_FLOAT,RegMask::SlotsPerVecZ), &quot;sanity&quot;);
 939           assert(RegMask::num_registers(Op_VecZ) == RegMask::SlotsPerVecZ, &quot;sanity&quot;);
 940           assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecZ), &quot;vector should be aligned&quot;);
 941           lrg.set_num_regs(RegMask::SlotsPerVecZ);
 942           lrg.set_reg_pressure(1);
 943           break;
 944         default:
 945           ShouldNotReachHere();
 946         }
 947       }
 948 
 949       // Now do the same for inputs
 950       uint cnt = n-&gt;req();
 951       // Setup for CISC SPILLING
 952       uint inp = (uint)AdlcVMDeps::Not_cisc_spillable;
 953       if( UseCISCSpill &amp;&amp; after_aggressive ) {
 954         inp = n-&gt;cisc_operand();
 955         if( inp != (uint)AdlcVMDeps::Not_cisc_spillable )
 956           // Convert operand number to edge index number
 957           inp = n-&gt;as_Mach()-&gt;operand_index(inp);
 958       }
 959 
 960       // Prepare register mask for each input
 961       for( uint k = input_edge_start; k &lt; cnt; k++ ) {
 962         uint vreg = _lrg_map.live_range_id(n-&gt;in(k));
 963         if (!vreg) {
 964           continue;
 965         }
 966 
 967         // If this instruction is CISC Spillable, add the flags
 968         // bit to its appropriate input
 969         if( UseCISCSpill &amp;&amp; after_aggressive &amp;&amp; inp == k ) {
 970 #ifndef PRODUCT
 971           if( TraceCISCSpill ) {
 972             tty-&gt;print(&quot;  use_cisc_RegMask: &quot;);
 973             n-&gt;dump();
 974           }
 975 #endif
 976           n-&gt;as_Mach()-&gt;use_cisc_RegMask();
 977         }
 978 
 979         if (is_machine_node &amp;&amp; _scheduling_info_generated) {
 980           MachNode* cur_node = n-&gt;as_Mach();
 981           // this is cleaned up by register allocation
 982           if (k &gt;= cur_node-&gt;num_opnds()) continue;
 983         }
 984 
 985         LRG &amp;lrg = lrgs(vreg);
 986         // // Testing for floating point code shape
 987         // Node *test = n-&gt;in(k);
 988         // if( test-&gt;is_Mach() ) {
 989         //   MachNode *m = test-&gt;as_Mach();
 990         //   int  op = m-&gt;ideal_Opcode();
 991         //   if (n-&gt;is_Call() &amp;&amp; (op == Op_AddF || op == Op_MulF) ) {
 992         //     int zzz = 1;
 993         //   }
 994         // }
 995 
 996         // Limit result register mask to acceptable registers.
 997         // Do not limit registers from uncommon uses before
 998         // AggressiveCoalesce.  This effectively pre-virtual-splits
 999         // around uncommon uses of common defs.
1000         const RegMask &amp;rm = n-&gt;in_RegMask(k);
1001         if (!after_aggressive &amp;&amp; _cfg.get_block_for_node(n-&gt;in(k))-&gt;_freq &gt; 1000 * block-&gt;_freq) {
1002           // Since we are BEFORE aggressive coalesce, leave the register
1003           // mask untrimmed by the call.  This encourages more coalescing.
1004           // Later, AFTER aggressive, this live range will have to spill
1005           // but the spiller handles slow-path calls very nicely.
1006         } else {
1007           lrg.AND( rm );
1008         }
1009 
1010         // Check for bound register masks
1011         const RegMask &amp;lrgmask = lrg.mask();
1012         uint kreg = n-&gt;in(k)-&gt;ideal_reg();
1013         bool is_vect = RegMask::is_vector(kreg);
1014         assert(n-&gt;in(k)-&gt;bottom_type()-&gt;isa_vect() == NULL ||
1015                is_vect || kreg == Op_RegD || kreg == Op_RegL,
1016                &quot;vector must be in vector registers&quot;);
1017         if (lrgmask.is_bound(kreg))
1018           lrg._is_bound = 1;
1019 
1020         // If this use of a double forces a mis-aligned double,
1021         // flag as &#39;_fat_proj&#39; - really flag as allowing misalignment
1022         // AND changes how we count interferences.  A mis-aligned
1023         // double can interfere with TWO aligned pairs, or effectively
1024         // FOUR registers!
1025 #ifdef ASSERT
1026         if (is_vect &amp;&amp; !_scheduling_info_generated) {
1027           if (lrg.num_regs() != 0) {
1028             assert(lrgmask.is_aligned_sets(lrg.num_regs()), &quot;vector should be aligned&quot;);
1029             assert(!lrg._fat_proj, &quot;sanity&quot;);
1030             assert(RegMask::num_registers(kreg) == lrg.num_regs(), &quot;sanity&quot;);
1031           } else {
1032             assert(n-&gt;is_Phi(), &quot;not all inputs processed only if Phi&quot;);
1033           }
1034         }
1035 #endif
1036         if (!is_vect &amp;&amp; lrg.num_regs() == 2 &amp;&amp; !lrg._fat_proj &amp;&amp; rm.is_misaligned_pair()) {
1037           lrg._fat_proj = 1;
1038           lrg._is_bound = 1;
1039         }
1040         // if the LRG is an unaligned pair, we will have to spill
1041         // so clear the LRG&#39;s register mask if it is not already spilled
1042         if (!is_vect &amp;&amp; !n-&gt;is_SpillCopy() &amp;&amp;
1043             (lrg._def == NULL || lrg.is_multidef() || !lrg._def-&gt;is_SpillCopy()) &amp;&amp;
1044             lrgmask.is_misaligned_pair()) {
1045           lrg.Clear();
1046         }
1047 
1048         // Check for maximum frequency value
1049         if (lrg._maxfreq &lt; block-&gt;_freq) {
1050           lrg._maxfreq = block-&gt;_freq;
1051         }
1052 
1053       } // End for all allocated inputs
1054     } // end for all instructions
1055   } // end for all blocks
1056 
1057   // Final per-liverange setup
1058   for (uint i2 = 0; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
1059     LRG &amp;lrg = lrgs(i2);
1060     assert(!lrg._is_vector || !lrg._fat_proj, &quot;sanity&quot;);
1061     if (lrg.num_regs() &gt; 1 &amp;&amp; !lrg._fat_proj) {
1062       lrg.clear_to_sets();
1063     }
1064     lrg.compute_set_mask_size();
1065     if (lrg.not_free()) {      // Handle case where we lose from the start
1066       lrg.set_reg(OptoReg::Name(LRG::SPILL_REG));
1067       lrg._direct_conflict = 1;
1068     }
1069     lrg.set_degree(0);          // no neighbors in IFG yet
1070   }
1071 }
1072 
1073 // Set the was-lo-degree bit.  Conservative coalescing should not change the
1074 // colorability of the graph.  If any live range was of low-degree before
1075 // coalescing, it should Simplify.  This call sets the was-lo-degree bit.
1076 // The bit is checked in Simplify.
1077 void PhaseChaitin::set_was_low() {
1078 #ifdef ASSERT
1079   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1080     int size = lrgs(i).num_regs();
1081     uint old_was_lo = lrgs(i)._was_lo;
1082     lrgs(i)._was_lo = 0;
1083     if( lrgs(i).lo_degree() ) {
1084       lrgs(i)._was_lo = 1;      // Trivially of low degree
1085     } else {                    // Else check the Brigg&#39;s assertion
1086       // Brigg&#39;s observation is that the lo-degree neighbors of a
1087       // hi-degree live range will not interfere with the color choices
1088       // of said hi-degree live range.  The Simplify reverse-stack-coloring
1089       // order takes care of the details.  Hence you do not have to count
1090       // low-degree neighbors when determining if this guy colors.
1091       int briggs_degree = 0;
1092       IndexSet *s = _ifg-&gt;neighbors(i);
1093       IndexSetIterator elements(s);
1094       uint lidx;
1095       while((lidx = elements.next()) != 0) {
1096         if( !lrgs(lidx).lo_degree() )
1097           briggs_degree += MAX2(size,lrgs(lidx).num_regs());
1098       }
1099       if( briggs_degree &lt; lrgs(i).degrees_of_freedom() )
1100         lrgs(i)._was_lo = 1;    // Low degree via the briggs assertion
1101     }
1102     assert(old_was_lo &lt;= lrgs(i)._was_lo, &quot;_was_lo may not decrease&quot;);
1103   }
1104 #endif
1105 }
1106 
1107 // Compute cost/area ratio, in case we spill.  Build the lo-degree list.
1108 void PhaseChaitin::cache_lrg_info( ) {
1109   Compile::TracePhase tp(&quot;chaitinCacheLRG&quot;, &amp;timers[_t_chaitinCacheLRG]);
1110 
1111   for (uint i = 1; i &lt; _lrg_map.max_lrg_id(); i++) {
1112     LRG &amp;lrg = lrgs(i);
1113 
1114     // Check for being of low degree: means we can be trivially colored.
1115     // Low degree, dead or must-spill guys just get to simplify right away
1116     if( lrg.lo_degree() ||
1117        !lrg.alive() ||
1118         lrg._must_spill ) {
1119       // Split low degree list into those guys that must get a
1120       // register and those that can go to register or stack.
1121       // The idea is LRGs that can go register or stack color first when
1122       // they have a good chance of getting a register.  The register-only
1123       // lo-degree live ranges always get a register.
1124       OptoReg::Name hi_reg = lrg.mask().find_last_elem();
1125       if( OptoReg::is_stack(hi_reg)) { // Can go to stack?
1126         lrg._next = _lo_stk_degree;
1127         _lo_stk_degree = i;
1128       } else {
1129         lrg._next = _lo_degree;
1130         _lo_degree = i;
1131       }
1132     } else {                    // Else high degree
1133       lrgs(_hi_degree)._prev = i;
1134       lrg._next = _hi_degree;
1135       lrg._prev = 0;
1136       _hi_degree = i;
1137     }
1138   }
1139 }
1140 
1141 // Simplify the IFG by removing LRGs of low degree.
1142 void PhaseChaitin::Simplify( ) {
1143   Compile::TracePhase tp(&quot;chaitinSimplify&quot;, &amp;timers[_t_chaitinSimplify]);
1144 
1145   while( 1 ) {                  // Repeat till simplified it all
1146     // May want to explore simplifying lo_degree before _lo_stk_degree.
1147     // This might result in more spills coloring into registers during
1148     // Select().
1149     while( _lo_degree || _lo_stk_degree ) {
1150       // If possible, pull from lo_stk first
1151       uint lo;
1152       if( _lo_degree ) {
1153         lo = _lo_degree;
1154         _lo_degree = lrgs(lo)._next;
1155       } else {
1156         lo = _lo_stk_degree;
1157         _lo_stk_degree = lrgs(lo)._next;
1158       }
1159 
1160       // Put the simplified guy on the simplified list.
1161       lrgs(lo)._next = _simplified;
1162       _simplified = lo;
1163       // If this guy is &quot;at risk&quot; then mark his current neighbors
1164       if (lrgs(lo)._at_risk &amp;&amp; !_ifg-&gt;neighbors(lo)-&gt;is_empty()) {
1165         IndexSetIterator elements(_ifg-&gt;neighbors(lo));
1166         uint datum;
1167         while ((datum = elements.next()) != 0) {
1168           lrgs(datum)._risk_bias = lo;
1169         }
1170       }
1171 
1172       // Yank this guy from the IFG.
1173       IndexSet *adj = _ifg-&gt;remove_node(lo);
1174       if (adj-&gt;is_empty()) {
1175         continue;
1176       }
1177 
1178       // If any neighbors&#39; degrees fall below their number of
1179       // allowed registers, then put that neighbor on the low degree
1180       // list.  Note that &#39;degree&#39; can only fall and &#39;numregs&#39; is
1181       // unchanged by this action.  Thus the two are equal at most once,
1182       // so LRGs hit the lo-degree worklist at most once.
1183       IndexSetIterator elements(adj);
1184       uint neighbor;
1185       while ((neighbor = elements.next()) != 0) {
1186         LRG *n = &amp;lrgs(neighbor);
1187 #ifdef ASSERT
1188         if (VerifyRegisterAllocator) {
1189           assert( _ifg-&gt;effective_degree(neighbor) == n-&gt;degree(), &quot;&quot; );
1190         }
1191 #endif
1192 
1193         // Check for just becoming of-low-degree just counting registers.
1194         // _must_spill live ranges are already on the low degree list.
1195         if (n-&gt;just_lo_degree() &amp;&amp; !n-&gt;_must_spill) {
1196           assert(!_ifg-&gt;_yanked-&gt;test(neighbor), &quot;Cannot move to lo degree twice&quot;);
1197           // Pull from hi-degree list
1198           uint prev = n-&gt;_prev;
1199           uint next = n-&gt;_next;
1200           if (prev) {
1201             lrgs(prev)._next = next;
1202           } else {
1203             _hi_degree = next;
1204           }
1205           lrgs(next)._prev = prev;
1206           n-&gt;_next = _lo_degree;
1207           _lo_degree = neighbor;
1208         }
1209       }
1210     } // End of while lo-degree/lo_stk_degree worklist not empty
1211 
1212     // Check for got everything: is hi-degree list empty?
1213     if (!_hi_degree) break;
1214 
1215     // Time to pick a potential spill guy
1216     uint lo_score = _hi_degree;
1217     double score = lrgs(lo_score).score();
1218     double area = lrgs(lo_score)._area;
1219     double cost = lrgs(lo_score)._cost;
1220     bool bound = lrgs(lo_score)._is_bound;
1221 
1222     // Find cheapest guy
1223     debug_only( int lo_no_simplify=0; );
1224     for (uint i = _hi_degree; i; i = lrgs(i)._next) {
1225       assert(!_ifg-&gt;_yanked-&gt;test(i), &quot;&quot;);
1226       // It&#39;s just vaguely possible to move hi-degree to lo-degree without
1227       // going through a just-lo-degree stage: If you remove a double from
1228       // a float live range it&#39;s degree will drop by 2 and you can skip the
1229       // just-lo-degree stage.  It&#39;s very rare (shows up after 5000+ methods
1230       // in -Xcomp of Java2Demo).  So just choose this guy to simplify next.
1231       if( lrgs(i).lo_degree() ) {
1232         lo_score = i;
1233         break;
1234       }
1235       debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );
1236       double iscore = lrgs(i).score();
1237       double iarea = lrgs(i)._area;
1238       double icost = lrgs(i)._cost;
1239       bool ibound = lrgs(i)._is_bound;
1240 
1241       // Compare cost/area of i vs cost/area of lo_score.  Smaller cost/area
1242       // wins.  Ties happen because all live ranges in question have spilled
1243       // a few times before and the spill-score adds a huge number which
1244       // washes out the low order bits.  We are choosing the lesser of 2
1245       // evils; in this case pick largest area to spill.
1246       // Ties also happen when live ranges are defined and used only inside
1247       // one block. In which case their area is 0 and score set to max.
1248       // In such case choose bound live range over unbound to free registers
1249       // or with smaller cost to spill.
1250       if ( iscore &lt; score ||
1251           (iscore == score &amp;&amp; iarea &gt; area &amp;&amp; lrgs(lo_score)._was_spilled2) ||
1252           (iscore == score &amp;&amp; iarea == area &amp;&amp;
1253            ( (ibound &amp;&amp; !bound) || (ibound == bound &amp;&amp; (icost &lt; cost)) )) ) {
1254         lo_score = i;
1255         score = iscore;
1256         area = iarea;
1257         cost = icost;
1258         bound = ibound;
1259       }
1260     }
1261     LRG *lo_lrg = &amp;lrgs(lo_score);
1262     // The live range we choose for spilling is either hi-degree, or very
1263     // rarely it can be low-degree.  If we choose a hi-degree live range
1264     // there better not be any lo-degree choices.
1265     assert( lo_lrg-&gt;lo_degree() || !lo_no_simplify, &quot;Live range was lo-degree before coalesce; should simplify&quot; );
1266 
1267     // Pull from hi-degree list
1268     uint prev = lo_lrg-&gt;_prev;
1269     uint next = lo_lrg-&gt;_next;
1270     if( prev ) lrgs(prev)._next = next;
1271     else _hi_degree = next;
1272     lrgs(next)._prev = prev;
1273     // Jam him on the lo-degree list, despite his high degree.
1274     // Maybe he&#39;ll get a color, and maybe he&#39;ll spill.
1275     // Only Select() will know.
1276     lrgs(lo_score)._at_risk = true;
1277     _lo_degree = lo_score;
1278     lo_lrg-&gt;_next = 0;
1279 
1280   } // End of while not simplified everything
1281 
1282 }
1283 
1284 // Is &#39;reg&#39; register legal for &#39;lrg&#39;?
1285 static bool is_legal_reg(LRG &amp;lrg, OptoReg::Name reg, int chunk) {
1286   if (reg &gt;= chunk &amp;&amp; reg &lt; (chunk + RegMask::CHUNK_SIZE) &amp;&amp;
1287       lrg.mask().Member(OptoReg::add(reg,-chunk))) {
1288     // RA uses OptoReg which represent the highest element of a registers set.
1289     // For example, vectorX (128bit) on x86 uses [XMM,XMMb,XMMc,XMMd] set
1290     // in which XMMd is used by RA to represent such vectors. A double value
1291     // uses [XMM,XMMb] pairs and XMMb is used by RA for it.
1292     // The register mask uses largest bits set of overlapping register sets.
1293     // On x86 with AVX it uses 8 bits for each XMM registers set.
1294     //
1295     // The &#39;lrg&#39; already has cleared-to-set register mask (done in Select()
1296     // before calling choose_color()). Passing mask.Member(reg) check above
1297     // indicates that the size (num_regs) of &#39;reg&#39; set is less or equal to
1298     // &#39;lrg&#39; set size.
1299     // For set size 1 any register which is member of &#39;lrg&#39; mask is legal.
1300     if (lrg.num_regs()==1)
1301       return true;
1302     // For larger sets only an aligned register with the same set size is legal.
1303     int mask = lrg.num_regs()-1;
1304     if ((reg&amp;mask) == mask)
1305       return true;
1306   }
1307   return false;
1308 }
1309 
1310 // Choose a color using the biasing heuristic
1311 OptoReg::Name PhaseChaitin::bias_color( LRG &amp;lrg, int chunk ) {
1312 
1313   // Check for &quot;at_risk&quot; LRG&#39;s
1314   uint risk_lrg = _lrg_map.find(lrg._risk_bias);
1315   if (risk_lrg != 0 &amp;&amp; !_ifg-&gt;neighbors(risk_lrg)-&gt;is_empty()) {
1316     // Walk the colored neighbors of the &quot;at_risk&quot; candidate
1317     // Choose a color which is both legal and already taken by a neighbor
1318     // of the &quot;at_risk&quot; candidate in order to improve the chances of the
1319     // &quot;at_risk&quot; candidate of coloring
1320     IndexSetIterator elements(_ifg-&gt;neighbors(risk_lrg));
1321     uint datum;
1322     while ((datum = elements.next()) != 0) {
1323       OptoReg::Name reg = lrgs(datum).reg();
1324       // If this LRG&#39;s register is legal for us, choose it
1325       if (is_legal_reg(lrg, reg, chunk))
1326         return reg;
1327     }
1328   }
1329 
1330   uint copy_lrg = _lrg_map.find(lrg._copy_bias);
1331   if (copy_lrg != 0) {
1332     // If he has a color,
1333     if(!_ifg-&gt;_yanked-&gt;test(copy_lrg)) {
1334       OptoReg::Name reg = lrgs(copy_lrg).reg();
1335       //  And it is legal for you,
1336       if (is_legal_reg(lrg, reg, chunk))
1337         return reg;
1338     } else if( chunk == 0 ) {
1339       // Choose a color which is legal for him
1340       RegMask tempmask = lrg.mask();
1341       tempmask.AND(lrgs(copy_lrg).mask());
1342       tempmask.clear_to_sets(lrg.num_regs());
1343       OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());
1344       if (OptoReg::is_valid(reg))
1345         return reg;
1346     }
1347   }
1348 
1349   // If no bias info exists, just go with the register selection ordering
1350   if (lrg._is_vector || lrg.num_regs() == 2) {
1351     // Find an aligned set
1352     return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);
1353   }
1354 
1355   // CNC - Fun hack.  Alternate 1st and 2nd selection.  Enables post-allocate
1356   // copy removal to remove many more copies, by preventing a just-assigned
1357   // register from being repeatedly assigned.
1358   OptoReg::Name reg = lrg.mask().find_first_elem();
1359   if( (++_alternate &amp; 1) &amp;&amp; OptoReg::is_valid(reg) ) {
1360     // This &#39;Remove; find; Insert&#39; idiom is an expensive way to find the
1361     // SECOND element in the mask.
1362     lrg.Remove(reg);
1363     OptoReg::Name reg2 = lrg.mask().find_first_elem();
1364     lrg.Insert(reg);
1365     if( OptoReg::is_reg(reg2))
1366       reg = reg2;
1367   }
1368   return OptoReg::add( reg, chunk );
1369 }
1370 
1371 // Choose a color in the current chunk
1372 OptoReg::Name PhaseChaitin::choose_color( LRG &amp;lrg, int chunk ) {
1373   assert( C-&gt;in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1374   assert(C-&gt;out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), &quot;must not allocate stack0 (inside preserve area)&quot;);
1375 
1376   if( lrg.num_regs() == 1 ||    // Common Case
1377       !lrg._fat_proj )          // Aligned+adjacent pairs ok
1378     // Use a heuristic to &quot;bias&quot; the color choice
1379     return bias_color(lrg, chunk);
1380 
1381   assert(!lrg._is_vector, &quot;should be not vector here&quot; );
1382   assert( lrg.num_regs() &gt;= 2, &quot;dead live ranges do not color&quot; );
1383 
1384   // Fat-proj case or misaligned double argument.
1385   assert(lrg.compute_mask_size() == lrg.num_regs() ||
1386          lrg.num_regs() == 2,&quot;fat projs exactly color&quot; );
1387   assert( !chunk, &quot;always color in 1st chunk&quot; );
1388   // Return the highest element in the set.
1389   return lrg.mask().find_last_elem();
1390 }
1391 
1392 // Select colors by re-inserting LRGs back into the IFG.  LRGs are re-inserted
1393 // in reverse order of removal.  As long as nothing of hi-degree was yanked,
1394 // everything going back is guaranteed a color.  Select that color.  If some
1395 // hi-degree LRG cannot get a color then we record that we must spill.
1396 uint PhaseChaitin::Select( ) {
1397   Compile::TracePhase tp(&quot;chaitinSelect&quot;, &amp;timers[_t_chaitinSelect]);
1398 
1399   uint spill_reg = LRG::SPILL_REG;
1400   _max_reg = OptoReg::Name(0);  // Past max register used
1401   while( _simplified ) {
1402     // Pull next LRG from the simplified list - in reverse order of removal
1403     uint lidx = _simplified;
1404     LRG *lrg = &amp;lrgs(lidx);
1405     _simplified = lrg-&gt;_next;
1406 
1407 
1408 #ifndef PRODUCT
1409     if (trace_spilling()) {
1410       ttyLocker ttyl;
1411       tty-&gt;print_cr(&quot;L%d selecting degree %d degrees_of_freedom %d&quot;, lidx, lrg-&gt;degree(),
1412                     lrg-&gt;degrees_of_freedom());
1413       lrg-&gt;dump();
1414     }
1415 #endif
1416 
1417     // Re-insert into the IFG
1418     _ifg-&gt;re_insert(lidx);
1419     if( !lrg-&gt;alive() ) continue;
1420     // capture allstackedness flag before mask is hacked
1421     const int is_allstack = lrg-&gt;mask().is_AllStack();
1422 
1423     // Yeah, yeah, yeah, I know, I know.  I can refactor this
1424     // to avoid the GOTO, although the refactored code will not
1425     // be much clearer.  We arrive here IFF we have a stack-based
1426     // live range that cannot color in the current chunk, and it
1427     // has to move into the next free stack chunk.
1428     int chunk = 0;              // Current chunk is first chunk
1429     retry_next_chunk:
1430 
1431     // Remove neighbor colors
1432     IndexSet *s = _ifg-&gt;neighbors(lidx);
1433     debug_only(RegMask orig_mask = lrg-&gt;mask();)
1434 
1435     if (!s-&gt;is_empty()) {
1436       IndexSetIterator elements(s);
1437       uint neighbor;
1438       while ((neighbor = elements.next()) != 0) {
1439         // Note that neighbor might be a spill_reg.  In this case, exclusion
1440         // of its color will be a no-op, since the spill_reg chunk is in outer
1441         // space.  Also, if neighbor is in a different chunk, this exclusion
1442         // will be a no-op.  (Later on, if lrg runs out of possible colors in
1443         // its chunk, a new chunk of color may be tried, in which case
1444         // examination of neighbors is started again, at retry_next_chunk.)
1445         LRG &amp;nlrg = lrgs(neighbor);
1446         OptoReg::Name nreg = nlrg.reg();
1447         // Only subtract masks in the same chunk
1448         if (nreg &gt;= chunk &amp;&amp; nreg &lt; chunk + RegMask::CHUNK_SIZE) {
1449 #ifndef PRODUCT
1450           uint size = lrg-&gt;mask().Size();
1451           RegMask rm = lrg-&gt;mask();
1452 #endif
1453           lrg-&gt;SUBTRACT(nlrg.mask());
1454 #ifndef PRODUCT
1455           if (trace_spilling() &amp;&amp; lrg-&gt;mask().Size() != size) {
1456             ttyLocker ttyl;
1457             tty-&gt;print(&quot;L%d &quot;, lidx);
1458             rm.dump();
1459             tty-&gt;print(&quot; intersected L%d &quot;, neighbor);
1460             nlrg.mask().dump();
1461             tty-&gt;print(&quot; removed &quot;);
1462             rm.SUBTRACT(lrg-&gt;mask());
1463             rm.dump();
1464             tty-&gt;print(&quot; leaving &quot;);
1465             lrg-&gt;mask().dump();
1466             tty-&gt;cr();
1467           }
1468 #endif
1469         }
1470       }
1471     }
1472     //assert(is_allstack == lrg-&gt;mask().is_AllStack(), &quot;nbrs must not change AllStackedness&quot;);
1473     // Aligned pairs need aligned masks
1474     assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1475     if (lrg-&gt;num_regs() &gt; 1 &amp;&amp; !lrg-&gt;_fat_proj) {
1476       lrg-&gt;clear_to_sets();
1477     }
1478 
1479     // Check if a color is available and if so pick the color
1480     OptoReg::Name reg = choose_color( *lrg, chunk );
1481 
1482     //---------------
1483     // If we fail to color and the AllStack flag is set, trigger
1484     // a chunk-rollover event
1485     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) &amp;&amp; is_allstack) {
1486       // Bump register mask up to next stack chunk
1487       chunk += RegMask::CHUNK_SIZE;
1488       lrg-&gt;Set_All();
1489 
1490       goto retry_next_chunk;
1491     }
1492 
1493     //---------------
1494     // Did we get a color?
1495     else if( OptoReg::is_valid(reg)) {
1496 #ifndef PRODUCT
1497       RegMask avail_rm = lrg-&gt;mask();
1498 #endif
1499 
1500       // Record selected register
1501       lrg-&gt;set_reg(reg);
1502 
1503       if( reg &gt;= _max_reg )     // Compute max register limit
1504         _max_reg = OptoReg::add(reg,1);
1505       // Fold reg back into normal space
1506       reg = OptoReg::add(reg,-chunk);
1507 
1508       // If the live range is not bound, then we actually had some choices
1509       // to make.  In this case, the mask has more bits in it than the colors
1510       // chosen.  Restrict the mask to just what was picked.
1511       int n_regs = lrg-&gt;num_regs();
1512       assert(!lrg-&gt;_is_vector || !lrg-&gt;_fat_proj, &quot;sanity&quot;);
1513       if (n_regs == 1 || !lrg-&gt;_fat_proj) {
1514         assert(!lrg-&gt;_is_vector || n_regs &lt;= RegMask::SlotsPerVecZ, &quot;sanity&quot;);
1515         lrg-&gt;Clear();           // Clear the mask
1516         lrg-&gt;Insert(reg);       // Set regmask to match selected reg
1517         // For vectors and pairs, also insert the low bit of the pair
1518         for (int i = 1; i &lt; n_regs; i++)
1519           lrg-&gt;Insert(OptoReg::add(reg,-i));
1520         lrg-&gt;set_mask_size(n_regs);
1521       } else {                  // Else fatproj
1522         // mask must be equal to fatproj bits, by definition
1523       }
1524 #ifndef PRODUCT
1525       if (trace_spilling()) {
1526         ttyLocker ttyl;
1527         tty-&gt;print(&quot;L%d selected &quot;, lidx);
1528         lrg-&gt;mask().dump();
1529         tty-&gt;print(&quot; from &quot;);
1530         avail_rm.dump();
1531         tty-&gt;cr();
1532       }
1533 #endif
1534       // Note that reg is the highest-numbered register in the newly-bound mask.
1535     } // end color available case
1536 
1537     //---------------
1538     // Live range is live and no colors available
1539     else {
1540       assert( lrg-&gt;alive(), &quot;&quot; );
1541       assert( !lrg-&gt;_fat_proj || lrg-&gt;is_multidef() ||
1542               lrg-&gt;_def-&gt;outcnt() &gt; 0, &quot;fat_proj cannot spill&quot;);
1543       assert( !orig_mask.is_AllStack(), &quot;All Stack does not spill&quot; );
1544 
1545       // Assign the special spillreg register
1546       lrg-&gt;set_reg(OptoReg::Name(spill_reg++));
1547       // Do not empty the regmask; leave mask_size lying around
1548       // for use during Spilling
1549 #ifndef PRODUCT
1550       if( trace_spilling() ) {
1551         ttyLocker ttyl;
1552         tty-&gt;print(&quot;L%d spilling with neighbors: &quot;, lidx);
1553         s-&gt;dump();
1554         debug_only(tty-&gt;print(&quot; original mask: &quot;));
1555         debug_only(orig_mask.dump());
1556         dump_lrg(lidx);
1557       }
1558 #endif
1559     } // end spill case
1560 
1561   }
1562 
1563   return spill_reg-LRG::SPILL_REG;      // Return number of spills
1564 }
1565 
1566 // Set the &#39;spilled_once&#39; or &#39;spilled_twice&#39; flag on a node.
1567 void PhaseChaitin::set_was_spilled( Node *n ) {
1568   if( _spilled_once.test_set(n-&gt;_idx) )
1569     _spilled_twice.set(n-&gt;_idx);
1570 }
1571 
1572 // Convert Ideal spill instructions into proper FramePtr + offset Loads and
1573 // Stores.  Use-def chains are NOT preserved, but Node-&gt;LRG-&gt;reg maps are.
1574 void PhaseChaitin::fixup_spills() {
1575   // This function does only cisc spill work.
1576   if( !UseCISCSpill ) return;
1577 
1578   Compile::TracePhase tp(&quot;fixupSpills&quot;, &amp;timers[_t_fixupSpills]);
1579 
1580   // Grab the Frame Pointer
1581   Node *fp = _cfg.get_root_block()-&gt;head()-&gt;in(1)-&gt;in(TypeFunc::FramePtr);
1582 
1583   // For all blocks
1584   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1585     Block* block = _cfg.get_block(i);
1586 
1587     // For all instructions in block
1588     uint last_inst = block-&gt;end_idx();
1589     for (uint j = 1; j &lt;= last_inst; j++) {
1590       Node* n = block-&gt;get_node(j);
1591 
1592       // Dead instruction???
1593       assert( n-&gt;outcnt() != 0 ||// Nothing dead after post alloc
1594               C-&gt;top() == n ||  // Or the random TOP node
1595               n-&gt;is_Proj(),     // Or a fat-proj kill node
1596               &quot;No dead instructions after post-alloc&quot; );
1597 
1598       int inp = n-&gt;cisc_operand();
1599       if( inp != AdlcVMDeps::Not_cisc_spillable ) {
1600         // Convert operand number to edge index number
1601         MachNode *mach = n-&gt;as_Mach();
1602         inp = mach-&gt;operand_index(inp);
1603         Node *src = n-&gt;in(inp);   // Value to load or store
1604         LRG &amp;lrg_cisc = lrgs(_lrg_map.find_const(src));
1605         OptoReg::Name src_reg = lrg_cisc.reg();
1606         // Doubles record the HIGH register of an adjacent pair.
1607         src_reg = OptoReg::add(src_reg,1-lrg_cisc.num_regs());
1608         if( OptoReg::is_stack(src_reg) ) { // If input is on stack
1609           // This is a CISC Spill, get stack offset and construct new node
1610 #ifndef PRODUCT
1611           if( TraceCISCSpill ) {
1612             tty-&gt;print(&quot;    reg-instr:  &quot;);
1613             n-&gt;dump();
1614           }
1615 #endif
1616           int stk_offset = reg2offset(src_reg);
1617           // Bailout if we might exceed node limit when spilling this instruction
1618           C-&gt;check_node_count(0, &quot;out of nodes fixing spills&quot;);
1619           if (C-&gt;failing())  return;
1620           // Transform node
1621           MachNode *cisc = mach-&gt;cisc_version(stk_offset)-&gt;as_Mach();
1622           cisc-&gt;set_req(inp,fp);          // Base register is frame pointer
1623           if( cisc-&gt;oper_input_base() &gt; 1 &amp;&amp; mach-&gt;oper_input_base() &lt;= 1 ) {
1624             assert( cisc-&gt;oper_input_base() == 2, &quot;Only adding one edge&quot;);
1625             cisc-&gt;ins_req(1,src);         // Requires a memory edge
1626           }
1627           block-&gt;map_node(cisc, j);          // Insert into basic block
1628           n-&gt;subsume_by(cisc, C); // Correct graph
1629           //
1630           ++_used_cisc_instructions;
1631 #ifndef PRODUCT
1632           if( TraceCISCSpill ) {
1633             tty-&gt;print(&quot;    cisc-instr: &quot;);
1634             cisc-&gt;dump();
1635           }
1636 #endif
1637         } else {
1638 #ifndef PRODUCT
1639           if( TraceCISCSpill ) {
1640             tty-&gt;print(&quot;    using reg-instr: &quot;);
1641             n-&gt;dump();
1642           }
1643 #endif
1644           ++_unused_cisc_instructions;    // input can be on stack
1645         }
1646       }
1647 
1648     } // End of for all instructions
1649 
1650   } // End of for all blocks
1651 }
1652 
1653 // Helper to stretch above; recursively discover the base Node for a
1654 // given derived Node.  Easy for AddP-related machine nodes, but needs
1655 // to be recursive for derived Phis.
1656 Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &amp;maxlrg ) {
1657   // See if already computed; if so return it
1658   if( derived_base_map[derived-&gt;_idx] )
1659     return derived_base_map[derived-&gt;_idx];
1660 
1661   // See if this happens to be a base.
1662   // NOTE: we use TypePtr instead of TypeOopPtr because we can have
1663   // pointers derived from NULL!  These are always along paths that
1664   // can&#39;t happen at run-time but the optimizer cannot deduce it so
1665   // we have to handle it gracefully.
1666   assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1667           derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1668   const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1669   // If its an OOP with a non-zero offset, then it is derived.
1670   if( tj == NULL || tj-&gt;_offset == 0 ) {
1671     derived_base_map[derived-&gt;_idx] = derived;
1672     return derived;
1673   }
1674   // Derived is NULL+offset?  Base is NULL!
1675   if( derived-&gt;is_Con() ) {
1676     Node *base = _matcher.mach_null();
1677     assert(base != NULL, &quot;sanity&quot;);
1678     if (base-&gt;in(0) == NULL) {
1679       // Initialize it once and make it shared:
1680       // set control to _root and place it into Start block
1681       // (where top() node is placed).
1682       base-&gt;init_req(0, _cfg.get_root_node());
1683       Block *startb = _cfg.get_block_for_node(C-&gt;top());
1684       uint node_pos = startb-&gt;find_node(C-&gt;top());
1685       startb-&gt;insert_node(base, node_pos);
1686       _cfg.map_node_to_block(base, startb);
1687       assert(_lrg_map.live_range_id(base) == 0, &quot;should not have LRG yet&quot;);
1688 
1689       // The loadConP0 might have projection nodes depending on architecture
1690       // Add the projection nodes to the CFG
1691       for (DUIterator_Fast imax, i = base-&gt;fast_outs(imax); i &lt; imax; i++) {
1692         Node* use = base-&gt;fast_out(i);
1693         if (use-&gt;is_MachProj()) {
1694           startb-&gt;insert_node(use, ++node_pos);
1695           _cfg.map_node_to_block(use, startb);
1696           new_lrg(use, maxlrg++);
1697         }
1698       }
1699     }
1700     if (_lrg_map.live_range_id(base) == 0) {
1701       new_lrg(base, maxlrg++);
1702     }
1703     assert(base-&gt;in(0) == _cfg.get_root_node() &amp;&amp; _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C-&gt;top()), &quot;base NULL should be shared&quot;);
1704     derived_base_map[derived-&gt;_idx] = base;
1705     return base;
1706   }
1707 
1708   // Check for AddP-related opcodes
1709   if (!derived-&gt;is_Phi()) {
1710     assert(derived-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP, &quot;but is: %s&quot;, derived-&gt;Name());
1711     Node *base = derived-&gt;in(AddPNode::Base);
1712     derived_base_map[derived-&gt;_idx] = base;
1713     return base;
1714   }
1715 
1716   // Recursively find bases for Phis.
1717   // First check to see if we can avoid a base Phi here.
1718   Node *base = find_base_for_derived( derived_base_map, derived-&gt;in(1),maxlrg);
1719   uint i;
1720   for( i = 2; i &lt; derived-&gt;req(); i++ )
1721     if( base != find_base_for_derived( derived_base_map,derived-&gt;in(i),maxlrg))
1722       break;
1723   // Went to the end without finding any different bases?
1724   if( i == derived-&gt;req() ) {   // No need for a base Phi here
1725     derived_base_map[derived-&gt;_idx] = base;
1726     return base;
1727   }
1728 
1729   // Now we see we need a base-Phi here to merge the bases
1730   const Type *t = base-&gt;bottom_type();
1731   base = new PhiNode( derived-&gt;in(0), t );
1732   for( i = 1; i &lt; derived-&gt;req(); i++ ) {
1733     base-&gt;init_req(i, find_base_for_derived(derived_base_map, derived-&gt;in(i), maxlrg));
1734     t = t-&gt;meet(base-&gt;in(i)-&gt;bottom_type());
1735   }
1736   base-&gt;as_Phi()-&gt;set_type(t);
1737 
1738   // Search the current block for an existing base-Phi
1739   Block *b = _cfg.get_block_for_node(derived);
1740   for( i = 1; i &lt;= b-&gt;end_idx(); i++ ) {// Search for matching Phi
1741     Node *phi = b-&gt;get_node(i);
1742     if( !phi-&gt;is_Phi() ) {      // Found end of Phis with no match?
1743       b-&gt;insert_node(base,  i); // Must insert created Phi here as base
1744       _cfg.map_node_to_block(base, b);
1745       new_lrg(base,maxlrg++);
1746       break;
1747     }
1748     // See if Phi matches.
1749     uint j;
1750     for( j = 1; j &lt; base-&gt;req(); j++ )
1751       if( phi-&gt;in(j) != base-&gt;in(j) &amp;&amp;
1752           !(phi-&gt;in(j)-&gt;is_Con() &amp;&amp; base-&gt;in(j)-&gt;is_Con()) ) // allow different NULLs
1753         break;
1754     if( j == base-&gt;req() ) {    // All inputs match?
1755       base = phi;               // Then use existing &#39;phi&#39; and drop &#39;base&#39;
1756       break;
1757     }
1758   }
1759 
1760 
1761   // Cache info for later passes
1762   derived_base_map[derived-&gt;_idx] = base;
1763   return base;
1764 }
1765 
1766 // At each Safepoint, insert extra debug edges for each pair of derived value/
1767 // base pointer that is live across the Safepoint for oopmap building.  The
1768 // edge pairs get added in after sfpt-&gt;jvmtail()-&gt;oopoff(), but are in the
1769 // required edge set.
1770 bool PhaseChaitin::stretch_base_pointer_live_ranges(ResourceArea *a) {
1771   int must_recompute_live = false;
1772   uint maxlrg = _lrg_map.max_lrg_id();
1773   Node **derived_base_map = (Node**)a-&gt;Amalloc(sizeof(Node*)*C-&gt;unique());
1774   memset( derived_base_map, 0, sizeof(Node*)*C-&gt;unique() );
1775 
1776   // For all blocks in RPO do...
1777   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
1778     Block* block = _cfg.get_block(i);
1779     // Note use of deep-copy constructor.  I cannot hammer the original
1780     // liveout bits, because they are needed by the following coalesce pass.
1781     IndexSet liveout(_live-&gt;live(block));
1782 
1783     for (uint j = block-&gt;end_idx() + 1; j &gt; 1; j--) {
1784       Node* n = block-&gt;get_node(j - 1);
1785 
1786       // Pre-split compares of loop-phis.  Loop-phis form a cycle we would
1787       // like to see in the same register.  Compare uses the loop-phi and so
1788       // extends its live range BUT cannot be part of the cycle.  If this
1789       // extended live range overlaps with the update of the loop-phi value
1790       // we need both alive at the same time -- which requires at least 1
1791       // copy.  But because Intel has only 2-address registers we end up with
1792       // at least 2 copies, one before the loop-phi update instruction and
1793       // one after.  Instead we split the input to the compare just after the
1794       // phi.
1795       if( n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_CmpI ) {
1796         Node *phi = n-&gt;in(1);
1797         if( phi-&gt;is_Phi() &amp;&amp; phi-&gt;as_Phi()-&gt;region()-&gt;is_Loop() ) {
1798           Block *phi_block = _cfg.get_block_for_node(phi);
1799           if (_cfg.get_block_for_node(phi_block-&gt;pred(2)) == block) {
1800             const RegMask *mask = C-&gt;matcher()-&gt;idealreg2spillmask[Op_RegI];
1801             Node *spill = new MachSpillCopyNode(MachSpillCopyNode::LoopPhiInput, phi, *mask, *mask);
1802             insert_proj( phi_block, 1, spill, maxlrg++ );
1803             n-&gt;set_req(1,spill);
1804             must_recompute_live = true;
1805           }
1806         }
1807       }
1808 
1809       // Get value being defined
1810       uint lidx = _lrg_map.live_range_id(n);
1811       // Ignore the occasional brand-new live range
1812       if (lidx &amp;&amp; lidx &lt; _lrg_map.max_lrg_id()) {
1813         // Remove from live-out set
1814         liveout.remove(lidx);
1815 
1816         // Copies do not define a new value and so do not interfere.
1817         // Remove the copies source from the liveout set before interfering.
1818         uint idx = n-&gt;is_Copy();
1819         if (idx) {
1820           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1821         }
1822       }
1823 
1824       // Found a safepoint?
1825       JVMState *jvms = n-&gt;jvms();
1826       if (jvms &amp;&amp; !liveout.is_empty()) {
1827         // Now scan for a live derived pointer
1828         IndexSetIterator elements(&amp;liveout);
1829         uint neighbor;
1830         while ((neighbor = elements.next()) != 0) {
1831           // Find reaching DEF for base and derived values
1832           // This works because we are still in SSA during this call.
1833           Node *derived = lrgs(neighbor)._def;
1834           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1835           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
1836                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);
1837           // If its an OOP with a non-zero offset, then it is derived.
1838           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {
1839             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1840             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1841             // Add reaching DEFs of derived pointer and base pointer as a
1842             // pair of inputs
1843             n-&gt;add_req(derived);
1844             n-&gt;add_req(base);
1845 
1846             // See if the base pointer is already live to this point.
1847             // Since I&#39;m working on the SSA form, live-ness amounts to
1848             // reaching def&#39;s.  So if I find the base&#39;s live range then
1849             // I know the base&#39;s def reaches here.
1850             if ((_lrg_map.live_range_id(base) &gt;= _lrg_map.max_lrg_id() || // (Brand new base (hence not live) or
1851                  !liveout.member(_lrg_map.live_range_id(base))) &amp;&amp; // not live) AND
1852                  (_lrg_map.live_range_id(base) &gt; 0) &amp;&amp; // not a constant
1853                  _cfg.get_block_for_node(base) != block) { // base not def&#39;d in blk)
1854               // Base pointer is not currently live.  Since I stretched
1855               // the base pointer to here and it crosses basic-block
1856               // boundaries, the global live info is now incorrect.
1857               // Recompute live.
1858               must_recompute_live = true;
1859             } // End of if base pointer is not live to debug info
1860           }
1861         } // End of scan all live data for derived ptrs crossing GC point
1862       } // End of if found a GC point
1863 
1864       // Make all inputs live
1865       if (!n-&gt;is_Phi()) {      // Phi function uses come from prior block
1866         for (uint k = 1; k &lt; n-&gt;req(); k++) {
1867           uint lidx = _lrg_map.live_range_id(n-&gt;in(k));
1868           if (lidx &lt; _lrg_map.max_lrg_id()) {
1869             liveout.insert(lidx);
1870           }
1871         }
1872       }
1873 
1874     } // End of forall instructions in block
1875     liveout.clear();  // Free the memory used by liveout.
1876 
1877   } // End of forall blocks
1878   _lrg_map.set_max_lrg_id(maxlrg);
1879 
1880   // If I created a new live range I need to recompute live
1881   if (maxlrg != _ifg-&gt;_maxlrg) {
1882     must_recompute_live = true;
1883   }
1884 
1885   return must_recompute_live != 0;
1886 }
1887 
1888 // Extend the node to LRG mapping
1889 
1890 void PhaseChaitin::add_reference(const Node *node, const Node *old_node) {
1891   _lrg_map.extend(node-&gt;_idx, _lrg_map.live_range_id(old_node));
1892 }
1893 
1894 #ifndef PRODUCT
1895 void PhaseChaitin::dump(const Node *n) const {
1896   uint r = (n-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(n) : 0;
1897   tty-&gt;print(&quot;L%d&quot;,r);
1898   if (r &amp;&amp; n-&gt;Opcode() != Op_Phi) {
1899     if( _node_regs ) {          // Got a post-allocation copy of allocation?
1900       tty-&gt;print(&quot;[&quot;);
1901       OptoReg::Name second = get_reg_second(n);
1902       if( OptoReg::is_valid(second) ) {
1903         if( OptoReg::is_reg(second) )
1904           tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1905         else
1906           tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(second));
1907       }
1908       OptoReg::Name first = get_reg_first(n);
1909       if( OptoReg::is_reg(first) )
1910         tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1911       else
1912          tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer), reg2offset_unchecked(first));
1913     } else
1914     n-&gt;out_RegMask().dump();
1915   }
1916   tty-&gt;print(&quot;/N%d\t&quot;,n-&gt;_idx);
1917   tty-&gt;print(&quot;%s === &quot;, n-&gt;Name());
1918   uint k;
1919   for (k = 0; k &lt; n-&gt;req(); k++) {
1920     Node *m = n-&gt;in(k);
1921     if (!m) {
1922       tty-&gt;print(&quot;_ &quot;);
1923     }
1924     else {
1925       uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1926       tty-&gt;print(&quot;L%d&quot;,r);
1927       // Data MultiNode&#39;s can have projections with no real registers.
1928       // Don&#39;t die while dumping them.
1929       int op = n-&gt;Opcode();
1930       if( r &amp;&amp; op != Op_Phi &amp;&amp; op != Op_Proj &amp;&amp; op != Op_SCMemProj) {
1931         if( _node_regs ) {
1932           tty-&gt;print(&quot;[&quot;);
1933           OptoReg::Name second = get_reg_second(n-&gt;in(k));
1934           if( OptoReg::is_valid(second) ) {
1935             if( OptoReg::is_reg(second) )
1936               tty-&gt;print(&quot;%s:&quot;,Matcher::regName[second]);
1937             else
1938               tty-&gt;print(&quot;%s+%d:&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1939                          reg2offset_unchecked(second));
1940           }
1941           OptoReg::Name first = get_reg_first(n-&gt;in(k));
1942           if( OptoReg::is_reg(first) )
1943             tty-&gt;print(&quot;%s]&quot;,Matcher::regName[first]);
1944           else
1945             tty-&gt;print(&quot;%s+%d]&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
1946                        reg2offset_unchecked(first));
1947         } else
1948           n-&gt;in_RegMask(k).dump();
1949       }
1950       tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1951     }
1952   }
1953   if( k &lt; n-&gt;len() &amp;&amp; n-&gt;in(k) ) tty-&gt;print(&quot;| &quot;);
1954   for( ; k &lt; n-&gt;len(); k++ ) {
1955     Node *m = n-&gt;in(k);
1956     if(!m) {
1957       break;
1958     }
1959     uint r = (m-&gt;_idx &lt; _lrg_map.size()) ? _lrg_map.find_const(m) : 0;
1960     tty-&gt;print(&quot;L%d&quot;,r);
1961     tty-&gt;print(&quot;/N%d &quot;,m-&gt;_idx);
1962   }
1963   if( n-&gt;is_Mach() ) n-&gt;as_Mach()-&gt;dump_spec(tty);
1964   else n-&gt;dump_spec(tty);
1965   if( _spilled_once.test(n-&gt;_idx ) ) {
1966     tty-&gt;print(&quot; Spill_1&quot;);
1967     if( _spilled_twice.test(n-&gt;_idx ) )
1968       tty-&gt;print(&quot; Spill_2&quot;);
1969   }
1970   tty-&gt;print(&quot;\n&quot;);
1971 }
1972 
1973 void PhaseChaitin::dump(const Block *b) const {
1974   b-&gt;dump_head(&amp;_cfg);
1975 
1976   // For all instructions
1977   for( uint j = 0; j &lt; b-&gt;number_of_nodes(); j++ )
1978     dump(b-&gt;get_node(j));
1979   // Print live-out info at end of block
1980   if( _live ) {
1981     tty-&gt;print(&quot;Liveout: &quot;);
1982     IndexSet *live = _live-&gt;live(b);
1983     IndexSetIterator elements(live);
1984     tty-&gt;print(&quot;{&quot;);
1985     uint i;
1986     while ((i = elements.next()) != 0) {
1987       tty-&gt;print(&quot;L%d &quot;, _lrg_map.find_const(i));
1988     }
1989     tty-&gt;print_cr(&quot;}&quot;);
1990   }
1991   tty-&gt;print(&quot;\n&quot;);
1992 }
1993 
1994 void PhaseChaitin::dump() const {
1995   tty-&gt;print( &quot;--- Chaitin -- argsize: %d  framesize: %d ---\n&quot;,
1996               _matcher._new_SP, _framesize );
1997 
1998   // For all blocks
1999   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2000     dump(_cfg.get_block(i));
2001   }
2002   // End of per-block dump
2003   tty-&gt;print(&quot;\n&quot;);
2004 
2005   if (!_ifg) {
2006     tty-&gt;print(&quot;(No IFG.)\n&quot;);
2007     return;
2008   }
2009 
2010   // Dump LRG array
2011   tty-&gt;print(&quot;--- Live RanGe Array ---\n&quot;);
2012   for (uint i2 = 1; i2 &lt; _lrg_map.max_lrg_id(); i2++) {
2013     tty-&gt;print(&quot;L%d: &quot;,i2);
2014     if (i2 &lt; _ifg-&gt;_maxlrg) {
2015       lrgs(i2).dump();
2016     }
2017     else {
2018       tty-&gt;print_cr(&quot;new LRG&quot;);
2019     }
2020   }
2021   tty-&gt;cr();
2022 
2023   // Dump lo-degree list
2024   tty-&gt;print(&quot;Lo degree: &quot;);
2025   for(uint i3 = _lo_degree; i3; i3 = lrgs(i3)._next )
2026     tty-&gt;print(&quot;L%d &quot;,i3);
2027   tty-&gt;cr();
2028 
2029   // Dump lo-stk-degree list
2030   tty-&gt;print(&quot;Lo stk degree: &quot;);
2031   for(uint i4 = _lo_stk_degree; i4; i4 = lrgs(i4)._next )
2032     tty-&gt;print(&quot;L%d &quot;,i4);
2033   tty-&gt;cr();
2034 
2035   // Dump lo-degree list
2036   tty-&gt;print(&quot;Hi degree: &quot;);
2037   for(uint i5 = _hi_degree; i5; i5 = lrgs(i5)._next )
2038     tty-&gt;print(&quot;L%d &quot;,i5);
2039   tty-&gt;cr();
2040 }
2041 
2042 void PhaseChaitin::dump_degree_lists() const {
2043   // Dump lo-degree list
2044   tty-&gt;print(&quot;Lo degree: &quot;);
2045   for( uint i = _lo_degree; i; i = lrgs(i)._next )
2046     tty-&gt;print(&quot;L%d &quot;,i);
2047   tty-&gt;cr();
2048 
2049   // Dump lo-stk-degree list
2050   tty-&gt;print(&quot;Lo stk degree: &quot;);
2051   for(uint i2 = _lo_stk_degree; i2; i2 = lrgs(i2)._next )
2052     tty-&gt;print(&quot;L%d &quot;,i2);
2053   tty-&gt;cr();
2054 
2055   // Dump lo-degree list
2056   tty-&gt;print(&quot;Hi degree: &quot;);
2057   for(uint i3 = _hi_degree; i3; i3 = lrgs(i3)._next )
2058     tty-&gt;print(&quot;L%d &quot;,i3);
2059   tty-&gt;cr();
2060 }
2061 
2062 void PhaseChaitin::dump_simplified() const {
2063   tty-&gt;print(&quot;Simplified: &quot;);
2064   for( uint i = _simplified; i; i = lrgs(i)._next )
2065     tty-&gt;print(&quot;L%d &quot;,i);
2066   tty-&gt;cr();
2067 }
2068 
2069 static char *print_reg( OptoReg::Name reg, const PhaseChaitin *pc, char *buf ) {
2070   if ((int)reg &lt; 0)
2071     sprintf(buf, &quot;&lt;OptoReg::%d&gt;&quot;, (int)reg);
2072   else if (OptoReg::is_reg(reg))
2073     strcpy(buf, Matcher::regName[reg]);
2074   else
2075     sprintf(buf,&quot;%s + #%d&quot;,OptoReg::regname(OptoReg::c_frame_pointer),
2076             pc-&gt;reg2offset(reg));
2077   return buf+strlen(buf);
2078 }
2079 
2080 // Dump a register name into a buffer.  Be intelligent if we get called
2081 // before allocation is complete.
2082 char *PhaseChaitin::dump_register( const Node *n, char *buf  ) const {
2083   if( _node_regs ) {
2084     // Post allocation, use direct mappings, no LRG info available
2085     print_reg( get_reg_first(n), this, buf );
2086   } else {
2087     uint lidx = _lrg_map.find_const(n); // Grab LRG number
2088     if( !_ifg ) {
2089       sprintf(buf,&quot;L%d&quot;,lidx);  // No register binding yet
2090     } else if( !lidx ) {        // Special, not allocated value
2091       strcpy(buf,&quot;Special&quot;);
2092     } else {
2093       if (lrgs(lidx)._is_vector) {
2094         if (lrgs(lidx).mask().is_bound_set(lrgs(lidx).num_regs()))
2095           print_reg( lrgs(lidx).reg(), this, buf ); // a bound machine register
2096         else
2097           sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2098       } else if( (lrgs(lidx).num_regs() == 1)
2099                  ? lrgs(lidx).mask().is_bound1()
2100                  : lrgs(lidx).mask().is_bound_pair() ) {
2101         // Hah!  We have a bound machine register
2102         print_reg( lrgs(lidx).reg(), this, buf );
2103       } else {
2104         sprintf(buf,&quot;L%d&quot;,lidx); // No register binding yet
2105       }
2106     }
2107   }
2108   return buf+strlen(buf);
2109 }
2110 
2111 void PhaseChaitin::dump_for_spill_split_recycle() const {
2112   if( WizardMode &amp;&amp; (PrintCompilation || PrintOpto) ) {
2113     // Display which live ranges need to be split and the allocator&#39;s state
2114     tty-&gt;print_cr(&quot;Graph-Coloring Iteration %d will split the following live ranges&quot;, _trip_cnt);
2115     for (uint bidx = 1; bidx &lt; _lrg_map.max_lrg_id(); bidx++) {
2116       if( lrgs(bidx).alive() &amp;&amp; lrgs(bidx).reg() &gt;= LRG::SPILL_REG ) {
2117         tty-&gt;print(&quot;L%d: &quot;, bidx);
2118         lrgs(bidx).dump();
2119       }
2120     }
2121     tty-&gt;cr();
2122     dump();
2123   }
2124 }
2125 
2126 void PhaseChaitin::dump_frame() const {
2127   const char *fp = OptoReg::regname(OptoReg::c_frame_pointer);
2128   const TypeTuple *domain = C-&gt;tf()-&gt;domain();
2129   const int        argcnt = domain-&gt;cnt() - TypeFunc::Parms;
2130 
2131   // Incoming arguments in registers dump
2132   for( int k = 0; k &lt; argcnt; k++ ) {
2133     OptoReg::Name parmreg = _matcher._parm_regs[k].first();
2134     if( OptoReg::is_reg(parmreg))  {
2135       const char *reg_name = OptoReg::regname(parmreg);
2136       tty-&gt;print(&quot;#r%3.3d %s&quot;, parmreg, reg_name);
2137       parmreg = _matcher._parm_regs[k].second();
2138       if( OptoReg::is_reg(parmreg))  {
2139         tty-&gt;print(&quot;:%s&quot;, OptoReg::regname(parmreg));
2140       }
2141       tty-&gt;print(&quot;   : parm %d: &quot;, k);
2142       domain-&gt;field_at(k + TypeFunc::Parms)-&gt;dump();
2143       tty-&gt;cr();
2144     }
2145   }
2146 
2147   // Check for un-owned padding above incoming args
2148   OptoReg::Name reg = _matcher._new_SP;
2149   if( reg &gt; _matcher._in_arg_limit ) {
2150     reg = OptoReg::add(reg, -1);
2151     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: pad0, owned by CALLER&quot;, reg, fp, reg2offset_unchecked(reg));
2152   }
2153 
2154   // Incoming argument area dump
2155   OptoReg::Name begin_in_arg = OptoReg::add(_matcher._old_SP,C-&gt;out_preserve_stack_slots());
2156   while( reg &gt; begin_in_arg ) {
2157     reg = OptoReg::add(reg, -1);
2158     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2159     int j;
2160     for( j = 0; j &lt; argcnt; j++) {
2161       if( _matcher._parm_regs[j].first() == reg ||
2162           _matcher._parm_regs[j].second() == reg ) {
2163         tty-&gt;print(&quot;parm %d: &quot;,j);
2164         domain-&gt;field_at(j + TypeFunc::Parms)-&gt;dump();
2165         tty-&gt;cr();
2166         break;
2167       }
2168     }
2169     if( j &gt;= argcnt )
2170       tty-&gt;print_cr(&quot;HOLE, owned by SELF&quot;);
2171   }
2172 
2173   // Old outgoing preserve area
2174   while( reg &gt; _matcher._old_SP ) {
2175     reg = OptoReg::add(reg, -1);
2176     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: old out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2177   }
2178 
2179   // Old SP
2180   tty-&gt;print_cr(&quot;# -- Old %s -- Framesize: %d --&quot;,fp,
2181     reg2offset_unchecked(OptoReg::add(_matcher._old_SP,-1)) - reg2offset_unchecked(_matcher._new_SP)+jintSize);
2182 
2183   // Preserve area dump
2184   int fixed_slots = C-&gt;fixed_slots();
2185   OptoReg::Name begin_in_preserve = OptoReg::add(_matcher._old_SP, -(int)C-&gt;in_preserve_stack_slots());
2186   OptoReg::Name return_addr = _matcher.return_addr();
2187 
2188   reg = OptoReg::add(reg, -1);
2189   while (OptoReg::is_stack(reg)) {
2190     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2191     if (return_addr == reg) {
2192       tty-&gt;print_cr(&quot;return address&quot;);
2193     } else if (reg &gt;= begin_in_preserve) {
2194       // Preserved slots are present on x86
2195       if (return_addr == OptoReg::add(reg, VMRegImpl::slots_per_word))
2196         tty-&gt;print_cr(&quot;saved fp register&quot;);
2197       else if (return_addr == OptoReg::add(reg, 2*VMRegImpl::slots_per_word) &amp;&amp;
2198                VerifyStackAtCalls)
2199         tty-&gt;print_cr(&quot;0xBADB100D   +VerifyStackAtCalls&quot;);
2200       else
2201         tty-&gt;print_cr(&quot;in_preserve&quot;);
2202     } else if ((int)OptoReg::reg2stack(reg) &lt; fixed_slots) {
2203       tty-&gt;print_cr(&quot;Fixed slot %d&quot;, OptoReg::reg2stack(reg));
2204     } else {
2205       tty-&gt;print_cr(&quot;pad2, stack alignment&quot;);
2206     }
2207     reg = OptoReg::add(reg, -1);
2208   }
2209 
2210   // Spill area dump
2211   reg = OptoReg::add(_matcher._new_SP, _framesize );
2212   while( reg &gt; _matcher._out_arg_limit ) {
2213     reg = OptoReg::add(reg, -1);
2214     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: spill&quot;,reg,fp,reg2offset_unchecked(reg));
2215   }
2216 
2217   // Outgoing argument area dump
2218   while( reg &gt; OptoReg::add(_matcher._new_SP, C-&gt;out_preserve_stack_slots()) ) {
2219     reg = OptoReg::add(reg, -1);
2220     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: outgoing argument&quot;,reg,fp,reg2offset_unchecked(reg));
2221   }
2222 
2223   // Outgoing new preserve area
2224   while( reg &gt; _matcher._new_SP ) {
2225     reg = OptoReg::add(reg, -1);
2226     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: new out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2227   }
2228   tty-&gt;print_cr(&quot;#&quot;);
2229 }
2230 
2231 void PhaseChaitin::dump_bb( uint pre_order ) const {
2232   tty-&gt;print_cr(&quot;---dump of B%d---&quot;,pre_order);
2233   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2234     Block* block = _cfg.get_block(i);
2235     if (block-&gt;_pre_order == pre_order) {
2236       dump(block);
2237     }
2238   }
2239 }
2240 
2241 void PhaseChaitin::dump_lrg( uint lidx, bool defs_only ) const {
2242   tty-&gt;print_cr(&quot;---dump of L%d---&quot;,lidx);
2243 
2244   if (_ifg) {
2245     if (lidx &gt;= _lrg_map.max_lrg_id()) {
2246       tty-&gt;print(&quot;Attempt to print live range index beyond max live range.\n&quot;);
2247       return;
2248     }
2249     tty-&gt;print(&quot;L%d: &quot;,lidx);
2250     if (lidx &lt; _ifg-&gt;_maxlrg) {
2251       lrgs(lidx).dump();
2252     } else {
2253       tty-&gt;print_cr(&quot;new LRG&quot;);
2254     }
2255   }
2256   if( _ifg &amp;&amp; lidx &lt; _ifg-&gt;_maxlrg) {
2257     tty-&gt;print(&quot;Neighbors: %d - &quot;, _ifg-&gt;neighbor_cnt(lidx));
2258     _ifg-&gt;neighbors(lidx)-&gt;dump();
2259     tty-&gt;cr();
2260   }
2261   // For all blocks
2262   for (uint i = 0; i &lt; _cfg.number_of_blocks(); i++) {
2263     Block* block = _cfg.get_block(i);
2264     int dump_once = 0;
2265 
2266     // For all instructions
2267     for( uint j = 0; j &lt; block-&gt;number_of_nodes(); j++ ) {
2268       Node *n = block-&gt;get_node(j);
2269       if (_lrg_map.find_const(n) == lidx) {
2270         if (!dump_once++) {
2271           tty-&gt;cr();
2272           block-&gt;dump_head(&amp;_cfg);
2273         }
2274         dump(n);
2275         continue;
2276       }
2277       if (!defs_only) {
2278         uint cnt = n-&gt;req();
2279         for( uint k = 1; k &lt; cnt; k++ ) {
2280           Node *m = n-&gt;in(k);
2281           if (!m)  {
2282             continue;  // be robust in the dumper
2283           }
2284           if (_lrg_map.find_const(m) == lidx) {
2285             if (!dump_once++) {
2286               tty-&gt;cr();
2287               block-&gt;dump_head(&amp;_cfg);
2288             }
2289             dump(n);
2290           }
2291         }
2292       }
2293     }
2294   } // End of per-block dump
2295   tty-&gt;cr();
2296 }
2297 #endif // not PRODUCT
2298 
2299 int PhaseChaitin::_final_loads  = 0;
2300 int PhaseChaitin::_final_stores = 0;
2301 int PhaseChaitin::_final_memoves= 0;
2302 int PhaseChaitin::_final_copies = 0;
2303 double PhaseChaitin::_final_load_cost  = 0;
2304 double PhaseChaitin::_final_store_cost = 0;
2305 double PhaseChaitin::_final_memove_cost= 0;
2306 double PhaseChaitin::_final_copy_cost  = 0;
2307 int PhaseChaitin::_conserv_coalesce = 0;
2308 int PhaseChaitin::_conserv_coalesce_pair = 0;
2309 int PhaseChaitin::_conserv_coalesce_trie = 0;
2310 int PhaseChaitin::_conserv_coalesce_quad = 0;
2311 int PhaseChaitin::_post_alloc = 0;
2312 int PhaseChaitin::_lost_opp_pp_coalesce = 0;
2313 int PhaseChaitin::_lost_opp_cflow_coalesce = 0;
2314 int PhaseChaitin::_used_cisc_instructions   = 0;
2315 int PhaseChaitin::_unused_cisc_instructions = 0;
2316 int PhaseChaitin::_allocator_attempts       = 0;
2317 int PhaseChaitin::_allocator_successes      = 0;
2318 
2319 #ifndef PRODUCT
2320 uint PhaseChaitin::_high_pressure           = 0;
2321 uint PhaseChaitin::_low_pressure            = 0;
2322 
2323 void PhaseChaitin::print_chaitin_statistics() {
2324   tty-&gt;print_cr(&quot;Inserted %d spill loads, %d spill stores, %d mem-mem moves and %d copies.&quot;, _final_loads, _final_stores, _final_memoves, _final_copies);
2325   tty-&gt;print_cr(&quot;Total load cost= %6.0f, store cost = %6.0f, mem-mem cost = %5.2f, copy cost = %5.0f.&quot;, _final_load_cost, _final_store_cost, _final_memove_cost, _final_copy_cost);
2326   tty-&gt;print_cr(&quot;Adjusted spill cost = %7.0f.&quot;,
2327                 _final_load_cost*4.0 + _final_store_cost  * 2.0 +
2328                 _final_copy_cost*1.0 + _final_memove_cost*12.0);
2329   tty-&gt;print(&quot;Conservatively coalesced %d copies, %d pairs&quot;,
2330                 _conserv_coalesce, _conserv_coalesce_pair);
2331   if( _conserv_coalesce_trie || _conserv_coalesce_quad )
2332     tty-&gt;print(&quot;, %d tries, %d quads&quot;, _conserv_coalesce_trie, _conserv_coalesce_quad);
2333   tty-&gt;print_cr(&quot;, %d post alloc.&quot;, _post_alloc);
2334   if( _lost_opp_pp_coalesce || _lost_opp_cflow_coalesce )
2335     tty-&gt;print_cr(&quot;Lost coalesce opportunity, %d private-private, and %d cflow interfered.&quot;,
2336                   _lost_opp_pp_coalesce, _lost_opp_cflow_coalesce );
2337   if( _used_cisc_instructions || _unused_cisc_instructions )
2338     tty-&gt;print_cr(&quot;Used cisc instruction  %d,  remained in register %d&quot;,
2339                    _used_cisc_instructions, _unused_cisc_instructions);
2340   if( _allocator_successes != 0 )
2341     tty-&gt;print_cr(&quot;Average allocation trips %f&quot;, (float)_allocator_attempts/(float)_allocator_successes);
2342   tty-&gt;print_cr(&quot;High Pressure Blocks = %d, Low Pressure Blocks = %d&quot;, _high_pressure, _low_pressure);
2343 }
2344 #endif // not PRODUCT
    </pre>
  </body>
</html>