<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jvm/ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;

  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 

  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;

  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
</pre>
<hr />
<pre>
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);

 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 190                 Feature.SEALED_CLASSES.allowedInSource(source);
 191     }
 192 
 193     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 194         return  keepEndPositions
 195                 ? new SimpleEndPosTable(this)
 196                 : new EmptyEndPosTable(this);
 197     }
 198 
 199     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 200         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 201     }
 202 
 203     /** Switch: should we fold strings?
 204      */
 205     boolean allowStringFolding;
 206 




 207     /** Switch: should we keep docComments?
 208      */
 209     boolean keepDocComments;
 210 
 211     /** Switch: should we keep line table?
 212      */
 213     boolean keepLineMap;
 214 
 215     /** Switch: is &quot;this&quot; allowed as an identifier?
 216      * This is needed to parse receiver types.
 217      */
 218     boolean allowThisIdent;
 219 
 220     /** Switch: is yield statement allowed in this source level?
 221      */
 222     boolean allowYieldStatement;
 223 
 224     /** Switch: are records allowed in this source level?
 225      */
 226     boolean allowRecords;
</pre>
<hr />
<pre>
 286 
 287     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 288         return peekToken(0, tk1, tk2);
 289     }
 290 
 291     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 292         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 293                 tk2.accepts(S.token(lookahead + 2).kind);
 294     }
 295 
 296     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 297         return peekToken(0, tk1, tk2, tk3);
 298     }
 299 
 300     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 301         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 302                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 303                 tk3.accepts(S.token(lookahead + 3).kind);
 304     }
 305 







 306     @SuppressWarnings(&quot;unchecked&quot;)
 307     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 308         return peekToken(0, kinds);
 309     }
 310 
 311     @SuppressWarnings(&quot;unchecked&quot;)
 312     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 313         for (; lookahead &lt; kinds.length ; lookahead++) {
 314             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 315                 return false;
 316             }
 317         }
 318         return true;
 319     }
 320 
 321     /* ---------- error recovery -------------- */
 322 
 323     private JCErroneous errorTree;
 324 
 325     /** Skip forward until a suitable stop token is found.
</pre>
<hr />
<pre>
 455 
 456     /** If next input token matches given token, skip it, otherwise report
 457      *  an error.
 458      */
 459     public void accept(TokenKind tk) {
 460         accept(tk, Errors::Expected);
 461     }
 462 
 463     /** If next input token matches given token, skip it, otherwise report
 464      *  an error.
 465      */
 466     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 467         if (token.kind == tk) {
 468             nextToken();
 469         } else {
 470             setErrorEndPos(token.pos);
 471             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 472         }
 473     }
 474 
















 475     /** Report an illegal start of expression/type error at given position.
 476      */
 477     JCExpression illegal(int pos) {
 478         setErrorEndPos(pos);
 479         if ((mode &amp; EXPR) != 0)
 480             return syntaxError(pos, Errors.IllegalStartOfExpr);
 481         else
 482             return syntaxError(pos, Errors.IllegalStartOfType);
 483 
 484     }
 485 
 486     /** Report an illegal start of expression/type error at current position.
 487      */
 488     JCExpression illegal() {
 489         return illegal(token.pos);
 490     }
 491 
 492     /** Diagnose a modifier flag from the set, if any. */
 493     protected void checkNoMods(long mods) {
 494         if (mods != 0) {
</pre>
<hr />
<pre>
1098                 selectTypeMode();
1099                 return typeArgument();
1100             } else
1101                 return illegal();
1102         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1103             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1104                 TokenKind tk = token.kind;
1105                 nextToken();
1106                 selectExprMode();
1107                 if (tk == SUB &amp;&amp;
1108                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1109                     token.radix() == 10) {
1110                     selectExprMode();
1111                     t = literal(names.hyphen, pos);
1112                 } else {
1113                     t = term3();
1114                     return F.at(pos).Unary(unoptag(tk), t);
1115                 }
1116             } else return illegal();
1117             break;















1118         case LPAREN:
1119             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1120                 ParensResult pres = analyzeParens();
1121                 switch (pres) {
1122                     case CAST:
1123                        accept(LPAREN);
1124                        selectTypeMode();
1125                        int pos1 = pos;
1126                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1127                        while (token.kind == AMP) {
1128                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1129                            accept(AMP);
1130                            targets = targets.prepend(parseType());
1131                        }
1132                        if (targets.length() &gt; 1) {
1133                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1134                        }
1135                        accept(RPAREN);
1136                        selectExprMode();
1137                        JCExpression t1 = term3();
</pre>
<hr />
<pre>
1266                         break loop;
1267                     case LPAREN:
1268                         if ((mode &amp; EXPR) != 0) {
1269                             selectExprMode();
1270                             t = arguments(typeArgs, t);
1271                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1272                             typeArgs = null;
1273                         }
1274                         break loop;
1275                     case DOT:
1276                         nextToken();
1277                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1278                             return illegal();
1279                         }
1280                         int oldmode = mode;
1281                         mode &amp;= ~NOPARAMS;
1282                         typeArgs = typeArgumentsOpt(EXPR);
1283                         mode = oldmode;
1284                         if ((mode &amp; EXPR) != 0) {
1285                             switch (token.kind) {






1286                             case CLASS:
1287                                 if (typeArgs != null) return illegal();
1288                                 selectExprMode();
1289                                 t = to(F.at(pos).Select(t, names._class));
1290                                 nextToken();
1291                                 break loop;
1292                             case THIS:
1293                                 if (typeArgs != null) return illegal();
1294                                 selectExprMode();
1295                                 t = to(F.at(pos).Select(t, names._this));
1296                                 nextToken();
1297                                 break loop;
1298                             case SUPER:
1299                                 selectExprMode();
1300                                 t = to(F.at(pos).Select(t, names._super));
1301                                 t = superSuffix(typeArgs, t);
1302                                 typeArgs = null;
1303                                 break loop;
1304                             case NEW:
1305                                 if (typeArgs != null) return illegal();
</pre>
<hr />
<pre>
1315 
1316                         List&lt;JCAnnotation&gt; tyannos = null;
1317                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1318                             tyannos = typeAnnotationsOpt();
1319                         }
1320                         // typeArgs saved for next loop iteration.
1321                         t = toP(F.at(pos).Select(t, ident()));
1322                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1323                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1324                         }
1325                         break;
1326                     case ELLIPSIS:
1327                         if (this.permitTypeAnnotationsPushBack) {
1328                             this.typeAnnotationsPushedBack = annos;
1329                         } else if (annos.nonEmpty()) {
1330                             // Don&#39;t return here -- error recovery attempt
1331                             illegal(annos.head.pos);
1332                         }
1333                         break loop;
1334                     case LT:
<span class="line-modified">1335                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {</span>
<span class="line-modified">1336                             //this is an unbound method reference whose qualifier</span>
<span class="line-modified">1337                             //is a generic type i.e. A&lt;S&gt;::m</span>

1338                             int pos1 = token.pos;
1339                             accept(LT);
1340                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1341                             args.append(typeArgument());
1342                             while (token.kind == COMMA) {
1343                                 nextToken();
1344                                 args.append(typeArgument());
1345                             }
1346                             accept(GT);
1347                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1348                             while (token.kind == DOT) {
1349                                 nextToken();






1350                                 selectTypeMode();
1351                                 t = toP(F.at(token.pos).Select(t, ident()));
1352                                 t = typeArgumentsOpt(t);
1353                             }
1354                             t = bracketsOpt(t);
1355                             if (token.kind != COLCOL) {
1356                                 //method reference expected here
1357                                 t = illegal();
1358                             }
1359                             selectExprMode();
1360                             return term3Rest(t, typeArgs);
1361                         }
1362                         break loop;
1363                     default:
1364                         break loop;
1365                     }
1366                 }
1367             }
1368             if (typeArgs != null) illegal();
1369             t = typeArgumentsOpt(t);
</pre>
<hr />
<pre>
1494                         }
1495                         return t;
1496                     }
1497                     mode = oldmode;
1498                 }
1499                 if ((mode &amp; EXPR) != 0) {
1500                     selectExprMode();
1501                     JCExpression t1 = term();
1502                     t = to(F.at(pos1).Indexed(t, t1));
1503                 }
1504                 accept(RBRACKET);
1505             } else if (token.kind == DOT) {
1506                 nextToken();
1507                 typeArgs = typeArgumentsOpt(EXPR);
1508                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1509                     selectExprMode();
1510                     t = to(F.at(pos1).Select(t, names._super));
1511                     nextToken();
1512                     t = arguments(typeArgs, t);
1513                     typeArgs = null;
<span class="line-modified">1514                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {</span>
1515                     if (typeArgs != null) return illegal();
1516                     selectExprMode();
1517                     int pos2 = token.pos;
1518                     nextToken();
1519                     if (token.kind == LT) typeArgs = typeArguments(false);
1520                     t = innerCreator(pos2, typeArgs, t);
1521                     typeArgs = null;
1522                 } else {
1523                     List&lt;JCAnnotation&gt; tyannos = null;
1524                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1525                         // is the mode check needed?
1526                         tyannos = typeAnnotationsOpt();
1527                     }
1528                     t = toP(F.at(pos1).Select(t, ident(true)));
1529                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1530                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1531                     }
1532                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1533                     typeArgs = null;
1534                 }
</pre>
<hr />
<pre>
1541                 if (!annos.isEmpty()) {
1542                     if (permitTypeAnnotationsPushBack)
1543                         typeAnnotationsPushedBack = annos;
1544                     else
1545                         return illegal(annos.head.pos);
1546                 }
1547                 break;
1548             }
1549         }
1550         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1551             selectExprMode();
1552             t = to(F.at(token.pos).Unary(
1553                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1554             nextToken();
1555         }
1556         return toP(t);
1557     }
1558 
1559     /**
1560      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<span class="line-modified">1561      * method reference or a binary expression. To disambiguate, look for a</span>

1562      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1563      */
1564     @SuppressWarnings(&quot;fallthrough&quot;)
<span class="line-modified">1565     boolean isUnboundMemberRef() {</span>
1566         int pos = 0, depth = 0;
1567         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1568             switch (t.kind) {
1569                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1570                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1571                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1572                 case DOUBLE: case BOOLEAN: case CHAR:
1573                 case MONKEYS_AT:
1574                     break;
1575 
1576                 case LPAREN:
1577                     // skip annotation values
1578                     int nesting = 0;
1579                     for (; ; pos++) {
1580                         TokenKind tk2 = S.token(pos).kind;
1581                         switch (tk2) {
1582                             case EOF:
1583                                 return false;
1584                             case LPAREN:
1585                                 nesting++;
</pre>
<hr />
<pre>
1667                     // based on subsequent token.
1668                     switch (S.token(lookahead + 1).kind) {
1669                         /*case PLUSPLUS: case SUBSUB: */
1670                         case BANG: case TILDE:
1671                         case LPAREN: case THIS: case SUPER:
1672                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1673                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1674                         case TRUE: case FALSE: case NULL:
1675                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1676                         case SWITCH:
1677                         case BYTE: case SHORT: case CHAR: case INT:
1678                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1679                             return ParensResult.CAST;
1680                         default:
1681                             return defaultResult;
1682                     }
1683                 case UNDERSCORE:
1684                 case ASSERT:
1685                 case ENUM:
1686                 case IDENTIFIER:
<span class="line-modified">1687                     if (peekToken(lookahead, LAX_IDENTIFIER)) {</span>
<span class="line-modified">1688                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</span>
1689                         return ParensResult.EXPLICIT_LAMBDA;
1690                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1691                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1692                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1693                                                       : ParensResult.PARENS;
1694                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1695                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1696                     }
1697                     type = false;
1698                     break;
1699                 case FINAL:
1700                 case ELLIPSIS:
1701                     //those can only appear in explicit lambdas
1702                     return ParensResult.EXPLICIT_LAMBDA;
1703                 case MONKEYS_AT:
1704                     type = true;
1705                     lookahead += 1; //skip &#39;@&#39;
1706                     while (peekToken(lookahead, DOT)) {
1707                         lookahead += 2;
1708                     }
</pre>
<hr />
<pre>
1744                         break;
1745                     } else {
1746                         return ParensResult.PARENS;
1747                     }
1748                 case LT:
1749                     depth++; break;
1750                 case GTGTGT:
1751                     depth--;
1752                 case GTGT:
1753                     depth--;
1754                 case GT:
1755                     depth--;
1756                     if (depth == 0) {
1757                         if (peekToken(lookahead, RPAREN) ||
1758                                 peekToken(lookahead, AMP)) {
1759                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1760                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1761                             return ParensResult.CAST;
1762                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1763                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||


1764                                 peekToken(lookahead, ELLIPSIS)) {
1765                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1766                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1767                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1768                             return ParensResult.EXPLICIT_LAMBDA;
1769                         }
1770                         //it looks a type, but could still be (i) a cast to generic type,
1771                         //(ii) an unbound method reference or (iii) an explicit lambda
1772                         type = true;
1773                         break;
1774                     } else if (depth &lt; 0) {
1775                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1776                         return ParensResult.PARENS;
1777                     }
1778                     break;
1779                 default:
1780                     //this includes EOF
1781                     return defaultResult;
1782             }
1783         }
</pre>
<hr />
<pre>
2140 
2141     private JCExpression bracketsOptCont(JCExpression t, int pos,
2142             List&lt;JCAnnotation&gt; annotations) {
2143         accept(RBRACKET);
2144         t = bracketsOpt(t);
2145         t = toP(F.at(pos).TypeArray(t));
2146         if (annotations.nonEmpty()) {
2147             t = toP(F.at(pos).AnnotatedType(annotations, t));
2148         }
2149         return t;
2150     }
2151 
2152     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2153      *  BracketsSuffixType =
2154      */
2155     JCExpression bracketsSuffix(JCExpression t) {
2156         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2157             selectExprMode();
2158             int pos = token.pos;
2159             nextToken();
<span class="line-modified">2160             accept(CLASS);</span>
2161             if (token.pos == endPosTable.errorEndPos) {
2162                 // error recovery
2163                 Name name;
2164                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2165                     name = token.name();
2166                     nextToken();
2167                 } else {
2168                     name = names.error;
2169                 }
2170                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2171             } else {
2172                 Tag tag = t.getTag();
2173                 // Type annotations are illegal on class literals. Annotated non array class literals
2174                 // are complained about directly in term3(), Here check for type annotations on dimensions
2175                 // taking care to handle some interior dimension(s) being annotated.
2176                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2177                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
<span class="line-modified">2178                 t = toP(F.at(pos).Select(t, names._class));</span>
2179             }
2180         } else if ((mode &amp; TYPE) != 0) {
2181             if (token.kind != COLCOL) {
2182                 selectTypeMode();
2183             }
2184         } else if (token.kind != COLCOL) {
2185             syntaxError(token.pos, Errors.DotClassExpected);
2186         }
2187         return t;
2188     }
2189 
2190     /**
2191      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2192      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2193      */
2194     JCExpression memberReferenceSuffix(JCExpression t) {
2195         int pos1 = token.pos;
2196         accept(COLCOL);
2197         return memberReferenceSuffix(pos1, t);
2198     }
</pre>
<hr />
<pre>
2203         List&lt;JCExpression&gt; typeArgs = null;
2204         if (token.kind == LT) {
2205             typeArgs = typeArguments(false);
2206         }
2207         Name refName;
2208         ReferenceMode refMode;
2209         if (token.kind == NEW) {
2210             refMode = ReferenceMode.NEW;
2211             refName = names.init;
2212             nextToken();
2213         } else {
2214             refMode = ReferenceMode.INVOKE;
2215             refName = ident();
2216         }
2217         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2218     }
2219 
2220     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2221      */
2222     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
<span class="line-modified">2223         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();</span>
<span class="line-modified">2224 </span>



2225         switch (token.kind) {
2226         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2227         case DOUBLE: case BOOLEAN:




2228             if (typeArgs == null) {
2229                 if (newAnnotations.isEmpty()) {
2230                     return arrayCreatorRest(newpos, basicType());
2231                 } else {
2232                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2233                 }
2234             }
2235             break;
2236         default:
2237         }
2238         JCExpression t = qualident(true);
2239 
2240         int oldmode = mode;
2241         selectTypeMode();
2242         boolean diamondFound = false;
2243         int lastTypeargsPos = -1;
2244         if (token.kind == LT) {
2245             lastTypeargsPos = token.pos;
2246             t = typeArguments(t, true);
2247             diamondFound = (mode &amp; DIAMOND) != 0;
</pre>
<hr />
<pre>
2276             JCExpression e = arrayCreatorRest(newpos, t);
2277             if (diamondFound) {
2278                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2279                 return toP(F.at(newpos).Erroneous(List.of(e)));
2280             }
2281             else if (typeArgs != null) {
2282                 int pos = newpos;
2283                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2284                     // note: this should always happen but we should
2285                     // not rely on this as the parser is continuously
2286                     // modified to improve error recovery.
2287                     pos = typeArgs.head.pos;
2288                 }
2289                 setErrorEndPos(S.prevToken().endPos);
2290                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2291                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2292                 return toP(err);
2293             }
2294             return e;
2295         } else if (token.kind == LPAREN) {



2296             // handle type annotations for instantiations and anonymous classes
2297             if (newAnnotations.nonEmpty()) {
2298                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2299             }
<span class="line-modified">2300             return classCreatorRest(newpos, null, typeArgs, t);</span>





2301         } else {
2302             setErrorEndPos(token.pos);
2303             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2304             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2305             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2306         }
2307     }
2308 
2309     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2310      */
2311     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2312         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2313 
2314         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2315 
2316         if (newAnnotations.nonEmpty()) {
2317             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2318         }
2319 
2320         if (token.kind == LT) {
2321             int oldmode = mode;
2322             t = typeArguments(t, true);
2323             mode = oldmode;
2324         }
<span class="line-modified">2325         return classCreatorRest(newpos, encl, typeArgs, t);</span>
2326     }
2327 
2328     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2329      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2330      */
2331     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2332         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2333 
2334         accept(LBRACKET);
2335         if (token.kind == RBRACKET) {
2336             accept(RBRACKET);
2337             elemtype = bracketsOpt(elemtype, annos);
2338             if (token.kind == LBRACE) {
2339                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2340                 if (annos.nonEmpty()) {
2341                     // when an array initializer is present then
2342                     // the parsed annotations should target the
2343                     // new array tree
2344                     // bracketsOpt inserts the annotation in
2345                     // elemtype, and it needs to be corrected
</pre>
<hr />
<pre>
2387             if (token.kind == LBRACE) {
2388                 elems = arrayInitializerElements(newpos, elemtype);
2389             }
2390 
2391             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2392             na.dimAnnotations = dimAnnotations.toList();
2393 
2394             if (elems != null) {
2395                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2396             }
2397 
2398             return na;
2399         }
2400     }
2401 
2402     /** ClassCreatorRest = Arguments [ClassBody]
2403      */
2404     JCNewClass classCreatorRest(int newpos,
2405                                   JCExpression encl,
2406                                   List&lt;JCExpression&gt; typeArgs,
<span class="line-modified">2407                                   JCExpression t)</span>

2408     {
2409         List&lt;JCExpression&gt; args = arguments();
2410         JCClassDecl body = null;
2411         if (token.kind == LBRACE) {
2412             int pos = token.pos;
2413             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
<span class="line-modified">2414             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);</span>
2415             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2416         }
<span class="line-modified">2417         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));</span>

2418     }
2419 
2420     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2421      */
2422     JCExpression arrayInitializer(int newpos, JCExpression t) {
2423         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2424         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2425     }
2426 
2427     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2428         accept(LBRACE);
2429         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2430         if (token.kind == COMMA) {
2431             nextToken();
2432         } else if (token.kind != RBRACE) {
2433             elems.append(variableInitializer());
2434             while (token.kind == COMMA) {
2435                 nextToken();
2436                 if (token.kind == RBRACE) break;
2437                 elems.append(variableInitializer());
</pre>
<hr />
<pre>
2528                 error = Errors.ClassNotAllowed;
2529                 break;
2530             case VARDEF:
2531                 error = Errors.VariableNotAllowed;
2532                 break;
2533             }
2534             if (error != null) {
2535                 log.error(DiagnosticFlag.SYNTAX, first, error);
2536                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2537                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2538             }
2539             return first;
2540         }
2541     }
2542 
2543     /**This method parses a statement appearing inside a block.
2544      */
2545     @SuppressWarnings(&quot;fallthrough&quot;)
2546     List&lt;JCStatement&gt; blockStatement() {
2547         //todo: skip to anchor on error(?)

2548         Comment dc;
2549         int pos = token.pos;
2550         switch (token.kind) {
2551         case RBRACE: case CASE: case DEFAULT: case EOF:
2552             return List.nil();
2553         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2554         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2555         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2556         case ASSERT:
2557             return List.of(parseSimpleStatement());

2558         case MONKEYS_AT:
2559         case FINAL: {
2560             dc = token.comment(CommentStyle.JAVADOC);
2561             JCModifiers mods = modifiersOpt();
2562             if (token.kind == INTERFACE ||
2563                 token.kind == CLASS ||
2564                 token.kind == ENUM ||
2565                 isRecordStart()) {
2566                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2567             } else {
2568                 JCExpression t = parseType(true);
2569                 return localVariableDeclarations(mods, t);
2570             }
2571         }
2572         case ABSTRACT: case STRICTFP: {
2573             dc = token.comment(CommentStyle.JAVADOC);
2574             JCModifiers mods = modifiersOpt();
2575             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2576         }
2577         case INTERFACE:
</pre>
<hr />
<pre>
2989             nextToken();
2990             pos = token.pos;
2991             JCExpression t = parseExpression();
2992             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
2993             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
2994         }
2995         return stats;
2996     }
2997 
2998     /** ForInit = StatementExpression MoreStatementExpressions
2999      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3000      */
3001     List&lt;JCStatement&gt; forInit() {
3002         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3003         int pos = token.pos;
3004         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3005             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3006         } else {
3007             JCExpression t = term(EXPR | TYPE);
3008             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<span class="line-modified">3009                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();</span>



3010             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3011                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3012                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3013             } else {
3014                 return moreStatementExpressions(pos, t, stats).toList();
3015             }
3016         }
3017     }
3018 
3019     /** ForUpdate = StatementExpression MoreStatementExpressions
3020      */
3021     List&lt;JCExpressionStatement&gt; forUpdate() {
3022         return moreStatementExpressions(token.pos,
3023                                         parseExpression(),
3024                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3025     }
3026 
3027     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3028      *
3029      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
</pre>
<hr />
<pre>
3059     }
3060     protected JCModifiers modifiersOpt(JCModifiers partial) {
3061         long flags;
3062         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3063         int pos;
3064         if (partial == null) {
3065             flags = 0;
3066             pos = token.pos;
3067         } else {
3068             flags = partial.flags;
3069             annotations.appendList(partial.annotations);
3070             pos = partial.pos;
3071         }
3072         if (token.deprecatedFlag()) {
3073             flags |= Flags.DEPRECATED;
3074         }
3075         int lastPos;
3076     loop:
3077         while (true) {
3078             long flag;

3079             switch (token.kind) {
3080             case PRIVATE     : flag = Flags.PRIVATE; break;
3081             case PROTECTED   : flag = Flags.PROTECTED; break;
3082             case PUBLIC      : flag = Flags.PUBLIC; break;
3083             case STATIC      : flag = Flags.STATIC; break;
3084             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3085             case FINAL       : flag = Flags.FINAL; break;
3086             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3087             case NATIVE      : flag = Flags.NATIVE; break;

3088             case VOLATILE    : flag = Flags.VOLATILE; break;
3089             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3090             case STRICTFP    : flag = Flags.STRICTFP; break;
3091             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3092             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3093             case ERROR       : flag = 0; nextToken(); break;
3094             case IDENTIFIER  : {
3095                 if (isNonSealedClassStart(false)) {
3096                     flag = Flags.NON_SEALED;
3097                     nextToken();
3098                     nextToken();
3099                     break;
3100                 }
3101                 if (isSealedClassStart(false)) {
3102                     checkSourceLevel(Feature.SEALED_CLASSES);
3103                     flag = Flags.SEALED;
3104                     break;
3105                 }
3106                 break loop;
3107             }
3108             default: break loop;
3109             }
3110             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3111             lastPos = token.pos;
3112             nextToken();
3113             if (flag == Flags.ANNOTATION) {
3114                 if (token.kind != INTERFACE) {
3115                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3116                     // if first modifier is an annotation, set pos to annotation&#39;s.
3117                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3118                         pos = ann.pos;
<span class="line-modified">3119                     annotations.append(ann);</span>
<span class="line-modified">3120                     flag = 0;</span>





3121                 }
3122             }
3123             flags |= flag;
3124         }
3125         switch (token.kind) {
3126         case ENUM: flags |= Flags.ENUM; break;
3127         case INTERFACE: flags |= Flags.INTERFACE; break;
3128         default: break;
3129         }
3130 
3131         /* A modifiers tree with no modifier tokens or annotations
3132          * has no text position. */
3133         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3134             pos = Position.NOPOS;
3135 





3136         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3137         if (pos != Position.NOPOS)
3138             storeEnd(mods, S.prevToken().endPos);
3139         return mods;
3140     }
3141 
3142     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3143      *
3144      * @param pos position of &quot;@&quot; token
3145      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3146      */
3147     JCAnnotation annotation(int pos, Tag kind) {
3148         // accept(AT); // AT consumed by caller
3149         if (kind == Tag.TYPE_ANNOTATION) {
3150             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3151         }
3152         JCTree ident = qualident(false);
3153         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3154         JCAnnotation ann;
3155         if (kind == Tag.ANNOTATION) {
</pre>
<hr />
<pre>
3303                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3304                 } else {
3305                     if(compound)
3306                         //error - &#39;var&#39; in compound local var decl
3307                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3308                     startPos = TreeInfo.getStartPos(mods);
3309                     if (startPos == Position.NOPOS)
3310                         startPos = TreeInfo.getStartPos(type);
3311                     //implicit type
3312                     type = null;
3313                 }
3314             }
3315         }
3316         JCVariableDecl result =
3317             toP(F.at(pos).VarDef(mods, name, type, init));
3318         attach(result, dc);
3319         result.startPos = startPos;
3320         return result;
3321     }
3322 




































3323     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3324         switch (e.getTag()) {
3325             case IDENT:
3326                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3327             case TYPEARRAY:
3328                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3329             default:
3330                 return null;
3331         }
3332     }
3333 
3334     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3335         if (name == names.var) {
3336             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3337                 return Source.JDK10;
3338             } else if (shouldWarn) {
3339                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3340             }
3341         }
3342         if (name == names.yield) {
</pre>
</td>
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
<span class="line-added">  37 import com.sun.tools.javac.code.Flags.Flag;</span>
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
<span class="line-added">  52 import static com.sun.tools.javac.code.Flags.asFlagSet;</span>
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
<span class="line-added">  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;</span>
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
</pre>
<hr />
<pre>
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
<span class="line-added"> 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);</span>
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
 193         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 194                 Feature.SEALED_CLASSES.allowedInSource(source);
 195     }
 196 
 197     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 198         return  keepEndPositions
 199                 ? new SimpleEndPosTable(this)
 200                 : new EmptyEndPosTable(this);
 201     }
 202 
 203     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 204         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 205     }
 206 
 207     /** Switch: should we fold strings?
 208      */
 209     boolean allowStringFolding;
 210 
<span class="line-added"> 211     /** Switch: should we allow withField operator at source level ?</span>
<span class="line-added"> 212     */</span>
<span class="line-added"> 213     boolean allowWithFieldOperator;</span>
<span class="line-added"> 214 </span>
 215     /** Switch: should we keep docComments?
 216      */
 217     boolean keepDocComments;
 218 
 219     /** Switch: should we keep line table?
 220      */
 221     boolean keepLineMap;
 222 
 223     /** Switch: is &quot;this&quot; allowed as an identifier?
 224      * This is needed to parse receiver types.
 225      */
 226     boolean allowThisIdent;
 227 
 228     /** Switch: is yield statement allowed in this source level?
 229      */
 230     boolean allowYieldStatement;
 231 
 232     /** Switch: are records allowed in this source level?
 233      */
 234     boolean allowRecords;
</pre>
<hr />
<pre>
 294 
 295     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 296         return peekToken(0, tk1, tk2);
 297     }
 298 
 299     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 300         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 301                 tk2.accepts(S.token(lookahead + 2).kind);
 302     }
 303 
 304     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 305         return peekToken(0, tk1, tk2, tk3);
 306     }
 307 
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 309         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 310                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 311                 tk3.accepts(S.token(lookahead + 3).kind);
 312     }
 313 
<span class="line-added"> 314     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {</span>
<span class="line-added"> 315         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;</span>
<span class="line-added"> 316                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;</span>
<span class="line-added"> 317                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;</span>
<span class="line-added"> 318                 tk4.accepts(S.token(lookahead + 4).kind);</span>
<span class="line-added"> 319     }</span>
<span class="line-added"> 320 </span>
 321     @SuppressWarnings(&quot;unchecked&quot;)
 322     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 323         return peekToken(0, kinds);
 324     }
 325 
 326     @SuppressWarnings(&quot;unchecked&quot;)
 327     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 328         for (; lookahead &lt; kinds.length ; lookahead++) {
 329             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 330                 return false;
 331             }
 332         }
 333         return true;
 334     }
 335 
 336     /* ---------- error recovery -------------- */
 337 
 338     private JCErroneous errorTree;
 339 
 340     /** Skip forward until a suitable stop token is found.
</pre>
<hr />
<pre>
 470 
 471     /** If next input token matches given token, skip it, otherwise report
 472      *  an error.
 473      */
 474     public void accept(TokenKind tk) {
 475         accept(tk, Errors::Expected);
 476     }
 477 
 478     /** If next input token matches given token, skip it, otherwise report
 479      *  an error.
 480      */
 481     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 482         if (token.kind == tk) {
 483             nextToken();
 484         } else {
 485             setErrorEndPos(token.pos);
 486             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 487         }
 488     }
 489 
<span class="line-added"> 490     /** If next input token matches one of the two given tokens, skip it, otherwise report</span>
<span class="line-added"> 491      *  an error.</span>
<span class="line-added"> 492      *</span>
<span class="line-added"> 493      * @return The actual token kind.</span>
<span class="line-added"> 494      */</span>
<span class="line-added"> 495     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {</span>
<span class="line-added"> 496         TokenKind returnValue = token.kind;</span>
<span class="line-added"> 497         if (token.kind == tk1 || token.kind == tk2) {</span>
<span class="line-added"> 498             nextToken();</span>
<span class="line-added"> 499         } else {</span>
<span class="line-added"> 500             setErrorEndPos(token.pos);</span>
<span class="line-added"> 501             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));</span>
<span class="line-added"> 502         }</span>
<span class="line-added"> 503         return returnValue;</span>
<span class="line-added"> 504     }</span>
<span class="line-added"> 505 </span>
 506     /** Report an illegal start of expression/type error at given position.
 507      */
 508     JCExpression illegal(int pos) {
 509         setErrorEndPos(pos);
 510         if ((mode &amp; EXPR) != 0)
 511             return syntaxError(pos, Errors.IllegalStartOfExpr);
 512         else
 513             return syntaxError(pos, Errors.IllegalStartOfType);
 514 
 515     }
 516 
 517     /** Report an illegal start of expression/type error at current position.
 518      */
 519     JCExpression illegal() {
 520         return illegal(token.pos);
 521     }
 522 
 523     /** Diagnose a modifier flag from the set, if any. */
 524     protected void checkNoMods(long mods) {
 525         if (mods != 0) {
</pre>
<hr />
<pre>
1129                 selectTypeMode();
1130                 return typeArgument();
1131             } else
1132                 return illegal();
1133         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1134             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1135                 TokenKind tk = token.kind;
1136                 nextToken();
1137                 selectExprMode();
1138                 if (tk == SUB &amp;&amp;
1139                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1140                     token.radix() == 10) {
1141                     selectExprMode();
1142                     t = literal(names.hyphen, pos);
1143                 } else {
1144                     t = term3();
1145                     return F.at(pos).Unary(unoptag(tk), t);
1146                 }
1147             } else return illegal();
1148             break;
<span class="line-added">1149         case WITHFIELD:</span>
<span class="line-added">1150             if (!allowWithFieldOperator) {</span>
<span class="line-added">1151                 log.error(pos, Errors.WithFieldOperatorDisallowed);</span>
<span class="line-added">1152             }</span>
<span class="line-added">1153             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {</span>
<span class="line-added">1154                 nextToken();</span>
<span class="line-added">1155                 accept(LPAREN);</span>
<span class="line-added">1156                 mode = EXPR;</span>
<span class="line-added">1157                 t = term();</span>
<span class="line-added">1158                 accept(COMMA);</span>
<span class="line-added">1159                 mode = EXPR;</span>
<span class="line-added">1160                 JCExpression v = term();</span>
<span class="line-added">1161                 accept(RPAREN);</span>
<span class="line-added">1162                 return F.at(pos).WithField(t, v);</span>
<span class="line-added">1163             } else return illegal();</span>
1164         case LPAREN:
1165             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1166                 ParensResult pres = analyzeParens();
1167                 switch (pres) {
1168                     case CAST:
1169                        accept(LPAREN);
1170                        selectTypeMode();
1171                        int pos1 = pos;
1172                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1173                        while (token.kind == AMP) {
1174                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1175                            accept(AMP);
1176                            targets = targets.prepend(parseType());
1177                        }
1178                        if (targets.length() &gt; 1) {
1179                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1180                        }
1181                        accept(RPAREN);
1182                        selectExprMode();
1183                        JCExpression t1 = term3();
</pre>
<hr />
<pre>
1312                         break loop;
1313                     case LPAREN:
1314                         if ((mode &amp; EXPR) != 0) {
1315                             selectExprMode();
1316                             t = arguments(typeArgs, t);
1317                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1318                             typeArgs = null;
1319                         }
1320                         break loop;
1321                     case DOT:
1322                         nextToken();
1323                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1324                             return illegal();
1325                         }
1326                         int oldmode = mode;
1327                         mode &amp;= ~NOPARAMS;
1328                         typeArgs = typeArgumentsOpt(EXPR);
1329                         mode = oldmode;
1330                         if ((mode &amp; EXPR) != 0) {
1331                             switch (token.kind) {
<span class="line-added">1332                             case DEFAULT:</span>
<span class="line-added">1333                                 if (typeArgs != null) return illegal();</span>
<span class="line-added">1334                                 selectExprMode();</span>
<span class="line-added">1335                                 t = to(F.at(pos).Select(t, names._default));</span>
<span class="line-added">1336                                 nextToken();</span>
<span class="line-added">1337                                 break loop;</span>
1338                             case CLASS:
1339                                 if (typeArgs != null) return illegal();
1340                                 selectExprMode();
1341                                 t = to(F.at(pos).Select(t, names._class));
1342                                 nextToken();
1343                                 break loop;
1344                             case THIS:
1345                                 if (typeArgs != null) return illegal();
1346                                 selectExprMode();
1347                                 t = to(F.at(pos).Select(t, names._this));
1348                                 nextToken();
1349                                 break loop;
1350                             case SUPER:
1351                                 selectExprMode();
1352                                 t = to(F.at(pos).Select(t, names._super));
1353                                 t = superSuffix(typeArgs, t);
1354                                 typeArgs = null;
1355                                 break loop;
1356                             case NEW:
1357                                 if (typeArgs != null) return illegal();
</pre>
<hr />
<pre>
1367 
1368                         List&lt;JCAnnotation&gt; tyannos = null;
1369                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1370                             tyannos = typeAnnotationsOpt();
1371                         }
1372                         // typeArgs saved for next loop iteration.
1373                         t = toP(F.at(pos).Select(t, ident()));
1374                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1375                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1376                         }
1377                         break;
1378                     case ELLIPSIS:
1379                         if (this.permitTypeAnnotationsPushBack) {
1380                             this.typeAnnotationsPushedBack = annos;
1381                         } else if (annos.nonEmpty()) {
1382                             // Don&#39;t return here -- error recovery attempt
1383                             illegal(annos.head.pos);
1384                         }
1385                         break loop;
1386                     case LT:
<span class="line-modified">1387                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {</span>
<span class="line-modified">1388                             //this is either an unbound method reference whose qualifier</span>
<span class="line-modified">1389                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of</span>
<span class="line-added">1390                             //the form ValueType&lt;S&gt;.default</span>
1391                             int pos1 = token.pos;
1392                             accept(LT);
1393                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1394                             args.append(typeArgument());
1395                             while (token.kind == COMMA) {
1396                                 nextToken();
1397                                 args.append(typeArgument());
1398                             }
1399                             accept(GT);
1400                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1401                             while (token.kind == DOT) {
1402                                 nextToken();
<span class="line-added">1403                                 if (token.kind == DEFAULT) {</span>
<span class="line-added">1404                                     t =  toP(F.at(token.pos).Select(t, names._default));</span>
<span class="line-added">1405                                     nextToken();</span>
<span class="line-added">1406                                     selectExprMode();</span>
<span class="line-added">1407                                     return term3Rest(t, typeArgs);</span>
<span class="line-added">1408                                 }</span>
1409                                 selectTypeMode();
1410                                 t = toP(F.at(token.pos).Select(t, ident()));
1411                                 t = typeArgumentsOpt(t);
1412                             }
1413                             t = bracketsOpt(t);
1414                             if (token.kind != COLCOL) {
1415                                 //method reference expected here
1416                                 t = illegal();
1417                             }
1418                             selectExprMode();
1419                             return term3Rest(t, typeArgs);
1420                         }
1421                         break loop;
1422                     default:
1423                         break loop;
1424                     }
1425                 }
1426             }
1427             if (typeArgs != null) illegal();
1428             t = typeArgumentsOpt(t);
</pre>
<hr />
<pre>
1553                         }
1554                         return t;
1555                     }
1556                     mode = oldmode;
1557                 }
1558                 if ((mode &amp; EXPR) != 0) {
1559                     selectExprMode();
1560                     JCExpression t1 = term();
1561                     t = to(F.at(pos1).Indexed(t, t1));
1562                 }
1563                 accept(RBRACKET);
1564             } else if (token.kind == DOT) {
1565                 nextToken();
1566                 typeArgs = typeArgumentsOpt(EXPR);
1567                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1568                     selectExprMode();
1569                     t = to(F.at(pos1).Select(t, names._super));
1570                     nextToken();
1571                     t = arguments(typeArgs, t);
1572                     typeArgs = null;
<span class="line-modified">1573                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {</span>
1574                     if (typeArgs != null) return illegal();
1575                     selectExprMode();
1576                     int pos2 = token.pos;
1577                     nextToken();
1578                     if (token.kind == LT) typeArgs = typeArguments(false);
1579                     t = innerCreator(pos2, typeArgs, t);
1580                     typeArgs = null;
1581                 } else {
1582                     List&lt;JCAnnotation&gt; tyannos = null;
1583                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1584                         // is the mode check needed?
1585                         tyannos = typeAnnotationsOpt();
1586                     }
1587                     t = toP(F.at(pos1).Select(t, ident(true)));
1588                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1589                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1590                     }
1591                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1592                     typeArgs = null;
1593                 }
</pre>
<hr />
<pre>
1600                 if (!annos.isEmpty()) {
1601                     if (permitTypeAnnotationsPushBack)
1602                         typeAnnotationsPushedBack = annos;
1603                     else
1604                         return illegal(annos.head.pos);
1605                 }
1606                 break;
1607             }
1608         }
1609         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1610             selectExprMode();
1611             t = to(F.at(token.pos).Unary(
1612                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1613             nextToken();
1614         }
1615         return toP(t);
1616     }
1617 
1618     /**
1619      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<span class="line-modified">1620      * method reference or a default value creation that uses a parameterized type</span>
<span class="line-added">1621      * or a binary expression. To disambiguate, look for a</span>
1622      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1623      */
1624     @SuppressWarnings(&quot;fallthrough&quot;)
<span class="line-modified">1625     boolean isParameterizedTypePrefix() {</span>
1626         int pos = 0, depth = 0;
1627         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1628             switch (t.kind) {
1629                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1630                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1631                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1632                 case DOUBLE: case BOOLEAN: case CHAR:
1633                 case MONKEYS_AT:
1634                     break;
1635 
1636                 case LPAREN:
1637                     // skip annotation values
1638                     int nesting = 0;
1639                     for (; ; pos++) {
1640                         TokenKind tk2 = S.token(pos).kind;
1641                         switch (tk2) {
1642                             case EOF:
1643                                 return false;
1644                             case LPAREN:
1645                                 nesting++;
</pre>
<hr />
<pre>
1727                     // based on subsequent token.
1728                     switch (S.token(lookahead + 1).kind) {
1729                         /*case PLUSPLUS: case SUBSUB: */
1730                         case BANG: case TILDE:
1731                         case LPAREN: case THIS: case SUPER:
1732                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1733                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1734                         case TRUE: case FALSE: case NULL:
1735                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1736                         case SWITCH:
1737                         case BYTE: case SHORT: case CHAR: case INT:
1738                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1739                             return ParensResult.CAST;
1740                         default:
1741                             return defaultResult;
1742                     }
1743                 case UNDERSCORE:
1744                 case ASSERT:
1745                 case ENUM:
1746                 case IDENTIFIER:
<span class="line-modified">1747                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {</span>
<span class="line-modified">1748                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</span>
1749                         return ParensResult.EXPLICIT_LAMBDA;
1750                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1751                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1752                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1753                                                       : ParensResult.PARENS;
1754                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1755                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1756                     }
1757                     type = false;
1758                     break;
1759                 case FINAL:
1760                 case ELLIPSIS:
1761                     //those can only appear in explicit lambdas
1762                     return ParensResult.EXPLICIT_LAMBDA;
1763                 case MONKEYS_AT:
1764                     type = true;
1765                     lookahead += 1; //skip &#39;@&#39;
1766                     while (peekToken(lookahead, DOT)) {
1767                         lookahead += 2;
1768                     }
</pre>
<hr />
<pre>
1804                         break;
1805                     } else {
1806                         return ParensResult.PARENS;
1807                     }
1808                 case LT:
1809                     depth++; break;
1810                 case GTGTGT:
1811                     depth--;
1812                 case GTGT:
1813                     depth--;
1814                 case GT:
1815                     depth--;
1816                     if (depth == 0) {
1817                         if (peekToken(lookahead, RPAREN) ||
1818                                 peekToken(lookahead, AMP)) {
1819                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1820                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1821                             return ParensResult.CAST;
1822                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1823                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
<span class="line-added">1824                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||</span>
<span class="line-added">1825                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||</span>
1826                                 peekToken(lookahead, ELLIPSIS)) {
1827                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1828                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1829                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1830                             return ParensResult.EXPLICIT_LAMBDA;
1831                         }
1832                         //it looks a type, but could still be (i) a cast to generic type,
1833                         //(ii) an unbound method reference or (iii) an explicit lambda
1834                         type = true;
1835                         break;
1836                     } else if (depth &lt; 0) {
1837                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1838                         return ParensResult.PARENS;
1839                     }
1840                     break;
1841                 default:
1842                     //this includes EOF
1843                     return defaultResult;
1844             }
1845         }
</pre>
<hr />
<pre>
2202 
2203     private JCExpression bracketsOptCont(JCExpression t, int pos,
2204             List&lt;JCAnnotation&gt; annotations) {
2205         accept(RBRACKET);
2206         t = bracketsOpt(t);
2207         t = toP(F.at(pos).TypeArray(t));
2208         if (annotations.nonEmpty()) {
2209             t = toP(F.at(pos).AnnotatedType(annotations, t));
2210         }
2211         return t;
2212     }
2213 
2214     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2215      *  BracketsSuffixType =
2216      */
2217     JCExpression bracketsSuffix(JCExpression t) {
2218         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2219             selectExprMode();
2220             int pos = token.pos;
2221             nextToken();
<span class="line-modified">2222             TokenKind selector = accept2(CLASS, DEFAULT);</span>
2223             if (token.pos == endPosTable.errorEndPos) {
2224                 // error recovery
2225                 Name name;
2226                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2227                     name = token.name();
2228                     nextToken();
2229                 } else {
2230                     name = names.error;
2231                 }
2232                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2233             } else {
2234                 Tag tag = t.getTag();
2235                 // Type annotations are illegal on class literals. Annotated non array class literals
2236                 // are complained about directly in term3(), Here check for type annotations on dimensions
2237                 // taking care to handle some interior dimension(s) being annotated.
2238                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2239                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
<span class="line-modified">2240                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));</span>
2241             }
2242         } else if ((mode &amp; TYPE) != 0) {
2243             if (token.kind != COLCOL) {
2244                 selectTypeMode();
2245             }
2246         } else if (token.kind != COLCOL) {
2247             syntaxError(token.pos, Errors.DotClassExpected);
2248         }
2249         return t;
2250     }
2251 
2252     /**
2253      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2254      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2255      */
2256     JCExpression memberReferenceSuffix(JCExpression t) {
2257         int pos1 = token.pos;
2258         accept(COLCOL);
2259         return memberReferenceSuffix(pos1, t);
2260     }
</pre>
<hr />
<pre>
2265         List&lt;JCExpression&gt; typeArgs = null;
2266         if (token.kind == LT) {
2267             typeArgs = typeArguments(false);
2268         }
2269         Name refName;
2270         ReferenceMode refMode;
2271         if (token.kind == NEW) {
2272             refMode = ReferenceMode.NEW;
2273             refName = names.init;
2274             nextToken();
2275         } else {
2276             refMode = ReferenceMode.INVOKE;
2277             refName = ident();
2278         }
2279         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2280     }
2281 
2282     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2283      */
2284     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
<span class="line-modified">2285         final JCModifiers mods = modifiersOpt();</span>
<span class="line-modified">2286         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;</span>
<span class="line-added">2287         if (!newAnnotations.isEmpty()) {</span>
<span class="line-added">2288             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);</span>
<span class="line-added">2289         }</span>
2290         switch (token.kind) {
2291         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2292         case DOUBLE: case BOOLEAN:
<span class="line-added">2293             if (mods.flags != 0) {</span>
<span class="line-added">2294                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2295                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2296             }</span>
2297             if (typeArgs == null) {
2298                 if (newAnnotations.isEmpty()) {
2299                     return arrayCreatorRest(newpos, basicType());
2300                 } else {
2301                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2302                 }
2303             }
2304             break;
2305         default:
2306         }
2307         JCExpression t = qualident(true);
2308 
2309         int oldmode = mode;
2310         selectTypeMode();
2311         boolean diamondFound = false;
2312         int lastTypeargsPos = -1;
2313         if (token.kind == LT) {
2314             lastTypeargsPos = token.pos;
2315             t = typeArguments(t, true);
2316             diamondFound = (mode &amp; DIAMOND) != 0;
</pre>
<hr />
<pre>
2345             JCExpression e = arrayCreatorRest(newpos, t);
2346             if (diamondFound) {
2347                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2348                 return toP(F.at(newpos).Erroneous(List.of(e)));
2349             }
2350             else if (typeArgs != null) {
2351                 int pos = newpos;
2352                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2353                     // note: this should always happen but we should
2354                     // not rely on this as the parser is continuously
2355                     // modified to improve error recovery.
2356                     pos = typeArgs.head.pos;
2357                 }
2358                 setErrorEndPos(S.prevToken().endPos);
2359                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2360                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2361                 return toP(err);
2362             }
2363             return e;
2364         } else if (token.kind == LPAREN) {
<span class="line-added">2365             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);</span>
<span class="line-added">2366             if (badModifiers != 0)</span>
<span class="line-added">2367                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
2368             // handle type annotations for instantiations and anonymous classes
2369             if (newAnnotations.nonEmpty()) {
2370                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2371             }
<span class="line-modified">2372             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);</span>
<span class="line-added">2373             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {</span>
<span class="line-added">2374                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2375                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2376             }</span>
<span class="line-added">2377             return newClass;</span>
2378         } else {
2379             setErrorEndPos(token.pos);
2380             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2381             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2382             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2383         }
2384     }
2385 
2386     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2387      */
2388     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2389         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2390 
2391         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2392 
2393         if (newAnnotations.nonEmpty()) {
2394             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2395         }
2396 
2397         if (token.kind == LT) {
2398             int oldmode = mode;
2399             t = typeArguments(t, true);
2400             mode = oldmode;
2401         }
<span class="line-modified">2402         return classCreatorRest(newpos, encl, typeArgs, t, 0);</span>
2403     }
2404 
2405     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2406      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2407      */
2408     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2409         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2410 
2411         accept(LBRACKET);
2412         if (token.kind == RBRACKET) {
2413             accept(RBRACKET);
2414             elemtype = bracketsOpt(elemtype, annos);
2415             if (token.kind == LBRACE) {
2416                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2417                 if (annos.nonEmpty()) {
2418                     // when an array initializer is present then
2419                     // the parsed annotations should target the
2420                     // new array tree
2421                     // bracketsOpt inserts the annotation in
2422                     // elemtype, and it needs to be corrected
</pre>
<hr />
<pre>
2464             if (token.kind == LBRACE) {
2465                 elems = arrayInitializerElements(newpos, elemtype);
2466             }
2467 
2468             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2469             na.dimAnnotations = dimAnnotations.toList();
2470 
2471             if (elems != null) {
2472                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2473             }
2474 
2475             return na;
2476         }
2477     }
2478 
2479     /** ClassCreatorRest = Arguments [ClassBody]
2480      */
2481     JCNewClass classCreatorRest(int newpos,
2482                                   JCExpression encl,
2483                                   List&lt;JCExpression&gt; typeArgs,
<span class="line-modified">2484                                   JCExpression t,</span>
<span class="line-added">2485                                   long flags)</span>
2486     {
2487         List&lt;JCExpression&gt; args = arguments();
2488         JCClassDecl body = null;
2489         if (token.kind == LBRACE) {
2490             int pos = token.pos;
2491             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
<span class="line-modified">2492             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);</span>
2493             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2494         }
<span class="line-modified">2495         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));</span>
<span class="line-added">2496         return newClass;</span>
2497     }
2498 
2499     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2500      */
2501     JCExpression arrayInitializer(int newpos, JCExpression t) {
2502         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2503         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2504     }
2505 
2506     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2507         accept(LBRACE);
2508         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2509         if (token.kind == COMMA) {
2510             nextToken();
2511         } else if (token.kind != RBRACE) {
2512             elems.append(variableInitializer());
2513             while (token.kind == COMMA) {
2514                 nextToken();
2515                 if (token.kind == RBRACE) break;
2516                 elems.append(variableInitializer());
</pre>
<hr />
<pre>
2607                 error = Errors.ClassNotAllowed;
2608                 break;
2609             case VARDEF:
2610                 error = Errors.VariableNotAllowed;
2611                 break;
2612             }
2613             if (error != null) {
2614                 log.error(DiagnosticFlag.SYNTAX, first, error);
2615                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2616                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2617             }
2618             return first;
2619         }
2620     }
2621 
2622     /**This method parses a statement appearing inside a block.
2623      */
2624     @SuppressWarnings(&quot;fallthrough&quot;)
2625     List&lt;JCStatement&gt; blockStatement() {
2626         //todo: skip to anchor on error(?)
<span class="line-added">2627         token = recastToken(token);</span>
2628         Comment dc;
2629         int pos = token.pos;
2630         switch (token.kind) {
2631         case RBRACE: case CASE: case DEFAULT: case EOF:
2632             return List.nil();
2633         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2634         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2635         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2636         case ASSERT:
2637             return List.of(parseSimpleStatement());
<span class="line-added">2638         case VALUE:</span>
2639         case MONKEYS_AT:
2640         case FINAL: {
2641             dc = token.comment(CommentStyle.JAVADOC);
2642             JCModifiers mods = modifiersOpt();
2643             if (token.kind == INTERFACE ||
2644                 token.kind == CLASS ||
2645                 token.kind == ENUM ||
2646                 isRecordStart()) {
2647                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2648             } else {
2649                 JCExpression t = parseType(true);
2650                 return localVariableDeclarations(mods, t);
2651             }
2652         }
2653         case ABSTRACT: case STRICTFP: {
2654             dc = token.comment(CommentStyle.JAVADOC);
2655             JCModifiers mods = modifiersOpt();
2656             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2657         }
2658         case INTERFACE:
</pre>
<hr />
<pre>
3070             nextToken();
3071             pos = token.pos;
3072             JCExpression t = parseExpression();
3073             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3074             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3075         }
3076         return stats;
3077     }
3078 
3079     /** ForInit = StatementExpression MoreStatementExpressions
3080      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3081      */
3082     List&lt;JCStatement&gt; forInit() {
3083         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3084         int pos = token.pos;
3085         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3086             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3087         } else {
3088             JCExpression t = term(EXPR | TYPE);
3089             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<span class="line-modified">3090                 pos = token.pos;</span>
<span class="line-added">3091                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);</span>
<span class="line-added">3092                 F.at(pos);</span>
<span class="line-added">3093                 return variableDeclarators(mods, t, stats, true).toList();</span>
3094             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3095                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3096                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3097             } else {
3098                 return moreStatementExpressions(pos, t, stats).toList();
3099             }
3100         }
3101     }
3102 
3103     /** ForUpdate = StatementExpression MoreStatementExpressions
3104      */
3105     List&lt;JCExpressionStatement&gt; forUpdate() {
3106         return moreStatementExpressions(token.pos,
3107                                         parseExpression(),
3108                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3109     }
3110 
3111     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3112      *
3113      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
</pre>
<hr />
<pre>
3143     }
3144     protected JCModifiers modifiersOpt(JCModifiers partial) {
3145         long flags;
3146         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3147         int pos;
3148         if (partial == null) {
3149             flags = 0;
3150             pos = token.pos;
3151         } else {
3152             flags = partial.flags;
3153             annotations.appendList(partial.annotations);
3154             pos = partial.pos;
3155         }
3156         if (token.deprecatedFlag()) {
3157             flags |= Flags.DEPRECATED;
3158         }
3159         int lastPos;
3160     loop:
3161         while (true) {
3162             long flag;
<span class="line-added">3163             token = recastToken(token);</span>
3164             switch (token.kind) {
3165             case PRIVATE     : flag = Flags.PRIVATE; break;
3166             case PROTECTED   : flag = Flags.PROTECTED; break;
3167             case PUBLIC      : flag = Flags.PUBLIC; break;
3168             case STATIC      : flag = Flags.STATIC; break;
3169             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3170             case FINAL       : flag = Flags.FINAL; break;
3171             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3172             case NATIVE      : flag = Flags.NATIVE; break;
<span class="line-added">3173             case VALUE       : flag = Flags.VALUE; break;</span>
3174             case VOLATILE    : flag = Flags.VOLATILE; break;
3175             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3176             case STRICTFP    : flag = Flags.STRICTFP; break;
3177             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3178             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3179             case ERROR       : flag = 0; nextToken(); break;
3180             case IDENTIFIER  : {
3181                 if (isNonSealedClassStart(false)) {
3182                     flag = Flags.NON_SEALED;
3183                     nextToken();
3184                     nextToken();
3185                     break;
3186                 }
3187                 if (isSealedClassStart(false)) {
3188                     checkSourceLevel(Feature.SEALED_CLASSES);
3189                     flag = Flags.SEALED;
3190                     break;
3191                 }
3192                 break loop;
3193             }
3194             default: break loop;
3195             }
3196             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3197             lastPos = token.pos;
3198             nextToken();
3199             if (flag == Flags.ANNOTATION) {
3200                 if (token.kind != INTERFACE) {
3201                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3202                     // if first modifier is an annotation, set pos to annotation&#39;s.
3203                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3204                         pos = ann.pos;
<span class="line-modified">3205                     final Name name = TreeInfo.name(ann.annotationType);</span>
<span class="line-modified">3206                     if (name == names.__inline__ || name == names.java_lang___inline__) {</span>
<span class="line-added">3207                         flag = Flags.VALUE;</span>
<span class="line-added">3208                     } else {</span>
<span class="line-added">3209                         annotations.append(ann);</span>
<span class="line-added">3210                         flag = 0;</span>
<span class="line-added">3211                     }</span>
3212                 }
3213             }
3214             flags |= flag;
3215         }
3216         switch (token.kind) {
3217         case ENUM: flags |= Flags.ENUM; break;
3218         case INTERFACE: flags |= Flags.INTERFACE; break;
3219         default: break;
3220         }
3221 
3222         /* A modifiers tree with no modifier tokens or annotations
3223          * has no text position. */
3224         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3225             pos = Position.NOPOS;
3226 
<span class="line-added">3227         // Force value classes to be automatically final.</span>
<span class="line-added">3228         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {</span>
<span class="line-added">3229             flags |= Flags.FINAL;</span>
<span class="line-added">3230         }</span>
<span class="line-added">3231 </span>
3232         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3233         if (pos != Position.NOPOS)
3234             storeEnd(mods, S.prevToken().endPos);
3235         return mods;
3236     }
3237 
3238     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3239      *
3240      * @param pos position of &quot;@&quot; token
3241      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3242      */
3243     JCAnnotation annotation(int pos, Tag kind) {
3244         // accept(AT); // AT consumed by caller
3245         if (kind == Tag.TYPE_ANNOTATION) {
3246             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3247         }
3248         JCTree ident = qualident(false);
3249         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3250         JCAnnotation ann;
3251         if (kind == Tag.ANNOTATION) {
</pre>
<hr />
<pre>
3399                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3400                 } else {
3401                     if(compound)
3402                         //error - &#39;var&#39; in compound local var decl
3403                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3404                     startPos = TreeInfo.getStartPos(mods);
3405                     if (startPos == Position.NOPOS)
3406                         startPos = TreeInfo.getStartPos(type);
3407                     //implicit type
3408                     type = null;
3409                 }
3410             }
3411         }
3412         JCVariableDecl result =
3413             toP(F.at(pos).VarDef(mods, name, type, init));
3414         attach(result, dc);
3415         result.startPos = startPos;
3416         return result;
3417     }
3418 
<span class="line-added">3419     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.</span>
<span class="line-added">3420     Token recastToken(Token token) {</span>
<span class="line-added">3421         if (token.kind != IDENTIFIER || token.name() != names.inline) {</span>
<span class="line-added">3422             return token;</span>
<span class="line-added">3423         }</span>
<span class="line-added">3424         if (peekToken(t-&gt;t == PRIVATE ||</span>
<span class="line-added">3425                          t == PROTECTED ||</span>
<span class="line-added">3426                          t == PUBLIC ||</span>
<span class="line-added">3427                          t == STATIC ||</span>
<span class="line-added">3428                          t == TRANSIENT ||</span>
<span class="line-added">3429                          t == FINAL ||</span>
<span class="line-added">3430                          t == ABSTRACT ||</span>
<span class="line-added">3431                          t == NATIVE ||</span>
<span class="line-added">3432                          t == VOLATILE ||</span>
<span class="line-added">3433                          t == SYNCHRONIZED ||</span>
<span class="line-added">3434                          t == STRICTFP ||</span>
<span class="line-added">3435                          t == MONKEYS_AT ||</span>
<span class="line-added">3436                          t == DEFAULT ||</span>
<span class="line-added">3437                          t == BYTE ||</span>
<span class="line-added">3438                          t == SHORT ||</span>
<span class="line-added">3439                          t == CHAR ||</span>
<span class="line-added">3440                          t == INT ||</span>
<span class="line-added">3441                          t == LONG ||</span>
<span class="line-added">3442                          t == FLOAT ||</span>
<span class="line-added">3443                          t == DOUBLE ||</span>
<span class="line-added">3444                          t == BOOLEAN ||</span>
<span class="line-added">3445                          t == CLASS ||</span>
<span class="line-added">3446                          t == INTERFACE ||</span>
<span class="line-added">3447                          t == ENUM ||</span>
<span class="line-added">3448                          t == IDENTIFIER)) { // new value Comparable() {}</span>
<span class="line-added">3449             checkSourceLevel(Feature.INLINE_TYPES);</span>
<span class="line-added">3450             return new Token(VALUE, token.pos, token.endPos, token.comments);</span>
<span class="line-added">3451         }</span>
<span class="line-added">3452         return token;</span>
<span class="line-added">3453     }</span>
<span class="line-added">3454 </span>
3455     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3456         switch (e.getTag()) {
3457             case IDENT:
3458                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3459             case TYPEARRAY:
3460                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3461             default:
3462                 return null;
3463         }
3464     }
3465 
3466     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3467         if (name == names.var) {
3468             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3469                 return Source.JDK10;
3470             } else if (shouldWarn) {
3471                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3472             }
3473         }
3474         if (name == names.yield) {
</pre>
</td>
</tr>
</table>
<center><a href="../jvm/ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>