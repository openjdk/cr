<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/universe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;code/codeBehaviours.hpp&quot;
  35 #include &quot;code/codeCache.hpp&quot;
  36 #include &quot;code/dependencies.hpp&quot;
  37 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  38 #include &quot;gc/shared/gcArguments.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/gcLogPrecious.hpp&quot;
  41 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/heapShared.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/metadataFactory.hpp&quot;
  48 #include &quot;memory/metaspaceClosure.hpp&quot;
  49 #include &quot;memory/metaspaceCounters.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/oopFactory.hpp&quot;
  52 #include &quot;memory/resourceArea.hpp&quot;
  53 #include &quot;memory/universe.hpp&quot;
  54 #include &quot;oops/compressedOops.hpp&quot;
  55 #include &quot;oops/constantPool.hpp&quot;
  56 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  57 #include &quot;oops/instanceKlass.hpp&quot;
  58 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  59 #include &quot;oops/instanceRefKlass.hpp&quot;
  60 #include &quot;oops/objArrayOop.inline.hpp&quot;
  61 #include &quot;oops/oop.inline.hpp&quot;
  62 #include &quot;oops/typeArrayKlass.hpp&quot;
  63 #include &quot;prims/resolvedMethodTable.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/deoptimization.hpp&quot;
  67 #include &quot;runtime/flags/flagSetting.hpp&quot;
  68 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/init.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/sharedRuntime.hpp&quot;
  74 #include &quot;runtime/synchronizer.hpp&quot;
  75 #include &quot;runtime/thread.inline.hpp&quot;
  76 #include &quot;runtime/timerTrace.hpp&quot;
  77 #include &quot;runtime/vmOperations.hpp&quot;
  78 #include &quot;services/memoryService.hpp&quot;
  79 #include &quot;utilities/align.hpp&quot;
  80 #include &quot;utilities/copy.hpp&quot;
  81 #include &quot;utilities/debug.hpp&quot;
  82 #include &quot;utilities/events.hpp&quot;
  83 #include &quot;utilities/formatBuffer.hpp&quot;
  84 #include &quot;utilities/hashtable.inline.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/ostream.hpp&quot;
  87 #include &quot;utilities/preserveException.hpp&quot;
  88 
  89 #define PRIMITIVE_MIRRORS_DO(func) \
  90   func(_int_mirror)    \
  91   func(_float_mirror)  \
  92   func(_double_mirror) \
  93   func(_byte_mirror)   \
  94   func(_bool_mirror)   \
  95   func(_char_mirror)   \
  96   func(_long_mirror)   \
  97   func(_short_mirror)  \
  98   func(_void_mirror)
  99 
 100 #define DEFINE_PRIMITIVE_MIRROR(m) \
 101     oop Universe::m  = NULL;
 102 
 103 // Known objects
 104 PRIMITIVE_MIRRORS_DO(DEFINE_PRIMITIVE_MIRROR)
 105 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
 106 Klass* Universe::_objectArrayKlassObj                 = NULL;
 107 oop Universe::_mirrors[T_VOID+1]                      = { NULL /*, NULL...*/ };
 108 oop Universe::_main_thread_group                      = NULL;
 109 oop Universe::_system_thread_group                    = NULL;
 110 objArrayOop Universe::_the_empty_class_klass_array    = NULL;
 111 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 112 oop Universe::_the_null_sentinel                      = NULL;
 113 oop Universe::_the_null_string                        = NULL;
 114 oop Universe::_the_min_jint_string                   = NULL;
 115 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 116 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 117 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 118 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 119 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
<a name="1" id="anc1"></a><span class="line-added"> 120 LatestMethodCache* Universe::_is_substitutable_cache  = NULL;</span>
 121 oop Universe::_out_of_memory_error_java_heap          = NULL;
 122 oop Universe::_out_of_memory_error_metaspace          = NULL;
 123 oop Universe::_out_of_memory_error_class_metaspace    = NULL;
 124 oop Universe::_out_of_memory_error_array_size         = NULL;
 125 oop Universe::_out_of_memory_error_gc_overhead_limit  = NULL;
 126 oop Universe::_out_of_memory_error_realloc_objects    = NULL;
 127 oop Universe::_out_of_memory_error_retry              = NULL;
 128 oop Universe::_delayed_stack_overflow_error_message   = NULL;
 129 objArrayOop Universe::_preallocated_out_of_memory_error_array = NULL;
 130 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 131 bool Universe::_verify_in_progress                    = false;
 132 long Universe::verify_flags                           = Universe::Verify_All;
 133 oop Universe::_null_ptr_exception_instance            = NULL;
 134 oop Universe::_arithmetic_exception_instance          = NULL;
 135 oop Universe::_virtual_machine_error_instance         = NULL;
 136 oop Universe::_vm_exception                           = NULL;
 137 oop Universe::_reference_pending_list                 = NULL;
 138 
 139 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 140 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 141 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 142 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
<a name="2" id="anc2"></a><span class="line-added"> 143 Array&lt;InstanceKlass*&gt;* Universe::_the_single_IdentityObject_klass_array = NULL;</span>
 144 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 145 
 146 // These variables are guarded by FullGCALot_lock.
 147 debug_only(objArrayOop Universe::_fullgc_alot_dummy_array = NULL;)
 148 debug_only(int Universe::_fullgc_alot_dummy_next      = 0;)
 149 
 150 // Heap
 151 int             Universe::_verify_count = 0;
 152 
 153 // Oop verification (see MacroAssembler::verify_oop)
 154 uintptr_t       Universe::_verify_oop_mask = 0;
 155 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 156 
 157 int             Universe::_base_vtable_size = 0;
 158 bool            Universe::_bootstrapping = false;
 159 bool            Universe::_module_initialized = false;
 160 bool            Universe::_fully_initialized = false;
 161 
 162 size_t          Universe::_heap_capacity_at_last_gc;
 163 size_t          Universe::_heap_used_at_last_gc = 0;
 164 
 165 CollectedHeap*  Universe::_collectedHeap = NULL;
 166 
 167 void Universe::basic_type_classes_do(void f(Klass*)) {
 168   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 169     f(_typeArrayKlassObjs[i]);
 170   }
 171 }
 172 
 173 void Universe::basic_type_classes_do(KlassClosure *closure) {
 174   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 175     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 176   }
 177 }
 178 
 179 #define DO_PRIMITIVE_MIRROR(m) \
 180   f-&gt;do_oop((oop*) &amp;m);
 181 
 182 void Universe::oops_do(OopClosure* f) {
 183   PRIMITIVE_MIRRORS_DO(DO_PRIMITIVE_MIRROR);
 184 
 185   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 186     f-&gt;do_oop((oop*) &amp;_mirrors[i]);
 187   }
 188   assert(_mirrors[0] == NULL &amp;&amp; _mirrors[T_BOOLEAN - 1] == NULL, &quot;checking&quot;);
 189 
 190   f-&gt;do_oop((oop*)&amp;_the_empty_class_klass_array);
 191   f-&gt;do_oop((oop*)&amp;_the_null_sentinel);
 192   f-&gt;do_oop((oop*)&amp;_the_null_string);
 193   f-&gt;do_oop((oop*)&amp;_the_min_jint_string);
 194   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_java_heap);
 195   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_metaspace);
 196   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_class_metaspace);
 197   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_array_size);
 198   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_gc_overhead_limit);
 199   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_realloc_objects);
 200   f-&gt;do_oop((oop*)&amp;_out_of_memory_error_retry);
 201   f-&gt;do_oop((oop*)&amp;_delayed_stack_overflow_error_message);
 202   f-&gt;do_oop((oop*)&amp;_preallocated_out_of_memory_error_array);
 203   f-&gt;do_oop((oop*)&amp;_null_ptr_exception_instance);
 204   f-&gt;do_oop((oop*)&amp;_arithmetic_exception_instance);
 205   f-&gt;do_oop((oop*)&amp;_virtual_machine_error_instance);
 206   f-&gt;do_oop((oop*)&amp;_main_thread_group);
 207   f-&gt;do_oop((oop*)&amp;_system_thread_group);
 208   f-&gt;do_oop((oop*)&amp;_vm_exception);
 209   f-&gt;do_oop((oop*)&amp;_reference_pending_list);
 210   debug_only(f-&gt;do_oop((oop*)&amp;_fullgc_alot_dummy_array);)
 211   ThreadsSMRSupport::exiting_threads_oops_do(f);
 212 }
 213 
 214 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 215   it-&gt;push(&amp;_klass);
 216 }
 217 
 218 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 219   for (int i = 0; i &lt; T_LONG+1; i++) {
 220     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 221   }
 222   it-&gt;push(&amp;_objectArrayKlassObj);
 223 
 224   it-&gt;push(&amp;_the_empty_int_array);
 225   it-&gt;push(&amp;_the_empty_short_array);
 226   it-&gt;push(&amp;_the_empty_klass_array);
 227   it-&gt;push(&amp;_the_empty_instance_klass_array);
 228   it-&gt;push(&amp;_the_empty_method_array);
 229   it-&gt;push(&amp;_the_array_interfaces_array);
<a name="3" id="anc3"></a><span class="line-added"> 230   it-&gt;push(&amp;_the_single_IdentityObject_klass_array);</span>
 231 
 232   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 233   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 234   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 235   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 236   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
<a name="4" id="anc4"></a><span class="line-added"> 237   _is_substitutable_cache-&gt;metaspace_pointers_do(it);</span>
 238 }
 239 
 240 #define ASSERT_MIRROR_NULL(m) \
 241   assert(m == NULL, &quot;archived mirrors should be NULL&quot;);
 242 
 243 #define SERIALIZE_MIRROR(m) \
 244   f-&gt;do_oop(&amp;m); \
 245   if (m != NULL) { java_lang_Class::update_archived_primitive_mirror_native_pointers(m); }
 246 
 247 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 248 void Universe::serialize(SerializeClosure* f) {
 249 
 250   for (int i = 0; i &lt; T_LONG+1; i++) {
 251     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 252   }
 253 
 254   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 255 
 256 #if INCLUDE_CDS_JAVA_HEAP
 257   DEBUG_ONLY(if (DumpSharedSpaces &amp;&amp; !HeapShared::is_heap_object_archiving_allowed()) {
 258       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NULL);
 259     });
 260   PRIMITIVE_MIRRORS_DO(SERIALIZE_MIRROR);
 261 #endif
 262 
 263   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 264   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 265   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 266   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 267   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 268   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
<a name="5" id="anc5"></a><span class="line-added"> 269   f-&gt;do_ptr((void**)&amp;_the_single_IdentityObject_klass_array);</span>
 270   _finalizer_register_cache-&gt;serialize(f);
 271   _loader_addClass_cache-&gt;serialize(f);
 272   _throw_illegal_access_error_cache-&gt;serialize(f);
 273   _throw_no_such_method_error_cache-&gt;serialize(f);
 274   _do_stack_walk_cache-&gt;serialize(f);
<a name="6" id="anc6"></a><span class="line-added"> 275   _is_substitutable_cache-&gt;serialize(f);</span>
 276 }
 277 
 278 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 279   if (size &lt; alignment || size % alignment != 0) {
 280     vm_exit_during_initialization(
 281       err_msg(&quot;Size of %s (&quot; UINTX_FORMAT &quot; bytes) must be aligned to &quot; UINTX_FORMAT &quot; bytes&quot;, name, size, alignment));
 282   }
 283 }
 284 
 285 void initialize_basic_type_klass(Klass* k, TRAPS) {
 286   Klass* ok = SystemDictionary::Object_klass();
 287 #if INCLUDE_CDS
 288   if (UseSharedSpaces) {
 289     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 290     assert(k-&gt;super() == ok, &quot;u3&quot;);
 291     if (k-&gt;is_instance_klass()) {
 292       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 293     } else {
 294       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 295     }
 296   } else
 297 #endif
 298   {
 299     k-&gt;initialize_supers(ok, NULL, CHECK);
 300   }
 301   k-&gt;append_to_sibling_list();
 302 }
 303 
 304 void Universe::genesis(TRAPS) {
 305   ResourceMark rm(THREAD);
 306 
 307   { FlagSetting fs(_bootstrapping, true);
 308 
 309     { MutexLocker mc(THREAD, Compile_lock);
 310 
 311       java_lang_Class::allocate_fixup_lists();
 312 
 313       // determine base vtable size; without that we cannot create the array klasses
 314       compute_base_vtable_size();
 315 
 316       if (!UseSharedSpaces) {
 317         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 318           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 319         }
 320 
 321         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 322 
<a name="7" id="anc7"></a><span class="line-modified"> 323         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 3, NULL, CHECK);</span>
 324         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 325         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 326         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 327         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 328         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 329       }
 330     }
 331 
 332     vmSymbols::initialize(CHECK);
 333 
 334     SystemDictionary::initialize(CHECK);
 335 
 336     Klass* ok = SystemDictionary::Object_klass();
 337 
 338     _the_null_string            = StringTable::intern(&quot;null&quot;, CHECK);
 339     _the_min_jint_string       = StringTable::intern(&quot;-2147483648&quot;, CHECK);
 340 
 341 #if INCLUDE_CDS
 342     if (UseSharedSpaces) {
 343       // Verify shared interfaces array.
 344       assert(_the_array_interfaces_array-&gt;at(0) ==
 345              SystemDictionary::Cloneable_klass(), &quot;u3&quot;);
 346       assert(_the_array_interfaces_array-&gt;at(1) ==
 347              SystemDictionary::Serializable_klass(), &quot;u3&quot;);
<a name="8" id="anc8"></a><span class="line-added"> 348       assert(_the_array_interfaces_array-&gt;at(2) ==</span>
<span class="line-added"> 349                    SystemDictionary::IdentityObject_klass(), &quot;u3&quot;);</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351       assert(_the_single_IdentityObject_klass_array-&gt;at(0) ==</span>
<span class="line-added"> 352           SystemDictionary::IdentityObject_klass(), &quot;u3&quot;);</span>
 353     } else
 354 #endif
 355     {
 356       // Set up shared interfaces array.  (Do this before supers are set up.)
 357       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 358       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
<a name="9" id="anc9"></a><span class="line-added"> 359       _the_array_interfaces_array-&gt;at_put(2, SystemDictionary::IdentityObject_klass());</span>
 360     }
 361 
 362     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 363     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 364     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 365     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 366     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 367     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 368     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 369     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 370   } // end of core bootstrapping
 371 
 372   {
 373     Handle tns = java_lang_String::create_from_str(&quot;&lt;null_sentinel&gt;&quot;, CHECK);
 374     _the_null_sentinel = tns();
 375   }
 376 
 377   // Maybe this could be lifted up now that object array can be initialized
 378   // during the bootstrapping.
 379 
 380   // OLD
 381   // Initialize _objectArrayKlass after core bootstraping to make
 382   // sure the super class is set up properly for _objectArrayKlass.
 383   // ---
 384   // NEW
 385   // Since some of the old system object arrays have been converted to
 386   // ordinary object arrays, _objectArrayKlass will be loaded when
 387   // SystemDictionary::initialize(CHECK); is run. See the extra check
 388   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 389   _objectArrayKlassObj = InstanceKlass::
 390     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 391   // OLD
 392   // Add the class to the class hierarchy manually to make sure that
 393   // its vtable is initialized after core bootstrapping is completed.
 394   // ---
 395   // New
 396   // Have already been initialized.
 397   _objectArrayKlassObj-&gt;append_to_sibling_list();
 398 
 399   #ifdef ASSERT
 400   if (FullGCALot) {
 401     // Allocate an array of dummy objects.
 402     // We&#39;d like these to be at the bottom of the old generation,
 403     // so that when we free one and then collect,
 404     // (almost) the whole heap moves
 405     // and we find out if we actually update all the oops correctly.
 406     // But we can&#39;t allocate directly in the old generation,
 407     // so we allocate wherever, and hope that the first collection
 408     // moves these objects to the bottom of the old generation.
 409     // We can allocate directly in the permanent generation, so we do.
 410     int size = FullGCALotDummies * 2;
 411 
 412     objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
 413     objArrayHandle dummy_array(THREAD, naked_array);
 414     int i = 0;
 415     while (i &lt; size) {
 416         // Allocate dummy in old generation
 417       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 418       dummy_array-&gt;obj_at_put(i++, dummy);
 419     }
 420     {
 421       // Only modify the global variable inside the mutex.
 422       // If we had a race to here, the other dummy_array instances
 423       // and their elements just get dropped on the floor, which is fine.
 424       MutexLocker ml(THREAD, FullGCALot_lock);
 425       if (_fullgc_alot_dummy_array == NULL) {
 426         _fullgc_alot_dummy_array = dummy_array();
 427       }
 428     }
 429     assert(i == _fullgc_alot_dummy_array-&gt;length(), &quot;just checking&quot;);
 430   }
 431   #endif
 432 }
 433 
 434 #define ASSERT_MIRROR_NOT_NULL(m) \
 435   assert(m != NULL, &quot;archived mirrors should not be NULL&quot;);
 436 
 437 void Universe::initialize_basic_type_mirrors(TRAPS) {
 438 #if INCLUDE_CDS_JAVA_HEAP
 439     if (UseSharedSpaces &amp;&amp;
 440         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 441         _int_mirror != NULL) {
 442       assert(HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 443       PRIMITIVE_MIRRORS_DO(ASSERT_MIRROR_NOT_NULL);
 444     } else
 445       // _int_mirror could be NULL if archived heap is not mapped.
 446 #endif
 447     {
 448       _int_mirror     =
 449         java_lang_Class::create_basic_type_mirror(&quot;int&quot;,    T_INT, CHECK);
 450       _float_mirror   =
 451         java_lang_Class::create_basic_type_mirror(&quot;float&quot;,  T_FLOAT,   CHECK);
 452       _double_mirror  =
 453         java_lang_Class::create_basic_type_mirror(&quot;double&quot;, T_DOUBLE,  CHECK);
 454       _byte_mirror    =
 455         java_lang_Class::create_basic_type_mirror(&quot;byte&quot;,   T_BYTE, CHECK);
 456       _bool_mirror    =
 457         java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK);
 458       _char_mirror    =
 459         java_lang_Class::create_basic_type_mirror(&quot;char&quot;,   T_CHAR, CHECK);
 460       _long_mirror    =
 461         java_lang_Class::create_basic_type_mirror(&quot;long&quot;,   T_LONG, CHECK);
 462       _short_mirror   =
 463         java_lang_Class::create_basic_type_mirror(&quot;short&quot;,  T_SHORT,   CHECK);
 464       _void_mirror    =
 465         java_lang_Class::create_basic_type_mirror(&quot;void&quot;,   T_VOID, CHECK);
 466     }
 467 
 468     _mirrors[T_INT]     = _int_mirror;
 469     _mirrors[T_FLOAT]   = _float_mirror;
 470     _mirrors[T_DOUBLE]  = _double_mirror;
 471     _mirrors[T_BYTE]    = _byte_mirror;
 472     _mirrors[T_BOOLEAN] = _bool_mirror;
 473     _mirrors[T_CHAR]    = _char_mirror;
 474     _mirrors[T_LONG]    = _long_mirror;
 475     _mirrors[T_SHORT]   = _short_mirror;
 476     _mirrors[T_VOID]    = _void_mirror;
 477   //_mirrors[T_OBJECT]  = _object_klass-&gt;java_mirror();
 478   //_mirrors[T_ARRAY]   = _object_klass-&gt;java_mirror();
 479 }
 480 
<a name="10" id="anc10"></a><span class="line-added"> 481 void Universe::initialize_the_single_IdentityObject_klass_array(InstanceKlass* ik, TRAPS) {</span>
<span class="line-added"> 482     assert(_the_single_IdentityObject_klass_array == NULL, &quot;Must not be initialized twice&quot;);</span>
<span class="line-added"> 483     assert(ik-&gt;name() == vmSymbols::java_lang_IdentityObject(), &quot;Must be&quot;);</span>
<span class="line-added"> 484     Array&lt;InstanceKlass*&gt;* array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(ik-&gt;class_loader_data(), 1, NULL, CHECK);</span>
<span class="line-added"> 485     array-&gt;at_put(0, ik);</span>
<span class="line-added"> 486     _the_single_IdentityObject_klass_array = array;</span>
<span class="line-added"> 487   }</span>
<span class="line-added"> 488 </span>
 489 void Universe::fixup_mirrors(TRAPS) {
 490   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 491   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 492   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 493   // that the number of objects allocated at this point is very small.
 494   assert(SystemDictionary::Class_klass_loaded(), &quot;java.lang.Class should be loaded&quot;);
 495   HandleMark hm(THREAD);
 496 
 497   if (!UseSharedSpaces) {
 498     // Cache the start of the static fields
 499     InstanceMirrorKlass::init_offset_of_static_fields();
 500   }
 501 
 502   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 503   int list_length = list-&gt;length();
 504   for (int i = 0; i &lt; list_length; i++) {
 505     Klass* k = list-&gt;at(i);
 506     assert(k-&gt;is_klass(), &quot;List should only hold classes&quot;);
 507     EXCEPTION_MARK;
 508     java_lang_Class::fixup_mirror(k, CATCH);
 509   }
 510   delete java_lang_Class::fixup_mirror_list();
 511   java_lang_Class::set_fixup_mirror_list(NULL);
 512 }
 513 
 514 #define assert_pll_locked(test) \
 515   assert(Heap_lock-&gt;test(), &quot;Reference pending list access requires lock&quot;)
 516 
 517 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 518 
 519 oop Universe::reference_pending_list() {
 520   if (Thread::current()-&gt;is_VM_thread()) {
 521     assert_pll_locked(is_locked);
 522   } else {
 523     assert_pll_ownership();
 524   }
 525   return _reference_pending_list;
 526 }
 527 
 528 void Universe::set_reference_pending_list(oop list) {
 529   assert_pll_ownership();
 530   _reference_pending_list = list;
 531 }
 532 
 533 bool Universe::has_reference_pending_list() {
 534   assert_pll_ownership();
 535   return _reference_pending_list != NULL;
 536 }
 537 
 538 oop Universe::swap_reference_pending_list(oop list) {
 539   assert_pll_locked(is_locked);
 540   return Atomic::xchg(&amp;_reference_pending_list, list);
 541 }
 542 
 543 #undef assert_pll_locked
 544 #undef assert_pll_ownership
 545 
 546 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 547   // init vtable of k and all subclasses
 548   ko-&gt;vtable().initialize_vtable(false, CHECK);
 549   if (ko-&gt;is_instance_klass()) {
 550     for (Klass* sk = ko-&gt;subklass();
 551          sk != NULL;
 552          sk = sk-&gt;next_sibling()) {
 553       reinitialize_vtable_of(sk, CHECK);
 554     }
 555   }
 556 }
 557 
 558 void Universe::reinitialize_vtables(TRAPS) {
 559   // The vtables are initialized by starting at java.lang.Object and
 560   // initializing through the subclass links, so that the super
 561   // classes are always initialized first.
 562   Klass* ok = SystemDictionary::Object_klass();
 563   Universe::reinitialize_vtable_of(ok, THREAD);
 564 }
 565 
 566 
 567 void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {
 568   k-&gt;itable().initialize_itable(false, CHECK);
 569 }
 570 
 571 
 572 void Universe::reinitialize_itables(TRAPS) {
 573   MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);
 574   ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
 575 }
 576 
 577 
 578 bool Universe::on_page_boundary(void* addr) {
 579   return is_aligned(addr, os::vm_page_size());
 580 }
 581 
 582 
 583 bool Universe::should_fill_in_stack_trace(Handle throwable) {
 584   // never attempt to fill in the stack trace of preallocated errors that do not have
 585   // backtrace. These errors are kept alive forever and may be &quot;re-used&quot; when all
 586   // preallocated errors with backtrace have been consumed. Also need to avoid
 587   // a potential loop which could happen if an out of memory occurs when attempting
 588   // to allocate the backtrace.
 589   return ((throwable() != Universe::_out_of_memory_error_java_heap) &amp;&amp;
 590           (throwable() != Universe::_out_of_memory_error_metaspace)  &amp;&amp;
 591           (throwable() != Universe::_out_of_memory_error_class_metaspace)  &amp;&amp;
 592           (throwable() != Universe::_out_of_memory_error_array_size) &amp;&amp;
 593           (throwable() != Universe::_out_of_memory_error_gc_overhead_limit) &amp;&amp;
 594           (throwable() != Universe::_out_of_memory_error_realloc_objects) &amp;&amp;
 595           (throwable() != Universe::_out_of_memory_error_retry));
 596 }
 597 
 598 
 599 oop Universe::gen_out_of_memory_error(oop default_err) {
 600   // generate an out of memory error:
 601   // - if there is a preallocated error and stack traces are available
 602   //   (j.l.Throwable is initialized), then return the preallocated
 603   //   error with a filled in stack trace, and with the message
 604   //   provided by the default error.
 605   // - otherwise, return the default error, without a stack trace.
 606   int next;
 607   if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
 608       SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
 609     next = (int)Atomic::add(&amp;_preallocated_out_of_memory_error_avail_count, -1);
 610     assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, &quot;avail count is corrupt&quot;);
 611   } else {
 612     next = -1;
 613   }
 614   if (next &lt; 0) {
 615     // all preallocated errors have been used.
 616     // return default
 617     return default_err;
 618   } else {
 619     Thread* THREAD = Thread::current();
 620     Handle default_err_h(THREAD, default_err);
 621     // get the error object at the slot and set set it to NULL so that the
 622     // array isn&#39;t keeping it alive anymore.
 623     Handle exc(THREAD, preallocated_out_of_memory_errors()-&gt;obj_at(next));
 624     assert(exc() != NULL, &quot;slot has been used already&quot;);
 625     preallocated_out_of_memory_errors()-&gt;obj_at_put(next, NULL);
 626 
 627     // use the message from the default error
 628     oop msg = java_lang_Throwable::message(default_err_h());
 629     assert(msg != NULL, &quot;no message&quot;);
 630     java_lang_Throwable::set_message(exc(), msg);
 631 
 632     // populate the stack trace and return it.
 633     java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(exc);
 634     return exc();
 635   }
 636 }
 637 
 638 intptr_t Universe::_non_oop_bits = 0;
 639 
 640 void* Universe::non_oop_word() {
 641   // Neither the high bits nor the low bits of this value is allowed
 642   // to look like (respectively) the high or low bits of a real oop.
 643   //
 644   // High and low are CPU-specific notions, but low always includes
 645   // the low-order bit.  Since oops are always aligned at least mod 4,
 646   // setting the low-order bit will ensure that the low half of the
 647   // word will never look like that of a real oop.
 648   //
 649   // Using the OS-supplied non-memory-address word (usually 0 or -1)
 650   // will take care of the high bits, however many there are.
 651 
 652   if (_non_oop_bits == 0) {
 653     _non_oop_bits = (intptr_t)os::non_memory_address_word() | 1;
 654   }
 655 
 656   return (void*)_non_oop_bits;
 657 }
 658 
 659 static void initialize_global_behaviours() {
 660   CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());
 661 }
 662 
 663 jint universe_init() {
 664   assert(!Universe::_fully_initialized, &quot;called after initialize_vtables&quot;);
 665   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 666          &quot;LogHeapWordSize is incorrect.&quot;);
 667   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), &quot;HeapWord larger than oop?&quot;);
 668   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 669             &quot;oop size is not not a multiple of HeapWord size&quot;);
 670 
 671   TraceTime timer(&quot;Genesis&quot;, TRACETIME_LOG(Info, startuptime));
 672 
 673   initialize_global_behaviours();
 674 
 675   GCLogPrecious::initialize();
 676 
 677   GCConfig::arguments()-&gt;initialize_heap_sizes();
 678 
 679   jint status = Universe::initialize_heap();
 680   if (status != JNI_OK) {
 681     return status;
 682   }
 683 
 684   Universe::initialize_tlab();
 685 
 686   Metaspace::global_initialize();
<a name="11" id="anc11"></a>
 687   // Initialize performance counters for metaspaces
 688   MetaspaceCounters::initialize_performance_counters();
 689   CompressedClassSpaceCounters::initialize_performance_counters();
 690 
 691   AOTLoader::universe_init();
 692 
 693   // Checks &#39;AfterMemoryInit&#39; constraints.
 694   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 695     return JNI_EINVAL;
 696   }
 697 
 698   // Create memory for metadata.  Must be after initializing heap for
 699   // DumpSharedSpaces.
 700   ClassLoaderData::init_null_class_loader_data();
 701 
 702   // We have a heap so create the Method* caches before
 703   // Metaspace::initialize_shared_spaces() tries to populate them.
 704   Universe::_finalizer_register_cache = new LatestMethodCache();
 705   Universe::_loader_addClass_cache    = new LatestMethodCache();
 706   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 707   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 708   Universe::_do_stack_walk_cache = new LatestMethodCache();
<a name="12" id="anc12"></a><span class="line-added"> 709   Universe::_is_substitutable_cache = new LatestMethodCache();</span>
 710 
 711 #if INCLUDE_CDS
 712   if (UseSharedSpaces) {
 713     // Read the data structures supporting the shared spaces (shared
 714     // system dictionary, symbol table, etc.).  After that, access to
 715     // the file (other than the mapped regions) is no longer needed, and
 716     // the file is closed. Closing the file does not affect the
 717     // currently mapped regions.
 718     MetaspaceShared::initialize_shared_spaces();
 719     StringTable::create_table();
 720   } else
 721 #endif
 722   {
 723     SymbolTable::create_table();
 724     StringTable::create_table();
 725   }
 726 
 727 #if INCLUDE_CDS
 728   if (Arguments::is_dumping_archive()) {
 729     MetaspaceShared::prepare_for_dumping();
 730   }
 731 #endif
 732 
 733   if (strlen(VerifySubSet) &gt; 0) {
 734     Universe::initialize_verify_flags();
 735   }
 736 
 737   ResolvedMethodTable::create_table();
 738 
 739   return JNI_OK;
 740 }
 741 
 742 jint Universe::initialize_heap() {
 743   assert(_collectedHeap == NULL, &quot;Heap already created&quot;);
 744   _collectedHeap = GCConfig::arguments()-&gt;create_heap();
 745 
 746   log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&gt;name());
 747   return _collectedHeap-&gt;initialize();
 748 }
 749 
 750 void Universe::initialize_tlab() {
 751   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());
 752   if (UseTLAB) {
 753     assert(Universe::heap()-&gt;supports_tlab_allocation(),
 754            &quot;Should support thread-local allocation buffers&quot;);
 755     ThreadLocalAllocBuffer::startup_initialization();
 756   }
 757 }
 758 
 759 ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {
 760 
 761   assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
 762          &quot;actual alignment &quot; SIZE_FORMAT &quot; must be within maximum heap alignment &quot; SIZE_FORMAT,
 763          alignment, Arguments::conservative_max_heap_alignment());
 764 
 765   size_t total_reserved = align_up(heap_size, alignment);
 766   assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())),
 767       &quot;heap size is too big for compressed oops&quot;);
 768 
 769   bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size());
 770   assert(!UseLargePages
 771       || UseParallelGC
 772       || use_large_pages, &quot;Wrong alignment to use large pages&quot;);
 773 
 774   // Now create the space.
 775   ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt);
 776 
 777   if (total_rs.is_reserved()) {
 778     assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
 779            &quot;must be exactly of required size and alignment&quot;);
 780     // We are good.
 781 
 782     if (AllocateHeapAt != NULL) {
 783       log_info(gc,heap)(&quot;Successfully allocated Java heap at location %s&quot;, AllocateHeapAt);
 784     }
 785 
 786     if (UseCompressedOops) {
 787       CompressedOops::initialize(total_rs);
 788     }
 789 
 790     Universe::calculate_verify_data((HeapWord*)total_rs.base(), (HeapWord*)total_rs.end());
 791 
 792     return total_rs;
 793   }
 794 
 795   vm_exit_during_initialization(
 796     err_msg(&quot;Could not reserve enough space for &quot; SIZE_FORMAT &quot;KB object heap&quot;,
 797             total_reserved/K));
 798 
 799   // satisfy compiler
 800   ShouldNotReachHere();
 801   return ReservedHeapSpace(0, 0, false);
 802 }
 803 
 804 
 805 // It&#39;s the caller&#39;s responsibility to ensure glitch-freedom
 806 // (if required).
 807 void Universe::update_heap_info_at_gc() {
 808   _heap_capacity_at_last_gc = heap()-&gt;capacity();
 809   _heap_used_at_last_gc     = heap()-&gt;used();
 810 }
 811 
 812 void initialize_known_method(LatestMethodCache* method_cache,
 813                              InstanceKlass* ik,
 814                              const char* method,
 815                              Symbol* signature,
 816                              bool is_static, TRAPS)
 817 {
 818   TempNewSymbol name = SymbolTable::new_symbol(method);
 819   Method* m = NULL;
 820   // The klass must be linked before looking up the method.
 821   if (!ik-&gt;link_class_or_fail(THREAD) ||
 822       ((m = ik-&gt;find_method(name, signature)) == NULL) ||
 823       is_static != m-&gt;is_static()) {
 824     ResourceMark rm(THREAD);
 825     // NoSuchMethodException doesn&#39;t actually work because it tries to run the
 826     // &lt;init&gt; function before java_lang_Class is linked. Print error and exit.
 827     vm_exit_during_initialization(err_msg(&quot;Unable to link/verify %s.%s method&quot;,
 828                                  ik-&gt;name()-&gt;as_C_string(), method));
 829   }
 830   method_cache-&gt;init(ik, m);
 831 }
 832 
 833 void Universe::initialize_known_methods(TRAPS) {
 834   // Set up static method for registering finalizers
 835   initialize_known_method(_finalizer_register_cache,
 836                           SystemDictionary::Finalizer_klass(),
 837                           &quot;register&quot;,
 838                           vmSymbols::object_void_signature(), true, CHECK);
 839 
 840   initialize_known_method(_throw_illegal_access_error_cache,
 841                           SystemDictionary::internal_Unsafe_klass(),
 842                           &quot;throwIllegalAccessError&quot;,
 843                           vmSymbols::void_method_signature(), true, CHECK);
 844 
 845   initialize_known_method(_throw_no_such_method_error_cache,
 846                           SystemDictionary::internal_Unsafe_klass(),
 847                           &quot;throwNoSuchMethodError&quot;,
 848                           vmSymbols::void_method_signature(), true, CHECK);
 849 
 850   // Set up method for registering loaded classes in class loader vector
 851   initialize_known_method(_loader_addClass_cache,
 852                           SystemDictionary::ClassLoader_klass(),
 853                           &quot;addClass&quot;,
 854                           vmSymbols::class_void_signature(), false, CHECK);
 855 
 856   // Set up method for stack walking
 857   initialize_known_method(_do_stack_walk_cache,
 858                           SystemDictionary::AbstractStackWalker_klass(),
 859                           &quot;doStackWalk&quot;,
 860                           vmSymbols::doStackWalk_signature(), false, CHECK);
<a name="13" id="anc13"></a><span class="line-added"> 861 </span>
<span class="line-added"> 862   // Set up substitutability testing</span>
<span class="line-added"> 863   ResourceMark rm;</span>
<span class="line-added"> 864   initialize_known_method(_is_substitutable_cache,</span>
<span class="line-added"> 865                           SystemDictionary::ValueBootstrapMethods_klass(),</span>
<span class="line-added"> 866                           vmSymbols::isSubstitutable_name()-&gt;as_C_string(),</span>
<span class="line-added"> 867                           vmSymbols::object_object_boolean_signature(), true, CHECK);</span>
 868 }
 869 
 870 void universe2_init() {
 871   EXCEPTION_MARK;
 872   Universe::genesis(CATCH);
 873 }
 874 
 875 // Set after initialization of the module runtime, call_initModuleRuntime
 876 void universe_post_module_init() {
 877   Universe::_module_initialized = true;
 878 }
 879 
 880 bool universe_post_init() {
 881   assert(!is_init_completed(), &quot;Error: initialization not yet completed!&quot;);
 882   Universe::_fully_initialized = true;
 883   EXCEPTION_MARK;
 884   if (!UseSharedSpaces) {
 885     ResourceMark rm;
 886     Universe::reinitialize_vtables(CHECK_false);
 887     Universe::reinitialize_itables(CHECK_false);
 888   }
 889 
 890   HandleMark hm(THREAD);
 891   // Setup preallocated empty java.lang.Class array
 892   Universe::_the_empty_class_klass_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);
 893 
 894   // Setup preallocated OutOfMemoryError errors
 895   Klass* k = SystemDictionary::OutOfMemoryError_klass();
 896   InstanceKlass* ik = InstanceKlass::cast(k);
 897   Universe::_out_of_memory_error_java_heap = ik-&gt;allocate_instance(CHECK_false);
 898   Universe::_out_of_memory_error_metaspace = ik-&gt;allocate_instance(CHECK_false);
 899   Universe::_out_of_memory_error_class_metaspace = ik-&gt;allocate_instance(CHECK_false);
 900   Universe::_out_of_memory_error_array_size = ik-&gt;allocate_instance(CHECK_false);
 901   Universe::_out_of_memory_error_gc_overhead_limit =
 902     ik-&gt;allocate_instance(CHECK_false);
 903   Universe::_out_of_memory_error_realloc_objects = ik-&gt;allocate_instance(CHECK_false);
 904   Universe::_out_of_memory_error_retry = ik-&gt;allocate_instance(CHECK_false);
 905 
 906   // Setup preallocated cause message for delayed StackOverflowError
 907   if (StackReservedPages &gt; 0) {
 908     Universe::_delayed_stack_overflow_error_message =
 909       java_lang_String::create_oop_from_str(&quot;Delayed StackOverflowError due to ReservedStackAccess annotated method&quot;, CHECK_false);
 910   }
 911 
 912   // Setup preallocated NullPointerException
 913   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
 914   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);
 915   Universe::_null_ptr_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 916   // Setup preallocated ArithmeticException
 917   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
 918   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);
 919   Universe::_arithmetic_exception_instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 920   // Virtual Machine Error for when we get into a situation we can&#39;t resolve
 921   k = SystemDictionary::VirtualMachineError_klass();
 922   bool linked = InstanceKlass::cast(k)-&gt;link_class_or_fail(CHECK_false);
 923   if (!linked) {
 924      tty-&gt;print_cr(&quot;Unable to link/verify VirtualMachineError class&quot;);
 925      return false; // initialization failed
 926   }
 927   Universe::_virtual_machine_error_instance =
 928     InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 929 
 930   Universe::_vm_exception = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 931 
 932   Handle msg = java_lang_String::create_from_str(&quot;Java heap space&quot;, CHECK_false);
 933   java_lang_Throwable::set_message(Universe::_out_of_memory_error_java_heap, msg());
 934 
 935   msg = java_lang_String::create_from_str(&quot;Metaspace&quot;, CHECK_false);
 936   java_lang_Throwable::set_message(Universe::_out_of_memory_error_metaspace, msg());
 937   msg = java_lang_String::create_from_str(&quot;Compressed class space&quot;, CHECK_false);
 938   java_lang_Throwable::set_message(Universe::_out_of_memory_error_class_metaspace, msg());
 939 
 940   msg = java_lang_String::create_from_str(&quot;Requested array size exceeds VM limit&quot;, CHECK_false);
 941   java_lang_Throwable::set_message(Universe::_out_of_memory_error_array_size, msg());
 942 
 943   msg = java_lang_String::create_from_str(&quot;GC overhead limit exceeded&quot;, CHECK_false);
 944   java_lang_Throwable::set_message(Universe::_out_of_memory_error_gc_overhead_limit, msg());
 945 
 946   msg = java_lang_String::create_from_str(&quot;Java heap space: failed reallocation of scalar replaced objects&quot;, CHECK_false);
 947   java_lang_Throwable::set_message(Universe::_out_of_memory_error_realloc_objects, msg());
 948 
 949   msg = java_lang_String::create_from_str(&quot;Java heap space: failed retryable allocation&quot;, CHECK_false);
 950   java_lang_Throwable::set_message(Universe::_out_of_memory_error_retry, msg());
 951 
 952   msg = java_lang_String::create_from_str(&quot;/ by zero&quot;, CHECK_false);
 953   java_lang_Throwable::set_message(Universe::_arithmetic_exception_instance, msg());
 954 
 955   // Setup the array of errors that have preallocated backtrace
 956   k = Universe::_out_of_memory_error_java_heap-&gt;klass();
 957   assert(k-&gt;name() == vmSymbols::java_lang_OutOfMemoryError(), &quot;should be out of memory error&quot;);
 958   ik = InstanceKlass::cast(k);
 959 
 960   int len = (StackTraceInThrowable) ? (int)PreallocatedOutOfMemoryErrorCount : 0;
 961   Universe::_preallocated_out_of_memory_error_array = oopFactory::new_objArray(ik, len, CHECK_false);
 962   for (int i=0; i&lt;len; i++) {
 963     oop err = ik-&gt;allocate_instance(CHECK_false);
 964     Handle err_h = Handle(THREAD, err);
 965     java_lang_Throwable::allocate_backtrace(err_h, CHECK_false);
 966     Universe::preallocated_out_of_memory_errors()-&gt;obj_at_put(i, err_h());
 967   }
 968   Universe::_preallocated_out_of_memory_error_avail_count = (jint)len;
 969 
 970   Universe::initialize_known_methods(CHECK_false);
 971 
 972   // This needs to be done before the first scavenge/gc, since
 973   // it&#39;s an input to soft ref clearing policy.
 974   {
 975     MutexLocker x(THREAD, Heap_lock);
 976     Universe::update_heap_info_at_gc();
 977   }
 978 
 979   // (&quot;weak&quot;) refs processing infrastructure initialization
 980   Universe::heap()-&gt;post_initialize();
 981 
 982   MemoryService::add_metaspace_memory_pools();
 983 
 984   MemoryService::set_universe_heap(Universe::heap());
 985 #if INCLUDE_CDS
 986   MetaspaceShared::post_initialize(CHECK_false);
 987 #endif
 988   return true;
 989 }
 990 
 991 
 992 void Universe::compute_base_vtable_size() {
 993   _base_vtable_size = ClassLoader::compute_Object_vtable();
 994 }
 995 
 996 void Universe::print_on(outputStream* st) {
 997   GCMutexLocker hl(Heap_lock); // Heap_lock might be locked by caller thread.
 998   st-&gt;print_cr(&quot;Heap&quot;);
 999   heap()-&gt;print_on(st);
1000 }
1001 
1002 void Universe::print_heap_at_SIGBREAK() {
1003   if (PrintHeapAtSIGBREAK) {
1004     print_on(tty);
1005     tty-&gt;cr();
1006     tty-&gt;flush();
1007   }
1008 }
1009 
1010 void Universe::print_heap_before_gc() {
1011   LogTarget(Debug, gc, heap) lt;
1012   if (lt.is_enabled()) {
1013     LogStream ls(lt);
1014     ls.print(&quot;Heap before GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1015     ResourceMark rm;
1016     heap()-&gt;print_on(&amp;ls);
1017   }
1018 }
1019 
1020 void Universe::print_heap_after_gc() {
1021   LogTarget(Debug, gc, heap) lt;
1022   if (lt.is_enabled()) {
1023     LogStream ls(lt);
1024     ls.print(&quot;Heap after GC invocations=%u (full %u):&quot;, heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1025     ResourceMark rm;
1026     heap()-&gt;print_on(&amp;ls);
1027   }
1028 }
1029 
1030 void Universe::initialize_verify_flags() {
1031   verify_flags = 0;
1032   const char delimiter[] = &quot; ,&quot;;
1033 
1034   size_t length = strlen(VerifySubSet);
1035   char* subset_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
1036   strncpy(subset_list, VerifySubSet, length + 1);
1037   char* save_ptr;
1038 
1039   char* token = strtok_r(subset_list, delimiter, &amp;save_ptr);
1040   while (token != NULL) {
1041     if (strcmp(token, &quot;threads&quot;) == 0) {
1042       verify_flags |= Verify_Threads;
1043     } else if (strcmp(token, &quot;heap&quot;) == 0) {
1044       verify_flags |= Verify_Heap;
1045     } else if (strcmp(token, &quot;symbol_table&quot;) == 0) {
1046       verify_flags |= Verify_SymbolTable;
1047     } else if (strcmp(token, &quot;string_table&quot;) == 0) {
1048       verify_flags |= Verify_StringTable;
1049     } else if (strcmp(token, &quot;codecache&quot;) == 0) {
1050       verify_flags |= Verify_CodeCache;
1051     } else if (strcmp(token, &quot;dictionary&quot;) == 0) {
1052       verify_flags |= Verify_SystemDictionary;
1053     } else if (strcmp(token, &quot;classloader_data_graph&quot;) == 0) {
1054       verify_flags |= Verify_ClassLoaderDataGraph;
1055     } else if (strcmp(token, &quot;metaspace&quot;) == 0) {
1056       verify_flags |= Verify_MetaspaceUtils;
1057     } else if (strcmp(token, &quot;jni_handles&quot;) == 0) {
1058       verify_flags |= Verify_JNIHandles;
1059     } else if (strcmp(token, &quot;codecache_oops&quot;) == 0) {
1060       verify_flags |= Verify_CodeCacheOops;
1061     } else if (strcmp(token, &quot;resolved_method_table&quot;) == 0) {
1062       verify_flags |= Verify_ResolvedMethodTable;
1063     } else {
1064       vm_exit_during_initialization(err_msg(&quot;VerifySubSet: \&#39;%s\&#39; memory sub-system is unknown, please correct it&quot;, token));
1065     }
1066     token = strtok_r(NULL, delimiter, &amp;save_ptr);
1067   }
1068   FREE_C_HEAP_ARRAY(char, subset_list);
1069 }
1070 
1071 bool Universe::should_verify_subset(uint subset) {
1072   if (verify_flags &amp; subset) {
1073     return true;
1074   }
1075   return false;
1076 }
1077 
1078 void Universe::verify(VerifyOption option, const char* prefix) {
1079   // The use of _verify_in_progress is a temporary work around for
1080   // 6320749.  Don&#39;t bother with a creating a class to set and clear
1081   // it since it is only used in this method and the control flow is
1082   // straight forward.
1083   _verify_in_progress = true;
1084 
1085   COMPILER2_PRESENT(
1086     assert(!DerivedPointerTable::is_active(),
1087          &quot;DPT should not be active during verification &quot;
1088          &quot;(of thread stacks below)&quot;);
1089   )
1090 
1091   ResourceMark rm;
1092   HandleMark hm;  // Handles created during verification can be zapped
1093   _verify_count++;
1094 
1095   FormatBuffer&lt;&gt; title(&quot;Verifying %s&quot;, prefix);
1096   GCTraceTime(Info, gc, verify) tm(title.buffer());
1097   if (should_verify_subset(Verify_Threads)) {
1098     log_debug(gc, verify)(&quot;Threads&quot;);
1099     Threads::verify();
1100   }
1101   if (should_verify_subset(Verify_Heap)) {
1102     log_debug(gc, verify)(&quot;Heap&quot;);
1103     heap()-&gt;verify(option);
1104   }
1105   if (should_verify_subset(Verify_SymbolTable)) {
1106     log_debug(gc, verify)(&quot;SymbolTable&quot;);
1107     SymbolTable::verify();
1108   }
1109   if (should_verify_subset(Verify_StringTable)) {
1110     log_debug(gc, verify)(&quot;StringTable&quot;);
1111     StringTable::verify();
1112   }
1113   if (should_verify_subset(Verify_CodeCache)) {
1114   {
1115     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1116     log_debug(gc, verify)(&quot;CodeCache&quot;);
1117     CodeCache::verify();
1118   }
1119   }
1120   if (should_verify_subset(Verify_SystemDictionary)) {
1121     log_debug(gc, verify)(&quot;SystemDictionary&quot;);
1122     SystemDictionary::verify();
1123   }
1124 #ifndef PRODUCT
1125   if (should_verify_subset(Verify_ClassLoaderDataGraph)) {
1126     log_debug(gc, verify)(&quot;ClassLoaderDataGraph&quot;);
1127     ClassLoaderDataGraph::verify();
1128   }
1129 #endif
1130   if (should_verify_subset(Verify_MetaspaceUtils)) {
1131     log_debug(gc, verify)(&quot;MetaspaceUtils&quot;);
1132     MetaspaceUtils::verify_free_chunks();
1133   }
1134   if (should_verify_subset(Verify_JNIHandles)) {
1135     log_debug(gc, verify)(&quot;JNIHandles&quot;);
1136     JNIHandles::verify();
1137   }
1138   if (should_verify_subset(Verify_CodeCacheOops)) {
1139     log_debug(gc, verify)(&quot;CodeCache Oops&quot;);
1140     CodeCache::verify_oops();
1141   }
1142   if (should_verify_subset(Verify_ResolvedMethodTable)) {
1143     log_debug(gc, verify)(&quot;ResolvedMethodTable Oops&quot;);
1144     ResolvedMethodTable::verify();
1145   }
1146 
1147   _verify_in_progress = false;
1148 }
1149 
1150 
1151 #ifndef PRODUCT
1152 void Universe::calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) {
1153   assert(low_boundary &lt; high_boundary, &quot;bad interval&quot;);
1154 
1155   // decide which low-order bits we require to be clear:
1156   size_t alignSize = MinObjAlignmentInBytes;
1157   size_t min_object_size = CollectedHeap::min_fill_size();
1158 
1159   // make an inclusive limit:
1160   uintptr_t max = (uintptr_t)high_boundary - min_object_size*wordSize;
1161   uintptr_t min = (uintptr_t)low_boundary;
1162   assert(min &lt; max, &quot;bad interval&quot;);
1163   uintptr_t diff = max ^ min;
1164 
1165   // throw away enough low-order bits to make the diff vanish
1166   uintptr_t mask = (uintptr_t)(-1);
1167   while ((mask &amp; diff) != 0)
1168     mask &lt;&lt;= 1;
1169   uintptr_t bits = (min &amp; mask);
1170   assert(bits == (max &amp; mask), &quot;correct mask&quot;);
1171   // check an intermediate value between min and max, just to make sure:
1172   assert(bits == ((min + (max-min)/2) &amp; mask), &quot;correct mask&quot;);
1173 
1174   // require address alignment, too:
1175   mask |= (alignSize - 1);
1176 
1177   if (!(_verify_oop_mask == 0 &amp;&amp; _verify_oop_bits == (uintptr_t)-1)) {
1178     assert(_verify_oop_mask == mask &amp;&amp; _verify_oop_bits == bits, &quot;mask stability&quot;);
1179   }
1180   _verify_oop_mask = mask;
1181   _verify_oop_bits = bits;
1182 }
1183 
1184 // Oop verification (see MacroAssembler::verify_oop)
1185 
1186 uintptr_t Universe::verify_oop_mask() {
1187   return _verify_oop_mask;
1188 }
1189 
1190 uintptr_t Universe::verify_oop_bits() {
1191   return _verify_oop_bits;
1192 }
1193 
1194 uintptr_t Universe::verify_mark_mask() {
1195   return markWord::lock_mask_in_place;
1196 }
1197 
1198 uintptr_t Universe::verify_mark_bits() {
1199   intptr_t mask = verify_mark_mask();
1200   intptr_t bits = (intptr_t)markWord::prototype().value();
1201   assert((bits &amp; ~mask) == 0, &quot;no stray header bits&quot;);
1202   return bits;
1203 }
1204 #endif // PRODUCT
1205 
1206 
1207 void LatestMethodCache::init(Klass* k, Method* m) {
1208   if (!UseSharedSpaces) {
1209     _klass = k;
1210   }
1211 #ifndef PRODUCT
1212   else {
1213     // sharing initilization should have already set up _klass
1214     assert(_klass != NULL, &quot;just checking&quot;);
1215   }
1216 #endif
1217 
1218   _method_idnum = m-&gt;method_idnum();
1219   assert(_method_idnum &gt;= 0, &quot;sanity check&quot;);
1220 }
1221 
1222 
1223 Method* LatestMethodCache::get_method() {
1224   if (klass() == NULL) return NULL;
1225   InstanceKlass* ik = InstanceKlass::cast(klass());
1226   Method* m = ik-&gt;method_with_idnum(method_idnum());
1227   assert(m != NULL, &quot;sanity check&quot;);
1228   return m;
1229 }
1230 
1231 
1232 #ifdef ASSERT
1233 // Release dummy object(s) at bottom of heap
1234 bool Universe::release_fullgc_alot_dummy() {
1235   MutexLocker ml(FullGCALot_lock);
1236   if (_fullgc_alot_dummy_array != NULL) {
1237     if (_fullgc_alot_dummy_next &gt;= _fullgc_alot_dummy_array-&gt;length()) {
1238       // No more dummies to release, release entire array instead
1239       _fullgc_alot_dummy_array = NULL;
1240       return false;
1241     }
1242 
1243     // Release dummy at bottom of old generation
1244     _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1245 
1246     // Release dummy at bottom of permanent generation
1247     _fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1248   }
1249   return true;
1250 }
1251 
1252 #endif // ASSERT
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>