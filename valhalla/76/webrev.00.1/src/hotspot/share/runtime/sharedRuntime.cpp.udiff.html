<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -42,16 +42,21 @@</span>
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interpreterRuntime.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/metaspaceShared.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/oopFactory.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/access.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  #include &quot;oops/klass.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  #include &quot;prims/forte.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,11 +88,10 @@</span>
  RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  RuntimeStub*        SharedRuntime::_ic_miss_blob;
  RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  RuntimeStub*        SharedRuntime::_resolve_static_call_blob;
<span class="udiff-line-removed">- address             SharedRuntime::_resolve_static_call_entry;</span>
  
  DeoptimizationBlob* SharedRuntime::_deopt_blob;
  SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,11 +107,10 @@</span>
    _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
    _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
    _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
    _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
    _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);
<span class="udiff-line-removed">-   _resolve_static_call_entry           = _resolve_static_call_blob-&gt;entry_point();</span>
  
  #if COMPILER2_OR_JVMCI
    // Vectors are generated only by C2 and JVMCI.
    bool support_wide = is_wide_vector(MaxVectorSize);
    if (support_wide) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1050,10 +1053,25 @@</span>
  
    // Find caller and bci from vframe
    methodHandle caller(THREAD, vfst.method());
    int          bci   = vfst.bci();
  
<span class="udiff-line-added">+   // Substitutability test implementation piggy backs on static call resolution</span>
<span class="udiff-line-added">+   Bytecodes::Code code = caller-&gt;java_code_at(bci);</span>
<span class="udiff-line-added">+   if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {</span>
<span class="udiff-line-added">+     bc = Bytecodes::_invokestatic;</span>
<span class="udiff-line-added">+     methodHandle attached_method(THREAD, extract_attached_method(vfst));</span>
<span class="udiff-line-added">+     assert(attached_method.not_null(), &quot;must have attached method&quot;);</span>
<span class="udiff-line-added">+     SystemDictionary::ValueBootstrapMethods_klass()-&gt;initialize(CHECK_NH);</span>
<span class="udiff-line-added">+     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+     Method* is_subst = SystemDictionary::ValueBootstrapMethods_klass()-&gt;find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());</span>
<span class="udiff-line-added">+     assert(callinfo.selected_method() == is_subst, &quot;must be isSubstitutable method&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     return receiver;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    Bytecode_invoke bytecode(caller, bci);
    int bytecode_index = bytecode.index();
    bc = bytecode.invoke_code();
  
    methodHandle attached_method(THREAD, extract_attached_method(vfst));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1085,56 +1103,77 @@</span>
            }
            break;
          default:
            break;
        }
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);</span>
<span class="udiff-line-added">+       if (!attached_method-&gt;method_holder()-&gt;is_value()) {</span>
<span class="udiff-line-added">+         // Ignore the attached method in this case to not confuse below code</span>
<span class="udiff-line-added">+         attached_method = methodHandle(thread, NULL);</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
    assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
  
    bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
                        bc != Bytecodes::_invokedynamic &amp;&amp;
                        bc != Bytecodes::_invokehandle;
<span class="udiff-line-added">+   bool check_null_and_abstract = true;</span>
  
    // Find receiver for non-static call
    if (has_receiver) {
      // This register map must be update since we need to find the receiver for
      // compiled frames. The receiver might be in a register.
      RegisterMap reg_map2(thread);
      frame stubFrame   = thread-&gt;last_frame();
      // Caller-frame is a compiled frame
      frame callerFrame = stubFrame.sender(&amp;reg_map2);
<span class="udiff-line-added">+     bool caller_is_c1 = false;</span>
  
<span class="udiff-line-modified-removed">-     if (attached_method.is_null()) {</span>
<span class="udiff-line-modified-removed">-       Method* callee = bytecode.static_target(CHECK_NH);</span>
<span class="udiff-line-modified-added">+     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {</span>
<span class="udiff-line-modified-added">+       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Method* callee = attached_method();</span>
<span class="udiff-line-added">+     if (callee == NULL) {</span>
<span class="udiff-line-added">+       callee = bytecode.static_target(CHECK_NH);</span>
        if (callee == NULL) {
          THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
        }
      }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Retrieve from a compiled argument list</span>
<span class="udiff-line-modified-removed">-     receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (receiver.is_null()) {</span>
<span class="udiff-line-modified-removed">-       THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>
<span class="udiff-line-modified-added">+     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_value()) {</span>
<span class="udiff-line-modified-added">+       // If the receiver is a value type that is passed as fields, no oop is available.</span>
<span class="udiff-line-modified-added">+       // Resolve the call without receiver null checking.</span>
<span class="udiff-line-modified-added">+       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);</span>
<span class="udiff-line-modified-added">+       if (bc == Bytecodes::_invokeinterface) {</span>
<span class="udiff-line-modified-added">+         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       check_null_and_abstract = false;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Retrieve from a compiled argument list</span>
<span class="udiff-line-added">+       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="udiff-line-added">+       if (receiver.is_null()) {</span>
<span class="udiff-line-added">+         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
    // Resolve method
    if (attached_method.not_null()) {
      // Parameterized by attached method.
<span class="udiff-line-modified-removed">-     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);</span>
<span class="udiff-line-modified-added">+     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);</span>
    } else {
      // Parameterized by bytecode.
      constantPoolHandle constants(THREAD, caller-&gt;constants());
      LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
    }
  
  #ifdef ASSERT
    // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<span class="udiff-line-modified-removed">-   if (has_receiver) {</span>
<span class="udiff-line-modified-added">+   if (has_receiver &amp;&amp; check_null_and_abstract) {</span>
      assert(receiver.not_null(), &quot;should have thrown exception&quot;);
      Klass* receiver_klass = receiver-&gt;klass();
      Klass* rk = NULL;
      if (attached_method.not_null()) {
        // In case there&#39;s resolved method attached, use its holder during the check.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1189,13 +1228,14 @@</span>
  }
  
  // Resolves a call.
  methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
                                             bool is_virtual,
<span class="udiff-line-modified-removed">-                                            bool is_optimized, TRAPS) {</span>
<span class="udiff-line-modified-added">+                                            bool is_optimized,</span>
<span class="udiff-line-added">+                                            bool* caller_is_c1, TRAPS) {</span>
    methodHandle callee_method;
<span class="udiff-line-modified-removed">-   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
<span class="udiff-line-modified-added">+   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
    if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
      int retry_count = 0;
      while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
             callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
        // If has a pending exception then there is no need to re-try to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1208,11 +1248,11 @@</span>
        // in the middle of resolve. If it is looping here more than 100 times
        // means then there could be a bug here.
        guarantee((retry_count++ &lt; 100),
                  &quot;Could not resolve to latest version of redefined method&quot;);
        // method is redefined in the middle of resolve so re-try.
<span class="udiff-line-modified-removed">-       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
<span class="udiff-line-modified-added">+       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
      }
    }
    return callee_method;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1239,21 +1279,28 @@</span>
  #ifdef ASSERT
    address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
  #endif
  
    bool is_nmethod = caller_nm-&gt;is_nmethod();
<span class="udiff-line-added">+   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
  
    if (is_virtual) {
<span class="udiff-line-modified-removed">-     assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>
<span class="udiff-line-modified-added">+     Klass* receiver_klass = NULL;</span>
<span class="udiff-line-added">+     if (InlineTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_value()) {</span>
<span class="udiff-line-added">+       // If the receiver is an inline type that is passed as fields, no oop is available</span>
<span class="udiff-line-added">+       receiver_klass = callee_method-&gt;method_holder();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>
<span class="udiff-line-added">+       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="udiff-line-added">+     }</span>
      bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<span class="udiff-line-modified-removed">-     Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="udiff-line-modified-removed">-     CompiledIC::compute_monomorphic_entry(callee_method, klass,</span>
<span class="udiff-line-removed">-                      is_optimized, static_bound, is_nmethod, virtual_call_info,</span>
<span class="udiff-line-modified-added">+     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,</span>
<span class="udiff-line-modified-added">+                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,</span>
                       CHECK_false);
    } else {
      // static call
<span class="udiff-line-modified-removed">-     CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);</span>
<span class="udiff-line-modified-added">+     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);</span>
    }
  
    // grab lock, check for deoptimization and potentially patch caller
    {
      CompiledICLocker ml(caller_nm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1301,19 +1348,21 @@</span>
  
  // Resolves a call.  The compilers generate code for calls that go here
  // and are patched with the real destination of the call.
  methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
                                                 bool is_virtual,
<span class="udiff-line-modified-removed">-                                                bool is_optimized, TRAPS) {</span>
<span class="udiff-line-modified-added">+                                                bool is_optimized,</span>
<span class="udiff-line-added">+                                                bool* caller_is_c1, TRAPS) {</span>
  
    ResourceMark rm(thread);
    RegisterMap cbl_map(thread, false);
    frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
  
    CodeBlob* caller_cb = caller_frame.cb();
    guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
    CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();
<span class="udiff-line-added">+   *caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
  
    // make sure caller is not getting deoptimized
    // and removed before we are done with it.
    // CLEANUP - with lazy deopt shouldn&#39;t need this lock
    nmethodLocker caller_lock(caller_nm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1411,18 +1460,19 @@</span>
    frame caller_frame = stub_frame.sender(&amp;reg_map);
    assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
  #endif /* ASSERT */
  
    methodHandle callee_method;
<span class="udiff-line-added">+   bool is_optimized = false;</span>
<span class="udiff-line-added">+   bool caller_is_c1 = false;</span>
    JRT_BLOCK
<span class="udiff-line-modified-removed">-     callee_method = SharedRuntime::handle_ic_miss_helper(thread, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     callee_method = SharedRuntime::handle_ic_miss_helper(thread, is_optimized, caller_is_c1, CHECK_NULL);</span>
      // Return Method* through TLS
      thread-&gt;set_vm_result_2(callee_method());
    JRT_BLOCK_END
    // return compiled code entry point after potential safepoints
<span class="udiff-line-modified-removed">-   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="udiff-line-removed">-   return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-modified-added">+   return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);</span>
  JRT_END
  
  
  // Handle call site that has been made non-entrant
  JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1461,18 +1511,20 @@</span>
      }
    }
  
    // Must be compiled to compiled path which is safe to stackwalk
    methodHandle callee_method;
<span class="udiff-line-added">+   bool is_static_call = false;</span>
<span class="udiff-line-added">+   bool is_optimized = false;</span>
<span class="udiff-line-added">+   bool caller_is_c1 = false;</span>
    JRT_BLOCK
      // Force resolving of caller (if we called from compiled frame)
<span class="udiff-line-modified-removed">-     callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_NULL);</span>
      thread-&gt;set_vm_result_2(callee_method());
    JRT_BLOCK_END
    // return compiled code entry point after potential safepoints
<span class="udiff-line-modified-removed">-   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="udiff-line-removed">-   return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-modified-added">+   return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);</span>
  JRT_END
  
  // Handle abstract method call
  JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
    // Verbose error message for AbstractMethodError.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1506,65 +1558,75 @@</span>
  
  
  // resolve a static call and patch code
  JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
    methodHandle callee_method;
<span class="udiff-line-added">+   bool caller_is_c1;</span>
    JRT_BLOCK
<span class="udiff-line-modified-removed">-     callee_method = SharedRuntime::resolve_helper(thread, false, false, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     callee_method = SharedRuntime::resolve_helper(thread, false, false, &amp;caller_is_c1, CHECK_NULL);</span>
      thread-&gt;set_vm_result_2(callee_method());
    JRT_BLOCK_END
    // return compiled code entry point after potential safepoints
<span class="udiff-line-modified-removed">-   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="udiff-line-modified-removed">-   return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-modified-added">+   address entry = caller_is_c1 ?</span>
<span class="udiff-line-modified-added">+     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-added">+   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+   return entry;</span>
  JRT_END
  
  
  // resolve virtual call and update inline cache to monomorphic
  JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
    methodHandle callee_method;
<span class="udiff-line-added">+   bool caller_is_c1;</span>
    JRT_BLOCK
<span class="udiff-line-modified-removed">-     callee_method = SharedRuntime::resolve_helper(thread, true, false, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     callee_method = SharedRuntime::resolve_helper(thread, true, false, &amp;caller_is_c1, CHECK_NULL);</span>
      thread-&gt;set_vm_result_2(callee_method());
    JRT_BLOCK_END
    // return compiled code entry point after potential safepoints
<span class="udiff-line-modified-removed">-   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="udiff-line-modified-removed">-   return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-modified-added">+   address entry = caller_is_c1 ?</span>
<span class="udiff-line-modified-added">+     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_value_ro_code_entry();</span>
<span class="udiff-line-added">+   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+   return entry;</span>
  JRT_END
  
  
  // Resolve a virtual call that can be statically bound (e.g., always
  // monomorphic, so it has no inline cache).  Patch code to resolved target.
  JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
    methodHandle callee_method;
<span class="udiff-line-added">+   bool caller_is_c1;</span>
    JRT_BLOCK
<span class="udiff-line-modified-removed">-     callee_method = SharedRuntime::resolve_helper(thread, true, true, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+     callee_method = SharedRuntime::resolve_helper(thread, true, true, &amp;caller_is_c1, CHECK_NULL);</span>
      thread-&gt;set_vm_result_2(callee_method());
    JRT_BLOCK_END
    // return compiled code entry point after potential safepoints
<span class="udiff-line-modified-removed">-   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="udiff-line-modified-removed">-   return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-modified-added">+   address entry = caller_is_c1 ?</span>
<span class="udiff-line-modified-added">+     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-added">+   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+   return entry;</span>
  JRT_END
  
  // The handle_ic_miss_helper_internal function returns false if it failed due
  // to either running out of vtable stubs or ic stubs due to IC transitions
  // to transitional states. The needs_ic_stub_refill value will be set if
  // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
  // refills the IC stubs and tries again.
  bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
                                                     const frame&amp; caller_frame, methodHandle callee_method,
                                                     Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="udiff-line-modified-removed">-                                                    bool&amp; needs_ic_stub_refill, TRAPS) {</span>
<span class="udiff-line-modified-added">+                                                    bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS) {</span>
    CompiledICLocker ml(caller_nm);
    CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
    bool should_be_mono = false;
    if (inline_cache-&gt;is_optimized()) {
      if (TraceCallFixup) {
        ResourceMark rm(THREAD);
        tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
        callee_method-&gt;print_short_name(tty);
        tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
      }
<span class="udiff-line-added">+     is_optimized = true;</span>
      should_be_mono = true;
    } else if (inline_cache-&gt;is_icholder_call()) {
      CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
      if (ic_oop != NULL) {
        if (!ic_oop-&gt;is_loader_alive()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1598,19 +1660,20 @@</span>
      Klass* receiver_klass = receiver()-&gt;klass();
      inline_cache-&gt;compute_monomorphic_entry(callee_method,
                                              receiver_klass,
                                              inline_cache-&gt;is_optimized(),
                                              false, caller_nm-&gt;is_nmethod(),
<span class="udiff-line-added">+                                             caller_nm-&gt;is_compiled_by_c1(),</span>
                                              info, CHECK_false);
      if (!inline_cache-&gt;set_to_monomorphic(info)) {
        needs_ic_stub_refill = true;
        return false;
      }
    } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
      // Potential change to megamorphic
  
<span class="udiff-line-modified-removed">-     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, CHECK_false);</span>
<span class="udiff-line-modified-added">+     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);</span>
      if (needs_ic_stub_refill) {
        return false;
      }
      if (!successful) {
        if (!inline_cache-&gt;set_to_clean()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1622,11 +1685,11 @@</span>
      // Either clean or megamorphic
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, TRAPS) {</span>
<span class="udiff-line-modified-added">+ methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
    ResourceMark rm(thread);
    CallInfo call_info;
    Bytecodes::Code bc;
  
    // receiver is NULL for static calls. An exception is thrown for NULL
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1642,11 +1705,13 @@</span>
    // plain ic_miss) and the site will be converted to an optimized virtual call site
    // never to miss again. I don&#39;t believe C2 will produce code like this but if it
    // did this would still be the correct thing to do for it too, hence no ifdef.
    //
    if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<span class="udiff-line-modified-removed">-     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_(methodHandle()));</span>
<span class="udiff-line-modified-added">+     bool is_static_call = false;</span>
<span class="udiff-line-added">+     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
<span class="udiff-line-added">+     assert(!is_static_call, &quot;IC miss at static call?&quot;);</span>
      if (TraceCallFixup) {
        RegisterMap reg_map(thread, false);
        frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
        ResourceMark rm(thread);
        tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1692,16 +1757,17 @@</span>
    // that refills them.
    RegisterMap reg_map(thread, false);
    frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
    CodeBlob* cb = caller_frame.cb();
    CompiledMethod* caller_nm = cb-&gt;as_compiled_method();
<span class="udiff-line-added">+   caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
  
    for (;;) {
      ICRefillVerifier ic_refill_verifier;
      bool needs_ic_stub_refill = false;
      bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<span class="udiff-line-modified-removed">-                                                      bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));</span>
<span class="udiff-line-modified-added">+                                                      bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
      if (successful || !needs_ic_stub_refill) {
        return callee_method;
      } else {
        InlineCacheBuffer::refill_ic_stubs();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1729,11 +1795,11 @@</span>
  // Resets a call-site in compiled code so it will get resolved again.
  // This routines handles both virtual call sites, optimized virtual call
  // sites, and static call sites. Typically used to change a call sites
  // destination from compiled to interpreted.
  //
<span class="udiff-line-modified-removed">- methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, TRAPS) {</span>
<span class="udiff-line-modified-added">+ methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
    ResourceMark rm(thread);
    RegisterMap reg_map(thread, false);
    frame stub_frame = thread-&gt;last_frame();
    assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
    frame caller = stub_frame.sender(&amp;reg_map);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1745,11 +1811,11 @@</span>
    if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
  
      address pc = caller.pc();
  
      // Check for static or virtual call
<span class="udiff-line-modified-removed">-     bool is_static_call = false;</span>
<span class="udiff-line-modified-added">+     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);</span>
      caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
  
      // Default call_addr is the location of the &quot;basic&quot; call.
      // Determine the address of the call we a reresolving. With
      // Inline Caches we will always find a recognizable call.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1790,10 +1856,11 @@</span>
            is_static_call = true;
          } else {
            assert(iter.type() == relocInfo::virtual_call_type ||
                   iter.type() == relocInfo::opt_virtual_call_type
                  , &quot;unexpected relocInfo. type&quot;);
<span class="udiff-line-added">+           is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);</span>
          }
        } else {
          assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
        }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1815,11 +1882,10 @@</span>
      }
    }
  
    methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
  
<span class="udiff-line-removed">- </span>
  #ifndef PRODUCT
    Atomic::inc(&amp;_wrong_method_ctr);
  
    if (TraceCallFixup) {
      ResourceMark rm(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1910,12 +1976,10 @@</span>
  // interpreted. If the caller is compiled we attempt to patch the caller
  // so he no longer calls into the interpreter.
  JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
    Method* moop(method);
  
<span class="udiff-line-removed">-   address entry_point = moop-&gt;from_compiled_entry_no_trampoline();</span>
<span class="udiff-line-removed">- </span>
    // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
    // been resolved yet, in which case this function will be called from
    // an nmethod that has been patched for deopt and we can ignore the
    // request for a fixup.
    // Also it is possible that we lost a race in that from_compiled_entry
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1923,11 +1987,15 @@</span>
    // we did we&#39;d leap into space because the callsite needs to use
    // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
    // ask me how I know this...
  
    CodeBlob* cb = CodeCache::find_blob(caller_pc);
<span class="udiff-line-modified-removed">-   if (cb == NULL || !cb-&gt;is_compiled() || entry_point == moop-&gt;get_c2i_entry()) {</span>
<span class="udiff-line-modified-added">+   if (cb == NULL || !cb-&gt;is_compiled()) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   address entry_point = moop-&gt;from_compiled_entry_no_trampoline(cb-&gt;is_compiled_by_c1());</span>
<span class="udiff-line-added">+   if (entry_point == moop-&gt;get_c2i_entry()) {</span>
      return;
    }
  
    // The check above makes sure this is a nmethod.
    CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2284,18 +2352,31 @@</span>
                 // Otherwise _value._fingerprint is the array.
  
    // Remap BasicTypes that are handled equivalently by the adapters.
    // These are correct for the current system but someday it might be
    // necessary to make this mapping platform dependent.
<span class="udiff-line-modified-removed">-   static int adapter_encoding(BasicType in) {</span>
<span class="udiff-line-modified-added">+   static int adapter_encoding(BasicType in, bool is_valuetype) {</span>
      switch (in) {
        case T_BOOLEAN:
        case T_BYTE:
        case T_SHORT:
<span class="udiff-line-modified-removed">-       case T_CHAR:</span>
<span class="udiff-line-modified-removed">-         // There are all promoted to T_INT in the calling convention</span>
<span class="udiff-line-modified-removed">-         return T_INT;</span>
<span class="udiff-line-modified-added">+       case T_CHAR: {</span>
<span class="udiff-line-modified-added">+         if (is_valuetype) {</span>
<span class="udiff-line-modified-added">+           // Do not widen inline type field types</span>
<span class="udiff-line-added">+           assert(InlineTypePassFieldsAsArgs, &quot;must be enabled&quot;);</span>
<span class="udiff-line-added">+           return in;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           // They are all promoted to T_INT in the calling convention</span>
<span class="udiff-line-added">+           return T_INT;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       case T_VALUETYPE: {</span>
<span class="udiff-line-added">+         // If inline types are passed as fields, return &#39;in&#39; to differentiate</span>
<span class="udiff-line-added">+         // between a T_VALUETYPE and a T_OBJECT in the signature.</span>
<span class="udiff-line-added">+         return InlineTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);</span>
<span class="udiff-line-added">+       }</span>
  
        case T_OBJECT:
        case T_ARRAY:
          // In other words, we assume that any register good enough for
          // an int or long is good enough for a managed pointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2317,13 +2398,14 @@</span>
          return T_CONFLICT;
      }
    }
  
   public:
<span class="udiff-line-modified-removed">-   AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {</span>
<span class="udiff-line-modified-added">+   AdapterFingerPrint(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
      // The fingerprint is based on the BasicType signature encoded
      // into an array of ints with eight entries per int.
<span class="udiff-line-added">+     int total_args_passed = (sig != NULL) ? sig-&gt;length() : 0;</span>
      int* ptr;
      int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
      if (len &lt;= _compact_int_count) {
        assert(_compact_int_count == 3, &quot;else change next line&quot;);
        _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2337,21 +2419,41 @@</span>
        ptr = _value._fingerprint;
      }
  
      // Now pack the BasicTypes with 8 per int
      int sig_index = 0;
<span class="udiff-line-added">+     BasicType prev_sbt = T_ILLEGAL;</span>
<span class="udiff-line-added">+     int vt_count = 0;</span>
      for (int index = 0; index &lt; len; index++) {
        int value = 0;
        for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<span class="udiff-line-modified-removed">-         int bt = ((sig_index &lt; total_args_passed)</span>
<span class="udiff-line-modified-removed">-                   ? adapter_encoding(sig_bt[sig_index++])</span>
<span class="udiff-line-modified-removed">-                   : 0);</span>
<span class="udiff-line-modified-added">+         int bt = 0;</span>
<span class="udiff-line-modified-added">+         if (sig_index &lt; total_args_passed) {</span>
<span class="udiff-line-modified-added">+           BasicType sbt = sig-&gt;at(sig_index++)._bt;</span>
<span class="udiff-line-added">+           if (InlineTypePassFieldsAsArgs &amp;&amp; sbt == T_VALUETYPE) {</span>
<span class="udiff-line-added">+             // Found start of inline type in signature</span>
<span class="udiff-line-added">+             vt_count++;</span>
<span class="udiff-line-added">+             if (sig_index == 1 &amp;&amp; has_ro_adapter) {</span>
<span class="udiff-line-added">+               // With a ro_adapter, replace receiver value type delimiter by T_VOID to prevent matching</span>
<span class="udiff-line-added">+               // with other adapters that have the same value type as first argument and no receiver.</span>
<span class="udiff-line-added">+               sbt = T_VOID;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           } else if (InlineTypePassFieldsAsArgs &amp;&amp; sbt == T_VOID &amp;&amp;</span>
<span class="udiff-line-added">+                      prev_sbt != T_LONG &amp;&amp; prev_sbt != T_DOUBLE) {</span>
<span class="udiff-line-added">+             // Found end of inline type in signature</span>
<span class="udiff-line-added">+             vt_count--;</span>
<span class="udiff-line-added">+             assert(vt_count &gt;= 0, &quot;invalid vt_count&quot;);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           bt = adapter_encoding(sbt, vt_count &gt; 0);</span>
<span class="udiff-line-added">+           prev_sbt = sbt;</span>
<span class="udiff-line-added">+         }</span>
          assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
          value = (value &lt;&lt; _basic_type_bits) | bt;
        }
        ptr[index] = value;
      }
<span class="udiff-line-added">+     assert(vt_count == 0, &quot;invalid vt_count&quot;);</span>
    }
  
    ~AdapterFingerPrint() {
      if (_length &gt; 0) {
        FREE_C_HEAP_ARRAY(int, _value._fingerprint);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2433,13 +2535,16 @@</span>
   public:
    AdapterHandlerTable()
      : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
  
    // Create a new entry suitable for insertion in the table
<span class="udiff-line-modified-removed">-   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>
<span class="udiff-line-modified-added">+   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,</span>
<span class="udiff-line-added">+                                  address c2i_value_entry, address c2i_value_ro_entry,</span>
<span class="udiff-line-added">+                                  address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {</span>
      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="udiff-line-modified-removed">-     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
<span class="udiff-line-modified-added">+     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry,</span>
<span class="udiff-line-added">+                 c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
      if (DumpSharedSpaces) {
        ((CDSAdapterHandlerEntry*)entry)-&gt;init();
      }
      return entry;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2454,13 +2559,13 @@</span>
      entry-&gt;deallocate();
      BasicHashtable&lt;mtCode&gt;::free_entry(entry);
    }
  
    // Find a entry with the same fingerprint if it exists
<span class="udiff-line-modified-removed">-   AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {</span>
<span class="udiff-line-modified-added">+   AdapterHandlerEntry* lookup(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
      NOT_PRODUCT(_lookups++);
<span class="udiff-line-modified-removed">-     AdapterFingerPrint fp(total_args_passed, sig_bt);</span>
<span class="udiff-line-modified-added">+     AdapterFingerPrint fp(sig, has_ro_adapter);</span>
      unsigned int hash = fp.compute_hash();
      int index = hash_to_index(hash);
      for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
        NOT_PRODUCT(_buckets++);
        if (e-&gt;hash() == hash) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2552,11 +2657,11 @@</span>
  
  // ---------------------------------------------------------------------------
  // Implementation of AdapterHandlerLibrary
  AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
  AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<span class="udiff-line-modified-removed">- const int AdapterHandlerLibrary_size = 16*K;</span>
<span class="udiff-line-modified-added">+ const int AdapterHandlerLibrary_size = 32*K;</span>
  BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
  
  BufferBlob* AdapterHandlerLibrary::buffer_blob() {
    // Should be called only when AdapterHandlerLibrary_lock is active.
    if (_buffer == NULL) // Initialize lazily
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2576,86 +2681,309 @@</span>
    // are never compiled so an i2c entry is somewhat meaningless, but
    // throw AbstractMethodError just in case.
    // Pass wrong_method_abstract for the c2i transitions to return
    // AbstractMethodError for invalid invocations.
    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<span class="udiff-line-modified-removed">-   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),</span>
<span class="udiff-line-modified-added">+   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
                                                                StubRoutines::throw_AbstractMethodError_entry(),
<span class="udiff-line-added">+                                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
                                                                wrong_method_abstract, wrong_method_abstract);
  }
  
  AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
                                                        address i2c_entry,
                                                        address c2i_entry,
<span class="udiff-line-added">+                                                       address c2i_value_entry,</span>
<span class="udiff-line-added">+                                                       address c2i_value_ro_entry,</span>
                                                        address c2i_unverified_entry,
<span class="udiff-line-added">+                                                       address c2i_unverified_value_entry,</span>
                                                        address c2i_no_clinit_check_entry) {
<span class="udiff-line-modified-removed">-   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
<span class="udiff-line-modified-added">+   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry,</span>
<span class="udiff-line-added">+                               c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void generate_trampoline(address trampoline, address destination) {</span>
<span class="udiff-line-added">+   if (*(int*)trampoline == 0) {</span>
<span class="udiff-line-added">+     CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="udiff-line-added">+     MacroAssembler _masm(&amp;buffer);</span>
<span class="udiff-line-added">+     SharedRuntime::generate_trampoline(&amp;_masm, destination);</span>
<span class="udiff-line-added">+     assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="udiff-line-added">+       _masm.flush();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (PrintInterpreter) {</span>
<span class="udiff-line-added">+       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
    AdapterHandlerEntry* entry = get_adapter0(method);
    if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
      // See comments around Method::link_method()
      MutexLocker mu(AdapterHandlerLibrary_lock);
      if (method-&gt;adapter() == NULL) {
        method-&gt;update_adapter_trampoline(entry);
      }
<span class="udiff-line-modified-removed">-     address trampoline = method-&gt;from_compiled_entry();</span>
<span class="udiff-line-modified-removed">-     if (*(int*)trampoline == 0) {</span>
<span class="udiff-line-modified-removed">-       CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(&amp;buffer);</span>
<span class="udiff-line-modified-removed">-       SharedRuntime::generate_trampoline(&amp;_masm, entry-&gt;get_c2i_entry());</span>
<span class="udiff-line-modified-removed">-       assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="udiff-line-modified-removed">-       _masm.flush();</span>
<span class="udiff-line-modified-added">+     generate_trampoline(method-&gt;from_compiled_entry(),          entry-&gt;get_c2i_entry());</span>
<span class="udiff-line-modified-added">+     generate_trampoline(method-&gt;from_compiled_value_ro_entry(), entry-&gt;get_c2i_value_ro_entry());</span>
<span class="udiff-line-modified-added">+     generate_trampoline(method-&gt;from_compiled_value_entry(),    entry-&gt;get_c2i_value_entry());</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   return entry;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
  
<span class="udiff-line-modified-removed">-       if (PrintInterpreter) {</span>
<span class="udiff-line-modified-removed">-         Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>
<span class="udiff-line-modified-added">+ CompiledEntrySignature::CompiledEntrySignature(Method* method) :</span>
<span class="udiff-line-modified-added">+   _method(method), _num_value_args(0), _has_value_recv(false),</span>
<span class="udiff-line-added">+   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),</span>
<span class="udiff-line-added">+   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),</span>
<span class="udiff-line-added">+   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {</span>
<span class="udiff-line-added">+   _has_reserved_entries = false;</span>
<span class="udiff-line-added">+   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {</span>
<span class="udiff-line-added">+   InstanceKlass* holder = _method-&gt;method_holder();</span>
<span class="udiff-line-added">+   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());</span>
<span class="udiff-line-added">+   if (!_method-&gt;is_static()) {</span>
<span class="udiff-line-added">+     if (holder-&gt;is_value() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+       sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       SigEntry::add_entry(sig_cc, T_OBJECT);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Thread* THREAD = Thread::current();</span>
<span class="udiff-line-added">+   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-added">+     if (ss.type() == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       ValueKlass* vk = ss.as_value_klass(holder);</span>
<span class="udiff-line-added">+       if (vk-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+         sig_cc-&gt;appendAll(vk-&gt;extended_sig());</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         SigEntry::add_entry(sig_cc, T_OBJECT);</span>
        }
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       SigEntry::add_entry(sig_cc, ss.type());</span>
      }
    }
<span class="udiff-line-added">+   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);</span>
<span class="udiff-line-added">+   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   return entry;</span>
<span class="udiff-line-modified-added">+ int CompiledEntrySignature::insert_reserved_entry(int ret_off) {</span>
<span class="udiff-line-added">+   // Find index in signature that belongs to return address slot</span>
<span class="udiff-line-added">+   BasicType bt = T_ILLEGAL;</span>
<span class="udiff-line-added">+   int i = 0;</span>
<span class="udiff-line-added">+   for (uint off = 0; i &lt; _sig_cc-&gt;length(); ++i) {</span>
<span class="udiff-line-added">+     if (SigEntry::skip_value_delimiters(_sig_cc, i)) {</span>
<span class="udiff-line-added">+       VMReg first = _regs_cc[off++].first();</span>
<span class="udiff-line-added">+       if (first-&gt;is_valid() &amp;&amp; first-&gt;is_stack()) {</span>
<span class="udiff-line-added">+         // Select a type for the reserved entry that will end up on the stack</span>
<span class="udiff-line-added">+         bt = _sig_cc-&gt;at(i)._bt;</span>
<span class="udiff-line-added">+         if (((int)first-&gt;reg2stack() + VMRegImpl::slots_per_word) == ret_off) {</span>
<span class="udiff-line-added">+           break; // Index of the return address found</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Insert reserved entry and re-compute calling convention</span>
<span class="udiff-line-added">+   SigEntry::insert_reserved_entry(_sig_cc, i, bt);</span>
<span class="udiff-line-added">+   return SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // See if we can save space by sharing the same entry for VVEP and VVEP(RO),</span>
<span class="udiff-line-added">+ // or the same entry for VEP and VVEP(RO).</span>
<span class="udiff-line-added">+ CodeOffsets::Entries CompiledEntrySignature::c1_value_ro_entry_type() const {</span>
<span class="udiff-line-added">+   if (!has_scalarized_args()) {</span>
<span class="udiff-line-added">+     // VEP/VVEP/VVEP(RO) all share the same entry. There&#39;s no packing.</span>
<span class="udiff-line-added">+     return CodeOffsets::Verified_Entry;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_method-&gt;is_static()) {</span>
<span class="udiff-line-added">+     // Static methods don&#39;t need VVEP(RO)</span>
<span class="udiff-line-added">+     return CodeOffsets::Verified_Entry;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (has_value_recv()) {</span>
<span class="udiff-line-added">+     if (num_value_args() == 1) {</span>
<span class="udiff-line-added">+       // Share same entry for VVEP and VVEP(RO).</span>
<span class="udiff-line-added">+       // This is quite common: we have an instance method in a ValueKlass that has</span>
<span class="udiff-line-added">+       // no value args other than &lt;this&gt;.</span>
<span class="udiff-line-added">+       return CodeOffsets::Verified_Value_Entry;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(num_value_args() &gt; 1, &quot;must be&quot;);</span>
<span class="udiff-line-added">+       // No sharing:</span>
<span class="udiff-line-added">+       //   VVEP(RO) -- &lt;this&gt; is passed as object</span>
<span class="udiff-line-added">+       //   VEP      -- &lt;this&gt; is passed as fields</span>
<span class="udiff-line-added">+       return CodeOffsets::Verified_Value_Entry_RO;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Either a static method, or &lt;this&gt; is not a value type</span>
<span class="udiff-line-added">+   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {</span>
<span class="udiff-line-added">+     // No sharing:</span>
<span class="udiff-line-added">+     // Some arguments are passed on the stack, and we have inserted reserved entries</span>
<span class="udiff-line-added">+     // into the VEP, but we never insert reserved entries into the VVEP(RO).</span>
<span class="udiff-line-added">+     return CodeOffsets::Verified_Value_Entry_RO;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // Share same entry for VEP and VVEP(RO).</span>
<span class="udiff-line-added">+     return CodeOffsets::Verified_Entry;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void CompiledEntrySignature::compute_calling_conventions() {</span>
<span class="udiff-line-added">+   // Get the (non-scalarized) signature and check for value type arguments</span>
<span class="udiff-line-added">+   if (!_method-&gt;is_static()) {</span>
<span class="udiff-line-added">+     if (_method-&gt;method_holder()-&gt;is_value() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+       _has_value_recv = true;</span>
<span class="udiff-line-added">+       _num_value_args++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     SigEntry::add_entry(_sig, T_OBJECT);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-added">+     BasicType bt = ss.type();</span>
<span class="udiff-line-added">+     if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+         _num_value_args++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       bt = T_OBJECT;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     SigEntry::add_entry(_sig, bt);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_method-&gt;is_abstract() &amp;&amp; !(InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="udiff-line-added">+   _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());</span>
<span class="udiff-line-added">+   _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Now compute the scalarized calling convention if there are value types in the signature</span>
<span class="udiff-line-added">+   _sig_cc = _sig;</span>
<span class="udiff-line-added">+   _sig_cc_ro = _sig;</span>
<span class="udiff-line-added">+   _regs_cc = _regs;</span>
<span class="udiff-line-added">+   _regs_cc_ro = _regs;</span>
<span class="udiff-line-added">+   _args_on_stack_cc = _args_on_stack;</span>
<span class="udiff-line-added">+   _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (InlineTypePassFieldsAsArgs &amp;&amp; has_value_arg() &amp;&amp; !_method-&gt;is_native()) {</span>
<span class="udiff-line-added">+     _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _sig_cc_ro = _sig_cc;</span>
<span class="udiff-line-added">+     _regs_cc_ro = _regs_cc;</span>
<span class="udiff-line-added">+     _args_on_stack_cc_ro = _args_on_stack_cc;</span>
<span class="udiff-line-added">+     if (_has_value_recv || _args_on_stack_cc &gt; _args_on_stack) {</span>
<span class="udiff-line-added">+       // For interface calls, we need another entry point / adapter to unpack the receiver</span>
<span class="udiff-line-added">+       _args_on_stack_cc_ro = compute_scalarized_cc(_sig_cc_ro, _regs_cc_ro, /* scalar_receiver = */ false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Compute the stack extension that is required to convert between the calling conventions.</span>
<span class="udiff-line-added">+     // The stack slots at these offsets are occupied by the return address with the unscalarized</span>
<span class="udiff-line-added">+     // calling convention. Don&#39;t use them for arguments with the scalarized calling convention.</span>
<span class="udiff-line-added">+     int ret_off    = _args_on_stack_cc - _args_on_stack;</span>
<span class="udiff-line-added">+     int ret_off_ro = _args_on_stack_cc - _args_on_stack_cc_ro;</span>
<span class="udiff-line-added">+     assert(ret_off_ro &lt;= 0 || ret_off &gt; 0, &quot;receiver unpacking requires more stack space than expected&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (ret_off &gt; 0) {</span>
<span class="udiff-line-added">+       // Make sure the stack of the scalarized calling convention with the reserved</span>
<span class="udiff-line-added">+       // entries (2 slots each) remains 16-byte (4 slots) aligned after stack extension.</span>
<span class="udiff-line-added">+       int alignment = StackAlignmentInBytes / VMRegImpl::stack_slot_size;</span>
<span class="udiff-line-added">+       if (ret_off_ro != ret_off &amp;&amp; ret_off_ro &gt;= 0) {</span>
<span class="udiff-line-added">+         ret_off    += 4; // Account for two reserved entries (4 slots)</span>
<span class="udiff-line-added">+         ret_off_ro += 4;</span>
<span class="udiff-line-added">+         ret_off     = align_up(ret_off, alignment);</span>
<span class="udiff-line-added">+         ret_off_ro  = align_up(ret_off_ro, alignment);</span>
<span class="udiff-line-added">+         // TODO can we avoid wasting a stack slot here?</span>
<span class="udiff-line-added">+         //assert(ret_off != ret_off_ro, &quot;fail&quot;);</span>
<span class="udiff-line-added">+         if (ret_off &gt; ret_off_ro) {</span>
<span class="udiff-line-added">+           swap(ret_off, ret_off_ro); // Sort by offset</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="udiff-line-added">+         _args_on_stack_cc = insert_reserved_entry(ret_off_ro);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         ret_off += 2; // Account for one reserved entry (2 slots)</span>
<span class="udiff-line-added">+         ret_off = align_up(ret_off, alignment);</span>
<span class="udiff-line-added">+         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _has_reserved_entries = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Upper bound on stack arguments to avoid hitting the argument limit and</span>
<span class="udiff-line-added">+     // bailing out of compilation (&quot;unsupported incoming calling sequence&quot;).</span>
<span class="udiff-line-added">+     // TODO we need a reasonable limit (flag?) here</span>
<span class="udiff-line-added">+     if (_args_on_stack_cc &gt; 50) {</span>
<span class="udiff-line-added">+       // Don&#39;t scalarize value type arguments</span>
<span class="udiff-line-added">+       _sig_cc = _sig;</span>
<span class="udiff-line-added">+       _sig_cc_ro = _sig;</span>
<span class="udiff-line-added">+       _regs_cc = _regs;</span>
<span class="udiff-line-added">+       _regs_cc_ro = _regs;</span>
<span class="udiff-line-added">+       _args_on_stack_cc = _args_on_stack;</span>
<span class="udiff-line-added">+       _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       _c1_needs_stack_repair = (_args_on_stack_cc &lt; _args_on_stack) || (_args_on_stack_cc_ro &lt; _args_on_stack);</span>
<span class="udiff-line-added">+       _c2_needs_stack_repair = (_args_on_stack_cc &gt; _args_on_stack) || (_args_on_stack_cc &gt; _args_on_stack_cc_ro);</span>
<span class="udiff-line-added">+       _has_scalarized_args = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
    // Use customized signature handler.  Need to lock around updates to
    // the AdapterHandlerTable (it is not safe for concurrent readers
    // and a single writer: this could be fixed if it becomes a
    // problem).
  
    ResourceMark rm;
  
<span class="udiff-line-modified-removed">-   NOT_PRODUCT(int insts_size);</span>
<span class="udiff-line-modified-added">+   NOT_PRODUCT(int insts_size = 0);</span>
    AdapterBlob* new_adapter = NULL;
    AdapterHandlerEntry* entry = NULL;
    AdapterFingerPrint* fingerprint = NULL;
<span class="udiff-line-added">+ </span>
    {
      MutexLocker mu(AdapterHandlerLibrary_lock);
      // make sure data structure is initialized
      initialize();
  
<span class="udiff-line-modified-removed">-     if (method-&gt;is_abstract()) {</span>
<span class="udiff-line-modified-removed">-       return _abstract_method_handler;</span>
<span class="udiff-line-modified-added">+     CompiledEntrySignature ces(method());</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+        MutexUnlocker mul(AdapterHandlerLibrary_lock);</span>
<span class="udiff-line-added">+        ces.compute_calling_conventions();</span>
      }
<span class="udiff-line-added">+     GrowableArray&lt;SigEntry&gt;&amp; sig       = ces.sig();</span>
<span class="udiff-line-added">+     GrowableArray&lt;SigEntry&gt;&amp; sig_cc    = ces.sig_cc();</span>
<span class="udiff-line-added">+     GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro = ces.sig_cc_ro();</span>
<span class="udiff-line-added">+     VMRegPair* regs         = ces.regs();</span>
<span class="udiff-line-added">+     VMRegPair* regs_cc      = ces.regs_cc();</span>
<span class="udiff-line-added">+     VMRegPair* regs_cc_ro   = ces.regs_cc_ro();</span>
  
<span class="udiff-line-modified-removed">-     // Fill in the signature array, for the calling-convention call.</span>
<span class="udiff-line-modified-removed">-     int total_args_passed = method-&gt;size_of_parameters(); // All args on stack</span>
<span class="udiff-line-modified-added">+     if (ces.has_scalarized_args()) {</span>
<span class="udiff-line-modified-added">+       method-&gt;set_has_scalarized_args(true);</span>
<span class="udiff-line-added">+       method-&gt;set_c1_needs_stack_repair(ces.c1_needs_stack_repair());</span>
<span class="udiff-line-added">+       method-&gt;set_c2_needs_stack_repair(ces.c2_needs_stack_repair());</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);</span>
<span class="udiff-line-modified-removed">-     VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);</span>
<span class="udiff-line-modified-removed">-     int i = 0;</span>
<span class="udiff-line-modified-removed">-     if (!method-&gt;is_static())  // Pass in receiver first</span>
<span class="udiff-line-modified-removed">-       sig_bt[i++] = T_OBJECT;</span>
<span class="udiff-line-modified-removed">-     for (SignatureStream ss(method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-modified-removed">-       sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>
<span class="udiff-line-modified-removed">-       if (ss.type() == T_LONG || ss.type() == T_DOUBLE)</span>
<span class="udiff-line-modified-removed">-         sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots</span>
<span class="udiff-line-modified-added">+     if (method-&gt;is_abstract()) {</span>
<span class="udiff-line-modified-added">+       if (ces.has_scalarized_args()) {</span>
<span class="udiff-line-modified-added">+         // Save a C heap allocated version of the signature for abstract methods with scalarized value type arguments</span>
<span class="udiff-line-modified-added">+         address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();</span>
<span class="udiff-line-modified-added">+         entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
<span class="udiff-line-modified-added">+                                                  StubRoutines::throw_AbstractMethodError_entry(),</span>
<span class="udiff-line-modified-added">+                                                  wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
<span class="udiff-line-modified-added">+                                                  wrong_method_abstract, wrong_method_abstract);</span>
<span class="udiff-line-modified-added">+         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc_ro.length(), true);</span>
<span class="udiff-line-added">+         heap_sig-&gt;appendAll(&amp;sig_cc_ro);</span>
<span class="udiff-line-added">+         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="udiff-line-added">+         return entry;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         return _abstract_method_handler;</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-removed">-     assert(i == total_args_passed, &quot;&quot;);</span>
  
      // Lookup method signature&#39;s fingerprint
<span class="udiff-line-modified-removed">-     entry = _adapters-&gt;lookup(total_args_passed, sig_bt);</span>
<span class="udiff-line-modified-added">+     entry = _adapters-&gt;lookup(&amp;sig_cc, regs_cc != regs_cc_ro);</span>
  
  #ifdef ASSERT
      AdapterHandlerEntry* shared_entry = NULL;
      // Start adapter sharing verification only after the VM is booted.
      if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2666,14 +2994,11 @@</span>
  
      if (entry != NULL) {
        return entry;
      }
  
<span class="udiff-line-modified-removed">-     // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="udiff-line-removed">-     int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Make a C heap allocated version of the fingerprint to store in the adapter</span>
<span class="udiff-line-modified-added">+     // Make a C heap allocated version of the fingerprint to store in the adapter</span>
      fingerprint = new AdapterFingerPrint(&amp;sig_cc, regs_cc != regs_cc_ro);
  
      // StubRoutines::code2() is initialized after this function can be called. As a result,
      // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
      // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2688,29 +3013,43 @@</span>
        buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
                                               sizeof(buffer_locs)/sizeof(relocInfo));
  
        MacroAssembler _masm(&amp;buffer);
        entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<span class="udiff-line-modified-removed">-                                                      total_args_passed,</span>
<span class="udiff-line-modified-removed">-                                                      comp_args_on_stack,</span>
<span class="udiff-line-removed">-                                                      sig_bt,</span>
<span class="udiff-line-modified-added">+                                                      ces.args_on_stack(),</span>
<span class="udiff-line-modified-added">+                                                      &amp;sig,</span>
                                                       regs,
<span class="udiff-line-modified-removed">-                                                      fingerprint);</span>
<span class="udiff-line-modified-added">+                                                      &amp;sig_cc,</span>
<span class="udiff-line-added">+                                                      regs_cc,</span>
<span class="udiff-line-added">+                                                      &amp;sig_cc_ro,</span>
<span class="udiff-line-added">+                                                      regs_cc_ro,</span>
<span class="udiff-line-added">+                                                      fingerprint,</span>
<span class="udiff-line-added">+                                                      new_adapter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (ces.has_scalarized_args()) {</span>
<span class="udiff-line-added">+         // Save a C heap allocated version of the scalarized signature and store it in the adapter</span>
<span class="udiff-line-added">+         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc.length(), true);</span>
<span class="udiff-line-added">+         heap_sig-&gt;appendAll(&amp;sig_cc);</span>
<span class="udiff-line-added">+         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
  #ifdef ASSERT
        if (VerifyAdapterSharing) {
          if (shared_entry != NULL) {
<span class="udiff-line-added">+           if (!shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size())) {</span>
<span class="udiff-line-added">+             method-&gt;print();</span>
<span class="udiff-line-added">+           }</span>
            assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
            // Release the one just created and return the original
            _adapters-&gt;free_entry(entry);
            return shared_entry;
          } else  {
            entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
          }
        }
  #endif
  
<span class="udiff-line-removed">-       new_adapter = AdapterBlob::create(&amp;buffer);</span>
        NOT_PRODUCT(insts_size = buffer.insts_size());
      }
      if (new_adapter == NULL) {
        // CodeCache is full, disable compilation
        // Ought to log this but compile log is only per compile thread
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2762,11 +3101,14 @@</span>
  
  address AdapterHandlerEntry::base_address() {
    address base = _i2c_entry;
    if (base == NULL)  base = _c2i_entry;
    assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
<span class="udiff-line-added">+   assert(base &lt;= _c2i_value_entry || _c2i_value_entry == NULL, &quot;&quot;);</span>
<span class="udiff-line-added">+   assert(base &lt;= _c2i_value_ro_entry || _c2i_value_ro_entry == NULL, &quot;&quot;);</span>
    assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
<span class="udiff-line-added">+   assert(base &lt;= _c2i_unverified_value_entry || _c2i_unverified_value_entry == NULL, &quot;&quot;);</span>
    assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
    return base;
  }
  
  void AdapterHandlerEntry::relocate(address new_base) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2775,20 +3117,29 @@</span>
    ptrdiff_t delta = new_base - old_base;
    if (_i2c_entry != NULL)
      _i2c_entry += delta;
    if (_c2i_entry != NULL)
      _c2i_entry += delta;
<span class="udiff-line-added">+   if (_c2i_value_entry != NULL)</span>
<span class="udiff-line-added">+     _c2i_value_entry += delta;</span>
<span class="udiff-line-added">+   if (_c2i_value_ro_entry != NULL)</span>
<span class="udiff-line-added">+     _c2i_value_ro_entry += delta;</span>
    if (_c2i_unverified_entry != NULL)
      _c2i_unverified_entry += delta;
<span class="udiff-line-added">+   if (_c2i_unverified_value_entry != NULL)</span>
<span class="udiff-line-added">+     _c2i_unverified_value_entry += delta;</span>
    if (_c2i_no_clinit_check_entry != NULL)
      _c2i_no_clinit_check_entry += delta;
    assert(base_address() == new_base, &quot;&quot;);
  }
  
  
  void AdapterHandlerEntry::deallocate() {
    delete _fingerprint;
<span class="udiff-line-added">+   if (_sig_cc != NULL) {</span>
<span class="udiff-line-added">+     delete _sig_cc;</span>
<span class="udiff-line-added">+   }</span>
  #ifdef ASSERT
    FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2868,11 +3219,12 @@</span>
        int i=0;
        if (!method-&gt;is_static())  // Pass in receiver first
          sig_bt[i++] = T_OBJECT;
        SignatureStream ss(method-&gt;signature());
        for (; !ss.at_return_type(); ss.next()) {
<span class="udiff-line-modified-removed">-         sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>
<span class="udiff-line-modified-added">+         BasicType bt = ss.type();</span>
<span class="udiff-line-added">+         sig_bt[i++] = bt;  // Collect remaining bits of signature</span>
          if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
            sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
        }
        assert(i == total_args_passed, &quot;&quot;);
        BasicType ret_type = ss.type();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3121,12 +3473,21 @@</span>
      st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
    }
    if (get_c2i_entry() != NULL) {
      st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
    }
<span class="udiff-line-added">+   if (get_c2i_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2iVE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_entry()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (get_c2i_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2iVROE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_ro_entry()));</span>
<span class="udiff-line-added">+   }</span>
    if (get_c2i_unverified_entry() != NULL) {
<span class="udiff-line-modified-removed">-     st-&gt;print(&quot; c2iUV: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>
<span class="udiff-line-modified-added">+     st-&gt;print(&quot; c2iUE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (get_c2i_unverified_entry() != NULL) {</span>
<span class="udiff-line-added">+     st-&gt;print(&quot; c2iUVE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_value_entry()));</span>
    }
    if (get_c2i_no_clinit_check_entry() != NULL) {
      st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
    }
    st-&gt;cr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3135,10 +3496,12 @@</span>
  #if INCLUDE_CDS
  
  void CDSAdapterHandlerEntry::init() {
    assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
    _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
<span class="udiff-line-added">+   _c2i_value_ro_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
<span class="udiff-line-added">+   _c2i_value_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
    _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
  };
  
  #endif // INCLUDE_CDS
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3220,5 +3583,211 @@</span>
    if (new_obj == NULL) return;
  
    BarrierSet *bs = BarrierSet::barrier_set();
    bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // We are at a compiled code to interpreter call. We need backing</span>
<span class="udiff-line-added">+ // buffers for all value type arguments. Allocate an object array to</span>
<span class="udiff-line-added">+ // hold them (convenient because once we&#39;re done with it we don&#39;t have</span>
<span class="udiff-line-added">+ // to worry about freeing it).</span>
<span class="udiff-line-added">+ oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {</span>
<span class="udiff-line-added">+   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int nb_slots = 0;</span>
<span class="udiff-line-added">+   InstanceKlass* holder = callee-&gt;method_holder();</span>
<span class="udiff-line-added">+   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_value();</span>
<span class="udiff-line-added">+   if (allocate_receiver) {</span>
<span class="udiff-line-added">+     nb_slots++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-added">+     if (ss.type() == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       nb_slots++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);</span>
<span class="udiff-line-added">+   objArrayHandle array(THREAD, array_oop);</span>
<span class="udiff-line-added">+   int i = 0;</span>
<span class="udiff-line-added">+   if (allocate_receiver) {</span>
<span class="udiff-line-added">+     ValueKlass* vk = ValueKlass::cast(holder);</span>
<span class="udiff-line-added">+     oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="udiff-line-added">+     array-&gt;obj_at_put(i, res);</span>
<span class="udiff-line-added">+     i++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="udiff-line-added">+     if (ss.type() == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       ValueKlass* vk = ss.as_value_klass(holder);</span>
<span class="udiff-line-added">+       oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="udiff-line-added">+       array-&gt;obj_at_put(i, res);</span>
<span class="udiff-line-added">+       i++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return array();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JRT_ENTRY(void, SharedRuntime::allocate_value_types(JavaThread* thread, Method* callee_method, bool allocate_receiver))</span>
<span class="udiff-line-added">+   methodHandle callee(thread, callee_method);</span>
<span class="udiff-line-added">+   oop array = SharedRuntime::allocate_value_types_impl(thread, callee, allocate_receiver, CHECK);</span>
<span class="udiff-line-added">+   thread-&gt;set_vm_result(array);</span>
<span class="udiff-line-added">+   thread-&gt;set_vm_result_2(callee()); // TODO: required to keep callee live?</span>
<span class="udiff-line-added">+ JRT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // TODO remove this once the AARCH64 dependency is gone</span>
<span class="udiff-line-added">+ // Iterate over the array of heap allocated value types and apply the GC post barrier to all reference fields.</span>
<span class="udiff-line-added">+ // This is called from the C2I adapter after value type arguments are heap allocated and initialized.</span>
<span class="udiff-line-added">+ JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   assert(InlineTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="udiff-line-added">+   assert(oopDesc::is_oop(array), &quot;should be oop&quot;);</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; array-&gt;length(); ++i) {</span>
<span class="udiff-line-added">+     instanceOop valueOop = (instanceOop)array-&gt;obj_at(i);</span>
<span class="udiff-line-added">+     ValueKlass* vk = ValueKlass::cast(valueOop-&gt;klass());</span>
<span class="udiff-line-added">+     if (vk-&gt;contains_oops()) {</span>
<span class="udiff-line-added">+       const address dst_oop_addr = ((address) (void*) valueOop);</span>
<span class="udiff-line-added">+       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();</span>
<span class="udiff-line-added">+       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();</span>
<span class="udiff-line-added">+       while (map != end) {</span>
<span class="udiff-line-added">+         address doop_address = dst_oop_addr + map-&gt;offset();</span>
<span class="udiff-line-added">+         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;</span>
<span class="udiff-line-added">+           write_ref_array((HeapWord*) doop_address, map-&gt;count());</span>
<span class="udiff-line-added">+         map++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ JRT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // We&#39;re returning from an interpreted method: load each field into a</span>
<span class="udiff-line-added">+ // register following the calling convention</span>
<span class="udiff-line-added">+ JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   assert(res-&gt;klass()-&gt;is_value(), &quot;only value types here&quot;);</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   RegisterMap reg_map(thread);</span>
<span class="udiff-line-added">+   frame stubFrame = thread-&gt;last_frame();</span>
<span class="udiff-line-added">+   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="udiff-line-added">+   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ValueKlass* vk = ValueKlass::cast(res-&gt;klass());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="udiff-line-added">+   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (regs == NULL) {</span>
<span class="udiff-line-added">+     // The fields of the value klass don&#39;t fit in registers, bail out</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int j = 1;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="udiff-line-added">+     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="udiff-line-added">+     if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (bt == T_VOID) {</span>
<span class="udiff-line-added">+       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="udiff-line-added">+           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+         j++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="udiff-line-added">+     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="udiff-line-added">+     VMRegPair pair = regs-&gt;at(j);</span>
<span class="udiff-line-added">+     address loc = reg_map.location(pair.first());</span>
<span class="udiff-line-added">+     switch(bt) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN:</span>
<span class="udiff-line-added">+       *(jboolean*)loc = res-&gt;bool_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_CHAR:</span>
<span class="udiff-line-added">+       *(jchar*)loc = res-&gt;char_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_BYTE:</span>
<span class="udiff-line-added">+       *(jbyte*)loc = res-&gt;byte_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_SHORT:</span>
<span class="udiff-line-added">+       *(jshort*)loc = res-&gt;short_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_INT: {</span>
<span class="udiff-line-added">+       *(jint*)loc = res-&gt;int_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case T_LONG:</span>
<span class="udiff-line-added">+ #ifdef _LP64</span>
<span class="udiff-line-added">+       *(intptr_t*)loc = res-&gt;long_field(off);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+       Unimplemented();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_OBJECT:</span>
<span class="udiff-line-added">+     case T_ARRAY: {</span>
<span class="udiff-line-added">+       *(oop*)loc = res-&gt;obj_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case T_FLOAT:</span>
<span class="udiff-line-added">+       *(jfloat*)loc = res-&gt;float_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:</span>
<span class="udiff-line-added">+       *(jdouble*)loc = res-&gt;double_field(off);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       ShouldNotReachHere();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     j++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   VMRegPair pair = regs-&gt;at(0);</span>
<span class="udiff-line-added">+   address loc = reg_map.location(pair.first());</span>
<span class="udiff-line-added">+   assert(*(oopDesc**)loc == res, &quot;overwritten object&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   thread-&gt;set_vm_result(res);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ JRT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // We&#39;ve returned to an interpreted method, the interpreter needs a</span>
<span class="udiff-line-added">+ // reference to a value type instance. Allocate it and initialize it</span>
<span class="udiff-line-added">+ // from field&#39;s values in registers.</span>
<span class="udiff-line-added">+ JRT_BLOCK_ENTRY(void, SharedRuntime::store_value_type_fields_to_buf(JavaThread* thread, intptr_t res))</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   RegisterMap reg_map(thread);</span>
<span class="udiff-line-added">+   frame stubFrame = thread-&gt;last_frame();</span>
<span class="udiff-line-added">+   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   ValueKlass* verif_vk = ValueKlass::returned_value_klass(reg_map);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!is_set_nth_bit(res, 0)) {</span>
<span class="udiff-line-added">+     // We&#39;re not returning with value type fields in registers (the</span>
<span class="udiff-line-added">+     // calling convention didn&#39;t allow it for this value klass)</span>
<span class="udiff-line-added">+     assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);</span>
<span class="udiff-line-added">+     thread-&gt;set_vm_result((oopDesc*)res);</span>
<span class="udiff-line-added">+     assert(verif_vk == NULL, &quot;broken calling convention&quot;);</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   clear_nth_bit(res, 0);</span>
<span class="udiff-line-added">+   ValueKlass* vk = (ValueKlass*)res;</span>
<span class="udiff-line-added">+   assert(verif_vk == vk, &quot;broken calling convention&quot;);</span>
<span class="udiff-line-added">+   assert(Metaspace::contains((void*)res), &quot;should be klass&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Allocate handles for every oop field so they are safe in case of</span>
<span class="udiff-line-added">+   // a safepoint when allocating</span>
<span class="udiff-line-added">+   GrowableArray&lt;Handle&gt; handles;</span>
<span class="udiff-line-added">+   vk-&gt;save_oop_fields(reg_map, handles);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // It&#39;s unsafe to safepoint until we are here</span>
<span class="udiff-line-added">+   JRT_BLOCK;</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     Thread* THREAD = thread;</span>
<span class="udiff-line-added">+     oop vt = vk-&gt;realloc_result(reg_map, handles, CHECK);</span>
<span class="udiff-line-added">+     thread-&gt;set_vm_result(vt);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   JRT_BLOCK_END;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ JRT_END</span>
<span class="udiff-line-added">+ </span>
</pre>
<center><a href="safepoint.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>