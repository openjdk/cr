<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../.hgtags.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -44,10 +44,11 @@</span>
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/jniHandles.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/signature_cc.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1312,11 +1313,15 @@</span>
      Unimplemented();
    }
  }
  
  void MacroAssembler::verify_oop(Register reg, const char* s) {
<span class="udiff-line-modified-removed">-   if (!VerifyOops) return;</span>
<span class="udiff-line-modified-added">+   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="udiff-line-added">+     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="udiff-line-added">+     // because it may differ between otherwise equivalent adapters.</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
  
    // Pass register number to verify_oop_subroutine
    const char* b = NULL;
    {
      ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1342,11 +1347,15 @@</span>
  
    BLOCK_COMMENT(&quot;} verify_oop&quot;);
  }
  
  void MacroAssembler::verify_oop_addr(Address addr, const char* s) {
<span class="udiff-line-modified-removed">-   if (!VerifyOops) return;</span>
<span class="udiff-line-modified-added">+   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="udiff-line-added">+     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="udiff-line-added">+     // because it may differ between otherwise equivalent adapters.</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
  
    const char* b = NULL;
    {
      ResourceMark rm;
      stringStream ss;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1435,10 +1444,14 @@</span>
    pass_arg1(this, arg_1);
    pass_arg2(this, arg_2);
    call_VM_leaf_base(entry_point, 3);
  }
  
<span class="udiff-line-added">+ void MacroAssembler::super_call_VM_leaf(address entry_point) {</span>
<span class="udiff-line-added">+   MacroAssembler::call_VM_leaf_base(entry_point, 1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
    pass_arg0(this, arg_0);
    MacroAssembler::call_VM_leaf_base(entry_point, 1);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1484,10 +1497,43 @@</span>
      // nothing to do, (later) access of M[reg + offset]
      // will provoke OS NULL exception if reg = NULL
    }
  }
  
<span class="udiff-line-added">+ void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {</span>
<span class="udiff-line-added">+   ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));</span>
<span class="udiff-line-added">+   andr(temp_reg, temp_reg, JVM_ACC_VALUE);</span>
<span class="udiff-line-added">+   cbnz(temp_reg, is_value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::test_field_is_inline_type(Register flags, Register temp_reg, Label&amp; is_inline) {</span>
<span class="udiff-line-added">+   (void) temp_reg; // keep signature uniform with x86</span>
<span class="udiff-line-added">+   tbnz(flags, ConstantPoolCacheEntry::is_inline_field_shift, is_inline);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::test_field_is_not_inline_type(Register flags, Register temp_reg, Label&amp; not_inline) {</span>
<span class="udiff-line-added">+   (void) temp_reg; // keep signature uniform with x86</span>
<span class="udiff-line-added">+   tbz(flags, ConstantPoolCacheEntry::is_inline_field_shift, not_inline);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label&amp; is_flattened) {</span>
<span class="udiff-line-added">+   (void) temp_reg; // keep signature uniform with x86</span>
<span class="udiff-line-added">+   tbnz(flags, ConstantPoolCacheEntry::is_flattened_field_shift, is_flattened);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label&amp; is_flattened_array) {</span>
<span class="udiff-line-added">+   load_storage_props(temp_reg, oop);</span>
<span class="udiff-line-added">+   andr(temp_reg, temp_reg, ArrayStorageProperties::flattened_value);</span>
<span class="udiff-line-added">+   cbnz(temp_reg, is_flattened_array);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp; is_null_free_array) {</span>
<span class="udiff-line-added">+   load_storage_props(temp_reg, oop);</span>
<span class="udiff-line-added">+   andr(temp_reg, temp_reg, ArrayStorageProperties::null_free_value);</span>
<span class="udiff-line-added">+   cbnz(temp_reg, is_null_free_array);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // MacroAssembler protected routines needed to implement
  // public methods
  
  void MacroAssembler::mov(Register r, Address dest) {
    code_section()-&gt;relocate(pc(), dest.rspec());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3687,19 +3733,28 @@</span>
    ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
    ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
    ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
  }
  
<span class="udiff-line-modified-removed">- void MacroAssembler::load_klass(Register dst, Register src) {</span>
<span class="udiff-line-modified-added">+ void MacroAssembler::load_metadata(Register dst, Register src) {</span>
    if (UseCompressedClassPointers) {
      ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
<span class="udiff-line-removed">-     decode_klass_not_null(dst);</span>
    } else {
      ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
    }
  }
  
<span class="udiff-line-added">+ void MacroAssembler::load_klass(Register dst, Register src) {</span>
<span class="udiff-line-added">+   load_metadata(dst, src);</span>
<span class="udiff-line-added">+   if (UseCompressedClassPointers) {</span>
<span class="udiff-line-added">+     andr(dst, dst, oopDesc::compressed_klass_mask());</span>
<span class="udiff-line-added">+     decode_klass_not_null(dst);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ubfm(dst, dst, 0, 63 - oopDesc::storage_props_nof_bits);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // ((OopHandle)result).resolve();
  void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
    // OopHandle::resolve is an indirection.
    access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3727,10 +3782,19 @@</span>
    ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
    ldr(dst, Address(dst, mirror_offset));
    resolve_oop_handle(dst, tmp);
  }
  
<span class="udiff-line-added">+ void MacroAssembler::load_storage_props(Register dst, Register src) {</span>
<span class="udiff-line-added">+   load_metadata(dst, src);</span>
<span class="udiff-line-added">+   if (UseCompressedClassPointers) {</span>
<span class="udiff-line-added">+     asrw(dst, dst, oopDesc::narrow_storage_props_shift);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     asr(dst, dst, oopDesc::wide_storage_props_shift);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
    if (UseCompressedClassPointers) {
      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
      if (CompressedKlassPointers::base() == NULL) {
        cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4064,18 +4128,19 @@</span>
    }
  }
  
  void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
                                       Address dst, Register src,
<span class="udiff-line-modified-removed">-                                      Register tmp1, Register thread_tmp) {</span>
<span class="udiff-line-modified-added">+                                      Register tmp1, Register thread_tmp, Register tmp3) {</span>
<span class="udiff-line-added">+ </span>
    BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
    decorators = AccessInternal::decorator_fixup(decorators);
    bool as_raw = (decorators &amp; AS_RAW) != 0;
    if (as_raw) {
<span class="udiff-line-modified-removed">-     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp);</span>
<span class="udiff-line-modified-added">+     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);</span>
    } else {
<span class="udiff-line-modified-removed">-     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp);</span>
<span class="udiff-line-modified-added">+     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);</span>
    }
  }
  
  void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
    // Use stronger ACCESS_WRITE|ACCESS_READ by default.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4095,17 +4160,17 @@</span>
                                              Register thread_tmp, DecoratorSet decorators) {
    access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
  }
  
  void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
<span class="udiff-line-modified-removed">-                                     Register thread_tmp, DecoratorSet decorators) {</span>
<span class="udiff-line-modified-removed">-   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);</span>
<span class="udiff-line-modified-added">+                                     Register thread_tmp, Register tmp3, DecoratorSet decorators) {</span>
<span class="udiff-line-modified-added">+   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);</span>
  }
  
  // Used for storing NULLs.
  void MacroAssembler::store_heap_oop_null(Address dst) {
<span class="udiff-line-modified-removed">-   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);</span>
<span class="udiff-line-modified-added">+   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);</span>
  }
  
  Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
    assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
    int index = oop_recorder()-&gt;allocate_metadata_index(obj);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5174,10 +5239,400 @@</span>
    }
  
    pop(saved_regs, sp);
  }
  
<span class="udiff-line-added">+ // C2 compiled method&#39;s prolog code</span>
<span class="udiff-line-added">+ // Moved here from aarch64.ad to support Valhalla code belows</span>
<span class="udiff-line-added">+ void MacroAssembler::verified_entry(Compile* C, int sp_inc) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // n.b. frame size includes space for return pc and rfp</span>
<span class="udiff-line-added">+   const long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-added">+   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2 * wordSize alignment&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // insert a nop at the start of the prolog so we can patch in a</span>
<span class="udiff-line-added">+   // branch if we need to invalidate the method later</span>
<span class="udiff-line-added">+   nop();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-added">+   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="udiff-line-added">+      generate_stack_overflow_check(bangsize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   build_frame(framesize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (VerifyStackAtCalls) {</span>
<span class="udiff-line-added">+     Unimplemented();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="udiff-line-added">+   // A value type might be returned. If fields are in registers we</span>
<span class="udiff-line-added">+   // need to allocate a value type instance and initialize it with</span>
<span class="udiff-line-added">+   // the value of the fields.</span>
<span class="udiff-line-added">+   Label skip;</span>
<span class="udiff-line-added">+   // We only need a new buffered value if a new one is not returned</span>
<span class="udiff-line-added">+   cmp(r0, (u1) 1);</span>
<span class="udiff-line-added">+   br(Assembler::EQ, skip);</span>
<span class="udiff-line-added">+   int call_offset = -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label slow_case;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Try to allocate a new buffered value (from the heap)</span>
<span class="udiff-line-added">+   if (UseTLAB) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (vk != NULL) {</span>
<span class="udiff-line-added">+       // Called from C1, where the return type is statically known.</span>
<span class="udiff-line-added">+       mov(r1, (intptr_t)vk-&gt;get_ValueKlass());</span>
<span class="udiff-line-added">+       jint lh = vk-&gt;layout_helper();</span>
<span class="udiff-line-added">+       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);</span>
<span class="udiff-line-added">+       mov(r14, lh);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+        // Call from interpreter. R0 contains ((the ValueKlass* of the return type) | 0x01)</span>
<span class="udiff-line-added">+        andr(r1, r0, -2);</span>
<span class="udiff-line-added">+        // get obj size</span>
<span class="udiff-line-added">+        ldrw(r14, Address(rscratch1 /*klass*/, Klass::layout_helper_offset()));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+      ldr(r13, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+      // check whether we have space in TLAB,</span>
<span class="udiff-line-added">+      // rscratch1 contains pointer to just allocated obj</span>
<span class="udiff-line-added">+       lea(r14, Address(r13, r14));</span>
<span class="udiff-line-added">+       ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       cmp(r14, rscratch1);</span>
<span class="udiff-line-added">+       br(Assembler::GT, slow_case);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // OK we have room in TLAB,</span>
<span class="udiff-line-added">+       // Set new TLAB top</span>
<span class="udiff-line-added">+       str(r14, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // Set new class always locked</span>
<span class="udiff-line-added">+       mov(rscratch1, (uint64_t) markWord::always_locked_prototype().value());</span>
<span class="udiff-line-added">+       str(rscratch1, Address(r13, oopDesc::mark_offset_in_bytes()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       store_klass_gap(r13, zr);  // zero klass gap for compressed oops</span>
<span class="udiff-line-added">+       if (vk == NULL) {</span>
<span class="udiff-line-added">+         // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).</span>
<span class="udiff-line-added">+          mov(r0, r1);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       store_klass(r13, r1);  // klass</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (vk != NULL) {</span>
<span class="udiff-line-added">+         // FIXME -- do the packing in-line to avoid the runtime call</span>
<span class="udiff-line-added">+         mov(r0, r13);</span>
<span class="udiff-line-added">+         far_call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // We have our new buffered value, initialize its fields with a</span>
<span class="udiff-line-added">+         // value class specific handler</span>
<span class="udiff-line-added">+         ldr(r1, Address(r0, InstanceKlass::adr_valueklass_fixed_block_offset()));</span>
<span class="udiff-line-added">+         ldr(r1, Address(r1, ValueKlass::pack_handler_offset()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Mov new class to r0 and call pack_handler</span>
<span class="udiff-line-added">+         mov(r0, r13);</span>
<span class="udiff-line-added">+         blr(r1);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       b(skip);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bind(slow_case);</span>
<span class="udiff-line-added">+   // We failed to allocate a new value, fall back to a runtime</span>
<span class="udiff-line-added">+   // call. Some oop field may be live in some registers but we can&#39;t</span>
<span class="udiff-line-added">+   // tell. That runtime call will take care of preserving them</span>
<span class="udiff-line-added">+   // across a GC if there&#39;s one.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (from_interpreter) {</span>
<span class="udiff-line-added">+     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ldr(rscratch1, RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));</span>
<span class="udiff-line-added">+     blr(rscratch1);</span>
<span class="udiff-line-added">+     call_offset = offset();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bind(skip);</span>
<span class="udiff-line-added">+   return call_offset;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Move a value between registers/stack slots and update the reg_state</span>
<span class="udiff-line-added">+ bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="udiff-line-added">+   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="udiff-line-added">+     return true; // Already written</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (from != to &amp;&amp; bt != T_VOID) {</span>
<span class="udiff-line-added">+     if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="udiff-line-added">+       return false; // Not yet writable</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (from-&gt;is_reg()) {</span>
<span class="udiff-line-added">+       if (to-&gt;is_reg()) {</span>
<span class="udiff-line-added">+         mov(to-&gt;as_Register(), from-&gt;as_Register());</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="udiff-line-added">+         Address to_addr = Address(sp, st_off);</span>
<span class="udiff-line-added">+         if (from-&gt;is_FloatRegister()) {</span>
<span class="udiff-line-added">+           if (bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+              strd(from-&gt;as_FloatRegister(), to_addr);</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+              assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="udiff-line-added">+              strs(from-&gt;as_FloatRegister(), to_addr);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           str(from-&gt;as_Register(), to_addr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       Address from_addr = Address(sp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);</span>
<span class="udiff-line-added">+       if (to-&gt;is_reg()) {</span>
<span class="udiff-line-added">+         if (to-&gt;is_FloatRegister()) {</span>
<span class="udiff-line-added">+           if (bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+              ldrd(to-&gt;as_FloatRegister(), from_addr);</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+             assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="udiff-line-added">+             ldrs(to-&gt;as_FloatRegister(), from_addr);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           ldr(to-&gt;as_Register(), from_addr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="udiff-line-added">+         ldr(rscratch1, from_addr);</span>
<span class="udiff-line-added">+         str(rscratch1, Address(sp, st_off));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Update register states</span>
<span class="udiff-line-added">+   reg_state[from-&gt;value()] = reg_writable;</span>
<span class="udiff-line-added">+   reg_state[to-&gt;value()] = reg_written;</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Read all fields from a value type oop and store the values in registers/stack slots</span>
<span class="udiff-line-added">+ bool MacroAssembler::unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,</span>
<span class="udiff-line-added">+                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="udiff-line-added">+   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;</span>
<span class="udiff-line-added">+   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int vt = 1;</span>
<span class="udiff-line-added">+   bool done = true;</span>
<span class="udiff-line-added">+   bool mark_done = true;</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     sig_index--;</span>
<span class="udiff-line-added">+     BasicType bt = sig-&gt;at(sig_index)._bt;</span>
<span class="udiff-line-added">+     if (bt == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       vt--;</span>
<span class="udiff-line-added">+     } else if (bt == T_VOID &amp;&amp;</span>
<span class="udiff-line-added">+                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;</span>
<span class="udiff-line-added">+                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {</span>
<span class="udiff-line-added">+       vt++;</span>
<span class="udiff-line-added">+     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {</span>
<span class="udiff-line-added">+       to_index--; // Ignore this</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);</span>
<span class="udiff-line-added">+       VMRegPair pair_to = regs_to[to_index--];</span>
<span class="udiff-line-added">+       VMReg to = pair_to.first();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (bt == T_VOID) continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       int idx = (int) to-&gt;value();</span>
<span class="udiff-line-added">+       if (reg_state[idx] == reg_readonly) {</span>
<span class="udiff-line-added">+          if (idx != from-&gt;value()) {</span>
<span class="udiff-line-added">+            mark_done = false;</span>
<span class="udiff-line-added">+          }</span>
<span class="udiff-line-added">+          done = false;</span>
<span class="udiff-line-added">+          continue;</span>
<span class="udiff-line-added">+       } else if (reg_state[idx] == reg_written) {</span>
<span class="udiff-line-added">+         continue;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);</span>
<span class="udiff-line-added">+         reg_state[idx] = reg_written;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (fromReg == noreg) {</span>
<span class="udiff-line-added">+         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="udiff-line-added">+         ldr(rscratch2, Address(sp, st_off));</span>
<span class="udiff-line-added">+         fromReg = rscratch2;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       int off = sig-&gt;at(sig_index)._offset;</span>
<span class="udiff-line-added">+       assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="udiff-line-added">+       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       Address fromAddr = Address(fromReg, off);</span>
<span class="udiff-line-added">+       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (!to-&gt;is_FloatRegister()) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Register dst = to-&gt;is_stack() ? rscratch1 : to-&gt;as_Register();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (is_oop) {</span>
<span class="udiff-line-added">+           load_heap_oop(dst, fromAddr);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (to-&gt;is_stack()) {</span>
<span class="udiff-line-added">+           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="udiff-line-added">+           str(dst, Address(sp, st_off));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         if (bt == T_DOUBLE) {</span>
<span class="udiff-line-added">+           ldrd(to-&gt;as_FloatRegister(), fromAddr);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="udiff-line-added">+           ldrs(to-&gt;as_FloatRegister(), fromAddr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   } while (vt != 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {</span>
<span class="udiff-line-added">+     // This is okay because no one else will write to that slot</span>
<span class="udiff-line-added">+     reg_state[from-&gt;value()] = reg_writable;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return done;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Pack fields back into a value type oop</span>
<span class="udiff-line-added">+ bool MacroAssembler::pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,</span>
<span class="udiff-line-added">+                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="udiff-line-added">+                                        int ret_off, int extra_stack_offset) {</span>
<span class="udiff-line-added">+   assert(sig-&gt;at(sig_index)._bt == T_VALUETYPE, &quot;should be at end delimiter&quot;);</span>
<span class="udiff-line-added">+   assert(to-&gt;is_valid(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="udiff-line-added">+     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="udiff-line-added">+     return true; // Already written</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Register val_array = r0;</span>
<span class="udiff-line-added">+   Register val_obj_tmp = r11;</span>
<span class="udiff-line-added">+   Register from_reg_tmp = r10;</span>
<span class="udiff-line-added">+   Register tmp1 = r14;</span>
<span class="udiff-line-added">+   Register tmp2 = r13;</span>
<span class="udiff-line-added">+   Register tmp3 = r1;</span>
<span class="udiff-line-added">+   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="udiff-line-added">+     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {</span>
<span class="udiff-line-added">+       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="udiff-line-added">+       return false; // Not yet writable</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     val_obj = val_obj_tmp;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_VALUETYPE);</span>
<span class="udiff-line-added">+   load_heap_oop(val_obj, Address(val_array, index));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="udiff-line-added">+   VMRegPair from_pair;</span>
<span class="udiff-line-added">+   BasicType bt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   while (stream.next(from_pair, bt)) {</span>
<span class="udiff-line-added">+     int off = sig-&gt;at(stream.sig_cc_index())._offset;</span>
<span class="udiff-line-added">+     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="udiff-line-added">+     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="udiff-line-added">+     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     VMReg from_r1 = from_pair.first();</span>
<span class="udiff-line-added">+     VMReg from_r2 = from_pair.second();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Pack the scalarized field into the value object.</span>
<span class="udiff-line-added">+     Address dst(val_obj, off);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!from_r1-&gt;is_FloatRegister()) {</span>
<span class="udiff-line-added">+       Register from_reg;</span>
<span class="udiff-line-added">+       if (from_r1-&gt;is_stack()) {</span>
<span class="udiff-line-added">+         from_reg = from_reg_tmp;</span>
<span class="udiff-line-added">+         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="udiff-line-added">+         load_sized_value(from_reg, Address(sp, ld_off), size_in_bytes, /* is_signed */ false);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         from_reg = from_r1-&gt;as_Register();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (is_oop) {</span>
<span class="udiff-line-added">+         DecoratorSet decorators = IN_HEAP | ACCESS_WRITE;</span>
<span class="udiff-line-added">+         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, decorators);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         store_sized_value(dst, from_reg, size_in_bytes);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       if (from_r2-&gt;is_valid()) {</span>
<span class="udiff-line-added">+         strd(from_r1-&gt;as_FloatRegister(), dst);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         strs(from_r1-&gt;as_FloatRegister(), dst);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     reg_state[from_r1-&gt;value()] = reg_writable;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   sig_index = stream.sig_cc_index();</span>
<span class="udiff-line-added">+   from_index = stream.regs_cc_index();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);</span>
<span class="udiff-line-added">+   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);</span>
<span class="udiff-line-added">+   assert(success, &quot;to register must be writeable&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Unpack all value type arguments passed as oops</span>
<span class="udiff-line-added">+ void MacroAssembler::unpack_value_args(Compile* C, bool receiver_only) {</span>
<span class="udiff-line-added">+   int sp_inc = unpack_value_args_common(C, receiver_only);</span>
<span class="udiff-line-added">+   // Emit code for verified entry and save increment for stack repair on return</span>
<span class="udiff-line-added">+   verified_entry(C, sp_inc);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int MacroAssembler::shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,</span>
<span class="udiff-line-added">+                                        BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="udiff-line-added">+                                        int args_passed, int args_on_stack, VMRegPair* regs,            // from</span>
<span class="udiff-line-added">+                                        int args_passed_to, int args_on_stack_to, VMRegPair* regs_to) { // to</span>
<span class="udiff-line-added">+   // Check if we need to extend the stack for packing/unpacking</span>
<span class="udiff-line-added">+   int sp_inc = (args_on_stack_to - args_on_stack) * VMRegImpl::stack_slot_size;</span>
<span class="udiff-line-added">+   if (sp_inc &gt; 0) {</span>
<span class="udiff-line-added">+     sp_inc = align_up(sp_inc, StackAlignmentInBytes);</span>
<span class="udiff-line-added">+     if (!is_packing) {</span>
<span class="udiff-line-added">+       // Save the return address, adjust the stack (make sure it is properly</span>
<span class="udiff-line-added">+       // 16-byte aligned) and copy the return address to the new top of the stack.</span>
<span class="udiff-line-added">+       // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).</span>
<span class="udiff-line-added">+       // FIXME: We need not to preserve return address on aarch64</span>
<span class="udiff-line-added">+       pop(rscratch1);</span>
<span class="udiff-line-added">+       sub(sp, sp, sp_inc);</span>
<span class="udiff-line-added">+       push(rscratch1);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // The scalarized calling convention needs less stack space than the unscalarized one.</span>
<span class="udiff-line-added">+     // No need to extend the stack, the caller will take care of these adjustments.</span>
<span class="udiff-line-added">+     sp_inc = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int ret_off; // make sure we don&#39;t overwrite the return address</span>
<span class="udiff-line-added">+   if (is_packing) {</span>
<span class="udiff-line-added">+     // For C1 code, the VVEP doesn&#39;t have reserved slots, so we store the returned address at</span>
<span class="udiff-line-added">+     // rsp[0] during shuffling.</span>
<span class="udiff-line-added">+     ret_off = 0;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // C2 code ensures that sp_inc is a reserved slot.</span>
<span class="udiff-line-added">+     ret_off = sp_inc;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,</span>
<span class="udiff-line-added">+                                    sig_bt, sig_cc,</span>
<span class="udiff-line-added">+                                    args_passed, args_on_stack, regs,</span>
<span class="udiff-line-added">+                                    args_passed_to, args_on_stack_to, regs_to,</span>
<span class="udiff-line-added">+                                    sp_inc, ret_off);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ VMReg MacroAssembler::spill_reg_for(VMReg reg) {</span>
<span class="udiff-line-added">+   return (reg-&gt;is_FloatRegister()) ? v0-&gt;as_VMReg() : r14-&gt;as_VMReg();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void MacroAssembler::cache_wb(Address line) {
    assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);
    assert(line.index() == noreg, &quot;index should be noreg&quot;);
    assert(line.offset() == 0, &quot;offset should be 0&quot;);
    // would like to assert this
</pre>
<center><a href="../../../../.hgtags.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>