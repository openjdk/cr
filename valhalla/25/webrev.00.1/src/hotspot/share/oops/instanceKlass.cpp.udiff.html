<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -62,10 +62,11 @@</span>
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/recordComponent.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/valueKlass.hpp&quot;</span>
  #include &quot;prims/jvmtiExport.hpp&quot;
  #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  #include &quot;prims/jvmtiThreadState.hpp&quot;
  #include &quot;prims/methodComparator.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,11 +372,13 @@</span>
    const int size = InstanceKlass::size(parser.vtable_size(),
                                         parser.itable_size(),
                                         nonstatic_oop_map_size(parser.total_oop_map_count()),
                                         parser.is_interface(),
                                         parser.is_unsafe_anonymous(),
<span class="udiff-line-modified-removed">-                                        should_store_fingerprint(parser.is_unsafe_anonymous()));</span>
<span class="udiff-line-modified-added">+                                        should_store_fingerprint(parser.is_unsafe_anonymous()),</span>
<span class="udiff-line-added">+                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,</span>
<span class="udiff-line-added">+                                        parser.is_value_type());</span>
  
    const Symbol* const class_name = parser.class_name();
    assert(class_name != NULL, &quot;invariant&quot;);
    ClassLoaderData* loader_data = parser.loader_data();
    assert(loader_data != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -385,14 +388,16 @@</span>
    // Allocation
    if (REF_NONE == parser.reference_type()) {
      if (class_name == vmSymbols::java_lang_Class()) {
        // mirror
        ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-     else if (is_class_loader(class_name, parser)) {</span>
<span class="udiff-line-modified-added">+     } else if (is_class_loader(class_name, parser)) {</span>
        // class loader
        ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="udiff-line-added">+     } else if (parser.is_value_type()) {</span>
<span class="udiff-line-added">+       // value type</span>
<span class="udiff-line-added">+       ik = new (loader_data, size, THREAD) ValueKlass(parser);</span>
      } else {
        // normal
        ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -404,13 +409,43 @@</span>
    // class count.  Can get OOM here.
    if (HAS_PENDING_EXCEPTION) {
      return NULL;
    }
  
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="udiff-line-added">+   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="udiff-line-added">+   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="udiff-line-added">+   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="udiff-line-added">+   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="udiff-line-added">+ #endif //ASSERT</span>
    return ik;
  }
  
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+ bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="udiff-line-added">+   const char* bad = NULL;</span>
<span class="udiff-line-added">+   address end = NULL;</span>
<span class="udiff-line-added">+   if (addr &lt; (address)this) {</span>
<span class="udiff-line-added">+     bad = &quot;before&quot;;</span>
<span class="udiff-line-added">+   } else if (addr == (address)this) {</span>
<span class="udiff-line-added">+     if (edge_ok)  return true;</span>
<span class="udiff-line-added">+     bad = &quot;just before&quot;;</span>
<span class="udiff-line-added">+   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="udiff-line-added">+     if (edge_ok)  return true;</span>
<span class="udiff-line-added">+     bad = &quot;just after&quot;;</span>
<span class="udiff-line-added">+   } else if (addr &gt; end) {</span>
<span class="udiff-line-added">+     bad = &quot;after&quot;;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="udiff-line-added">+       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="udiff-line-added">+   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif //PRODUCT</span>
  
  // copy method ordering from resource area to Metaspace
  void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
    if (m != NULL) {
      // allocate a new array and copy contents (memcpy?)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,32 +475,41 @@</span>
    _static_field_size(parser.static_field_size()),
    _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
    _itable_len(parser.itable_size()),
    _init_thread(NULL),
    _init_state(allocated),
<span class="udiff-line-modified-removed">-   _reference_type(parser.reference_type())</span>
<span class="udiff-line-modified-added">+   _reference_type(parser.reference_type()),</span>
<span class="udiff-line-added">+   _value_field_klasses(NULL),</span>
<span class="udiff-line-added">+   _adr_valueklass_fixed_block(NULL)</span>
  {
    set_vtable_length(parser.vtable_size());
    set_kind(kind);
    set_access_flags(parser.access_flags());
    set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
    set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
                                                      false));
<span class="udiff-line-added">+     if (parser.has_flattenable_fields()) {</span>
<span class="udiff-line-added">+       set_has_value_fields();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     _java_fields_count = parser.java_fields_count();</span>
  
<span class="udiff-line-modified-removed">-   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
<span class="udiff-line-modified-added">+     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="udiff-line-modified-added">+     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="udiff-line-modified-added">+     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
  
    if (Arguments::is_dumping_archive()) {
<span class="udiff-line-modified-removed">-     SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+       SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="udiff-line-modified-added">+     }</span>
  
    // Set biased locking bit for all instances of this class; it will be
    // cleared if revocation occurs too often for this type
    if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
      set_prototype_header(markWord::biased_locking_prototype());
    }
<span class="udiff-line-added">+   if (has_value_fields()) {</span>
<span class="udiff-line-added">+     _value_field_klasses = (const Klass**) adr_value_fields_klasses();</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
                                         Array&lt;Method*&gt;* methods) {
    if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -813,10 +857,68 @@</span>
    for (int index = 0; index &lt; num_interfaces; index++) {
      InstanceKlass* interk = interfaces-&gt;at(index);
      interk-&gt;link_class_impl(CHECK_false);
    }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // If a class declares a method that uses a value class as an argument</span>
<span class="udiff-line-added">+   // type or return value type, this value class must be loaded during the</span>
<span class="udiff-line-added">+   // linking of this class because size and properties of the value class</span>
<span class="udiff-line-added">+   // must be known in order to be able to perform value type optimizations.</span>
<span class="udiff-line-added">+   // The implementation below is an approximation of this rule, the code</span>
<span class="udiff-line-added">+   // iterates over all methods of the current class (including overridden</span>
<span class="udiff-line-added">+   // methods), not only the methods declared by this class. This</span>
<span class="udiff-line-added">+   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="udiff-line-added">+   // because classes declaring methods overridden by the current class are</span>
<span class="udiff-line-added">+   // linked (and have performed their own pre-loading) before the linking</span>
<span class="udiff-line-added">+   // of the current class.</span>
<span class="udiff-line-added">+   // This is also the moment to detect potential mismatch between the</span>
<span class="udiff-line-added">+   // ValueTypes attribute and the kind of the class effectively loaded.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Note:</span>
<span class="udiff-line-added">+   // Value class types used for flattenable fields are loaded during</span>
<span class="udiff-line-added">+   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="udiff-line-added">+   // Value class types used as element types for array creation</span>
<span class="udiff-line-added">+   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="udiff-line-added">+   // or multianewarray bytecodes.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Could it be possible to do the following processing only if the</span>
<span class="udiff-line-added">+   // class uses value types?</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     ResourceMark rm(THREAD);</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       Method* m = methods()-&gt;at(i);</span>
<span class="udiff-line-added">+       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="udiff-line-added">+         if (ss.is_reference()) {</span>
<span class="udiff-line-added">+           if (ss.is_array()) {</span>
<span class="udiff-line-added">+             ss.skip_array_prefix();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           if (ss.type() == T_VALUETYPE) {</span>
<span class="udiff-line-added">+             Symbol* symb = ss.as_symbol();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             oop loader = class_loader();</span>
<span class="udiff-line-added">+             oop protection_domain = this-&gt;protection_domain();</span>
<span class="udiff-line-added">+             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="udiff-line-added">+                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="udiff-line-added">+                                                              CHECK_false);</span>
<span class="udiff-line-added">+             if (klass == NULL) {</span>
<span class="udiff-line-added">+               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!klass-&gt;is_value()) {</span>
<span class="udiff-line-added">+               Exceptions::fthrow(</span>
<span class="udiff-line-added">+                 THREAD_AND_LOCATION,</span>
<span class="udiff-line-added">+                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="udiff-line-added">+                 &quot;class %s is not an inline type&quot;,</span>
<span class="udiff-line-added">+                 klass-&gt;external_name());</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // in case the class is linked in the process of linking its superclasses
    if (is_linked()) {
      return true;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -882,10 +984,11 @@</span>
          vtable().verify(tty, true);
          // In case itable verification is ever added.
          // itable().verify(tty, true);
        }
  #endif
<span class="udiff-line-added">+ </span>
        set_init_state(linked);
        if (JvmtiExport::should_post_class_prepare()) {
          Thread *thread = THREAD;
          assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
          JvmtiExport::post_class_prepare((JavaThread *) thread, this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1035,15 +1138,46 @@</span>
        DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
        THROW_OOP(e());
      }
    }
  
<span class="udiff-line-added">+   // Step 8</span>
<span class="udiff-line-added">+   // Initialize classes of flattenable fields</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="udiff-line-added">+       if (fs.is_flattenable()) {</span>
<span class="udiff-line-added">+         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());</span>
<span class="udiff-line-added">+         if (klass == NULL) {</span>
<span class="udiff-line-added">+           assert(fs.access_flags().is_static() &amp;&amp; fs.access_flags().is_flattenable(),</span>
<span class="udiff-line-added">+               &quot;Otherwise should have been pre-loaded&quot;);</span>
<span class="udiff-line-added">+           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="udiff-line-added">+               Handle(THREAD, class_loader()),</span>
<span class="udiff-line-added">+               Handle(THREAD, protection_domain()),</span>
<span class="udiff-line-added">+               true, CHECK);</span>
<span class="udiff-line-added">+           if (klass == NULL) {</span>
<span class="udiff-line-added">+             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           if (!klass-&gt;is_value()) {</span>
<span class="udiff-line-added">+             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           this-&gt;set_value_field_klass(fs.index(), klass);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="udiff-line-added">+         if (fs.access_flags().is_static()) {</span>
<span class="udiff-line-added">+           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="udiff-line-added">+             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  
    // Look for aot compiled methods for this klass, including class initializer.
    AOTLoader::load_for_klass(this, THREAD);
  
<span class="udiff-line-modified-removed">-   // Step 8</span>
<span class="udiff-line-modified-added">+   // Step 9</span>
    {
      DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
      // Timer includes any side effects of class initialization (resolution,
      // etc), but not recursive entry into call_class_initializer().
      PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1053,19 +1187,19 @@</span>
                               jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
                               PerfClassTraceTime::CLASS_CLINIT);
      call_class_initializer(THREAD);
    }
  
<span class="udiff-line-modified-removed">-   // Step 9</span>
<span class="udiff-line-modified-added">+   // Step 10</span>
    if (!HAS_PENDING_EXCEPTION) {
      set_initialization_state_and_notify(fully_initialized, CHECK);
      {
        debug_only(vtable().verify(tty, true);)
      }
    }
    else {
<span class="udiff-line-modified-removed">-     // Step 10 and 11</span>
<span class="udiff-line-modified-added">+     // Step 11 and 12</span>
      Handle e(THREAD, PENDING_EXCEPTION);
      CLEAR_PENDING_EXCEPTION;
      // JVMTI has already reported the pending exception
      // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
      JvmtiExport::clear_detected_exception(jt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1313,11 +1447,12 @@</span>
      THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
                : vmSymbols::java_lang_IllegalAccessException(), external_name());
    }
  }
  
<span class="udiff-line-modified-removed">- Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {</span>
<span class="udiff-line-modified-added">+ Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, int n, TRAPS) {</span>
<span class="udiff-line-added">+   assert(storage_props.is_empty(), &quot;Unexpected&quot;);</span>
    // Need load-acquire for lock-free read
    if (array_klasses_acquire() == NULL) {
      if (or_null) return NULL;
  
      ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1326,34 +1461,34 @@</span>
        // Atomic creation of array_klasses
        MutexLocker ma(THREAD, MultiArray_lock);
  
        // Check if update has already taken place
        if (array_klasses() == NULL) {
<span class="udiff-line-modified-removed">-         Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+         Klass*    k = ObjArrayKlass::allocate_objArray_klass(storage_props, 1, this, CHECK_NULL);</span>
          // use &#39;release&#39; to pair with lock-free load
          release_set_array_klasses(k);
        }
      }
    }
    // _this will always be set at this point
    ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
    if (or_null) {
<span class="udiff-line-modified-removed">-     return oak-&gt;array_klass_or_null(n);</span>
<span class="udiff-line-modified-added">+     return oak-&gt;array_klass_or_null(storage_props, n);</span>
    }
<span class="udiff-line-modified-removed">-   return oak-&gt;array_klass(n, THREAD);</span>
<span class="udiff-line-modified-added">+   return oak-&gt;array_klass(storage_props, n, THREAD);</span>
  }
  
<span class="udiff-line-modified-removed">- Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {</span>
<span class="udiff-line-modified-removed">-   return array_klass_impl(or_null, 1, THREAD);</span>
<span class="udiff-line-modified-added">+ Klass* InstanceKlass::array_klass_impl(ArrayStorageProperties storage_props, bool or_null, TRAPS) {</span>
<span class="udiff-line-modified-added">+   return array_klass_impl(storage_props, or_null, 1, THREAD);</span>
  }
  
  static int call_class_initializer_counter = 0;   // for debugging
  
  Method* InstanceKlass::class_initializer() const {
    Method* clinit = find_method(
        vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="udiff-line-modified-removed">-   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
<span class="udiff-line-modified-added">+   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
      return clinit;
    }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1387,11 +1522,11 @@</span>
    InterpreterOopMap* entry_for) {
    // Lazily create the _oop_map_cache at first request
    // Lock-free access requires load_acquire.
    OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
    if (oop_map_cache == NULL) {
<span class="udiff-line-modified-removed">-     MutexLocker x(OopMapCacheAlloc_lock);</span>
<span class="udiff-line-modified-added">+     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
      // Check if _oop_map_cache was allocated while we were waiting for this lock
      if ((oop_map_cache = _oop_map_cache) == NULL) {
        oop_map_cache = new OopMapCache();
        // Ensure _oop_map_cache is stable, since it is examined without a lock
        Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1399,15 +1534,10 @@</span>
    }
    // _oop_map_cache is constant after init; lookup below does its own locking.
    oop_map_cache-&gt;lookup(method, bci, entry_for);
  }
  
<span class="udiff-line-removed">- bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="udiff-line-removed">-   fieldDescriptor fd;</span>
<span class="udiff-line-removed">-   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
    for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
      Symbol* f_name = fs.name();
      Symbol* f_sig  = fs.signature();
      if (f_name == name &amp;&amp; f_sig == sig) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1474,10 +1604,19 @@</span>
    }
    // 4) otherwise field lookup fails
    return NULL;
  }
  
<span class="udiff-line-added">+ bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="udiff-line-added">+   if (this-&gt;is_value()) {</span>
<span class="udiff-line-added">+     ValueKlass* vk = ValueKlass::cast(this);</span>
<span class="udiff-line-added">+     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     fieldDescriptor fd;</span>
<span class="udiff-line-added">+     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
    for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
      if (fs.offset() == offset) {
        fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1570,15 +1709,10 @@</span>
    }
    FREE_C_HEAP_ARRAY(int, fields_sorted);
  }
  
  
<span class="udiff-line-removed">- void InstanceKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {</span>
<span class="udiff-line-removed">-   if (array_klasses() != NULL)</span>
<span class="udiff-line-removed">-     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f, THREAD);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void InstanceKlass::array_klasses_do(void f(Klass* k)) {
    if (array_klasses() != NULL)
      ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1858,10 +1992,13 @@</span>
                                                                          find_static,
                                                                          private_mode);
      if (method != NULL) {
        return method;
      }
<span class="udiff-line-added">+     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="udiff-line-added">+       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="udiff-line-added">+     }</span>
      klass = klass-&gt;super();
      overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
    }
    return NULL;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2440,10 +2577,14 @@</span>
    // sure the current state is &lt;loaded.
    assert(!is_loaded(), &quot;invalid init state&quot;);
    set_package(loader_data, pkg_entry, CHECK);
    Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
  
<span class="udiff-line-added">+   if (is_value()) {</span>
<span class="udiff-line-added">+     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    Array&lt;Method*&gt;* methods = this-&gt;methods();
    int num_methods = methods-&gt;length();
    for (int index = 0; index &lt; num_methods; ++index) {
      methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2465,11 +2606,11 @@</span>
      // --&gt; see ArrayKlass::complete_create_array_klass()
      ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
    }
  
    // Initialize current biased locking state.
<span class="udiff-line-modified-removed">-   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
<span class="udiff-line-modified-added">+   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
      set_prototype_header(markWord::biased_locking_prototype());
    }
  }
  
  void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2582,10 +2723,18 @@</span>
    // Decrement symbol reference counts associated with the unloaded class.
    if (_name != NULL) _name-&gt;decrement_refcount();
    // unreference array name derived from this class name (arrays of an unloaded
    // class can&#39;t be referenced anymore).
    if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="udiff-line-added">+   if (_value_types != NULL) {</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; _value_types-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       Symbol* s = _value_types-&gt;at(i)._class_name;</span>
<span class="udiff-line-added">+       if (s != NULL) {</span>
<span class="udiff-line-added">+         s-&gt;decrement_refcount();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
    FREE_C_HEAP_ARRAY(char, _source_debug_extension);
  }
  
  void InstanceKlass::set_source_debug_extension(const char* array, int length) {
    if (array == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2604,10 +2753,14 @@</span>
      _source_debug_extension = sde;
    }
  }
  
  const char* InstanceKlass::signature_name() const {
<span class="udiff-line-added">+   return signature_name_of(is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const char* InstanceKlass::signature_name_of(char c) const {</span>
    int hash_len = 0;
    char hash_buf[40];
  
    // If this is an unsafe anonymous class, append a hash to make the name unique
    if (is_unsafe_anonymous()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2620,13 +2773,13 @@</span>
    const char* src = (const char*) (name()-&gt;as_C_string());
    const int src_length = (int)strlen(src);
  
    char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
  
<span class="udiff-line-modified-removed">-   // Add L as type indicator</span>
<span class="udiff-line-modified-added">+   // Add L or Q as type indicator</span>
    int dest_index = 0;
<span class="udiff-line-modified-removed">-   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
<span class="udiff-line-modified-added">+   dest[dest_index++] = c;</span>
  
    // Add the actual class name
    for (int src_index = 0; src_index &lt; src_length; ) {
      dest[dest_index++] = src[src_index++];
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3134,33 +3287,69 @@</span>
  
  static const char* state_names[] = {
    &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
  };
  
<span class="udiff-line-modified-removed">- static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>
<span class="udiff-line-modified-added">+ static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
    for (int i = 0; i &lt; len; i++) {
      intptr_t e = start[i];
      st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="udiff-line-added">+     if (forward_refs[i] != 0) {</span>
<span class="udiff-line-added">+       int from = forward_refs[i];</span>
<span class="udiff-line-added">+       int off = (int) start[from];</span>
<span class="udiff-line-added">+       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="udiff-line-added">+     }</span>
      if (MetaspaceObj::is_valid((Metadata*)e)) {
        st-&gt;print(&quot; &quot;);
        ((Metadata*)e)-&gt;print_value_on(st);
<span class="udiff-line-added">+     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="udiff-line-added">+       address location = self + e;</span>
<span class="udiff-line-added">+       int index = (int)((intptr_t*)location - start);</span>
<span class="udiff-line-added">+       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="udiff-line-added">+       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="udiff-line-added">+         forward_refs[index] = i;</span>
      }
      st-&gt;cr();
    }
  }
  
  static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="udiff-line-modified-removed">-   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="udiff-line-modified-added">+   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template&lt;typename T&gt;</span>
<span class="udiff-line-added">+  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="udiff-line-added">+    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="udiff-line-added">+    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="udiff-line-added">+    if (Verbose || WizardMode) {</span>
<span class="udiff-line-added">+      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="udiff-line-added">+        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+    }</span>
<span class="udiff-line-added">+  }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="udiff-line-added">+   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="udiff-line-added">+   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="udiff-line-added">+   if (Verbose || WizardMode) {</span>
<span class="udiff-line-added">+     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="udiff-line-added">+       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void InstanceKlass::print_on(outputStream* st) const {
    assert(is_klass(), &quot;must be klass&quot;);
    Klass::print_on(st);
  
    st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
    st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
    st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="udiff-line-added">+   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
    st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
    st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
    st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
    st-&gt;print(BULLET&quot;sub:               &quot;);
    Klass* sub = subklass();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3183,30 +3372,18 @@</span>
        st-&gt;cr();
      }
    }
  
    st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="udiff-line-modified-removed">-   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="udiff-line-modified-removed">-   if (Verbose || WizardMode) {</span>
<span class="udiff-line-modified-removed">-     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="udiff-line-removed">-       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="udiff-line-removed">-   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="udiff-line-removed">-   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="udiff-line-removed">-     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="udiff-line-removed">-       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>
    if (default_vtable_indices() != NULL) {
<span class="udiff-line-modified-removed">-     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
<span class="udiff-line-modified-added">+     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
    }
<span class="udiff-line-modified-removed">-   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="udiff-line-modified-removed">-   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="udiff-line-modified-added">+   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
    st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
    if (class_loader_data() != NULL) {
      st-&gt;print(BULLET&quot;class loader data:  &quot;);
      class_loader_data()-&gt;print_value_on(st);
      st-&gt;cr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3258,11 +3435,11 @@</span>
      st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
    }
    st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
    if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
    st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="udiff-line-modified-removed">-   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
<span class="udiff-line-modified-added">+   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
    st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
    FieldPrinter print_static_field(st);
    ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
    st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
    FieldPrinter print_nonstatic_field(st);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3997,5 +4174,10 @@</span>
  
  unsigned char * InstanceKlass::get_cached_class_file_bytes() {
    return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
  }
  #endif
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define THROW_DVT_ERROR(s) \</span>
<span class="udiff-line-added">+   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="udiff-line-added">+       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="udiff-line-added">+       return</span>
</pre>
<center><a href="constantPool.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>