<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
<a name="1" id="anc1"></a><span class="line-added">  37 import com.sun.tools.javac.code.Flags.Flag;</span>
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
<a name="2" id="anc2"></a><span class="line-added">  52 import static com.sun.tools.javac.code.Flags.asFlagSet;</span>
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
<a name="3" id="anc3"></a><span class="line-added">  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;</span>
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
  82     private static final int infixPrecedenceLevels = 10;
  83 
  84     /** Is the parser instantiated to parse a module-info file ?
  85      */
  86     private final boolean parseModuleInfo;
  87 
  88     /** The scanner used for lexical analysis.
  89      */
  90     protected Lexer S;
  91 
  92     /** The factory to be used for abstract syntax tree construction.
  93      */
  94     protected TreeMaker F;
  95 
  96     /** The log to be used for error diagnostics.
  97      */
  98     private Log log;
  99 
 100     /** The Source language setting. */
 101     private Source source;
 102 
 103     /** The Preview language setting. */
 104     private Preview preview;
 105 
 106     /** The name table. */
 107     private Names names;
 108 
 109     /** End position mappings container */
 110     protected final AbstractEndPosTable endPosTable;
 111 
 112     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 113     // the presence of type annotations even though they are not ambiguous
 114     // in the absence of type annotations.  Consider this code:
 115     //   void m(String [] m) { }
 116     //   void m(String ... m) { }
 117     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 118     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 119     // if the next token is ... and in that case parse an ellipsis.  But in
 120     // the presence of type annotations:
 121     //   void m(String @A [] m) { }
 122     //   void m(String @A ... m) { }
 123     // no finite lookahead is enough to determine whether to read array
 124     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 125     // bracketsOpt first reads all the leading annotations and only then
 126     // discovers that it needs to fail.  bracketsOpt needs a way to push
 127     // back the extra annotations that it read.  (But, bracketsOpt should
 128     // not *always* be allowed to push back extra annotations that it finds
 129     // -- in most contexts, any such extra annotation is an error.
 130     //
 131     // The following two variables permit type annotations that have
 132     // already been read to be stored for later use.  Alternate
 133     // implementations are possible but would cause much larger changes to
 134     // the parser.
 135 
 136     /** Type annotations that have already been read but have not yet been used. **/
 137     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 138 
 139     /**
 140      * If the parser notices extra annotations, then it either immediately
 141      * issues an error (if this variable is false) or places the extra
 142      * annotations in variable typeAnnotationsPushedBack (if this variable
 143      * is true).
 144      */
 145     private boolean permitTypeAnnotationsPushBack = false;
 146 
 147     interface ErrorRecoveryAction {
 148         JCTree doRecover(JavacParser parser);
 149     }
 150 
 151     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 152         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 153         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 154     }
 155 
 156     /** Construct a parser from a given scanner, tree factory and log.
 157      */
 158     protected JavacParser(ParserFactory fac,
 159                           Lexer S,
 160                           boolean keepDocComments,
 161                           boolean keepLineMap,
 162                           boolean keepEndPositions) {
 163         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 164 
 165     }
 166     /** Construct a parser from a given scanner, tree factory and log.
 167      */
 168     protected JavacParser(ParserFactory fac,
 169                      Lexer S,
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
<a name="4" id="anc4"></a><span class="line-added"> 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);</span>
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
 193         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 194                 Feature.SEALED_CLASSES.allowedInSource(source);
 195     }
 196 
 197     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 198         return  keepEndPositions
 199                 ? new SimpleEndPosTable(this)
 200                 : new EmptyEndPosTable(this);
 201     }
 202 
 203     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 204         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 205     }
 206 
 207     /** Switch: should we fold strings?
 208      */
 209     boolean allowStringFolding;
 210 
<a name="5" id="anc5"></a><span class="line-added"> 211     /** Switch: should we allow withField operator at source level ?</span>
<span class="line-added"> 212     */</span>
<span class="line-added"> 213     boolean allowWithFieldOperator;</span>
<span class="line-added"> 214 </span>
 215     /** Switch: should we keep docComments?
 216      */
 217     boolean keepDocComments;
 218 
 219     /** Switch: should we keep line table?
 220      */
 221     boolean keepLineMap;
 222 
 223     /** Switch: is &quot;this&quot; allowed as an identifier?
 224      * This is needed to parse receiver types.
 225      */
 226     boolean allowThisIdent;
 227 
 228     /** Switch: is yield statement allowed in this source level?
 229      */
 230     boolean allowYieldStatement;
 231 
 232     /** Switch: are records allowed in this source level?
 233      */
 234     boolean allowRecords;
 235 
 236     /** Switch: are sealed types allowed in this source level?
 237      */
 238     boolean allowSealedTypes;
 239 
 240     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 241      */
 242     JCVariableDecl receiverParam;
 243 
 244     /** When terms are parsed, the mode determines which is expected:
 245      *     mode = EXPR        : an expression
 246      *     mode = TYPE        : a type
 247      *     mode = NOPARAMS    : no parameters allowed for type
 248      *     mode = TYPEARG     : type argument
 249      *     mode |= NOLAMBDA   : lambdas are not allowed
 250      */
 251     protected static final int EXPR = 0x1;
 252     protected static final int TYPE = 0x2;
 253     protected static final int NOPARAMS = 0x4;
 254     protected static final int TYPEARG = 0x8;
 255     protected static final int DIAMOND = 0x10;
 256     protected static final int NOLAMBDA = 0x20;
 257 
 258     protected void selectExprMode() {
 259         mode = (mode &amp; NOLAMBDA) | EXPR;
 260     }
 261 
 262     protected void selectTypeMode() {
 263         mode = (mode &amp; NOLAMBDA) | TYPE;
 264     }
 265 
 266     /** The current mode.
 267      */
 268     protected int mode = 0;
 269 
 270     /** The mode of the term that was parsed last.
 271      */
 272     protected int lastmode = 0;
 273 
 274     /* ---------- token management -------------- */
 275 
 276     protected Token token;
 277 
 278     public Token token() {
 279         return token;
 280     }
 281 
 282     public void nextToken() {
 283         S.nextToken();
 284         token = S.token();
 285     }
 286 
 287     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 288         return peekToken(0, tk);
 289     }
 290 
 291     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 292         return tk.accepts(S.token(lookahead + 1).kind);
 293     }
 294 
 295     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 296         return peekToken(0, tk1, tk2);
 297     }
 298 
 299     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 300         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 301                 tk2.accepts(S.token(lookahead + 2).kind);
 302     }
 303 
 304     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 305         return peekToken(0, tk1, tk2, tk3);
 306     }
 307 
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 309         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 310                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 311                 tk3.accepts(S.token(lookahead + 3).kind);
 312     }
 313 
<a name="6" id="anc6"></a><span class="line-added"> 314     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {</span>
<span class="line-added"> 315         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;</span>
<span class="line-added"> 316                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;</span>
<span class="line-added"> 317                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;</span>
<span class="line-added"> 318                 tk4.accepts(S.token(lookahead + 4).kind);</span>
<span class="line-added"> 319     }</span>
<span class="line-added"> 320 </span>
 321     @SuppressWarnings(&quot;unchecked&quot;)
 322     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 323         return peekToken(0, kinds);
 324     }
 325 
 326     @SuppressWarnings(&quot;unchecked&quot;)
 327     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 328         for (; lookahead &lt; kinds.length ; lookahead++) {
 329             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 330                 return false;
 331             }
 332         }
 333         return true;
 334     }
 335 
 336     /* ---------- error recovery -------------- */
 337 
 338     private JCErroneous errorTree;
 339 
 340     /** Skip forward until a suitable stop token is found.
 341      */
 342     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 343          while (true) {
 344              switch (token.kind) {
 345                 case SEMI:
 346                     nextToken();
 347                     return;
 348                 case PUBLIC:
 349                 case FINAL:
 350                 case ABSTRACT:
 351                 case MONKEYS_AT:
 352                 case EOF:
 353                 case CLASS:
 354                 case INTERFACE:
 355                 case ENUM:
 356                     return;
 357                 case IMPORT:
 358                     if (stopAtImport)
 359                         return;
 360                     break;
 361                 case LBRACE:
 362                 case RBRACE:
 363                 case PRIVATE:
 364                 case PROTECTED:
 365                 case STATIC:
 366                 case TRANSIENT:
 367                 case NATIVE:
 368                 case VOLATILE:
 369                 case SYNCHRONIZED:
 370                 case STRICTFP:
 371                 case LT:
 372                 case BYTE:
 373                 case SHORT:
 374                 case CHAR:
 375                 case INT:
 376                 case LONG:
 377                 case FLOAT:
 378                 case DOUBLE:
 379                 case BOOLEAN:
 380                 case VOID:
 381                     if (stopAtMemberDecl)
 382                         return;
 383                     break;
 384                 case UNDERSCORE:
 385                 case IDENTIFIER:
 386                    if (stopAtIdentifier)
 387                         return;
 388                     break;
 389                 case CASE:
 390                 case DEFAULT:
 391                 case IF:
 392                 case FOR:
 393                 case WHILE:
 394                 case DO:
 395                 case TRY:
 396                 case SWITCH:
 397                 case RETURN:
 398                 case THROW:
 399                 case BREAK:
 400                 case CONTINUE:
 401                 case ELSE:
 402                 case FINALLY:
 403                 case CATCH:
 404                 case THIS:
 405                 case SUPER:
 406                 case NEW:
 407                     if (stopAtStatement)
 408                         return;
 409                     break;
 410                 case ASSERT:
 411                     if (stopAtStatement)
 412                         return;
 413                     break;
 414             }
 415             nextToken();
 416         }
 417     }
 418 
 419     protected JCErroneous syntaxError(int pos, Error errorKey) {
 420         return syntaxError(pos, List.nil(), errorKey);
 421     }
 422 
 423     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 424         setErrorEndPos(pos);
 425         JCErroneous err = F.at(pos).Erroneous(errs);
 426         reportSyntaxError(err, errorKey);
 427         if (errs != null) {
 428             JCTree last = errs.last();
 429             if (last != null)
 430                 storeEnd(last, pos);
 431         }
 432         return toP(err);
 433     }
 434 
 435     private static final int RECOVERY_THRESHOLD = 50;
 436     private int errorPos = Position.NOPOS;
 437     private int count = 0;
 438 
 439     /**
 440      * Report a syntax using the given the position parameter and arguments,
 441      * unless one was already reported at the same position.
 442      */
 443     protected void reportSyntaxError(int pos, Error errorKey) {
 444         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 445         reportSyntaxError(diag, errorKey);
 446     }
 447 
 448     /**
 449      * Report a syntax error using the given DiagnosticPosition object and
 450      * arguments, unless one was already reported at the same position.
 451      */
 452     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 453         int pos = diagPos.getPreferredPosition();
 454         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 455             if (token.kind == EOF) {
 456                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 457             } else {
 458                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 459             }
 460         }
 461         S.errPos(pos);
 462         if (token.pos == errorPos) {
 463             //check for a possible infinite loop in parsing:
 464             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 465         } else {
 466             count = 0;
 467             errorPos = token.pos;
 468         }
 469     }
 470 
 471     /** If next input token matches given token, skip it, otherwise report
 472      *  an error.
 473      */
 474     public void accept(TokenKind tk) {
 475         accept(tk, Errors::Expected);
 476     }
 477 
 478     /** If next input token matches given token, skip it, otherwise report
 479      *  an error.
 480      */
 481     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 482         if (token.kind == tk) {
 483             nextToken();
 484         } else {
 485             setErrorEndPos(token.pos);
 486             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 487         }
 488     }
 489 
<a name="7" id="anc7"></a><span class="line-added"> 490     /** If next input token matches one of the two given tokens, skip it, otherwise report</span>
<span class="line-added"> 491      *  an error.</span>
<span class="line-added"> 492      *</span>
<span class="line-added"> 493      * @return The actual token kind.</span>
<span class="line-added"> 494      */</span>
<span class="line-added"> 495     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {</span>
<span class="line-added"> 496         TokenKind returnValue = token.kind;</span>
<span class="line-added"> 497         if (token.kind == tk1 || token.kind == tk2) {</span>
<span class="line-added"> 498             nextToken();</span>
<span class="line-added"> 499         } else {</span>
<span class="line-added"> 500             setErrorEndPos(token.pos);</span>
<span class="line-added"> 501             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));</span>
<span class="line-added"> 502         }</span>
<span class="line-added"> 503         return returnValue;</span>
<span class="line-added"> 504     }</span>
<span class="line-added"> 505 </span>
 506     /** Report an illegal start of expression/type error at given position.
 507      */
 508     JCExpression illegal(int pos) {
 509         setErrorEndPos(pos);
 510         if ((mode &amp; EXPR) != 0)
 511             return syntaxError(pos, Errors.IllegalStartOfExpr);
 512         else
 513             return syntaxError(pos, Errors.IllegalStartOfType);
 514 
 515     }
 516 
 517     /** Report an illegal start of expression/type error at current position.
 518      */
 519     JCExpression illegal() {
 520         return illegal(token.pos);
 521     }
 522 
 523     /** Diagnose a modifier flag from the set, if any. */
 524     protected void checkNoMods(long mods) {
 525         if (mods != 0) {
 526             long lowestMod = mods &amp; -mods;
 527             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 528         }
 529     }
 530 
 531 /* ---------- doc comments --------- */
 532 
 533     /** A table to store all documentation comments
 534      *  indexed by the tree nodes they refer to.
 535      *  defined only if option flag keepDocComment is set.
 536      */
 537     private final DocCommentTable docComments;
 538 
 539     /** Make an entry into docComments hashtable,
 540      *  provided flag keepDocComments is set and given doc comment is non-null.
 541      *  @param tree   The tree to be used as index in the hashtable
 542      *  @param dc     The doc comment to associate with the tree, or null.
 543      */
 544     protected void attach(JCTree tree, Comment dc) {
 545         if (keepDocComments &amp;&amp; dc != null) {
 546 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 547             docComments.putComment(tree, dc);
 548         }
 549     }
 550 
 551 /* -------- source positions ------- */
 552 
 553     protected void setErrorEndPos(int errPos) {
 554         endPosTable.setErrorEndPos(errPos);
 555     }
 556 
 557     protected void storeEnd(JCTree tree, int endpos) {
 558         endPosTable.storeEnd(tree, endpos);
 559     }
 560 
 561     protected &lt;T extends JCTree&gt; T to(T t) {
 562         return endPosTable.to(t);
 563     }
 564 
 565     protected &lt;T extends JCTree&gt; T toP(T t) {
 566         return endPosTable.toP(t);
 567     }
 568 
 569     /** Get the start position for a tree node.  The start position is
 570      * defined to be the position of the first character of the first
 571      * token of the node&#39;s source text.
 572      * @param tree  The tree node
 573      */
 574     public int getStartPos(JCTree tree) {
 575         return TreeInfo.getStartPos(tree);
 576     }
 577 
 578     /**
 579      * Get the end position for a tree node.  The end position is
 580      * defined to be the position of the last character of the last
 581      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 582      * positions are not generated or the position is otherwise not
 583      * found.
 584      * @param tree  The tree node
 585      */
 586     public int getEndPos(JCTree tree) {
 587         return endPosTable.getEndPos(tree);
 588     }
 589 
 590 
 591 
 592 /* ---------- parsing -------------- */
 593 
 594     /**
 595      * Ident = IDENTIFIER
 596      */
 597     public Name ident() {
 598         return ident(false);
 599     }
 600 
 601     protected Name ident(boolean advanceOnErrors) {
 602         if (token.kind == IDENTIFIER) {
 603             Name name = token.name();
 604             nextToken();
 605             return name;
 606         } else if (token.kind == ASSERT) {
 607             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 608             nextToken();
 609             return names.error;
 610         } else if (token.kind == ENUM) {
 611             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 612             nextToken();
 613             return names.error;
 614         } else if (token.kind == THIS) {
 615             if (allowThisIdent) {
 616                 // Make sure we&#39;re using a supported source version.
 617                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 618                 Name name = token.name();
 619                 nextToken();
 620                 return name;
 621             } else {
 622                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 623                 nextToken();
 624                 return names.error;
 625             }
 626         } else if (token.kind == UNDERSCORE) {
 627             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 628                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 629             } else {
 630                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 631             }
 632             Name name = token.name();
 633             nextToken();
 634             return name;
 635         } else {
 636             accept(IDENTIFIER);
 637             if (advanceOnErrors) {
 638                 nextToken();
 639             }
 640             return names.error;
 641         }
 642     }
 643 
 644     /**
 645      * Qualident = Ident { DOT [Annotations] Ident }
 646      */
 647     public JCExpression qualident(boolean allowAnnos) {
 648         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 649         while (token.kind == DOT) {
 650             int pos = token.pos;
 651             nextToken();
 652             List&lt;JCAnnotation&gt; tyannos = null;
 653             if (allowAnnos) {
 654                 tyannos = typeAnnotationsOpt();
 655             }
 656             t = toP(F.at(pos).Select(t, ident()));
 657             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 658                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 659             }
 660         }
 661         return t;
 662     }
 663 
 664     JCExpression literal(Name prefix) {
 665         return literal(prefix, token.pos);
 666     }
 667 
 668     /**
 669      * Literal =
 670      *     INTLITERAL
 671      *   | LONGLITERAL
 672      *   | FLOATLITERAL
 673      *   | DOUBLELITERAL
 674      *   | CHARLITERAL
 675      *   | STRINGLITERAL
 676      *   | TRUE
 677      *   | FALSE
 678      *   | NULL
 679      */
 680     JCExpression literal(Name prefix, int pos) {
 681         JCExpression t = errorTree;
 682         switch (token.kind) {
 683         case INTLITERAL:
 684             try {
 685                 t = F.at(pos).Literal(
 686                     TypeTag.INT,
 687                     Convert.string2int(strval(prefix), token.radix()));
 688             } catch (NumberFormatException ex) {
 689                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 690             }
 691             break;
 692         case LONGLITERAL:
 693             try {
 694                 t = F.at(pos).Literal(
 695                     TypeTag.LONG,
 696                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 697             } catch (NumberFormatException ex) {
 698                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 699             }
 700             break;
 701         case FLOATLITERAL: {
 702             String proper = token.radix() == 16 ?
 703                     (&quot;0x&quot;+ token.stringVal()) :
 704                     token.stringVal();
 705             Float n;
 706             try {
 707                 n = Float.valueOf(proper);
 708             } catch (NumberFormatException ex) {
 709                 // error already reported in scanner
 710                 n = Float.NaN;
 711             }
 712             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 713                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 714             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 715                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 716             else
 717                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 718             break;
 719         }
 720         case DOUBLELITERAL: {
 721             String proper = token.radix() == 16 ?
 722                     (&quot;0x&quot;+ token.stringVal()) :
 723                     token.stringVal();
 724             Double n;
 725             try {
 726                 n = Double.valueOf(proper);
 727             } catch (NumberFormatException ex) {
 728                 // error already reported in scanner
 729                 n = Double.NaN;
 730             }
 731             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 732                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 733             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 734                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 735             else
 736                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 737             break;
 738         }
 739         case CHARLITERAL:
 740             t = F.at(pos).Literal(
 741                 TypeTag.CHAR,
 742                 token.stringVal().charAt(0) + 0);
 743             break;
 744         case STRINGLITERAL:
 745             t = F.at(pos).Literal(
 746                 TypeTag.CLASS,
 747                 token.stringVal());
 748             break;
 749         case TRUE: case FALSE:
 750             t = F.at(pos).Literal(
 751                 TypeTag.BOOLEAN,
 752                 (token.kind == TRUE ? 1 : 0));
 753             break;
 754         case NULL:
 755             t = F.at(pos).Literal(
 756                 TypeTag.BOT,
 757                 null);
 758             break;
 759         default:
 760             Assert.error();
 761         }
 762         if (t == errorTree)
 763             t = F.at(pos).Erroneous();
 764         storeEnd(t, token.endPos);
 765         nextToken();
 766         return t;
 767     }
 768     //where
 769         boolean isZero(String s) {
 770             char[] cs = s.toCharArray();
 771             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 772             int i = ((base==16) ? 2 : 0);
 773             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 774             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 775         }
 776 
 777         String strval(Name prefix) {
 778             String s = token.stringVal();
 779             return prefix.isEmpty() ? s : prefix + s;
 780         }
 781 
 782     /** terms can be either expressions or types.
 783      */
 784     public JCExpression parseExpression() {
 785         return term(EXPR);
 786     }
 787 
 788     /**
 789      * parses (optional) type annotations followed by a type. If the
 790      * annotations are present before the type and are not consumed during array
 791      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 792      * these annotations and the underlying type. Otherwise, it returns the
 793      * underlying type.
 794      *
 795      * &lt;p&gt;
 796      *
 797      * Note that this method sets {@code mode} to {@code TYPE} first, before
 798      * parsing annotations.
 799      */
 800     public JCExpression parseType() {
 801         return parseType(false);
 802     }
 803 
 804     public JCExpression parseType(boolean allowVar) {
 805         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 806         return parseType(allowVar, annotations);
 807     }
 808 
 809     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 810         JCExpression result = unannotatedType(allowVar);
 811 
 812         if (annotations.nonEmpty()) {
 813             result = insertAnnotationsToMostInner(result, annotations, false);
 814         }
 815 
 816         return result;
 817     }
 818 
 819     public JCExpression unannotatedType(boolean allowVar) {
 820         JCExpression result = term(TYPE);
 821         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 822 
 823         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 824             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 825         }
 826 
 827         return result;
 828     }
 829 
 830 
 831 
 832     protected JCExpression term(int newmode) {
 833         int prevmode = mode;
 834         mode = newmode;
 835         JCExpression t = term();
 836         lastmode = mode;
 837         mode = prevmode;
 838         return t;
 839     }
 840 
 841     /**
 842      *  {@literal
 843      *  Expression = Expression1 [ExpressionRest]
 844      *  ExpressionRest = [AssignmentOperator Expression1]
 845      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 846      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 847      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 848      *  Type = Type1
 849      *  TypeNoParams = TypeNoParams1
 850      *  StatementExpression = Expression
 851      *  ConstantExpression = Expression
 852      *  }
 853      */
 854     JCExpression term() {
 855         JCExpression t = term1();
 856         if ((mode &amp; EXPR) != 0 &amp;&amp;
 857             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 858             return termRest(t);
 859         else
 860             return t;
 861     }
 862 
 863     JCExpression termRest(JCExpression t) {
 864         switch (token.kind) {
 865         case EQ: {
 866             int pos = token.pos;
 867             nextToken();
 868             selectExprMode();
 869             JCExpression t1 = term();
 870             return toP(F.at(pos).Assign(t, t1));
 871         }
 872         case PLUSEQ:
 873         case SUBEQ:
 874         case STAREQ:
 875         case SLASHEQ:
 876         case PERCENTEQ:
 877         case AMPEQ:
 878         case BAREQ:
 879         case CARETEQ:
 880         case LTLTEQ:
 881         case GTGTEQ:
 882         case GTGTGTEQ:
 883             int pos = token.pos;
 884             TokenKind tk = token.kind;
 885             nextToken();
 886             selectExprMode();
 887             JCExpression t1 = term();
 888             return F.at(pos).Assignop(optag(tk), t, t1);
 889         default:
 890             return t;
 891         }
 892     }
 893 
 894     /** Expression1   = Expression2 [Expression1Rest]
 895      *  Type1         = Type2
 896      *  TypeNoParams1 = TypeNoParams2
 897      */
 898     JCExpression term1() {
 899         JCExpression t = term2();
 900         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 901             selectExprMode();
 902             return term1Rest(t);
 903         } else {
 904             return t;
 905         }
 906     }
 907 
 908     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 909      */
 910     JCExpression term1Rest(JCExpression t) {
 911         if (token.kind == QUES) {
 912             int pos = token.pos;
 913             nextToken();
 914             JCExpression t1 = term();
 915             accept(COLON);
 916             JCExpression t2 = term1();
 917             return F.at(pos).Conditional(t, t1, t2);
 918         } else {
 919             return t;
 920         }
 921     }
 922 
 923     /** Expression2   = Expression3 [Expression2Rest]
 924      *  Type2         = Type3
 925      *  TypeNoParams2 = TypeNoParams3
 926      */
 927     JCExpression term2() {
 928         JCExpression t = term3();
 929         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 930             selectExprMode();
 931             return term2Rest(t, TreeInfo.orPrec);
 932         } else {
 933             return t;
 934         }
 935     }
 936 
 937     /*  Expression2Rest = {infixop Expression3}
 938      *                  | Expression3 instanceof Type
 939      *                  | Expression3 instanceof Pattern
 940      *  infixop         = &quot;||&quot;
 941      *                  | &quot;&amp;&amp;&quot;
 942      *                  | &quot;|&quot;
 943      *                  | &quot;^&quot;
 944      *                  | &quot;&amp;&quot;
 945      *                  | &quot;==&quot; | &quot;!=&quot;
 946      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 947      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 948      *                  | &quot;+&quot; | &quot;-&quot;
 949      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 950      */
 951     JCExpression term2Rest(JCExpression t, int minprec) {
 952         JCExpression[] odStack = newOdStack();
 953         Token[] opStack = newOpStack();
 954 
 955         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 956         int top = 0;
 957         odStack[0] = t;
 958         int startPos = token.pos;
 959         Token topOp = Tokens.DUMMY;
 960         while (prec(token.kind) &gt;= minprec) {
 961             opStack[top] = topOp;
 962 
 963             if (token.kind == INSTANCEOF) {
 964                 int pos = token.pos;
 965                 nextToken();
 966                 JCTree pattern = parseType();
 967                 if (token.kind == IDENTIFIER) {
 968                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 969                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 970                 }
 971                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 972             } else {
 973                 topOp = token;
 974                 nextToken();
 975                 top++;
 976                 odStack[top] = term3();
 977             }
 978             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 979                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 980                 top--;
 981                 topOp = opStack[top];
 982             }
 983         }
 984         Assert.check(top == 0);
 985         t = odStack[0];
 986 
 987         if (t.hasTag(JCTree.Tag.PLUS)) {
 988             t = foldStrings(t);
 989         }
 990 
 991         odStackSupply.add(odStack);
 992         opStackSupply.add(opStack);
 993         return t;
 994     }
 995     //where
 996         /** If tree is a concatenation of string literals, replace it
 997          *  by a single literal representing the concatenated string.
 998          */
 999         protected JCExpression foldStrings(JCExpression tree) {
1000             if (!allowStringFolding)
1001                 return tree;
1002             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1003             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1004             boolean needsFolding = false;
1005             JCExpression curr = tree;
1006             while (true) {
1007                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1008                     JCBinary op = (JCBinary)curr;
1009                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1010                     curr = op.lhs;
1011                 } else {
1012                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1013                     break; //last one!
1014                 }
1015             }
1016             if (needsFolding) {
1017                 List&lt;JCExpression&gt; ops = opStack.toList();
1018                 JCExpression res = ops.head;
1019                 for (JCExpression op : ops.tail) {
1020                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1021                     storeEnd(res, getEndPos(op));
1022                 }
1023                 return res;
1024             } else {
1025                 return tree;
1026             }
1027         }
1028 
1029         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1030                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1031             JCLiteral str = stringLiteral(tree);
1032             if (str != null) {
1033                 litBuf.prepend(str);
1034                 return last &amp;&amp; merge(litBuf, opStack);
1035             } else {
1036                 boolean res = merge(litBuf, opStack);
1037                 litBuf.clear();
1038                 opStack.prepend(tree);
1039                 return res;
1040             }
1041         }
1042 
1043         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1044             if (litBuf.isEmpty()) {
1045                 return false;
1046             } else if (litBuf.size() == 1) {
1047                 opStack.prepend(litBuf.first());
1048                 return false;
1049             } else {
1050                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1051                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1052                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1053                 opStack.prepend(t);
1054                 return true;
1055             }
1056         }
1057 
1058         private JCLiteral stringLiteral(JCTree tree) {
1059             if (tree.hasTag(LITERAL)) {
1060                 JCLiteral lit = (JCLiteral)tree;
1061                 if (lit.typetag == TypeTag.CLASS) {
1062                     return lit;
1063                 }
1064             }
1065             return null;
1066         }
1067 
1068 
1069         /** optimization: To save allocating a new operand/operator stack
1070          *  for every binary operation, we use supplys.
1071          */
1072         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1073         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1074 
1075         private JCExpression[] newOdStack() {
1076             if (odStackSupply.isEmpty())
1077                 return new JCExpression[infixPrecedenceLevels + 1];
1078             return odStackSupply.remove(odStackSupply.size() - 1);
1079         }
1080 
1081         private Token[] newOpStack() {
1082             if (opStackSupply.isEmpty())
1083                 return new Token[infixPrecedenceLevels + 1];
1084             return opStackSupply.remove(opStackSupply.size() - 1);
1085         }
1086 
1087     /**
1088      *  Expression3    = PrefixOp Expression3
1089      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1090      *                 | Primary {Selector} {PostfixOp}
1091      *
1092      *  {@literal
1093      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1094      *                 | Literal
1095      *                 | [TypeArguments] THIS [Arguments]
1096      *                 | [TypeArguments] SUPER SuperSuffix
1097      *                 | NEW [TypeArguments] Creator
1098      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1099      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1100      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1101      *                 | Expression3 MemberReferenceSuffix
1102      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1103      *                   | Arguments
1104      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1105      *                   ]
1106      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1107      *  }
1108      *
1109      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1110      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1111      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1112      *                 | BasicType
1113      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1114      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1115      *                 | &quot;.&quot; THIS
1116      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1117      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1118      *                 | &quot;[&quot; Expression &quot;]&quot;
1119      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1120      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1121      */
1122     protected JCExpression term3() {
1123         int pos = token.pos;
1124         JCExpression t;
1125         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1126         switch (token.kind) {
1127         case QUES:
1128             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1129                 selectTypeMode();
1130                 return typeArgument();
1131             } else
1132                 return illegal();
1133         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1134             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1135                 TokenKind tk = token.kind;
1136                 nextToken();
1137                 selectExprMode();
1138                 if (tk == SUB &amp;&amp;
1139                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1140                     token.radix() == 10) {
1141                     selectExprMode();
1142                     t = literal(names.hyphen, pos);
1143                 } else {
1144                     t = term3();
1145                     return F.at(pos).Unary(unoptag(tk), t);
1146                 }
1147             } else return illegal();
1148             break;
<a name="8" id="anc8"></a><span class="line-added">1149         case WITHFIELD:</span>
<span class="line-added">1150             if (!allowWithFieldOperator) {</span>
<span class="line-added">1151                 log.error(pos, Errors.WithFieldOperatorDisallowed);</span>
<span class="line-added">1152             }</span>
<span class="line-added">1153             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {</span>
<span class="line-added">1154                 nextToken();</span>
<span class="line-added">1155                 accept(LPAREN);</span>
<span class="line-added">1156                 mode = EXPR;</span>
<span class="line-added">1157                 t = term();</span>
<span class="line-added">1158                 accept(COMMA);</span>
<span class="line-added">1159                 mode = EXPR;</span>
<span class="line-added">1160                 JCExpression v = term();</span>
<span class="line-added">1161                 accept(RPAREN);</span>
<span class="line-added">1162                 return F.at(pos).WithField(t, v);</span>
<span class="line-added">1163             } else return illegal();</span>
1164         case LPAREN:
1165             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1166                 ParensResult pres = analyzeParens();
1167                 switch (pres) {
1168                     case CAST:
1169                        accept(LPAREN);
1170                        selectTypeMode();
1171                        int pos1 = pos;
1172                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1173                        while (token.kind == AMP) {
1174                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1175                            accept(AMP);
1176                            targets = targets.prepend(parseType());
1177                        }
1178                        if (targets.length() &gt; 1) {
1179                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1180                        }
1181                        accept(RPAREN);
1182                        selectExprMode();
1183                        JCExpression t1 = term3();
1184                        return F.at(pos).TypeCast(t, t1);
1185                     case IMPLICIT_LAMBDA:
1186                     case EXPLICIT_LAMBDA:
1187                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1188                         break;
1189                     default: //PARENS
1190                         accept(LPAREN);
1191                         selectExprMode();
1192                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1193                         accept(RPAREN);
1194                         t = toP(F.at(pos).Parens(t));
1195                         break;
1196                 }
1197             } else {
1198                 return illegal();
1199             }
1200             break;
1201         case THIS:
1202             if ((mode &amp; EXPR) != 0) {
1203                 selectExprMode();
1204                 t = to(F.at(pos).Ident(names._this));
1205                 nextToken();
1206                 if (typeArgs == null)
1207                     t = argumentsOpt(null, t);
1208                 else
1209                     t = arguments(typeArgs, t);
1210                 typeArgs = null;
1211             } else return illegal();
1212             break;
1213         case SUPER:
1214             if ((mode &amp; EXPR) != 0) {
1215                 selectExprMode();
1216                 t = to(F.at(pos).Ident(names._super));
1217                 t = superSuffix(typeArgs, t);
1218                 typeArgs = null;
1219             } else return illegal();
1220             break;
1221         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1222         case CHARLITERAL: case STRINGLITERAL:
1223         case TRUE: case FALSE: case NULL:
1224             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1225                 selectExprMode();
1226                 t = literal(names.empty);
1227             } else return illegal();
1228             break;
1229         case NEW:
1230             if (typeArgs != null) return illegal();
1231             if ((mode &amp; EXPR) != 0) {
1232                 selectExprMode();
1233                 nextToken();
1234                 if (token.kind == LT) typeArgs = typeArguments(false);
1235                 t = creator(pos, typeArgs);
1236                 typeArgs = null;
1237             } else return illegal();
1238             break;
1239         case MONKEYS_AT:
1240             // Only annotated cast types and method references are valid
1241             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1242             if (typeAnnos.isEmpty()) {
1243                 // else there would be no &#39;@&#39;
1244                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1245             }
1246 
1247             JCExpression expr = term3();
1248 
1249             if ((mode &amp; TYPE) == 0) {
1250                 // Type annotations on class literals no longer legal
1251                 switch (expr.getTag()) {
1252                 case REFERENCE: {
1253                     JCMemberReference mref = (JCMemberReference) expr;
1254                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1255                     t = mref;
1256                     break;
1257                 }
1258                 case SELECT: {
1259                     JCFieldAccess sel = (JCFieldAccess) expr;
1260 
1261                     if (sel.name != names._class) {
1262                         return illegal();
1263                     } else {
1264                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1265                         return expr;
1266                     }
1267                 }
1268                 default:
1269                     return illegal(typeAnnos.head.pos);
1270                 }
1271 
1272             } else {
1273                 // Type annotations targeting a cast
1274                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1275             }
1276             break;
1277         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1278             if (typeArgs != null) return illegal();
1279             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1280                 t = lambdaExpressionOrStatement(false, false, pos);
1281             } else {
1282                 t = toP(F.at(token.pos).Ident(ident()));
1283                 loop: while (true) {
1284                     pos = token.pos;
1285                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1286 
1287                     // need to report an error later if LBRACKET is for array
1288                     // index access rather than array creation level
1289                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1290                         return illegal(annos.head.pos);
1291 
1292                     switch (token.kind) {
1293                     case LBRACKET:
1294                         nextToken();
1295                         if (token.kind == RBRACKET) {
1296                             nextToken();
1297                             t = bracketsOpt(t);
1298                             t = toP(F.at(pos).TypeArray(t));
1299                             if (annos.nonEmpty()) {
1300                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1301                             }
1302                             t = bracketsSuffix(t);
1303                         } else {
1304                             if ((mode &amp; EXPR) != 0) {
1305                                 selectExprMode();
1306                                 JCExpression t1 = term();
1307                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1308                                 t = to(F.at(pos).Indexed(t, t1));
1309                             }
1310                             accept(RBRACKET);
1311                         }
1312                         break loop;
1313                     case LPAREN:
1314                         if ((mode &amp; EXPR) != 0) {
1315                             selectExprMode();
1316                             t = arguments(typeArgs, t);
1317                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1318                             typeArgs = null;
1319                         }
1320                         break loop;
1321                     case DOT:
1322                         nextToken();
1323                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1324                             return illegal();
1325                         }
1326                         int oldmode = mode;
1327                         mode &amp;= ~NOPARAMS;
1328                         typeArgs = typeArgumentsOpt(EXPR);
1329                         mode = oldmode;
1330                         if ((mode &amp; EXPR) != 0) {
1331                             switch (token.kind) {
<a name="9" id="anc9"></a><span class="line-added">1332                             case DEFAULT:</span>
<span class="line-added">1333                                 if (typeArgs != null) return illegal();</span>
<span class="line-added">1334                                 selectExprMode();</span>
<span class="line-added">1335                                 t = to(F.at(pos).Select(t, names._default));</span>
<span class="line-added">1336                                 nextToken();</span>
<span class="line-added">1337                                 break loop;</span>
1338                             case CLASS:
1339                                 if (typeArgs != null) return illegal();
1340                                 selectExprMode();
1341                                 t = to(F.at(pos).Select(t, names._class));
1342                                 nextToken();
1343                                 break loop;
1344                             case THIS:
1345                                 if (typeArgs != null) return illegal();
1346                                 selectExprMode();
1347                                 t = to(F.at(pos).Select(t, names._this));
1348                                 nextToken();
1349                                 break loop;
1350                             case SUPER:
1351                                 selectExprMode();
1352                                 t = to(F.at(pos).Select(t, names._super));
1353                                 t = superSuffix(typeArgs, t);
1354                                 typeArgs = null;
1355                                 break loop;
1356                             case NEW:
1357                                 if (typeArgs != null) return illegal();
1358                                 selectExprMode();
1359                                 int pos1 = token.pos;
1360                                 nextToken();
1361                                 if (token.kind == LT) typeArgs = typeArguments(false);
1362                                 t = innerCreator(pos1, typeArgs, t);
1363                                 typeArgs = null;
1364                                 break loop;
1365                             }
1366                         }
1367 
1368                         List&lt;JCAnnotation&gt; tyannos = null;
1369                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1370                             tyannos = typeAnnotationsOpt();
1371                         }
1372                         // typeArgs saved for next loop iteration.
1373                         t = toP(F.at(pos).Select(t, ident()));
1374                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1375                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1376                         }
1377                         break;
1378                     case ELLIPSIS:
1379                         if (this.permitTypeAnnotationsPushBack) {
1380                             this.typeAnnotationsPushedBack = annos;
1381                         } else if (annos.nonEmpty()) {
1382                             // Don&#39;t return here -- error recovery attempt
1383                             illegal(annos.head.pos);
1384                         }
1385                         break loop;
1386                     case LT:
<a name="10" id="anc10"></a><span class="line-modified">1387                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {</span>
<span class="line-modified">1388                             //this is either an unbound method reference whose qualifier</span>
<span class="line-modified">1389                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of</span>
<span class="line-added">1390                             //the form ValueType&lt;S&gt;.default</span>
1391                             int pos1 = token.pos;
1392                             accept(LT);
1393                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1394                             args.append(typeArgument());
1395                             while (token.kind == COMMA) {
1396                                 nextToken();
1397                                 args.append(typeArgument());
1398                             }
1399                             accept(GT);
1400                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1401                             while (token.kind == DOT) {
1402                                 nextToken();
<a name="11" id="anc11"></a><span class="line-added">1403                                 if (token.kind == DEFAULT) {</span>
<span class="line-added">1404                                     t =  toP(F.at(token.pos).Select(t, names._default));</span>
<span class="line-added">1405                                     nextToken();</span>
<span class="line-added">1406                                     selectExprMode();</span>
<span class="line-added">1407                                     return term3Rest(t, typeArgs);</span>
<span class="line-added">1408                                 }</span>
1409                                 selectTypeMode();
1410                                 t = toP(F.at(token.pos).Select(t, ident()));
1411                                 t = typeArgumentsOpt(t);
1412                             }
1413                             t = bracketsOpt(t);
1414                             if (token.kind != COLCOL) {
1415                                 //method reference expected here
1416                                 t = illegal();
1417                             }
1418                             selectExprMode();
1419                             return term3Rest(t, typeArgs);
1420                         }
1421                         break loop;
1422                     default:
1423                         break loop;
1424                     }
1425                 }
1426             }
1427             if (typeArgs != null) illegal();
1428             t = typeArgumentsOpt(t);
1429             break;
1430         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1431         case DOUBLE: case BOOLEAN:
1432             if (typeArgs != null) illegal();
1433             t = bracketsSuffix(bracketsOpt(basicType()));
1434             break;
1435         case VOID:
1436             if (typeArgs != null) illegal();
1437             if ((mode &amp; EXPR) != 0) {
1438                 nextToken();
1439                 if (token.kind == DOT) {
1440                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1441                     t = bracketsSuffix(ti);
1442                 } else {
1443                     return illegal(pos);
1444                 }
1445             } else {
1446                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1447                 // a void type (like other primitive types) to the next phase.
1448                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1449                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1450                 nextToken();
1451                 return ti;
1452                 //return illegal();
1453             }
1454             break;
1455         case SWITCH:
1456             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1457             allowYieldStatement = true;
1458             int switchPos = token.pos;
1459             nextToken();
1460             JCExpression selector = parExpression();
1461             accept(LBRACE);
1462             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1463             while (true) {
1464                 pos = token.pos;
1465                 switch (token.kind) {
1466                 case CASE:
1467                 case DEFAULT:
1468                     cases.appendList(switchExpressionStatementGroup());
1469                     break;
1470                 case RBRACE: case EOF:
1471                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1472                                                                                cases.toList()));
1473                     e.endpos = token.pos;
1474                     accept(RBRACE);
1475                     return e;
1476                 default:
1477                     nextToken(); // to ensure progress
1478                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1479                 }
1480             }
1481         default:
1482             return illegal();
1483         }
1484         return term3Rest(t, typeArgs);
1485     }
1486 
1487     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1488         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1489         int casePos = token.pos;
1490         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1491 
1492         if (token.kind == DEFAULT) {
1493             nextToken();
1494         } else {
1495             accept(CASE);
1496             while (true) {
1497                 pats.append(term(EXPR | NOLAMBDA));
1498                 if (token.kind != COMMA) break;
1499                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1500                 nextToken();
1501             };
1502         }
1503         List&lt;JCStatement&gt; stats = null;
1504         JCTree body = null;
1505         CaseTree.CaseKind kind;
1506         switch (token.kind) {
1507             case ARROW:
1508                 checkSourceLevel(Feature.SWITCH_RULE);
1509                 nextToken();
1510                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1511                     stats = List.of(parseStatement());
1512                     body = stats.head;
1513                     kind = JCCase.RULE;
1514                 } else {
1515                     JCExpression value = parseExpression();
1516                     stats = List.of(to(F.at(value).Yield(value)));
1517                     body = value;
1518                     kind = JCCase.RULE;
1519                     accept(SEMI);
1520                 }
1521                 break;
1522             default:
1523                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1524                 stats = blockStatements();
1525                 kind = JCCase.STATEMENT;
1526                 break;
1527         }
1528         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1529         return caseExprs.toList();
1530     }
1531 
1532     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1533         if (typeArgs != null) illegal();
1534         while (true) {
1535             int pos1 = token.pos;
1536             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1537 
1538             if (token.kind == LBRACKET) {
1539                 nextToken();
1540                 if ((mode &amp; TYPE) != 0) {
1541                     int oldmode = mode;
1542                     selectTypeMode();
1543                     if (token.kind == RBRACKET) {
1544                         nextToken();
1545                         t = bracketsOpt(t);
1546                         t = toP(F.at(pos1).TypeArray(t));
1547                         if (token.kind == COLCOL) {
1548                             selectExprMode();
1549                             continue;
1550                         }
1551                         if (annos.nonEmpty()) {
1552                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1553                         }
1554                         return t;
1555                     }
1556                     mode = oldmode;
1557                 }
1558                 if ((mode &amp; EXPR) != 0) {
1559                     selectExprMode();
1560                     JCExpression t1 = term();
1561                     t = to(F.at(pos1).Indexed(t, t1));
1562                 }
1563                 accept(RBRACKET);
1564             } else if (token.kind == DOT) {
1565                 nextToken();
1566                 typeArgs = typeArgumentsOpt(EXPR);
1567                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1568                     selectExprMode();
1569                     t = to(F.at(pos1).Select(t, names._super));
1570                     nextToken();
1571                     t = arguments(typeArgs, t);
1572                     typeArgs = null;
<a name="12" id="anc12"></a><span class="line-modified">1573                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {</span>
1574                     if (typeArgs != null) return illegal();
1575                     selectExprMode();
1576                     int pos2 = token.pos;
1577                     nextToken();
1578                     if (token.kind == LT) typeArgs = typeArguments(false);
1579                     t = innerCreator(pos2, typeArgs, t);
1580                     typeArgs = null;
1581                 } else {
1582                     List&lt;JCAnnotation&gt; tyannos = null;
1583                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1584                         // is the mode check needed?
1585                         tyannos = typeAnnotationsOpt();
1586                     }
1587                     t = toP(F.at(pos1).Select(t, ident(true)));
1588                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1589                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1590                     }
1591                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1592                     typeArgs = null;
1593                 }
1594             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1595                 selectExprMode();
1596                 if (typeArgs != null) return illegal();
1597                 accept(COLCOL);
1598                 t = memberReferenceSuffix(pos1, t);
1599             } else {
1600                 if (!annos.isEmpty()) {
1601                     if (permitTypeAnnotationsPushBack)
1602                         typeAnnotationsPushedBack = annos;
1603                     else
1604                         return illegal(annos.head.pos);
1605                 }
1606                 break;
1607             }
1608         }
1609         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1610             selectExprMode();
1611             t = to(F.at(token.pos).Unary(
1612                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1613             nextToken();
1614         }
1615         return toP(t);
1616     }
1617 
1618     /**
1619      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<a name="13" id="anc13"></a><span class="line-modified">1620      * method reference or a default value creation that uses a parameterized type</span>
<span class="line-added">1621      * or a binary expression. To disambiguate, look for a</span>
1622      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1623      */
1624     @SuppressWarnings(&quot;fallthrough&quot;)
<a name="14" id="anc14"></a><span class="line-modified">1625     boolean isParameterizedTypePrefix() {</span>
1626         int pos = 0, depth = 0;
1627         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1628             switch (t.kind) {
1629                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1630                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1631                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1632                 case DOUBLE: case BOOLEAN: case CHAR:
1633                 case MONKEYS_AT:
1634                     break;
1635 
1636                 case LPAREN:
1637                     // skip annotation values
1638                     int nesting = 0;
1639                     for (; ; pos++) {
1640                         TokenKind tk2 = S.token(pos).kind;
1641                         switch (tk2) {
1642                             case EOF:
1643                                 return false;
1644                             case LPAREN:
1645                                 nesting++;
1646                                 break;
1647                             case RPAREN:
1648                                 nesting--;
1649                                 if (nesting == 0) {
1650                                     continue outer;
1651                                 }
1652                                 break;
1653                         }
1654                     }
1655 
1656                 case LT:
1657                     depth++; break;
1658                 case GTGTGT:
1659                     depth--;
1660                 case GTGT:
1661                     depth--;
1662                 case GT:
1663                     depth--;
1664                     if (depth == 0) {
1665                         TokenKind nextKind = S.token(pos + 1).kind;
1666                         return
1667                             nextKind == TokenKind.DOT ||
1668                             nextKind == TokenKind.LBRACKET ||
1669                             nextKind == TokenKind.COLCOL;
1670                     }
1671                     break;
1672                 default:
1673                     return false;
1674             }
1675         }
1676     }
1677 
1678     /**
1679      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1680      * method reference or a binary expression. To disambiguate, look for a
1681      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1682      */
1683     @SuppressWarnings(&quot;fallthrough&quot;)
1684     ParensResult analyzeParens() {
1685         int depth = 0;
1686         boolean type = false;
1687         ParensResult defaultResult = ParensResult.PARENS;
1688         outer: for (int lookahead = 0; ; lookahead++) {
1689             TokenKind tk = S.token(lookahead).kind;
1690             switch (tk) {
1691                 case COMMA:
1692                     type = true;
1693                 case EXTENDS: case SUPER: case DOT: case AMP:
1694                     //skip
1695                     break;
1696                 case QUES:
1697                     if (peekToken(lookahead, EXTENDS) ||
1698                             peekToken(lookahead, SUPER)) {
1699                         //wildcards
1700                         type = true;
1701                     }
1702                     break;
1703                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1704                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1705                     if (peekToken(lookahead, RPAREN)) {
1706                         //Type, &#39;)&#39; -&gt; cast
1707                         return ParensResult.CAST;
1708                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1709                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1710                         return ParensResult.EXPLICIT_LAMBDA;
1711                     }
1712                     break;
1713                 case LPAREN:
1714                     if (lookahead != 0) {
1715                         // &#39;(&#39; in a non-starting position -&gt; parens
1716                         return ParensResult.PARENS;
1717                     } else if (peekToken(lookahead, RPAREN)) {
1718                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1719                         return ParensResult.EXPLICIT_LAMBDA;
1720                     }
1721                     break;
1722                 case RPAREN:
1723                     // if we have seen something that looks like a type,
1724                     // then it&#39;s a cast expression
1725                     if (type) return ParensResult.CAST;
1726                     // otherwise, disambiguate cast vs. parenthesized expression
1727                     // based on subsequent token.
1728                     switch (S.token(lookahead + 1).kind) {
1729                         /*case PLUSPLUS: case SUBSUB: */
1730                         case BANG: case TILDE:
1731                         case LPAREN: case THIS: case SUPER:
1732                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1733                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1734                         case TRUE: case FALSE: case NULL:
1735                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1736                         case SWITCH:
1737                         case BYTE: case SHORT: case CHAR: case INT:
1738                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1739                             return ParensResult.CAST;
1740                         default:
1741                             return defaultResult;
1742                     }
1743                 case UNDERSCORE:
1744                 case ASSERT:
1745                 case ENUM:
1746                 case IDENTIFIER:
<a name="15" id="anc15"></a><span class="line-modified">1747                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {</span>
<span class="line-modified">1748                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</span>
1749                         return ParensResult.EXPLICIT_LAMBDA;
1750                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1751                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1752                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1753                                                       : ParensResult.PARENS;
1754                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1755                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1756                     }
1757                     type = false;
1758                     break;
1759                 case FINAL:
1760                 case ELLIPSIS:
1761                     //those can only appear in explicit lambdas
1762                     return ParensResult.EXPLICIT_LAMBDA;
1763                 case MONKEYS_AT:
1764                     type = true;
1765                     lookahead += 1; //skip &#39;@&#39;
1766                     while (peekToken(lookahead, DOT)) {
1767                         lookahead += 2;
1768                     }
1769                     if (peekToken(lookahead, LPAREN)) {
1770                         lookahead++;
1771                         //skip annotation values
1772                         int nesting = 0;
1773                         for (; ; lookahead++) {
1774                             TokenKind tk2 = S.token(lookahead).kind;
1775                             switch (tk2) {
1776                                 case EOF:
1777                                     return ParensResult.PARENS;
1778                                 case LPAREN:
1779                                     nesting++;
1780                                     break;
1781                                 case RPAREN:
1782                                     nesting--;
1783                                     if (nesting == 0) {
1784                                         continue outer;
1785                                     }
1786                                 break;
1787                             }
1788                         }
1789                     }
1790                     break;
1791                 case LBRACKET:
1792                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1793                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1794                         return ParensResult.EXPLICIT_LAMBDA;
1795                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1796                             peekToken(lookahead, RBRACKET, AMP)) {
1797                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1798                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1799                         return ParensResult.CAST;
1800                     } else if (peekToken(lookahead, RBRACKET)) {
1801                         //consume the &#39;]&#39; and skip
1802                         type = true;
1803                         lookahead++;
1804                         break;
1805                     } else {
1806                         return ParensResult.PARENS;
1807                     }
1808                 case LT:
1809                     depth++; break;
1810                 case GTGTGT:
1811                     depth--;
1812                 case GTGT:
1813                     depth--;
1814                 case GT:
1815                     depth--;
1816                     if (depth == 0) {
1817                         if (peekToken(lookahead, RPAREN) ||
1818                                 peekToken(lookahead, AMP)) {
1819                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1820                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1821                             return ParensResult.CAST;
1822                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1823                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
<a name="16" id="anc16"></a><span class="line-added">1824                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||</span>
<span class="line-added">1825                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||</span>
1826                                 peekToken(lookahead, ELLIPSIS)) {
1827                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1828                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1829                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1830                             return ParensResult.EXPLICIT_LAMBDA;
1831                         }
1832                         //it looks a type, but could still be (i) a cast to generic type,
1833                         //(ii) an unbound method reference or (iii) an explicit lambda
1834                         type = true;
1835                         break;
1836                     } else if (depth &lt; 0) {
1837                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1838                         return ParensResult.PARENS;
1839                     }
1840                     break;
1841                 default:
1842                     //this includes EOF
1843                     return defaultResult;
1844             }
1845         }
1846     }
1847 
1848     /** Accepts all identifier-like tokens */
1849     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1850 
1851     enum ParensResult {
1852         CAST,
1853         EXPLICIT_LAMBDA,
1854         IMPLICIT_LAMBDA,
1855         PARENS
1856     }
1857 
1858     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1859         List&lt;JCVariableDecl&gt; params = explicitParams ?
1860                 formalParameters(true, false) :
1861                 implicitParameters(hasParens);
1862         if (explicitParams) {
1863             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1864             for (JCVariableDecl param: params) {
1865                 Name restrictedTypeName;
1866                 if (param.vartype != null &amp;&amp;
1867                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1868                         param.vartype.hasTag(TYPEARRAY)) {
1869                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1870                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1871                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1872                 }
1873                 lambdaClassifier.addParameter(param);
1874                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1875                     break;
1876                 }
1877             }
1878             if (lambdaClassifier.diagFragment != null) {
1879                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1880             }
1881             for (JCVariableDecl param: params) {
1882                 if (param.vartype != null
1883                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1884                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1885                     param.startPos = TreeInfo.getStartPos(param.vartype);
1886                     param.vartype = null;
1887                 }
1888             }
1889         }
1890         return lambdaExpressionOrStatementRest(params, pos);
1891     }
1892 
1893     enum LambdaParameterKind {
1894         VAR(0),
1895         EXPLICIT(1),
1896         IMPLICIT(2),
1897         ERROR(-1);
1898 
1899         private final int index;
1900 
1901         LambdaParameterKind(int index) {
1902             this.index = index;
1903         }
1904     }
1905 
1906     private final static Fragment[][] decisionTable = new Fragment[][] {
1907         /*              VAR                              EXPLICIT                         IMPLICIT  */
1908         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1909         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1910         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1911     };
1912 
1913     class LambdaClassifier {
1914 
1915         LambdaParameterKind kind;
1916         Fragment diagFragment;
1917         List&lt;JCVariableDecl&gt; params;
1918 
1919         void addParameter(JCVariableDecl param) {
1920             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1921                 if (restrictedTypeName(param.vartype, false) != null) {
1922                     reduce(LambdaParameterKind.VAR);
1923                 } else {
1924                     reduce(LambdaParameterKind.EXPLICIT);
1925                 }
1926             }
1927             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1928                 param.vartype != null &amp;&amp; param.name == names.empty) {
1929                 reduce(LambdaParameterKind.IMPLICIT);
1930             }
1931         }
1932 
1933         private void reduce(LambdaParameterKind newKind) {
1934             if (kind == null) {
1935                 kind = newKind;
1936             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1937                 LambdaParameterKind currentKind = kind;
1938                 kind = LambdaParameterKind.ERROR;
1939                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1940                         newKind.index == LambdaParameterKind.VAR.index;
1941                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1942                         decisionTable[currentKind.index][newKind.index] : null;
1943             }
1944         }
1945 
1946         LambdaParameterKind result() {
1947             return kind;
1948         }
1949     }
1950 
1951     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1952         checkSourceLevel(Feature.LAMBDA);
1953         accept(ARROW);
1954 
1955         return token.kind == LBRACE ?
1956             lambdaStatement(args, pos, token.pos) :
1957             lambdaExpression(args, pos);
1958     }
1959 
1960     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1961         JCBlock block = block(pos2, 0);
1962         return toP(F.at(pos).Lambda(args, block));
1963     }
1964 
1965     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1966         JCTree expr = parseExpression();
1967         return toP(F.at(pos).Lambda(args, expr));
1968     }
1969 
1970     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1971      */
1972     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1973         nextToken();
1974         if (token.kind == LPAREN || typeArgs != null) {
1975             t = arguments(typeArgs, t);
1976         } else if (token.kind == COLCOL) {
1977             if (typeArgs != null) return illegal();
1978             t = memberReferenceSuffix(t);
1979         } else {
1980             int pos = token.pos;
1981             accept(DOT);
1982             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1983             t = toP(F.at(pos).Select(t, ident()));
1984             t = argumentsOpt(typeArgs, t);
1985         }
1986         return t;
1987     }
1988 
1989     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1990      */
1991     JCPrimitiveTypeTree basicType() {
1992         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1993         nextToken();
1994         return t;
1995     }
1996 
1997     /** ArgumentsOpt = [ Arguments ]
1998      */
1999     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2000         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
2001             selectExprMode();
2002             return arguments(typeArgs, t);
2003         } else {
2004             return t;
2005         }
2006     }
2007 
2008     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
2009      */
2010     List&lt;JCExpression&gt; arguments() {
2011         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2012         if (token.kind == LPAREN) {
2013             nextToken();
2014             if (token.kind != RPAREN) {
2015                 args.append(parseExpression());
2016                 while (token.kind == COMMA) {
2017                     nextToken();
2018                     args.append(parseExpression());
2019                 }
2020             }
2021             accept(RPAREN);
2022         } else {
2023             syntaxError(token.pos, Errors.Expected(LPAREN));
2024         }
2025         return args.toList();
2026     }
2027 
2028     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2029         int pos = token.pos;
2030         List&lt;JCExpression&gt; args = arguments();
2031         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2032         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2033                                                                     ((JCIdent) t).name)) {
2034             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2035             mi = F.Erroneous(List.of(mi));
2036         }
2037         return toP(mi);
2038     }
2039 
2040     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2041         if (name == names.yield) {
2042             if (allowYieldStatement) {
2043                 return true;
2044             } else {
2045                 log.warning(pos, Warnings.InvalidYield);
2046             }
2047         }
2048         return false;
2049     }
2050 
2051     /**  TypeArgumentsOpt = [ TypeArguments ]
2052      */
2053     JCExpression typeArgumentsOpt(JCExpression t) {
2054         if (token.kind == LT &amp;&amp;
2055             (mode &amp; TYPE) != 0 &amp;&amp;
2056             (mode &amp; NOPARAMS) == 0) {
2057             selectTypeMode();
2058             return typeArguments(t, false);
2059         } else {
2060             return t;
2061         }
2062     }
2063     List&lt;JCExpression&gt; typeArgumentsOpt() {
2064         return typeArgumentsOpt(TYPE);
2065     }
2066 
2067     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2068         if (token.kind == LT) {
2069             if ((mode &amp; useMode) == 0 ||
2070                 (mode &amp; NOPARAMS) != 0) {
2071                 illegal();
2072             }
2073             mode = useMode;
2074             return typeArguments(false);
2075         }
2076         return null;
2077     }
2078 
2079     /**
2080      *  {@literal
2081      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2082      *  }
2083      */
2084     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2085         if (token.kind == LT) {
2086             nextToken();
2087             if (token.kind == GT &amp;&amp; diamondAllowed) {
2088                 checkSourceLevel(Feature.DIAMOND);
2089                 mode |= DIAMOND;
2090                 nextToken();
2091                 return List.nil();
2092             } else {
2093                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2094                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2095                 while (token.kind == COMMA) {
2096                     nextToken();
2097                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2098                 }
2099                 switch (token.kind) {
2100 
2101                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2102                 case GTGTGT: case GTGT:
2103                     token = S.split();
2104                     break;
2105                 case GT:
2106                     nextToken();
2107                     break;
2108                 default:
2109                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2110                     break;
2111                 }
2112                 return args.toList();
2113             }
2114         } else {
2115             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2116         }
2117     }
2118 
2119     /**
2120      *  {@literal
2121      *  TypeArgument = Type
2122      *               | [Annotations] &quot;?&quot;
2123      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2124      *               | [Annotations] &quot;?&quot; SUPER Type
2125      *  }
2126      */
2127     JCExpression typeArgument() {
2128         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2129         if (token.kind != QUES) return parseType(false, annotations);
2130         int pos = token.pos;
2131         nextToken();
2132         JCExpression result;
2133         if (token.kind == EXTENDS) {
2134             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2135             nextToken();
2136             JCExpression bound = parseType();
2137             result = F.at(pos).Wildcard(t, bound);
2138         } else if (token.kind == SUPER) {
2139             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2140             nextToken();
2141             JCExpression bound = parseType();
2142             result = F.at(pos).Wildcard(t, bound);
2143         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2144             //error recovery
2145             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2146             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2147             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2148             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2149             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2150             result = err;
2151         } else {
2152             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2153             result = toP(F.at(pos).Wildcard(t, null));
2154         }
2155         if (!annotations.isEmpty()) {
2156             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2157         }
2158         return result;
2159     }
2160 
2161     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2162         int pos = token.pos;
2163         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2164         return toP(F.at(pos).TypeApply(t, args));
2165     }
2166 
2167     /**
2168      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2169      *
2170      * &lt;p&gt;
2171      *
2172      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2173      * the expression &lt;code&gt;t&lt;/code&gt;.
2174      */
2175     private JCExpression bracketsOpt(JCExpression t,
2176             List&lt;JCAnnotation&gt; annotations) {
2177         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2178 
2179         if (token.kind == LBRACKET) {
2180             int pos = token.pos;
2181             nextToken();
2182             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2183         } else if (!nextLevelAnnotations.isEmpty()) {
2184             if (permitTypeAnnotationsPushBack) {
2185                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2186             } else {
2187                 return illegal(nextLevelAnnotations.head.pos);
2188             }
2189         }
2190 
2191         if (!annotations.isEmpty()) {
2192             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2193         }
2194         return t;
2195     }
2196 
2197     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2198      */
2199     private JCExpression bracketsOpt(JCExpression t) {
2200         return bracketsOpt(t, List.nil());
2201     }
2202 
2203     private JCExpression bracketsOptCont(JCExpression t, int pos,
2204             List&lt;JCAnnotation&gt; annotations) {
2205         accept(RBRACKET);
2206         t = bracketsOpt(t);
2207         t = toP(F.at(pos).TypeArray(t));
2208         if (annotations.nonEmpty()) {
2209             t = toP(F.at(pos).AnnotatedType(annotations, t));
2210         }
2211         return t;
2212     }
2213 
2214     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2215      *  BracketsSuffixType =
2216      */
2217     JCExpression bracketsSuffix(JCExpression t) {
2218         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2219             selectExprMode();
2220             int pos = token.pos;
2221             nextToken();
<a name="17" id="anc17"></a><span class="line-modified">2222             TokenKind selector = accept2(CLASS, DEFAULT);</span>
2223             if (token.pos == endPosTable.errorEndPos) {
2224                 // error recovery
2225                 Name name;
2226                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2227                     name = token.name();
2228                     nextToken();
2229                 } else {
2230                     name = names.error;
2231                 }
2232                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2233             } else {
2234                 Tag tag = t.getTag();
2235                 // Type annotations are illegal on class literals. Annotated non array class literals
2236                 // are complained about directly in term3(), Here check for type annotations on dimensions
2237                 // taking care to handle some interior dimension(s) being annotated.
2238                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2239                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
<a name="18" id="anc18"></a><span class="line-modified">2240                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));</span>
2241             }
2242         } else if ((mode &amp; TYPE) != 0) {
2243             if (token.kind != COLCOL) {
2244                 selectTypeMode();
2245             }
2246         } else if (token.kind != COLCOL) {
2247             syntaxError(token.pos, Errors.DotClassExpected);
2248         }
2249         return t;
2250     }
2251 
2252     /**
2253      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2254      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2255      */
2256     JCExpression memberReferenceSuffix(JCExpression t) {
2257         int pos1 = token.pos;
2258         accept(COLCOL);
2259         return memberReferenceSuffix(pos1, t);
2260     }
2261 
2262     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2263         checkSourceLevel(Feature.METHOD_REFERENCES);
2264         selectExprMode();
2265         List&lt;JCExpression&gt; typeArgs = null;
2266         if (token.kind == LT) {
2267             typeArgs = typeArguments(false);
2268         }
2269         Name refName;
2270         ReferenceMode refMode;
2271         if (token.kind == NEW) {
2272             refMode = ReferenceMode.NEW;
2273             refName = names.init;
2274             nextToken();
2275         } else {
2276             refMode = ReferenceMode.INVOKE;
2277             refName = ident();
2278         }
2279         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2280     }
2281 
2282     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2283      */
2284     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
<a name="19" id="anc19"></a><span class="line-modified">2285         final JCModifiers mods = modifiersOpt();</span>
<span class="line-modified">2286         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;</span>
<span class="line-added">2287         if (!newAnnotations.isEmpty()) {</span>
<span class="line-added">2288             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);</span>
<span class="line-added">2289         }</span>
2290         switch (token.kind) {
2291         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2292         case DOUBLE: case BOOLEAN:
<a name="20" id="anc20"></a><span class="line-added">2293             if (mods.flags != 0) {</span>
<span class="line-added">2294                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2295                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2296             }</span>
2297             if (typeArgs == null) {
2298                 if (newAnnotations.isEmpty()) {
2299                     return arrayCreatorRest(newpos, basicType());
2300                 } else {
2301                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2302                 }
2303             }
2304             break;
2305         default:
2306         }
2307         JCExpression t = qualident(true);
2308 
2309         int oldmode = mode;
2310         selectTypeMode();
2311         boolean diamondFound = false;
2312         int lastTypeargsPos = -1;
2313         if (token.kind == LT) {
2314             lastTypeargsPos = token.pos;
2315             t = typeArguments(t, true);
2316             diamondFound = (mode &amp; DIAMOND) != 0;
2317         }
2318         while (token.kind == DOT) {
2319             if (diamondFound) {
2320                 //cannot select after a diamond
2321                 illegal();
2322             }
2323             int pos = token.pos;
2324             nextToken();
2325             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2326             t = toP(F.at(pos).Select(t, ident()));
2327 
2328             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2329                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2330             }
2331 
2332             if (token.kind == LT) {
2333                 lastTypeargsPos = token.pos;
2334                 t = typeArguments(t, true);
2335                 diamondFound = (mode &amp; DIAMOND) != 0;
2336             }
2337         }
2338         mode = oldmode;
2339         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2340             // handle type annotations for non primitive arrays
2341             if (newAnnotations.nonEmpty()) {
2342                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2343             }
2344 
2345             JCExpression e = arrayCreatorRest(newpos, t);
2346             if (diamondFound) {
2347                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2348                 return toP(F.at(newpos).Erroneous(List.of(e)));
2349             }
2350             else if (typeArgs != null) {
2351                 int pos = newpos;
2352                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2353                     // note: this should always happen but we should
2354                     // not rely on this as the parser is continuously
2355                     // modified to improve error recovery.
2356                     pos = typeArgs.head.pos;
2357                 }
2358                 setErrorEndPos(S.prevToken().endPos);
2359                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2360                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2361                 return toP(err);
2362             }
2363             return e;
2364         } else if (token.kind == LPAREN) {
<a name="21" id="anc21"></a><span class="line-added">2365             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);</span>
<span class="line-added">2366             if (badModifiers != 0)</span>
<span class="line-added">2367                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
2368             // handle type annotations for instantiations and anonymous classes
2369             if (newAnnotations.nonEmpty()) {
2370                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2371             }
<a name="22" id="anc22"></a><span class="line-modified">2372             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);</span>
<span class="line-added">2373             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {</span>
<span class="line-added">2374                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;</span>
<span class="line-added">2375                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));</span>
<span class="line-added">2376             }</span>
<span class="line-added">2377             return newClass;</span>
2378         } else {
2379             setErrorEndPos(token.pos);
2380             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2381             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2382             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2383         }
2384     }
2385 
2386     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2387      */
2388     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2389         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2390 
2391         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2392 
2393         if (newAnnotations.nonEmpty()) {
2394             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2395         }
2396 
2397         if (token.kind == LT) {
2398             int oldmode = mode;
2399             t = typeArguments(t, true);
2400             mode = oldmode;
2401         }
<a name="23" id="anc23"></a><span class="line-modified">2402         return classCreatorRest(newpos, encl, typeArgs, t, 0);</span>
2403     }
2404 
2405     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2406      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2407      */
2408     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2409         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2410 
2411         accept(LBRACKET);
2412         if (token.kind == RBRACKET) {
2413             accept(RBRACKET);
2414             elemtype = bracketsOpt(elemtype, annos);
2415             if (token.kind == LBRACE) {
2416                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2417                 if (annos.nonEmpty()) {
2418                     // when an array initializer is present then
2419                     // the parsed annotations should target the
2420                     // new array tree
2421                     // bracketsOpt inserts the annotation in
2422                     // elemtype, and it needs to be corrected
2423                     //
2424                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2425                     assert annotated.annotations == annos;
2426                     na.annotations = annotated.annotations;
2427                     na.elemtype = annotated.underlyingType;
2428                 }
2429                 return na;
2430             } else {
2431                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2432                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2433             }
2434         } else {
2435             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2436 
2437             // maintain array dimension type annotations
2438             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2439             dimAnnotations.append(annos);
2440 
2441             dims.append(parseExpression());
2442             accept(RBRACKET);
2443             while (token.kind == LBRACKET
2444                     || token.kind == MONKEYS_AT) {
2445                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2446                 int pos = token.pos;
2447                 nextToken();
2448                 if (token.kind == RBRACKET) {
2449                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2450                 } else {
2451                     if (token.kind == RBRACKET) { // no dimension
2452                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2453                     } else {
2454                         dimAnnotations.append(maybeDimAnnos);
2455                         dims.append(parseExpression());
2456                         accept(RBRACKET);
2457                     }
2458                 }
2459             }
2460 
2461             List&lt;JCExpression&gt; elems = null;
2462             int errpos = token.pos;
2463 
2464             if (token.kind == LBRACE) {
2465                 elems = arrayInitializerElements(newpos, elemtype);
2466             }
2467 
2468             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2469             na.dimAnnotations = dimAnnotations.toList();
2470 
2471             if (elems != null) {
2472                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2473             }
2474 
2475             return na;
2476         }
2477     }
2478 
2479     /** ClassCreatorRest = Arguments [ClassBody]
2480      */
2481     JCNewClass classCreatorRest(int newpos,
2482                                   JCExpression encl,
2483                                   List&lt;JCExpression&gt; typeArgs,
<a name="24" id="anc24"></a><span class="line-modified">2484                                   JCExpression t,</span>
<span class="line-added">2485                                   long flags)</span>
2486     {
2487         List&lt;JCExpression&gt; args = arguments();
2488         JCClassDecl body = null;
2489         if (token.kind == LBRACE) {
2490             int pos = token.pos;
2491             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
<a name="25" id="anc25"></a><span class="line-modified">2492             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);</span>
2493             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2494         }
<a name="26" id="anc26"></a><span class="line-modified">2495         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));</span>
<span class="line-added">2496         return newClass;</span>
2497     }
2498 
2499     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2500      */
2501     JCExpression arrayInitializer(int newpos, JCExpression t) {
2502         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2503         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2504     }
2505 
2506     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2507         accept(LBRACE);
2508         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2509         if (token.kind == COMMA) {
2510             nextToken();
2511         } else if (token.kind != RBRACE) {
2512             elems.append(variableInitializer());
2513             while (token.kind == COMMA) {
2514                 nextToken();
2515                 if (token.kind == RBRACE) break;
2516                 elems.append(variableInitializer());
2517             }
2518         }
2519         accept(RBRACE);
2520         return elems.toList();
2521     }
2522 
2523     /** VariableInitializer = ArrayInitializer | Expression
2524      */
2525     public JCExpression variableInitializer() {
2526         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2527     }
2528 
2529     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2530      */
2531     JCExpression parExpression() {
2532         int pos = token.pos;
2533         accept(LPAREN);
2534         JCExpression t = parseExpression();
2535         accept(RPAREN);
2536         return toP(F.at(pos).Parens(t));
2537     }
2538 
2539     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2540      */
2541     JCBlock block(int pos, long flags) {
2542         accept(LBRACE);
2543         List&lt;JCStatement&gt; stats = blockStatements();
2544         JCBlock t = F.at(pos).Block(flags, stats);
2545         while (token.kind == CASE || token.kind == DEFAULT) {
2546             syntaxError(token.pos, Errors.Orphaned(token.kind));
2547             switchBlockStatementGroups();
2548         }
2549         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2550         // usually but not necessarily the last char of the last token.
2551         t.endpos = token.pos;
2552         accept(RBRACE);
2553         return toP(t);
2554     }
2555 
2556     public JCBlock block() {
2557         return block(token.pos, 0);
2558     }
2559 
2560     /** BlockStatements = { BlockStatement }
2561      *  BlockStatement  = LocalVariableDeclarationStatement
2562      *                  | ClassOrInterfaceOrEnumDeclaration
2563      *                  | [Ident &quot;:&quot;] Statement
2564      *  LocalVariableDeclarationStatement
2565      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2566      */
2567     @SuppressWarnings(&quot;fallthrough&quot;)
2568     List&lt;JCStatement&gt; blockStatements() {
2569         //todo: skip to anchor on error(?)
2570         int lastErrPos = -1;
2571         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2572         while (true) {
2573             List&lt;JCStatement&gt; stat = blockStatement();
2574             if (stat.isEmpty()) {
2575                 return stats.toList();
2576             } else {
2577                 // error recovery
2578                 if (token.pos == lastErrPos)
2579                     return stats.toList();
2580                 if (token.pos &lt;= endPosTable.errorEndPos) {
2581                     skip(false, true, true, true);
2582                     lastErrPos = token.pos;
2583                 }
2584                 stats.addAll(stat);
2585             }
2586         }
2587     }
2588 
2589     /*
2590      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2591      * this method will also recognize variable and class declarations (which are
2592      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2593      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2594      * and an error will be produced by this method.
2595      */
2596     JCStatement parseStatementAsBlock() {
2597         int pos = token.pos;
2598         List&lt;JCStatement&gt; stats = blockStatement();
2599         if (stats.isEmpty()) {
2600             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2601             return toP(F.at(pos).Exec(e));
2602         } else {
2603             JCStatement first = stats.head;
2604             Error error = null;
2605             switch (first.getTag()) {
2606             case CLASSDEF:
2607                 error = Errors.ClassNotAllowed;
2608                 break;
2609             case VARDEF:
2610                 error = Errors.VariableNotAllowed;
2611                 break;
2612             }
2613             if (error != null) {
2614                 log.error(DiagnosticFlag.SYNTAX, first, error);
2615                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2616                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2617             }
2618             return first;
2619         }
2620     }
2621 
2622     /**This method parses a statement appearing inside a block.
2623      */
2624     @SuppressWarnings(&quot;fallthrough&quot;)
2625     List&lt;JCStatement&gt; blockStatement() {
2626         //todo: skip to anchor on error(?)
<a name="27" id="anc27"></a><span class="line-added">2627         token = recastToken(token);</span>
2628         Comment dc;
2629         int pos = token.pos;
2630         switch (token.kind) {
2631         case RBRACE: case CASE: case DEFAULT: case EOF:
2632             return List.nil();
2633         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2634         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2635         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2636         case ASSERT:
2637             return List.of(parseSimpleStatement());
<a name="28" id="anc28"></a><span class="line-added">2638         case VALUE:</span>
2639         case MONKEYS_AT:
2640         case FINAL: {
2641             dc = token.comment(CommentStyle.JAVADOC);
2642             JCModifiers mods = modifiersOpt();
2643             if (token.kind == INTERFACE ||
2644                 token.kind == CLASS ||
2645                 token.kind == ENUM ||
2646                 isRecordStart()) {
2647                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2648             } else {
2649                 JCExpression t = parseType(true);
2650                 return localVariableDeclarations(mods, t);
2651             }
2652         }
2653         case ABSTRACT: case STRICTFP: {
2654             dc = token.comment(CommentStyle.JAVADOC);
2655             JCModifiers mods = modifiersOpt();
2656             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2657         }
2658         case INTERFACE:
2659         case CLASS:
2660             dc = token.comment(CommentStyle.JAVADOC);
2661             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2662         case ENUM:
2663             if (!allowRecords) {
2664                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2665             }
2666             dc = token.comment(CommentStyle.JAVADOC);
2667             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2668         case IDENTIFIER:
2669             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2670                 Token next = S.token(1);
2671                 boolean isYieldStatement;
2672                 switch (next.kind) {
2673                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2674                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2675                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2676                     case NEW: case SWITCH: case THIS: case SUPER:
2677                         isYieldStatement = true;
2678                         break;
2679                     case PLUSPLUS: case SUBSUB:
2680                         isYieldStatement = S.token(2).kind != SEMI;
2681                         break;
2682                     case LPAREN:
2683                         int lookahead = 2;
2684                         int balance = 1;
2685                         boolean hasComma = false;
2686                         Token l;
2687                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2688                             switch (l.kind) {
2689                                 case LPAREN: balance++; break;
2690                                 case RPAREN: balance--; break;
2691                                 case COMMA: if (balance == 1) hasComma = true; break;
2692                             }
2693                             lookahead++;
2694                         }
2695                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2696                         break;
2697                     case SEMI: //error recovery - this is not a valid statement:
2698                         isYieldStatement = true;
2699                         break;
2700                     default:
2701                         isYieldStatement = false;
2702                         break;
2703                 }
2704 
2705                 if (isYieldStatement) {
2706                     nextToken();
2707                     JCExpression t = term(EXPR);
2708                     accept(SEMI);
2709                     return List.of(toP(F.at(pos).Yield(t)));
2710                 }
2711 
2712                 //else intentional fall-through
2713             } else {
2714                 if (isNonSealedClassStart(true)) {
2715                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);
2716                     nextToken();
2717                     nextToken();
2718                     nextToken();
2719                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));
2720                 } else if (isSealedClassStart(true)) {
2721                     checkSourceLevel(Feature.SEALED_CLASSES);
2722                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);
2723                     nextToken();
2724                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));
2725                 }
2726             }
2727         }
2728         if (isRecordStart() &amp;&amp; allowRecords) {
2729             dc = token.comment(CommentStyle.JAVADOC);
2730             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2731         } else {
2732             Token prevToken = token;
2733             JCExpression t = term(EXPR | TYPE);
2734             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2735                 nextToken();
2736                 JCStatement stat = parseStatementAsBlock();
2737                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2738             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2739                 pos = token.pos;
2740                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2741                 F.at(pos);
2742                 return localVariableDeclarations(mods, t);
2743             } else {
2744                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2745                 t = checkExprStat(t);
2746                 accept(SEMI);
2747                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2748                 return List.of(expr);
2749             }
2750         }
2751     }
2752     //where
2753         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2754             ListBuffer&lt;JCStatement&gt; stats =
2755                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2756             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2757             accept(SEMI);
2758             storeEnd(stats.last(), S.prevToken().endPos);
2759             return stats.toList();
2760         }
2761 
2762     /** Statement =
2763      *       Block
2764      *     | IF ParExpression Statement [ELSE Statement]
2765      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2766      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2767      *     | WHILE ParExpression Statement
2768      *     | DO Statement WHILE ParExpression &quot;;&quot;
2769      *     | TRY Block ( Catches | [Catches] FinallyPart )
2770      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2771      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2772      *     | SYNCHRONIZED ParExpression Block
2773      *     | RETURN [Expression] &quot;;&quot;
2774      *     | THROW Expression &quot;;&quot;
2775      *     | BREAK [Ident] &quot;;&quot;
2776      *     | CONTINUE [Ident] &quot;;&quot;
2777      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2778      *     | &quot;;&quot;
2779      */
2780     public JCStatement parseSimpleStatement() {
2781         int pos = token.pos;
2782         switch (token.kind) {
2783         case LBRACE:
2784             return block();
2785         case IF: {
2786             nextToken();
2787             JCExpression cond = parExpression();
2788             JCStatement thenpart = parseStatementAsBlock();
2789             JCStatement elsepart = null;
2790             if (token.kind == ELSE) {
2791                 nextToken();
2792                 elsepart = parseStatementAsBlock();
2793             }
2794             return F.at(pos).If(cond, thenpart, elsepart);
2795         }
2796         case FOR: {
2797             nextToken();
2798             accept(LPAREN);
2799             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2800             if (inits.length() == 1 &amp;&amp;
2801                 inits.head.hasTag(VARDEF) &amp;&amp;
2802                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2803                 token.kind == COLON) {
2804                 JCVariableDecl var = (JCVariableDecl)inits.head;
2805                 accept(COLON);
2806                 JCExpression expr = parseExpression();
2807                 accept(RPAREN);
2808                 JCStatement body = parseStatementAsBlock();
2809                 return F.at(pos).ForeachLoop(var, expr, body);
2810             } else {
2811                 accept(SEMI);
2812                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2813                 accept(SEMI);
2814                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2815                 accept(RPAREN);
2816                 JCStatement body = parseStatementAsBlock();
2817                 return F.at(pos).ForLoop(inits, cond, steps, body);
2818             }
2819         }
2820         case WHILE: {
2821             nextToken();
2822             JCExpression cond = parExpression();
2823             JCStatement body = parseStatementAsBlock();
2824             return F.at(pos).WhileLoop(cond, body);
2825         }
2826         case DO: {
2827             nextToken();
2828             JCStatement body = parseStatementAsBlock();
2829             accept(WHILE);
2830             JCExpression cond = parExpression();
2831             accept(SEMI);
2832             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2833             return t;
2834         }
2835         case TRY: {
2836             nextToken();
2837             List&lt;JCTree&gt; resources = List.nil();
2838             if (token.kind == LPAREN) {
2839                 nextToken();
2840                 resources = resources();
2841                 accept(RPAREN);
2842             }
2843             JCBlock body = block();
2844             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2845             JCBlock finalizer = null;
2846             if (token.kind == CATCH || token.kind == FINALLY) {
2847                 while (token.kind == CATCH) catchers.append(catchClause());
2848                 if (token.kind == FINALLY) {
2849                     nextToken();
2850                     finalizer = block();
2851                 }
2852             } else {
2853                 if (resources.isEmpty()) {
2854                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2855                 }
2856             }
2857             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2858         }
2859         case SWITCH: {
2860             nextToken();
2861             JCExpression selector = parExpression();
2862             accept(LBRACE);
2863             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2864             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2865             accept(RBRACE);
2866             return t;
2867         }
2868         case SYNCHRONIZED: {
2869             nextToken();
2870             JCExpression lock = parExpression();
2871             JCBlock body = block();
2872             return F.at(pos).Synchronized(lock, body);
2873         }
2874         case RETURN: {
2875             nextToken();
2876             JCExpression result = token.kind == SEMI ? null : parseExpression();
2877             accept(SEMI);
2878             JCReturn t = toP(F.at(pos).Return(result));
2879             return t;
2880         }
2881         case THROW: {
2882             nextToken();
2883             JCExpression exc = parseExpression();
2884             accept(SEMI);
2885             JCThrow t = toP(F.at(pos).Throw(exc));
2886             return t;
2887         }
2888         case BREAK: {
2889             nextToken();
2890             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2891             accept(SEMI);
2892             JCBreak t = toP(F.at(pos).Break(label));
2893             return t;
2894         }
2895         case CONTINUE: {
2896             nextToken();
2897             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2898             accept(SEMI);
2899             JCContinue t =  toP(F.at(pos).Continue(label));
2900             return t;
2901         }
2902         case SEMI:
2903             nextToken();
2904             return toP(F.at(pos).Skip());
2905         case ELSE:
2906             int elsePos = token.pos;
2907             nextToken();
2908             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2909         case FINALLY:
2910             int finallyPos = token.pos;
2911             nextToken();
2912             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2913         case CATCH:
2914             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2915         case ASSERT: {
2916             nextToken();
2917             JCExpression assertion = parseExpression();
2918             JCExpression message = null;
2919             if (token.kind == COLON) {
2920                 nextToken();
2921                 message = parseExpression();
2922             }
2923             accept(SEMI);
2924             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2925             return t;
2926         }
2927         default:
2928             Assert.error();
2929             return null;
2930         }
2931     }
2932 
2933     @Override
2934     public JCStatement parseStatement() {
2935         return parseStatementAsBlock();
2936     }
2937 
2938     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2939         int errPos = S.errPos();
2940         JCTree stm = action.doRecover(this);
2941         S.errPos(errPos);
2942         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2943     }
2944 
2945     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2946      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2947      */
2948     protected JCCatch catchClause() {
2949         int pos = token.pos;
2950         accept(CATCH);
2951         accept(LPAREN);
2952         JCModifiers mods = optFinal(Flags.PARAMETER);
2953         List&lt;JCExpression&gt; catchTypes = catchTypes();
2954         JCExpression paramType = catchTypes.size() &gt; 1 ?
2955                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2956                 catchTypes.head;
2957         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2958         accept(RPAREN);
2959         JCBlock body = block();
2960         return F.at(pos).Catch(formal, body);
2961     }
2962 
2963     List&lt;JCExpression&gt; catchTypes() {
2964         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2965         catchTypes.add(parseType());
2966         while (token.kind == BAR) {
2967             nextToken();
2968             // Instead of qualident this is now parseType.
2969             // But would that allow too much, e.g. arrays or generics?
2970             catchTypes.add(parseType());
2971         }
2972         return catchTypes.toList();
2973     }
2974 
2975     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2976      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2977      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2978      */
2979     List&lt;JCCase&gt; switchBlockStatementGroups() {
2980         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2981         while (true) {
2982             int pos = token.pos;
2983             switch (token.kind) {
2984             case CASE:
2985             case DEFAULT:
2986                 cases.appendList(switchBlockStatementGroup());
2987                 break;
2988             case RBRACE: case EOF:
2989                 return cases.toList();
2990             default:
2991                 nextToken(); // to ensure progress
2992                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2993             }
2994         }
2995     }
2996 
2997     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2998         int pos = token.pos;
2999         List&lt;JCStatement&gt; stats;
3000         JCCase c;
3001         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
3002         switch (token.kind) {
3003         case CASE: {
3004             nextToken();
3005             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
3006             while (true) {
3007                 pats.append(term(EXPR | NOLAMBDA));
3008                 if (token.kind != COMMA) break;
3009                 nextToken();
3010                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
3011             };
3012             CaseTree.CaseKind caseKind;
3013             JCTree body = null;
3014             if (token.kind == ARROW) {
3015                 checkSourceLevel(Feature.SWITCH_RULE);
3016                 accept(ARROW);
3017                 caseKind = JCCase.RULE;
3018                 JCStatement statement = parseStatementAsBlock();
3019                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3020                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3021                 }
3022                 stats = List.of(statement);
3023                 body = stats.head;
3024             } else {
3025                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3026                 caseKind = JCCase.STATEMENT;
3027                 stats = blockStatements();
3028             }
3029             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
3030             if (stats.isEmpty())
3031                 storeEnd(c, S.prevToken().endPos);
3032             return cases.append(c).toList();
3033         }
3034         case DEFAULT: {
3035             nextToken();
3036             CaseTree.CaseKind caseKind;
3037             JCTree body = null;
3038             if (token.kind == ARROW) {
3039                 checkSourceLevel(Feature.SWITCH_RULE);
3040                 accept(ARROW);
3041                 caseKind = JCCase.RULE;
3042                 JCStatement statement = parseStatementAsBlock();
3043                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3044                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3045                 }
3046                 stats = List.of(statement);
3047                 body = stats.head;
3048             } else {
3049                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3050                 caseKind = JCCase.STATEMENT;
3051                 stats = blockStatements();
3052             }
3053             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3054             if (stats.isEmpty())
3055                 storeEnd(c, S.prevToken().endPos);
3056             return cases.append(c).toList();
3057         }
3058         }
3059         throw new AssertionError(&quot;should not reach here&quot;);
3060     }
3061 
3062     /** MoreStatementExpressions = { COMMA StatementExpression }
3063      */
3064     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3065                                                                     JCExpression first,
3066                                                                     T stats) {
3067         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3068         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3069         while (token.kind == COMMA) {
3070             nextToken();
3071             pos = token.pos;
3072             JCExpression t = parseExpression();
3073             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3074             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3075         }
3076         return stats;
3077     }
3078 
3079     /** ForInit = StatementExpression MoreStatementExpressions
3080      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3081      */
3082     List&lt;JCStatement&gt; forInit() {
3083         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3084         int pos = token.pos;
3085         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3086             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3087         } else {
3088             JCExpression t = term(EXPR | TYPE);
3089             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<a name="29" id="anc29"></a><span class="line-modified">3090                 pos = token.pos;</span>
<span class="line-added">3091                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);</span>
<span class="line-added">3092                 F.at(pos);</span>
<span class="line-added">3093                 return variableDeclarators(mods, t, stats, true).toList();</span>
3094             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3095                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3096                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3097             } else {
3098                 return moreStatementExpressions(pos, t, stats).toList();
3099             }
3100         }
3101     }
3102 
3103     /** ForUpdate = StatementExpression MoreStatementExpressions
3104      */
3105     List&lt;JCExpressionStatement&gt; forUpdate() {
3106         return moreStatementExpressions(token.pos,
3107                                         parseExpression(),
3108                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3109     }
3110 
3111     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3112      *
3113      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3114      */
3115     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3116         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3117         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3118         int prevmode = mode;
3119         while (token.kind == MONKEYS_AT) {
3120             int pos = token.pos;
3121             nextToken();
3122             buf.append(annotation(pos, kind));
3123         }
3124         lastmode = mode;
3125         mode = prevmode;
3126         List&lt;JCAnnotation&gt; annotations = buf.toList();
3127 
3128         return annotations;
3129     }
3130 
3131     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3132         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3133         return annotations;
3134     }
3135 
3136     /** ModifiersOpt = { Modifier }
3137      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3138      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3139      *           | &quot;@&quot; Annotation
3140      */
3141     protected JCModifiers modifiersOpt() {
3142         return modifiersOpt(null);
3143     }
3144     protected JCModifiers modifiersOpt(JCModifiers partial) {
3145         long flags;
3146         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3147         int pos;
3148         if (partial == null) {
3149             flags = 0;
3150             pos = token.pos;
3151         } else {
3152             flags = partial.flags;
3153             annotations.appendList(partial.annotations);
3154             pos = partial.pos;
3155         }
3156         if (token.deprecatedFlag()) {
3157             flags |= Flags.DEPRECATED;
3158         }
3159         int lastPos;
3160     loop:
3161         while (true) {
3162             long flag;
<a name="30" id="anc30"></a><span class="line-added">3163             token = recastToken(token);</span>
3164             switch (token.kind) {
3165             case PRIVATE     : flag = Flags.PRIVATE; break;
3166             case PROTECTED   : flag = Flags.PROTECTED; break;
3167             case PUBLIC      : flag = Flags.PUBLIC; break;
3168             case STATIC      : flag = Flags.STATIC; break;
3169             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3170             case FINAL       : flag = Flags.FINAL; break;
3171             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3172             case NATIVE      : flag = Flags.NATIVE; break;
<a name="31" id="anc31"></a><span class="line-added">3173             case VALUE       : flag = Flags.VALUE; break;</span>
3174             case VOLATILE    : flag = Flags.VOLATILE; break;
3175             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3176             case STRICTFP    : flag = Flags.STRICTFP; break;
3177             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3178             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3179             case ERROR       : flag = 0; nextToken(); break;
3180             case IDENTIFIER  : {
3181                 if (isNonSealedClassStart(false)) {
3182                     flag = Flags.NON_SEALED;
3183                     nextToken();
3184                     nextToken();
3185                     break;
3186                 }
3187                 if (isSealedClassStart(false)) {
3188                     checkSourceLevel(Feature.SEALED_CLASSES);
3189                     flag = Flags.SEALED;
3190                     break;
3191                 }
3192                 break loop;
3193             }
3194             default: break loop;
3195             }
3196             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3197             lastPos = token.pos;
3198             nextToken();
3199             if (flag == Flags.ANNOTATION) {
3200                 if (token.kind != INTERFACE) {
3201                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3202                     // if first modifier is an annotation, set pos to annotation&#39;s.
3203                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3204                         pos = ann.pos;
<a name="32" id="anc32"></a><span class="line-modified">3205                     final Name name = TreeInfo.name(ann.annotationType);</span>
<span class="line-modified">3206                     if (name == names.__inline__ || name == names.java_lang___inline__) {</span>
<span class="line-added">3207                         flag = Flags.VALUE;</span>
<span class="line-added">3208                     } else {</span>
<span class="line-added">3209                         annotations.append(ann);</span>
<span class="line-added">3210                         flag = 0;</span>
<span class="line-added">3211                     }</span>
3212                 }
3213             }
3214             flags |= flag;
3215         }
3216         switch (token.kind) {
3217         case ENUM: flags |= Flags.ENUM; break;
3218         case INTERFACE: flags |= Flags.INTERFACE; break;
3219         default: break;
3220         }
3221 
3222         /* A modifiers tree with no modifier tokens or annotations
3223          * has no text position. */
3224         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3225             pos = Position.NOPOS;
3226 
<a name="33" id="anc33"></a><span class="line-added">3227         // Force value classes to be automatically final.</span>
<span class="line-added">3228         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {</span>
<span class="line-added">3229             flags |= Flags.FINAL;</span>
<span class="line-added">3230         }</span>
<span class="line-added">3231 </span>
3232         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3233         if (pos != Position.NOPOS)
3234             storeEnd(mods, S.prevToken().endPos);
3235         return mods;
3236     }
3237 
3238     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3239      *
3240      * @param pos position of &quot;@&quot; token
3241      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3242      */
3243     JCAnnotation annotation(int pos, Tag kind) {
3244         // accept(AT); // AT consumed by caller
3245         if (kind == Tag.TYPE_ANNOTATION) {
3246             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3247         }
3248         JCTree ident = qualident(false);
3249         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3250         JCAnnotation ann;
3251         if (kind == Tag.ANNOTATION) {
3252             ann = F.at(pos).Annotation(ident, fieldValues);
3253         } else if (kind == Tag.TYPE_ANNOTATION) {
3254             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3255         } else {
3256             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3257         }
3258 
3259         storeEnd(ann, S.prevToken().endPos);
3260         return ann;
3261     }
3262 
3263     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3264         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3265     }
3266 
3267     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3268     List&lt;JCExpression&gt; annotationFieldValues() {
3269         accept(LPAREN);
3270         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3271         if (token.kind != RPAREN) {
3272             buf.append(annotationFieldValue());
3273             while (token.kind == COMMA) {
3274                 nextToken();
3275                 buf.append(annotationFieldValue());
3276             }
3277         }
3278         accept(RPAREN);
3279         return buf.toList();
3280     }
3281 
3282     /** AnnotationFieldValue    = AnnotationValue
3283      *                          | Identifier &quot;=&quot; AnnotationValue
3284      */
3285     JCExpression annotationFieldValue() {
3286         if (LAX_IDENTIFIER.accepts(token.kind)) {
3287             selectExprMode();
3288             JCExpression t1 = term1();
3289             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3290                 int pos = token.pos;
3291                 accept(EQ);
3292                 JCExpression v = annotationValue();
3293                 return toP(F.at(pos).Assign(t1, v));
3294             } else {
3295                 return t1;
3296             }
3297         }
3298         return annotationValue();
3299     }
3300 
3301     /* AnnotationValue          = ConditionalExpression
3302      *                          | Annotation
3303      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3304      */
3305     JCExpression annotationValue() {
3306         int pos;
3307         switch (token.kind) {
3308         case MONKEYS_AT:
3309             pos = token.pos;
3310             nextToken();
3311             return annotation(pos, Tag.ANNOTATION);
3312         case LBRACE:
3313             pos = token.pos;
3314             accept(LBRACE);
3315             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3316             if (token.kind == COMMA) {
3317                 nextToken();
3318             } else if (token.kind != RBRACE) {
3319                 buf.append(annotationValue());
3320                 while (token.kind == COMMA) {
3321                     nextToken();
3322                     if (token.kind == RBRACE) break;
3323                     buf.append(annotationValue());
3324                 }
3325             }
3326             accept(RBRACE);
3327             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3328         default:
3329             selectExprMode();
3330             return term1();
3331         }
3332     }
3333 
3334     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3335      */
3336     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3337                                                                          JCExpression type,
3338                                                                          T vdefs,
3339                                                                          boolean localDecl)
3340     {
3341         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3342     }
3343 
3344     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3345      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3346      *
3347      *  @param reqInit  Is an initializer always required?
3348      *  @param dc       The documentation comment for the variable declarations, or null.
3349      */
3350     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3351                                                                      JCModifiers mods,
3352                                                                      JCExpression type,
3353                                                                      Name name,
3354                                                                      boolean reqInit,
3355                                                                      Comment dc,
3356                                                                      T vdefs,
3357                                                                      boolean localDecl)
3358     {
3359         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3360         vdefs.append(head);
3361         while (token.kind == COMMA) {
3362             // All but last of multiple declarators subsume a comma
3363             storeEnd((JCTree)vdefs.last(), token.endPos);
3364             nextToken();
3365             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3366         }
3367         return vdefs;
3368     }
3369 
3370     /** VariableDeclarator = Ident VariableDeclaratorRest
3371      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3372      */
3373     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3374         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3375     }
3376 
3377     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3378      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3379      *
3380      *  @param reqInit  Is an initializer always required?
3381      *  @param dc       The documentation comment for the variable declarations, or null.
3382      */
3383     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3384                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3385         type = bracketsOpt(type);
3386         JCExpression init = null;
3387         if (token.kind == EQ) {
3388             nextToken();
3389             init = variableInitializer();
3390         }
3391         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3392         JCTree elemType = TreeInfo.innermostType(type, true);
3393         int startPos = Position.NOPOS;
3394         if (elemType.hasTag(IDENT)) {
3395             Name typeName = ((JCIdent)elemType).name;
3396             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3397                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3398                     //error - &#39;var&#39; and arrays
3399                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3400                 } else {
3401                     if(compound)
3402                         //error - &#39;var&#39; in compound local var decl
3403                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3404                     startPos = TreeInfo.getStartPos(mods);
3405                     if (startPos == Position.NOPOS)
3406                         startPos = TreeInfo.getStartPos(type);
3407                     //implicit type
3408                     type = null;
3409                 }
3410             }
3411         }
3412         JCVariableDecl result =
3413             toP(F.at(pos).VarDef(mods, name, type, init));
3414         attach(result, dc);
3415         result.startPos = startPos;
3416         return result;
3417     }
3418 
<a name="34" id="anc34"></a><span class="line-added">3419     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.</span>
<span class="line-added">3420     Token recastToken(Token token) {</span>
<span class="line-added">3421         if (token.kind != IDENTIFIER || token.name() != names.inline) {</span>
<span class="line-added">3422             return token;</span>
<span class="line-added">3423         }</span>
<span class="line-added">3424         if (peekToken(t-&gt;t == PRIVATE ||</span>
<span class="line-added">3425                          t == PROTECTED ||</span>
<span class="line-added">3426                          t == PUBLIC ||</span>
<span class="line-added">3427                          t == STATIC ||</span>
<span class="line-added">3428                          t == TRANSIENT ||</span>
<span class="line-added">3429                          t == FINAL ||</span>
<span class="line-added">3430                          t == ABSTRACT ||</span>
<span class="line-added">3431                          t == NATIVE ||</span>
<span class="line-added">3432                          t == VOLATILE ||</span>
<span class="line-added">3433                          t == SYNCHRONIZED ||</span>
<span class="line-added">3434                          t == STRICTFP ||</span>
<span class="line-added">3435                          t == MONKEYS_AT ||</span>
<span class="line-added">3436                          t == DEFAULT ||</span>
<span class="line-added">3437                          t == BYTE ||</span>
<span class="line-added">3438                          t == SHORT ||</span>
<span class="line-added">3439                          t == CHAR ||</span>
<span class="line-added">3440                          t == INT ||</span>
<span class="line-added">3441                          t == LONG ||</span>
<span class="line-added">3442                          t == FLOAT ||</span>
<span class="line-added">3443                          t == DOUBLE ||</span>
<span class="line-added">3444                          t == BOOLEAN ||</span>
<span class="line-added">3445                          t == CLASS ||</span>
<span class="line-added">3446                          t == INTERFACE ||</span>
<span class="line-added">3447                          t == ENUM ||</span>
<span class="line-added">3448                          t == IDENTIFIER)) { // new value Comparable() {}</span>
<span class="line-added">3449             checkSourceLevel(Feature.INLINE_TYPES);</span>
<span class="line-added">3450             return new Token(VALUE, token.pos, token.endPos, token.comments);</span>
<span class="line-added">3451         }</span>
<span class="line-added">3452         return token;</span>
<span class="line-added">3453     }</span>
<span class="line-added">3454 </span>
3455     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3456         switch (e.getTag()) {
3457             case IDENT:
3458                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3459             case TYPEARRAY:
3460                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3461             default:
3462                 return null;
3463         }
3464     }
3465 
3466     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3467         if (name == names.var) {
3468             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3469                 return Source.JDK10;
3470             } else if (shouldWarn) {
3471                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3472             }
3473         }
3474         if (name == names.yield) {
3475             if (allowYieldStatement) {
3476                 return Source.JDK14;
3477             } else if (shouldWarn) {
3478                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3479             }
3480         }
3481         if (name == names.record) {
3482             if (allowRecords) {
3483                 return Source.JDK14;
3484             } else if (shouldWarn) {
3485                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3486             }
3487         }
3488         if (name == names.sealed) {
3489             if (allowSealedTypes) {
3490                 return Source.JDK15;
3491             } else if (shouldWarn) {
3492                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3493             }
3494         }
3495         if (name == names.permits) {
3496             if (allowSealedTypes) {
3497                 return Source.JDK15;
3498             } else if (shouldWarn) {
3499                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3500             }
3501         }
3502         return null;
3503     }
3504 
3505     /** VariableDeclaratorId = Ident BracketsOpt
3506      */
3507     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3508         return variableDeclaratorId(mods, type, false);
3509     }
3510     //where
3511     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3512         int pos = token.pos;
3513         Name name;
3514         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3515             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3516             name = token.name();
3517             nextToken();
3518         } else {
3519             if (allowThisIdent ||
3520                 !lambdaParameter ||
3521                 LAX_IDENTIFIER.accepts(token.kind) ||
3522                 mods.flags != Flags.PARAMETER ||
3523                 mods.annotations.nonEmpty()) {
3524                 JCExpression pn = qualident(false);
3525                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3526                     name = ((JCIdent)pn).name;
3527                 } else {
3528                     if (allowThisIdent) {
3529                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3530                             log.error(token.pos, Errors.VarargsAndReceiver);
3531                         }
3532                         if (token.kind == LBRACKET) {
3533                             log.error(token.pos, Errors.ArrayAndReceiver);
3534                         }
3535                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3536                             log.error(token.pos, Errors.WrongReceiver);
3537                         }
3538                     }
3539                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3540                 }
3541             } else {
3542                 /** if it is a lambda parameter and the token kind is not an identifier,
3543                  *  and there are no modifiers or annotations, then this means that the compiler
3544                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3545                  *  var or explicit parameters. So we assign the error name to the parameter name
3546                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3547                  *  a higher level.
3548                  */
3549                 name = names.empty;
3550             }
3551         }
3552         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3553                 token.kind == LBRACKET) {
3554             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3555         }
3556         type = bracketsOpt(type);
3557 
3558         return toP(F.at(pos).VarDef(mods, name, type, null));
3559     }
3560 
3561     /** Resources = Resource { &quot;;&quot; Resources }
3562      */
3563     List&lt;JCTree&gt; resources() {
3564         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3565         defs.append(resource());
3566         while (token.kind == SEMI) {
3567             // All but last of multiple declarators must subsume a semicolon
3568             storeEnd(defs.last(), token.endPos);
3569             int semiColonPos = token.pos;
3570             nextToken();
3571             if (token.kind == RPAREN) { // Optional trailing semicolon
3572                                        // after last resource
3573                 break;
3574             }
3575             defs.append(resource());
3576         }
3577         return defs.toList();
3578     }
3579 
3580     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3581      *           | Expression
3582      */
3583     protected JCTree resource() {
3584         int startPos = token.pos;
3585         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3586             JCModifiers mods = optFinal(Flags.FINAL);
3587             JCExpression t = parseType(true);
3588             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3589         }
3590         JCExpression t = term(EXPR | TYPE);
3591         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3592             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3593             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3594         } else {
3595             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3596             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3597                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3598             }
3599 
3600             return t;
3601         }
3602     }
3603 
3604     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3605      */
3606     public JCTree.JCCompilationUnit parseCompilationUnit() {
3607         Token firstToken = token;
3608         JCModifiers mods = null;
3609         boolean consumedToplevelDoc = false;
3610         boolean seenImport = false;
3611         boolean seenPackage = false;
3612         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3613         if (token.kind == MONKEYS_AT)
3614             mods = modifiersOpt();
3615 
3616         if (token.kind == PACKAGE) {
3617             int packagePos = token.pos;
3618             List&lt;JCAnnotation&gt; annotations = List.nil();
3619             seenPackage = true;
3620             if (mods != null) {
3621                 checkNoMods(mods.flags);
3622                 annotations = mods.annotations;
3623                 mods = null;
3624             }
3625             nextToken();
3626             JCExpression pid = qualident(false);
3627             accept(SEMI);
3628             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3629             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3630             consumedToplevelDoc = true;
3631             defs.append(pd);
3632         }
3633 
3634         boolean checkForImports = true;
3635         boolean firstTypeDecl = true;
3636         while (token.kind != EOF) {
3637             if (token.pos &lt;= endPosTable.errorEndPos) {
3638                 // error recovery
3639                 skip(checkForImports, false, false, false);
3640                 if (token.kind == EOF)
3641                     break;
3642             }
3643             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3644                 seenImport = true;
3645                 defs.append(importDeclaration());
3646             } else {
3647                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3648                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3649                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3650                     consumedToplevelDoc = true;
3651                 }
3652                 if (mods != null || token.kind != SEMI)
3653                     mods = modifiersOpt(mods);
3654                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3655                     ModuleKind kind = ModuleKind.STRONG;
3656                     if (token.name() == names.open) {
3657                         kind = ModuleKind.OPEN;
3658                         nextToken();
3659                     }
3660                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3661                         if (mods != null) {
3662                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3663                         }
3664                         defs.append(moduleDecl(mods, kind, docComment));
3665                         consumedToplevelDoc = true;
3666                         break;
3667                     } else if (kind != ModuleKind.STRONG) {
3668                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3669                     }
3670                 }
3671                 JCTree def = typeDeclaration(mods, docComment);
3672                 if (def instanceof JCExpressionStatement)
3673                     def = ((JCExpressionStatement)def).expr;
3674                 defs.append(def);
3675                 if (def instanceof JCClassDecl)
3676                     checkForImports = false;
3677                 mods = null;
3678                 firstTypeDecl = false;
3679             }
3680         }
3681         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3682         if (!consumedToplevelDoc)
3683             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3684         if (defs.isEmpty())
3685             storeEnd(toplevel, S.prevToken().endPos);
3686         if (keepDocComments)
3687             toplevel.docComments = docComments;
3688         if (keepLineMap)
3689             toplevel.lineMap = S.getLineMap();
3690         this.endPosTable.setParser(null); // remove reference to parser
3691         toplevel.endPositions = this.endPosTable;
3692         return toplevel;
3693     }
3694 
3695     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3696         int pos = token.pos;
3697         checkSourceLevel(Feature.MODULES);
3698 
3699         nextToken();
3700         JCExpression name = qualident(false);
3701         List&lt;JCDirective&gt; directives = null;
3702 
3703         accept(LBRACE);
3704         directives = moduleDirectiveList();
3705         accept(RBRACE);
3706         accept(EOF);
3707 
3708         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3709         attach(result, dc);
3710         return result;
3711     }
3712 
3713     List&lt;JCDirective&gt; moduleDirectiveList() {
3714         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3715         while (token.kind == IDENTIFIER) {
3716             int pos = token.pos;
3717             if (token.name() == names.requires) {
3718                 nextToken();
3719                 boolean isTransitive = false;
3720                 boolean isStaticPhase = false;
3721             loop:
3722                 while (true) {
3723                     switch (token.kind) {
3724                         case IDENTIFIER:
3725                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3726                                 Token t1 = S.token(1);
3727                                 if (t1.kind == SEMI || t1.kind == DOT) {
3728                                     break loop;
3729                                 }
3730                                 isTransitive = true;
3731                                 break;
3732                             } else {
3733                                 break loop;
3734                             }
3735                         case STATIC:
3736                             if (isStaticPhase) {
3737                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3738                             }
3739                             isStaticPhase = true;
3740                             break;
3741                         default:
3742                             break loop;
3743                     }
3744                     nextToken();
3745                 }
3746                 JCExpression moduleName = qualident(false);
3747                 accept(SEMI);
3748                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3749             } else if (token.name() == names.exports || token.name() == names.opens) {
3750                 boolean exports = token.name() == names.exports;
3751                 nextToken();
3752                 JCExpression pkgName = qualident(false);
3753                 List&lt;JCExpression&gt; moduleNames = null;
3754                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3755                     nextToken();
3756                     moduleNames = qualidentList(false);
3757                 }
3758                 accept(SEMI);
3759                 JCDirective d;
3760                 if (exports) {
3761                     d = F.at(pos).Exports(pkgName, moduleNames);
3762                 } else {
3763                     d = F.at(pos).Opens(pkgName, moduleNames);
3764                 }
3765                 defs.append(toP(d));
3766             } else if (token.name() == names.provides) {
3767                 nextToken();
3768                 JCExpression serviceName = qualident(false);
3769                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3770                     nextToken();
3771                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3772                     accept(SEMI);
3773                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3774                 } else {
3775                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3776                     skip(false, false, false, false);
3777                 }
3778             } else if (token.name() == names.uses) {
3779                 nextToken();
3780                 JCExpression service = qualident(false);
3781                 accept(SEMI);
3782                 defs.append(toP(F.at(pos).Uses(service)));
3783             } else {
3784                 setErrorEndPos(pos);
3785                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3786                 break;
3787             }
3788         }
3789         return defs.toList();
3790     }
3791 
3792     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3793      */
3794     protected JCTree importDeclaration() {
3795         int pos = token.pos;
3796         nextToken();
3797         boolean importStatic = false;
3798         if (token.kind == STATIC) {
3799             importStatic = true;
3800             nextToken();
3801         }
3802         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3803         do {
3804             int pos1 = token.pos;
3805             accept(DOT);
3806             if (token.kind == STAR) {
3807                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3808                 nextToken();
3809                 break;
3810             } else {
3811                 pid = toP(F.at(pos1).Select(pid, ident()));
3812             }
3813         } while (token.kind == DOT);
3814         accept(SEMI);
3815         return toP(F.at(pos).Import(pid, importStatic));
3816     }
3817 
3818     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3819      *                  | &quot;;&quot;
3820      */
3821     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3822         int pos = token.pos;
3823         if (mods == null &amp;&amp; token.kind == SEMI) {
3824             nextToken();
3825             return toP(F.at(pos).Skip());
3826         } else {
3827             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3828         }
3829     }
3830 
3831     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3832      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3833      *  @param mods     Any modifiers starting the class or interface declaration
3834      *  @param dc       The documentation comment for the class, or null.
3835      */
3836     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3837         if (token.kind == CLASS) {
3838             return classDeclaration(mods, dc);
3839         } if (isRecordStart()) {
3840             return recordDeclaration(mods, dc);
3841         } else if (token.kind == INTERFACE) {
3842             return interfaceDeclaration(mods, dc);
3843         } else if (token.kind == ENUM) {
3844             return enumDeclaration(mods, dc);
3845         } else {
3846             int pos = token.pos;
3847             List&lt;JCTree&gt; errs;
3848             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3849                 checkSourceLevel(Feature.RECORDS);
3850                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3851                 return toP(F.Exec(erroneousTree));
3852             } else {
3853                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3854                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3855                     setErrorEndPos(token.pos);
3856                 } else {
3857                     errs = List.of(mods);
3858                 }
3859                 final JCErroneous erroneousTree;
3860                 if (parseModuleInfo) {
3861                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3862                 } else {
3863                     if (allowRecords) {
3864                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3865                     } else {
3866                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3867                     }
3868                 }
3869                 return toP(F.Exec(erroneousTree));
3870             }
3871         }
3872     }
3873 
3874     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3875      *                     [IMPLEMENTS TypeList] ClassBody
3876      *  @param mods    The modifiers starting the class declaration
3877      *  @param dc       The documentation comment for the class, or null.
3878      */
3879     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3880         int pos = token.pos;
3881         accept(CLASS);
3882         Name name = typeName();
3883 
3884         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3885 
3886         JCExpression extending = null;
3887         if (token.kind == EXTENDS) {
3888             nextToken();
3889             extending = parseType();
3890         }
3891         List&lt;JCExpression&gt; implementing = List.nil();
3892         if (token.kind == IMPLEMENTS) {
3893             nextToken();
3894             implementing = typeList();
3895         }
3896         List&lt;JCExpression&gt; permitting = List.nil();
3897         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {
3898             checkSourceLevel(Feature.SEALED_CLASSES);
3899             if ((mods.flags &amp; Flags.SEALED) == 0) {
3900                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;class&quot;)));
3901             }
3902             nextToken();
3903             permitting = qualidentList(false);
3904         }
3905         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3906         JCClassDecl result = toP(F.at(pos).ClassDef(
3907             mods, name, typarams, extending, implementing, permitting, defs));
3908         attach(result, dc);
3909         return result;
3910     }
3911 
3912     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3913         int pos = token.pos;
3914         nextToken();
3915         mods.flags |= Flags.RECORD;
3916         Name name = typeName();
3917 
3918         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3919 
3920         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3921 
3922         List&lt;JCExpression&gt; implementing = List.nil();
3923         if (token.kind == IMPLEMENTS) {
3924             nextToken();
3925             implementing = typeList();
3926         }
3927         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3928         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3929         for (JCVariableDecl field : headerFields) {
3930             fields.add(field);
3931         }
3932         for (JCTree def : defs) {
3933             if (def.hasTag(METHODDEF)) {
3934                 JCMethodDecl methDef = (JCMethodDecl) def;
3935                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3936                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3937                     for (JCVariableDecl param : headerFields) {
3938                         tmpParams.add(F.at(param)
3939                                 // we will get flags plus annotations from the record component
3940                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3941                                 param.name, param.vartype, null));
3942                     }
3943                     methDef.params = tmpParams.toList();
3944                 }
3945             }
3946         }
3947         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3948             JCVariableDecl field = fields.get(i);
3949             defs = defs.prepend(field);
3950         }
3951         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3952         attach(result, dc);
3953         return result;
3954     }
3955 
3956     Name typeName() {
3957         int pos = token.pos;
3958         Name name = ident();
3959         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3960         if (source != null) {
3961             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3962         }
3963         return name;
3964     }
3965 
3966     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3967      *                         [EXTENDS TypeList] InterfaceBody
3968      *  @param mods    The modifiers starting the interface declaration
3969      *  @param dc       The documentation comment for the interface, or null.
3970      */
3971     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3972         int pos = token.pos;
3973         accept(INTERFACE);
3974 
3975         Name name = typeName();
3976 
3977         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3978 
3979         List&lt;JCExpression&gt; extending = List.nil();
3980         if (token.kind == EXTENDS) {
3981             nextToken();
3982             extending = typeList();
3983         }
3984         List&lt;JCExpression&gt; permitting = List.nil();
3985         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {
3986             checkSourceLevel(Feature.SEALED_CLASSES);
3987             if ((mods.flags &amp; Flags.SEALED) == 0) {
3988                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;interface&quot;)));
3989             }
3990             nextToken();
3991             permitting = typeList();
3992         }
3993         List&lt;JCTree&gt; defs;
3994         defs = classInterfaceOrRecordBody(name, true, false);
3995         JCClassDecl result = toP(F.at(pos).ClassDef(
3996             mods, name, typarams, null, extending, permitting, defs));
3997         attach(result, dc);
3998         return result;
3999     }
4000 
4001     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
4002      *  @param mods    The modifiers starting the enum declaration
4003      *  @param dc       The documentation comment for the enum, or null.
4004      */
4005     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
4006         int pos = token.pos;
4007         accept(ENUM);
4008 
4009         Name name = typeName();
4010 
4011         List&lt;JCExpression&gt; implementing = List.nil();
4012         if (token.kind == IMPLEMENTS) {
4013             nextToken();
4014             implementing = typeList();
4015         }
4016 
4017         List&lt;JCTree&gt; defs = enumBody(name);
4018         mods.flags |= Flags.ENUM;
4019         JCClassDecl result = toP(F.at(pos).
4020             ClassDef(mods, name, List.nil(),
4021                      null, implementing, defs));
4022         attach(result, dc);
4023         return result;
4024     }
4025 
4026     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
4027      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
4028      */
4029     List&lt;JCTree&gt; enumBody(Name enumName) {
4030         accept(LBRACE);
4031         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4032         boolean wasSemi = false;
4033         boolean hasStructuralErrors = false;
4034         boolean wasError = false;
4035         if (token.kind == COMMA) {
4036             nextToken();
4037             if (token.kind == SEMI) {
4038                 wasSemi = true;
4039                 nextToken();
4040             } else if (token.kind != RBRACE) {
4041                 reportSyntaxError(S.prevToken().endPos,
4042                                   Errors.Expected2(RBRACE, SEMI));
4043                 wasError = true;
4044             }
4045         }
4046         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4047             if (token.kind == SEMI) {
4048                 accept(SEMI);
4049                 wasSemi = true;
4050                 if (token.kind == RBRACE || token.kind == EOF) break;
4051             }
4052             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
4053             if (memberType == EnumeratorEstimate.UNKNOWN) {
4054                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
4055                                      : EnumeratorEstimate.ENUMERATOR;
4056             }
4057             if (memberType == EnumeratorEstimate.ENUMERATOR) {
4058                 wasError = false;
4059                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
4060                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
4061                     hasStructuralErrors = true;
4062                 }
4063                 defs.append(enumeratorDeclaration(enumName));
4064                 if (token.pos &lt;= endPosTable.errorEndPos) {
4065                     // error recovery
4066                    skip(false, true, true, false);
4067                 } else {
4068                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
4069                         if (token.kind == COMMA) {
4070                             nextToken();
4071                         } else {
4072                             setErrorEndPos(token.pos);
4073                             reportSyntaxError(S.prevToken().endPos,
4074                                               Errors.Expected3(COMMA, RBRACE, SEMI));
4075                             wasError = true;
4076                         }
4077                     }
4078                 }
4079             } else {
4080                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
4081                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
4082                     hasStructuralErrors = true;
4083                 }
4084                 wasError = false;
4085                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
4086                                                                 false, false));
4087                 if (token.pos &lt;= endPosTable.errorEndPos) {
4088                     // error recovery
4089                    skip(false, true, true, false);
4090                 }
4091             }
4092         }
4093         accept(RBRACE);
4094         return defs.toList();
4095     }
4096 
4097     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
4098         // if we are seeing a record declaration inside of an enum we want the same error message as expected for a
4099         // let&#39;s say an interface declaration inside an enum
4100         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName &amp;&amp;
4101                 (!allowRecords || !isRecordStart())) {
4102             Token next = S.token(1);
4103             switch (next.kind) {
4104                 case LPAREN: case LBRACE: case COMMA: case SEMI:
4105                     return EnumeratorEstimate.ENUMERATOR;
4106             }
4107         }
4108         switch (token.kind) {
4109             case IDENTIFIER: case MONKEYS_AT: case LT:
4110                 if (token.kind == IDENTIFIER) {
4111                     if (allowRecords &amp;&amp; isRecordStart()) {
4112                         return EnumeratorEstimate.MEMBER;
4113                     }
4114                 }
4115                 return EnumeratorEstimate.UNKNOWN;
4116             default:
4117                 return EnumeratorEstimate.MEMBER;
4118         }
4119     }
4120 
4121     private enum EnumeratorEstimate {
4122         ENUMERATOR,
4123         MEMBER,
4124         UNKNOWN;
4125     }
4126 
4127     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
4128      */
4129     JCTree enumeratorDeclaration(Name enumName) {
4130         Comment dc = token.comment(CommentStyle.JAVADOC);
4131         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
4132         if (token.deprecatedFlag()) {
4133             flags |= Flags.DEPRECATED;
4134         }
4135         int pos = token.pos;
4136         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
4137         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
4138         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4139         int identPos = token.pos;
4140         Name name = ident();
4141         int createPos = token.pos;
4142         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4143             ? arguments() : List.nil();
4144         JCClassDecl body = null;
4145         if (token.kind == LBRACE) {
4146             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4147             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4148             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4149         }
4150         if (args.isEmpty() &amp;&amp; body == null)
4151             createPos = identPos;
4152         JCIdent ident = F.at(identPos).Ident(enumName);
4153         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4154         if (createPos != identPos)
4155             storeEnd(create, S.prevToken().endPos);
4156         ident = F.at(identPos).Ident(enumName);
4157         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4158         attach(result, dc);
4159         return result;
4160     }
4161 
4162     /** TypeList = Type {&quot;,&quot; Type}
4163      */
4164     List&lt;JCExpression&gt; typeList() {
4165         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4166         ts.append(parseType());
4167         while (token.kind == COMMA) {
4168             nextToken();
4169             ts.append(parseType());
4170         }
4171         return ts.toList();
4172     }
4173 
4174     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4175      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4176      */
4177     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4178         accept(LBRACE);
4179         if (token.pos &lt;= endPosTable.errorEndPos) {
4180             // error recovery
4181             skip(false, true, false, false);
4182             if (token.kind == LBRACE)
4183                 nextToken();
4184         }
4185         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4186         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4187             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4188             if (token.pos &lt;= endPosTable.errorEndPos) {
4189                // error recovery
4190                skip(false, true, true, false);
4191            }
4192         }
4193         accept(RBRACE);
4194         return defs.toList();
4195     }
4196 
4197     /** ClassBodyDeclaration =
4198      *      &quot;;&quot;
4199      *    | [STATIC] Block
4200      *    | ModifiersOpt
4201      *      ( Type Ident
4202      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4203      *      | VOID Ident VoidMethodDeclaratorRest
4204      *      | TypeParameters [Annotations]
4205      *        ( Type Ident MethodDeclaratorRest
4206      *        | VOID Ident VoidMethodDeclaratorRest
4207      *        )
4208      *      | Ident ConstructorDeclaratorRest
4209      *      | TypeParameters Ident ConstructorDeclaratorRest
4210      *      | ClassOrInterfaceOrEnumDeclaration
4211      *      )
4212      *  InterfaceBodyDeclaration =
4213      *      &quot;;&quot;
4214      *    | ModifiersOpt
4215      *      ( Type Ident
4216      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4217      *      | VOID Ident MethodDeclaratorRest
4218      *      | TypeParameters [Annotations]
4219      *        ( Type Ident MethodDeclaratorRest
4220      *        | VOID Ident VoidMethodDeclaratorRest
4221      *        )
4222      *      | ClassOrInterfaceOrEnumDeclaration
4223      *      )
4224      *
4225      */
4226     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4227         if (token.kind == SEMI) {
4228             nextToken();
4229             return List.nil();
4230         } else {
4231             Comment dc = token.comment(CommentStyle.JAVADOC);
4232             int pos = token.pos;
4233             JCModifiers mods = modifiersOpt();
4234             if (token.kind == CLASS ||
4235                 allowRecords &amp;&amp; isRecordStart() ||
4236                 token.kind == INTERFACE ||
4237                 token.kind == ENUM) {
4238                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4239             } else if (token.kind == LBRACE &amp;&amp;
4240                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4241                        mods.annotations.isEmpty()) {
4242                 if (isInterface) {
4243                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4244                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4245                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4246                 }
4247                 return List.of(block(pos, mods.flags));
4248             } else {
4249                 pos = token.pos;
4250                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4251                 // if there are type parameters but no modifiers, save the start
4252                 // position of the method in the modifiers.
4253                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4254                     mods.pos = pos;
4255                     storeEnd(mods, pos);
4256                 }
4257                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4258 
4259                 if (annosAfterParams.nonEmpty()) {
4260                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4261                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4262                     if (mods.pos == Position.NOPOS)
4263                         mods.pos = mods.annotations.head.pos;
4264                 }
4265 
4266                 Token tk = token;
4267                 pos = token.pos;
4268                 JCExpression type;
4269                 boolean isVoid = token.kind == VOID;
4270                 if (isVoid) {
4271                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4272                     nextToken();
4273                 } else {
4274                     // method returns types are un-annotated types
4275                     type = unannotatedType(false);
4276                 }
4277                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4278                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4279                     if (isInterface || tk.name() != className)
4280                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4281                     else if (annosAfterParams.nonEmpty())
4282                         illegal(annosAfterParams.head.pos);
4283                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4284                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4285                     }
4286                     return List.of(methodDeclaratorRest(
4287                         pos, mods, null, names.init, typarams,
4288                         isInterface, true, isRecord, dc));
4289                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4290                     // trying to define a compact constructor with a throws clause
4291                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4292                             Errors.InvalidCanonicalConstructorInRecord(
4293                                     Fragments.Compact,
4294                                     className,
4295                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4296                     skip(false, true, false, false);
4297                     return List.of(methodDeclaratorRest(
4298                             pos, mods, null, names.init, typarams,
4299                             isInterface, true, isRecord, dc));
4300                 } else {
4301                     pos = token.pos;
4302                     Name name = ident();
4303                     if (token.kind == LPAREN) {
4304                         return List.of(methodDeclaratorRest(
4305                             pos, mods, type, name, typarams,
4306                             isInterface, isVoid, false, dc));
4307                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4308                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4309                         List&lt;JCTree&gt; defs =
4310                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4311                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4312                         accept(SEMI);
4313                         storeEnd(defs.last(), S.prevToken().endPos);
4314                         return defs;
4315                     } else {
4316                             int errPos = pos;
4317                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4318                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4319                             accept(SEMI);
4320                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4321                         }
4322                     } else {
4323                         pos = token.pos;
4324                         List&lt;JCTree&gt; err;
4325                         if (isVoid || typarams.nonEmpty()) {
4326                             JCMethodDecl m =
4327                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4328                                                             List.nil(), List.nil(), null, null));
4329                             attach(m, dc);
4330                             err = List.of(m);
4331                         } else {
4332                             err = List.nil();
4333                         }
4334                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4335                     }
4336                 }
4337             }
4338         }
4339     }
4340 
4341     protected boolean isRecordStart() {
4342         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4343             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4344              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4345              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4346              checkSourceLevel(Feature.RECORDS);
4347             return true;
4348         } else {
4349             return false;
4350         }
4351     }
4352 
4353     protected boolean isNonSealedClassStart(boolean local) {
4354         if (isNonSealedIdentifier(token, 0)) {
4355             Token next = S.token(3);
4356             return allowedAfterSealedOrNonSealed(next, local, true);
4357         }
4358         return false;
4359     }
4360 
4361     protected boolean isNonSealedIdentifier(Token someToken, int lookAheadOffset) {
4362         if (someToken.name() == names.non &amp;&amp; peekToken(lookAheadOffset, TokenKind.SUB, TokenKind.IDENTIFIER)) {
4363             Token tokenSub = S.token(lookAheadOffset + 1);
4364             Token tokenSealed = S.token(lookAheadOffset + 2);
4365             if (someToken.endPos == tokenSub.pos &amp;&amp;
4366                     tokenSub.endPos == tokenSealed.pos &amp;&amp;
4367                     tokenSealed.name() == names.sealed) {
4368                 checkSourceLevel(Feature.SEALED_CLASSES);
4369                 return true;
4370             }
4371         }
4372         return false;
4373     }
4374 
4375     protected boolean isSealedClassStart(boolean local) {
4376         if (token.name() == names.sealed) {
4377             Token next = S.token(1);
4378             if (allowedAfterSealedOrNonSealed(next, local, false)) {
4379                 checkSourceLevel(Feature.SEALED_CLASSES);
4380                 return true;
4381             }
4382         }
4383         return false;
4384     }
4385 
4386     private boolean allowedAfterSealedOrNonSealed(Token next, boolean local, boolean currentIsNonSealed) {
4387         return local ?
4388             switch (next.kind) {
4389                 case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;
4390                 default -&gt; false;
4391             } :
4392             switch (next.kind) {
4393                 case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;
4394                 case IDENTIFIER -&gt; isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;
4395                 default -&gt; false;
4396             };
4397     }
4398 
4399     /** MethodDeclaratorRest =
4400      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4401      *  VoidMethodDeclaratorRest =
4402      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4403      *  ConstructorDeclaratorRest =
4404      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4405      */
4406     protected JCTree methodDeclaratorRest(int pos,
4407                               JCModifiers mods,
4408                               JCExpression type,
4409                               Name name,
4410                               List&lt;JCTypeParameter&gt; typarams,
4411                               boolean isInterface, boolean isVoid,
4412                               boolean isRecord,
4413                               Comment dc) {
4414         if (isInterface) {
4415             if ((mods.flags &amp; Flags.STATIC) != 0) {
4416                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4417             }
4418             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4419                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4420             }
4421         }
4422         JCVariableDecl prevReceiverParam = this.receiverParam;
4423         try {
4424             this.receiverParam = null;
4425             // Parsing formalParameters sets the receiverParam, if present
4426             List&lt;JCVariableDecl&gt; params = List.nil();
4427             List&lt;JCExpression&gt; thrown = List.nil();
4428             if (!isRecord || name != names.init || token.kind == LPAREN) {
4429                 params = formalParameters();
4430                 if (!isVoid) type = bracketsOpt(type);
4431                 if (token.kind == THROWS) {
4432                     nextToken();
4433                     thrown = qualidentList(true);
4434                 }
4435             }
4436             JCBlock body = null;
4437             JCExpression defaultValue;
4438             if (token.kind == LBRACE) {
4439                 body = block();
4440                 defaultValue = null;
4441             } else {
4442                 if (token.kind == DEFAULT) {
4443                     accept(DEFAULT);
4444                     defaultValue = annotationValue();
4445                 } else {
4446                     defaultValue = null;
4447                 }
4448                 accept(SEMI);
4449                 if (token.pos &lt;= endPosTable.errorEndPos) {
4450                     // error recovery
4451                     skip(false, true, false, false);
4452                     if (token.kind == LBRACE) {
4453                         body = block();
4454                     }
4455                 }
4456             }
4457 
4458             JCMethodDecl result =
4459                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4460                                             receiverParam, params, thrown,
4461                                             body, defaultValue));
4462             attach(result, dc);
4463             return result;
4464         } finally {
4465             this.receiverParam = prevReceiverParam;
4466         }
4467     }
4468 
4469     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4470      */
4471     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4472         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4473 
4474         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4475         JCExpression qi = qualident(allowAnnos);
4476         if (!typeAnnos.isEmpty()) {
4477             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4478             ts.append(at);
4479         } else {
4480             ts.append(qi);
4481         }
4482         while (token.kind == COMMA) {
4483             nextToken();
4484 
4485             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4486             qi = qualident(allowAnnos);
4487             if (!typeAnnos.isEmpty()) {
4488                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4489                 ts.append(at);
4490             } else {
4491                 ts.append(qi);
4492             }
4493         }
4494         return ts.toList();
4495     }
4496 
4497     /**
4498      *  {@literal
4499      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4500      *  }
4501      */
4502     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4503         if (token.kind == LT) {
4504             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4505             nextToken();
4506             typarams.append(typeParameter());
4507             while (token.kind == COMMA) {
4508                 nextToken();
4509                 typarams.append(typeParameter());
4510             }
4511             accept(GT);
4512             return typarams.toList();
4513         } else {
4514             return List.nil();
4515         }
4516     }
4517 
4518     /**
4519      *  {@literal
4520      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4521      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4522      *  TypeVariable = Ident
4523      *  }
4524      */
4525     JCTypeParameter typeParameter() {
4526         int pos = token.pos;
4527         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4528         Name name = typeName();
4529         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4530         if (token.kind == EXTENDS) {
4531             nextToken();
4532             bounds.append(parseType());
4533             while (token.kind == AMP) {
4534                 nextToken();
4535                 bounds.append(parseType());
4536             }
4537         }
4538         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4539     }
4540 
4541     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4542      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4543      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4544      */
4545     List&lt;JCVariableDecl&gt; formalParameters() {
4546         return formalParameters(false, false);
4547     }
4548     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4549         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4550         JCVariableDecl lastParam;
4551         accept(LPAREN);
4552         if (token.kind != RPAREN) {
4553             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4554             lastParam = formalParameter(lambdaParameters, recordComponents);
4555             if (lastParam.nameexpr != null) {
4556                 this.receiverParam = lastParam;
4557             } else {
4558                 params.append(lastParam);
4559             }
4560             this.allowThisIdent = false;
4561             while (token.kind == COMMA) {
4562                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4563                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4564                 }
4565                 nextToken();
4566                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4567             }
4568         }
4569         if (token.kind == RPAREN) {
4570             nextToken();
4571         } else {
4572             setErrorEndPos(token.pos);
4573             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4574         }
4575         return params.toList();
4576     }
4577 
4578     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4579         if (hasParens) {
4580             accept(LPAREN);
4581         }
4582         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4583         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4584             params.append(implicitParameter());
4585             while (token.kind == COMMA) {
4586                 nextToken();
4587                 params.append(implicitParameter());
4588             }
4589         }
4590         if (hasParens) {
4591             accept(RPAREN);
4592         }
4593         return params.toList();
4594     }
4595 
4596     JCModifiers optFinal(long flags) {
4597         JCModifiers mods = modifiersOpt();
4598         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4599         mods.flags |= flags;
4600         return mods;
4601     }
4602 
4603     /**
4604      * Inserts the annotations (and possibly a new array level)
4605      * to the left-most type in an array or nested type.
4606      *
4607      * When parsing a type like {@code @B Outer.Inner @A []}, the
4608      * {@code @A} annotation should target the array itself, while
4609      * {@code @B} targets the nested type {@code Outer}.
4610      *
4611      * Currently the parser parses the annotation first, then
4612      * the array, and then inserts the annotation to the left-most
4613      * nested type.
4614      *
4615      * When {@code createNewLevel} is true, then a new array
4616      * level is inserted as the most inner type, and have the
4617      * annotations target it.  This is useful in the case of
4618      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4619      * first parses the type {@code String @A []} then inserts
4620      * a new array level with {@code @B} annotation.
4621      */
4622     private JCExpression insertAnnotationsToMostInner(
4623             JCExpression type, List&lt;JCAnnotation&gt; annos,
4624             boolean createNewLevel) {
4625         int origEndPos = getEndPos(type);
4626         JCExpression mostInnerType = type;
4627         JCArrayTypeTree mostInnerArrayType = null;
4628         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4629             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4630             mostInnerType = mostInnerArrayType.elemtype;
4631         }
4632 
4633         if (createNewLevel) {
4634             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4635         }
4636 
4637         JCExpression mostInnerTypeToReturn = mostInnerType;
4638         if (annos.nonEmpty()) {
4639             JCExpression lastToModify = mostInnerType;
4640 
4641             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4642                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4643                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4644                     lastToModify = mostInnerType;
4645                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4646                 }
4647                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4648                     lastToModify = mostInnerType;
4649                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4650                 }
4651             }
4652 
4653             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4654 
4655             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4656                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4657             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4658                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4659             } else {
4660                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4661                 mostInnerTypeToReturn = mostInnerType;
4662             }
4663         }
4664 
4665         if (mostInnerArrayType == null) {
4666             return mostInnerTypeToReturn;
4667         } else {
4668             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4669             storeEnd(type, origEndPos);
4670             return type;
4671         }
4672     }
4673 
4674     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4675      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4676      */
4677     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4678         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4679         if (recordComponent &amp;&amp; mods.flags != 0) {
4680             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4681         }
4682         if (recordComponent) {
4683             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4684         }
4685         // need to distinguish between vararg annos and array annos
4686         // look at typeAnnotationsPushedBack comment
4687         this.permitTypeAnnotationsPushBack = true;
4688         JCExpression type = parseType(lambdaParameter);
4689         this.permitTypeAnnotationsPushBack = false;
4690 
4691         if (token.kind == ELLIPSIS) {
4692             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4693             typeAnnotationsPushedBack = List.nil();
4694             mods.flags |= Flags.VARARGS;
4695             // insert var arg type annotations
4696             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4697             nextToken();
4698         } else {
4699             // if not a var arg, then typeAnnotationsPushedBack should be null
4700             if (typeAnnotationsPushedBack.nonEmpty()) {
4701                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4702             }
4703             typeAnnotationsPushedBack = List.nil();
4704         }
4705         return variableDeclaratorId(mods, type, lambdaParameter);
4706     }
4707 
4708     protected JCVariableDecl implicitParameter() {
4709         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4710         return variableDeclaratorId(mods, null, true);
4711     }
4712 
4713 /* ---------- auxiliary methods -------------- */
4714     /** Check that given tree is a legal expression statement.
4715      */
4716     protected JCExpression checkExprStat(JCExpression t) {
4717         if (!TreeInfo.isExpressionStatement(t)) {
4718             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4719             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4720             return ret;
4721         } else {
4722             return t;
4723         }
4724     }
4725 
4726     /** Return precedence of operator represented by token,
4727      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4728      */
4729     static int prec(TokenKind token) {
4730         JCTree.Tag oc = optag(token);
4731         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4732     }
4733 
4734     /**
4735      * Return the lesser of two positions, making allowance for either one
4736      * being unset.
4737      */
4738     static int earlier(int pos1, int pos2) {
4739         if (pos1 == Position.NOPOS)
4740             return pos2;
4741         if (pos2 == Position.NOPOS)
4742             return pos1;
4743         return (pos1 &lt; pos2 ? pos1 : pos2);
4744     }
4745 
4746     /** Return operation tag of binary operator represented by token,
4747      *  No_TAG if token is not a binary operator.
4748      */
4749     static JCTree.Tag optag(TokenKind token) {
4750         switch (token) {
4751         case BARBAR:
4752             return OR;
4753         case AMPAMP:
4754             return AND;
4755         case BAR:
4756             return BITOR;
4757         case BAREQ:
4758             return BITOR_ASG;
4759         case CARET:
4760             return BITXOR;
4761         case CARETEQ:
4762             return BITXOR_ASG;
4763         case AMP:
4764             return BITAND;
4765         case AMPEQ:
4766             return BITAND_ASG;
4767         case EQEQ:
4768             return JCTree.Tag.EQ;
4769         case BANGEQ:
4770             return NE;
4771         case LT:
4772             return JCTree.Tag.LT;
4773         case GT:
4774             return JCTree.Tag.GT;
4775         case LTEQ:
4776             return LE;
4777         case GTEQ:
4778             return GE;
4779         case LTLT:
4780             return SL;
4781         case LTLTEQ:
4782             return SL_ASG;
4783         case GTGT:
4784             return SR;
4785         case GTGTEQ:
4786             return SR_ASG;
4787         case GTGTGT:
4788             return USR;
4789         case GTGTGTEQ:
4790             return USR_ASG;
4791         case PLUS:
4792             return JCTree.Tag.PLUS;
4793         case PLUSEQ:
4794             return PLUS_ASG;
4795         case SUB:
4796             return MINUS;
4797         case SUBEQ:
4798             return MINUS_ASG;
4799         case STAR:
4800             return MUL;
4801         case STAREQ:
4802             return MUL_ASG;
4803         case SLASH:
4804             return DIV;
4805         case SLASHEQ:
4806             return DIV_ASG;
4807         case PERCENT:
4808             return MOD;
4809         case PERCENTEQ:
4810             return MOD_ASG;
4811         case INSTANCEOF:
4812             return TYPETEST;
4813         default:
4814             return NO_TAG;
4815         }
4816     }
4817 
4818     /** Return operation tag of unary operator represented by token,
4819      *  No_TAG if token is not a binary operator.
4820      */
4821     static JCTree.Tag unoptag(TokenKind token) {
4822         switch (token) {
4823         case PLUS:
4824             return POS;
4825         case SUB:
4826             return NEG;
4827         case BANG:
4828             return NOT;
4829         case TILDE:
4830             return COMPL;
4831         case PLUSPLUS:
4832             return PREINC;
4833         case SUBSUB:
4834             return PREDEC;
4835         default:
4836             return NO_TAG;
4837         }
4838     }
4839 
4840     /** Return type tag of basic type represented by token,
4841      *  NONE if token is not a basic type identifier.
4842      */
4843     static TypeTag typetag(TokenKind token) {
4844         switch (token) {
4845         case BYTE:
4846             return TypeTag.BYTE;
4847         case CHAR:
4848             return TypeTag.CHAR;
4849         case SHORT:
4850             return TypeTag.SHORT;
4851         case INT:
4852             return TypeTag.INT;
4853         case LONG:
4854             return TypeTag.LONG;
4855         case FLOAT:
4856             return TypeTag.FLOAT;
4857         case DOUBLE:
4858             return TypeTag.DOUBLE;
4859         case BOOLEAN:
4860             return TypeTag.BOOLEAN;
4861         default:
4862             return TypeTag.NONE;
4863         }
4864     }
4865 
4866     void checkSourceLevel(Feature feature) {
4867         checkSourceLevel(token.pos, feature);
4868     }
4869 
4870     protected void checkSourceLevel(int pos, Feature feature) {
4871         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4872             //preview feature without --preview flag, error
4873             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4874         } else if (!feature.allowedInSource(source)) {
4875             //incompatible source level, error
4876             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4877         } else if (preview.isPreview(feature)) {
4878             //use of preview feature, warn
4879             preview.warnPreview(pos, feature);
4880         }
4881     }
4882 
4883     /*
4884      * a functional source tree and end position mappings
4885      */
4886     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4887 
4888         private final IntHashTable endPosMap;
4889 
4890         SimpleEndPosTable(JavacParser parser) {
4891             super(parser);
4892             endPosMap = new IntHashTable();
4893         }
4894 
4895         public void storeEnd(JCTree tree, int endpos) {
4896             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4897                                  endPosMap.lookup(tree));
4898         }
4899 
4900         protected &lt;T extends JCTree&gt; T to(T t) {
4901             storeEnd(t, parser.token.endPos);
4902             return t;
4903         }
4904 
4905         protected &lt;T extends JCTree&gt; T toP(T t) {
4906             storeEnd(t, parser.S.prevToken().endPos);
4907             return t;
4908         }
4909 
4910         public int getEndPos(JCTree tree) {
4911             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4912             // As long as Position.NOPOS==-1, this just returns value.
4913             return (value == -1) ? Position.NOPOS : value;
4914         }
4915 
4916         public int replaceTree(JCTree oldTree, JCTree newTree) {
4917             int pos = endPosMap.remove(oldTree);
4918             if (pos != -1) {
4919                 storeEnd(newTree, pos);
4920                 return pos;
4921             }
4922             return Position.NOPOS;
4923         }
4924     }
4925 
4926     /*
4927      * a default skeletal implementation without any mapping overhead.
4928      */
4929     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4930 
4931         EmptyEndPosTable(JavacParser parser) {
4932             super(parser);
4933         }
4934 
4935         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4936 
4937         protected &lt;T extends JCTree&gt; T to(T t) {
4938             return t;
4939         }
4940 
4941         protected &lt;T extends JCTree&gt; T toP(T t) {
4942             return t;
4943         }
4944 
4945         public int getEndPos(JCTree tree) {
4946             return Position.NOPOS;
4947         }
4948 
4949         public int replaceTree(JCTree oldTree, JCTree newTree) {
4950             return Position.NOPOS;
4951         }
4952 
4953     }
4954 
4955     protected static abstract class AbstractEndPosTable implements EndPosTable {
4956         /**
4957          * The current parser.
4958          */
4959         protected JavacParser parser;
4960 
4961         /**
4962          * Store the last error position.
4963          */
4964         public int errorEndPos = Position.NOPOS;
4965 
4966         public AbstractEndPosTable(JavacParser parser) {
4967             this.parser = parser;
4968         }
4969 
4970         /**
4971          * Store current token&#39;s ending position for a tree, the value of which
4972          * will be the greater of last error position and the ending position of
4973          * the current token.
4974          * @param t The tree.
4975          */
4976         protected abstract &lt;T extends JCTree&gt; T to(T t);
4977 
4978         /**
4979          * Store current token&#39;s ending position for a tree, the value of which
4980          * will be the greater of last error position and the ending position of
4981          * the previous token.
4982          * @param t The tree.
4983          */
4984         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4985 
4986         /**
4987          * Set the error position during the parsing phases, the value of which
4988          * will be set only if it is greater than the last stored error position.
4989          * @param errPos The error position
4990          */
4991         public void setErrorEndPos(int errPos) {
4992             if (errPos &gt; errorEndPos) {
4993                 errorEndPos = errPos;
4994             }
4995         }
4996 
4997         public void setParser(JavacParser parser) {
4998             this.parser = parser;
4999         }
5000     }
5001 }
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>