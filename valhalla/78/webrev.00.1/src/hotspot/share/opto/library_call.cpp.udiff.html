<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arraycopynode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -51,10 +51,11 @@</span>
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;prims/nativeLookup.hpp&quot;
  #include &quot;prims/unsafe.hpp&quot;
  #include &quot;runtime/objectMonitor.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,13 +133,21 @@</span>
    bool  try_to_inline(int predicate);
    Node* try_to_predicate(int predicate);
  
    void push_result() {
      // Push the result onto the stack.
<span class="udiff-line-modified-removed">-     if (!stopped() &amp;&amp; result() != NULL) {</span>
<span class="udiff-line-modified-removed">-       BasicType bt = result()-&gt;bottom_type()-&gt;basic_type();</span>
<span class="udiff-line-modified-removed">-       push_node(bt, result());</span>
<span class="udiff-line-modified-added">+     Node* res = result();</span>
<span class="udiff-line-modified-added">+     if (!stopped() &amp;&amp; res != NULL) {</span>
<span class="udiff-line-modified-added">+       BasicType bt = res-&gt;bottom_type()-&gt;basic_type();</span>
<span class="udiff-line-added">+       if (C-&gt;inlining_incrementally() &amp;&amp; res-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+         // The caller expects an oop when incrementally inlining an intrinsic that returns an</span>
<span class="udiff-line-added">+         // inline type. Make sure the call is re-executed if the allocation triggers a deoptimization.</span>
<span class="udiff-line-added">+         PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+         jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+         res = ValueTypePtrNode::make_from_value_type(this, res-&gt;as_ValueType());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       push_node(bt, res);</span>
      }
    }
  
   private:
    void fatal_unexpected_iid(vmIntrinsics::ID iid) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,11 +171,10 @@</span>
                               Node* array_length,
                               RegionNode* region);
    void  generate_string_range_check(Node* array, Node* offset,
                                      Node* length, bool char_count);
    Node* generate_current_thread(Node* &amp;tls_output);
<span class="udiff-line-removed">-   Node* load_mirror_from_klass(Node* klass);</span>
    Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
                                        RegionNode* region, int null_path,
                                        int offset);
    Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
                                 RegionNode* region, int null_path) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,25 +192,43 @@</span>
    }
    Node* generate_access_flags_guard(Node* kls,
                                      int modifier_mask, int modifier_bits,
                                      RegionNode* region);
    Node* generate_interface_guard(Node* kls, RegionNode* region);
<span class="udiff-line-added">+   Node* generate_value_guard(Node* kls, RegionNode* region);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   enum ArrayKind {</span>
<span class="udiff-line-added">+     AnyArray,</span>
<span class="udiff-line-added">+     NonArray,</span>
<span class="udiff-line-added">+     ObjectArray,</span>
<span class="udiff-line-added">+     NonObjectArray,</span>
<span class="udiff-line-added">+     TypeArray,</span>
<span class="udiff-line-added">+     ValueArray</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
    Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
<span class="udiff-line-added">+ </span>
    Node* generate_array_guard(Node* kls, RegionNode* region) {
<span class="udiff-line-modified-removed">-     return generate_array_guard_common(kls, region, false, false);</span>
<span class="udiff-line-modified-added">+     return generate_array_guard_common(kls, region, AnyArray);</span>
    }
    Node* generate_non_array_guard(Node* kls, RegionNode* region) {
<span class="udiff-line-modified-removed">-     return generate_array_guard_common(kls, region, false, true);</span>
<span class="udiff-line-modified-added">+     return generate_array_guard_common(kls, region, NonArray);</span>
    }
    Node* generate_objArray_guard(Node* kls, RegionNode* region) {
<span class="udiff-line-modified-removed">-     return generate_array_guard_common(kls, region, true, false);</span>
<span class="udiff-line-modified-added">+     return generate_array_guard_common(kls, region, ObjectArray);</span>
    }
    Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
<span class="udiff-line-modified-removed">-     return generate_array_guard_common(kls, region, true, true);</span>
<span class="udiff-line-modified-added">+     return generate_array_guard_common(kls, region, NonObjectArray);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Node* generate_typeArray_guard(Node* kls, RegionNode* region) {</span>
<span class="udiff-line-added">+     return generate_array_guard_common(kls, region, TypeArray);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Node* generate_valueArray_guard(Node* kls, RegionNode* region) {</span>
<span class="udiff-line-added">+     assert(ValueArrayFlatten, &quot;can never be flattened&quot;);</span>
<span class="udiff-line-added">+     return generate_array_guard_common(kls, region, ValueArray);</span>
    }
<span class="udiff-line-modified-removed">-   Node* generate_array_guard_common(Node* kls, RegionNode* region,</span>
<span class="udiff-line-removed">-                                     bool obj_array, bool not_array);</span>
<span class="udiff-line-modified-added">+   Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);</span>
    Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
    CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
                                       bool is_virtual = false, bool is_static = false);
    CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {
      return generate_method_call(method_id, false, true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -256,10 +282,12 @@</span>
    bool inline_unsafe_allocate();
    bool inline_unsafe_newArray(bool uninitialized);
    bool inline_unsafe_writeback0();
    bool inline_unsafe_writebackSync0(bool is_pre);
    bool inline_unsafe_copyMemory();
<span class="udiff-line-added">+   bool inline_unsafe_make_private_buffer();</span>
<span class="udiff-line-added">+   bool inline_unsafe_finish_private_buffer();</span>
    bool inline_native_currentThread();
  
    bool inline_native_time_funcs(address method, const char* funcName);
  #ifdef JFR_HAVE_INTRINSICS
    bool inline_native_classID();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -600,29 +628,33 @@</span>
    case vmIntrinsics::_compressStringC:
    case vmIntrinsics::_compressStringB:          return inline_string_copy( is_compress);
    case vmIntrinsics::_inflateStringC:
    case vmIntrinsics::_inflateStringB:           return inline_string_copy(!is_compress);
  
<span class="udiff-line-added">+   case vmIntrinsics::_makePrivateBuffer:        return inline_unsafe_make_private_buffer();</span>
<span class="udiff-line-added">+   case vmIntrinsics::_finishPrivateBuffer:      return inline_unsafe_finish_private_buffer();</span>
    case vmIntrinsics::_getReference:             return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false);
    case vmIntrinsics::_getBoolean:               return inline_unsafe_access(!is_store, T_BOOLEAN,  Relaxed, false);
    case vmIntrinsics::_getByte:                  return inline_unsafe_access(!is_store, T_BYTE,     Relaxed, false);
    case vmIntrinsics::_getShort:                 return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, false);
    case vmIntrinsics::_getChar:                  return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, false);
    case vmIntrinsics::_getInt:                   return inline_unsafe_access(!is_store, T_INT,      Relaxed, false);
    case vmIntrinsics::_getLong:                  return inline_unsafe_access(!is_store, T_LONG,     Relaxed, false);
    case vmIntrinsics::_getFloat:                 return inline_unsafe_access(!is_store, T_FLOAT,    Relaxed, false);
    case vmIntrinsics::_getDouble:                return inline_unsafe_access(!is_store, T_DOUBLE,   Relaxed, false);
<span class="udiff-line-added">+   case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_VALUETYPE,Relaxed, false);</span>
  
    case vmIntrinsics::_putReference:             return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false);
    case vmIntrinsics::_putBoolean:               return inline_unsafe_access( is_store, T_BOOLEAN,  Relaxed, false);
    case vmIntrinsics::_putByte:                  return inline_unsafe_access( is_store, T_BYTE,     Relaxed, false);
    case vmIntrinsics::_putShort:                 return inline_unsafe_access( is_store, T_SHORT,    Relaxed, false);
    case vmIntrinsics::_putChar:                  return inline_unsafe_access( is_store, T_CHAR,     Relaxed, false);
    case vmIntrinsics::_putInt:                   return inline_unsafe_access( is_store, T_INT,      Relaxed, false);
    case vmIntrinsics::_putLong:                  return inline_unsafe_access( is_store, T_LONG,     Relaxed, false);
    case vmIntrinsics::_putFloat:                 return inline_unsafe_access( is_store, T_FLOAT,    Relaxed, false);
    case vmIntrinsics::_putDouble:                return inline_unsafe_access( is_store, T_DOUBLE,   Relaxed, false);
<span class="udiff-line-added">+   case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_VALUETYPE,Relaxed, false);</span>
  
    case vmIntrinsics::_getReferenceVolatile:     return inline_unsafe_access(!is_store, T_OBJECT,   Volatile, false);
    case vmIntrinsics::_getBooleanVolatile:       return inline_unsafe_access(!is_store, T_BOOLEAN,  Volatile, false);
    case vmIntrinsics::_getByteVolatile:          return inline_unsafe_access(!is_store, T_BYTE,     Volatile, false);
    case vmIntrinsics::_getShortVolatile:         return inline_unsafe_access(!is_store, T_SHORT,    Volatile, false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2394,22 +2426,22 @@</span>
      ciSignature* sig = callee()-&gt;signature();
  #ifdef ASSERT
      if (!is_store) {
        // Object getReference(Object base, int/long offset), etc.
        BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
<span class="udiff-line-modified-removed">-       assert(rtype == type, &quot;getter must return the expected value&quot;);</span>
<span class="udiff-line-modified-removed">-       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);</span>
<span class="udiff-line-modified-added">+       assert(rtype == type || (rtype == T_OBJECT &amp;&amp; type == T_VALUETYPE), &quot;getter must return the expected value&quot;);</span>
<span class="udiff-line-modified-added">+       assert(sig-&gt;count() == 2 || (type == T_VALUETYPE &amp;&amp; sig-&gt;count() == 3), &quot;oop getter has 2 or 3 arguments&quot;);</span>
        assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
        assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
      } else {
        // void putReference(Object base, int/long offset, Object x), etc.
        assert(sig-&gt;return_type()-&gt;basic_type() == T_VOID, &quot;putter must not return a value&quot;);
<span class="udiff-line-modified-removed">-       assert(sig-&gt;count() == 3, &quot;oop putter has 3 arguments&quot;);</span>
<span class="udiff-line-modified-added">+       assert(sig-&gt;count() == 3 || (type == T_VALUETYPE &amp;&amp; sig-&gt;count() == 4), &quot;oop putter has 3 arguments&quot;);</span>
        assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;putter base is object&quot;);
        assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;putter offset is correct&quot;);
        BasicType vtype = sig-&gt;type_at(sig-&gt;count()-1)-&gt;basic_type();
<span class="udiff-line-modified-removed">-       assert(vtype == type, &quot;putter must accept the expected value&quot;);</span>
<span class="udiff-line-modified-added">+       assert(vtype == type || (type == T_VALUETYPE &amp;&amp; vtype == T_OBJECT), &quot;putter must accept the expected value&quot;);</span>
      }
  #endif // ASSERT
   }
  #endif //PRODUCT
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2430,16 +2462,79 @@</span>
    // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
    // to be plain byte offsets, which are also the same as those accepted
    // by oopDesc::field_addr.
    assert(Unsafe_field_offset_to_byte_offset(11) == 11,
           &quot;fieldOffset must be byte-scaled&quot;);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ciValueKlass* value_klass = NULL;</span>
<span class="udiff-line-added">+   if (type == T_VALUETYPE) {</span>
<span class="udiff-line-added">+     Node* cls = null_check(argument(4));</span>
<span class="udiff-line-added">+     if (stopped()) {</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Node* kls = load_klass_from_mirror(cls, false, NULL, 0);</span>
<span class="udiff-line-added">+     const TypeKlassPtr* kls_t = _gvn.type(kls)-&gt;isa_klassptr();</span>
<span class="udiff-line-added">+     if (!kls_t-&gt;klass_is_exact()) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ciKlass* klass = kls_t-&gt;klass();</span>
<span class="udiff-line-added">+     if (!klass-&gt;is_valuetype()) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     value_klass = klass-&gt;as_value_klass();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   receiver = null_check(receiver);</span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (base-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     ValueTypeNode* vt = base-&gt;as_ValueType();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (is_store) {</span>
<span class="udiff-line-added">+       if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_valuetype()-&gt;larval()) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       base = vt-&gt;get_oop();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       if (offset-&gt;is_Con()) {</span>
<span class="udiff-line-added">+         long off = find_long_con(offset, 0);</span>
<span class="udiff-line-added">+         ciValueKlass* vk = vt-&gt;type()-&gt;value_klass();</span>
<span class="udiff-line-added">+         if ((long)(int)off != off || !vk-&gt;contains_field_offset(off)) {</span>
<span class="udiff-line-added">+           return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ciField* f = vk-&gt;get_non_flattened_field_by_offset((int)off);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (f != NULL) {</span>
<span class="udiff-line-added">+           BasicType bt = f-&gt;layout_type();</span>
<span class="udiff-line-added">+           if (bt == T_ARRAY || bt == T_NARROWOOP) {</span>
<span class="udiff-line-added">+             bt = T_OBJECT;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           if (bt == type) {</span>
<span class="udiff-line-added">+             if (bt != T_VALUETYPE || f-&gt;type() == value_klass) {</span>
<span class="udiff-line-added">+               set_result(vt-&gt;field_value_by_offset((int)off, false));</span>
<span class="udiff-line-added">+               return true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       // Re-execute the unsafe access if allocation triggers deoptimization.</span>
<span class="udiff-line-added">+       PreserveReexecuteState preexecs(this);</span>
<span class="udiff-line-added">+       jvms()-&gt;set_should_reexecute(true);</span>
<span class="udiff-line-added">+       vt = vt-&gt;allocate(this)-&gt;as_ValueType();</span>
<span class="udiff-line-added">+       base = vt-&gt;get_oop();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // 32-bit machines ignore the high half!
    offset = ConvL2X(offset);
    adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
  
    if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {
<span class="udiff-line-modified-removed">-     if (type != T_OBJECT) {</span>
<span class="udiff-line-modified-added">+     if (type != T_OBJECT &amp;&amp; (value_klass == NULL || !value_klass-&gt;has_object_fields())) {</span>
        decorators |= IN_NATIVE; // off-heap primitive access
      } else {
        return false; // off-heap oop accesses are not supported
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2451,11 +2546,11 @@</span>
  
    if (!can_access_non_heap) {
      decorators |= IN_HEAP;
    }
  
<span class="udiff-line-modified-removed">-   val = is_store ? argument(4) : NULL;</span>
<span class="udiff-line-modified-added">+   val = is_store ? argument(4 + (type == T_VALUETYPE ? 1 : 0)) : NULL;</span>
  
    const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();
    if (adr_type == TypePtr::NULL_PTR) {
      return false; // off-heap access with zero address
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2468,11 +2563,35 @@</span>
        alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
      return false; // not supported
    }
  
    bool mismatched = false;
<span class="udiff-line-modified-removed">-   BasicType bt = alias_type-&gt;basic_type();</span>
<span class="udiff-line-modified-added">+   BasicType bt = T_ILLEGAL;</span>
<span class="udiff-line-added">+   ciField* field = NULL;</span>
<span class="udiff-line-added">+   if (adr_type-&gt;isa_instptr()) {</span>
<span class="udiff-line-added">+     const TypeInstPtr* instptr = adr_type-&gt;is_instptr();</span>
<span class="udiff-line-added">+     ciInstanceKlass* k = instptr-&gt;klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+     int off = instptr-&gt;offset();</span>
<span class="udiff-line-added">+     if (instptr-&gt;const_oop() != NULL &amp;&amp;</span>
<span class="udiff-line-added">+         instptr-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="udiff-line-added">+         instptr-&gt;offset() &gt;= (instptr-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {</span>
<span class="udiff-line-added">+       k = instptr-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+       field = k-&gt;get_field_by_offset(off, true);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       field = k-&gt;get_non_flattened_field_by_offset(off);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (field != NULL) {</span>
<span class="udiff-line-added">+       bt = field-&gt;layout_type();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     assert(bt == alias_type-&gt;basic_type() || bt == T_VALUETYPE, &quot;should match&quot;);</span>
<span class="udiff-line-added">+     if (field != NULL &amp;&amp; bt == T_VALUETYPE &amp;&amp; !field-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+       bt = T_OBJECT;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     bt = alias_type-&gt;basic_type();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (bt != T_ILLEGAL) {
      assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
      if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
        // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
        // Use address type to get the element type.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2489,10 +2608,31 @@</span>
      mismatched = (bt != type);
    } else if (alias_type-&gt;adr_type()-&gt;isa_oopptr()) {
      mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
    }
  
<span class="udiff-line-added">+   if (type == T_VALUETYPE) {</span>
<span class="udiff-line-added">+     if (adr_type-&gt;isa_instptr()) {</span>
<span class="udiff-line-added">+       if (field == NULL || field-&gt;type() != value_klass) {</span>
<span class="udiff-line-added">+         mismatched = true;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (adr_type-&gt;isa_aryptr()) {</span>
<span class="udiff-line-added">+       const Type* elem = adr_type-&gt;is_aryptr()-&gt;elem();</span>
<span class="udiff-line-added">+       if (!elem-&gt;isa_valuetype()) {</span>
<span class="udiff-line-added">+         mismatched = true;</span>
<span class="udiff-line-added">+       } else if (elem-&gt;value_klass() != value_klass) {</span>
<span class="udiff-line-added">+         mismatched = true;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (is_store) {</span>
<span class="udiff-line-added">+       const Type* val_t = _gvn.type(val);</span>
<span class="udiff-line-added">+       if (!val_t-&gt;isa_valuetype() || val_t-&gt;value_klass() != value_klass) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    assert(!mismatched || alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;off-heap access can&#39;t be mismatched&quot;);
  
    if (mismatched) {
      decorators |= C2_MISMATCHED;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2501,37 +2641,47 @@</span>
    const Type *value_type = Type::get_const_basic_type(type);
  
    // Figure out the memory ordering.
    decorators |= mo_decorator_for_access_kind(kind);
  
<span class="udiff-line-modified-removed">-   if (!is_store &amp;&amp; type == T_OBJECT) {</span>
<span class="udiff-line-modified-removed">-     const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);</span>
<span class="udiff-line-modified-removed">-     if (tjp != NULL) {</span>
<span class="udiff-line-modified-removed">-       value_type = tjp;</span>
<span class="udiff-line-modified-added">+   if (!is_store) {</span>
<span class="udiff-line-modified-added">+     if (type == T_OBJECT) {</span>
<span class="udiff-line-modified-added">+       const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);</span>
<span class="udiff-line-modified-added">+       if (tjp != NULL) {</span>
<span class="udiff-line-added">+         value_type = tjp;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (type == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       value_type = NULL;</span>
      }
    }
  
<span class="udiff-line-removed">-   receiver = null_check(receiver);</span>
<span class="udiff-line-removed">-   if (stopped()) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
    // Heap pointers get a null-check from the interpreter,
    // as a courtesy.  However, this is not guaranteed by Unsafe,
    // and it is not possible to fully distinguish unintended nulls
    // from intended ones in this API.
  
    if (!is_store) {
      Node* p = NULL;
      // Try to constant fold a load from a constant field
<span class="udiff-line-modified-removed">-     ciField* field = alias_type-&gt;field();</span>
<span class="udiff-line-modified-added">+ </span>
      if (heap_base_oop != top() &amp;&amp; field != NULL &amp;&amp; field-&gt;is_constant() &amp;&amp; !mismatched) {
        // final or stable field
        p = make_constant_from_field(field, heap_base_oop);
      }
  
      if (p == NULL) { // Could not constant fold the load
<span class="udiff-line-modified-removed">-       p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);</span>
<span class="udiff-line-modified-added">+       if (type == T_VALUETYPE) {</span>
<span class="udiff-line-added">+         if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {</span>
<span class="udiff-line-added">+           ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+           int offset = adr_type-&gt;is_instptr()-&gt;offset();</span>
<span class="udiff-line-added">+           p = ValueTypeNode::make_from_flattened(this, value_klass, base, base, holder, offset, decorators);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           p = ValueTypeNode::make_from_flattened(this, value_klass, base, adr, NULL, 0, decorators);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);</span>
<span class="udiff-line-added">+       }</span>
        // Normalize the value returned by getBoolean in the following cases
        if (type == T_BOOLEAN &amp;&amp;
            (mismatched ||
             heap_base_oop == top() ||                  // - heap_base_oop is NULL or
             (can_access_non_heap &amp;&amp; field == NULL))    // - heap_base_oop is potentially NULL
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2554,10 +2704,18 @@</span>
      }
      if (type == T_ADDRESS) {
        p = gvn().transform(new CastP2XNode(NULL, p));
        p = ConvX2UL(p);
      }
<span class="udiff-line-added">+     if (field != NULL &amp;&amp; field-&gt;is_flattenable() &amp;&amp; !field-&gt;is_flattened()) {</span>
<span class="udiff-line-added">+       // Load a non-flattened but flattenable value type from memory</span>
<span class="udiff-line-added">+       if (value_type-&gt;value_klass()-&gt;is_scalarizable()) {</span>
<span class="udiff-line-added">+         p = ValueTypeNode::make_from_oop(this, p, value_type-&gt;value_klass());</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         p = null2default(p, value_type-&gt;value_klass());</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      // The load node has the control of the preceding MemBarCPUOrder.  All
      // following nodes will have the control of the MemBarCPUOrder inserted at
      // the end of this method.  So, pushing the load onto the stack at a later
      // point is fine.
      set_result(p);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2565,13 +2723,70 @@</span>
      if (bt == T_ADDRESS) {
        // Repackage the long as a pointer.
        val = ConvL2X(val);
        val = gvn().transform(new CastX2PNode(val));
      }
<span class="udiff-line-modified-removed">-     access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);</span>
<span class="udiff-line-modified-added">+     if (type == T_VALUETYPE) {</span>
<span class="udiff-line-added">+       if (adr_type-&gt;isa_instptr() &amp;&amp; !mismatched) {</span>
<span class="udiff-line-added">+         ciInstanceKlass* holder = adr_type-&gt;is_instptr()-&gt;klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-added">+         int offset = adr_type-&gt;is_instptr()-&gt;offset();</span>
<span class="udiff-line-added">+         val-&gt;as_ValueType()-&gt;store_flattened(this, base, base, holder, offset, decorators);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         val-&gt;as_ValueType()-&gt;store_flattened(this, base, adr, NULL, 0, decorators);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (argument(1)-&gt;is_ValueType() &amp;&amp; is_store) {</span>
<span class="udiff-line-added">+     Node* value = ValueTypeNode::make_from_oop(this, base, _gvn.type(base)-&gt;value_klass());</span>
<span class="udiff-line-added">+     value = value-&gt;as_ValueType()-&gt;make_larval(this, false);</span>
<span class="udiff-line-added">+     replace_in_map(argument(1), value);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_unsafe_make_private_buffer() {</span>
<span class="udiff-line-added">+   Node* receiver = argument(0);</span>
<span class="udiff-line-added">+   Node* value = argument(1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   receiver = null_check(receiver);</span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!value-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     return false;</span>
    }
  
<span class="udiff-line-added">+   set_result(value-&gt;as_ValueType()-&gt;make_larval(this, true));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LibraryCallKit::inline_unsafe_finish_private_buffer() {</span>
<span class="udiff-line-added">+   Node* receiver = argument(0);</span>
<span class="udiff-line-added">+   Node* buffer = argument(1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   receiver = null_check(receiver);</span>
<span class="udiff-line-added">+   if (stopped()) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!buffer-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ValueTypeNode* vt = buffer-&gt;as_ValueType();</span>
<span class="udiff-line-added">+   if (!vt-&gt;is_allocated(&amp;_gvn) || !_gvn.type(vt)-&gt;is_valuetype()-&gt;larval()) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   set_result(vt-&gt;finish_larval(this));</span>
<span class="udiff-line-added">+ </span>
    return true;
  }
  
  //----------------------------inline_unsafe_load_store----------------------------
  // This method serves a couple of different customers (depending on LoadStoreKind):
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3030,19 +3245,10 @@</span>
    Node* junk = NULL;
    set_result(generate_current_thread(junk));
    return true;
  }
  
<span class="udiff-line-removed">- //---------------------------load_mirror_from_klass----------------------------</span>
<span class="udiff-line-removed">- // Given a klass oop, load its java mirror (a java.lang.Class oop).</span>
<span class="udiff-line-removed">- Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {</span>
<span class="udiff-line-removed">-   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));</span>
<span class="udiff-line-removed">-   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);</span>
<span class="udiff-line-removed">-   // mirror = ((OopHandle)mirror)-&gt;resolve();</span>
<span class="udiff-line-removed">-   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //-----------------------load_klass_from_mirror_common-------------------------
  // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
  // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
  // and branch to the given path on the region.
  // If never_see_null, take an uncommon trap on null, so we can optimistically
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3081,17 +3287,22 @@</span>
    Node* mbit = _gvn.transform(new AndINode(mods, mask));
    Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
    Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
    return generate_fair_guard(bol, region);
  }
<span class="udiff-line-added">+ </span>
  Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
    return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
  }
  Node* LibraryCallKit::generate_hidden_class_guard(Node* kls, RegionNode* region) {
    return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);
  }
  
<span class="udiff-line-added">+ Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {</span>
<span class="udiff-line-added">+   return generate_access_flags_guard(kls, JVM_ACC_VALUE, 0, region);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  //-------------------------inline_native_Class_query-------------------
  bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
    const Type* return_type = TypeInt::BOOL;
    Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
    bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3285,22 +3496,34 @@</span>
      return false;  // dead path (mirror-&gt;is_top()).
    }
    if (obj == NULL || obj-&gt;is_top()) {
      return false;  // dead path
    }
<span class="udiff-line-modified-removed">-   const TypeOopPtr* tp = _gvn.type(obj)-&gt;isa_oopptr();</span>
<span class="udiff-line-modified-added">+   ciKlass* obj_klass = NULL;</span>
<span class="udiff-line-added">+   const Type* obj_t = _gvn.type(obj);</span>
<span class="udiff-line-added">+   if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     obj_klass = obj_t-&gt;value_klass();</span>
<span class="udiff-line-added">+   } else if (obj_t-&gt;isa_oopptr()) {</span>
<span class="udiff-line-added">+     obj_klass = obj_t-&gt;is_oopptr()-&gt;klass();</span>
<span class="udiff-line-added">+   }</span>
  
    // First, see if Class.cast() can be folded statically.
    // java_mirror_type() returns non-null for compile-time Class constants.
    ciType* tm = mirror_con-&gt;java_mirror_type();
<span class="udiff-line-modified-removed">-   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       tp != NULL &amp;&amp; tp-&gt;klass() != NULL) {</span>
<span class="udiff-line-removed">-     if (!tp-&gt;klass()-&gt;is_loaded()) {</span>
<span class="udiff-line-modified-added">+   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp; obj_klass != NULL) {</span>
<span class="udiff-line-modified-added">+     if (!obj_klass-&gt;is_loaded()) {</span>
        // Don&#39;t use intrinsic when class is not loaded.
        return false;
      } else {
<span class="udiff-line-modified-removed">-       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), tp-&gt;klass());</span>
<span class="udiff-line-modified-added">+       if (!obj-&gt;is_ValueType() &amp;&amp; tm-&gt;as_klass()-&gt;is_valuetype()) {</span>
<span class="udiff-line-added">+         // Casting to .val, check for null</span>
<span class="udiff-line-added">+         obj = null_check(obj);</span>
<span class="udiff-line-added">+         if (stopped()) {</span>
<span class="udiff-line-added">+           return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), obj_klass);</span>
        if (static_res == Compile::SSC_always_true) {
          // isInstance() is true - fold the code.
          set_result(obj);
          return true;
        } else if (static_res == Compile::SSC_always_false) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3326,28 +3549,48 @@</span>
    if (stopped()) {
      return true;
    }
  
    // Not-subtype or the mirror&#39;s klass ptr is NULL (in case it is a primitive).
<span class="udiff-line-modified-removed">-   enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };</span>
<span class="udiff-line-modified-added">+   enum { _bad_type_path = 1, _prim_path = 2, _npe_path = 3, PATH_LIMIT };</span>
    RegionNode* region = new RegionNode(PATH_LIMIT);
    record_for_igvn(region);
  
    // Now load the mirror&#39;s klass metaobject, and null-check it.
    // If kls is null, we have a primitive mirror and
    // nothing is an instance of a primitive type.
    Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
  
    Node* res = top();
    if (!stopped()) {
<span class="udiff-line-added">+     if (EnableValhalla &amp;&amp; !obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+       // Check if we are casting to .val</span>
<span class="udiff-line-added">+       Node* is_val_kls = generate_value_guard(kls, NULL);</span>
<span class="udiff-line-added">+       if (is_val_kls != NULL) {</span>
<span class="udiff-line-added">+         RegionNode* r = new RegionNode(3);</span>
<span class="udiff-line-added">+         record_for_igvn(r);</span>
<span class="udiff-line-added">+         r-&gt;init_req(1, control());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Casting to .val, check for null</span>
<span class="udiff-line-added">+         set_control(is_val_kls);</span>
<span class="udiff-line-added">+         Node* null_ctr = top();</span>
<span class="udiff-line-added">+         null_check_oop(obj, &amp;null_ctr);</span>
<span class="udiff-line-added">+         region-&gt;init_req(_npe_path, null_ctr);</span>
<span class="udiff-line-added">+         r-&gt;init_req(2, control());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         set_control(_gvn.transform(r));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      Node* bad_type_ctrl = top();
      // Do checkcast optimizations.
      res = gen_checkcast(obj, kls, &amp;bad_type_ctrl);
      region-&gt;init_req(_bad_type_path, bad_type_ctrl);
    }
    if (region-&gt;in(_prim_path) != top() ||
<span class="udiff-line-modified-removed">-       region-&gt;in(_bad_type_path) != top()) {</span>
<span class="udiff-line-modified-added">+       region-&gt;in(_bad_type_path) != top() ||</span>
<span class="udiff-line-added">+       region-&gt;in(_npe_path) != top()) {</span>
      // Let Interpreter throw ClassCastException.
      PreserveJVMState pjvms(this);
      set_control(_gvn.transform(region));
      uncommon_trap(Deoptimization::Reason_intrinsic,
                    Deoptimization::Action_maybe_recompile);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3380,12 +3623,14 @@</span>
      _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
      PATH_LIMIT
    };
  
    RegionNode* region = new RegionNode(PATH_LIMIT);
<span class="udiff-line-added">+   RegionNode* prim_region = new RegionNode(2);</span>
    Node*       phi    = new PhiNode(region, TypeInt::BOOL);
    record_for_igvn(region);
<span class="udiff-line-added">+   record_for_igvn(prim_region);</span>
  
    const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
    const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
    int class_klass_offset = java_lang_Class::klass_offset();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3406,12 +3651,15 @@</span>
    bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
    for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
      Node* kls = klasses[which_arg];
      Node* null_ctl = top();
      kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
<span class="udiff-line-modified-removed">-     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);</span>
<span class="udiff-line-modified-removed">-     region-&gt;init_req(prim_path, null_ctl);</span>
<span class="udiff-line-modified-added">+     if (which_arg == 0) {</span>
<span class="udiff-line-modified-added">+       prim_region-&gt;init_req(1, null_ctl);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       region-&gt;init_req(_prim_1_path, null_ctl);</span>
<span class="udiff-line-added">+     }</span>
      if (stopped())  break;
      klasses[which_arg] = kls;
    }
  
    if (!stopped()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3424,16 +3672,17 @@</span>
    }
  
    // If both operands are primitive (both klasses null), then
    // we must return true when they are identical primitives.
    // It is convenient to test this after the first null klass check.
<span class="udiff-line-modified-removed">-   set_control(region-&gt;in(_prim_0_path)); // go back to first null check</span>
<span class="udiff-line-modified-added">+   // This path is also used if superc is a value mirror.</span>
<span class="udiff-line-added">+   set_control(_gvn.transform(prim_region));</span>
    if (!stopped()) {
      // Since superc is primitive, make a guard for the superc==subc case.
      Node* cmp_eq = _gvn.transform(new CmpPNode(args[0], args[1]));
      Node* bol_eq = _gvn.transform(new BoolNode(cmp_eq, BoolTest::eq));
<span class="udiff-line-modified-removed">-     generate_guard(bol_eq, region, PROB_FAIR);</span>
<span class="udiff-line-modified-added">+     generate_fair_guard(bol_eq, region);</span>
      if (region-&gt;req() == PATH_LIMIT+1) {
        // A guard was added.  If the added guard is taken, superc==subc.
        region-&gt;swap_edges(PATH_LIMIT, _prim_same_path);
        region-&gt;del_req(PATH_LIMIT);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3460,59 +3709,78 @@</span>
    set_result(_gvn.transform(phi));
    return true;
  }
  
  //---------------------generate_array_guard_common------------------------
<span class="udiff-line-modified-removed">- Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,</span>
<span class="udiff-line-removed">-                                                   bool obj_array, bool not_array) {</span>
<span class="udiff-line-modified-added">+ Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind) {</span>
  
    if (stopped()) {
      return NULL;
    }
  
<span class="udiff-line-removed">-   // If obj_array/non_array==false/false:</span>
<span class="udiff-line-removed">-   // Branch around if the given klass is in fact an array (either obj or prim).</span>
<span class="udiff-line-removed">-   // If obj_array/non_array==false/true:</span>
<span class="udiff-line-removed">-   // Branch around if the given klass is not an array klass of any kind.</span>
<span class="udiff-line-removed">-   // If obj_array/non_array==true/true:</span>
<span class="udiff-line-removed">-   // Branch around if the kls is not an oop array (kls is int[], String, etc.)</span>
<span class="udiff-line-removed">-   // If obj_array/non_array==true/false:</span>
<span class="udiff-line-removed">-   // Branch around if the kls is an oop array (Object[] or subtype)</span>
<span class="udiff-line-removed">-   //</span>
    // Like generate_guard, adds a new path onto the region.
    jint  layout_con = 0;
    Node* layout_val = get_layout_helper(kls, layout_con);
    if (layout_val == NULL) {
<span class="udiff-line-modified-removed">-     bool query = (obj_array</span>
<span class="udiff-line-modified-removed">-                   ? Klass::layout_helper_is_objArray(layout_con)</span>
<span class="udiff-line-modified-removed">-                   : Klass::layout_helper_is_array(layout_con));</span>
<span class="udiff-line-modified-removed">-     if (query == not_array) {</span>
<span class="udiff-line-modified-added">+     bool query = 0;</span>
<span class="udiff-line-modified-added">+     switch(kind) {</span>
<span class="udiff-line-modified-added">+       case ObjectArray:    query = Klass::layout_helper_is_objArray(layout_con); break;</span>
<span class="udiff-line-modified-added">+       case NonObjectArray: query = !Klass::layout_helper_is_objArray(layout_con); break;</span>
<span class="udiff-line-added">+       case TypeArray:      query = Klass::layout_helper_is_typeArray(layout_con); break;</span>
<span class="udiff-line-added">+       case ValueArray:     query = Klass::layout_helper_is_valueArray(layout_con); break;</span>
<span class="udiff-line-added">+       case AnyArray:       query = Klass::layout_helper_is_array(layout_con); break;</span>
<span class="udiff-line-added">+       case NonArray:       query = !Klass::layout_helper_is_array(layout_con); break;</span>
<span class="udiff-line-added">+       default:</span>
<span class="udiff-line-added">+         ShouldNotReachHere();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (!query) {</span>
        return NULL;                       // never a branch
      } else {                             // always a branch
        Node* always_branch = control();
        if (region != NULL)
          region-&gt;add_req(always_branch);
        set_control(top());
        return always_branch;
      }
    }
<span class="udiff-line-added">+   unsigned int value = 0;</span>
<span class="udiff-line-added">+   BoolTest::mask btest = BoolTest::illegal;</span>
<span class="udiff-line-added">+   switch(kind) {</span>
<span class="udiff-line-added">+     case ObjectArray:</span>
<span class="udiff-line-added">+     case NonObjectArray: {</span>
<span class="udiff-line-added">+       value = Klass::_lh_array_tag_obj_value;</span>
<span class="udiff-line-added">+       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));</span>
<span class="udiff-line-added">+       btest = kind == ObjectArray ? BoolTest::eq : BoolTest::ne;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case TypeArray: {</span>
<span class="udiff-line-added">+       value = Klass::_lh_array_tag_type_value;</span>
<span class="udiff-line-added">+       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));</span>
<span class="udiff-line-added">+       btest = BoolTest::eq;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case ValueArray: {</span>
<span class="udiff-line-added">+       value = Klass::_lh_array_tag_vt_value;</span>
<span class="udiff-line-added">+       layout_val = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));</span>
<span class="udiff-line-added">+       btest = BoolTest::eq;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case AnyArray:    value = Klass::_lh_neutral_value; btest = BoolTest::lt; break;</span>
<span class="udiff-line-added">+     case NonArray:    value = Klass::_lh_neutral_value; btest = BoolTest::gt; break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       ShouldNotReachHere();</span>
<span class="udiff-line-added">+   }</span>
    // Now test the correct condition.
<span class="udiff-line-modified-removed">-   jint  nval = (obj_array</span>
<span class="udiff-line-removed">-                 ? (jint)(Klass::_lh_array_tag_type_value</span>
<span class="udiff-line-removed">-                    &lt;&lt;    Klass::_lh_array_tag_shift)</span>
<span class="udiff-line-removed">-                 : Klass::_lh_neutral_value);</span>
<span class="udiff-line-modified-added">+   jint nval = (jint)value;</span>
    Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
<span class="udiff-line-removed">-   BoolTest::mask btest = BoolTest::lt;  // correct for testing is_[obj]array</span>
<span class="udiff-line-removed">-   // invert the test if we are looking for a non-array</span>
<span class="udiff-line-removed">-   if (not_array)  btest = BoolTest(btest).negate();</span>
    Node* bol = _gvn.transform(new BoolNode(cmp, btest));
    return generate_fair_guard(bol, region);
  }
  
  
  //-----------------------inline_native_newArray--------------------------
<span class="udiff-line-modified-removed">- // private static native Object java.lang.reflect.newArray(Class&lt;?&gt; componentType, int length);</span>
<span class="udiff-line-modified-added">+ // private static native Object java.lang.reflect.Array.newArray(Class&lt;?&gt; componentType, int length);</span>
  // private        native Object Unsafe.allocateUninitializedArray0(Class&lt;?&gt; cls, int size);
  bool LibraryCallKit::inline_unsafe_newArray(bool uninitialized) {
    Node* mirror;
    Node* count_val;
    if (uninitialized) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3624,10 +3892,23 @@</span>
    Node* original          = argument(0);
    Node* start             = is_copyOfRange? argument(1): intcon(0);
    Node* end               = is_copyOfRange? argument(2): argument(1);
    Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
  
<span class="udiff-line-added">+   const TypeAryPtr* original_t = _gvn.type(original)-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+   const TypeInstPtr* mirror_t = _gvn.type(array_type_mirror)-&gt;isa_instptr();</span>
<span class="udiff-line-added">+   if (EnableValhalla &amp;&amp; ValueArrayFlatten &amp;&amp;</span>
<span class="udiff-line-added">+       (original_t == NULL || mirror_t == NULL ||</span>
<span class="udiff-line-added">+        (mirror_t-&gt;java_mirror_type() == NULL &amp;&amp;</span>
<span class="udiff-line-added">+         (original_t-&gt;elem()-&gt;isa_valuetype() ||</span>
<span class="udiff-line-added">+          (original_t-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;</span>
<span class="udiff-line-added">+           original_t-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()))))) {</span>
<span class="udiff-line-added">+     // We need to know statically if the copy is to a flattened array</span>
<span class="udiff-line-added">+     // or not but can&#39;t tell.</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    Node* newcopy = NULL;
  
    // Set the original stack and the reexecute bit for the interpreter to reexecute
    // the bytecode that invokes Arrays.copyOf if deoptimization happens.
    { PreserveReexecuteState preexecs(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3647,20 +3928,66 @@</span>
      RegionNode* bailout = new RegionNode(1);
      record_for_igvn(bailout);
  
      // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
      // Bail out if that is so.
<span class="udiff-line-modified-removed">-     Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);</span>
<span class="udiff-line-modified-added">+     // Value type array may have object field that would require a</span>
<span class="udiff-line-added">+     // write barrier. Conservatively, go to slow path.</span>
<span class="udiff-line-added">+     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-added">+     Node* not_objArray = !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing) ?</span>
<span class="udiff-line-added">+         generate_typeArray_guard(klass_node, bailout) : generate_non_objArray_guard(klass_node, bailout);</span>
      if (not_objArray != NULL) {
        // Improve the klass node&#39;s type from the new optimistic assumption:
        ciKlass* ak = ciArrayKlass::make(env()-&gt;Object_klass());
<span class="udiff-line-modified-removed">-       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0/*offset*/);</span>
<span class="udiff-line-modified-added">+       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, Type::Offset(0), false);</span>
        Node* cast = new CastPPNode(klass_node, akls);
        cast-&gt;init_req(0, control());
        klass_node = _gvn.transform(cast);
      }
  
<span class="udiff-line-added">+     Node* original_kls = load_object_klass(original);</span>
<span class="udiff-line-added">+     // ArrayCopyNode:Ideal may transform the ArrayCopyNode to</span>
<span class="udiff-line-added">+     // loads/stores but it is legal only if we&#39;re sure the</span>
<span class="udiff-line-added">+     // Arrays.copyOf would succeed. So we need all input arguments</span>
<span class="udiff-line-added">+     // to the copyOf to be validated, including that the copy to the</span>
<span class="udiff-line-added">+     // new array won&#39;t trigger an ArrayStoreException. That subtype</span>
<span class="udiff-line-added">+     // check can be optimized if we know something on the type of</span>
<span class="udiff-line-added">+     // the input array from type speculation.</span>
<span class="udiff-line-added">+     if (_gvn.type(klass_node)-&gt;singleton() &amp;&amp; !stopped()) {</span>
<span class="udiff-line-added">+       ciKlass* subk   = _gvn.type(original_kls)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-added">+       ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       int test = C-&gt;static_subtype_check(superk, subk);</span>
<span class="udiff-line-added">+       if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {</span>
<span class="udiff-line-added">+         const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();</span>
<span class="udiff-line-added">+         if (t_original-&gt;speculative_type() != NULL) {</span>
<span class="udiff-line-added">+           original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);</span>
<span class="udiff-line-added">+           original_kls = load_object_klass(original);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (ValueArrayFlatten) {</span>
<span class="udiff-line-added">+       // Either both or neither new array klass and original array</span>
<span class="udiff-line-added">+       // klass must be flattened</span>
<span class="udiff-line-added">+       Node* is_flat = generate_valueArray_guard(klass_node, NULL);</span>
<span class="udiff-line-added">+       if (!original_t-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+         generate_valueArray_guard(original_kls, bailout);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (is_flat != NULL) {</span>
<span class="udiff-line-added">+         RegionNode* r = new RegionNode(2);</span>
<span class="udiff-line-added">+         record_for_igvn(r);</span>
<span class="udiff-line-added">+         r-&gt;init_req(1, control());</span>
<span class="udiff-line-added">+         set_control(is_flat);</span>
<span class="udiff-line-added">+         if (!original_t-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+           generate_valueArray_guard(original_kls, r);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         bailout-&gt;add_req(control());</span>
<span class="udiff-line-added">+         set_control(_gvn.transform(r));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Bail out if either start or end is negative.
      generate_negative_guard(start, bailout, &amp;start);
      generate_negative_guard(end,   bailout, &amp;end);
  
      Node* length = end;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3691,30 +4018,10 @@</span>
        // We know the copy is disjoint but we might not know if the
        // oop stores need checking.
        // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
        // This will fail a store-check if x contains any non-nulls.
  
<span class="udiff-line-removed">-       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to</span>
<span class="udiff-line-removed">-       // loads/stores but it is legal only if we&#39;re sure the</span>
<span class="udiff-line-removed">-       // Arrays.copyOf would succeed. So we need all input arguments</span>
<span class="udiff-line-removed">-       // to the copyOf to be validated, including that the copy to the</span>
<span class="udiff-line-removed">-       // new array won&#39;t trigger an ArrayStoreException. That subtype</span>
<span class="udiff-line-removed">-       // check can be optimized if we know something on the type of</span>
<span class="udiff-line-removed">-       // the input array from type speculation.</span>
<span class="udiff-line-removed">-       if (_gvn.type(klass_node)-&gt;singleton()) {</span>
<span class="udiff-line-removed">-         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-removed">-         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int test = C-&gt;static_subtype_check(superk, subk);</span>
<span class="udiff-line-removed">-         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {</span>
<span class="udiff-line-removed">-           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();</span>
<span class="udiff-line-removed">-           if (t_original-&gt;speculative_type() != NULL) {</span>
<span class="udiff-line-removed">-             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
        bool validated = false;
        // Reason_class_check rather than Reason_intrinsic because we
        // want to intrinsify even if this traps.
        if (!too_many_traps(Deoptimization::Reason_class_check)) {
          Node* not_subtype_ctrl = gen_subtype_check(original, klass_node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3731,11 +4038,11 @@</span>
  
        if (!stopped()) {
          newcopy = new_array(klass_node, length, 0);  // no arguments to push
  
          ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
<span class="udiff-line-modified-removed">-                                                 load_object_klass(original), klass_node);</span>
<span class="udiff-line-modified-added">+                                                 original_kls, klass_node);</span>
          if (!is_copyOfRange) {
            ac-&gt;set_copyof(validated);
          } else {
            ac-&gt;set_copyofrange(validated);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3855,21 +4162,25 @@</span>
  
    RegionNode* result_reg = new RegionNode(PATH_LIMIT);
    PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
    PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
    PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
<span class="udiff-line-modified-removed">-   Node* obj = NULL;</span>
<span class="udiff-line-modified-added">+   Node* obj = argument(0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (obj-&gt;is_ValueType() || gvn().type(obj)-&gt;is_valuetypeptr()) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (!is_static) {
      // Check for hashing null object
      obj = null_check_receiver();
      if (stopped())  return true;        // unconditionally null
      result_reg-&gt;init_req(_null_path, top());
      result_val-&gt;init_req(_null_path, top());
    } else {
      // Do a null check, and return zero if null.
      // System.identityHashCode(null) == 0
<span class="udiff-line-removed">-     obj = argument(0);</span>
      Node* null_ctl = top();
      obj = null_check_oop(obj, &amp;null_ctl);
      result_reg-&gt;init_req(_null_path, null_ctl);
      result_val-&gt;init_req(_null_path, _gvn.intcon(0));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3905,10 +4216,11 @@</span>
    // the null check after castPP removal.
    Node* no_ctrl = NULL;
    Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
  
    // Test the header to see if it is unlocked.
<span class="udiff-line-added">+   // This also serves as guard against value types (they have the always_locked_pattern set).</span>
    Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);
    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
    Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);
    Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
    Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3971,11 +4283,17 @@</span>
  //---------------------------inline_native_getClass----------------------------
  // public final native Class&lt;?&gt; java.lang.Object.getClass();
  //
  // Build special case code for calls to getClass on an object.
  bool LibraryCallKit::inline_native_getClass() {
<span class="udiff-line-modified-removed">-   Node* obj = null_check_receiver();</span>
<span class="udiff-line-modified-added">+   Node* obj = argument(0);</span>
<span class="udiff-line-added">+   if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+     ciKlass* vk = _gvn.type(obj)-&gt;value_klass();</span>
<span class="udiff-line-added">+     set_result(makecon(TypeInstPtr::make(vk-&gt;java_mirror())));</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   obj = null_check_receiver();</span>
    if (stopped())  return true;
    set_result(load_mirror_from_klass(load_object_klass(obj)));
    return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4233,11 +4551,18 @@</span>
      // copy and a StoreStore barrier exists after the array copy.
      alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
    }
  
    Node* size = _gvn.transform(obj_size);
<span class="udiff-line-modified-removed">-   access_clone(obj, alloc_obj, size, is_array);</span>
<span class="udiff-line-modified-added">+   // Exclude the header but include array length to copy by 8 bytes words.</span>
<span class="udiff-line-added">+   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.</span>
<span class="udiff-line-added">+   int base_off = BarrierSetC2::arraycopy_payload_base_offset(is_array);</span>
<span class="udiff-line-added">+   Node* countx = size;</span>
<span class="udiff-line-added">+   countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));</span>
<span class="udiff-line-added">+   countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   access_clone(obj, alloc_obj, countx, is_array);</span>
  
    // Do not let reads from the cloned object float above the arraycopy.
    if (alloc != NULL) {
      // Do not let stores that initialize this object be reordered with
      // a subsequent store that would make this object accessible by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4276,21 +4601,27 @@</span>
    // Set the reexecute bit for the interpreter to reexecute
    // the bytecode that invokes Object.clone if deoptimization happens.
    { PreserveReexecuteState preexecs(this);
      jvms()-&gt;set_should_reexecute(true);
  
<span class="udiff-line-modified-removed">-     Node* obj = null_check_receiver();</span>
<span class="udiff-line-modified-added">+     Node* obj = argument(0);</span>
<span class="udiff-line-added">+     if (obj-&gt;is_ValueType()) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     obj = null_check_receiver();</span>
      if (stopped())  return true;
  
      const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
  
      // If we are going to clone an instance, we need its exact type to
      // know the number and types of fields to convert the clone to
      // loads/stores. Maybe a speculative type can help us.
      if (!obj_type-&gt;klass_is_exact() &amp;&amp;
          obj_type-&gt;speculative_type() != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {</span>
<span class="udiff-line-modified-added">+         obj_type-&gt;speculative_type()-&gt;is_instance_klass() &amp;&amp;</span>
<span class="udiff-line-added">+         !obj_type-&gt;speculative_type()-&gt;is_valuetype()) {</span>
        ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
        if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
            !spec_ik-&gt;has_injected_fields()) {
          ciKlass* k = obj_type-&gt;klass();
          if (!k-&gt;is_instance_klass() ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4318,64 +4649,76 @@</span>
      PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
      PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
      record_for_igvn(result_reg);
  
      Node* obj_klass = load_object_klass(obj);
<span class="udiff-line-added">+     // We only go to the fast case code if we pass a number of guards.</span>
<span class="udiff-line-added">+     // The paths which do not pass are accumulated in the slow_region.</span>
<span class="udiff-line-added">+     RegionNode* slow_region = new RegionNode(1);</span>
<span class="udiff-line-added">+     record_for_igvn(slow_region);</span>
<span class="udiff-line-added">+ </span>
      Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
      if (array_ctl != NULL) {
        // It&#39;s an array.
        PreserveJVMState pjvms(this);
        set_control(array_ctl);
<span class="udiff-line-removed">-       Node* obj_length = load_array_length(obj);</span>
<span class="udiff-line-removed">-       Node* obj_size  = NULL;</span>
<span class="udiff-line-removed">-       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size, /*deoptimize_on_exception=*/true);</span>
  
        BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="udiff-line-modified-removed">-       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {</span>
<span class="udiff-line-modified-removed">-         // If it is an oop array, it requires very special treatment,</span>
<span class="udiff-line-modified-removed">-         // because gc barriers are required when accessing the array.</span>
<span class="udiff-line-modified-removed">-         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);</span>
<span class="udiff-line-modified-removed">-         if (is_obja != NULL) {</span>
<span class="udiff-line-removed">-           PreserveJVMState pjvms2(this);</span>
<span class="udiff-line-removed">-           set_control(is_obja);</span>
<span class="udiff-line-removed">-           // Generate a direct call to the right arraycopy function(s).</span>
<span class="udiff-line-removed">-           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);</span>
<span class="udiff-line-removed">-           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);</span>
<span class="udiff-line-removed">-           ac-&gt;set_clone_oop_array();</span>
<span class="udiff-line-removed">-           Node* n = _gvn.transform(ac);</span>
<span class="udiff-line-removed">-           assert(n == ac, &quot;cannot disappear&quot;);</span>
<span class="udiff-line-removed">-           ac-&gt;connect_outputs(this, /*deoptimize_on_exception=*/true);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           result_reg-&gt;init_req(_objArray_path, control());</span>
<span class="udiff-line-removed">-           result_val-&gt;init_req(_objArray_path, alloc_obj);</span>
<span class="udiff-line-removed">-           result_i_o -&gt;set_req(_objArray_path, i_o());</span>
<span class="udiff-line-removed">-           result_mem -&gt;set_req(_objArray_path, reset_memory());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &amp;&amp;</span>
<span class="udiff-line-modified-added">+           (!obj_type-&gt;isa_aryptr() || !obj_type-&gt;is_aryptr()-&gt;is_not_flat())) {</span>
<span class="udiff-line-modified-added">+         // Flattened value type array may have object field that would require a</span>
<span class="udiff-line-modified-added">+         // write barrier. Conservatively, go to slow path.</span>
<span class="udiff-line-modified-added">+         generate_valueArray_guard(obj_klass, slow_region);</span>
        }
<span class="udiff-line-removed">-       // Otherwise, there are no barriers to worry about.</span>
<span class="udiff-line-removed">-       // (We can dispense with card marks if we know the allocation</span>
<span class="udiff-line-removed">-       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks</span>
<span class="udiff-line-removed">-       //  causes the non-eden paths to take compensating steps to</span>
<span class="udiff-line-removed">-       //  simulate a fresh allocation, so that no further</span>
<span class="udiff-line-removed">-       //  card marks are required in compiled code to initialize</span>
<span class="udiff-line-removed">-       //  the object.)</span>
  
        if (!stopped()) {
<span class="udiff-line-modified-removed">-         copy_to_clone(obj, alloc_obj, obj_size, true);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         // Present the results of the copy.</span>
<span class="udiff-line-modified-removed">-         result_reg-&gt;init_req(_array_path, control());</span>
<span class="udiff-line-modified-removed">-         result_val-&gt;init_req(_array_path, alloc_obj);</span>
<span class="udiff-line-modified-removed">-         result_i_o -&gt;set_req(_array_path, i_o());</span>
<span class="udiff-line-modified-removed">-         result_mem -&gt;set_req(_array_path, reset_memory());</span>
<span class="udiff-line-modified-added">+         Node* obj_length = load_array_length(obj);</span>
<span class="udiff-line-modified-added">+         Node* obj_size  = NULL;</span>
<span class="udiff-line-modified-added">+         Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size, true);  // no arguments to push</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-modified-added">+         if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {</span>
<span class="udiff-line-modified-added">+           // If it is an oop array, it requires very special treatment,</span>
<span class="udiff-line-added">+           // because gc barriers are required when accessing the array.</span>
<span class="udiff-line-added">+           Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);</span>
<span class="udiff-line-added">+           if (is_obja != NULL) {</span>
<span class="udiff-line-added">+             PreserveJVMState pjvms2(this);</span>
<span class="udiff-line-added">+             set_control(is_obja);</span>
<span class="udiff-line-added">+             // Generate a direct call to the right arraycopy function(s).</span>
<span class="udiff-line-added">+             Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);</span>
<span class="udiff-line-added">+             ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);</span>
<span class="udiff-line-added">+             ac-&gt;set_clone_oop_array();</span>
<span class="udiff-line-added">+             Node* n = _gvn.transform(ac);</span>
<span class="udiff-line-added">+             assert(n == ac, &quot;cannot disappear&quot;);</span>
<span class="udiff-line-added">+             ac-&gt;connect_outputs(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             result_reg-&gt;init_req(_objArray_path, control());</span>
<span class="udiff-line-added">+             result_val-&gt;init_req(_objArray_path, alloc_obj);</span>
<span class="udiff-line-added">+             result_i_o -&gt;set_req(_objArray_path, i_o());</span>
<span class="udiff-line-added">+             result_mem -&gt;set_req(_objArray_path, reset_memory());</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // Otherwise, there are no barriers to worry about.</span>
<span class="udiff-line-added">+         // (We can dispense with card marks if we know the allocation</span>
<span class="udiff-line-added">+         //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks</span>
<span class="udiff-line-added">+         //  causes the non-eden paths to take compensating steps to</span>
<span class="udiff-line-added">+         //  simulate a fresh allocation, so that no further</span>
<span class="udiff-line-added">+         //  card marks are required in compiled code to initialize</span>
<span class="udiff-line-added">+         //  the object.)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (!stopped()) {</span>
<span class="udiff-line-added">+           copy_to_clone(obj, alloc_obj, obj_size, true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           // Present the results of the copy.</span>
<span class="udiff-line-added">+           result_reg-&gt;init_req(_array_path, control());</span>
<span class="udiff-line-added">+           result_val-&gt;init_req(_array_path, alloc_obj);</span>
<span class="udiff-line-added">+           result_i_o -&gt;set_req(_array_path, i_o());</span>
<span class="udiff-line-added">+           result_mem -&gt;set_req(_array_path, reset_memory());</span>
<span class="udiff-line-added">+         }</span>
        }
      }
  
<span class="udiff-line-removed">-     // We only go to the instance fast case code if we pass a number of guards.</span>
<span class="udiff-line-removed">-     // The paths which do not pass are accumulated in the slow_region.</span>
<span class="udiff-line-removed">-     RegionNode* slow_region = new RegionNode(1);</span>
<span class="udiff-line-removed">-     record_for_igvn(slow_region);</span>
      if (!stopped()) {
        // It&#39;s an instance (we did array above).  Make the slow-path tests.
        // If this is a virtual call, we generate a funny guard.  We grab
        // the vtable entry corresponding to clone() from the target object.
        // If the target method which we are calling happens to be the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4532,15 +4875,14 @@</span>
      map()-&gt;replaced_nodes().apply(saved_jvms-&gt;map(), new_idx);
      set_jvms(saved_jvms);
      _reexecute_sp = saved_reexecute_sp;
  
      // Remove the allocation from above the guards
<span class="udiff-line-modified-removed">-     CallProjections callprojs;</span>
<span class="udiff-line-removed">-     alloc-&gt;extract_projections(&amp;callprojs, true);</span>
<span class="udiff-line-modified-added">+     CallProjections* callprojs = alloc-&gt;extract_projections(true);</span>
      InitializeNode* init = alloc-&gt;initialization();
      Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
<span class="udiff-line-modified-removed">-     C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));</span>
<span class="udiff-line-modified-added">+     C-&gt;gvn_replace_by(callprojs-&gt;fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));</span>
      C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Memory), alloc_mem);
      C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Control), alloc-&gt;in(0));
  
      // move the allocation here (after the guards)
      _gvn.hash_delete(alloc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4548,11 +4890,11 @@</span>
      alloc-&gt;set_req(TypeFunc::I_O, i_o());
      Node *mem = reset_memory();
      set_all_memory(mem);
      alloc-&gt;set_req(TypeFunc::Memory, mem);
      set_control(init-&gt;proj_out_or_null(TypeFunc::Control));
<span class="udiff-line-modified-removed">-     set_i_o(callprojs.fallthrough_ioproj);</span>
<span class="udiff-line-modified-added">+     set_i_o(callprojs-&gt;fallthrough_ioproj);</span>
  
      // Update memory as done in GraphKit::set_output_for_allocation()
      const TypeInt* length_type = _gvn.find_int_type(alloc-&gt;in(AllocateNode::ALength));
      const TypeOopPtr* ary_type = _gvn.type(alloc-&gt;in(AllocateNode::KlassNode))-&gt;is_klassptr()-&gt;as_instance_type();
      if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4692,12 +5034,12 @@</span>
    }
  
    if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
      BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="udiff-line-modified-removed">-     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="udiff-line-modified-removed">-     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
<span class="udiff-line-modified-added">+     if (src_elem  == T_ARRAY)  src_elem  = T_OBJECT;</span>
<span class="udiff-line-modified-added">+     if (dest_elem == T_ARRAY)  dest_elem = T_OBJECT;</span>
  
      if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
        // If both arrays are object arrays then having the exact types
        // for both will remove the need for a subtype check at runtime
        // before the call and may make it possible to pick a faster copy
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4793,21 +5135,33 @@</span>
          uncommon_trap(Deoptimization::Reason_intrinsic,
                        Deoptimization::Action_make_not_entrant);
          assert(stopped(), &quot;Should be stopped&quot;);
        }
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();</span>
<span class="udiff-line-added">+     const Type* toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());</span>
<span class="udiff-line-added">+     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));</span>
<span class="udiff-line-added">+     src_type = _gvn.type(src);</span>
<span class="udiff-line-added">+     top_src  = src_type-&gt;isa_aryptr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (top_dest != NULL &amp;&amp; !top_dest-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_dest-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+       generate_valueArray_guard(dest_klass, slow_region);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (top_src != NULL &amp;&amp; !top_src-&gt;elem()-&gt;isa_valuetype() &amp;&amp; !top_src-&gt;is_not_flat()) {</span>
<span class="udiff-line-added">+       Node* src_klass = load_object_klass(src);</span>
<span class="udiff-line-added">+       generate_valueArray_guard(src_klass, slow_region);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      {
        PreserveJVMState pjvms(this);
        set_control(_gvn.transform(slow_region));
        uncommon_trap(Deoptimization::Reason_intrinsic,
                      Deoptimization::Action_make_not_entrant);
        assert(stopped(), &quot;Should be stopped&quot;);
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();</span>
<span class="udiff-line-removed">-     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());</span>
<span class="udiff-line-removed">-     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));</span>
    }
  
    arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
  
    if (stopped()) {
</pre>
<center><a href="arraycopynode.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>