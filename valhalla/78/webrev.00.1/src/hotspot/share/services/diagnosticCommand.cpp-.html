<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;compiler/directivesParser.hpp&quot;
  31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  32 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  39 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  40 #include &quot;runtime/handles.inline.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/javaCalls.hpp&quot;
  43 #include &quot;runtime/os.hpp&quot;
  44 #include &quot;services/diagnosticArgument.hpp&quot;
  45 #include &quot;services/diagnosticCommand.hpp&quot;
  46 #include &quot;services/diagnosticFramework.hpp&quot;
  47 #include &quot;services/heapDumper.hpp&quot;
  48 #include &quot;services/management.hpp&quot;
  49 #include &quot;services/writeableFlags.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
  51 #include &quot;utilities/events.hpp&quot;
  52 #include &quot;utilities/formatBuffer.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 
  55 
  56 static void loadAgentModule(TRAPS) {
  57   ResourceMark rm(THREAD);
  58   HandleMark hm(THREAD);
  59 
  60   JavaValue result(T_OBJECT);
  61   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  62   JavaCalls::call_static(&amp;result,
  63                          SystemDictionary::module_Modules_klass(),
  64                          vmSymbols::loadModule_name(),
  65                          vmSymbols::loadModule_signature(),
  66                          h_module_name,
  67                          THREAD);
  68 }
  69 
  70 void DCmdRegistrant::register_dcmds(){
  71   // Registration of the diagnostic commands
  72   // First argument specifies which interfaces will export the command
  73   // Second argument specifies if the command is enabled
  74   // Third  argument specifies if the command is hidden
  75   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  76                          | DCmd_Source_MBean;
  77   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  88   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  90 #if INCLUDE_SERVICES
  91   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));
  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  97   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));
  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;EventLogDCmd&gt;(full_export, true, false));
  99 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
 100   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
 101 #endif // INCLUDE_JVMTI
 102 #endif // INCLUDE_SERVICES
 103 #if INCLUDE_JVMTI
 104   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 105 #endif // INCLUDE_JVMTI
 106   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 107   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 112   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 114 
 115   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 116   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 117   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 118   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 119 
 120   // Enhanced JMX Agent Support
 121   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 122   // appropriate permission is created for them
 123   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 124   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 125   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 126   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 127   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 128 
 129   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 130 #if INCLUDE_JVMTI
 131   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, true));
 132 #endif // INCLUDE_JVMTI
 133 
 134 }
 135 
 136 #ifndef HAVE_EXTRA_DCMD
 137 void DCmdRegistrant::register_dcmds_ext(){
 138    // Do nothing here
 139 }
 140 #endif
 141 
 142 
 143 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 144   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 145   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 146         &quot;STRING&quot;, false) {
 147   _dcmdparser.add_dcmd_option(&amp;_all);
 148   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 149 };
 150 
 151 
 152 static int compare_strings(const char** s1, const char** s2) {
 153   return ::strcmp(*s1, *s2);
 154 }
 155 
 156 void HelpDCmd::execute(DCmdSource source, TRAPS) {
 157   if (_all.value()) {
 158     GrowableArray&lt;const char*&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 159     cmd_list-&gt;sort(compare_strings);
 160     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 161       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 162                                                   strlen(cmd_list-&gt;at(i)));
 163       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 164                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 165       output()-&gt;print_cr(&quot;\t%s&quot;, factory-&gt;description());
 166       output()-&gt;cr();
 167       factory = factory-&gt;next();
 168     }
 169   } else if (_cmd.has_value()) {
 170     DCmd* cmd = NULL;
 171     DCmdFactory* factory = DCmdFactory::factory(source, _cmd.value(),
 172                                                 strlen(_cmd.value()));
 173     if (factory != NULL) {
 174       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 175                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 176       output()-&gt;print_cr(&quot;%s&quot;, factory-&gt;description());
 177       output()-&gt;print_cr(&quot;\nImpact: %s&quot;, factory-&gt;impact());
 178       JavaPermission p = factory-&gt;permission();
 179       if(p._class != NULL) {
 180         if(p._action != NULL) {
 181           output()-&gt;print_cr(&quot;\nPermission: %s(%s, %s)&quot;,
 182                   p._class, p._name == NULL ? &quot;null&quot; : p._name, p._action);
 183         } else {
 184           output()-&gt;print_cr(&quot;\nPermission: %s(%s)&quot;,
 185                   p._class, p._name == NULL ? &quot;null&quot; : p._name);
 186         }
 187       }
 188       output()-&gt;cr();
 189       cmd = factory-&gt;create_resource_instance(output());
 190       if (cmd != NULL) {
 191         DCmdMark mark(cmd);
 192         cmd-&gt;print_help(factory-&gt;name());
 193       }
 194     } else {
 195       output()-&gt;print_cr(&quot;Help unavailable : &#39;%s&#39; : No such command&quot;, _cmd.value());
 196     }
 197   } else {
 198     output()-&gt;print_cr(&quot;The following commands are available:&quot;);
 199     GrowableArray&lt;const char *&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 200     cmd_list-&gt;sort(compare_strings);
 201     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 202       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 203                                                   strlen(cmd_list-&gt;at(i)));
 204       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 205                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 206       factory = factory-&gt;_next;
 207     }
 208     output()-&gt;print_cr(&quot;\nFor more information about a specific command use &#39;help &lt;command&gt;&#39;.&quot;);
 209   }
 210 }
 211 
 212 int HelpDCmd::num_arguments() {
 213   ResourceMark rm;
 214   HelpDCmd* dcmd = new HelpDCmd(NULL, false);
 215   if (dcmd != NULL) {
 216     DCmdMark mark(dcmd);
 217     return dcmd-&gt;_dcmdparser.num_arguments();
 218   } else {
 219     return 0;
 220   }
 221 }
 222 
 223 void VersionDCmd::execute(DCmdSource source, TRAPS) {
 224   output()-&gt;print_cr(&quot;%s version %s&quot;, VM_Version::vm_name(),
 225           VM_Version::vm_release());
 226   JDK_Version jdk_version = JDK_Version::current();
 227   if (jdk_version.patch_version() &gt; 0) {
 228     output()-&gt;print_cr(&quot;JDK %d.%d.%d.%d&quot;, jdk_version.major_version(),
 229             jdk_version.minor_version(), jdk_version.security_version(),
 230             jdk_version.patch_version());
 231   } else {
 232     output()-&gt;print_cr(&quot;JDK %d.%d.%d&quot;, jdk_version.major_version(),
 233             jdk_version.minor_version(), jdk_version.security_version());
 234   }
 235 }
 236 
 237 PrintVMFlagsDCmd::PrintVMFlagsDCmd(outputStream* output, bool heap) :
 238                                    DCmdWithParser(output, heap),
 239   _all(&quot;-all&quot;, &quot;Print all flags supported by the VM&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 240   _dcmdparser.add_dcmd_option(&amp;_all);
 241 }
 242 
 243 void PrintVMFlagsDCmd::execute(DCmdSource source, TRAPS) {
 244   if (_all.value()) {
 245     JVMFlag::printFlags(output(), true);
 246   } else {
 247     JVMFlag::printSetFlags(output());
 248   }
 249 }
 250 
 251 int PrintVMFlagsDCmd::num_arguments() {
 252     ResourceMark rm;
 253     PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);
 254     if (dcmd != NULL) {
 255       DCmdMark mark(dcmd);
 256       return dcmd-&gt;_dcmdparser.num_arguments();
 257     } else {
 258       return 0;
 259     }
 260 }
 261 
 262 SetVMFlagDCmd::SetVMFlagDCmd(outputStream* output, bool heap) :
 263                                    DCmdWithParser(output, heap),
 264   _flag(&quot;flag name&quot;, &quot;The name of the flag we want to set&quot;,
 265         &quot;STRING&quot;, true),
 266   _value(&quot;string value&quot;, &quot;The value we want to set&quot;, &quot;STRING&quot;, false) {
 267   _dcmdparser.add_dcmd_argument(&amp;_flag);
 268   _dcmdparser.add_dcmd_argument(&amp;_value);
 269 }
 270 
 271 void SetVMFlagDCmd::execute(DCmdSource source, TRAPS) {
 272   const char* val = NULL;
 273   if (_value.value() != NULL) {
 274     val = _value.value();
 275   }
 276 
 277   FormatBuffer&lt;80&gt; err_msg(&quot;%s&quot;, &quot;&quot;);
 278   int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);
 279 
 280   if (ret != JVMFlag::SUCCESS) {
 281     output()-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
 282   }
 283 }
 284 
 285 int SetVMFlagDCmd::num_arguments() {
 286   ResourceMark rm;
 287   SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);
 288   if (dcmd != NULL) {
 289     DCmdMark mark(dcmd);
 290     return dcmd-&gt;_dcmdparser.num_arguments();
 291   } else {
 292     return 0;
 293   }
 294 }
 295 
 296 void JVMTIDataDumpDCmd::execute(DCmdSource source, TRAPS) {
 297   if (JvmtiExport::should_post_data_dump()) {
 298     JvmtiExport::post_data_dump();
 299   }
 300 }
 301 
 302 #if INCLUDE_SERVICES
 303 JVMTIAgentLoadDCmd::JVMTIAgentLoadDCmd(outputStream* output, bool heap) :
 304                                        DCmdWithParser(output, heap),
 305   _libpath(&quot;library path&quot;, &quot;Absolute path of the JVMTI agent to load.&quot;,
 306            &quot;STRING&quot;, true),
 307   _option(&quot;agent option&quot;, &quot;Option string to pass the agent.&quot;, &quot;STRING&quot;, false) {
 308   _dcmdparser.add_dcmd_argument(&amp;_libpath);
 309   _dcmdparser.add_dcmd_argument(&amp;_option);
 310 }
 311 
 312 void JVMTIAgentLoadDCmd::execute(DCmdSource source, TRAPS) {
 313 
 314   if (_libpath.value() == NULL) {
 315     output()-&gt;print_cr(&quot;JVMTI.agent_load dcmd needs library path.&quot;);
 316     return;
 317   }
 318 
 319   char *suffix = strrchr(_libpath.value(), &#39;.&#39;);
 320   bool is_java_agent = (suffix != NULL) &amp;&amp; (strncmp(&quot;.jar&quot;, suffix, 4) == 0);
 321 
 322   if (is_java_agent) {
 323     if (_option.value() == NULL) {
 324       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;,
 325                                       _libpath.value(), output());
 326     } else {
 327       size_t opt_len = strlen(_libpath.value()) + strlen(_option.value()) + 2;
 328       if (opt_len &gt; 4096) {
 329         output()-&gt;print_cr(&quot;JVMTI agent attach failed: Options is too long.&quot;);
 330         return;
 331       }
 332 
 333       char *opt = (char *)os::malloc(opt_len, mtInternal);
 334       if (opt == NULL) {
 335         output()-&gt;print_cr(&quot;JVMTI agent attach failed: &quot;
 336                            &quot;Could not allocate &quot; SIZE_FORMAT &quot; bytes for argument.&quot;,
 337                            opt_len);
 338         return;
 339       }
 340 
 341       jio_snprintf(opt, opt_len, &quot;%s=%s&quot;, _libpath.value(), _option.value());
 342       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;, opt, output());
 343 
 344       os::free(opt);
 345     }
 346   } else {
 347     JvmtiExport::load_agent_library(_libpath.value(), &quot;true&quot;,
 348                                     _option.value(), output());
 349   }
 350 }
 351 
 352 int JVMTIAgentLoadDCmd::num_arguments() {
 353   ResourceMark rm;
 354   JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);
 355   if (dcmd != NULL) {
 356     DCmdMark mark(dcmd);
 357     return dcmd-&gt;_dcmdparser.num_arguments();
 358   } else {
 359     return 0;
 360   }
 361 }
 362 #endif // INCLUDE_SERVICES
 363 
 364 void PrintSystemPropertiesDCmd::execute(DCmdSource source, TRAPS) {
 365   // load VMSupport
 366   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
 367   Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK);
 368   InstanceKlass* ik = InstanceKlass::cast(k);
 369   if (ik-&gt;should_be_initialized()) {
 370     ik-&gt;initialize(THREAD);
 371   }
 372   if (HAS_PENDING_EXCEPTION) {
 373     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 374     output()-&gt;cr();
 375     CLEAR_PENDING_EXCEPTION;
 376     return;
 377   }
 378 
 379   // invoke the serializePropertiesToByteArray method
 380   JavaValue result(T_OBJECT);
 381   JavaCallArguments args;
 382 
 383   Symbol* signature = vmSymbols::serializePropertiesToByteArray_signature();
 384   JavaCalls::call_static(&amp;result,
 385                          ik,
 386                          vmSymbols::serializePropertiesToByteArray_name(),
 387                          signature,
 388                          &amp;args,
 389                          THREAD);
 390   if (HAS_PENDING_EXCEPTION) {
 391     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 392     output()-&gt;cr();
 393     CLEAR_PENDING_EXCEPTION;
 394     return;
 395   }
 396 
 397   // The result should be a [B
 398   oop res = (oop)result.get_jobject();
 399   assert(res-&gt;is_typeArray(), &quot;just checking&quot;);
 400   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;just checking&quot;);
 401 
 402   // copy the bytes to the output stream
 403   typeArrayOop ba = typeArrayOop(res);
 404   jbyte* addr = typeArrayOop(res)-&gt;byte_at_addr(0);
 405   output()-&gt;print_raw((const char*)addr, ba-&gt;length());
 406 }
 407 
 408 VMUptimeDCmd::VMUptimeDCmd(outputStream* output, bool heap) :
 409                            DCmdWithParser(output, heap),
 410   _date(&quot;-date&quot;, &quot;Add a prefix with current date&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 411   _dcmdparser.add_dcmd_option(&amp;_date);
 412 }
 413 
 414 void VMUptimeDCmd::execute(DCmdSource source, TRAPS) {
 415   if (_date.value()) {
 416     output()-&gt;date_stamp(true, &quot;&quot;, &quot;: &quot;);
 417   }
 418   output()-&gt;time_stamp().update_to(tty-&gt;time_stamp().ticks());
 419   output()-&gt;stamp();
 420   output()-&gt;print_cr(&quot; s&quot;);
 421 }
 422 
 423 int VMUptimeDCmd::num_arguments() {
 424   ResourceMark rm;
 425   VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);
 426   if (dcmd != NULL) {
 427     DCmdMark mark(dcmd);
 428     return dcmd-&gt;_dcmdparser.num_arguments();
 429   } else {
 430     return 0;
 431   }
 432 }
 433 
 434 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 435   VMError::print_vm_info(_output);
 436 }
 437 
 438 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 439   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 440 }
 441 
 442 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 443   Klass* k = SystemDictionary::System_klass();
 444   JavaValue result(T_VOID);
 445   JavaCalls::call_static(&amp;result, k,
 446                          vmSymbols::run_finalization_name(),
 447                          vmSymbols::void_method_signature(), CHECK);
 448 }
 449 
 450 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
 451   MutexLocker hl(THREAD, Heap_lock);
 452   Universe::heap()-&gt;print_on(output());
 453 }
 454 
 455 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
 456   ResourceMark rm(THREAD);
 457 
 458   Klass* k = SystemDictionary::resolve_or_fail(
 459     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 460 
 461   JavaValue result(T_ARRAY);
 462 
 463   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 464   // and expect it to return array of FinalizerHistogramEntry as Object[]
 465 
 466   JavaCalls::call_static(&amp;result, k,
 467                          vmSymbols::get_finalizer_histogram_name(),
 468                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 469 
 470   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 471   if (result_oop-&gt;length() == 0) {
 472     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 473     return;
 474   }
 475 
 476   oop foop = result_oop-&gt;obj_at(0);
 477   InstanceKlass* ik = InstanceKlass::cast(foop-&gt;klass());
 478 
 479   fieldDescriptor count_fd, name_fd;
 480 
 481   Klass* count_res = ik-&gt;find_field(
 482     vmSymbols::finalizer_histogram_entry_count_field(), vmSymbols::int_signature(), &amp;count_fd);
 483 
 484   Klass* name_res = ik-&gt;find_field(
 485     vmSymbols::finalizer_histogram_entry_name_field(), vmSymbols::string_signature(), &amp;name_fd);
 486 
 487   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 488 
 489   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 490   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 491   output()-&gt;print_cr(&quot;-----------------------&quot;);
 492 
 493   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 494     oop element_oop = result_oop-&gt;obj_at(i);
 495     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 496     char *name = java_lang_String::as_utf8_string(str_oop);
 497     int count = element_oop-&gt;int_field(count_fd.offset());
 498     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 499   }
 500 }
 501 
 502 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 503 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 504                            DCmdWithParser(output, heap),
 505   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 506   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 507        &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 508   _gzip(&quot;-gz&quot;, &quot;If specified, the heap dump is written in gzipped format &quot;
 509                &quot;using the given compression level. 1 (recommended) is the fastest, &quot;
 510                &quot;9 the strongest compression.&quot;, &quot;INT&quot;, false, &quot;1&quot;) {
 511   _dcmdparser.add_dcmd_option(&amp;_all);
 512   _dcmdparser.add_dcmd_argument(&amp;_filename);
 513   _dcmdparser.add_dcmd_option(&amp;_gzip);
 514 }
 515 
 516 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 517   jlong level = -1; // -1 means no compression.
 518 
 519   if (_gzip.is_set()) {
 520     level = _gzip.value();
 521 
 522     if (level &lt; 1 || level &gt; 9) {
 523       output()-&gt;print_cr(&quot;Compression level out of range (1-9): &quot; JLONG_FORMAT, level);
 524       return;
 525     }
 526   }
 527 
 528   // Request a full GC before heap dump if _all is false
 529   // This helps reduces the amount of unreachable objects in the dump
 530   // and makes it easier to browse.
 531   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
 532   dumper.dump(_filename.value(), output(), (int) level);
 533 }
 534 
 535 int HeapDumpDCmd::num_arguments() {
 536   ResourceMark rm;
 537   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 538   if (dcmd != NULL) {
 539     DCmdMark mark(dcmd);
 540     return dcmd-&gt;_dcmdparser.num_arguments();
 541   } else {
 542     return 0;
 543   }
 544 }
 545 
 546 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 547                                        DCmdWithParser(output, heap),
 548   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 549        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 550   _dcmdparser.add_dcmd_option(&amp;_all);
 551 }
 552 
 553 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 554   VM_GC_HeapInspection heapop(output(),
 555                               !_all.value() /* request full gc if false */);
 556   VMThread::execute(&amp;heapop);
 557 }
 558 
 559 int ClassHistogramDCmd::num_arguments() {
 560   ResourceMark rm;
 561   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 562   if (dcmd != NULL) {
 563     DCmdMark mark(dcmd);
 564     return dcmd-&gt;_dcmdparser.num_arguments();
 565   } else {
 566     return 0;
 567   }
 568 }
 569 
 570 #endif // INCLUDE_SERVICES
 571 
 572 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 573                                DCmdWithParser(output, heap),
 574   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 575   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 576   _dcmdparser.add_dcmd_option(&amp;_locks);
 577   _dcmdparser.add_dcmd_option(&amp;_extended);
 578 }
 579 
 580 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 581   // thread stacks
 582   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 583   VMThread::execute(&amp;op1);
 584 
 585   // JNI global handles
 586   VM_PrintJNI op2(output());
 587   VMThread::execute(&amp;op2);
 588 
 589   // Deadlock detection
 590   VM_FindDeadlocks op3(output());
 591   VMThread::execute(&amp;op3);
 592 }
 593 
 594 int ThreadDumpDCmd::num_arguments() {
 595   ResourceMark rm;
 596   ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);
 597   if (dcmd != NULL) {
 598     DCmdMark mark(dcmd);
 599     return dcmd-&gt;_dcmdparser.num_arguments();
 600   } else {
 601     return 0;
 602   }
 603 }
 604 
 605 // Enhanced JMX Agent support
 606 
 607 JMXStartRemoteDCmd::JMXStartRemoteDCmd(outputStream *output, bool heap_allocated) :
 608 
 609   DCmdWithParser(output, heap_allocated),
 610 
 611   _config_file
 612   (&quot;config.file&quot;,
 613    &quot;set com.sun.management.config.file&quot;, &quot;STRING&quot;, false),
 614 
 615   _jmxremote_host
 616   (&quot;jmxremote.host&quot;,
 617    &quot;set com.sun.management.jmxremote.host&quot;, &quot;STRING&quot;, false),
 618 
 619   _jmxremote_port
 620   (&quot;jmxremote.port&quot;,
 621    &quot;set com.sun.management.jmxremote.port&quot;, &quot;STRING&quot;, false),
 622 
 623   _jmxremote_rmi_port
 624   (&quot;jmxremote.rmi.port&quot;,
 625    &quot;set com.sun.management.jmxremote.rmi.port&quot;, &quot;STRING&quot;, false),
 626 
 627   _jmxremote_ssl
 628   (&quot;jmxremote.ssl&quot;,
 629    &quot;set com.sun.management.jmxremote.ssl&quot;, &quot;STRING&quot;, false),
 630 
 631   _jmxremote_registry_ssl
 632   (&quot;jmxremote.registry.ssl&quot;,
 633    &quot;set com.sun.management.jmxremote.registry.ssl&quot;, &quot;STRING&quot;, false),
 634 
 635   _jmxremote_authenticate
 636   (&quot;jmxremote.authenticate&quot;,
 637    &quot;set com.sun.management.jmxremote.authenticate&quot;, &quot;STRING&quot;, false),
 638 
 639   _jmxremote_password_file
 640   (&quot;jmxremote.password.file&quot;,
 641    &quot;set com.sun.management.jmxremote.password.file&quot;, &quot;STRING&quot;, false),
 642 
 643   _jmxremote_access_file
 644   (&quot;jmxremote.access.file&quot;,
 645    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 646 
 647   _jmxremote_login_config
 648   (&quot;jmxremote.login.config&quot;,
 649    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 650 
 651   _jmxremote_ssl_enabled_cipher_suites
 652   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 653    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 654 
 655   _jmxremote_ssl_enabled_protocols
 656   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 657    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 658 
 659   _jmxremote_ssl_need_client_auth
 660   (&quot;jmxremote.ssl.need.client.auth&quot;,
 661    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 662 
 663   _jmxremote_ssl_config_file
 664   (&quot;jmxremote.ssl.config.file&quot;,
 665    &quot;set com.sun.management.jmxremote.ssl.config.file&quot;, &quot;STRING&quot;, false),
 666 
 667 // JDP Protocol support
 668   _jmxremote_autodiscovery
 669   (&quot;jmxremote.autodiscovery&quot;,
 670    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 671 
 672    _jdp_port
 673   (&quot;jdp.port&quot;,
 674    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 675 
 676    _jdp_address
 677   (&quot;jdp.address&quot;,
 678    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 679 
 680    _jdp_source_addr
 681   (&quot;jdp.source_addr&quot;,
 682    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 683 
 684    _jdp_ttl
 685   (&quot;jdp.ttl&quot;,
 686    &quot;set com.sun.management.jdp.ttl&quot;, &quot;INT&quot;, false),
 687 
 688    _jdp_pause
 689   (&quot;jdp.pause&quot;,
 690    &quot;set com.sun.management.jdp.pause&quot;, &quot;INT&quot;, false),
 691 
 692    _jdp_name
 693   (&quot;jdp.name&quot;,
 694    &quot;set com.sun.management.jdp.name&quot;, &quot;STRING&quot;, false)
 695 
 696   {
 697     _dcmdparser.add_dcmd_option(&amp;_config_file);
 698     _dcmdparser.add_dcmd_option(&amp;_jmxremote_host);
 699     _dcmdparser.add_dcmd_option(&amp;_jmxremote_port);
 700     _dcmdparser.add_dcmd_option(&amp;_jmxremote_rmi_port);
 701     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl);
 702     _dcmdparser.add_dcmd_option(&amp;_jmxremote_registry_ssl);
 703     _dcmdparser.add_dcmd_option(&amp;_jmxremote_authenticate);
 704     _dcmdparser.add_dcmd_option(&amp;_jmxremote_password_file);
 705     _dcmdparser.add_dcmd_option(&amp;_jmxremote_access_file);
 706     _dcmdparser.add_dcmd_option(&amp;_jmxremote_login_config);
 707     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_cipher_suites);
 708     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_protocols);
 709     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_need_client_auth);
 710     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_config_file);
 711     _dcmdparser.add_dcmd_option(&amp;_jmxremote_autodiscovery);
 712     _dcmdparser.add_dcmd_option(&amp;_jdp_port);
 713     _dcmdparser.add_dcmd_option(&amp;_jdp_address);
 714     _dcmdparser.add_dcmd_option(&amp;_jdp_source_addr);
 715     _dcmdparser.add_dcmd_option(&amp;_jdp_ttl);
 716     _dcmdparser.add_dcmd_option(&amp;_jdp_pause);
 717     _dcmdparser.add_dcmd_option(&amp;_jdp_name);
 718 }
 719 
 720 
 721 int JMXStartRemoteDCmd::num_arguments() {
 722   ResourceMark rm;
 723   JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);
 724   if (dcmd != NULL) {
 725     DCmdMark mark(dcmd);
 726     return dcmd-&gt;_dcmdparser.num_arguments();
 727   } else {
 728     return 0;
 729   }
 730 }
 731 
 732 
 733 void JMXStartRemoteDCmd::execute(DCmdSource source, TRAPS) {
 734     ResourceMark rm(THREAD);
 735     HandleMark hm(THREAD);
 736 
 737     // Load and initialize the jdk.internal.agent.Agent class
 738     // invoke startRemoteManagementAgent(string) method to start
 739     // the remote management server.
 740     // throw java.lang.NoSuchMethodError if the method doesn&#39;t exist
 741 
 742     loadAgentModule(CHECK);
 743     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 744     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 745 
 746     JavaValue result(T_VOID);
 747 
 748     // Pass all command line arguments to java as key=value,...
 749     // All checks are done on java side
 750 
 751     int len = 0;
 752     stringStream options;
 753     char comma[2] = {0,0};
 754 
 755     // Leave default values on Agent.class side and pass only
 756     // agruments explicitly set by user. All arguments passed
 757     // to jcmd override properties with the same name set by
 758     // command line with -D or by managmenent.properties
 759     // file.
 760 #define PUT_OPTION(a) \
 761     do { \
 762         if ( (a).is_set() ){ \
 763             if ( *((a).type()) == &#39;I&#39; ) { \
 764                 options.print(&quot;%scom.sun.management.%s=&quot; JLONG_FORMAT, comma, (a).name(), (jlong)((a).value())); \
 765             } else { \
 766                 options.print(&quot;%scom.sun.management.%s=%s&quot;, comma, (a).name(), (char*)((a).value())); \
 767             } \
 768             comma[0] = &#39;,&#39;; \
 769         }\
 770     } while(0);
 771 
 772 
 773     PUT_OPTION(_config_file);
 774     PUT_OPTION(_jmxremote_host);
 775     PUT_OPTION(_jmxremote_port);
 776     PUT_OPTION(_jmxremote_rmi_port);
 777     PUT_OPTION(_jmxremote_ssl);
 778     PUT_OPTION(_jmxremote_registry_ssl);
 779     PUT_OPTION(_jmxremote_authenticate);
 780     PUT_OPTION(_jmxremote_password_file);
 781     PUT_OPTION(_jmxremote_access_file);
 782     PUT_OPTION(_jmxremote_login_config);
 783     PUT_OPTION(_jmxremote_ssl_enabled_cipher_suites);
 784     PUT_OPTION(_jmxremote_ssl_enabled_protocols);
 785     PUT_OPTION(_jmxremote_ssl_need_client_auth);
 786     PUT_OPTION(_jmxremote_ssl_config_file);
 787     PUT_OPTION(_jmxremote_autodiscovery);
 788     PUT_OPTION(_jdp_port);
 789     PUT_OPTION(_jdp_address);
 790     PUT_OPTION(_jdp_source_addr);
 791     PUT_OPTION(_jdp_ttl);
 792     PUT_OPTION(_jdp_pause);
 793     PUT_OPTION(_jdp_name);
 794 
 795 #undef PUT_OPTION
 796 
 797     Handle str = java_lang_String::create_from_str(options.as_string(), CHECK);
 798     JavaCalls::call_static(&amp;result, k, vmSymbols::startRemoteAgent_name(), vmSymbols::string_void_signature(), str, CHECK);
 799 }
 800 
 801 JMXStartLocalDCmd::JMXStartLocalDCmd(outputStream *output, bool heap_allocated) :
 802   DCmd(output, heap_allocated) {
 803   // do nothing
 804 }
 805 
 806 void JMXStartLocalDCmd::execute(DCmdSource source, TRAPS) {
 807     ResourceMark rm(THREAD);
 808     HandleMark hm(THREAD);
 809 
 810     // Load and initialize the jdk.internal.agent.Agent class
 811     // invoke startLocalManagementAgent(void) method to start
 812     // the local management server
 813     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 814 
 815     loadAgentModule(CHECK);
 816     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 817     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 818 
 819     JavaValue result(T_VOID);
 820     JavaCalls::call_static(&amp;result, k, vmSymbols::startLocalAgent_name(), vmSymbols::void_method_signature(), CHECK);
 821 }
 822 
 823 void JMXStopRemoteDCmd::execute(DCmdSource source, TRAPS) {
 824     ResourceMark rm(THREAD);
 825     HandleMark hm(THREAD);
 826 
 827     // Load and initialize the jdk.internal.agent.Agent class
 828     // invoke stopRemoteManagementAgent method to stop the
 829     // management server
 830     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 831 
 832     loadAgentModule(CHECK);
 833     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 834     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 835 
 836     JavaValue result(T_VOID);
 837     JavaCalls::call_static(&amp;result, k, vmSymbols::stopRemoteAgent_name(), vmSymbols::void_method_signature(), CHECK);
 838 }
 839 
 840 JMXStatusDCmd::JMXStatusDCmd(outputStream *output, bool heap_allocated) :
 841   DCmd(output, heap_allocated) {
 842   // do nothing
 843 }
 844 
 845 void JMXStatusDCmd::execute(DCmdSource source, TRAPS) {
 846   ResourceMark rm(THREAD);
 847   HandleMark hm(THREAD);
 848 
 849   // Load and initialize the jdk.internal.agent.Agent class
 850   // invoke getManagementAgentStatus() method to generate the status info
 851   // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 852 
 853   loadAgentModule(CHECK);
 854   Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 855   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 856 
 857   JavaValue result(T_OBJECT);
 858   JavaCalls::call_static(&amp;result, k, vmSymbols::getAgentStatus_name(), vmSymbols::void_string_signature(), CHECK);
 859 
 860   jvalue* jv = (jvalue*) result.get_value_addr();
 861   oop str = (oop) jv-&gt;l;
 862   if (str != NULL) {
 863       char* out = java_lang_String::as_utf8_string(str);
 864       if (out) {
 865           output()-&gt;print_cr(&quot;%s&quot;, out);
 866           return;
 867       }
 868   }
 869   output()-&gt;print_cr(&quot;Error obtaining management agent status&quot;);
 870 }
 871 
 872 VMDynamicLibrariesDCmd::VMDynamicLibrariesDCmd(outputStream *output, bool heap_allocated) :
 873   DCmd(output, heap_allocated) {
 874   // do nothing
 875 }
 876 
 877 void VMDynamicLibrariesDCmd::execute(DCmdSource source, TRAPS) {
 878   os::print_dll_info(output());
 879   output()-&gt;cr();
 880 }
 881 
 882 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 883   VM_PrintCompileQueue printCompileQueueOp(output());
 884   VMThread::execute(&amp;printCompileQueueOp);
 885 }
 886 
 887 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 888   CodeCache::print_codelist(output());
 889 }
 890 
 891 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 892   CodeCache::print_layout(output());
 893 }
 894 
 895 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 896 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 897                                              DCmdWithParser(output, heap),
 898   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
 899   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;INT&quot;, false, &quot;4096&quot;) {
 900   _dcmdparser.add_dcmd_argument(&amp;_function);
 901   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 902 }
 903 
 904 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
 905   jlong granularity = _granularity.value();
 906   if (granularity &lt; 1) {
 907     Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
 908                        &quot;Invalid granularity value &quot; JLONG_FORMAT  &quot;. Should be positive.\n&quot;, granularity);
 909     return;
 910   }
 911 
 912   CompileBroker::print_heapinfo(output(), _function.value(), granularity);
 913 }
 914 
 915 int CodeHeapAnalyticsDCmd::num_arguments() {
 916   ResourceMark rm;
 917   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 918   if (dcmd != NULL) {
 919     DCmdMark mark(dcmd);
 920     return dcmd-&gt;_dcmdparser.num_arguments();
 921   } else {
 922     return 0;
 923   }
 924 }
 925 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 926 
 927 EventLogDCmd::EventLogDCmd(outputStream* output, bool heap) :
 928   DCmdWithParser(output, heap),
 929   _log(&quot;log&quot;, &quot;Name of log to be printed. If omitted, all logs are printed.&quot;, &quot;STRING&quot;, false, NULL),
 930   _max(&quot;max&quot;, &quot;Maximum number of events to be printed (newest first). If omitted, all events are printed.&quot;, &quot;STRING&quot;, false, NULL)
 931 {
 932   _dcmdparser.add_dcmd_option(&amp;_log);
 933   _dcmdparser.add_dcmd_option(&amp;_max);
 934 }
 935 
 936 void EventLogDCmd::execute(DCmdSource source, TRAPS) {
 937   const char* max_value = _max.value();
 938   long max = -1;
 939   if (max_value != NULL) {
 940     char* endptr = NULL;
 941     max = ::strtol(max_value, &amp;endptr, 10);
 942     if (max == 0 &amp;&amp; max_value == endptr) {
 943       output()-&gt;print_cr(&quot;Invalid max option: \&quot;%s\&quot;.&quot;, max_value);
 944       return;
 945     }
 946   }
 947   const char* log_name = _log.value();
 948   if (log_name != NULL) {
 949     Events::print_one(output(), log_name, max);
 950   } else {
 951     Events::print_all(output(), max);
 952   }
 953 }
 954 
 955 int EventLogDCmd::num_arguments() {
 956   ResourceMark rm;
 957   EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);
 958   if (dcmd != NULL) {
 959     DCmdMark mark(dcmd);
 960     return dcmd-&gt;_dcmdparser.num_arguments();
 961   } else {
 962     return 0;
 963   }
 964 }
 965 
 966 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 967   DirectivesStack::print(output());
 968 }
 969 
 970 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 971                            DCmdWithParser(output, heap),
 972   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 973   _dcmdparser.add_dcmd_argument(&amp;_filename);
 974 }
 975 
 976 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 977   DirectivesParser::parse_from_file(_filename.value(), output());
 978 }
 979 
 980 int CompilerDirectivesAddDCmd::num_arguments() {
 981   ResourceMark rm;
 982   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 983   if (dcmd != NULL) {
 984     DCmdMark mark(dcmd);
 985     return dcmd-&gt;_dcmdparser.num_arguments();
 986   } else {
 987     return 0;
 988   }
 989 }
 990 
 991 void CompilerDirectivesRemoveDCmd::execute(DCmdSource source, TRAPS) {
 992   DirectivesStack::pop(1);
 993 }
 994 
 995 void CompilerDirectivesClearDCmd::execute(DCmdSource source, TRAPS) {
 996   DirectivesStack::clear();
 997 }
 998 #if INCLUDE_SERVICES
 999 ClassHierarchyDCmd::ClassHierarchyDCmd(outputStream* output, bool heap) :
1000                                        DCmdWithParser(output, heap),
1001   _print_interfaces(&quot;-i&quot;, &quot;Inherited interfaces should be printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1002   _print_subclasses(&quot;-s&quot;, &quot;If a classname is specified, print its subclasses. &quot;
1003                     &quot;Otherwise only its superclasses are printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
1004   _classname(&quot;classname&quot;, &quot;Name of class whose hierarchy should be printed. &quot;
1005              &quot;If not specified, all class hierarchies are printed.&quot;,
1006              &quot;STRING&quot;, false) {
1007   _dcmdparser.add_dcmd_option(&amp;_print_interfaces);
1008   _dcmdparser.add_dcmd_option(&amp;_print_subclasses);
1009   _dcmdparser.add_dcmd_argument(&amp;_classname);
1010 }
1011 
1012 void ClassHierarchyDCmd::execute(DCmdSource source, TRAPS) {
1013   VM_PrintClassHierarchy printClassHierarchyOp(output(), _print_interfaces.value(),
1014                                                _print_subclasses.value(), _classname.value());
1015   VMThread::execute(&amp;printClassHierarchyOp);
1016 }
1017 
1018 int ClassHierarchyDCmd::num_arguments() {
1019   ResourceMark rm;
1020   ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);
1021   if (dcmd != NULL) {
1022     DCmdMark mark(dcmd);
1023     return dcmd-&gt;_dcmdparser.num_arguments();
1024   } else {
1025     return 0;
1026   }
1027 }
1028 
1029 #endif
1030 
1031 class VM_DumpTouchedMethods : public VM_Operation {
1032 private:
1033   outputStream* _out;
1034 public:
1035   VM_DumpTouchedMethods(outputStream* out) {
1036     _out = out;
1037   }
1038 
1039   virtual VMOp_Type type() const { return VMOp_DumpTouchedMethods; }
1040 
1041   virtual void doit() {
1042     Method::print_touched_methods(_out);
1043   }
1044 };
1045 
1046 TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :
1047                                        DCmdWithParser(output, heap)
1048 {}
1049 
1050 void TouchedMethodsDCmd::execute(DCmdSource source, TRAPS) {
1051   if (!LogTouchedMethods) {
1052     output()-&gt;print_cr(&quot;VM.print_touched_methods command requires -XX:+LogTouchedMethods&quot;);
1053     return;
1054   }
1055   VM_DumpTouchedMethods dumper(output());
1056   VMThread::execute(&amp;dumper);
1057 }
1058 
1059 int TouchedMethodsDCmd::num_arguments() {
1060   return 0;
1061 }
1062 
1063 #if INCLUDE_JVMTI
1064 extern &quot;C&quot; typedef char const* (JNICALL *debugInit_startDebuggingViaCommandPtr)(JNIEnv* env, jthread thread, char const** transport_name,
1065                                                                                 char const** address, jboolean* first_start);
1066 static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = NULL;
1067 
1068 DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {
1069 }
1070 
1071 void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
1072   char const* transport = NULL;
1073   char const* addr = NULL;
1074   jboolean is_first_start = JNI_FALSE;
1075   JavaThread* thread = (JavaThread*) THREAD;
1076   jthread jt = JNIHandles::make_local(thread-&gt;threadObj());
1077   ThreadToNativeFromVM ttn(thread);
1078   const char *error = &quot;Could not find jdwp agent.&quot;;
1079 
1080   if (!dvc_start_ptr) {
1081     for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
1082       if ((strcmp(&quot;jdwp&quot;, agent-&gt;name()) == 0) &amp;&amp; (dvc_start_ptr == NULL)) {
1083         char const* func = &quot;debugInit_startDebuggingViaCommand&quot;;
1084         dvc_start_ptr = (debugInit_startDebuggingViaCommandPtr) os::find_agent_function(agent, false, &amp;func, 1);
1085       }
1086     }
1087   }
1088 
1089   if (dvc_start_ptr) {
1090     error = dvc_start_ptr(thread-&gt;jni_environment(), jt, &amp;transport, &amp;addr, &amp;is_first_start);
1091   }
1092 
1093   if (error != NULL) {
1094     output()-&gt;print_cr(&quot;Debugging has not been started: %s&quot;, error);
1095   } else {
1096     output()-&gt;print_cr(is_first_start ? &quot;Debugging has been started.&quot; : &quot;Debugging is already active.&quot;);
1097     output()-&gt;print_cr(&quot;Transport : %s&quot;, transport ? transport : &quot;#unknown&quot;);
1098     output()-&gt;print_cr(&quot;Address : %s&quot;, addr ? addr : &quot;#unknown&quot;);
1099   }
1100 }
1101 #endif // INCLUDE_JVMTI
    </pre>
  </body>
</html>