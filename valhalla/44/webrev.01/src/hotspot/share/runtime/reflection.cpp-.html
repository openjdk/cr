<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/valueKlass.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 
  57 static void trace_class_resolution(oop mirror) {
  58   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {
  59     return;
  60   }
  61   Klass* to_class = java_lang_Class::as_Klass(mirror);
  62   ResourceMark rm;
  63   int line_number = -1;
  64   const char * source_file = NULL;
  65   Klass* caller = NULL;
  66   JavaThread* jthread = JavaThread::current();
  67   if (jthread-&gt;has_last_Java_frame()) {
  68     vframeStream vfst(jthread);
  69     // skip over any frames belonging to java.lang.Class
  70     while (!vfst.at_end() &amp;&amp;
  71            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  72       vfst.next();
  73     }
  74     if (!vfst.at_end()) {
  75       // this frame is a likely suspect
  76       caller = vfst.method()-&gt;method_holder();
  77       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  78       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  79       if (s != NULL) {
  80         source_file = s-&gt;as_C_string();
  81       }
  82     }
  83   }
  84   if (caller != NULL) {
  85     const char * from = caller-&gt;external_name();
  86     const char * to = to_class-&gt;external_name();
  87     // print in a single call to reduce interleaving between threads
  88     if (source_file != NULL) {
  89       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  90     } else {
  91       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  92     }
  93   }
  94 }
  95 
  96 
  97 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  98   if (type == T_VOID) {
  99     return NULL;
 100   }
 101   if (is_reference_type(type)) {
 102     // regular objects are not boxed
 103     return (oop) value-&gt;l;
 104   }
 105   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 106   if (result == NULL) {
 107     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 108   }
 109   return result;
 110 }
 111 
 112 
 113 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 114   if (box == NULL) {
 115     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 116   }
 117   return java_lang_boxing_object::get_value(box, value);
 118 }
 119 
 120 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 121   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 122   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);
 123   return T_OBJECT;
 124 }
 125 
 126 
 127 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 128   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 129   switch (wide_type) {
 130     case T_BOOLEAN:
 131     case T_BYTE:
 132     case T_CHAR:
 133       break;  // fail
 134     case T_SHORT:
 135       switch (current_type) {
 136         case T_BYTE:
 137           value-&gt;s = (jshort) value-&gt;b;
 138           return;
 139         default:
 140           break;
 141       }
 142       break;  // fail
 143     case T_INT:
 144       switch (current_type) {
 145         case T_BYTE:
 146           value-&gt;i = (jint) value-&gt;b;
 147           return;
 148         case T_CHAR:
 149           value-&gt;i = (jint) value-&gt;c;
 150           return;
 151         case T_SHORT:
 152           value-&gt;i = (jint) value-&gt;s;
 153           return;
 154         default:
 155           break;
 156       }
 157       break;  // fail
 158     case T_LONG:
 159       switch (current_type) {
 160         case T_BYTE:
 161           value-&gt;j = (jlong) value-&gt;b;
 162           return;
 163         case T_CHAR:
 164           value-&gt;j = (jlong) value-&gt;c;
 165           return;
 166         case T_SHORT:
 167           value-&gt;j = (jlong) value-&gt;s;
 168           return;
 169         case T_INT:
 170           value-&gt;j = (jlong) value-&gt;i;
 171           return;
 172         default:
 173           break;
 174       }
 175       break;  // fail
 176     case T_FLOAT:
 177       switch (current_type) {
 178         case T_BYTE:
 179           value-&gt;f = (jfloat) value-&gt;b;
 180           return;
 181         case T_CHAR:
 182           value-&gt;f = (jfloat) value-&gt;c;
 183           return;
 184         case T_SHORT:
 185           value-&gt;f = (jfloat) value-&gt;s;
 186           return;
 187         case T_INT:
 188           value-&gt;f = (jfloat) value-&gt;i;
 189           return;
 190         case T_LONG:
 191           value-&gt;f = (jfloat) value-&gt;j;
 192           return;
 193         default:
 194           break;
 195       }
 196       break;  // fail
 197     case T_DOUBLE:
 198       switch (current_type) {
 199         case T_BYTE:
 200           value-&gt;d = (jdouble) value-&gt;b;
 201           return;
 202         case T_CHAR:
 203           value-&gt;d = (jdouble) value-&gt;c;
 204           return;
 205         case T_SHORT:
 206           value-&gt;d = (jdouble) value-&gt;s;
 207           return;
 208         case T_INT:
 209           value-&gt;d = (jdouble) value-&gt;i;
 210           return;
 211         case T_FLOAT:
 212           value-&gt;d = (jdouble) value-&gt;f;
 213           return;
 214         case T_LONG:
 215           value-&gt;d = (jdouble) value-&gt;j;
 216           return;
 217         default:
 218           break;
 219       }
 220       break;  // fail
 221     default:
 222       break;  // fail
 223   }
 224   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 225 }
 226 
 227 
 228 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 229   if (!a-&gt;is_within_bounds(index)) {
 230     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 231   }
 232   if (a-&gt;is_objArray()) {
 233     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));
 234     return T_OBJECT;
 235   } else {
 236     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 237     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 238     switch (type) {
 239       case T_BOOLEAN:
 240         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 241         break;
 242       case T_CHAR:
 243         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 244         break;
 245       case T_FLOAT:
 246         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 247         break;
 248       case T_DOUBLE:
 249         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 250         break;
 251       case T_BYTE:
 252         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 253         break;
 254       case T_SHORT:
 255         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 256         break;
 257       case T_INT:
 258         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 259         break;
 260       case T_LONG:
 261         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 262         break;
 263       default:
 264         return T_ILLEGAL;
 265     }
 266     return type;
 267   }
 268 }
 269 
 270 
 271 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 272   if (!a-&gt;is_within_bounds(index)) {
 273     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 274   }
 275   if (a-&gt;is_objArray()) {
 276     if (value_type == T_OBJECT) {
 277       oop obj = (oop) value-&gt;l;
 278       if (obj != NULL) {
 279         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 280         if (!obj-&gt;is_a(element_klass)) {
 281           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;array element type mismatch&quot;);
 282         }
 283       }
 284       objArrayOop(a)-&gt;obj_at_put(index, obj);
 285     }
 286   } else {
 287     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 288     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 289     if (array_type != value_type) {
 290       // The widen operation can potentially throw an exception, but cannot block,
 291       // so typeArrayOop a is safe if the call succeeds.
 292       widen(value, value_type, array_type, CHECK);
 293     }
 294     switch (array_type) {
 295       case T_BOOLEAN:
 296         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 297         break;
 298       case T_CHAR:
 299         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 300         break;
 301       case T_FLOAT:
 302         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 303         break;
 304       case T_DOUBLE:
 305         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 306         break;
 307       case T_BYTE:
 308         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 309         break;
 310       case T_SHORT:
 311         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 312         break;
 313       case T_INT:
 314         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 315         break;
 316       case T_LONG:
 317         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 318         break;
 319       default:
 320         THROW(vmSymbols::java_lang_IllegalArgumentException());
 321     }
 322   }
 323 }
 324 
 325 static Klass* basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 326   assert(java_lang_Class::is_primitive(basic_type_mirror), &quot;just checking&quot;);
 327   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 328   if (type == T_VOID) {
 329     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 330   }
 331   else {
 332     return Universe::typeArrayKlassObj(type);
 333   }
 334 }
 335 
 336 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 337   if (element_mirror == NULL) {
 338     THROW_0(vmSymbols::java_lang_NullPointerException());
 339   }
 340   if (length &lt; 0) {
 341     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 342   }
 343   if (java_lang_Class::is_primitive(element_mirror)) {
 344     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 345     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 346   } else {
 347     Klass* k = java_lang_Class::as_Klass(element_mirror);
 348     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 349       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 350     }
 351     if (java_lang_Class::is_indirect_type(element_mirror)) {
 352       return oopFactory::new_objArray(k, length, THREAD);
 353     } else {
 354       return oopFactory::new_valueArray(k, length, THREAD);
 355     }
 356   }
 357 }
 358 
 359 
 360 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 361   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 362   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 363 
 364   if (element_mirror == NULL) {
 365     THROW_0(vmSymbols::java_lang_NullPointerException());
 366   }
 367 
 368   int len = dim_array-&gt;length();
 369   if (len &lt;= 0 || len &gt; MAX_DIM) {
 370     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 371   }
 372 
 373   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 374   for (int i = 0; i &lt; len; i++) {
 375     int d = dim_array-&gt;int_at(i);
 376     if (d &lt; 0) {
 377       THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, d));
 378     }
 379     dimensions[i] = d;
 380   }
 381 
 382   Klass* klass;
 383   int dim = len;
 384   if (java_lang_Class::is_primitive(element_mirror)) {
 385     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 386   } else {
 387     klass = java_lang_Class::as_Klass(element_mirror);
 388     if (klass-&gt;is_array_klass()) {
 389       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 390       if (k_dim + len &gt; MAX_DIM) {
 391         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 392       }
 393       dim += k_dim;
 394     }
 395   }
 396   ArrayStorageProperties storage_props = ArrayStorageProperties::for_signature(klass-&gt;name());
 397   klass = klass-&gt;array_klass(storage_props, dim, CHECK_NULL);
 398   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 399   assert(obj-&gt;is_array(), &quot;just checking&quot;);
 400   return arrayOop(obj);
 401 }
 402 
 403 
 404 static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {
 405   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 406   for (;;) {
 407     const InstanceKlass* hc = ik-&gt;unsafe_anonymous_host();
 408     if (hc == NULL)        return false;
 409     if (hc == unsafe_anonymous_host)  return true;
 410     ik = hc;
 411 
 412     // There&#39;s no way to make a host class loop short of patching memory.
 413     // Therefore there cannot be a loop here unless there&#39;s another bug.
 414     // Still, let&#39;s check for it.
 415     assert(--inf_loop_check &gt; 0, &quot;no unsafe_anonymous_host loop&quot;);
 416   }
 417 }
 418 
 419 static bool can_relax_access_check_for(const Klass* accessor,
 420                                        const Klass* accessee,
 421                                        bool classloader_only) {
 422 
 423   const InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 424   const InstanceKlass* accessee_ik = InstanceKlass::cast(accessee);
 425 
 426   // If either is on the other&#39;s unsafe_anonymous_host chain, access is OK,
 427   // because one is inside the other.
 428   if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||
 429     under_unsafe_anonymous_host(accessee_ik, accessor_ik))
 430     return true;
 431 
 432   if (RelaxAccessControlCheck &amp;&amp;
 433     accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 434     accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) {
 435     return classloader_only &amp;&amp;
 436       Verifier::relax_access_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 437       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 438       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 439   }
 440 
 441   return false;
 442 }
 443 
 444 /*
 445     Type Accessibility check for public types: Callee Type T is accessible to Caller Type S if:
 446 
 447                         Callee T in             Callee T in package PT,
 448                         unnamed module          runtime module MT
 449  ------------------------------------------------------------------------------------------------
 450 
 451  Caller S in package     If MS is loose: YES      If same classloader/package (PS == PT): YES
 452  PS, runtime module MS   If MS can read T&#39;s       If same runtime module: (MS == MT): YES
 453                          unnamed module: YES
 454                                                   Else if (MS can read MT (establish readability) &amp;&amp;
 455                                                     ((MT exports PT to MS or to all modules) ||
 456                                                      (MT is open))): YES
 457 
 458  ------------------------------------------------------------------------------------------------
 459  Caller S in unnamed         YES                  Readability exists because unnamed module
 460  module UM                                            &quot;reads&quot; all modules
 461                                                   if (MT exports PT to UM or to all modules): YES
 462 
 463  ------------------------------------------------------------------------------------------------
 464 
 465  Note: a loose module is a module that can read all current and future unnamed modules.
 466 */
 467 Reflection::VerifyClassAccessResults Reflection::verify_class_access(
 468   const Klass* current_class, const InstanceKlass* new_class, bool classloader_only) {
 469 
 470   // Verify that current_class can access new_class.  If the classloader_only
 471   // flag is set, we automatically allow any accesses in which current_class
 472   // doesn&#39;t have a classloader.
 473   if ((current_class == NULL) ||
 474       (current_class == new_class) ||
 475       is_same_class_package(current_class, new_class)) {
 476     return ACCESS_OK;
 477   }
 478   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 479   // succeed trivially.
 480   if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &amp;&amp;
 481       current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 482     return ACCESS_OK;
 483   }
 484 
 485   // module boundaries
 486   if (new_class-&gt;is_public()) {
 487     // Ignore modules for DumpSharedSpaces because we do not have any package
 488     // or module information for modules other than java.base.
 489     if (DumpSharedSpaces) {
 490       return ACCESS_OK;
 491     }
 492 
 493     // Find the module entry for current_class, the accessor
 494     ModuleEntry* module_from = current_class-&gt;module();
 495     // Find the module entry for new_class, the accessee
 496     ModuleEntry* module_to = new_class-&gt;module();
 497 
 498     // both in same (possibly unnamed) module
 499     if (module_from == module_to) {
 500       return ACCESS_OK;
 501     }
 502 
 503     // Acceptable access to a type in an unnamed module. Note that since
 504     // unnamed modules can read all unnamed modules, this also handles the
 505     // case where module_from is also unnamed but in a different class loader.
 506     if (!module_to-&gt;is_named() &amp;&amp;
 507         (module_from-&gt;can_read_all_unnamed() || module_from-&gt;can_read(module_to))) {
 508       return ACCESS_OK;
 509     }
 510 
 511     // Establish readability, check if module_from is allowed to read module_to.
 512     if (!module_from-&gt;can_read(module_to)) {
 513       return MODULE_NOT_READABLE;
 514     }
 515 
 516     // Access is allowed if module_to is open, i.e. all its packages are unqualifiedly exported
 517     if (module_to-&gt;is_open()) {
 518       return ACCESS_OK;
 519     }
 520 
 521     PackageEntry* package_to = new_class-&gt;package();
 522     assert(package_to != NULL, &quot;can not obtain new_class&#39; package&quot;);
 523 
 524     {
 525       MutexLocker m1(Module_lock);
 526 
 527       // Once readability is established, if module_to exports T unqualifiedly,
 528       // (to all modules), than whether module_from is in the unnamed module
 529       // or not does not matter, access is allowed.
 530       if (package_to-&gt;is_unqual_exported()) {
 531         return ACCESS_OK;
 532       }
 533 
 534       // Access is allowed if both 1 &amp; 2 hold:
 535       //   1. Readability, module_from can read module_to (established above).
 536       //   2. Either module_to exports T to module_from qualifiedly.
 537       //      or
 538       //      module_to exports T to all unnamed modules and module_from is unnamed.
 539       //      or
 540       //      module_to exports T unqualifiedly to all modules (checked above).
 541       if (!package_to-&gt;is_qexported_to(module_from)) {
 542         return TYPE_NOT_EXPORTED;
 543       }
 544     }
 545     return ACCESS_OK;
 546   }
 547 
 548   if (can_relax_access_check_for(current_class, new_class, classloader_only)) {
 549     return ACCESS_OK;
 550   }
 551   return OTHER_PROBLEM;
 552 }
 553 
 554 // Return an error message specific to the specified Klass*&#39;s and result.
 555 // This function must be called from within a block containing a ResourceMark.
 556 char* Reflection::verify_class_access_msg(const Klass* current_class,
 557                                           const InstanceKlass* new_class,
 558                                           const VerifyClassAccessResults result) {
 559   assert(result != ACCESS_OK, &quot;must be failure result&quot;);
 560   char * msg = NULL;
 561   if (result != OTHER_PROBLEM &amp;&amp; new_class != NULL &amp;&amp; current_class != NULL) {
 562     // Find the module entry for current_class, the accessor
 563     ModuleEntry* module_from = current_class-&gt;module();
 564     const char * module_from_name = module_from-&gt;is_named() ? module_from-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 565     const char * current_class_name = current_class-&gt;external_name();
 566 
 567     // Find the module entry for new_class, the accessee
 568     ModuleEntry* module_to = NULL;
 569     module_to = new_class-&gt;module();
 570     const char * module_to_name = module_to-&gt;is_named() ? module_to-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 571     const char * new_class_name = new_class-&gt;external_name();
 572 
 573     if (result == MODULE_NOT_READABLE) {
 574       assert(module_from-&gt;is_named(), &quot;Unnamed modules can read all modules&quot;);
 575       if (module_to-&gt;is_named()) {
 576         size_t len = 100 + strlen(current_class_name) + 2*strlen(module_from_name) +
 577           strlen(new_class_name) + 2*strlen(module_to_name);
 578         msg = NEW_RESOURCE_ARRAY(char, len);
 579         jio_snprintf(msg, len - 1,
 580           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not read module %s&quot;,
 581           current_class_name, module_from_name, new_class_name,
 582           module_to_name, module_from_name, module_to_name);
 583       } else {
 584         oop jlm = module_to-&gt;module();
 585         assert(jlm != NULL, &quot;Null jlm in module_to ModuleEntry&quot;);
 586         intptr_t identity_hash = jlm-&gt;identity_hash();
 587         size_t len = 160 + strlen(current_class_name) + 2*strlen(module_from_name) +
 588           strlen(new_class_name) + 2*sizeof(uintx);
 589         msg = NEW_RESOURCE_ARRAY(char, len);
 590         jio_snprintf(msg, len - 1,
 591           &quot;class %s (in module %s) cannot access class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) because module %s does not read unnamed module @&quot; SIZE_FORMAT_HEX,
 592           current_class_name, module_from_name, new_class_name, uintx(identity_hash),
 593           module_from_name, uintx(identity_hash));
 594       }
 595 
 596     } else if (result == TYPE_NOT_EXPORTED) {
 597       assert(new_class-&gt;package() != NULL,
 598              &quot;Unnamed packages are always exported&quot;);
 599       const char * package_name =
 600         new_class-&gt;package()-&gt;name()-&gt;as_klass_external_name();
 601       assert(module_to-&gt;is_named(), &quot;Unnamed modules export all packages&quot;);
 602       if (module_from-&gt;is_named()) {
 603         size_t len = 118 + strlen(current_class_name) + 2*strlen(module_from_name) +
 604           strlen(new_class_name) + 2*strlen(module_to_name) + strlen(package_name);
 605         msg = NEW_RESOURCE_ARRAY(char, len);
 606         jio_snprintf(msg, len - 1,
 607           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not export %s to module %s&quot;,
 608           current_class_name, module_from_name, new_class_name,
 609           module_to_name, module_to_name, package_name, module_from_name);
 610       } else {
 611         oop jlm = module_from-&gt;module();
 612         assert(jlm != NULL, &quot;Null jlm in module_from ModuleEntry&quot;);
 613         intptr_t identity_hash = jlm-&gt;identity_hash();
 614         size_t len = 170 + strlen(current_class_name) + strlen(new_class_name) +
 615           2*strlen(module_to_name) + strlen(package_name) + 2*sizeof(uintx);
 616         msg = NEW_RESOURCE_ARRAY(char, len);
 617         jio_snprintf(msg, len - 1,
 618           &quot;class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) cannot access class %s (in module %s) because module %s does not export %s to unnamed module @&quot; SIZE_FORMAT_HEX,
 619           current_class_name, uintx(identity_hash), new_class_name, module_to_name,
 620           module_to_name, package_name, uintx(identity_hash));
 621       }
 622     } else {
 623         ShouldNotReachHere();
 624     }
 625   }  // result != OTHER_PROBLEM...
 626   return msg;
 627 }
 628 
 629 bool Reflection::verify_member_access(const Klass* current_class,
 630                                       const Klass* resolved_class,
 631                                       const Klass* member_class,
 632                                       AccessFlags access,
 633                                       bool classloader_only,
 634                                       bool protected_restriction,
 635                                       TRAPS) {
 636   // Verify that current_class can access a member of member_class, where that
 637   // field&#39;s access bits are &quot;access&quot;.  We assume that we&#39;ve already verified
 638   // that current_class can access member_class.
 639   //
 640   // If the classloader_only flag is set, we automatically allow any accesses
 641   // in which current_class doesn&#39;t have a classloader.
 642   //
 643   // &quot;resolved_class&quot; is the runtime type of &quot;member_class&quot;. Sometimes we don&#39;t
 644   // need this distinction (e.g. if all we have is the runtime type, or during
 645   // class file parsing when we only care about the static type); in that case
 646   // callers should ensure that resolved_class == member_class.
 647   //
 648   if ((current_class == NULL) ||
 649       (current_class == member_class) ||
 650       access.is_public()) {
 651     return true;
 652   }
 653 
 654   const Klass* host_class = current_class;
 655   if (current_class-&gt;is_instance_klass() &amp;&amp;
 656       InstanceKlass::cast(current_class)-&gt;is_unsafe_anonymous()) {
 657     host_class = InstanceKlass::cast(current_class)-&gt;unsafe_anonymous_host();
 658     assert(host_class != NULL, &quot;Unsafe anonymous class has null host class&quot;);
 659     assert(!(host_class-&gt;is_instance_klass() &amp;&amp;
 660            InstanceKlass::cast(host_class)-&gt;is_unsafe_anonymous()),
 661            &quot;unsafe_anonymous_host should not be unsafe anonymous itself&quot;);
 662   }
 663   if (host_class == member_class) {
 664     return true;
 665   }
 666 
 667   if (access.is_protected()) {
 668     if (!protected_restriction) {
 669       // See if current_class (or outermost host class) is a subclass of member_class
 670       // An interface may not access protected members of j.l.Object
 671       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(member_class)) {
 672         if (access.is_static() || // static fields are ok, see 6622385
 673             current_class == resolved_class ||
 674             member_class == resolved_class ||
 675             host_class-&gt;is_subclass_of(resolved_class) ||
 676             resolved_class-&gt;is_subclass_of(host_class)) {
 677           return true;
 678         }
 679       }
 680     }
 681   }
 682 
 683   // package access
 684   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, member_class)) {
 685     return true;
 686   }
 687 
 688   // private access between different classes needs a nestmate check, but
 689   // not for unsafe anonymous classes - so check host_class
 690   if (access.is_private() &amp;&amp; host_class == current_class) {
 691     if (current_class-&gt;is_instance_klass() &amp;&amp; member_class-&gt;is_instance_klass() ) {
 692       InstanceKlass* cur_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(current_class));
 693       InstanceKlass* field_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(member_class));
 694       // Nestmate access checks may require resolution and validation of the nest-host.
 695       // It is up to the caller to check for pending exceptions and handle appropriately.
 696       bool access = cur_ik-&gt;has_nestmate_access_to(field_ik, CHECK_false);
 697       if (access) {
 698         guarantee(resolved_class-&gt;is_subclass_of(member_class), &quot;must be!&quot;);
 699         return true;
 700       }
 701     }
 702   }
 703 
 704   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 705   // succeed trivially.
 706   if (current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 707     return true;
 708   }
 709 
 710   // Check for special relaxations
 711   return can_relax_access_check_for(current_class, member_class, classloader_only);
 712 }
 713 
 714 bool Reflection::is_same_class_package(const Klass* class1, const Klass* class2) {
 715   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 716 }
 717 
 718 // Checks that the &#39;outer&#39; klass has declared &#39;inner&#39; as being an inner klass. If not,
 719 // throw an incompatible class change exception
 720 // If inner_is_member, require the inner to be a member of the outer.
 721 // If !inner_is_member, require the inner to be unsafe anonymous (a non-member).
 722 // Caller is responsible for figuring out in advance which case must be true.
 723 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
 724                                        bool inner_is_member, TRAPS) {
 725   InnerClassesIterator iter(outer);
 726   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 727   for (; !iter.done(); iter.next()) {
 728     int ioff = iter.inner_class_info_index();
 729     int ooff = iter.outer_class_info_index();
 730 
 731     if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 732       if (cp-&gt;klass_name_at_matches(outer, ooff) &amp;&amp;
 733           cp-&gt;klass_name_at_matches(inner, ioff)) {
 734         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 735         if (o == outer) {
 736           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 737           if (i == inner) {
 738             return;
 739           }
 740         }
 741       }
 742     }
 743 
 744     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 745         cp-&gt;klass_name_at_matches(inner, ioff)) {
 746       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 747       if (i == inner) {
 748         return;
 749       }
 750     }
 751   }
 752 
 753   // &#39;inner&#39; not declared as an inner klass in outer
 754   ResourceMark rm(THREAD);
 755   Exceptions::fthrow(
 756     THREAD_AND_LOCATION,
 757     vmSymbols::java_lang_IncompatibleClassChangeError(),
 758     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 759     outer-&gt;external_name(),
 760     inner-&gt;external_name()
 761   );
 762 }
 763 
 764 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 765                                           int parameter_count,
 766                                           oop* return_type,
 767                                           TRAPS) {
 768   // Allocate array holding parameter types (java.lang.Class instances)
 769   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 770   objArrayHandle mirrors(THREAD, m);
 771   int index = 0;
 772   // Collect parameter types
 773   ResourceMark rm(THREAD);
 774   for (ResolvingSignatureStream ss(method()); !ss.is_done(); ss.next()) {
 775     oop mirror = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_(objArrayHandle()));
 776     if (log_is_enabled(Debug, class, resolve)) {
 777       trace_class_resolution(mirror);
 778     }
 779     if (!ss.at_return_type()) {
 780       mirrors-&gt;obj_at_put(index++, mirror);
 781     } else if (return_type != NULL) {
 782       // Collect return type as well
 783       assert(ss.at_return_type(), &quot;return type should be present&quot;);
 784       *return_type = mirror;
 785     }
 786   }
 787   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 788   return mirrors;
 789 }
 790 
 791 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 792   return method-&gt;resolved_checked_exceptions(THREAD);
 793 }
 794 
 795 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
 796   ResolvingSignatureStream ss(signature, k, false);
 797   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);
 798   return Handle(THREAD, nt);
 799 }
 800 
 801 
 802 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 803   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 804   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,
 805          &quot;should call new_constructor instead&quot;);
 806   InstanceKlass* holder = method-&gt;method_holder();
 807   int slot = method-&gt;method_idnum();
 808 
 809   Symbol*  signature  = method-&gt;signature();
 810   int parameter_count = ArgumentCount(signature).size();
 811   oop return_type_oop = NULL;
 812   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 813   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 814 
 815   Handle return_type(THREAD, return_type_oop);
 816 
 817   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 818 
 819   if (exception_types.is_null()) return NULL;
 820 
 821   Symbol*  method_name = method-&gt;name();
 822   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 823   Handle name = Handle(THREAD, name_oop);
 824   if (name == NULL) return NULL;
 825 
 826   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 827 
 828   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 829 
 830   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 831   java_lang_reflect_Method::set_slot(mh(), slot);
 832   java_lang_reflect_Method::set_name(mh(), name());
 833   java_lang_reflect_Method::set_return_type(mh(), return_type());
 834   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 835   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 836   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 837   java_lang_reflect_Method::set_override(mh(), false);
 838   if (method-&gt;generic_signature() != NULL) {
 839     Symbol*  gs = method-&gt;generic_signature();
 840     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 841     java_lang_reflect_Method::set_signature(mh(), sig());
 842   }
 843   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 844   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 845   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 846   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 847   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 848   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 849   return mh();
 850 }
 851 
 852 
 853 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
 854   assert(method()-&gt;is_object_constructor() ||
 855          method()-&gt;is_static_init_factory(),
 856          &quot;should call new_method instead&quot;);
 857 
 858   InstanceKlass* holder = method-&gt;method_holder();
 859   int slot = method-&gt;method_idnum();
 860 
 861   Symbol*  signature  = method-&gt;signature();
 862   int parameter_count = ArgumentCount(signature).size();
 863   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 864   if (parameter_types.is_null()) return NULL;
 865 
 866   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 867   if (exception_types.is_null()) return NULL;
 868 
 869   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 870 
 871   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 872 
 873   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 874   java_lang_reflect_Constructor::set_slot(ch(), slot);
 875   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 876   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 877   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 878   java_lang_reflect_Constructor::set_override(ch(), false);
 879   if (method-&gt;generic_signature() != NULL) {
 880     Symbol*  gs = method-&gt;generic_signature();
 881     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 882     java_lang_reflect_Constructor::set_signature(ch(), sig());
 883   }
 884   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 885   java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 886   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 887   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 888   return ch();
 889 }
 890 
 891 
 892 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 893   Symbol*  field_name = fd-&gt;name();
 894   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 895   Handle name = Handle(THREAD, name_oop);
 896   Symbol*  signature  = fd-&gt;signature();
 897   InstanceKlass* holder = fd-&gt;field_holder();
 898   Handle type = new_type(signature, holder, CHECK_NULL);
 899   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 900 
 901   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 902   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 903   java_lang_reflect_Field::set_name(rh(), name());
 904   java_lang_reflect_Field::set_type(rh(), type());
 905   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 906   int modifiers = fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
 907   if (fd-&gt;is_flattenable()) {
 908     modifiers |= JVM_ACC_FIELD_FLATTENABLE;
 909     // JVM_ACC_FLATTENABLE should not be set in LWorld.  set_is_flattenable should be re-examined.
 910     modifiers &amp;= ~JVM_ACC_FLATTENABLE;
 911   }
 912   if (fd-&gt;is_flattened()) {
 913     modifiers |= JVM_ACC_FIELD_FLATTENED;
 914   }
 915   java_lang_reflect_Field::set_modifiers(rh(), modifiers);
 916   java_lang_reflect_Field::set_override(rh(), false);
 917   if (fd-&gt;has_generic_signature()) {
 918     Symbol*  gs = fd-&gt;generic_signature();
 919     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 920     java_lang_reflect_Field::set_signature(rh(), sig());
 921   }
 922   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 923   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 924   return rh();
 925 }
 926 
 927 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 928                               int flags, TRAPS) {
 929 
 930   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 931 
 932   if(NULL != sym) {
 933     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 934     java_lang_reflect_Parameter::set_name(rh(), name());
 935   } else {
 936     java_lang_reflect_Parameter::set_name(rh(), NULL);
 937   }
 938 
 939   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 940   java_lang_reflect_Parameter::set_executable(rh(), method());
 941   java_lang_reflect_Parameter::set_index(rh(), index);
 942   return rh();
 943 }
 944 
 945 
 946 static methodHandle resolve_interface_call(InstanceKlass* klass,
 947                                            const methodHandle&amp; method,
 948                                            Klass* recv_klass,
 949                                            Handle receiver,
 950                                            TRAPS) {
 951 
 952   assert(!method.is_null() , &quot;method should not be null&quot;);
 953 
 954   CallInfo info;
 955   Symbol*  signature  = method-&gt;signature();
 956   Symbol*  name       = method-&gt;name();
 957   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 958                                        LinkInfo(klass, name, signature),
 959                                        true,
 960                                        CHECK_(methodHandle()));
 961   return methodHandle(THREAD, info.selected_method());
 962 }
 963 
 964 // Conversion
 965 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 966   assert(java_lang_Class::is_primitive(basic_type_mirror),
 967     &quot;just checking&quot;);
 968   return java_lang_Class::primitive_type(basic_type_mirror);
 969 }
 970 
 971 // Narrowing of basic types. Used to create correct jvalues for
 972 // boolean, byte, char and short return return values from interpreter
 973 // which are returned as ints. Throws IllegalArgumentException.
 974 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 975   switch (narrow_type) {
 976   case T_BOOLEAN:
 977     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 978     return;
 979   case T_BYTE:
 980     value-&gt;b = (jbyte)value-&gt;i;
 981     return;
 982   case T_CHAR:
 983     value-&gt;c = (jchar)value-&gt;i;
 984     return;
 985   case T_SHORT:
 986     value-&gt;s = (jshort)value-&gt;i;
 987     return;
 988   default:
 989     break; // fail
 990   }
 991   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 992 }
 993 
 994 
 995 // Method call (shared by invoke_method and invoke_constructor)
 996 static oop invoke(InstanceKlass* klass,
 997                   const methodHandle&amp; reflected_method,
 998                   Handle receiver,
 999                   bool override,
1000                   objArrayHandle ptypes,
1001                   BasicType rtype,
1002                   objArrayHandle args,
1003                   bool is_method_invoke,
1004                   TRAPS) {
1005 
1006   ResourceMark rm(THREAD);
1007 
1008   methodHandle method;      // actual method to invoke
1009   Klass* target_klass;      // target klass, receiver&#39;s klass for non-static
1010 
1011   // Ensure klass is initialized
1012   klass-&gt;initialize(CHECK_NULL);
1013 
1014   bool is_static = reflected_method-&gt;is_static();
1015   if (is_static) {
1016     // ignore receiver argument
1017     method = reflected_method;
1018     target_klass = klass;
1019   } else {
1020     // check for null receiver
1021     if (receiver.is_null()) {
1022       THROW_0(vmSymbols::java_lang_NullPointerException());
1023     }
1024     // Check class of receiver against class declaring method
1025     if (!receiver-&gt;is_a(klass)) {
1026       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;object is not an instance of declaring class&quot;);
1027     }
1028     // target klass is receiver&#39;s klass
1029     target_klass = receiver-&gt;klass();
1030     // no need to resolve if method is private or &lt;init&gt;
1031     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
1032       method = reflected_method;
1033     } else {
1034       // resolve based on the receiver
1035       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
1036         // resolve interface call
1037         //
1038         // Match resolution errors with those thrown due to reflection inlining
1039         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
1040         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
1041         if (HAS_PENDING_EXCEPTION) {
1042           // Method resolution threw an exception; wrap it in an InvocationTargetException
1043           oop resolution_exception = PENDING_EXCEPTION;
1044           CLEAR_PENDING_EXCEPTION;
1045           // JVMTI has already reported the pending exception
1046           // JVMTI internal flag reset is needed in order to report InvocationTargetException
1047           if (THREAD-&gt;is_Java_thread()) {
1048             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1049           }
1050           JavaCallArguments args(Handle(THREAD, resolution_exception));
1051           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1052                       vmSymbols::throwable_void_signature(),
1053                       &amp;args);
1054         }
1055       }  else {
1056         // if the method can be overridden, we resolve using the vtable index.
1057         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1058         int index = reflected_method-&gt;vtable_index();
1059         method = reflected_method;
1060         if (index != Method::nonvirtual_vtable_index) {
1061           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1062         }
1063         if (!method.is_null()) {
1064           // Check for abstract methods as well
1065           if (method-&gt;is_abstract()) {
1066             // new default: 6531596
1067             ResourceMark rm(THREAD);
1068             stringStream ss;
1069             ss.print(&quot;&#39;&quot;);
1070             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());
1071             ss.print(&quot;&#39;&quot;);
1072             Handle h_origexception = Exceptions::new_exception(THREAD,
1073               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1074             JavaCallArguments args(h_origexception);
1075             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1076               vmSymbols::throwable_void_signature(),
1077               &amp;args);
1078           }
1079         }
1080       }
1081     }
1082   }
1083 
1084   // I believe this is a ShouldNotGetHere case which requires
1085   // an internal vtable bug. If you ever get this please let Karen know.
1086   if (method.is_null()) {
1087     ResourceMark rm(THREAD);
1088     stringStream ss;
1089     ss.print(&quot;&#39;&quot;);
1090     Method::print_external_name(&amp;ss, klass,
1091                                      reflected_method-&gt;name(),
1092                                      reflected_method-&gt;signature());
1093     ss.print(&quot;&#39;&quot;);
1094     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
1095   }
1096 
1097   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1098   int args_len = args.is_null() ? 0 : args-&gt;length();
1099   // Check number of arguments
1100   if (ptypes-&gt;length() != args_len) {
1101     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1102                 &quot;wrong number of arguments&quot;);
1103   }
1104 
1105   // Create object to contain parameters for the JavaCall
1106   JavaCallArguments java_args(method-&gt;size_of_parameters());
1107 
1108   if (!is_static) {
1109     java_args.push_oop(receiver);
1110   }
1111 
1112   for (int i = 0; i &lt; args_len; i++) {
1113     oop type_mirror = ptypes-&gt;obj_at(i);
1114     oop arg = args-&gt;obj_at(i);
1115     if (java_lang_Class::is_primitive(type_mirror)) {
1116       jvalue value;
1117       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1118       BasicType atype = Reflection::unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1119       if (ptype != atype) {
1120         Reflection::widen(&amp;value, atype, ptype, CHECK_NULL);
1121       }
1122       switch (ptype) {
1123         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1124         case T_CHAR:        java_args.push_int(value.c);    break;
1125         case T_BYTE:        java_args.push_int(value.b);    break;
1126         case T_SHORT:       java_args.push_int(value.s);    break;
1127         case T_INT:         java_args.push_int(value.i);    break;
1128         case T_LONG:        java_args.push_long(value.j);   break;
1129         case T_FLOAT:       java_args.push_float(value.f);  break;
1130         case T_DOUBLE:      java_args.push_double(value.d); break;
1131         default:
1132           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1133       }
1134     } else {
1135       if (arg != NULL) {
1136         Klass* k = java_lang_Class::as_Klass(type_mirror);
1137         if (!arg-&gt;is_a(k)) {
1138           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1139                       &quot;argument type mismatch&quot;);
1140         }
1141       }
1142       Handle arg_handle(THREAD, arg);         // Create handle for argument
1143       java_args.push_oop(arg_handle); // Push handle
1144     }
1145   }
1146 
1147   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(),
1148     &quot;just checking&quot;);
1149 
1150   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1151   // oop (i.e., NOT as an handle)
1152   JavaValue result(rtype);
1153   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1154 
1155   if (HAS_PENDING_EXCEPTION) {
1156     // Method threw an exception; wrap it in an InvocationTargetException
1157     oop target_exception = PENDING_EXCEPTION;
1158     CLEAR_PENDING_EXCEPTION;
1159     // JVMTI has already reported the pending exception
1160     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1161     if (THREAD-&gt;is_Java_thread()) {
1162       JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1163     }
1164 
1165     JavaCallArguments args(Handle(THREAD, target_exception));
1166     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1167                 vmSymbols::throwable_void_signature(),
1168                 &amp;args);
1169   } else {
1170     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1171       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1172     }
1173     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1174   }
1175 }
1176 
1177 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1178 // of java.lang.reflect.Constructor
1179 
1180 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1181   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1182   int slot               = java_lang_reflect_Method::slot(method_mirror);
1183   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1184   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1185 
1186   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1187   BasicType rtype;
1188   if (java_lang_Class::is_primitive(return_type_mirror)) {
1189     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1190   } else if (java_lang_Class::inline_type_mirror(return_type_mirror) == return_type_mirror) {
1191     rtype = T_VALUETYPE;
1192   } else {
1193     rtype = T_OBJECT;
1194   }
1195 
1196   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1197   Method* m = klass-&gt;method_with_idnum(slot);
1198   if (m == NULL) {
1199     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1200   }
1201   methodHandle method(THREAD, m);
1202 
1203   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1204 }
1205 
1206 
1207 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1208   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1209   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1210   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1211   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1212 
1213   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1214   Method* m = klass-&gt;method_with_idnum(slot);
1215   if (m == NULL) {
1216     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1217   }
1218   methodHandle method(THREAD, m);
1219   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1220 
1221   // Make sure klass gets initialize
1222   klass-&gt;initialize(CHECK_NULL);
1223 
1224   // Create new instance (the receiver)
1225   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1226 
1227   // Special case for factory methods
1228   if (!method-&gt;signature()-&gt;is_void_method_signature()) {
1229     assert(klass-&gt;is_value(), &quot;inline classes must use factory methods&quot;);
1230     Handle no_receiver; // null instead of receiver
1231     return invoke(klass, method, no_receiver, override, ptypes, T_VALUETYPE, args, false, CHECK_NULL);
1232   }
1233 
1234   // main branch of code creates a non-inline object:
1235   assert(!klass-&gt;is_value(), &quot;classic constructors are only for non-inline classes&quot;);
1236   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1237 
1238   // Ignore result from call and return receiver
1239   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1240   return receiver();
1241 }
    </pre>
  </body>
</html>