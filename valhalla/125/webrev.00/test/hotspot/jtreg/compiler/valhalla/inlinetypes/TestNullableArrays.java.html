<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
  32  * @key randomness
  33  * @summary Test nullable inline type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestNullableArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  41  *                               compiler.valhalla.inlinetypes.TestNullableArrays
  42  */
  43 public class TestNullableArrays extends InlineTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         if (isCompiledByC2(m)) {
  48             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  49         }
  50     }
  51 
  52     // Extra VM parameters for some test scenarios. See InlineTypeTest.getVMParameters()
  53     @Override
  54     public String[] getExtraVMParameters(int scenario) {
  55         switch (scenario) {
  56         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  57         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  58         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  59         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  60         }
  61         return null;
  62     }
  63 
  64     public static void main(String[] args) throws Throwable {
  65         TestNullableArrays test = new TestNullableArrays();
  66         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  67     }
  68 
  69     // Helper methods
  70 
  71     protected long hash() {
  72         return hash(rI, rL);
  73     }
  74 
  75     protected long hash(int x, long y) {
  76         return MyValue1.createWithFieldsInline(x, y).hash();
  77     }
  78 
  79     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  80 
  81     // Test nullable inline type array creation and initialization
  82     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
  83     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
  84     public MyValue1.ref[] test1(int len) {
  85         MyValue1.ref[] va = new MyValue1.ref[len];
  86         if (len &gt; 0) {
  87             va[0] = null;
  88         }
  89         for (int i = 1; i &lt; len; ++i) {
  90             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  91         }
  92         return va;
  93     }
  94 
  95     @DontCompile
  96     public void test1_verifier(boolean warmup) {
  97         int len = Math.abs(rI % 10);
  98         MyValue1.ref[] va = test1(len);
  99         if (len &gt; 0) {
 100             Asserts.assertEQ(va[0], null);
 101         }
 102         for (int i = 1; i &lt; len; ++i) {
 103             Asserts.assertEQ(va[i].hash(), hash());
 104         }
 105     }
 106 
 107     // Test creation of an inline type array and element access
 108     @Test
 109     // TODO 8227588
 110     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 111     public long test2() {
 112         MyValue1.ref[] va = new MyValue1.ref[1];
 113         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 114         return va[0].hash();
 115     }
 116 
 117     @DontCompile
 118     public void test2_verifier(boolean warmup) {
 119         long result = test2();
 120         Asserts.assertEQ(result, hash());
 121     }
 122 
 123     // Test receiving an inline type array from the interpreter,
 124     // updating its elements in a loop and computing a hash.
 125     @Test(failOn = ALLOCA)
 126     public long test3(MyValue1.ref[] va) {
 127         long result = 0;
 128         for (int i = 0; i &lt; 10; ++i) {
 129             if (va[i] != null) {
 130                 result += va[i].hash();
 131             }
 132             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 133         }
 134         va[0] = null;
 135         return result;
 136     }
 137 
 138     @DontCompile
 139     public void test3_verifier(boolean warmup) {
 140         MyValue1.ref[] va = new MyValue1.ref[10];
 141         long expected = 0;
 142         for (int i = 1; i &lt; 10; ++i) {
 143             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 144             expected += va[i].hash();
 145         }
 146         long result = test3(va);
 147         Asserts.assertEQ(expected, result);
 148         Asserts.assertEQ(va[0], null);
 149         for (int i = 1; i &lt; 10; ++i) {
 150             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 151                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 152             }
 153         }
 154     }
 155 
 156     // Test returning an inline type array received from the interpreter
 157     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 158     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 159         return va;
 160     }
 161 
 162     @DontCompile
 163     public void test4_verifier(boolean warmup) {
 164         MyValue1.ref[] va = new MyValue1.ref[10];
 165         for (int i = 0; i &lt; 10; ++i) {
 166             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 167         }
 168         va = test4(va);
 169         for (int i = 0; i &lt; 10; ++i) {
 170             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 171         }
 172     }
 173 
 174     // Merge inline type arrays created from two branches
 175     @Test
 176     public MyValue1.ref[] test5(boolean b) {
 177         MyValue1.ref[] va;
 178         if (b) {
 179             va = new MyValue1.ref[5];
 180             for (int i = 0; i &lt; 5; ++i) {
 181                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 182             }
 183             va[4] = null;
 184         } else {
 185             va = new MyValue1.ref[10];
 186             for (int i = 0; i &lt; 10; ++i) {
 187                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 188             }
 189             va[9] = null;
 190         }
 191         long sum = va[0].hashInterpreted();
 192         if (b) {
 193             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 194         } else {
 195             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
 196         }
 197         return va;
 198     }
 199 
 200     @DontCompile
 201     public void test5_verifier(boolean warmup) {
 202         MyValue1.ref[] va = test5(true);
 203         Asserts.assertEQ(va.length, 5);
 204         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 205         for (int i = 1; i &lt; 4; ++i) {
 206             Asserts.assertEQ(va[i].hash(), hash());
 207         }
 208         Asserts.assertEQ(va[4], null);
 209         va = test5(false);
 210         Asserts.assertEQ(va.length, 10);
 211         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 212         for (int i = 1; i &lt; 9; ++i) {
 213             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 214         }
 215         Asserts.assertEQ(va[9], null);
 216     }
 217 
 218     // Test creation of inline type array with single element
 219     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 220     public MyValue1.ref test6() {
 221         MyValue1.ref[] va = new MyValue1.ref[1];
 222         return va[0];
 223     }
 224 
 225     @DontCompile
 226     public void test6_verifier(boolean warmup) {
 227         MyValue1.ref[] va = new MyValue1.ref[1];
 228         MyValue1.ref v = test6();
 229         Asserts.assertEQ(v, null);
 230     }
 231 
 232     // Test default initialization of inline type arrays
 233     @Test(failOn = LOAD)
 234     public MyValue1.ref[] test7(int len) {
 235         return new MyValue1.ref[len];
 236     }
 237 
 238     @DontCompile
 239     public void test7_verifier(boolean warmup) {
 240         int len = Math.abs(rI % 10);
 241         MyValue1.ref[] va = test7(len);
 242         for (int i = 0; i &lt; len; ++i) {
 243             Asserts.assertEQ(va[i], null);
 244             va[i] = null;
 245         }
 246     }
 247 
 248     // Test creation of inline type array with zero length
 249     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 250     public MyValue1.ref[] test8() {
 251         return new MyValue1.ref[0];
 252     }
 253 
 254     @DontCompile
 255     public void test8_verifier(boolean warmup) {
 256         MyValue1.ref[] va = test8();
 257         Asserts.assertEQ(va.length, 0);
 258     }
 259 
 260     static MyValue1.ref[] test9_va;
 261 
 262     // Test that inline type array loaded from field has correct type
 263     @Test(failOn = LOOP)
 264     public long test9() {
 265         return test9_va[0].hash();
 266     }
 267 
 268     @DontCompile
 269     public void test9_verifier(boolean warmup) {
 270         test9_va = new MyValue1.ref[1];
 271         test9_va[0] = testValue1;
 272         long result = test9();
 273         Asserts.assertEQ(result, hash());
 274     }
 275 
 276     // Multi-dimensional arrays
 277     @Test
 278     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 279         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 280         for (int i = 0; i &lt; len1; i++) {
 281             for (int j = 0; j &lt; len2; j++) {
 282                 for (int k = 0; k &lt; len3; k++) {
 283                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
 284                     if (k == 0) {
 285                         arr[i][j][k] = null;
 286                     }
 287                 }
 288             }
 289         }
 290         return arr;
 291     }
 292 
 293     @DontCompile
 294     public void test10_verifier(boolean warmup) {
 295         MyValue1.ref[][][] arr = test10(2, 3, 4);
 296         for (int i = 0; i &lt; 2; i++) {
 297             for (int j = 0; j &lt; 3; j++) {
 298                 for (int k = 0; k &lt; 4; k++) {
 299                     if (k == 0) {
 300                         Asserts.assertEQ(arr[i][j][k], null);
 301                     } else {
 302                         Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());
 303                     }
 304                     arr[i][j][k] = null;
 305                 }
 306             }
 307         }
 308     }
 309 
 310     @Test
 311     public void test11(MyValue1.ref[][][] arr, long[] res) {
 312         int l = 0;
 313         for (int i = 0; i &lt; arr.length; i++) {
 314             for (int j = 0; j &lt; arr[i].length; j++) {
 315                 for (int k = 0; k &lt; arr[i][j].length; k++) {
 316                     if (arr[i][j][k] != null) {
 317                         res[l] = arr[i][j][k].hash();
 318                     }
 319                     arr[i][j][k] = null;
 320                     l++;
 321                 }
 322             }
 323         }
 324     }
 325 
 326     @DontCompile
 327     public void test11_verifier(boolean warmup) {
 328         MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];
 329         long[] res = new long[2*3*4];
 330         long[] verif = new long[2*3*4];
 331         int l = 0;
 332         for (int i = 0; i &lt; 2; i++) {
 333             for (int j = 0; j &lt; 3; j++) {
 334                 for (int k = 0; k &lt; 4; k++) {
 335                     if (j != 2) {
 336                         arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);
 337                         verif[l] = arr[i][j][k].hash();
 338                     }
 339                     l++;
 340                 }
 341             }
 342         }
 343         test11(arr, res);
 344         for (int i = 0; i &lt; verif.length; i++) {
 345             Asserts.assertEQ(res[i], verif[i]);
 346         }
 347     }
 348 
 349     // Array load out of bounds (upper bound) at compile time
 350     @Test
 351     public int test12() {
 352         int arraySize = Math.abs(rI) % 10;
 353         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 354 
 355         for (int i = 0; i &lt; arraySize; i++) {
 356             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 357         }
 358 
 359         try {
 360             return va[arraySize + 1].x;
 361         } catch (ArrayIndexOutOfBoundsException e) {
 362             return rI;
 363         }
 364     }
 365 
 366     public void test12_verifier(boolean warmup) {
 367         Asserts.assertEQ(test12(), rI);
 368     }
 369 
 370     // Array load  out of bounds (lower bound) at compile time
 371     @Test
 372     public int test13() {
 373         int arraySize = Math.abs(rI) % 10;
 374         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 375 
 376         for (int i = 0; i &lt; arraySize; i++) {
 377             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
 378         }
 379 
 380         try {
 381             return va[-arraySize].x;
 382         } catch (ArrayIndexOutOfBoundsException e) {
 383             return rI;
 384         }
 385     }
 386 
 387     public void test13_verifier(boolean warmup) {
 388         Asserts.assertEQ(test13(), rI);
 389     }
 390 
 391     // Array load out of bound not known to compiler (both lower and upper bound)
 392     @Test
 393     public int test14(MyValue1.ref[] va, int index)  {
 394         return va[index].x;
 395     }
 396 
 397     public void test14_verifier(boolean warmup) {
 398         int arraySize = Math.abs(rI) % 10;
 399         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 400 
 401         for (int i = 0; i &lt; arraySize; i++) {
 402             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 403         }
 404 
 405         int result;
 406         for (int i = -20; i &lt; 20; i++) {
 407             try {
 408                 result = test14(va, i);
 409             } catch (ArrayIndexOutOfBoundsException e) {
 410                 result = rI;
 411             }
 412             Asserts.assertEQ(result, rI);
 413         }
 414     }
 415 
 416     // Array store out of bounds (upper bound) at compile time
 417     @Test
 418     public int test15() {
 419         int arraySize = Math.abs(rI) % 10;
 420         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 421 
 422         try {
 423             for (int i = 0; i &lt;= arraySize; i++) {
 424                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 425             }
 426             return rI - 1;
 427         } catch (ArrayIndexOutOfBoundsException e) {
 428             return rI;
 429         }
 430     }
 431 
 432     public void test15_verifier(boolean warmup) {
 433         Asserts.assertEQ(test15(), rI);
 434     }
 435 
 436     // Array store out of bounds (lower bound) at compile time
 437     @Test
 438     public int test16() {
 439         int arraySize = Math.abs(rI) % 10;
 440         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 441 
 442         try {
 443             for (int i = -1; i &lt;= arraySize; i++) {
 444                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 445             }
 446             return rI - 1;
 447         } catch (ArrayIndexOutOfBoundsException e) {
 448             return rI;
 449         }
 450     }
 451 
 452     public void test16_verifier(boolean warmup) {
 453         Asserts.assertEQ(test16(), rI);
 454     }
 455 
 456     // Array store out of bound not known to compiler (both lower and upper bound)
 457     @Test
 458     public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {
 459         va[index] = vt;
 460         return va[index].x;
 461     }
 462 
 463     @DontCompile
 464     public void test17_verifier(boolean warmup) {
 465         int arraySize = Math.abs(rI) % 10;
 466         MyValue1.ref[] va = new MyValue1.ref[arraySize];
 467 
 468         for (int i = 0; i &lt; arraySize; i++) {
 469             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
 470         }
 471 
 472         MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);
 473         int result;
 474         for (int i = -20; i &lt; 20; i++) {
 475             try {
 476                 result = test17(va, i, vt);
 477             } catch (ArrayIndexOutOfBoundsException e) {
 478                 result = rI + 1;
 479             }
 480             Asserts.assertEQ(result, rI + 1);
 481         }
 482 
 483         for (int i = 0; i &lt; arraySize; i++) {
 484             Asserts.assertEQ(va[i].x, rI + 1);
 485         }
 486     }
 487 
 488     // clone() as stub call
 489     @Test
 490     public MyValue1.ref[] test18(MyValue1.ref[] va) {
 491         return va.clone();
 492     }
 493 
 494     @DontCompile
 495     public void test18_verifier(boolean warmup) {
 496         int len = Math.abs(rI) % 10;
 497         MyValue1.ref[] va1 = new MyValue1.ref[len];
 498         MyValue1[]  va2 = new MyValue1[len];
 499         for (int i = 1; i &lt; len; ++i) {
 500             va1[i] = testValue1;
 501             va2[i] = testValue1;
 502         }
 503         MyValue1.ref[] result1 = test18(va1);
 504         if (len &gt; 0) {
 505             Asserts.assertEQ(result1[0], null);
 506         }
 507         for (int i = 1; i &lt; len; ++i) {
 508             Asserts.assertEQ(result1[i].hash(), va1[i].hash());
 509         }
 510         // make sure we do deopt: GraphKit::new_array assumes an
 511         // array of references
 512         for (int j = 0; j &lt; 10; j++) {
 513             MyValue1.ref[] result2 = test18(va2);
 514 
 515             for (int i = 0; i &lt; len; ++i) {
 516                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 517             }
 518         }
 519         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
 520             MyValue1.ref[] result2 = test18(va2);
 521             for (int i = 0; i &lt; len; ++i) {
 522                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
 523             }
 524         }
 525     }
 526 
 527     // clone() as series of loads/stores
 528     static MyValue1.ref[] test19_orig = null;
 529 
 530     @Test
 531     public MyValue1.ref[] test19() {
 532         MyValue1.ref[] va = new MyValue1.ref[8];
 533         for (int i = 1; i &lt; va.length; ++i) {
 534             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 535         }
 536         test19_orig = va;
 537 
 538         return va.clone();
 539     }
 540 
 541     @DontCompile
 542     public void test19_verifier(boolean warmup) {
 543         MyValue1.ref[] result = test19();
 544         Asserts.assertEQ(result[0], null);
 545         for (int i = 1; i &lt; test19_orig.length; ++i) {
 546             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 547         }
 548     }
 549 
 550     // arraycopy() of inline type array with oop fields
 551     @Test
 552     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 553         System.arraycopy(src, 0, dst, 0, src.length);
 554     }
 555 
 556     @DontCompile
 557     public void test20_verifier(boolean warmup) {
 558         int len = Math.abs(rI) % 10;
 559         MyValue1.ref[] src1 = new MyValue1.ref[len];
 560         MyValue1.ref[] src2 = new MyValue1.ref[len];
 561         MyValue1[]  src3 = new MyValue1[len];
 562         MyValue1[]  src4 = new MyValue1[len];
 563         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 564         MyValue1[]  dst2 = new MyValue1[len];
 565         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 566         MyValue1[]  dst4 = new MyValue1[len];
 567         if (len &gt; 0) {
 568             src2[0] = testValue1;
 569         }
 570         for (int i = 1; i &lt; len; ++i) {
 571             src1[i] = testValue1;
 572             src2[i] = testValue1;
 573             src3[i] = testValue1;
 574             src4[i] = testValue1;
 575         }
 576         test20(src1, dst1);
 577         test20(src2, dst2);
 578         test20(src3, dst3);
 579         test20(src4, dst4);
 580         if (len &gt; 0) {
 581             Asserts.assertEQ(dst1[0], null);
 582             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 583             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 584             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 585         }
 586         for (int i = 1; i &lt; len; ++i) {
 587             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 588             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 589             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 590             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 591         }
 592     }
 593 
 594     // arraycopy() of inline type array with no oop field
 595     @Test
 596     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 597         System.arraycopy(src, 0, dst, 0, src.length);
 598     }
 599 
 600     @DontCompile
 601     public void test21_verifier(boolean warmup) {
 602         int len = Math.abs(rI) % 10;
 603         MyValue2.ref[] src1 = new MyValue2.ref[len];
 604         MyValue2.ref[] src2 = new MyValue2.ref[len];
 605         MyValue2[]  src3 = new MyValue2[len];
 606         MyValue2[]  src4 = new MyValue2[len];
 607         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 608         MyValue2[]  dst2 = new MyValue2[len];
 609         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 610         MyValue2[]  dst4 = new MyValue2[len];
 611         if (len &gt; 0) {
 612             src2[0] = MyValue2.createWithFieldsInline(rI, true);
 613         }
 614         for (int i = 1; i &lt; len; ++i) {
 615             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 616             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 617             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 618             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 619         }
 620         test21(src1, dst1);
 621         test21(src2, dst2);
 622         test21(src3, dst3);
 623         test21(src4, dst4);
 624         if (len &gt; 0) {
 625             Asserts.assertEQ(dst1[0], null);
 626             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 627             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 628             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 629         }
 630         for (int i = 1; i &lt; len; ++i) {
 631             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 632             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 633             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 634             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 635         }
 636     }
 637 
 638     // arraycopy() of inline type array with oop field and tightly
 639     // coupled allocation as dest
 640     @Test
 641     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 642         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 643         System.arraycopy(src, 0, dst, 0, src.length);
 644         return dst;
 645     }
 646 
 647     @DontCompile
 648     public void test22_verifier(boolean warmup) {
 649         int len = Math.abs(rI) % 10;
 650         MyValue1.ref[] src1 = new MyValue1.ref[len];
 651         MyValue1[]  src2 = new MyValue1[len];
 652         for (int i = 1; i &lt; len; ++i) {
 653             src1[i] = testValue1;
 654             src2[i] = testValue1;
 655         }
 656         MyValue1.ref[] dst1 = test22(src1);
 657         MyValue1.ref[] dst2 = test22(src2);
 658         if (len &gt; 0) {
 659             Asserts.assertEQ(dst1[0], null);
 660             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 661         }
 662         for (int i = 1; i &lt; len; ++i) {
 663             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 664             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 665         }
 666     }
 667 
 668     // arraycopy() of inline type array with oop fields and tightly
 669     // coupled allocation as dest
 670     @Test
 671     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 672         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 673         System.arraycopy(src, 0, dst, 5, src.length);
 674         return dst;
 675     }
 676 
 677     @DontCompile
 678     public void test23_verifier(boolean warmup) {
 679         int len = Math.abs(rI) % 10;
 680         MyValue1.ref[] src1 = new MyValue1.ref[len];
 681         MyValue1[] src2 = new MyValue1[len];
 682         for (int i = 0; i &lt; len; ++i) {
 683             src1[i] = testValue1;
 684             src2[i] = testValue1;
 685         }
 686         MyValue1.ref[] dst1 = test23(src1);
 687         MyValue1.ref[] dst2 = test23(src2);
 688         for (int i = 0; i &lt; 5; ++i) {
 689             Asserts.assertEQ(dst1[i], null);
 690             Asserts.assertEQ(dst2[i], null);
 691         }
 692         for (int i = 5; i &lt; len; ++i) {
 693             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 694             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 695         }
 696     }
 697 
 698     // arraycopy() of inline type array passed as Object
 699     @Test
 700     public void test24(MyValue1.ref[] src, Object dst) {
 701         System.arraycopy(src, 0, dst, 0, src.length);
 702     }
 703 
 704     @DontCompile
 705     public void test24_verifier(boolean warmup) {
 706         int len = Math.abs(rI) % 10;
 707         MyValue1.ref[] src1 = new MyValue1.ref[len];
 708         MyValue1.ref[] src2 = new MyValue1.ref[len];
 709         MyValue1[]  src3 = new MyValue1[len];
 710         MyValue1[]  src4 = new MyValue1[len];
 711         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 712         MyValue1[]  dst2 = new MyValue1[len];
 713         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 714         MyValue1[]  dst4 = new MyValue1[len];
 715         if (len &gt; 0) {
 716             src2[0] = testValue1;
 717         }
 718         for (int i = 1; i &lt; len; ++i) {
 719             src1[i] = testValue1;
 720             src2[i] = testValue1;
 721             src3[i] = testValue1;
 722             src4[i] = testValue1;
 723         }
 724         test24(src1, dst1);
 725         test24(src2, dst2);
 726         test24(src3, dst3);
 727         test24(src4, dst4);
 728         if (len &gt; 0) {
 729             Asserts.assertEQ(dst1[0], null);
 730             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 731             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 732             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 733         }
 734         for (int i = 1; i &lt; len; ++i) {
 735             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 736             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 737             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 738             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 739         }
 740     }
 741 
 742     // short arraycopy() with no oop field
 743     @Test
 744     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
 745         System.arraycopy(src, 0, dst, 0, 8);
 746     }
 747 
 748     @DontCompile
 749     public void test25_verifier(boolean warmup) {
 750         MyValue2.ref[] src1 = new MyValue2.ref[8];
 751         MyValue2.ref[] src2 = new MyValue2.ref[8];
 752         MyValue2[]  src3 = new MyValue2[8];
 753         MyValue2[]  src4 = new MyValue2[8];
 754         MyValue2.ref[] dst1 = new MyValue2.ref[8];
 755         MyValue2[]  dst2 = new MyValue2[8];
 756         MyValue2.ref[] dst3 = new MyValue2.ref[8];
 757         MyValue2[]  dst4 = new MyValue2[8];
 758         src2[0] = MyValue2.createWithFieldsInline(rI, true);
 759         for (int i = 1; i &lt; 8; ++i) {
 760             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 761             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 762             src3[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 763             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 764         }
 765         test25(src1, dst1);
 766         test25(src2, dst2);
 767         test25(src3, dst3);
 768         test25(src4, dst4);
 769         Asserts.assertEQ(dst1[0], null);
 770         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 771         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 772         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 773         for (int i = 1; i &lt; 8; ++i) {
 774             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 775             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 776             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 777             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 778         }
 779     }
 780 
 781     // short arraycopy() with oop fields
 782     @Test
 783     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
 784         System.arraycopy(src, 0, dst, 0, 8);
 785     }
 786 
 787     @DontCompile
 788     public void test26_verifier(boolean warmup) {
 789         MyValue1.ref[] src1 = new MyValue1.ref[8];
 790         MyValue1.ref[] src2 = new MyValue1.ref[8];
 791         MyValue1[]  src3 = new MyValue1[8];
 792         MyValue1[]  src4 = new MyValue1[8];
 793         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 794         MyValue1[]  dst2 = new MyValue1[8];
 795         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 796         MyValue1[]  dst4 = new MyValue1[8];
 797         src2[0] = testValue1;
 798         for (int i = 1; i &lt; 8 ; ++i) {
 799             src1[i] = testValue1;
 800             src2[i] = testValue1;
 801             src3[i] = testValue1;
 802             src4[i] = testValue1;
 803         }
 804         test26(src1, dst1);
 805         test26(src2, dst2);
 806         test26(src3, dst3);
 807         test26(src4, dst4);
 808         Asserts.assertEQ(dst1[0], null);
 809         Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 810         Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 811         Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 812         for (int i = 1; i &lt; 8; ++i) {
 813             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 814             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 815             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 816             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 817         }
 818     }
 819 
 820     // short arraycopy() with oop fields and offsets
 821     @Test
 822     public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {
 823         System.arraycopy(src, 1, dst, 2, 6);
 824     }
 825 
 826     @DontCompile
 827     public void test27_verifier(boolean warmup) {
 828         MyValue1.ref[] src1 = new MyValue1.ref[8];
 829         MyValue1.ref[] src2 = new MyValue1.ref[8];
 830         MyValue1[]  src3 = new MyValue1[8];
 831         MyValue1[]  src4 = new MyValue1[8];
 832         MyValue1.ref[] dst1 = new MyValue1.ref[8];
 833         MyValue1[]  dst2 = new MyValue1[8];
 834         MyValue1.ref[] dst3 = new MyValue1.ref[8];
 835         MyValue1[]  dst4 = new MyValue1[8];
 836         for (int i = 1; i &lt; 8; ++i) {
 837             src1[i] = testValue1;
 838             src2[i] = testValue1;
 839             src3[i] = testValue1;
 840             src4[i] = testValue1;
 841         }
 842         test27(src1, dst1);
 843         test27(src2, dst2);
 844         test27(src3, dst3);
 845         test27(src4, dst4);
 846         for (int i = 0; i &lt; 2; ++i) {
 847             Asserts.assertEQ(dst1[i], null);
 848             Asserts.assertEQ(dst2[i].hash(), MyValue1.default.hash());
 849             Asserts.assertEQ(dst3[i], null);
 850             Asserts.assertEQ(dst4[i].hash(), MyValue1.default.hash());
 851         }
 852         for (int i = 2; i &lt; 8; ++i) {
 853             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 854             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 855             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 856             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 857         }
 858     }
 859 
 860     // non escaping allocations
 861     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
 862     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 863     @Test(valid = ZGCOn)
 864     public MyValue2.ref test28() {
 865         MyValue2.ref[] src = new MyValue2.ref[10];
 866         src[0] = null;
 867         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
 868         return dst[0];
 869     }
 870 
 871     @DontCompile
 872     public void test28_verifier(boolean warmup) {
 873         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
 874         MyValue2.ref result = test28();
 875         Asserts.assertEQ(result, null);
 876     }
 877 
 878     // non escaping allocations
 879     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 880     @Test(failOn = ALLOCA + LOOP + TRAP)
 881     public MyValue2.ref test29(MyValue2.ref[] src) {
 882         MyValue2.ref[] dst = new MyValue2.ref[10];
 883         System.arraycopy(src, 0, dst, 0, 10);
 884         return dst[0];
 885     }
 886 
 887     @DontCompile
 888     public void test29_verifier(boolean warmup) {
 889         MyValue2.ref[] src = new MyValue2.ref[10];
 890         for (int i = 0; i &lt; 10; ++i) {
 891             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 892         }
 893         MyValue2.ref v = test29(src);
 894         Asserts.assertEQ(src[0].hash(), v.hash());
 895     }
 896 
 897     // non escaping allocation with uncommon trap that needs
 898     // eliminated inline type array element as debug info
 899     @Test
 900     @Warmup(10000)
 901     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 902         MyValue2.ref[] dst = new MyValue2.ref[10];
 903         System.arraycopy(src, 0, dst, 0, 10);
 904         if (flag) { }
 905         return dst[0];
 906     }
 907 
 908     @DontCompile
 909     public void test30_verifier(boolean warmup) {
 910         MyValue2.ref[] src = new MyValue2.ref[10];
 911         for (int i = 0; i &lt; 10; ++i) {
 912             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 913         }
 914         MyValue2.ref v = test30(src, !warmup);
 915         Asserts.assertEQ(src[0].hash(), v.hash());
 916     }
 917 
 918     // non escaping allocation with memory phi
 919     @Test()
 920     // TODO 8227588
 921     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 922     public long test31(boolean b, boolean deopt) {
 923         MyValue2.ref[] src = new MyValue2.ref[1];
 924         if (b) {
 925             src[0] = MyValue2.createWithFieldsInline(rI, true);
 926         } else {
 927             src[0] = MyValue2.createWithFieldsInline(rI, false);
 928         }
 929         if (deopt) {
 930             // uncommon trap
 931             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test31&quot;));
 932         }
 933         return src[0].hash();
 934     }
 935 
 936     @DontCompile
 937     public void test31_verifier(boolean warmup) {
 938         MyValue2 v1 = MyValue2.createWithFieldsInline(rI, true);
 939         long result1 = test31(true, !warmup);
 940         Asserts.assertEQ(result1, v1.hash());
 941         MyValue2 v2 = MyValue2.createWithFieldsInline(rI, false);
 942         long result2 = test31(false, !warmup);
 943         Asserts.assertEQ(result2, v2.hash());
 944     }
 945 
 946     // Tests with Object arrays and clone/arraycopy
 947     // clone() as stub call
 948     @Test
 949     public Object[] test32(Object[] va) {
 950         return va.clone();
 951     }
 952 
 953     @DontCompile
 954     public void test32_verifier(boolean warmup) {
 955         int len = Math.abs(rI) % 10;
 956         MyValue1.ref[] va1 = new MyValue1.ref[len];
 957         MyValue1[] va2 = new MyValue1[len];
 958         for (int i = 1; i &lt; len; ++i) {
 959             va1[i] = testValue1;
 960             va2[i] = testValue1;
 961         }
 962         MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);
 963         MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);
 964         if (len &gt; 0) {
 965             Asserts.assertEQ(result1[0], null);
 966             Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
 967         }
 968         for (int i = 1; i &lt; len; ++i) {
 969             Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());
 970             Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());
 971         }
 972     }
 973 
 974     @Test
 975     public Object[] test33(Object[] va) {
 976         return va.clone();
 977     }
 978 
 979     @DontCompile
 980     public void test33_verifier(boolean warmup) {
 981         int len = Math.abs(rI) % 10;
 982         Object[] va = new Object[len];
 983         for (int i = 0; i &lt; len; ++i) {
 984             va[i] = testValue1;
 985         }
 986         Object[] result = test33(va);
 987         for (int i = 0; i &lt; len; ++i) {
 988             Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());
 989         }
 990     }
 991 
 992     // clone() as series of loads/stores
 993     static Object[] test34_orig = null;
 994 
 995     @ForceInline
 996     public Object[] test34_helper(boolean flag) {
 997         Object[] va = null;
 998         if (flag) {
 999             va = new MyValue1.ref[8];
1000             for (int i = 0; i &lt; va.length; ++i) {
1001                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
1002             }
1003         } else {
1004             va = new Object[8];
1005         }
1006         return va;
1007     }
1008 
1009     @Test
1010     public Object[] test34(boolean flag) {
1011         Object[] va = test34_helper(flag);
1012         test34_orig = va;
1013         return va.clone();
1014     }
1015 
1016     @DontCompile
1017     public void test34_verifier(boolean warmup) {
1018         test34(false);
1019         for (int i = 0; i &lt; 10; i++) { // make sure we do deopt
1020             Object[] result = test34(true);
1021             verify(test34_orig, result);
1022         }
1023         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test34&quot;)) {
1024             Object[] result = test34(true);
1025             verify(test34_orig, result);
1026         }
1027     }
1028 
1029     static void verify(Object[] src, Object[] dst) {
1030         for (int i = 0; i &lt; src.length; ++i) {
1031             if (src[i] != null) {
1032                 Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());
1033             } else {
1034                 Asserts.assertEQ(dst[i], null);
1035             }
1036         }
1037     }
1038 
1039     static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {
1040         for (int i = 0; i &lt; src.length; ++i) {
1041             if (src[i] != null) {
1042                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1043             } else {
1044                 Asserts.assertEQ(dst[i], null);
1045             }
1046         }
1047     }
1048 
1049     static void verify(MyValue1.ref[] src, Object[] dst) {
1050         for (int i = 0; i &lt; src.length; ++i) {
1051             if (src[i] != null) {
1052                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1053             } else {
1054                 Asserts.assertEQ(dst[i], null);
1055             }
1056         }
1057     }
1058 
1059     static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {
1060         for (int i = 0; i &lt; src.length; ++i) {
1061             if (src[i] != null) {
1062                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1063             } else {
1064                 Asserts.assertEQ(dst[i], null);
1065             }
1066         }
1067     }
1068 
1069     static void verify(MyValue2.ref[] src, Object[] dst) {
1070         for (int i = 0; i &lt; src.length; ++i) {
1071             if (src[i] != null) {
1072                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1073             } else {
1074                 Asserts.assertEQ(dst[i], null);
1075             }
1076         }
1077     }
1078 
1079     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1080         if (!warmup) {
1081             Method m = tests.get(test);
1082             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
1083                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1084                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1085                 }
1086                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1087                 return true;
1088             }
1089         }
1090         return false;
1091     }
1092 
1093     // arraycopy() of inline type array of unknown size
1094     @Test
1095     public void test35(Object src, Object dst, int len) {
1096         System.arraycopy(src, 0, dst, 0, len);
1097     }
1098 
1099     @DontCompile
1100     public void test35_verifier(boolean warmup) {
1101         int len = Math.abs(rI) % 10;
1102         MyValue1.ref[] src = new MyValue1.ref[len];
1103         MyValue1.ref[] dst = new MyValue1.ref[len];
1104         for (int i = 1; i &lt; len; ++i) {
1105             src[i] = testValue1;
1106         }
1107         test35(src, dst, src.length);
1108         verify(src, dst);
1109         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1110             test35(src, dst, src.length);
1111             verify(src, dst);
1112         }
1113     }
1114 
1115     @Test
1116     public void test36(Object src, MyValue2.ref[] dst) {
1117         System.arraycopy(src, 0, dst, 0, dst.length);
1118     }
1119 
1120     @DontCompile
1121     public void test36_verifier(boolean warmup) {
1122         int len = Math.abs(rI) % 10;
1123         MyValue2.ref[] src = new MyValue2.ref[len];
1124         MyValue2.ref[] dst = new MyValue2.ref[len];
1125         for (int i = 1; i &lt; len; ++i) {
1126             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1127         }
1128         test36(src, dst);
1129         verify(src, dst);
1130         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test36&quot;)) {
1131             test36(src, dst);
1132             verify(src, dst);
1133         }
1134     }
1135 
1136     @Test
1137     public void test37(MyValue2.ref[] src, Object dst) {
1138         System.arraycopy(src, 0, dst, 0, src.length);
1139     }
1140 
1141     @DontCompile
1142     public void test37_verifier(boolean warmup) {
1143         int len = Math.abs(rI) % 10;
1144         MyValue2.ref[] src = new MyValue2.ref[len];
1145         MyValue2.ref[] dst = new MyValue2.ref[len];
1146         for (int i = 1; i &lt; len; ++i) {
1147             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1148         }
1149         test37(src, dst);
1150         verify(src, dst);
1151         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test37&quot;)) {
1152             test37(src, dst);
1153             verify(src, dst);
1154         }
1155     }
1156 
1157     @Test
1158     @Warmup(1) // Avoid early compilation
1159     public void test38(Object src, MyValue2.ref[] dst) {
1160         System.arraycopy(src, 0, dst, 0, dst.length);
1161     }
1162 
1163     @DontCompile
1164     public void test38_verifier(boolean warmup) {
1165         int len = Math.abs(rI) % 10;
1166         Object[] src = new Object[len];
1167         MyValue2.ref[] dst = new MyValue2.ref[len];
1168         for (int i = 1; i &lt; len; ++i) {
1169             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1170         }
1171         test38(src, dst);
1172         verify(dst, src);
1173         if (!warmup) {
1174             Method m = tests.get(&quot;TestNullableArrays::test38&quot;);
1175             assertDeoptimizedByC2(m);
1176             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1177             test38(src, dst);
1178             verify(dst, src);
1179             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1180                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1181             }
1182         }
1183     }
1184 
1185     @Test
1186     public void test39(MyValue2.ref[] src, Object dst) {
1187         System.arraycopy(src, 0, dst, 0, src.length);
1188     }
1189 
1190     @DontCompile
1191     public void test39_verifier(boolean warmup) {
1192         int len = Math.abs(rI) % 10;
1193         MyValue2.ref[] src = new MyValue2.ref[len];
1194         Object[] dst = new Object[len];
1195         for (int i = 1; i &lt; len; ++i) {
1196             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1197         }
1198         test39(src, dst);
1199         verify(src, dst);
1200         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test39&quot;)) {
1201             test39(src, dst);
1202             verify(src, dst);
1203         }
1204     }
1205 
1206     @Test
1207     @Warmup(1) // Avoid early compilation
1208     public void test40(Object[] src, Object dst) {
1209         System.arraycopy(src, 0, dst, 0, src.length);
1210     }
1211 
1212     @DontCompile
1213     public void test40_verifier(boolean warmup) {
1214         int len = Math.abs(rI) % 10;
1215         Object[] src = new Object[len];
1216         MyValue2.ref[] dst = new MyValue2.ref[len];
1217         for (int i = 1; i &lt; len; ++i) {
1218             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1219         }
1220         test40(src, dst);
1221         verify(dst, src);
1222         if (!warmup) {
1223             Method m = tests.get(&quot;TestNullableArrays::test40&quot;);
1224             assertDeoptimizedByC2(m);
1225             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1226             test40(src, dst);
1227             verify(dst, src);
1228             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1229                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1230             }
1231         }
1232     }
1233 
1234     @Test
1235     public void test41(Object src, Object[] dst) {
1236         System.arraycopy(src, 0, dst, 0, dst.length);
1237     }
1238 
1239     @DontCompile
1240     public void test41_verifier(boolean warmup) {
1241         int len = Math.abs(rI) % 10;
1242         MyValue2.ref[] src = new MyValue2.ref[len];
1243         Object[] dst = new Object[len];
1244         for (int i = 1; i &lt; len; ++i) {
1245             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1246         }
1247         test41(src, dst);
1248         verify(src, dst);
1249         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test41&quot;)) {
1250             test41(src, dst);
1251             verify(src, dst);
1252         }
1253     }
1254 
1255     @Test
1256     public void test42(Object[] src, Object[] dst) {
1257         System.arraycopy(src, 0, dst, 0, src.length);
1258     }
1259 
1260     @DontCompile
1261     public void test42_verifier(boolean warmup) {
1262         int len = Math.abs(rI) % 10;
1263         Object[] src = new Object[len];
1264         Object[] dst = new Object[len];
1265         for (int i = 1; i &lt; len; ++i) {
1266             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1267         }
1268         test42(src, dst);
1269         verify(src, dst);
1270         if (!warmup) {
1271             Method m = tests.get(&quot;TestNullableArrays::test42&quot;);
1272             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1273                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1274             }
1275         }
1276     }
1277 
1278     // short arraycopy()&#39;s
1279     @Test
1280     public void test43(Object src, Object dst) {
1281         System.arraycopy(src, 0, dst, 0, 8);
1282     }
1283 
1284     @DontCompile
1285     public void test43_verifier(boolean warmup) {
1286         MyValue1.ref[] src = new MyValue1.ref[8];
1287         MyValue1.ref[] dst = new MyValue1.ref[8];
1288         for (int i = 1; i &lt; 8; ++i) {
1289             src[i] = testValue1;
1290         }
1291         test43(src, dst);
1292         verify(src, dst);
1293         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test43&quot;)) {
1294             test43(src, dst);
1295             verify(src, dst);
1296         }
1297     }
1298 
1299     @Test
1300     public void test44(Object src, MyValue2.ref[] dst) {
1301         System.arraycopy(src, 0, dst, 0, 8);
1302     }
1303 
1304     @DontCompile
1305     public void test44_verifier(boolean warmup) {
1306         MyValue2.ref[] src = new MyValue2.ref[8];
1307         MyValue2.ref[] dst = new MyValue2.ref[8];
1308         for (int i = 1; i &lt; 8; ++i) {
1309             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1310         }
1311         test44(src, dst);
1312         verify(src, dst);
1313         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test44&quot;)) {
1314             test44(src, dst);
1315             verify(src, dst);
1316         }
1317     }
1318 
1319     @Test
1320     public void test45(MyValue2.ref[] src, Object dst) {
1321         System.arraycopy(src, 0, dst, 0, 8);
1322     }
1323 
1324     @DontCompile
1325     public void test45_verifier(boolean warmup) {
1326         MyValue2.ref[] src = new MyValue2.ref[8];
1327         MyValue2.ref[] dst = new MyValue2.ref[8];
1328         for (int i = 1; i &lt; 8; ++i) {
1329             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1330         }
1331         test45(src, dst);
1332         verify(src, dst);
1333         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test45&quot;)) {
1334             test45(src, dst);
1335             verify(src, dst);
1336         }
1337     }
1338 
1339     @Test
1340     @Warmup(1) // Avoid early compilation
1341     public void test46(Object[] src, MyValue2.ref[] dst) {
1342         System.arraycopy(src, 0, dst, 0, 8);
1343     }
1344 
1345     @DontCompile
1346     public void test46_verifier(boolean warmup) {
1347         Object[] src = new Object[8];
1348         MyValue2.ref[] dst = new MyValue2.ref[8];
1349         for (int i = 1; i &lt; 8; ++i) {
1350             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1351         }
1352         test46(src, dst);
1353         verify(dst, src);
1354         if (!warmup) {
1355             Method m = tests.get(&quot;TestNullableArrays::test46&quot;);
1356             assertDeoptimizedByC2(m);
1357             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1358             test46(src, dst);
1359             verify(dst, src);
1360             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1361                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1362             }
1363         }
1364     }
1365 
1366     @Test
1367     public void test47(MyValue2.ref[] src, Object[] dst) {
1368         System.arraycopy(src, 0, dst, 0, 8);
1369     }
1370 
1371     @DontCompile
1372     public void test47_verifier(boolean warmup) {
1373         MyValue2.ref[] src = new MyValue2.ref[8];
1374         Object[] dst = new Object[8];
1375         for (int i = 1; i &lt; 8; ++i) {
1376             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1377         }
1378         test47(src, dst);
1379         verify(src, dst);
1380         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test47&quot;)) {
1381             test47(src, dst);
1382             verify(src, dst);
1383         }
1384     }
1385 
1386     @Test
1387     @Warmup(1) // Avoid early compilation
1388     public void test48(Object[] src, Object dst) {
1389         System.arraycopy(src, 0, dst, 0, 8);
1390     }
1391 
1392     @DontCompile
1393     public void test48_verifier(boolean warmup) {
1394         Object[] src = new Object[8];
1395         MyValue2.ref[] dst = new MyValue2.ref[8];
1396         for (int i = 1; i &lt; 8; ++i) {
1397             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1398         }
1399         test48(src, dst);
1400         verify(dst, src);
1401         if (!warmup) {
1402             Method m = tests.get(&quot;TestNullableArrays::test48&quot;);
1403             assertDeoptimizedByC2(m);
1404             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1405             test48(src, dst);
1406             verify(dst, src);
1407             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1408                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1409             }
1410         }
1411     }
1412 
1413     @Test
1414     public void test49(Object src, Object[] dst) {
1415         System.arraycopy(src, 0, dst, 0, 8);
1416     }
1417 
1418     @DontCompile
1419     public void test49_verifier(boolean warmup) {
1420         MyValue2.ref[] src = new MyValue2.ref[8];
1421         Object[] dst = new Object[8];
1422         for (int i = 1; i &lt; 8; ++i) {
1423             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1424         }
1425         test49(src, dst);
1426         verify(src, dst);
1427         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test49&quot;)) {
1428             test49(src, dst);
1429             verify(src, dst);
1430         }
1431     }
1432 
1433     @Test
1434     public void test50(Object[] src, Object[] dst) {
1435         System.arraycopy(src, 0, dst, 0, 8);
1436     }
1437 
1438     @DontCompile
1439     public void test50_verifier(boolean warmup) {
1440         Object[] src = new Object[8];
1441         Object[] dst = new Object[8];
1442         for (int i = 1; i &lt; 8; ++i) {
1443             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1444         }
1445         test50(src, dst);
1446         verify(src, dst);
1447         if (!warmup) {
1448             Method m = tests.get(&quot;TestNullableArrays::test50&quot;);
1449             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1450                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1451             }
1452         }
1453     }
1454 
1455     @Test
1456     public MyValue1.ref[] test51(MyValue1.ref[] va) {
1457         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1458     }
1459 
1460     @DontCompile
1461     public void test51_verifier(boolean warmup) {
1462         int len = Math.abs(rI) % 10;
1463         MyValue1.ref[] va = new MyValue1.ref[len];
1464         for (int i = 1; i &lt; len; ++i) {
1465             va[i] = testValue1;
1466         }
1467         MyValue1.ref[] result = test51(va);
1468         verify(va, result);
1469     }
1470 
1471     static final MyValue1.ref[] test52_va = new MyValue1.ref[8];
1472 
1473     @Test
1474     public MyValue1.ref[] test52() {
1475         return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);
1476     }
1477 
1478     @DontCompile
1479     public void test52_verifier(boolean warmup) {
1480         for (int i = 1; i &lt; 8; ++i) {
1481             test52_va[i] = testValue1;
1482         }
1483         MyValue1.ref[] result = test52();
1484         verify(test52_va, result);
1485     }
1486 
1487     @Test
1488     public MyValue1.ref[] test53(Object[] va) {
1489         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1490     }
1491 
1492     @DontCompile
1493     public void test53_verifier(boolean warmup) {
1494         int len = Math.abs(rI) % 10;
1495         MyValue1.ref[] va = new MyValue1.ref[len];
1496         for (int i = 1; i &lt; len; ++i) {
1497             va[i] = testValue1;
1498         }
1499         MyValue1.ref[] result = test53(va);
1500         verify(result, va);
1501     }
1502 
1503     @Test
1504     public Object[] test54(MyValue1.ref[] va) {
1505         return Arrays.copyOf(va, va.length, Object[].class);
1506     }
1507 
1508     @DontCompile
1509     public void test54_verifier(boolean warmup) {
1510         int len = Math.abs(rI) % 10;
1511         MyValue1.ref[] va = new MyValue1.ref[len];
1512         for (int i = 1; i &lt; len; ++i) {
1513             va[i] = testValue1;
1514         }
1515         Object[] result = test54(va);
1516         verify(va, result);
1517     }
1518 
1519     @Test
1520     public Object[] test55(Object[] va) {
1521         return Arrays.copyOf(va, va.length, Object[].class);
1522     }
1523 
1524     @DontCompile
1525     public void test55_verifier(boolean warmup) {
1526         int len = Math.abs(rI) % 10;
1527         MyValue1.ref[] va = new MyValue1.ref[len];
1528         for (int i = 1; i &lt; len; ++i) {
1529             va[i] = testValue1;
1530         }
1531         Object[] result = test55(va);
1532         verify(va, result);
1533     }
1534 
1535     @Test
1536     public MyValue1.ref[] test56(Object[] va) {
1537         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
1538     }
1539 
1540     @DontCompile
1541     public void test56_verifier(boolean warmup) {
1542         int len = Math.abs(rI) % 10;
1543         Object[] va = new Object[len];
1544         for (int i = 1; i &lt; len; ++i) {
1545             va[i] = testValue1;
1546         }
1547         MyValue1.ref[] result = test56(va);
1548         verify(result, va);
1549     }
1550 
1551    @Test
1552     public Object[] test57(Object[] va, Class klass) {
1553         return Arrays.copyOf(va, va.length, klass);
1554     }
1555 
1556     @DontCompile
1557     public void test57_verifier(boolean warmup) {
1558         int len = Math.abs(rI) % 10;
1559         Object[] va = new MyValue1.ref[len];
1560         for (int i = 1; i &lt; len; ++i) {
1561             va[i] = testValue1;
1562         }
1563         Object[] result = test57(va, MyValue1.ref[].class);
1564         verify(va, result);
1565     }
1566 
1567     @Test
1568     public Object[] test58(MyValue1.ref[] va, Class klass) {
1569         return Arrays.copyOf(va, va.length, klass);
1570     }
1571 
1572     @DontCompile
1573     public void test58_verifier(boolean warmup) {
1574         int len = Math.abs(rI) % 10;
1575         MyValue1.ref[] va = new MyValue1.ref[len];
1576         for (int i = 1; i &lt; len; ++i) {
1577             va[i] = testValue1;
1578         }
1579         for (int i = 1; i &lt; 10; i++) {
1580             Object[] result = test58(va, MyValue1.ref[].class);
1581             verify(va, result);
1582         }
1583         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
1584             Object[] result = test58(va, MyValue1.ref[].class);
1585             verify(va, result);
1586         }
1587     }
1588 
1589     @Test
1590     public Object[] test59(MyValue1.ref[] va) {
1591         return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);
1592     }
1593 
1594     @DontCompile
1595     public void test59_verifier(boolean warmup) {
1596         int len = Math.abs(rI) % 10;
1597         MyValue1.ref[] va = new MyValue1.ref[len];
1598         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1599         for (int i = 1; i &lt; len; ++i) {
1600             va[i] = testValue1;
1601             verif[i] = va[i];
1602         }
1603         Object[] result = test59(va);
1604         verify(verif, result);
1605     }
1606 
1607     @Test
1608     public Object[] test60(Object[] va, Class klass) {
1609         return Arrays.copyOf(va, va.length+1, klass);
1610     }
1611 
1612     @DontCompile
1613     public void test60_verifier(boolean warmup) {
1614         int len = Math.abs(rI) % 10;
1615         MyValue1.ref[] va = new MyValue1.ref[len];
1616         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1617         for (int i = 1; i &lt; len; ++i) {
1618             va[i] = testValue1;
1619             verif[i] = (MyValue1)va[i];
1620         }
1621         Object[] result = test60(va, MyValue1.ref[].class);
1622         verify(verif, result);
1623     }
1624 
1625     @Test
1626     public Object[] test61(Object[] va, Class klass) {
1627         return Arrays.copyOf(va, va.length+1, klass);
1628     }
1629 
1630     @DontCompile
1631     public void test61_verifier(boolean warmup) {
1632         int len = Math.abs(rI) % 10;
1633         Object[] va = new Integer[len];
1634         for (int i = 1; i &lt; len; ++i) {
1635             va[i] = new Integer(rI);
1636         }
1637         Object[] result = test61(va, Integer[].class);
1638         for (int i = 0; i &lt; va.length; ++i) {
1639             Asserts.assertEQ(va[i], result[i]);
1640         }
1641     }
1642 
1643     @ForceInline
1644     public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1645         Object[] arr = null;
1646         if (i == 10) {
1647             arr = oa;
1648         } else {
1649             arr = va;
1650         }
1651         return arr;
1652     }
1653 
1654     @Test
1655     public Object[] test62(MyValue1.ref[] va, Integer[] oa) {
1656         int i = 0;
1657         for (; i &lt; 10; i++);
1658 
1659         Object[] arr = test62_helper(i, va, oa);
1660 
1661         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1662     }
1663 
1664     @DontCompile
1665     public void test62_verifier(boolean warmup) {
1666         int len = Math.abs(rI) % 10;
1667         MyValue1.ref[] va = new MyValue1.ref[len];
1668         Integer[] oa = new Integer[len];
1669         for (int i = 1; i &lt; len; ++i) {
1670             oa[i] = new Integer(rI);
1671         }
1672         test62_helper(42, va, oa);
1673         Object[] result = test62(va, oa);
1674         for (int i = 0; i &lt; va.length; ++i) {
1675             Asserts.assertEQ(oa[i], result[i]);
1676         }
1677     }
1678 
1679     @ForceInline
1680     public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1681         Object[] arr = null;
1682         if (i == 10) {
1683             arr = va;
1684         } else {
1685             arr = oa;
1686         }
1687         return arr;
1688     }
1689 
1690     @Test
1691     public Object[] test63(MyValue1.ref[] va, Integer[] oa) {
1692         int i = 0;
1693         for (; i &lt; 10; i++);
1694 
1695         Object[] arr = test63_helper(i, va, oa);
1696 
1697         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1698     }
1699 
1700     @DontCompile
1701     public void test63_verifier(boolean warmup) {
1702         int len = Math.abs(rI) % 10;
1703         MyValue1.ref[] va = new MyValue1.ref[len];
1704         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1705         for (int i = 1; i &lt; len; ++i) {
1706             va[i] = testValue1;
1707             verif[i] = va[i];
1708         }
1709         Integer[] oa = new Integer[len];
1710         test63_helper(42, va, oa);
1711         Object[] result = test63(va, oa);
1712         verify(verif, result);
1713     }
1714 
1715     // Test default initialization of inline type arrays: small array
1716     @Test
1717     public MyValue1.ref[] test64() {
1718         return new MyValue1.ref[8];
1719     }
1720 
1721     @DontCompile
1722     public void test64_verifier(boolean warmup) {
1723         MyValue1.ref[] va = test64();
1724         for (int i = 0; i &lt; 8; ++i) {
1725             Asserts.assertEQ(va[i], null);
1726         }
1727     }
1728 
1729     // Test default initialization of inline type arrays: large array
1730     @Test
1731     public MyValue1.ref[] test65() {
1732         return new MyValue1.ref[32];
1733     }
1734 
1735     @DontCompile
1736     public void test65_verifier(boolean warmup) {
1737         MyValue1.ref[] va = test65();
1738         for (int i = 0; i &lt; 32; ++i) {
1739             Asserts.assertEQ(va[i], null);
1740         }
1741     }
1742 
1743     // Check init store elimination
1744     @Test(match = { ALLOCA }, matchCount = { 1 })
1745     public MyValue1.ref[] test66(MyValue1.ref vt) {
1746         MyValue1.ref[] va = new MyValue1.ref[1];
1747         va[0] = vt;
1748         return va;
1749     }
1750 
1751     @DontCompile
1752     public void test66_verifier(boolean warmup) {
1753         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1754         MyValue1.ref[] va = test66(vt);
1755         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
1756     }
1757 
1758     // Zeroing elimination and arraycopy
1759     @Test
1760     public MyValue1.ref[] test67(MyValue1.ref[] src) {
1761         MyValue1.ref[] dst = new MyValue1.ref[16];
1762         System.arraycopy(src, 0, dst, 0, 13);
1763         return dst;
1764     }
1765 
1766     @DontCompile
1767     public void test67_verifier(boolean warmup) {
1768         MyValue1.ref[] va = new MyValue1.ref[16];
1769         MyValue1.ref[] var = test67(va);
1770         for (int i = 0; i &lt; 16; ++i) {
1771             Asserts.assertEQ(var[i], null);
1772         }
1773     }
1774 
1775     // A store with a default value can be eliminated
1776     @Test
1777     public MyValue1.ref[] test68() {
1778         MyValue1.ref[] va = new MyValue1.ref[2];
1779         va[0] = va[1];
1780         return va;
1781     }
1782 
1783     @DontCompile
1784     public void test68_verifier(boolean warmup) {
1785         MyValue1.ref[] va = test68();
1786         for (int i = 0; i &lt; 2; ++i) {
1787             Asserts.assertEQ(va[i], null);
1788         }
1789     }
1790 
1791     // Requires individual stores to init array
1792     @Test
1793     public MyValue1.ref[] test69(MyValue1.ref vt) {
1794         MyValue1.ref[] va = new MyValue1.ref[4];
1795         va[0] = vt;
1796         va[3] = vt;
1797         return va;
1798     }
1799 
1800     @DontCompile
1801     public void test69_verifier(boolean warmup) {
1802         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
1803         MyValue1.ref[] va = new MyValue1.ref[4];
1804         va[0] = vt;
1805         va[3] = vt;
1806         MyValue1.ref[] var = test69(vt);
1807         for (int i = 0; i &lt; va.length; ++i) {
1808             Asserts.assertEQ(va[i], var[i]);
1809         }
1810     }
1811 
1812     // A store with a default value can be eliminated: same as test68
1813     // but store is farther away from allocation
1814     @Test
1815     public MyValue1.ref[] test70(MyValue1.ref[] other) {
1816         other[1] = other[0];
1817         MyValue1.ref[] va = new MyValue1.ref[2];
1818         other[0] = va[1];
1819         va[0] = va[1];
1820         return va;
1821     }
1822 
1823     @DontCompile
1824     public void test70_verifier(boolean warmup) {
1825         MyValue1.ref[] va = new MyValue1.ref[2];
1826         MyValue1.ref[] var = test70(va);
1827         for (int i = 0; i &lt; 2; ++i) {
1828             Asserts.assertEQ(va[i], var[i]);
1829         }
1830     }
1831 
1832     // EA needs to consider oop fields in flattened arrays
1833     @Test
1834     public void test71() {
1835         int len = 10;
1836         MyValue2.ref[] src = new MyValue2.ref[len];
1837         MyValue2.ref[] dst = new MyValue2.ref[len];
1838         for (int i = 1; i &lt; len; ++i) {
1839             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
1840         }
1841         System.arraycopy(src, 0, dst, 0, src.length);
1842         for (int i = 0; i &lt; len; ++i) {
1843             if (src[i] == null) {
1844                 Asserts.assertEQ(dst[i], null);
1845             } else {
1846                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
1847             }
1848         }
1849     }
1850 
1851     @DontCompile
1852     public void test71_verifier(boolean warmup) {
1853         test71();
1854     }
1855 
1856     // Test EA with leaf call to &#39;store_unknown_value&#39;
1857     @Test
1858     public void test72(Object[] o, boolean b, Object element) {
1859         Object[] arr1 = new Object[10];
1860         Object[] arr2 = new Object[10];
1861         if (b) {
1862             arr1 = o;
1863         }
1864         arr1[0] = element;
1865         arr2[0] = element;
1866     }
1867 
1868     @DontCompile
1869     public void test72_verifier(boolean warmup) {
1870         Object[] arr = new Object[1];
1871         Object elem = new Object();
1872         test72(arr, true, elem);
1873         test72(arr, false, elem);
1874     }
1875 
1876     @Test
1877     public void test73(Object[] oa, MyValue1.ref v, Object o) {
1878         // TestLWorld.test38 use a C1 Phi node for the array. This test
1879         // adds the case where the stored value is a C1 Phi node.
1880         Object o2 = (o == null) ? v : o;
1881         oa[0] = v;  // The stored value is known to be flattenable
1882         oa[1] = o;  // The stored value may be flattenable
1883         oa[2] = o2; // The stored value may be flattenable (a C1 Phi node)
1884         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
1885     }
1886 
1887     @DontCompile
1888     public void test73_verifier(boolean warmup) {
1889         MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);
1890         MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
1891         MyValue1.ref[] arr = new MyValue1.ref[3];
1892         try {
1893             test73(arr, v0, v1);
1894             throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
1895         } catch (ArrayStoreException t) {
1896             // expected
1897         }
1898         Asserts.assertEQ(arr[0].hash(), v0.hash());
1899         Asserts.assertEQ(arr[1].hash(), v1.hash());
1900         Asserts.assertEQ(arr[2].hash(), v1.hash());
1901     }
1902 
1903     // Some more array clone tests
1904     @ForceInline
1905     public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1906         Object[] arr = null;
1907         if (i == 10) {
1908             arr = oa;
1909         } else {
1910             arr = va;
1911         }
1912         return arr;
1913     }
1914 
1915     @Test
1916     public Object[] test74(MyValue1.ref[] va, Integer[] oa) {
1917         int i = 0;
1918         for (; i &lt; 10; i++);
1919 
1920         Object[] arr = test74_helper(i, va, oa);
1921         return arr.clone();
1922     }
1923 
1924     @DontCompile
1925     public void test74_verifier(boolean warmup) {
1926         int len = Math.abs(rI) % 10;
1927         MyValue1.ref[] va = new MyValue1.ref[len];
1928         Integer[] oa = new Integer[len];
1929         for (int i = 1; i &lt; len; ++i) {
1930             oa[i] = new Integer(rI);
1931         }
1932         test74_helper(42, va, oa);
1933         Object[] result = test74(va, oa);
1934 
1935         for (int i = 0; i &lt; va.length; ++i) {
1936             Asserts.assertEQ(oa[i], result[i]);
1937             // Check that array has correct properties (null-ok)
1938             result[i] = null;
1939         }
1940     }
1941 
1942     @ForceInline
1943     public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {
1944         Object[] arr = null;
1945         if (i == 10) {
1946             arr = va;
1947         } else {
1948             arr = oa;
1949         }
1950         return arr;
1951     }
1952 
1953     @Test
1954     public Object[] test75(MyValue1.ref[] va, Integer[] oa) {
1955         int i = 0;
1956         for (; i &lt; 10; i++);
1957 
1958         Object[] arr = test75_helper(i, va, oa);
1959         return arr.clone();
1960     }
1961 
1962     @DontCompile
1963     public void test75_verifier(boolean warmup) {
1964         int len = Math.abs(rI) % 10;
1965         MyValue1.ref[] va = new MyValue1.ref[len];
1966         MyValue1.ref[] verif = new MyValue1.ref[len];
1967         for (int i = 1; i &lt; len; ++i) {
1968             va[i] = testValue1;
1969             verif[i] = va[i];
1970         }
1971         Integer[] oa = new Integer[len];
1972         test75_helper(42, va, oa);
1973         Object[] result = test75(va, oa);
1974         verify(verif, result);
1975         if (len &gt; 0) {
1976             // Check that array has correct properties (null-ok)
1977             result[0] = null;
1978         }
1979     }
1980 
1981     // Test mixing nullable and non-nullable arrays
1982     @Test
1983     public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {
1984         Object[] result = null;
1985         if (n == 0) {
1986             result = vva;
1987         } else if (n == 1) {
1988             result = vba;
1989         } else if (n == 2) {
1990             result = new MyValue1[42];
1991         } else if (n == 3) {
1992             result = new MyValue1.ref[42];
1993         }
1994         result[0] = vt;
1995         out[0] = result[1];
1996         return result;
1997     }
1998 
1999     @DontCompile
2000     public void test76_verifier(boolean warmup) {
2001         MyValue1 vt = testValue1;
2002         Object[] out = new Object[1];
2003         MyValue1[] vva = new MyValue1[42];
2004         MyValue1[] vva_r = new MyValue1[42];
2005         vva_r[0] = vt;
2006         MyValue1.ref[] vba = new MyValue1.ref[42];
2007         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2008         vba_r[0] = vt;
2009         Object[] result = test76(vva, vba, vt, out, 0);
2010         verify(result, vva_r);
2011         Asserts.assertEQ(out[0], vva_r[1]);
2012         result = test76(vva, vba, vt, out, 1);
2013         verify(result, vba_r);
2014         Asserts.assertEQ(out[0], vba_r[1]);
2015         result = test76(vva, vba, vt, out, 2);
2016         verify(result, vva_r);
2017         Asserts.assertEQ(out[0], vva_r[1]);
2018         result = test76(vva, vba, vt, out, 3);
2019         verify(result, vba_r);
2020         Asserts.assertEQ(out[0], vba_r[1]);
2021     }
2022 
2023     @Test
2024     public Object[] test77(boolean b) {
2025         Object[] va;
2026         if (b) {
2027             va = new MyValue1.ref[5];
2028             for (int i = 0; i &lt; 5; ++i) {
2029                 va[i] = testValue1;
2030             }
2031         } else {
2032             va = new MyValue1[10];
2033             for (int i = 0; i &lt; 10; ++i) {
2034                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
2035             }
2036         }
2037         long sum = ((MyValue1)va[0]).hashInterpreted();
2038         if (b) {
2039             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
2040         } else {
2041             va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);
2042         }
2043         return va;
2044     }
2045 
2046     @DontCompile
2047     public void test77_verifier(boolean warmup) {
2048         Object[] va = test77(true);
2049         Asserts.assertEQ(va.length, 5);
2050         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2051         for (int i = 1; i &lt; 5; ++i) {
2052             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2053         }
2054         va = test77(false);
2055         Asserts.assertEQ(va.length, 10);
2056         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2057         for (int i = 1; i &lt; 10; ++i) {
2058             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2059         }
2060     }
2061 
2062     // Same as test76 but with non inline type array cases
2063     @Test
2064     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2065         Object[] result = null;
2066         if (n == 0) {
2067             result = vva;
2068         } else if (n == 1) {
2069             result = vba;
2070         } else if (n == 2) {
2071             result = new MyValue1[42];
2072         } else if (n == 3) {
2073             result = new MyValue1.ref[42];
2074         } else if (n == 4) {
2075             result = new Integer[42];
2076         }
2077         result[0] = val;
2078         out[0] = result[1];
2079         return result;
2080     }
2081 
2082     @DontCompile
2083     public void test78_verifier(boolean warmup) {
2084         MyValue1 vt = testValue1;
2085         Integer i = new Integer(42);
2086         Object[] out = new Object[1];
2087         MyValue1[] vva = new MyValue1[42];
2088         MyValue1[] vva_r = new MyValue1[42];
2089         vva_r[0] = vt;
2090         MyValue1.ref[] vba = new MyValue1.ref[42];
2091         MyValue1.ref[] vba_r = new MyValue1.ref[42];
2092         vba_r[0] = vt;
2093         Object[] result = test78(vva, vba, vt, out, 0);
2094         verify(result, vva_r);
2095         Asserts.assertEQ(out[0], vva_r[1]);
2096         result = test78(vva, vba, vt, out, 1);
2097         verify(result, vba_r);
2098         Asserts.assertEQ(out[0], vba_r[1]);
2099         result = test78(vva, vba, vt, out, 2);
2100         verify(result, vva_r);
2101         Asserts.assertEQ(out[0], vva_r[1]);
2102         result = test78(vva, vba, vt, out, 3);
2103         verify(result, vba_r);
2104         Asserts.assertEQ(out[0], vba_r[1]);
2105         result = test78(vva, vba, i, out, 4);
2106         Asserts.assertEQ(result[0], i);
2107         Asserts.assertEQ(out[0], null);
2108     }
2109 
2110     // Test widening conversions from [Q to [L
2111     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2112     public static MyValue1.ref[] test79(MyValue1[] va) {
2113         return va;
2114     }
2115 
2116     @DontCompile
2117     public void test79_verifier(boolean warmup) {
2118         MyValue1[] va = new MyValue1[1];
2119         va[0] = testValue1;
2120         MyValue1.ref[] res = test79(va);
2121         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2122         try {
2123             res[0] = null;
2124             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2125         } catch (NullPointerException npe) {
2126             // Expected
2127         }
2128         res[0] = testValue1;
2129         test79(null); // Should not throw NPE
2130     }
2131 
2132     // Same as test79 but with explicit cast and Object return
2133     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2134     public static Object[] test80(MyValue1[] va) {
2135         return (MyValue1.ref[])va;
2136     }
2137 
2138     @DontCompile
2139     public void test80_verifier(boolean warmup) {
2140         MyValue1[] va = new MyValue1[1];
2141         va[0] = testValue1;
2142         Object[] res = test80(va);
2143         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2144         try {
2145             res[0] = null;
2146             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2147         } catch (NullPointerException npe) {
2148             // Expected
2149         }
2150         res[0] = testValue1;
2151         test80(null); // Should not throw NPE
2152     }
2153 
2154     // Test mixing widened and boxed array type
2155     @Test()
2156     public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
2157         MyValue1.ref[] result = b ? va1 : va2;
2158         try {
2159             result[0] = vt;
2160         } catch (NullPointerException npe) {
2161             // Ignored
2162         }
2163         return result[1].hash();
2164     }
2165 
2166     @DontCompile
2167     public void test81_verifier(boolean warmup) {
2168         MyValue1[] va = new MyValue1[2];
2169         MyValue1.ref[] vaB = new MyValue1.ref[2];
2170         va[1] = testValue1;
2171         vaB[1] = testValue1;
2172         long res = test81(va, vaB, testValue1, true, true);
2173         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2174         Asserts.assertEquals(res, testValue1.hash());
2175         res = test81(va, vaB, testValue1, false, false);
2176         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2177         Asserts.assertEquals(res, testValue1.hash());
2178         res = test81(va, va, testValue1, false, true);
2179         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2180         Asserts.assertEquals(res, testValue1.hash());
2181     }
2182 
2183     // Same as test81 but more cases and null writes
2184     @Test()
2185     public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {
2186         MyValue1.ref[] result = null;
2187         if (i == 0) {
2188             result = va1;
2189         } else if (i == 1) {
2190             result = va2;
2191         } else if (i == 2) {
2192             result = new MyValue1.ref[2];
2193             result[1] = vt1;
2194         } else if (i == 3) {
2195             result = new MyValue1[2];
2196             result[1] = vt1;
2197         }
2198         try {
2199             result[0] = (i &lt;= 1) ? null : vt2;
2200             if (shouldThrow) {
2201                 throw new RuntimeException(&quot;NullPointerException expected&quot;);
2202             }
2203         } catch (NullPointerException npe) {
2204             Asserts.assertTrue(shouldThrow, &quot;NullPointerException thrown&quot;);
2205         }
2206         result[0] = vt1;
2207         return result[1].hash();
2208     }
2209 
2210     @DontCompile
2211     public void test82_verifier(boolean warmup) {
2212         MyValue1[] va = new MyValue1[2];
2213         MyValue1.ref[] vaB = new MyValue1.ref[2];
2214         va[1] = testValue1;
2215         vaB[1] = testValue1;
2216         long res = test82(va, vaB, testValue1, testValue1, 0, true);
2217         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2218         Asserts.assertEquals(res, testValue1.hash());
2219         res = test82(va, vaB, testValue1, testValue1, 1, false);
2220         Asserts.assertEquals(vaB[0].hash(), testValue1.hash());
2221         Asserts.assertEquals(res, testValue1.hash());
2222         res = test82(va, va, testValue1, testValue1, 1, true);
2223         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2224         Asserts.assertEquals(res, testValue1.hash());
2225         res = test82(va, va, testValue1, null, 2, false);
2226         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2227         Asserts.assertEquals(res, testValue1.hash());
2228         res = test82(va, va, testValue1, null, 3, true);
2229         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2230         Asserts.assertEquals(res, testValue1.hash());
2231     }
2232 
2233     @Test(failOn = ALLOC + ALLOCA + STORE)
2234     public static long test83(MyValue1[] va) {
2235         MyValue1.ref[] result = va;
2236         return result[0].hash();
2237     }
2238 
2239     @DontCompile
2240     public void test83_verifier(boolean warmup) {
2241         MyValue1[] va = new MyValue1[42];
2242         va[0] = testValue1;
2243         long res = test83(va);
2244         Asserts.assertEquals(res, testValue1.hash());
2245     }
2246 
2247     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
2248     @Test(valid = InlineTypeArrayFlattenOff)
2249     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2250         MyValue1.ref[] result = new MyValue1[2];
2251         result[0] = vt1;
2252         result[1] = vt2;
2253         return result;
2254     }
2255 
2256     @DontCompile
2257     public void test84_verifier(boolean warmup) {
2258         MyValue1.ref[] res = test84(testValue1, testValue1);
2259         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2260         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2261         try {
2262             test84(testValue1, null);
2263             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2264         } catch (NullPointerException npe) {
2265             // Expected
2266         }
2267     }
2268 
2269     @Test()
2270     public static long test85(MyValue1.ref[] va, MyValue1 val) {
2271         va[0] = val;
2272         return va[1].hash();
2273     }
2274 
2275     @DontCompile
2276     public void test85_verifier(boolean warmup) {
2277         MyValue1[] va = new MyValue1[2];
2278         MyValue1.ref[] vab = new MyValue1.ref[2];
2279         va[1] = testValue1;
2280         vab[1] = testValue1;
2281         long res = test85(va, testValue1);
2282         Asserts.assertEquals(res, testValue1.hash());
2283         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2284         res = test85(vab, testValue1);
2285         Asserts.assertEquals(res, testValue1.hash());
2286         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2287     }
2288 
2289     // Same as test85 but with ref value
2290     @Test()
2291     public static long test86(MyValue1.ref[] va, MyValue1.ref val) {
2292         va[0] = val;
2293         return va[1].hash();
2294     }
2295 
2296     @DontCompile
2297     public void test86_verifier(boolean warmup) {
2298         MyValue1[] va = new MyValue1[2];
2299         MyValue1.ref[] vab = new MyValue1.ref[2];
2300         va[1] = testValue1;
2301         vab[1] = testValue1;
2302         long res = test86(va, testValue1);
2303         Asserts.assertEquals(res, testValue1.hash());
2304         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2305         try {
2306             test86(va, null);
2307             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2308         } catch (NullPointerException npe) {
2309             // Expected
2310         }
2311         res = test86(vab, testValue1);
2312         Asserts.assertEquals(res, testValue1.hash());
2313         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2314         res = test86(vab, null);
2315         Asserts.assertEquals(res, testValue1.hash());
2316         Asserts.assertEquals(vab[0], null);
2317     }
2318 
2319     // Test initialization of nullable array with constant
2320     @Test()
2321     public long test87() {
2322         MyValue1.ref[] va = new MyValue1.ref[1];
2323         va[0] = testValue1;
2324         return va[0].hash();
2325     }
2326 
2327     @DontCompile
2328     public void test87_verifier(boolean warmup) {
2329         long result = test87();
2330         Asserts.assertEQ(result, hash());
2331     }
2332 
2333     // Test narrowing conversion from [L to [Q
2334     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2335     public static MyValue1[] test88(MyValue1.ref[] va) {
2336         return (MyValue1[])va;
2337     }
2338 
2339     @DontCompile
2340     public void test88_verifier(boolean warmup) {
2341         MyValue1[] va = new MyValue1[1];
2342         va[0] = testValue1;
2343         MyValue1[] res = test88(va);
2344         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2345         res[0] = testValue1;
2346         test88(null); // Should not throw NPE
2347         try {
2348             test88(new MyValue1.ref[1]);
2349             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2350         } catch (ClassCastException cce) {
2351             // Expected
2352         }
2353     }
2354 
2355     // Same as test88 but with explicit cast and Object argument
2356     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
2357     public static MyValue1[] test89(Object[] va) {
2358         return (MyValue1[])va;
2359     }
2360 
2361     @DontCompile
2362     public void test89_verifier(boolean warmup) {
2363         MyValue1[] va = new MyValue1[1];
2364         va[0] = testValue1;
2365         MyValue1[] res = test89(va);
2366         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
2367         res[0] = testValue1;
2368         test89(null); // Should not throw NPE
2369         try {
2370             test89(new MyValue1.ref[1]);
2371             throw new RuntimeException(&quot;ClassCastException expected&quot;);
2372         } catch (ClassCastException cce) {
2373             // Expected
2374         }
2375     }
2376 
2377     // More cast tests
2378     @Test()
2379     public static MyValue1.ref[] test90(Object va) {
2380         return (MyValue1.ref[])va;
2381     }
2382 
2383     @DontCompile
2384     public void test90_verifier(boolean warmup) {
2385         MyValue1[] va = new MyValue1[1];
2386         MyValue1.ref[] vab = new MyValue1.ref[1];
2387         try {
2388           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2389           test90(new Integer[0]);
2390         } catch (ClassCastException cce) {
2391           // Expected
2392         }
2393         test90(va);
2394         test90(vab);
2395         test90(null);
2396     }
2397 
2398     @Test()
2399     public static MyValue1.ref[] test91(Object[] va) {
2400         return (MyValue1.ref[])va;
2401     }
2402 
2403     @DontCompile
2404     public void test91_verifier(boolean warmup) {
2405         MyValue1[] va = new MyValue1[1];
2406         MyValue1.ref[] vab = new MyValue1.ref[1];
2407         try {
2408           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
2409           test91(new Integer[0]);
2410         } catch (ClassCastException cce) {
2411           // Expected
2412         }
2413         test91(va);
2414         test91(vab);
2415         test91(null);
2416     }
2417 
2418     // Test if arraycopy intrinsic correctly checks for flattened source array
2419     @Test()
2420     public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {
2421         System.arraycopy(src, 0, dst, 0, 2);
2422     }
2423 
2424     @DontCompile
2425     public void test92_verifier(boolean warmup) {
2426         MyValue1[]  va = new MyValue1[2];
2427         MyValue1.ref[] vab = new MyValue1.ref[2];
2428         va[0] = testValue1;
2429         vab[0] = testValue1;
2430         test92(va, vab);
2431         Asserts.assertEquals(va[0], vab[0]);
2432         Asserts.assertEquals(va[1], vab[1]);
2433     }
2434 
2435     @Test()
2436     public static void test93(Object src, MyValue1.ref[] dst) {
2437         System.arraycopy(src, 0, dst, 0, 2);
2438     }
2439 
2440     @DontCompile
2441     public void test93_verifier(boolean warmup) {
2442         MyValue1[]  va = new MyValue1[2];
2443         MyValue1.ref[] vab = new MyValue1.ref[2];
2444         va[0] = testValue1;
2445         vab[0] = testValue1;
2446         test93(va, vab);
2447         Asserts.assertEquals(va[0], vab[0]);
2448         Asserts.assertEquals(va[1], vab[1]);
2449     }
2450 
2451     // Test non-escaping allocation with arraycopy
2452     // that does not modify loaded array element.
2453     @Test()
2454     public static long test94() {
2455         MyValue1.ref[] src = new MyValue1.ref[8];
2456         MyValue1[]  dst = new MyValue1[8];
2457         for (int i = 1; i &lt; 8; ++i) {
2458             src[i] = testValue1;
2459         }
2460         System.arraycopy(src, 1, dst, 2, 6);
2461         return dst[0].hash();
2462     }
2463 
2464     @DontCompile
2465     public static void test94_verifier(boolean warmup) {
2466         long result = test94();
2467         Asserts.assertEquals(result, MyValue1.default.hash());
2468     }
2469 
2470     // Test meeting constant TypeInstPtr with InlineTypeNode
2471     @ForceInline
2472     public long test95_callee() {
2473         MyValue1.ref[] va = new MyValue1.ref[1];
2474         va[0] = testValue1;
2475         return va[0].hashInterpreted();
2476     }
2477 
2478     @Test()
2479     @Warmup(0)
2480     public long test95() {
2481         return test95_callee();
2482     }
2483 
2484     @DontCompile
2485     public void test95_verifier(boolean warmup) {
2486         long result = test95();
2487         Asserts.assertEQ(result, hash());
2488     }
2489 
2490     // Matrix multiplication test to exercise type flow analysis with nullable inline type arrays
2491     inline static class Complex {
2492         private final double re;
2493         private final double im;
2494 
2495         Complex(double re, double im) {
2496             this.re = re;
2497             this.im = im;
2498         }
2499 
2500         public Complex add(Complex that) {
2501             return new Complex(this.re + that.re, this.im + that.im);
2502         }
2503 
2504         public Complex mul(Complex that) {
2505             return new Complex(this.re * that.re - this.im * that.im,
2506                                this.re * that.im + this.im * that.re);
2507         }
2508     }
2509 
2510     @Test()
2511     public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {
2512         int size = A.length;
2513         Complex.ref[][] R = new Complex.ref[size][size];
2514         for (int i = 0; i &lt; size; i++) {
2515             for (int k = 0; k &lt; size; k++) {
2516                 Complex.ref aik = A[i][k];
2517                 for (int j = 0; j &lt; size; j++) {
2518                     R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
2519                 }
2520             }
2521         }
2522         return R;
2523     }
2524 
2525     static Complex.ref[][] test96_A = new Complex.ref[10][10];
2526     static Complex.ref[][] test96_B = new Complex.ref[10][10];
2527     static Complex.ref[][] test96_R;
2528 
2529     static {
2530         for (int i = 0; i &lt; 10; i++) {
2531             for (int j = 0; j &lt; 10; j++) {
2532                 test96_A[i][j] = new Complex(rI, rI);
2533                 test96_B[i][j] = new Complex(rI, rI);
2534             }
2535         }
2536     }
2537 
2538     @DontCompile
2539     public void test96_verifier(boolean warmup) {
2540         Complex.ref[][] result = test96(test96_A, test96_B);
2541         if (test96_R == null) {
2542             test96_R = result;
2543         }
2544         for (int i = 0; i &lt; 10; i++) {
2545             for (int j = 0; j &lt; 10; j++) {
2546                 Asserts.assertEQ(result[i][j], test96_R[i][j]);
2547             }
2548         }
2549     }
2550 
2551     // Test loads from vararg arrays
2552     @Test(failOn = LOAD_UNKNOWN_INLINE)
2553     public static Object test97(Object... args) {
2554         return args[0];
2555     }
2556 
2557     @DontCompile
2558     public static void test97_verifier(boolean warmup) {
2559         Object obj = new Object();
2560         Object result = test97(obj);
2561         Asserts.assertEquals(result, obj);
2562         Integer[] myInt = new Integer[1];
2563         myInt[0] = rI;
2564         result = test97((Object[])myInt);
2565         Asserts.assertEquals(result, rI);
2566     }
2567 
2568     @Test()
2569     public static Object test98(Object... args) {
2570         return args[0];
2571     }
2572 
2573     @DontCompile
2574     public static void test98_verifier(boolean warmup) {
2575         Object obj = new Object();
2576         Object result = test98(obj);
2577         Asserts.assertEquals(result, obj);
2578         Integer[] myInt = new Integer[1];
2579         myInt[0] = rI;
2580         result = test98((Object[])myInt);
2581         Asserts.assertEquals(result, rI);
2582         if (!warmup) {
2583             MyValue1[] va = new MyValue1[1];
2584             MyValue1.ref[] vab = new MyValue1.ref[1];
2585             result = test98((Object[])va);
2586             Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
2587             result = test98((Object[])vab);
2588             Asserts.assertEquals(result, null);
2589         }
2590     }
2591 
2592     @Test()
2593     public static Object test99(Object... args) {
2594         return args[0];
2595     }
2596 
2597     @DontCompile
2598     public static void test99_verifier(boolean warmup) {
2599         Object obj = new Object();
2600         Object result = test99(obj);
2601         Asserts.assertEquals(result, obj);
2602         Integer[] myInt = new Integer[1];
2603         myInt[0] = rI;
2604         result = test99((Object[])myInt);
2605         Asserts.assertEquals(result, rI);
2606         if (!warmup) {
2607             try {
2608                 test99((Object[])null);
2609                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2610             } catch (NullPointerException npe) {
2611                 // Expected
2612             }
2613         }
2614     }
2615 
2616     @Test()
2617     public static Object test100(Object... args) {
2618         return args[0];
2619     }
2620 
2621     @DontCompile
2622     public static void test100_verifier(boolean warmup) {
2623         Object obj = new Object();
2624         Object result = test100(obj);
2625         Asserts.assertEquals(result, obj);
2626         Integer[] myInt = new Integer[1];
2627         myInt[0] = rI;
2628         result = test100((Object[])myInt);
2629         Asserts.assertEquals(result, rI);
2630         if (!warmup) {
2631             try {
2632                 test100();
2633                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2634             } catch (ArrayIndexOutOfBoundsException aioobe) {
2635                 // Expected
2636             }
2637         }
2638     }
2639 
2640     // Test stores to varag arrays
2641     @Test(failOn = STORE_UNKNOWN_INLINE)
2642     public static void test101(Object val, Object... args) {
2643         args[0] = val;
2644     }
2645 
2646     @DontCompile
2647     public static void test101_verifier(boolean warmup) {
2648         Object obj = new Object();
2649         test101(obj, obj);
2650         Integer[] myInt = new Integer[1];
2651         test101(rI, (Object[])myInt);
2652         Asserts.assertEquals(myInt[0], rI);
2653         test101(null, (Object[])myInt);
2654         Asserts.assertEquals(myInt[0], null);
2655     }
2656 
2657     @Test()
2658     public static void test102(Object val, Object... args) {
2659         args[0] = val;
2660     }
2661 
2662     @DontCompile
2663     public static void test102_verifier(boolean warmup) {
2664         Object obj = new Object();
2665         test102(obj, obj);
2666         Integer[] myInt = new Integer[1];
2667         test102(rI, (Object[])myInt);
2668         Asserts.assertEquals(myInt[0], rI);
2669         test102(null, (Object[])myInt);
2670         Asserts.assertEquals(myInt[0], null);
2671         if (!warmup) {
2672             MyValue1[] va = new MyValue1[1];
2673             MyValue1.ref[] vab = new MyValue1.ref[1];
2674             test102(testValue1, (Object[])va);
2675             Asserts.assertEquals(va[0].hash(), testValue1.hash());
2676             test102(testValue1, (Object[])vab);
2677             Asserts.assertEquals(vab[0].hash(), testValue1.hash());
2678             test102(null, (Object[])vab);
2679             Asserts.assertEquals(vab[0], null);
2680         }
2681     }
2682 
2683     @Test()
2684     public static void test103(Object val, Object... args) {
2685         args[0] = val;
2686     }
2687 
2688     @DontCompile
2689     public static void test103_verifier(boolean warmup) {
2690         Object obj = new Object();
2691         test103(obj, obj);
2692         Integer[] myInt = new Integer[1];
2693         test103(rI, (Object[])myInt);
2694         Asserts.assertEquals(myInt[0], rI);
2695         test103(null, (Object[])myInt);
2696         Asserts.assertEquals(myInt[0], null);
2697         if (!warmup) {
2698             MyValue1[] va = new MyValue1[1];
2699             try {
2700                 test103(null, (Object[])va);
2701                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2702             } catch (NullPointerException npe) {
2703                 // Expected
2704             }
2705         }
2706     }
2707 
2708     @Test()
2709     public static void test104(Object val, Object... args) {
2710         args[0] = val;
2711     }
2712 
2713     @DontCompile
2714     public static void test104_verifier(boolean warmup) {
2715         Object obj = new Object();
2716         test104(obj, obj);
2717         Integer[] myInt = new Integer[1];
2718         test104(rI, (Object[])myInt);
2719         Asserts.assertEquals(myInt[0], rI);
2720         test104(null, (Object[])myInt);
2721         Asserts.assertEquals(myInt[0], null);
2722         if (!warmup) {
2723             try {
2724                 test104(testValue1);
2725                 throw new RuntimeException(&quot;No AIOOBE thrown&quot;);
2726             } catch (ArrayIndexOutOfBoundsException aioobe) {
2727                 // Expected
2728             }
2729         }
2730     }
2731 
2732     @Test()
2733     public static void test105(Object val, Object... args) {
2734         args[0] = val;
2735     }
2736 
2737     @DontCompile
2738     public static void test105_verifier(boolean warmup) {
2739         Object obj = new Object();
2740         test105(obj, obj);
2741         Integer[] myInt = new Integer[1];
2742         test105(rI, (Object[])myInt);
2743         Asserts.assertEquals(myInt[0], rI);
2744         test105(null, (Object[])myInt);
2745         Asserts.assertEquals(myInt[0], null);
2746         if (!warmup) {
2747             try {
2748                 test105(testValue1, (Object[])null);
2749                 throw new RuntimeException(&quot;No NPE thrown&quot;);
2750             } catch (NullPointerException npe) {
2751                 // Expected
2752             }
2753         }
2754     }
2755 
2756     @Test()
2757     public static Object[] test106(Object[] dst, Object... args) {
2758         // Access array to speculate on non-flatness
2759         if (args[0] == null) {
2760             args[0] = testValue1;
2761         }
2762         System.arraycopy(args, 0, dst, 0, args.length);
2763         System.arraycopy(dst, 0, args, 0, dst.length);
2764         Object[] clone = args.clone();
2765         if (clone[0] == null) {
2766             throw new RuntimeException(&quot;Unexpected null&quot;);
2767         }
2768         return Arrays.copyOf(args, args.length, Object[].class);
2769     }
2770 
2771     @DontCompile
2772     public static void test106_verifier(boolean warmup) {
2773         Object[] dst = new Object[1];
2774         Object obj = new Object();
2775         Object[] result = test106(dst, obj);
2776         Asserts.assertEquals(result[0], obj);
2777         Integer[] myInt = new Integer[1];
2778         myInt[0] = rI;
2779         result = test106(myInt, (Object[])myInt);
2780         Asserts.assertEquals(result[0], rI);
2781         if (!warmup) {
2782             MyValue1[] va = new MyValue1[1];
2783             MyValue1.ref[] vab = new MyValue1.ref[1];
2784             result = test106(va, (Object[])va);
2785             Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
2786             result = test106(vab, (Object[])vab);
2787             Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
2788         }
2789     }
2790 
2791     // Test that allocation is not replaced by non-dominating allocation
2792     public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {
2793         try {
2794             va[0] = vt;
2795         } catch (NullPointerException npe) { }
2796         return va[1].hash();
2797     }
2798 
2799     @Test()
2800     public void test107() {
2801         MyValue1[] va = new MyValue1[2];
2802         MyValue1.ref[] tmp = new MyValue1.ref[2];
2803         long res1 = test107_helper(va, testValue1);
2804         long res2 = test107_helper(va, testValue1);
2805         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2806         Asserts.assertEquals(res1, MyValue1.default.hash());
2807         Asserts.assertEquals(res2, MyValue1.default.hash());
2808     }
2809 
2810     @DontCompile
2811     public void test107_verifier(boolean warmup) {
2812         test107();
2813     }
2814 
2815 
2816     @Test
2817     @Warmup(10000)
2818     public Object test108(MyValue1.ref[] src, boolean flag) {
2819         MyValue1.ref[] dst = new MyValue1.ref[8];
2820         System.arraycopy(src, 1, dst, 2, 6);
2821         if (flag) {} // uncommon trap
2822         return dst[2];
2823     }
2824 
2825     @DontCompile
2826     public void test108_verifier(boolean warmup) {
2827         MyValue1.ref[] src = new MyValue1.ref[8];
2828         test108(src, !warmup);
2829     }
2830 
2831 }
    </pre>
  </body>
</html>