<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/os/windows/os_windows.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce
  26 #define _WIN32_WINNT 0x0600
  27 
  28 // no precompiled headers
  29 #include &quot;jvm.h&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/vtableStubs.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;compiler/disassembler.hpp&quot;
  37 #include &quot;interpreter/interpreter.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/filemap.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;os_share_windows.hpp&quot;
  44 #include &quot;os_windows.inline.hpp&quot;
  45 #include &quot;prims/jniFastGetField.hpp&quot;
  46 #include &quot;prims/jvm_misc.hpp&quot;
  47 #include &quot;runtime/arguments.hpp&quot;
  48 #include &quot;runtime/atomic.hpp&quot;
  49 #include &quot;runtime/extendedPC.hpp&quot;
  50 #include &quot;runtime/globals.hpp&quot;
  51 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
  56 #include &quot;runtime/orderAccess.hpp&quot;
  57 #include &quot;runtime/osThread.hpp&quot;
  58 #include &quot;runtime/perfMemory.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;runtime/statSampler.hpp&quot;
  61 #include &quot;runtime/stubRoutines.hpp&quot;
  62 #include &quot;runtime/thread.inline.hpp&quot;
  63 #include &quot;runtime/threadCritical.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;services/attachListener.hpp&quot;
  67 #include &quot;services/memTracker.hpp&quot;
  68 #include &quot;services/runtimeService.hpp&quot;
  69 #include &quot;utilities/align.hpp&quot;
  70 #include &quot;utilities/decoder.hpp&quot;
  71 #include &quot;utilities/defaultStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/growableArray.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/vmError.hpp&quot;
  76 #include &quot;symbolengine.hpp&quot;
  77 #include &quot;windbghelp.hpp&quot;
  78 
  79 
  80 #ifdef _DEBUG
  81 #include &lt;crtdbg.h&gt;
  82 #endif
  83 
  84 
  85 #include &lt;windows.h&gt;
  86 #include &lt;sys/types.h&gt;
  87 #include &lt;sys/stat.h&gt;
  88 #include &lt;sys/timeb.h&gt;
  89 #include &lt;objidl.h&gt;
  90 #include &lt;shlobj.h&gt;
  91 
  92 #include &lt;malloc.h&gt;
  93 #include &lt;signal.h&gt;
  94 #include &lt;direct.h&gt;
  95 #include &lt;errno.h&gt;
  96 #include &lt;fcntl.h&gt;
  97 #include &lt;io.h&gt;
  98 #include &lt;process.h&gt;              // For _beginthreadex(), _endthreadex()
  99 #include &lt;imagehlp.h&gt;             // For os::dll_address_to_function_name
 100 // for enumerating dll libraries
 101 #include &lt;vdmdbg.h&gt;
 102 #include &lt;psapi.h&gt;
 103 #include &lt;mmsystem.h&gt;
 104 #include &lt;winsock2.h&gt;
 105 
 106 // for timer info max values which include all bits
 107 #define ALL_64_BITS CONST64(-1)
 108 
 109 // For DLL loading/load error detection
 110 // Values of PE COFF
 111 #define IMAGE_FILE_PTR_TO_SIGNATURE 0x3c
 112 #define IMAGE_FILE_SIGNATURE_LENGTH 4
 113 
 114 static HANDLE main_process;
 115 static HANDLE main_thread;
 116 static int    main_thread_id;
 117 
 118 static FILETIME process_creation_time;
 119 static FILETIME process_exit_time;
 120 static FILETIME process_user_time;
 121 static FILETIME process_kernel_time;
 122 
 123 #ifdef _M_AMD64
 124   #define __CPU__ amd64
 125 #else
 126   #define __CPU__ i486
 127 #endif
 128 
 129 #if INCLUDE_AOT
 130 PVOID  topLevelVectoredExceptionHandler = NULL;
 131 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);
 132 #endif
 133 
 134 // save DLL module handle, used by GetModuleFileName
 135 
 136 HINSTANCE vm_lib_handle;
 137 
 138 BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
 139   switch (reason) {
 140   case DLL_PROCESS_ATTACH:
 141     vm_lib_handle = hinst;
 142     if (ForceTimeHighResolution) {
 143       timeBeginPeriod(1L);
 144     }
 145     WindowsDbgHelp::pre_initialize();
 146     SymbolEngine::pre_initialize();
 147     break;
 148   case DLL_PROCESS_DETACH:
 149     if (ForceTimeHighResolution) {
 150       timeEndPeriod(1L);
 151     }
 152 #if INCLUDE_AOT
 153     if (topLevelVectoredExceptionHandler != NULL) {
 154       RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);
 155       topLevelVectoredExceptionHandler = NULL;
 156     }
 157 #endif
 158     break;
 159   default:
 160     break;
 161   }
 162   return true;
 163 }
 164 
 165 static inline double fileTimeAsDouble(FILETIME* time) {
 166   const double high  = (double) ((unsigned int) ~0);
 167   const double split = 10000000.0;
 168   double result = (time-&gt;dwLowDateTime / split) +
 169                    time-&gt;dwHighDateTime * (high/split);
 170   return result;
 171 }
 172 
 173 // Implementation of os
 174 
 175 bool os::unsetenv(const char* name) {
 176   assert(name != NULL, &quot;Null pointer&quot;);
 177   return (SetEnvironmentVariable(name, NULL) == TRUE);
 178 }
 179 
 180 // No setuid programs under Windows.
 181 bool os::have_special_privileges() {
 182   return false;
 183 }
 184 
 185 
 186 // This method is  a periodic task to check for misbehaving JNI applications
 187 // under CheckJNI, we can add any periodic checks here.
 188 // For Windows at the moment does nothing
 189 void os::run_periodic_checks() {
 190   return;
 191 }
 192 
 193 // previous UnhandledExceptionFilter, if there is one
 194 static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = NULL;
 195 
 196 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);
 197 
 198 void os::init_system_properties_values() {
 199   // sysclasspath, java_home, dll_dir
 200   {
 201     char *home_path;
 202     char *dll_path;
 203     char *pslash;
 204     const char *bin = &quot;\\bin&quot;;
 205     char home_dir[MAX_PATH + 1];
 206     char *alt_home_dir = ::getenv(&quot;_ALT_JAVA_HOME_DIR&quot;);
 207 
 208     if (alt_home_dir != NULL)  {
 209       strncpy(home_dir, alt_home_dir, MAX_PATH + 1);
 210       home_dir[MAX_PATH] = &#39;\0&#39;;
 211     } else {
 212       os::jvm_path(home_dir, sizeof(home_dir));
 213       // Found the full path to jvm.dll.
 214       // Now cut the path to &lt;java_home&gt;/jre if we can.
 215       *(strrchr(home_dir, &#39;\\&#39;)) = &#39;\0&#39;;  // get rid of \jvm.dll
 216       pslash = strrchr(home_dir, &#39;\\&#39;);
 217       if (pslash != NULL) {
 218         *pslash = &#39;\0&#39;;                   // get rid of \{client|server}
 219         pslash = strrchr(home_dir, &#39;\\&#39;);
 220         if (pslash != NULL) {
 221           *pslash = &#39;\0&#39;;                 // get rid of \bin
 222         }
 223       }
 224     }
 225 
 226     home_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + 1, mtInternal);
 227     strcpy(home_path, home_dir);
 228     Arguments::set_java_home(home_path);
 229     FREE_C_HEAP_ARRAY(char, home_path);
 230 
 231     dll_path = NEW_C_HEAP_ARRAY(char, strlen(home_dir) + strlen(bin) + 1,
 232                                 mtInternal);
 233     strcpy(dll_path, home_dir);
 234     strcat(dll_path, bin);
 235     Arguments::set_dll_dir(dll_path);
 236     FREE_C_HEAP_ARRAY(char, dll_path);
 237 
 238     if (!set_boot_path(&#39;\\&#39;, &#39;;&#39;)) {
 239       vm_exit_during_initialization(&quot;Failed setting boot class path.&quot;, NULL);
 240     }
 241   }
 242 
 243 // library_path
 244 #define EXT_DIR &quot;\\lib\\ext&quot;
 245 #define BIN_DIR &quot;\\bin&quot;
 246 #define PACKAGE_DIR &quot;\\Sun\\Java&quot;
 247   {
 248     // Win32 library search order (See the documentation for LoadLibrary):
 249     //
 250     // 1. The directory from which application is loaded.
 251     // 2. The system wide Java Extensions directory (Java only)
 252     // 3. System directory (GetSystemDirectory)
 253     // 4. Windows directory (GetWindowsDirectory)
 254     // 5. The PATH environment variable
 255     // 6. The current directory
 256 
 257     char *library_path;
 258     char tmp[MAX_PATH];
 259     char *path_str = ::getenv(&quot;PATH&quot;);
 260 
 261     library_path = NEW_C_HEAP_ARRAY(char, MAX_PATH * 5 + sizeof(PACKAGE_DIR) +
 262                                     sizeof(BIN_DIR) + (path_str ? strlen(path_str) : 0) + 10, mtInternal);
 263 
 264     library_path[0] = &#39;\0&#39;;
 265 
 266     GetModuleFileName(NULL, tmp, sizeof(tmp));
 267     *(strrchr(tmp, &#39;\\&#39;)) = &#39;\0&#39;;
 268     strcat(library_path, tmp);
 269 
 270     GetWindowsDirectory(tmp, sizeof(tmp));
 271     strcat(library_path, &quot;;&quot;);
 272     strcat(library_path, tmp);
 273     strcat(library_path, PACKAGE_DIR BIN_DIR);
 274 
 275     GetSystemDirectory(tmp, sizeof(tmp));
 276     strcat(library_path, &quot;;&quot;);
 277     strcat(library_path, tmp);
 278 
 279     GetWindowsDirectory(tmp, sizeof(tmp));
 280     strcat(library_path, &quot;;&quot;);
 281     strcat(library_path, tmp);
 282 
 283     if (path_str) {
 284       strcat(library_path, &quot;;&quot;);
 285       strcat(library_path, path_str);
 286     }
 287 
 288     strcat(library_path, &quot;;.&quot;);
 289 
 290     Arguments::set_library_path(library_path);
 291     FREE_C_HEAP_ARRAY(char, library_path);
 292   }
 293 
 294   // Default extensions directory
 295   {
 296     char path[MAX_PATH];
 297     char buf[2 * MAX_PATH + 2 * sizeof(EXT_DIR) + sizeof(PACKAGE_DIR) + 1];
 298     GetWindowsDirectory(path, MAX_PATH);
 299     sprintf(buf, &quot;%s%s;%s%s%s&quot;, Arguments::get_java_home(), EXT_DIR,
 300             path, PACKAGE_DIR, EXT_DIR);
 301     Arguments::set_ext_dirs(buf);
 302   }
 303   #undef EXT_DIR
 304   #undef BIN_DIR
 305   #undef PACKAGE_DIR
 306 
 307 #ifndef _WIN64
 308   // set our UnhandledExceptionFilter and save any previous one
 309   prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);
 310 #endif
 311 
 312   // Done
 313   return;
 314 }
 315 
 316 void os::breakpoint() {
 317   DebugBreak();
 318 }
 319 
 320 // Invoked from the BREAKPOINT Macro
 321 extern &quot;C&quot; void breakpoint() {
 322   os::breakpoint();
 323 }
 324 
 325 // RtlCaptureStackBackTrace Windows API may not exist prior to Windows XP.
 326 // So far, this method is only used by Native Memory Tracking, which is
 327 // only supported on Windows XP or later.
 328 //
 329 int os::get_native_stack(address* stack, int frames, int toSkip) {
 330   int captured = RtlCaptureStackBackTrace(toSkip + 1, frames, (PVOID*)stack, NULL);
 331   for (int index = captured; index &lt; frames; index ++) {
 332     stack[index] = NULL;
 333   }
 334   return captured;
 335 }
 336 
 337 
 338 // os::current_stack_base()
 339 //
 340 //   Returns the base of the stack, which is the stack&#39;s
 341 //   starting address.  This function must be called
 342 //   while running on the stack of the thread being queried.
 343 
 344 address os::current_stack_base() {
 345   MEMORY_BASIC_INFORMATION minfo;
 346   address stack_bottom;
 347   size_t stack_size;
 348 
 349   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 350   stack_bottom =  (address)minfo.AllocationBase;
 351   stack_size = minfo.RegionSize;
 352 
 353   // Add up the sizes of all the regions with the same
 354   // AllocationBase.
 355   while (1) {
 356     VirtualQuery(stack_bottom+stack_size, &amp;minfo, sizeof(minfo));
 357     if (stack_bottom == (address)minfo.AllocationBase) {
 358       stack_size += minfo.RegionSize;
 359     } else {
 360       break;
 361     }
 362   }
 363   return stack_bottom + stack_size;
 364 }
 365 
 366 size_t os::current_stack_size() {
 367   size_t sz;
 368   MEMORY_BASIC_INFORMATION minfo;
 369   VirtualQuery(&amp;minfo, &amp;minfo, sizeof(minfo));
 370   sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;
 371   return sz;
 372 }
 373 
 374 bool os::committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size) {
 375   MEMORY_BASIC_INFORMATION minfo;
 376   committed_start = NULL;
 377   committed_size = 0;
 378   address top = start + size;
 379   const address start_addr = start;
 380   while (start &lt; top) {
 381     VirtualQuery(start, &amp;minfo, sizeof(minfo));
 382     if ((minfo.State &amp; MEM_COMMIT) == 0) {  // not committed
 383       if (committed_start != NULL) {
 384         break;
 385       }
 386     } else {  // committed
 387       if (committed_start == NULL) {
 388         committed_start = start;
 389       }
 390       size_t offset = start - (address)minfo.BaseAddress;
 391       committed_size += minfo.RegionSize - offset;
 392     }
 393     start = (address)minfo.BaseAddress + minfo.RegionSize;
 394   }
 395 
 396   if (committed_start == NULL) {
 397     assert(committed_size == 0, &quot;Sanity&quot;);
 398     return false;
 399   } else {
 400     assert(committed_start &gt;= start_addr &amp;&amp; committed_start &lt; top, &quot;Out of range&quot;);
 401     // current region may go beyond the limit, trim to the limit
 402     committed_size = MIN2(committed_size, size_t(top - committed_start));
 403     return true;
 404   }
 405 }
 406 
 407 struct tm* os::localtime_pd(const time_t* clock, struct tm* res) {
 408   const struct tm* time_struct_ptr = localtime(clock);
 409   if (time_struct_ptr != NULL) {
 410     *res = *time_struct_ptr;
 411     return res;
 412   }
 413   return NULL;
 414 }
 415 
 416 struct tm* os::gmtime_pd(const time_t* clock, struct tm* res) {
 417   const struct tm* time_struct_ptr = gmtime(clock);
 418   if (time_struct_ptr != NULL) {
 419     *res = *time_struct_ptr;
 420     return res;
 421   }
 422   return NULL;
 423 }
 424 
 425 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo);
 426 
 427 // Thread start routine for all newly created threads
 428 static unsigned __stdcall thread_native_entry(Thread* thread) {
 429 
 430   thread-&gt;record_stack_base_and_size();
 431 
 432   // Try to randomize the cache line index of hot stack frames.
 433   // This helps when threads of the same stack traces evict each other&#39;s
 434   // cache lines. The threads can be either from the same JVM instance, or
 435   // from different JVM instances. The benefit is especially true for
 436   // processors with hyperthreading technology.
 437   static int counter = 0;
 438   int pid = os::current_process_id();
 439   _alloca(((pid ^ counter++) &amp; 7) * 128);
 440 
 441   thread-&gt;initialize_thread_current();
 442 
 443   OSThread* osthr = thread-&gt;osthread();
 444   assert(osthr-&gt;get_state() == RUNNABLE, &quot;invalid os thread state&quot;);
 445 
 446   if (UseNUMA) {
 447     int lgrp_id = os::numa_get_group_id();
 448     if (lgrp_id != -1) {
 449       thread-&gt;set_lgrp_id(lgrp_id);
 450     }
 451   }
 452 
 453   // Diagnostic code to investigate JDK-6573254
 454   int res = 30115;  // non-java thread
 455   if (thread-&gt;is_Java_thread()) {
 456     res = 20115;    // java thread
 457   }
 458 
 459   log_info(os, thread)(&quot;Thread is alive (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 460 
 461   // Install a win32 structured exception handler around every thread created
 462   // by VM, so VM can generate error dump when an exception occurred in non-
 463   // Java thread (e.g. VM thread).
 464   __try {
 465     thread-&gt;call_run();
 466   } __except(topLevelExceptionFilter(
 467                                      (_EXCEPTION_POINTERS*)_exception_info())) {
 468     // Nothing to do.
 469   }
 470 
 471   // Note: at this point the thread object may already have deleted itself.
 472   // Do not dereference it from here on out.
 473 
 474   log_info(os, thread)(&quot;Thread finished (tid: &quot; UINTX_FORMAT &quot;).&quot;, os::current_thread_id());
 475 
 476   // One less thread is executing
 477   // When the VMThread gets here, the main thread may have already exited
 478   // which frees the CodeHeap containing the Atomic::add code
 479   if (thread != VMThread::vm_thread() &amp;&amp; VMThread::vm_thread() != NULL) {
 480     Atomic::dec(&amp;os::win32::_os_thread_count);
 481   }
 482 
 483   // Thread must not return from exit_process_or_thread(), but if it does,
 484   // let it proceed to exit normally
 485   return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);
 486 }
 487 
 488 static OSThread* create_os_thread(Thread* thread, HANDLE thread_handle,
 489                                   int thread_id) {
 490   // Allocate the OSThread object
 491   OSThread* osthread = new OSThread(NULL, NULL);
 492   if (osthread == NULL) return NULL;
 493 
 494   // Initialize the JDK library&#39;s interrupt event.
 495   // This should really be done when OSThread is constructed,
 496   // but there is no way for a constructor to report failure to
 497   // allocate the event.
 498   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 499   if (interrupt_event == NULL) {
 500     delete osthread;
 501     return NULL;
 502   }
 503   osthread-&gt;set_interrupt_event(interrupt_event);
 504 
 505   // Store info on the Win32 thread into the OSThread
 506   osthread-&gt;set_thread_handle(thread_handle);
 507   osthread-&gt;set_thread_id(thread_id);
 508 
 509   if (UseNUMA) {
 510     int lgrp_id = os::numa_get_group_id();
 511     if (lgrp_id != -1) {
 512       thread-&gt;set_lgrp_id(lgrp_id);
 513     }
 514   }
 515 
 516   // Initial thread state is INITIALIZED, not SUSPENDED
 517   osthread-&gt;set_state(INITIALIZED);
 518 
 519   return osthread;
 520 }
 521 
 522 
 523 bool os::create_attached_thread(JavaThread* thread) {
 524 #ifdef ASSERT
 525   thread-&gt;verify_not_published();
 526 #endif
 527   HANDLE thread_h;
 528   if (!DuplicateHandle(main_process, GetCurrentThread(), GetCurrentProcess(),
 529                        &amp;thread_h, THREAD_ALL_ACCESS, false, 0)) {
 530     fatal(&quot;DuplicateHandle failed\n&quot;);
 531   }
 532   OSThread* osthread = create_os_thread(thread, thread_h,
 533                                         (int)current_thread_id());
 534   if (osthread == NULL) {
 535     return false;
 536   }
 537 
 538   // Initial thread state is RUNNABLE
 539   osthread-&gt;set_state(RUNNABLE);
 540 
 541   thread-&gt;set_osthread(osthread);
 542 
 543   log_info(os, thread)(&quot;Thread attached (tid: &quot; UINTX_FORMAT &quot;).&quot;,
 544     os::current_thread_id());
 545 
 546   return true;
 547 }
 548 
 549 bool os::create_main_thread(JavaThread* thread) {
 550 #ifdef ASSERT
 551   thread-&gt;verify_not_published();
 552 #endif
 553   if (_starting_thread == NULL) {
 554     _starting_thread = create_os_thread(thread, main_thread, main_thread_id);
 555     if (_starting_thread == NULL) {
 556       return false;
 557     }
 558   }
 559 
 560   // The primordial thread is runnable from the start)
 561   _starting_thread-&gt;set_state(RUNNABLE);
 562 
 563   thread-&gt;set_osthread(_starting_thread);
 564   return true;
 565 }
 566 
 567 // Helper function to trace _beginthreadex attributes,
 568 //  similar to os::Posix::describe_pthread_attr()
 569 static char* describe_beginthreadex_attributes(char* buf, size_t buflen,
 570                                                size_t stacksize, unsigned initflag) {
 571   stringStream ss(buf, buflen);
 572   if (stacksize == 0) {
 573     ss.print(&quot;stacksize: default, &quot;);
 574   } else {
 575     ss.print(&quot;stacksize: &quot; SIZE_FORMAT &quot;k, &quot;, stacksize / 1024);
 576   }
 577   ss.print(&quot;flags: &quot;);
 578   #define PRINT_FLAG(f) if (initflag &amp; f) ss.print( #f &quot; &quot;);
 579   #define ALL(X) \
 580     X(CREATE_SUSPENDED) \
 581     X(STACK_SIZE_PARAM_IS_A_RESERVATION)
 582   ALL(PRINT_FLAG)
 583   #undef ALL
 584   #undef PRINT_FLAG
 585   return buf;
 586 }
 587 
 588 // Allocate and initialize a new OSThread
 589 bool os::create_thread(Thread* thread, ThreadType thr_type,
 590                        size_t stack_size) {
 591   unsigned thread_id;
 592 
 593   // Allocate the OSThread object
 594   OSThread* osthread = new OSThread(NULL, NULL);
 595   if (osthread == NULL) {
 596     return false;
 597   }
 598 
 599   // Initialize the JDK library&#39;s interrupt event.
 600   // This should really be done when OSThread is constructed,
 601   // but there is no way for a constructor to report failure to
 602   // allocate the event.
 603   HANDLE interrupt_event = CreateEvent(NULL, true, false, NULL);
 604   if (interrupt_event == NULL) {
 605     delete osthread;
 606     return false;
 607   }
 608   osthread-&gt;set_interrupt_event(interrupt_event);
 609   // We don&#39;t call set_interrupted(false) as it will trip the assert in there
 610   // as we are not operating on the current thread. We don&#39;t need to call it
 611   // because the initial state is already correct.
 612 
 613   thread-&gt;set_osthread(osthread);
 614 
 615   if (stack_size == 0) {
 616     switch (thr_type) {
 617     case os::java_thread:
 618       // Java threads use ThreadStackSize which default value can be changed with the flag -Xss
 619       if (JavaThread::stack_size_at_create() &gt; 0) {
 620         stack_size = JavaThread::stack_size_at_create();
 621       }
 622       break;
 623     case os::compiler_thread:
 624       if (CompilerThreadStackSize &gt; 0) {
 625         stack_size = (size_t)(CompilerThreadStackSize * K);
 626         break;
 627       } // else fall through:
 628         // use VMThreadStackSize if CompilerThreadStackSize is not defined
 629     case os::vm_thread:
 630     case os::pgc_thread:
 631     case os::cgc_thread:
 632     case os::watcher_thread:
 633       if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
 634       break;
 635     }
 636   }
 637 
 638   // Create the Win32 thread
 639   //
 640   // Contrary to what MSDN document says, &quot;stack_size&quot; in _beginthreadex()
 641   // does not specify stack size. Instead, it specifies the size of
 642   // initially committed space. The stack size is determined by
 643   // PE header in the executable. If the committed &quot;stack_size&quot; is larger
 644   // than default value in the PE header, the stack is rounded up to the
 645   // nearest multiple of 1MB. For example if the launcher has default
 646   // stack size of 320k, specifying any size less than 320k does not
 647   // affect the actual stack size at all, it only affects the initial
 648   // commitment. On the other hand, specifying &#39;stack_size&#39; larger than
 649   // default value may cause significant increase in memory usage, because
 650   // not only the stack space will be rounded up to MB, but also the
 651   // entire space is committed upfront.
 652   //
 653   // Finally Windows XP added a new flag &#39;STACK_SIZE_PARAM_IS_A_RESERVATION&#39;
 654   // for CreateThread() that can treat &#39;stack_size&#39; as stack size. However we
 655   // are not supposed to call CreateThread() directly according to MSDN
 656   // document because JVM uses C runtime library. The good news is that the
 657   // flag appears to work with _beginthredex() as well.
 658 
 659   const unsigned initflag = CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION;
 660   HANDLE thread_handle =
 661     (HANDLE)_beginthreadex(NULL,
 662                            (unsigned)stack_size,
 663                            (unsigned (__stdcall *)(void*)) thread_native_entry,
 664                            thread,
 665                            initflag,
 666                            &amp;thread_id);
 667 
 668   char buf[64];
 669   if (thread_handle != NULL) {
 670     log_info(os, thread)(&quot;Thread started (tid: %u, attributes: %s)&quot;,
 671       thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 672   } else {
 673     log_warning(os, thread)(&quot;Failed to start thread - _beginthreadex failed (%s) for attributes: %s.&quot;,
 674       os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));
 675     // Log some OS information which might explain why creating the thread failed.
 676     log_info(os, thread)(&quot;Number of threads approx. running in the VM: %d&quot;, Threads::number_of_threads());
 677     LogStream st(Log(os, thread)::info());
 678     os::print_memory_info(&amp;st);
 679   }
 680 
 681   if (thread_handle == NULL) {
 682     // Need to clean up stuff we&#39;ve allocated so far
 683     thread-&gt;set_osthread(NULL);
 684     delete osthread;
 685     return false;
 686   }
 687 
 688   Atomic::inc(&amp;os::win32::_os_thread_count);
 689 
 690   // Store info on the Win32 thread into the OSThread
 691   osthread-&gt;set_thread_handle(thread_handle);
 692   osthread-&gt;set_thread_id(thread_id);
 693 
 694   // Initial thread state is INITIALIZED, not SUSPENDED
 695   osthread-&gt;set_state(INITIALIZED);
 696 
 697   // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain
 698   return true;
 699 }
 700 
 701 
 702 // Free Win32 resources related to the OSThread
 703 void os::free_thread(OSThread* osthread) {
 704   assert(osthread != NULL, &quot;osthread not set&quot;);
 705 
 706   // We are told to free resources of the argument thread,
 707   // but we can only really operate on the current thread.
 708   assert(Thread::current()-&gt;osthread() == osthread,
 709          &quot;os::free_thread but not current thread&quot;);
 710 
 711   CloseHandle(osthread-&gt;thread_handle());
 712   delete osthread;
 713 }
 714 
 715 static jlong first_filetime;
 716 static jlong initial_performance_count;
 717 static jlong performance_frequency;
 718 
 719 
 720 jlong as_long(LARGE_INTEGER x) {
 721   jlong result = 0; // initialization to avoid warning
 722   set_high(&amp;result, x.HighPart);
 723   set_low(&amp;result, x.LowPart);
 724   return result;
 725 }
 726 
 727 
 728 jlong os::elapsed_counter() {
 729   LARGE_INTEGER count;
 730   QueryPerformanceCounter(&amp;count);
 731   return as_long(count) - initial_performance_count;
 732 }
 733 
 734 
 735 jlong os::elapsed_frequency() {
 736   return performance_frequency;
 737 }
 738 
 739 
 740 julong os::available_memory() {
 741   return win32::available_memory();
 742 }
 743 
 744 julong os::win32::available_memory() {
 745   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
 746   // value if total memory is larger than 4GB
 747   MEMORYSTATUSEX ms;
 748   ms.dwLength = sizeof(ms);
 749   GlobalMemoryStatusEx(&amp;ms);
 750 
 751   return (julong)ms.ullAvailPhys;
 752 }
 753 
 754 julong os::physical_memory() {
 755   return win32::physical_memory();
 756 }
 757 
 758 bool os::has_allocatable_memory_limit(julong* limit) {
 759   MEMORYSTATUSEX ms;
 760   ms.dwLength = sizeof(ms);
 761   GlobalMemoryStatusEx(&amp;ms);
 762 #ifdef _LP64
 763   *limit = (julong)ms.ullAvailVirtual;
 764   return true;
 765 #else
 766   // Limit to 1400m because of the 2gb address space wall
 767   *limit = MIN2((julong)1400*M, (julong)ms.ullAvailVirtual);
 768   return true;
 769 #endif
 770 }
 771 
 772 int os::active_processor_count() {
 773   // User has overridden the number of active processors
 774   if (ActiveProcessorCount &gt; 0) {
 775     log_trace(os)(&quot;active_processor_count: &quot;
 776                   &quot;active processor count set by user : %d&quot;,
 777                   ActiveProcessorCount);
 778     return ActiveProcessorCount;
 779   }
 780 
 781   DWORD_PTR lpProcessAffinityMask = 0;
 782   DWORD_PTR lpSystemAffinityMask = 0;
 783   int proc_count = processor_count();
 784   if (proc_count &lt;= sizeof(UINT_PTR) * BitsPerByte &amp;&amp;
 785       GetProcessAffinityMask(GetCurrentProcess(), &amp;lpProcessAffinityMask, &amp;lpSystemAffinityMask)) {
 786     // Nof active processors is number of bits in process affinity mask
 787     int bitcount = 0;
 788     while (lpProcessAffinityMask != 0) {
 789       lpProcessAffinityMask = lpProcessAffinityMask &amp; (lpProcessAffinityMask-1);
 790       bitcount++;
 791     }
 792     return bitcount;
 793   } else {
 794     return proc_count;
 795   }
 796 }
 797 
 798 uint os::processor_id() {
 799   return (uint)GetCurrentProcessorNumber();
 800 }
 801 
 802 void os::set_native_thread_name(const char *name) {
 803 
 804   // See: http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx
 805   //
 806   // Note that unfortunately this only works if the process
 807   // is already attached to a debugger; debugger must observe
 808   // the exception below to show the correct name.
 809 
 810   // If there is no debugger attached skip raising the exception
 811   if (!IsDebuggerPresent()) {
 812     return;
 813   }
 814 
 815   const DWORD MS_VC_EXCEPTION = 0x406D1388;
 816   struct {
 817     DWORD dwType;     // must be 0x1000
 818     LPCSTR szName;    // pointer to name (in user addr space)
 819     DWORD dwThreadID; // thread ID (-1=caller thread)
 820     DWORD dwFlags;    // reserved for future use, must be zero
 821   } info;
 822 
 823   info.dwType = 0x1000;
 824   info.szName = name;
 825   info.dwThreadID = -1;
 826   info.dwFlags = 0;
 827 
 828   __try {
 829     RaiseException (MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(DWORD), (const ULONG_PTR*)&amp;info );
 830   } __except(EXCEPTION_EXECUTE_HANDLER) {}
 831 }
 832 
 833 bool os::bind_to_processor(uint processor_id) {
 834   // Not yet implemented.
 835   return false;
 836 }
 837 
 838 void os::win32::initialize_performance_counter() {
 839   LARGE_INTEGER count;
 840   QueryPerformanceFrequency(&amp;count);
 841   performance_frequency = as_long(count);
 842   QueryPerformanceCounter(&amp;count);
 843   initial_performance_count = as_long(count);
 844 }
 845 
 846 
 847 double os::elapsedTime() {
 848   return (double) elapsed_counter() / (double) elapsed_frequency();
 849 }
 850 
 851 
 852 // Windows format:
 853 //   The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.
 854 // Java format:
 855 //   Java standards require the number of milliseconds since 1/1/1970
 856 
 857 // Constant offset - calculated using offset()
 858 static jlong  _offset   = 116444736000000000;
 859 // Fake time counter for reproducible results when debugging
 860 static jlong  fake_time = 0;
 861 
 862 #ifdef ASSERT
 863 // Just to be safe, recalculate the offset in debug mode
 864 static jlong _calculated_offset = 0;
 865 static int   _has_calculated_offset = 0;
 866 
 867 jlong offset() {
 868   if (_has_calculated_offset) return _calculated_offset;
 869   SYSTEMTIME java_origin;
 870   java_origin.wYear          = 1970;
 871   java_origin.wMonth         = 1;
 872   java_origin.wDayOfWeek     = 0; // ignored
 873   java_origin.wDay           = 1;
 874   java_origin.wHour          = 0;
 875   java_origin.wMinute        = 0;
 876   java_origin.wSecond        = 0;
 877   java_origin.wMilliseconds  = 0;
 878   FILETIME jot;
 879   if (!SystemTimeToFileTime(&amp;java_origin, &amp;jot)) {
 880     fatal(&quot;Error = %d\nWindows error&quot;, GetLastError());
 881   }
 882   _calculated_offset = jlong_from(jot.dwHighDateTime, jot.dwLowDateTime);
 883   _has_calculated_offset = 1;
 884   assert(_calculated_offset == _offset, &quot;Calculated and constant time offsets must be equal&quot;);
 885   return _calculated_offset;
 886 }
 887 #else
 888 jlong offset() {
 889   return _offset;
 890 }
 891 #endif
 892 
 893 jlong windows_to_java_time(FILETIME wt) {
 894   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 895   return (a - offset()) / 10000;
 896 }
 897 
 898 // Returns time ticks in (10th of micro seconds)
 899 jlong windows_to_time_ticks(FILETIME wt) {
 900   jlong a = jlong_from(wt.dwHighDateTime, wt.dwLowDateTime);
 901   return (a - offset());
 902 }
 903 
 904 FILETIME java_to_windows_time(jlong l) {
 905   jlong a = (l * 10000) + offset();
 906   FILETIME result;
 907   result.dwHighDateTime = high(a);
 908   result.dwLowDateTime  = low(a);
 909   return result;
 910 }
 911 
 912 bool os::supports_vtime() { return true; }
 913 
 914 double os::elapsedVTime() {
 915   FILETIME created;
 916   FILETIME exited;
 917   FILETIME kernel;
 918   FILETIME user;
 919   if (GetThreadTimes(GetCurrentThread(), &amp;created, &amp;exited, &amp;kernel, &amp;user) != 0) {
 920     // the resolution of windows_to_java_time() should be sufficient (ms)
 921     return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
 922   } else {
 923     return elapsedTime();
 924   }
 925 }
 926 
 927 jlong os::javaTimeMillis() {
 928   FILETIME wt;
 929   GetSystemTimeAsFileTime(&amp;wt);
 930   return windows_to_java_time(wt);
 931 }
 932 
 933 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
 934   FILETIME wt;
 935   GetSystemTimeAsFileTime(&amp;wt);
 936   jlong ticks = windows_to_time_ticks(wt); // 10th of micros
 937   jlong secs = jlong(ticks / 10000000); // 10000 * 1000
 938   seconds = secs;
 939   nanos = jlong(ticks - (secs*10000000)) * 100;
 940 }
 941 
 942 jlong os::javaTimeNanos() {
 943     LARGE_INTEGER current_count;
 944     QueryPerformanceCounter(&amp;current_count);
 945     double current = as_long(current_count);
 946     double freq = performance_frequency;
 947     jlong time = (jlong)((current/freq) * NANOSECS_PER_SEC);
 948     return time;
 949 }
 950 
 951 void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {
 952   jlong freq = performance_frequency;
 953   if (freq &lt; NANOSECS_PER_SEC) {
 954     // the performance counter is 64 bits and we will
 955     // be multiplying it -- so no wrap in 64 bits
 956     info_ptr-&gt;max_value = ALL_64_BITS;
 957   } else if (freq &gt; NANOSECS_PER_SEC) {
 958     // use the max value the counter can reach to
 959     // determine the max value which could be returned
 960     julong max_counter = (julong)ALL_64_BITS;
 961     info_ptr-&gt;max_value = (jlong)(max_counter / (freq / NANOSECS_PER_SEC));
 962   } else {
 963     // the performance counter is 64 bits and we will
 964     // be using it directly -- so no wrap in 64 bits
 965     info_ptr-&gt;max_value = ALL_64_BITS;
 966   }
 967 
 968   // using a counter, so no skipping
 969   info_ptr-&gt;may_skip_backward = false;
 970   info_ptr-&gt;may_skip_forward = false;
 971 
 972   info_ptr-&gt;kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time
 973 }
 974 
 975 char* os::local_time_string(char *buf, size_t buflen) {
 976   SYSTEMTIME st;
 977   GetLocalTime(&amp;st);
 978   jio_snprintf(buf, buflen, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,
 979                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 980   return buf;
 981 }
 982 
 983 bool os::getTimesSecs(double* process_real_time,
 984                       double* process_user_time,
 985                       double* process_system_time) {
 986   HANDLE h_process = GetCurrentProcess();
 987   FILETIME create_time, exit_time, kernel_time, user_time;
 988   BOOL result = GetProcessTimes(h_process,
 989                                 &amp;create_time,
 990                                 &amp;exit_time,
 991                                 &amp;kernel_time,
 992                                 &amp;user_time);
 993   if (result != 0) {
 994     FILETIME wt;
 995     GetSystemTimeAsFileTime(&amp;wt);
 996     jlong rtc_millis = windows_to_java_time(wt);
 997     *process_real_time = ((double) rtc_millis) / ((double) MILLIUNITS);
 998     *process_user_time =
 999       (double) jlong_from(user_time.dwHighDateTime, user_time.dwLowDateTime) / (10 * MICROUNITS);
1000     *process_system_time =
1001       (double) jlong_from(kernel_time.dwHighDateTime, kernel_time.dwLowDateTime) / (10 * MICROUNITS);
1002     return true;
1003   } else {
1004     return false;
1005   }
1006 }
1007 
1008 void os::shutdown() {
1009   // allow PerfMemory to attempt cleanup of any persistent resources
1010   perfMemory_exit();
1011 
1012   // flush buffered output, finish log files
1013   ostream_abort();
1014 
1015   // Check for abort hook
1016   abort_hook_t abort_hook = Arguments::abort_hook();
1017   if (abort_hook != NULL) {
1018     abort_hook();
1019   }
1020 }
1021 
1022 
1023 static HANDLE dumpFile = NULL;
1024 
1025 // Check if dump file can be created.
1026 void os::check_dump_limit(char* buffer, size_t buffsz) {
1027   bool status = true;
1028   if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) &amp;&amp; !CreateCoredumpOnCrash) {
1029     jio_snprintf(buffer, buffsz, &quot;CreateCoredumpOnCrash is disabled from command line&quot;);
1030     status = false;
1031   }
1032 
1033 #ifndef ASSERT
1034   if (!os::win32::is_windows_server() &amp;&amp; FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {
1035     jio_snprintf(buffer, buffsz, &quot;Minidumps are not enabled by default on client versions of Windows&quot;);
1036     status = false;
1037   }
1038 #endif
1039 
1040   if (status) {
1041     const char* cwd = get_current_directory(NULL, 0);
1042     int pid = current_process_id();
1043     if (cwd != NULL) {
1044       jio_snprintf(buffer, buffsz, &quot;%s\\hs_err_pid%u.mdmp&quot;, cwd, pid);
1045     } else {
1046       jio_snprintf(buffer, buffsz, &quot;.\\hs_err_pid%u.mdmp&quot;, pid);
1047     }
1048 
1049     if (dumpFile == NULL &amp;&amp;
1050        (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
1051                  == INVALID_HANDLE_VALUE) {
1052       jio_snprintf(buffer, buffsz, &quot;Failed to create minidump file (0x%x).&quot;, GetLastError());
1053       status = false;
1054     }
1055   }
1056   VMError::record_coredump_status(buffer, status);
1057 }
1058 
1059 void os::abort(bool dump_core, void* siginfo, const void* context) {
1060   EXCEPTION_POINTERS ep;
1061   MINIDUMP_EXCEPTION_INFORMATION mei;
1062   MINIDUMP_EXCEPTION_INFORMATION* pmei;
1063 
1064   HANDLE hProcess = GetCurrentProcess();
1065   DWORD processId = GetCurrentProcessId();
1066   MINIDUMP_TYPE dumpType;
1067 
1068   shutdown();
1069   if (!dump_core || dumpFile == NULL) {
1070     if (dumpFile != NULL) {
1071       CloseHandle(dumpFile);
1072     }
1073     win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1074   }
1075 
1076   dumpType = (MINIDUMP_TYPE)(MiniDumpWithFullMemory | MiniDumpWithHandleData |
1077     MiniDumpWithFullMemoryInfo | MiniDumpWithThreadInfo | MiniDumpWithUnloadedModules);
1078 
1079   if (siginfo != NULL &amp;&amp; context != NULL) {
1080     ep.ContextRecord = (PCONTEXT) context;
1081     ep.ExceptionRecord = (PEXCEPTION_RECORD) siginfo;
1082 
1083     mei.ThreadId = GetCurrentThreadId();
1084     mei.ExceptionPointers = &amp;ep;
1085     pmei = &amp;mei;
1086   } else {
1087     pmei = NULL;
1088   }
1089 
1090   // Older versions of dbghelp.dll (the one shipped with Win2003 for example) may not support all
1091   // the dump types we really want. If first call fails, lets fall back to just use MiniDumpWithFullMemory then.
1092   if (!WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) &amp;&amp;
1093       !WindowsDbgHelp::miniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL)) {
1094     jio_fprintf(stderr, &quot;Call to MiniDumpWriteDump() failed (Error 0x%x)\n&quot;, GetLastError());
1095   }
1096   CloseHandle(dumpFile);
1097   win32::exit_process_or_thread(win32::EPT_PROCESS, 1);
1098 }
1099 
1100 // Die immediately, no exit hook, no abort hook, no cleanup.
1101 void os::die() {
1102   win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);
1103 }
1104 
1105 // Directory routines copied from src/win32/native/java/io/dirent_md.c
1106 //  * dirent_md.c       1.15 00/02/02
1107 //
1108 // The declarations for DIR and struct dirent are in jvm_win32.h.
1109 
1110 // Caller must have already run dirname through JVM_NativePath, which removes
1111 // duplicate slashes and converts all instances of &#39;/&#39; into &#39;\\&#39;.
1112 
1113 DIR * os::opendir(const char *dirname) {
1114   assert(dirname != NULL, &quot;just checking&quot;);   // hotspot change
1115   DIR *dirp = (DIR *)malloc(sizeof(DIR), mtInternal);
1116   DWORD fattr;                                // hotspot change
1117   char alt_dirname[4] = { 0, 0, 0, 0 };
1118 
1119   if (dirp == 0) {
1120     errno = ENOMEM;
1121     return 0;
1122   }
1123 
1124   // Win32 accepts &quot;\&quot; in its POSIX stat(), but refuses to treat it
1125   // as a directory in FindFirstFile().  We detect this case here and
1126   // prepend the current drive name.
1127   //
1128   if (dirname[1] == &#39;\0&#39; &amp;&amp; dirname[0] == &#39;\\&#39;) {
1129     alt_dirname[0] = _getdrive() + &#39;A&#39; - 1;
1130     alt_dirname[1] = &#39;:&#39;;
1131     alt_dirname[2] = &#39;\\&#39;;
1132     alt_dirname[3] = &#39;\0&#39;;
1133     dirname = alt_dirname;
1134   }
1135 
1136   dirp-&gt;path = (char *)malloc(strlen(dirname) + 5, mtInternal);
1137   if (dirp-&gt;path == 0) {
1138     free(dirp);
1139     errno = ENOMEM;
1140     return 0;
1141   }
1142   strcpy(dirp-&gt;path, dirname);
1143 
1144   fattr = GetFileAttributes(dirp-&gt;path);
1145   if (fattr == 0xffffffff) {
1146     free(dirp-&gt;path);
1147     free(dirp);
1148     errno = ENOENT;
1149     return 0;
1150   } else if ((fattr &amp; FILE_ATTRIBUTE_DIRECTORY) == 0) {
1151     free(dirp-&gt;path);
1152     free(dirp);
1153     errno = ENOTDIR;
1154     return 0;
1155   }
1156 
1157   // Append &quot;*.*&quot;, or possibly &quot;\\*.*&quot;, to path
1158   if (dirp-&gt;path[1] == &#39;:&#39; &amp;&amp;
1159       (dirp-&gt;path[2] == &#39;\0&#39; ||
1160       (dirp-&gt;path[2] == &#39;\\&#39; &amp;&amp; dirp-&gt;path[3] == &#39;\0&#39;))) {
1161     // No &#39;\\&#39; needed for cases like &quot;Z:&quot; or &quot;Z:\&quot;
1162     strcat(dirp-&gt;path, &quot;*.*&quot;);
1163   } else {
1164     strcat(dirp-&gt;path, &quot;\\*.*&quot;);
1165   }
1166 
1167   dirp-&gt;handle = FindFirstFile(dirp-&gt;path, &amp;dirp-&gt;find_data);
1168   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1169     if (GetLastError() != ERROR_FILE_NOT_FOUND) {
1170       free(dirp-&gt;path);
1171       free(dirp);
1172       errno = EACCES;
1173       return 0;
1174     }
1175   }
1176   return dirp;
1177 }
1178 
1179 struct dirent * os::readdir(DIR *dirp) {
1180   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1181   if (dirp-&gt;handle == INVALID_HANDLE_VALUE) {
1182     return NULL;
1183   }
1184 
1185   strcpy(dirp-&gt;dirent.d_name, dirp-&gt;find_data.cFileName);
1186 
1187   if (!FindNextFile(dirp-&gt;handle, &amp;dirp-&gt;find_data)) {
1188     if (GetLastError() == ERROR_INVALID_HANDLE) {
1189       errno = EBADF;
1190       return NULL;
1191     }
1192     FindClose(dirp-&gt;handle);
1193     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1194   }
1195 
1196   return &amp;dirp-&gt;dirent;
1197 }
1198 
1199 int os::closedir(DIR *dirp) {
1200   assert(dirp != NULL, &quot;just checking&quot;);      // hotspot change
1201   if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
1202     if (!FindClose(dirp-&gt;handle)) {
1203       errno = EBADF;
1204       return -1;
1205     }
1206     dirp-&gt;handle = INVALID_HANDLE_VALUE;
1207   }
1208   free(dirp-&gt;path);
1209   free(dirp);
1210   return 0;
1211 }
1212 
1213 // This must be hard coded because it&#39;s the system&#39;s temporary
1214 // directory not the java application&#39;s temp directory, ala java.io.tmpdir.
1215 const char* os::get_temp_directory() {
1216   static char path_buf[MAX_PATH];
1217   if (GetTempPath(MAX_PATH, path_buf) &gt; 0) {
1218     return path_buf;
1219   } else {
1220     path_buf[0] = &#39;\0&#39;;
1221     return path_buf;
1222   }
1223 }
1224 
1225 // Needs to be in os specific directory because windows requires another
1226 // header file &lt;direct.h&gt;
1227 const char* os::get_current_directory(char *buf, size_t buflen) {
1228   int n = static_cast&lt;int&gt;(buflen);
1229   if (buflen &gt; INT_MAX)  n = INT_MAX;
1230   return _getcwd(buf, n);
1231 }
1232 
1233 //-----------------------------------------------------------
1234 // Helper functions for fatal error handler
1235 #ifdef _WIN64
1236 // Helper routine which returns true if address in
1237 // within the NTDLL address space.
1238 //
1239 static bool _addr_in_ntdll(address addr) {
1240   HMODULE hmod;
1241   MODULEINFO minfo;
1242 
1243   hmod = GetModuleHandle(&quot;NTDLL.DLL&quot;);
1244   if (hmod == NULL) return false;
1245   if (!GetModuleInformation(GetCurrentProcess(), hmod,
1246                                           &amp;minfo, sizeof(MODULEINFO))) {
1247     return false;
1248   }
1249 
1250   if ((addr &gt;= minfo.lpBaseOfDll) &amp;&amp;
1251       (addr &lt; (address)((uintptr_t)minfo.lpBaseOfDll + (uintptr_t)minfo.SizeOfImage))) {
1252     return true;
1253   } else {
1254     return false;
1255   }
1256 }
1257 #endif
1258 
1259 struct _modinfo {
1260   address addr;
1261   char*   full_path;   // point to a char buffer
1262   int     buflen;      // size of the buffer
1263   address base_addr;
1264 };
1265 
1266 static int _locate_module_by_addr(const char * mod_fname, address base_addr,
1267                                   address top_address, void * param) {
1268   struct _modinfo *pmod = (struct _modinfo *)param;
1269   if (!pmod) return -1;
1270 
1271   if (base_addr   &lt;= pmod-&gt;addr &amp;&amp;
1272       top_address &gt; pmod-&gt;addr) {
1273     // if a buffer is provided, copy path name to the buffer
1274     if (pmod-&gt;full_path) {
1275       jio_snprintf(pmod-&gt;full_path, pmod-&gt;buflen, &quot;%s&quot;, mod_fname);
1276     }
1277     pmod-&gt;base_addr = base_addr;
1278     return 1;
1279   }
1280   return 0;
1281 }
1282 
1283 bool os::dll_address_to_library_name(address addr, char* buf,
1284                                      int buflen, int* offset) {
1285   // buf is not optional, but offset is optional
1286   assert(buf != NULL, &quot;sanity check&quot;);
1287 
1288 // NOTE: the reason we don&#39;t use SymGetModuleInfo() is it doesn&#39;t always
1289 //       return the full path to the DLL file, sometimes it returns path
1290 //       to the corresponding PDB file (debug info); sometimes it only
1291 //       returns partial path, which makes life painful.
1292 
1293   struct _modinfo mi;
1294   mi.addr      = addr;
1295   mi.full_path = buf;
1296   mi.buflen    = buflen;
1297   if (get_loaded_modules_info(_locate_module_by_addr, (void *)&amp;mi)) {
1298     // buf already contains path name
1299     if (offset) *offset = addr - mi.base_addr;
1300     return true;
1301   }
1302 
1303   buf[0] = &#39;\0&#39;;
1304   if (offset) *offset = -1;
1305   return false;
1306 }
1307 
1308 bool os::dll_address_to_function_name(address addr, char *buf,
1309                                       int buflen, int *offset,
1310                                       bool demangle) {
1311   // buf is not optional, but offset is optional
1312   assert(buf != NULL, &quot;sanity check&quot;);
1313 
1314   if (Decoder::decode(addr, buf, buflen, offset, demangle)) {
1315     return true;
1316   }
1317   if (offset != NULL)  *offset  = -1;
1318   buf[0] = &#39;\0&#39;;
1319   return false;
1320 }
1321 
1322 // save the start and end address of jvm.dll into param[0] and param[1]
1323 static int _locate_jvm_dll(const char* mod_fname, address base_addr,
1324                            address top_address, void * param) {
1325   if (!param) return -1;
1326 
1327   if (base_addr   &lt;= (address)_locate_jvm_dll &amp;&amp;
1328       top_address &gt; (address)_locate_jvm_dll) {
1329     ((address*)param)[0] = base_addr;
1330     ((address*)param)[1] = top_address;
1331     return 1;
1332   }
1333   return 0;
1334 }
1335 
1336 address vm_lib_location[2];    // start and end address of jvm.dll
1337 
1338 // check if addr is inside jvm.dll
1339 bool os::address_is_in_vm(address addr) {
1340   if (!vm_lib_location[0] || !vm_lib_location[1]) {
1341     if (!get_loaded_modules_info(_locate_jvm_dll, (void *)vm_lib_location)) {
1342       assert(false, &quot;Can&#39;t find jvm module.&quot;);
1343       return false;
1344     }
1345   }
1346 
1347   return (vm_lib_location[0] &lt;= addr) &amp;&amp; (addr &lt; vm_lib_location[1]);
1348 }
1349 
1350 // print module info; param is outputStream*
1351 static int _print_module(const char* fname, address base_address,
1352                          address top_address, void* param) {
1353   if (!param) return -1;
1354 
1355   outputStream* st = (outputStream*)param;
1356 
1357   st-&gt;print(PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; \t%s\n&quot;, base_address, top_address, fname);
1358   return 0;
1359 }
1360 
1361 // Loads .dll/.so and
1362 // in case of error it checks if .dll/.so was built for the
1363 // same architecture as Hotspot is running on
1364 void * os::dll_load(const char *name, char *ebuf, int ebuflen) {
1365   log_info(os)(&quot;attempting shared library load of %s&quot;, name);
1366 
1367   void * result = LoadLibrary(name);
1368   if (result != NULL) {
1369     Events::log(NULL, &quot;Loaded shared library %s&quot;, name);
1370     // Recalculate pdb search path if a DLL was loaded successfully.
1371     SymbolEngine::recalc_search_path();
1372     log_info(os)(&quot;shared library load of %s was successful&quot;, name);
1373     return result;
1374   }
1375   DWORD errcode = GetLastError();
1376   // Read system error message into ebuf
1377   // It may or may not be overwritten below (in the for loop and just above)
1378   lasterror(ebuf, (size_t) ebuflen);
1379   ebuf[ebuflen - 1] = &#39;\0&#39;;
1380   Events::log(NULL, &quot;Loading shared library %s failed, error code %lu&quot;, name, errcode);
1381   log_info(os)(&quot;shared library load of %s failed, error code %lu&quot;, name, errcode);
1382 
1383   if (errcode == ERROR_MOD_NOT_FOUND) {
1384     strncpy(ebuf, &quot;Can&#39;t find dependent libraries&quot;, ebuflen - 1);
1385     ebuf[ebuflen - 1] = &#39;\0&#39;;
1386     return NULL;
1387   }
1388 
1389   // Parsing dll below
1390   // If we can read dll-info and find that dll was built
1391   // for an architecture other than Hotspot is running in
1392   // - then print to buffer &quot;DLL was built for a different architecture&quot;
1393   // else call os::lasterror to obtain system error message
1394   int fd = ::open(name, O_RDONLY | O_BINARY, 0);
1395   if (fd &lt; 0) {
1396     return NULL;
1397   }
1398 
1399   uint32_t signature_offset;
1400   uint16_t lib_arch = 0;
1401   bool failed_to_get_lib_arch =
1402     ( // Go to position 3c in the dll
1403      (os::seek_to_file_offset(fd, IMAGE_FILE_PTR_TO_SIGNATURE) &lt; 0)
1404      ||
1405      // Read location of signature
1406      (sizeof(signature_offset) !=
1407      (os::read(fd, (void*)&amp;signature_offset, sizeof(signature_offset))))
1408      ||
1409      // Go to COFF File Header in dll
1410      // that is located after &quot;signature&quot; (4 bytes long)
1411      (os::seek_to_file_offset(fd,
1412      signature_offset + IMAGE_FILE_SIGNATURE_LENGTH) &lt; 0)
1413      ||
1414      // Read field that contains code of architecture
1415      // that dll was built for
1416      (sizeof(lib_arch) != (os::read(fd, (void*)&amp;lib_arch, sizeof(lib_arch))))
1417     );
1418 
1419   ::close(fd);
1420   if (failed_to_get_lib_arch) {
1421     // file i/o error - report os::lasterror(...) msg
1422     return NULL;
1423   }
1424 
1425   typedef struct {
1426     uint16_t arch_code;
1427     char* arch_name;
1428   } arch_t;
1429 
1430   static const arch_t arch_array[] = {
1431     {IMAGE_FILE_MACHINE_I386,      (char*)&quot;IA 32&quot;},
1432     {IMAGE_FILE_MACHINE_AMD64,     (char*)&quot;AMD 64&quot;}
1433   };
1434 #if (defined _M_AMD64)
1435   static const uint16_t running_arch = IMAGE_FILE_MACHINE_AMD64;
1436 #elif (defined _M_IX86)
1437   static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;
1438 #else
1439   #error Method os::dll_load requires that one of following \
1440          is defined :_M_AMD64 or _M_IX86
1441 #endif
1442 
1443 
1444   // Obtain a string for printf operation
1445   // lib_arch_str shall contain string what platform this .dll was built for
1446   // running_arch_str shall string contain what platform Hotspot was built for
1447   char *running_arch_str = NULL, *lib_arch_str = NULL;
1448   for (unsigned int i = 0; i &lt; ARRAY_SIZE(arch_array); i++) {
1449     if (lib_arch == arch_array[i].arch_code) {
1450       lib_arch_str = arch_array[i].arch_name;
1451     }
1452     if (running_arch == arch_array[i].arch_code) {
1453       running_arch_str = arch_array[i].arch_name;
1454     }
1455   }
1456 
1457   assert(running_arch_str,
1458          &quot;Didn&#39;t find running architecture code in arch_array&quot;);
1459 
1460   // If the architecture is right
1461   // but some other error took place - report os::lasterror(...) msg
1462   if (lib_arch == running_arch) {
1463     return NULL;
1464   }
1465 
1466   if (lib_arch_str != NULL) {
1467     ::_snprintf(ebuf, ebuflen - 1,
1468                 &quot;Can&#39;t load %s-bit .dll on a %s-bit platform&quot;,
1469                 lib_arch_str, running_arch_str);
1470   } else {
1471     // don&#39;t know what architecture this dll was build for
1472     ::_snprintf(ebuf, ebuflen - 1,
1473                 &quot;Can&#39;t load this .dll (machine code=0x%x) on a %s-bit platform&quot;,
1474                 lib_arch, running_arch_str);
1475   }
1476 
1477   return NULL;
1478 }
1479 
1480 void os::print_dll_info(outputStream *st) {
1481   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
1482   get_loaded_modules_info(_print_module, (void *)st);
1483 }
1484 
1485 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
1486   HANDLE   hProcess;
1487 
1488 # define MAX_NUM_MODULES 128
1489   HMODULE     modules[MAX_NUM_MODULES];
1490   static char filename[MAX_PATH];
1491   int         result = 0;
1492 
1493   int pid = os::current_process_id();
1494   hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
1495                          FALSE, pid);
1496   if (hProcess == NULL) return 0;
1497 
1498   DWORD size_needed;
1499   if (!EnumProcessModules(hProcess, modules, sizeof(modules), &amp;size_needed)) {
1500     CloseHandle(hProcess);
1501     return 0;
1502   }
1503 
1504   // number of modules that are currently loaded
1505   int num_modules = size_needed / sizeof(HMODULE);
1506 
1507   for (int i = 0; i &lt; MIN2(num_modules, MAX_NUM_MODULES); i++) {
1508     // Get Full pathname:
1509     if (!GetModuleFileNameEx(hProcess, modules[i], filename, sizeof(filename))) {
1510       filename[0] = &#39;\0&#39;;
1511     }
1512 
1513     MODULEINFO modinfo;
1514     if (!GetModuleInformation(hProcess, modules[i], &amp;modinfo, sizeof(modinfo))) {
1515       modinfo.lpBaseOfDll = NULL;
1516       modinfo.SizeOfImage = 0;
1517     }
1518 
1519     // Invoke callback function
1520     result = callback(filename, (address)modinfo.lpBaseOfDll,
1521                       (address)((u8)modinfo.lpBaseOfDll + (u8)modinfo.SizeOfImage), param);
1522     if (result) break;
1523   }
1524 
1525   CloseHandle(hProcess);
1526   return result;
1527 }
1528 
1529 bool os::get_host_name(char* buf, size_t buflen) {
1530   DWORD size = (DWORD)buflen;
1531   return (GetComputerNameEx(ComputerNameDnsHostname, buf, &amp;size) == TRUE);
1532 }
1533 
1534 void os::get_summary_os_info(char* buf, size_t buflen) {
1535   stringStream sst(buf, buflen);
1536   os::win32::print_windows_version(&amp;sst);
1537   // chop off newline character
1538   char* nl = strchr(buf, &#39;\n&#39;);
1539   if (nl != NULL) *nl = &#39;\0&#39;;
1540 }
1541 
1542 int os::vsnprintf(char* buf, size_t len, const char* fmt, va_list args) {
1543 #if _MSC_VER &gt;= 1900
1544   // Starting with Visual Studio 2015, vsnprint is C99 compliant.
1545   int result = ::vsnprintf(buf, len, fmt, args);
1546   // If an encoding error occurred (result &lt; 0) then it&#39;s not clear
1547   // whether the buffer is NUL terminated, so ensure it is.
1548   if ((result &lt; 0) &amp;&amp; (len &gt; 0)) {
1549     buf[len - 1] = &#39;\0&#39;;
1550   }
1551   return result;
1552 #else
1553   // Before Visual Studio 2015, vsnprintf is not C99 compliant, so use
1554   // _vsnprintf, whose behavior seems to be *mostly* consistent across
1555   // versions.  However, when len == 0, avoid _vsnprintf too, and just
1556   // go straight to _vscprintf.  The output is going to be truncated in
1557   // that case, except in the unusual case of empty output.  More
1558   // importantly, the documentation for various versions of Visual Studio
1559   // are inconsistent about the behavior of _vsnprintf when len == 0,
1560   // including it possibly being an error.
1561   int result = -1;
1562   if (len &gt; 0) {
1563     result = _vsnprintf(buf, len, fmt, args);
1564     // If output (including NUL terminator) is truncated, the buffer
1565     // won&#39;t be NUL terminated.  Add the trailing NUL specified by C99.
1566     if ((result &lt; 0) || ((size_t)result &gt;= len)) {
1567       buf[len - 1] = &#39;\0&#39;;
1568     }
1569   }
1570   if (result &lt; 0) {
1571     result = _vscprintf(fmt, args);
1572   }
1573   return result;
1574 #endif // _MSC_VER dispatch
1575 }
1576 
1577 static inline time_t get_mtime(const char* filename) {
1578   struct stat st;
1579   int ret = os::stat(filename, &amp;st);
1580   assert(ret == 0, &quot;failed to stat() file &#39;%s&#39;: %s&quot;, filename, os::strerror(errno));
1581   return st.st_mtime;
1582 }
1583 
1584 int os::compare_file_modified_times(const char* file1, const char* file2) {
1585   time_t t1 = get_mtime(file1);
1586   time_t t2 = get_mtime(file2);
1587   return t1 - t2;
1588 }
1589 
1590 void os::print_os_info_brief(outputStream* st) {
1591   os::print_os_info(st);
1592 }
1593 
1594 void os::win32::print_uptime_info(outputStream* st) {
1595   unsigned long long ticks = GetTickCount64();
1596   os::print_dhm(st, &quot;OS uptime:&quot;, ticks/1000);
1597 }
1598 
1599 void os::print_os_info(outputStream* st) {
1600 #ifdef ASSERT
1601   char buffer[1024];
1602   st-&gt;print(&quot;HostName: &quot;);
1603   if (get_host_name(buffer, sizeof(buffer))) {
1604     st-&gt;print(&quot;%s &quot;, buffer);
1605   } else {
1606     st-&gt;print(&quot;N/A &quot;);
1607   }
1608 #endif
1609   st-&gt;print(&quot;OS:&quot;);
1610   os::win32::print_windows_version(st);
1611 
1612   os::win32::print_uptime_info(st);
1613 
1614 #ifdef _LP64
1615   VM_Version::print_platform_virtualization_info(st);
1616 #endif
1617 }
1618 
1619 void os::win32::print_windows_version(outputStream* st) {
1620   OSVERSIONINFOEX osvi;
1621   VS_FIXEDFILEINFO *file_info;
1622   TCHAR kernel32_path[MAX_PATH];
1623   UINT len, ret;
1624 
1625   // Use the GetVersionEx information to see if we&#39;re on a server or
1626   // workstation edition of Windows. Starting with Windows 8.1 we can&#39;t
1627   // trust the OS version information returned by this API.
1628   ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));
1629   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
1630   if (!GetVersionEx((OSVERSIONINFO *)&amp;osvi)) {
1631     st-&gt;print_cr(&quot;Call to GetVersionEx failed&quot;);
1632     return;
1633   }
1634   bool is_workstation = (osvi.wProductType == VER_NT_WORKSTATION);
1635 
1636   // Get the full path to \Windows\System32\kernel32.dll and use that for
1637   // determining what version of Windows we&#39;re running on.
1638   len = MAX_PATH - (UINT)strlen(&quot;\\kernel32.dll&quot;) - 1;
1639   ret = GetSystemDirectory(kernel32_path, len);
1640   if (ret == 0 || ret &gt; len) {
1641     st-&gt;print_cr(&quot;Call to GetSystemDirectory failed&quot;);
1642     return;
1643   }
1644   strncat(kernel32_path, &quot;\\kernel32.dll&quot;, MAX_PATH - ret);
1645 
1646   DWORD version_size = GetFileVersionInfoSize(kernel32_path, NULL);
1647   if (version_size == 0) {
1648     st-&gt;print_cr(&quot;Call to GetFileVersionInfoSize failed&quot;);
1649     return;
1650   }
1651 
1652   LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);
1653   if (version_info == NULL) {
1654     st-&gt;print_cr(&quot;Failed to allocate version_info&quot;);
1655     return;
1656   }
1657 
1658   if (!GetFileVersionInfo(kernel32_path, NULL, version_size, version_info)) {
1659     os::free(version_info);
1660     st-&gt;print_cr(&quot;Call to GetFileVersionInfo failed&quot;);
1661     return;
1662   }
1663 
1664   if (!VerQueryValue(version_info, TEXT(&quot;\\&quot;), (LPVOID*)&amp;file_info, &amp;len)) {
1665     os::free(version_info);
1666     st-&gt;print_cr(&quot;Call to VerQueryValue failed&quot;);
1667     return;
1668   }
1669 
1670   int major_version = HIWORD(file_info-&gt;dwProductVersionMS);
1671   int minor_version = LOWORD(file_info-&gt;dwProductVersionMS);
1672   int build_number = HIWORD(file_info-&gt;dwProductVersionLS);
1673   int build_minor = LOWORD(file_info-&gt;dwProductVersionLS);
1674   int os_vers = major_version * 1000 + minor_version;
1675   os::free(version_info);
1676 
1677   st-&gt;print(&quot; Windows &quot;);
1678   switch (os_vers) {
1679 
1680   case 6000:
1681     if (is_workstation) {
1682       st-&gt;print(&quot;Vista&quot;);
1683     } else {
1684       st-&gt;print(&quot;Server 2008&quot;);
1685     }
1686     break;
1687 
1688   case 6001:
1689     if (is_workstation) {
1690       st-&gt;print(&quot;7&quot;);
1691     } else {
1692       st-&gt;print(&quot;Server 2008 R2&quot;);
1693     }
1694     break;
1695 
1696   case 6002:
1697     if (is_workstation) {
1698       st-&gt;print(&quot;8&quot;);
1699     } else {
1700       st-&gt;print(&quot;Server 2012&quot;);
1701     }
1702     break;
1703 
1704   case 6003:
1705     if (is_workstation) {
1706       st-&gt;print(&quot;8.1&quot;);
1707     } else {
1708       st-&gt;print(&quot;Server 2012 R2&quot;);
1709     }
1710     break;
1711 
1712   case 10000:
1713     if (is_workstation) {
1714       st-&gt;print(&quot;10&quot;);
1715     } else {
1716       // distinguish Windows Server 2016 and 2019 by build number
1717       // Windows server 2019 GA 10/2018 build number is 17763
1718       if (build_number &gt; 17762) {
1719         st-&gt;print(&quot;Server 2019&quot;);
1720       } else {
1721         st-&gt;print(&quot;Server 2016&quot;);
1722       }
1723     }
1724     break;
1725 
1726   default:
1727     // Unrecognized windows, print out its major and minor versions
1728     st-&gt;print(&quot;%d.%d&quot;, major_version, minor_version);
1729     break;
1730   }
1731 
1732   // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
1733   // find out whether we are running on 64 bit processor or not
1734   SYSTEM_INFO si;
1735   ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
1736   GetNativeSystemInfo(&amp;si);
1737   if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
1738     st-&gt;print(&quot; , 64 bit&quot;);
1739   }
1740 
1741   st-&gt;print(&quot; Build %d&quot;, build_number);
1742   st-&gt;print(&quot; (%d.%d.%d.%d)&quot;, major_version, minor_version, build_number, build_minor);
1743   st-&gt;cr();
1744 }
1745 
1746 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
1747   // Nothing to do for now.
1748 }
1749 
1750 void os::get_summary_cpu_info(char* buf, size_t buflen) {
1751   HKEY key;
1752   DWORD status = RegOpenKey(HKEY_LOCAL_MACHINE,
1753                &quot;HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0&quot;, &amp;key);
1754   if (status == ERROR_SUCCESS) {
1755     DWORD size = (DWORD)buflen;
1756     status = RegQueryValueEx(key, &quot;ProcessorNameString&quot;, NULL, NULL, (byte*)buf, &amp;size);
1757     if (status != ERROR_SUCCESS) {
1758         strncpy(buf, &quot;## __CPU__&quot;, buflen);
1759     }
1760     RegCloseKey(key);
1761   } else {
1762     // Put generic cpu info to return
1763     strncpy(buf, &quot;## __CPU__&quot;, buflen);
1764   }
1765 }
1766 
1767 void os::print_memory_info(outputStream* st) {
1768   st-&gt;print(&quot;Memory:&quot;);
1769   st-&gt;print(&quot; %dk page&quot;, os::vm_page_size()&gt;&gt;10);
1770 
1771   // Use GlobalMemoryStatusEx() because GlobalMemoryStatus() may return incorrect
1772   // value if total memory is larger than 4GB
1773   MEMORYSTATUSEX ms;
1774   ms.dwLength = sizeof(ms);
1775   int r1 = GlobalMemoryStatusEx(&amp;ms);
1776 
1777   if (r1 != 0) {
1778     st-&gt;print(&quot;, system-wide physical &quot; INT64_FORMAT &quot;M &quot;,
1779              (int64_t) ms.ullTotalPhys &gt;&gt; 20);
1780     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)\n&quot;, (int64_t) ms.ullAvailPhys &gt;&gt; 20);
1781 
1782     st-&gt;print(&quot;TotalPageFile size &quot; INT64_FORMAT &quot;M &quot;,
1783              (int64_t) ms.ullTotalPageFile &gt;&gt; 20);
1784     st-&gt;print(&quot;(AvailPageFile size &quot; INT64_FORMAT &quot;M)&quot;,
1785              (int64_t) ms.ullAvailPageFile &gt;&gt; 20);
1786 
1787     // on 32bit Total/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)
1788 #if defined(_M_IX86)
1789     st-&gt;print(&quot;, user-mode portion of virtual address-space &quot; INT64_FORMAT &quot;M &quot;,
1790              (int64_t) ms.ullTotalVirtual &gt;&gt; 20);
1791     st-&gt;print(&quot;(&quot; INT64_FORMAT &quot;M free)&quot;, (int64_t) ms.ullAvailVirtual &gt;&gt; 20);
1792 #endif
1793   } else {
1794     st-&gt;print(&quot;, GlobalMemoryStatusEx did not succeed so we miss some memory values.&quot;);
1795   }
1796 
1797   // extended memory statistics for a process
1798   PROCESS_MEMORY_COUNTERS_EX pmex;
1799   ZeroMemory(&amp;pmex, sizeof(PROCESS_MEMORY_COUNTERS_EX));
1800   pmex.cb = sizeof(pmex);
1801   int r2 = GetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &amp;pmex, sizeof(pmex));
1802 
1803   if (r2 != 0) {
1804     st-&gt;print(&quot;\ncurrent process WorkingSet (physical memory assigned to process): &quot; INT64_FORMAT &quot;M, &quot;,
1805              (int64_t) pmex.WorkingSetSize &gt;&gt; 20);
1806     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M\n&quot;, (int64_t) pmex.PeakWorkingSetSize &gt;&gt; 20);
1807 
1808     st-&gt;print(&quot;current process commit charge (\&quot;private bytes\&quot;): &quot; INT64_FORMAT &quot;M, &quot;,
1809              (int64_t) pmex.PrivateUsage &gt;&gt; 20);
1810     st-&gt;print(&quot;peak: &quot; INT64_FORMAT &quot;M&quot;, (int64_t) pmex.PeakPagefileUsage &gt;&gt; 20);
1811   } else {
1812     st-&gt;print(&quot;\nGetProcessMemoryInfo did not succeed so we miss some memory values.&quot;);
1813   }
1814 
1815   st-&gt;cr();
1816 }
1817 
1818 bool os::signal_sent_by_kill(const void* siginfo) {
1819   // TODO: Is this possible?
1820   return false;
1821 }
1822 
1823 void os::print_siginfo(outputStream *st, const void* siginfo) {
1824   const EXCEPTION_RECORD* const er = (EXCEPTION_RECORD*)siginfo;
1825   st-&gt;print(&quot;siginfo:&quot;);
1826 
1827   char tmp[64];
1828   if (os::exception_name(er-&gt;ExceptionCode, tmp, sizeof(tmp)) == NULL) {
1829     strcpy(tmp, &quot;EXCEPTION_??&quot;);
1830   }
1831   st-&gt;print(&quot; %s (0x%x)&quot;, tmp, er-&gt;ExceptionCode);
1832 
1833   if ((er-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
1834        er-&gt;ExceptionCode == EXCEPTION_IN_PAGE_ERROR) &amp;&amp;
1835        er-&gt;NumberParameters &gt;= 2) {
1836     switch (er-&gt;ExceptionInformation[0]) {
1837     case 0: st-&gt;print(&quot;, reading address&quot;); break;
1838     case 1: st-&gt;print(&quot;, writing address&quot;); break;
1839     case 8: st-&gt;print(&quot;, data execution prevention violation at address&quot;); break;
1840     default: st-&gt;print(&quot;, ExceptionInformation=&quot; INTPTR_FORMAT,
1841                        er-&gt;ExceptionInformation[0]);
1842     }
1843     st-&gt;print(&quot; &quot; INTPTR_FORMAT, er-&gt;ExceptionInformation[1]);
1844   } else {
1845     int num = er-&gt;NumberParameters;
1846     if (num &gt; 0) {
1847       st-&gt;print(&quot;, ExceptionInformation=&quot;);
1848       for (int i = 0; i &lt; num; i++) {
1849         st-&gt;print(INTPTR_FORMAT &quot; &quot;, er-&gt;ExceptionInformation[i]);
1850       }
1851     }
1852   }
1853   st-&gt;cr();
1854 }
1855 
1856 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1857   // TODO: Can we kill thread?
1858   return false;
1859 }
1860 
1861 void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {
1862   // do nothing
1863 }
1864 
1865 static char saved_jvm_path[MAX_PATH] = {0};
1866 
1867 // Find the full path to the current module, jvm.dll
1868 void os::jvm_path(char *buf, jint buflen) {
1869   // Error checking.
1870   if (buflen &lt; MAX_PATH) {
1871     assert(false, &quot;must use a large-enough buffer&quot;);
1872     buf[0] = &#39;\0&#39;;
1873     return;
1874   }
1875   // Lazy resolve the path to current module.
1876   if (saved_jvm_path[0] != 0) {
1877     strcpy(buf, saved_jvm_path);
1878     return;
1879   }
1880 
1881   buf[0] = &#39;\0&#39;;
1882   if (Arguments::sun_java_launcher_is_altjvm()) {
1883     // Support for the java launcher&#39;s &#39;-XXaltjvm=&lt;path&gt;&#39; option. Check
1884     // for a JAVA_HOME environment variable and fix up the path so it
1885     // looks like jvm.dll is installed there (append a fake suffix
1886     // hotspot/jvm.dll).
1887     char* java_home_var = ::getenv(&quot;JAVA_HOME&quot;);
1888     if (java_home_var != NULL &amp;&amp; java_home_var[0] != 0 &amp;&amp;
1889         strlen(java_home_var) &lt; (size_t)buflen) {
1890       strncpy(buf, java_home_var, buflen);
1891 
1892       // determine if this is a legacy image or modules image
1893       // modules image doesn&#39;t have &quot;jre&quot; subdirectory
1894       size_t len = strlen(buf);
1895       char* jrebin_p = buf + len;
1896       jio_snprintf(jrebin_p, buflen-len, &quot;\\jre\\bin\\&quot;);
1897       if (0 != _access(buf, 0)) {
1898         jio_snprintf(jrebin_p, buflen-len, &quot;\\bin\\&quot;);
1899       }
1900       len = strlen(buf);
1901       jio_snprintf(buf + len, buflen-len, &quot;hotspot\\jvm.dll&quot;);
1902     }
1903   }
1904 
1905   if (buf[0] == &#39;\0&#39;) {
1906     GetModuleFileName(vm_lib_handle, buf, buflen);
1907   }
1908   strncpy(saved_jvm_path, buf, MAX_PATH);
1909   saved_jvm_path[MAX_PATH - 1] = &#39;\0&#39;;
1910 }
1911 
1912 
1913 void os::print_jni_name_prefix_on(outputStream* st, int args_size) {
1914 #ifndef _WIN64
1915   st-&gt;print(&quot;_&quot;);
1916 #endif
1917 }
1918 
1919 
1920 void os::print_jni_name_suffix_on(outputStream* st, int args_size) {
1921 #ifndef _WIN64
1922   st-&gt;print(&quot;@%d&quot;, args_size  * sizeof(int));
1923 #endif
1924 }
1925 
1926 // This method is a copy of JDK&#39;s sysGetLastErrorString
1927 // from src/windows/hpi/src/system_md.c
1928 
1929 size_t os::lasterror(char* buf, size_t len) {
1930   DWORD errval;
1931 
1932   if ((errval = GetLastError()) != 0) {
1933     // DOS error
1934     size_t n = (size_t)FormatMessage(
1935                                      FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
1936                                      NULL,
1937                                      errval,
1938                                      0,
1939                                      buf,
1940                                      (DWORD)len,
1941                                      NULL);
1942     if (n &gt; 3) {
1943       // Drop final &#39;.&#39;, CR, LF
1944       if (buf[n - 1] == &#39;\n&#39;) n--;
1945       if (buf[n - 1] == &#39;\r&#39;) n--;
1946       if (buf[n - 1] == &#39;.&#39;) n--;
1947       buf[n] = &#39;\0&#39;;
1948     }
1949     return n;
1950   }
1951 
1952   if (errno != 0) {
1953     // C runtime error that has no corresponding DOS error code
1954     const char* s = os::strerror(errno);
1955     size_t n = strlen(s);
1956     if (n &gt;= len) n = len - 1;
1957     strncpy(buf, s, n);
1958     buf[n] = &#39;\0&#39;;
1959     return n;
1960   }
1961 
1962   return 0;
1963 }
1964 
1965 int os::get_last_error() {
1966   DWORD error = GetLastError();
1967   if (error == 0) {
1968     error = errno;
1969   }
1970   return (int)error;
1971 }
1972 
1973 // sun.misc.Signal
1974 // NOTE that this is a workaround for an apparent kernel bug where if
1975 // a signal handler for SIGBREAK is installed then that signal handler
1976 // takes priority over the console control handler for CTRL_CLOSE_EVENT.
1977 // See bug 4416763.
1978 static void (*sigbreakHandler)(int) = NULL;
1979 
1980 static void UserHandler(int sig, void *siginfo, void *context) {
1981   os::signal_notify(sig);
1982   // We need to reinstate the signal handler each time...
1983   os::signal(sig, (void*)UserHandler);
1984 }
1985 
1986 void* os::user_handler() {
1987   return (void*) UserHandler;
1988 }
1989 
1990 void* os::signal(int signal_number, void* handler) {
1991   if ((signal_number == SIGBREAK) &amp;&amp; (!ReduceSignalUsage)) {
1992     void (*oldHandler)(int) = sigbreakHandler;
1993     sigbreakHandler = (void (*)(int)) handler;
1994     return (void*) oldHandler;
1995   } else {
1996     return (void*)::signal(signal_number, (void (*)(int))handler);
1997   }
1998 }
1999 
2000 void os::signal_raise(int signal_number) {
2001   raise(signal_number);
2002 }
2003 
2004 // The Win32 C runtime library maps all console control events other than ^C
2005 // into SIGBREAK, which makes it impossible to distinguish ^BREAK from close,
2006 // logoff, and shutdown events.  We therefore install our own console handler
2007 // that raises SIGTERM for the latter cases.
2008 //
2009 static BOOL WINAPI consoleHandler(DWORD event) {
2010   switch (event) {
2011   case CTRL_C_EVENT:
2012     if (VMError::is_error_reported()) {
2013       // Ctrl-C is pressed during error reporting, likely because the error
2014       // handler fails to abort. Let VM die immediately.
2015       os::die();
2016     }
2017 
2018     os::signal_raise(SIGINT);
2019     return TRUE;
2020     break;
2021   case CTRL_BREAK_EVENT:
2022     if (sigbreakHandler != NULL) {
2023       (*sigbreakHandler)(SIGBREAK);
2024     }
2025     return TRUE;
2026     break;
2027   case CTRL_LOGOFF_EVENT: {
2028     // Don&#39;t terminate JVM if it is running in a non-interactive session,
2029     // such as a service process.
2030     USEROBJECTFLAGS flags;
2031     HANDLE handle = GetProcessWindowStation();
2032     if (handle != NULL &amp;&amp;
2033         GetUserObjectInformation(handle, UOI_FLAGS, &amp;flags,
2034         sizeof(USEROBJECTFLAGS), NULL)) {
2035       // If it is a non-interactive session, let next handler to deal
2036       // with it.
2037       if ((flags.dwFlags &amp; WSF_VISIBLE) == 0) {
2038         return FALSE;
2039       }
2040     }
2041   }
2042   case CTRL_CLOSE_EVENT:
2043   case CTRL_SHUTDOWN_EVENT:
2044     os::signal_raise(SIGTERM);
2045     return TRUE;
2046     break;
2047   default:
2048     break;
2049   }
2050   return FALSE;
2051 }
2052 
2053 // The following code is moved from os.cpp for making this
2054 // code platform specific, which it is by its very nature.
2055 
2056 // Return maximum OS signal used + 1 for internal use only
2057 // Used as exit signal for signal_thread
2058 int os::sigexitnum_pd() {
2059   return NSIG;
2060 }
2061 
2062 // a counter for each possible signal value, including signal_thread exit signal
2063 static volatile jint pending_signals[NSIG+1] = { 0 };
2064 static Semaphore* sig_sem = NULL;
2065 
2066 static void jdk_misc_signal_init() {
2067   // Initialize signal structures
2068   memset((void*)pending_signals, 0, sizeof(pending_signals));
2069 
2070   // Initialize signal semaphore
2071   sig_sem = new Semaphore();
2072 
2073   // Programs embedding the VM do not want it to attempt to receive
2074   // events like CTRL_LOGOFF_EVENT, which are used to implement the
2075   // shutdown hooks mechanism introduced in 1.3.  For example, when
2076   // the VM is run as part of a Windows NT service (i.e., a servlet
2077   // engine in a web server), the correct behavior is for any console
2078   // control handler to return FALSE, not TRUE, because the OS&#39;s
2079   // &quot;final&quot; handler for such events allows the process to continue if
2080   // it is a service (while terminating it if it is not a service).
2081   // To make this behavior uniform and the mechanism simpler, we
2082   // completely disable the VM&#39;s usage of these console events if -Xrs
2083   // (=ReduceSignalUsage) is specified.  This means, for example, that
2084   // the CTRL-BREAK thread dump mechanism is also disabled in this
2085   // case.  See bugs 4323062, 4345157, and related bugs.
2086 
2087   // Add a CTRL-C handler
2088   SetConsoleCtrlHandler(consoleHandler, TRUE);
2089 }
2090 
2091 void os::signal_notify(int sig) {
2092   if (sig_sem != NULL) {
2093     Atomic::inc(&amp;pending_signals[sig]);
2094     sig_sem-&gt;signal();
2095   } else {
2096     // Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init
2097     // initialization isn&#39;t called.
2098     assert(ReduceSignalUsage, &quot;signal semaphore should be created&quot;);
2099   }
2100 }
2101 
2102 static int check_pending_signals() {
2103   while (true) {
2104     for (int i = 0; i &lt; NSIG + 1; i++) {
2105       jint n = pending_signals[i];
2106       if (n &gt; 0 &amp;&amp; n == Atomic::cmpxchg(&amp;pending_signals[i], n, n - 1)) {
2107         return i;
2108       }
2109     }
2110     JavaThread *thread = JavaThread::current();
2111 
2112     ThreadBlockInVM tbivm(thread);
2113 
2114     bool threadIsSuspended;
2115     do {
2116       thread-&gt;set_suspend_equivalent();
2117       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
2118       sig_sem-&gt;wait();
2119 
2120       // were we externally suspended while we were waiting?
2121       threadIsSuspended = thread-&gt;handle_special_suspend_equivalent_condition();
2122       if (threadIsSuspended) {
2123         // The semaphore has been incremented, but while we were waiting
2124         // another thread suspended us. We don&#39;t want to continue running
2125         // while suspended because that would surprise the thread that
2126         // suspended us.
2127         sig_sem-&gt;signal();
2128 
2129         thread-&gt;java_suspend_self();
2130       }
2131     } while (threadIsSuspended);
2132   }
2133 }
2134 
2135 int os::signal_wait() {
2136   return check_pending_signals();
2137 }
2138 
2139 // Implicit OS exception handling
2140 
2141 LONG Handle_Exception(struct _EXCEPTION_POINTERS* exceptionInfo,
2142                       address handler) {
2143   JavaThread* thread = (JavaThread*) Thread::current_or_null();
2144   // Save pc in thread
2145 #ifdef _M_AMD64
2146   // Do not blow up if no thread info available.
2147   if (thread) {
2148     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Rip);
2149   }
2150   // Set pc to handler
2151   exceptionInfo-&gt;ContextRecord-&gt;Rip = (DWORD64)handler;
2152 #else
2153   // Do not blow up if no thread info available.
2154   if (thread) {
2155     thread-&gt;set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo-&gt;ContextRecord-&gt;Eip);
2156   }
2157   // Set pc to handler
2158   exceptionInfo-&gt;ContextRecord-&gt;Eip = (DWORD)(DWORD_PTR)handler;
2159 #endif
2160 
2161   // Continue the execution
2162   return EXCEPTION_CONTINUE_EXECUTION;
2163 }
2164 
2165 
2166 // Used for PostMortemDump
2167 extern &quot;C&quot; void safepoints();
2168 extern &quot;C&quot; void find(int x);
2169 extern &quot;C&quot; void events();
2170 
2171 // According to Windows API documentation, an illegal instruction sequence should generate
2172 // the 0xC000001C exception code. However, real world experience shows that occasionnaly
2173 // the execution of an illegal instruction can generate the exception code 0xC000001E. This
2174 // seems to be an undocumented feature of Win NT 4.0 (and probably other Windows systems).
2175 
2176 #define EXCEPTION_ILLEGAL_INSTRUCTION_2 0xC000001E
2177 
2178 // From &quot;Execution Protection in the Windows Operating System&quot; draft 0.35
2179 // Once a system header becomes available, the &quot;real&quot; define should be
2180 // included or copied here.
2181 #define EXCEPTION_INFO_EXEC_VIOLATION 0x08
2182 
2183 // Windows Vista/2008 heap corruption check
2184 #define EXCEPTION_HEAP_CORRUPTION        0xC0000374
2185 
2186 // All Visual C++ exceptions thrown from code generated by the Microsoft Visual
2187 // C++ compiler contain this error code. Because this is a compiler-generated
2188 // error, the code is not listed in the Win32 API header files.
2189 // The code is actually a cryptic mnemonic device, with the initial &quot;E&quot;
2190 // standing for &quot;exception&quot; and the final 3 bytes (0x6D7363) representing the
2191 // ASCII values of &quot;msc&quot;.
2192 
2193 #define EXCEPTION_UNCAUGHT_CXX_EXCEPTION    0xE06D7363
2194 
2195 #define def_excpt(val) { #val, (val) }
2196 
2197 static const struct { const char* name; uint number; } exceptlabels[] = {
2198     def_excpt(EXCEPTION_ACCESS_VIOLATION),
2199     def_excpt(EXCEPTION_DATATYPE_MISALIGNMENT),
2200     def_excpt(EXCEPTION_BREAKPOINT),
2201     def_excpt(EXCEPTION_SINGLE_STEP),
2202     def_excpt(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
2203     def_excpt(EXCEPTION_FLT_DENORMAL_OPERAND),
2204     def_excpt(EXCEPTION_FLT_DIVIDE_BY_ZERO),
2205     def_excpt(EXCEPTION_FLT_INEXACT_RESULT),
2206     def_excpt(EXCEPTION_FLT_INVALID_OPERATION),
2207     def_excpt(EXCEPTION_FLT_OVERFLOW),
2208     def_excpt(EXCEPTION_FLT_STACK_CHECK),
2209     def_excpt(EXCEPTION_FLT_UNDERFLOW),
2210     def_excpt(EXCEPTION_INT_DIVIDE_BY_ZERO),
2211     def_excpt(EXCEPTION_INT_OVERFLOW),
2212     def_excpt(EXCEPTION_PRIV_INSTRUCTION),
2213     def_excpt(EXCEPTION_IN_PAGE_ERROR),
2214     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION),
2215     def_excpt(EXCEPTION_ILLEGAL_INSTRUCTION_2),
2216     def_excpt(EXCEPTION_NONCONTINUABLE_EXCEPTION),
2217     def_excpt(EXCEPTION_STACK_OVERFLOW),
2218     def_excpt(EXCEPTION_INVALID_DISPOSITION),
2219     def_excpt(EXCEPTION_GUARD_PAGE),
2220     def_excpt(EXCEPTION_INVALID_HANDLE),
2221     def_excpt(EXCEPTION_UNCAUGHT_CXX_EXCEPTION),
2222     def_excpt(EXCEPTION_HEAP_CORRUPTION)
2223 };
2224 
2225 #undef def_excpt
2226 
2227 const char* os::exception_name(int exception_code, char *buf, size_t size) {
2228   uint code = static_cast&lt;uint&gt;(exception_code);
2229   for (uint i = 0; i &lt; ARRAY_SIZE(exceptlabels); ++i) {
2230     if (exceptlabels[i].number == code) {
2231       jio_snprintf(buf, size, &quot;%s&quot;, exceptlabels[i].name);
2232       return buf;
2233     }
2234   }
2235 
2236   return NULL;
2237 }
2238 
2239 //-----------------------------------------------------------------------------
2240 LONG Handle_IDiv_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2241   // handle exception caused by idiv; should only happen for -MinInt/-1
2242   // (division by zero is handled explicitly)
2243 #ifdef  _M_AMD64
2244   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2245   address pc = (address)ctx-&gt;Rip;
2246   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; pc[1] == 0xF7 || pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2247   assert(pc[0] &gt;= Assembler::REX &amp;&amp; pc[0] &lt;= Assembler::REX_WRXB &amp;&amp; (pc[2] &amp; ~0x7) == 0xF8 || (pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2248   if (pc[0] == 0xF7) {
2249     // set correct result values and continue after idiv instruction
2250     ctx-&gt;Rip = (DWORD64)pc + 2;        // idiv reg, reg  is 2 bytes
2251   } else {
2252     ctx-&gt;Rip = (DWORD64)pc + 3;        // REX idiv reg, reg  is 3 bytes
2253   }
2254   // Do not set ctx-&gt;Rax as it already contains the correct value (either 32 or 64 bit, depending on the operation)
2255   // this is the case because the exception only happens for -MinValue/-1 and -MinValue is always in rax because of the
2256   // idiv opcode (0xF7).
2257   ctx-&gt;Rdx = (DWORD)0;             // remainder
2258   // Continue the execution
2259 #else
2260   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2261   address pc = (address)ctx-&gt;Eip;
2262   assert(pc[0] == 0xF7, &quot;not an idiv opcode&quot;);
2263   assert((pc[1] &amp; ~0x7) == 0xF8, &quot;cannot handle non-register operands&quot;);
2264   assert(ctx-&gt;Eax == min_jint, &quot;unexpected idiv exception&quot;);
2265   // set correct result values and continue after idiv instruction
2266   ctx-&gt;Eip = (DWORD)pc + 2;        // idiv reg, reg  is 2 bytes
2267   ctx-&gt;Eax = (DWORD)min_jint;      // result
2268   ctx-&gt;Edx = (DWORD)0;             // remainder
2269   // Continue the execution
2270 #endif
2271   return EXCEPTION_CONTINUE_EXECUTION;
2272 }
2273 
2274 //-----------------------------------------------------------------------------
2275 LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {
2276   PCONTEXT ctx = exceptionInfo-&gt;ContextRecord;
2277 #ifndef  _WIN64
2278   // handle exception caused by native method modifying control word
2279   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2280 
2281   switch (exception_code) {
2282   case EXCEPTION_FLT_DENORMAL_OPERAND:
2283   case EXCEPTION_FLT_DIVIDE_BY_ZERO:
2284   case EXCEPTION_FLT_INEXACT_RESULT:
2285   case EXCEPTION_FLT_INVALID_OPERATION:
2286   case EXCEPTION_FLT_OVERFLOW:
2287   case EXCEPTION_FLT_STACK_CHECK:
2288   case EXCEPTION_FLT_UNDERFLOW:
2289     jint fp_control_word = (* (jint*) StubRoutines::addr_fpu_cntrl_wrd_std());
2290     if (fp_control_word != ctx-&gt;FloatSave.ControlWord) {
2291       // Restore FPCW and mask out FLT exceptions
2292       ctx-&gt;FloatSave.ControlWord = fp_control_word | 0xffffffc0;
2293       // Mask out pending FLT exceptions
2294       ctx-&gt;FloatSave.StatusWord &amp;=  0xffffff00;
2295       return EXCEPTION_CONTINUE_EXECUTION;
2296     }
2297   }
2298 
2299   if (prev_uef_handler != NULL) {
2300     // We didn&#39;t handle this exception so pass it to the previous
2301     // UnhandledExceptionFilter.
2302     return (prev_uef_handler)(exceptionInfo);
2303   }
2304 #else // !_WIN64
2305   // On Windows, the mxcsr control bits are non-volatile across calls
2306   // See also CR 6192333
2307   //
2308   jint MxCsr = INITIAL_MXCSR;
2309   // we can&#39;t use StubRoutines::addr_mxcsr_std()
2310   // because in Win64 mxcsr is not saved there
2311   if (MxCsr != ctx-&gt;MxCsr) {
2312     ctx-&gt;MxCsr = MxCsr;
2313     return EXCEPTION_CONTINUE_EXECUTION;
2314   }
2315 #endif // !_WIN64
2316 
2317   return EXCEPTION_CONTINUE_SEARCH;
2318 }
2319 
2320 static inline void report_error(Thread* t, DWORD exception_code,
2321                                 address addr, void* siginfo, void* context) {
2322   VMError::report_and_die(t, exception_code, addr, siginfo, context);
2323 
2324   // If UseOsErrorReporting, this will return here and save the error file
2325   // somewhere where we can find it in the minidump.
2326 }
2327 
2328 bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,
2329         struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {
2330   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2331   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2332   if (Interpreter::contains(pc)) {
2333     *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2334     if (!fr-&gt;is_first_java_frame()) {
2335       // get_frame_at_stack_banging_point() is only called when we
2336       // have well defined stacks so java_sender() calls do not need
2337       // to assert safe_for_sender() first.
2338       *fr = fr-&gt;java_sender();
2339     }
2340   } else {
2341     // more complex code with compiled code
2342     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
2343     CodeBlob* cb = CodeCache::find_blob(pc);
2344     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
2345       // Not sure where the pc points to, fallback to default
2346       // stack overflow handling
2347       return false;
2348     } else {
2349       *fr = os::fetch_frame_from_context((void*)exceptionInfo-&gt;ContextRecord);
2350       // in compiled code, the stack banging is performed just after the return pc
2351       // has been pushed on the stack
2352       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));
2353       if (!fr-&gt;is_java_frame()) {
2354         // See java_sender() comment above.
2355         *fr = fr-&gt;java_sender();
2356       }
2357     }
2358   }
2359   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
2360   return true;
2361 }
2362 
2363 #if INCLUDE_AOT
2364 LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2365   PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2366   address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2367   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2368 
2369   // Handle the case where we get an implicit exception in AOT generated
2370   // code.  AOT DLL&#39;s loaded are not registered for structured exceptions.
2371   // If the exception occurred in the codeCache or AOT code, pass control
2372   // to our normal exception handler.
2373   CodeBlob* cb = CodeCache::find_blob(pc);
2374   if (cb != NULL) {
2375     return topLevelExceptionFilter(exceptionInfo);
2376   }
2377 
2378   return EXCEPTION_CONTINUE_SEARCH;
2379 }
2380 #endif
2381 
2382 //-----------------------------------------------------------------------------
2383 LONG WINAPI topLevelExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2384   if (InterceptOSException) return EXCEPTION_CONTINUE_SEARCH;
2385   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2386 #ifdef _M_AMD64
2387   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Rip;
2388 #else
2389   address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2390 #endif
2391   Thread* t = Thread::current_or_null_safe();
2392 
2393   // Handle SafeFetch32 and SafeFetchN exceptions.
2394   if (StubRoutines::is_safefetch_fault(pc)) {
2395     return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));
2396   }
2397 
2398 #ifndef _WIN64
2399   // Execution protection violation - win32 running on AMD64 only
2400   // Handled first to avoid misdiagnosis as a &quot;normal&quot; access violation;
2401   // This is safe to do because we have a new/unique ExceptionInformation
2402   // code for this condition.
2403   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2404     PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2405     int exception_subcode = (int) exceptionRecord-&gt;ExceptionInformation[0];
2406     address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2407 
2408     if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {
2409       int page_size = os::vm_page_size();
2410 
2411       // Make sure the pc and the faulting address are sane.
2412       //
2413       // If an instruction spans a page boundary, and the page containing
2414       // the beginning of the instruction is executable but the following
2415       // page is not, the pc and the faulting address might be slightly
2416       // different - we still want to unguard the 2nd page in this case.
2417       //
2418       // 15 bytes seems to be a (very) safe value for max instruction size.
2419       bool pc_is_near_addr =
2420         (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
2421       bool instr_spans_page_boundary =
2422         (align_down((intptr_t) pc ^ (intptr_t) addr,
2423                          (intptr_t) page_size) &gt; 0);
2424 
2425       if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
2426         static volatile address last_addr =
2427           (address) os::non_memory_address_word();
2428 
2429         // In conservative mode, don&#39;t unguard unless the address is in the VM
2430         if (UnguardOnExecutionViolation &gt; 0 &amp;&amp; addr != last_addr &amp;&amp;
2431             (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
2432 
2433           // Set memory to RWX and retry
2434           address page_start = align_down(addr, page_size);
2435           bool res = os::protect_memory((char*) page_start, page_size,
2436                                         os::MEM_PROT_RWX);
2437 
2438           log_debug(os)(&quot;Execution protection violation &quot;
2439                         &quot;at &quot; INTPTR_FORMAT
2440                         &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(addr),
2441                         p2i(page_start), (res ? &quot;success&quot; : os::strerror(errno)));
2442 
2443           // Set last_addr so if we fault again at the same address, we don&#39;t
2444           // end up in an endless loop.
2445           //
2446           // There are two potential complications here.  Two threads trapping
2447           // at the same address at the same time could cause one of the
2448           // threads to think it already unguarded, and abort the VM.  Likely
2449           // very rare.
2450           //
2451           // The other race involves two threads alternately trapping at
2452           // different addresses and failing to unguard the page, resulting in
2453           // an endless loop.  This condition is probably even more unlikely
2454           // than the first.
2455           //
2456           // Although both cases could be avoided by using locks or thread
2457           // local last_addr, these solutions are unnecessary complication:
2458           // this handler is a best-effort safety net, not a complete solution.
2459           // It is disabled by default and should only be used as a workaround
2460           // in case we missed any no-execute-unsafe VM code.
2461 
2462           last_addr = addr;
2463 
2464           return EXCEPTION_CONTINUE_EXECUTION;
2465         }
2466       }
2467 
2468       // Last unguard failed or not unguarding
2469       tty-&gt;print_raw_cr(&quot;Execution protection violation&quot;);
2470       report_error(t, exception_code, addr, exceptionInfo-&gt;ExceptionRecord,
2471                    exceptionInfo-&gt;ContextRecord);
2472       return EXCEPTION_CONTINUE_SEARCH;
2473     }
2474   }
2475 #endif // _WIN64
2476 
2477   if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &amp;&amp;
2478       VM_Version::is_cpuinfo_segv_addr(pc)) {
2479     // Verify that OS save/restore AVX registers.
2480     return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr());
2481   }
2482 
2483   if (t != NULL &amp;&amp; t-&gt;is_Java_thread()) {
2484     JavaThread* thread = (JavaThread*) t;
2485     bool in_java = thread-&gt;thread_state() == _thread_in_Java;
2486 
2487     // Handle potential stack overflows up front.
2488     if (exception_code == EXCEPTION_STACK_OVERFLOW) {
2489       if (thread-&gt;stack_guards_enabled()) {
2490         if (in_java) {
2491           frame fr;
2492           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2493           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2494           if (os::win32::get_frame_at_stack_banging_point(thread, exceptionInfo, pc, &amp;fr)) {
2495             assert(fr.is_java_frame(), &quot;Must be a Java frame&quot;);
2496             SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
2497           }
2498         }
2499         // Yellow zone violation.  The o/s has unprotected the first yellow
2500         // zone page for us.  Note:  must call disable_stack_yellow_zone to
2501         // update the enabled status, even if the zone contains only one page.
2502         assert(thread-&gt;thread_state() != _thread_in_vm, &quot;Undersized StackShadowPages&quot;);
2503         thread-&gt;disable_stack_yellow_reserved_zone();
2504         // If not in java code, return and hope for the best.
2505         return in_java
2506             ? Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW))
2507             :  EXCEPTION_CONTINUE_EXECUTION;
2508       } else {
2509         // Fatal red zone violation.
2510         thread-&gt;disable_stack_red_zone();
2511         tty-&gt;print_raw_cr(&quot;An unrecoverable stack overflow has occurred.&quot;);
2512         report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2513                       exceptionInfo-&gt;ContextRecord);
2514         return EXCEPTION_CONTINUE_SEARCH;
2515       }
2516     } else if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2517       // Either stack overflow or null pointer exception.
2518       if (in_java) {
2519         PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2520         address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2521         address stack_end = thread-&gt;stack_end();
2522         if (addr &lt; stack_end &amp;&amp; addr &gt;= stack_end - os::vm_page_size()) {
2523           // Stack overflow.
2524           assert(!os::uses_stack_guard_pages(),
2525                  &quot;should be caught by red zone code above.&quot;);
2526           return Handle_Exception(exceptionInfo,
2527                                   SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW));
2528         }
2529         // Check for safepoint polling and implicit null
2530         // We only expect null pointers in the stubs (vtable)
2531         // the rest are checked explicitly now.
2532         CodeBlob* cb = CodeCache::find_blob(pc);
2533         if (cb != NULL) {
2534           if (os::is_poll_address(addr)) {
2535             address stub = SharedRuntime::get_poll_stub(pc);
2536             return Handle_Exception(exceptionInfo, stub);
2537           }
2538         }
2539         {
2540 #ifdef _WIN64
2541           // If it&#39;s a legal stack address map the entire region in
2542           //
2543           PEXCEPTION_RECORD exceptionRecord = exceptionInfo-&gt;ExceptionRecord;
2544           address addr = (address) exceptionRecord-&gt;ExceptionInformation[1];
2545           if (thread-&gt;is_in_usable_stack(addr)) {
2546             addr = (address)((uintptr_t)addr &amp;
2547                              (~((uintptr_t)os::vm_page_size() - (uintptr_t)1)));
2548             os::commit_memory((char *)addr, thread-&gt;stack_base() - addr,
2549                               !ExecMem);
2550             return EXCEPTION_CONTINUE_EXECUTION;
2551           } else
2552 #endif
2553           {
2554             // Null pointer exception.
2555             if (MacroAssembler::uses_implicit_null_check((void*)addr)) {
2556               address stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
2557               if (stub != NULL) return Handle_Exception(exceptionInfo, stub);
2558             }
2559             report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2560                          exceptionInfo-&gt;ContextRecord);
2561             return EXCEPTION_CONTINUE_SEARCH;
2562           }
2563         }
2564       }
2565 
2566 #ifdef _WIN64
2567       // Special care for fast JNI field accessors.
2568       // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks
2569       // in and the heap gets shrunk before the field access.
2570       if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2571         address addr = JNI_FastGetField::find_slowcase_pc(pc);
2572         if (addr != (address)-1) {
2573           return Handle_Exception(exceptionInfo, addr);
2574         }
2575       }
2576 #endif
2577 
2578       // Stack overflow or null pointer exception in native code.
2579       report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2580                    exceptionInfo-&gt;ContextRecord);
2581       return EXCEPTION_CONTINUE_SEARCH;
2582     } // /EXCEPTION_ACCESS_VIOLATION
2583     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
2584 
2585     if (exception_code == EXCEPTION_IN_PAGE_ERROR) {
2586       CompiledMethod* nm = NULL;
2587       JavaThread* thread = (JavaThread*)t;
2588       if (in_java) {
2589         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
2590         nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
2591       }
2592 
2593       bool is_unsafe_arraycopy = (thread-&gt;thread_state() == _thread_in_native || in_java) &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
2594       if (((thread-&gt;thread_state() == _thread_in_vm ||
2595            thread-&gt;thread_state() == _thread_in_native ||
2596            is_unsafe_arraycopy) &amp;&amp;
2597           thread-&gt;doing_unsafe_access()) ||
2598           (nm != NULL &amp;&amp; nm-&gt;has_unsafe_access())) {
2599         address next_pc =  Assembler::locate_next_instruction(pc);
2600         if (is_unsafe_arraycopy) {
2601           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
2602         }
2603         return Handle_Exception(exceptionInfo, SharedRuntime::handle_unsafe_access(thread, next_pc));
2604       }
2605     }
2606 
2607     if (in_java) {
2608       switch (exception_code) {
2609       case EXCEPTION_INT_DIVIDE_BY_ZERO:
2610         return Handle_Exception(exceptionInfo, SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO));
2611 
2612       case EXCEPTION_INT_OVERFLOW:
2613         return Handle_IDiv_Exception(exceptionInfo);
2614 
2615       } // switch
2616     }
2617     if (((thread-&gt;thread_state() == _thread_in_Java) ||
2618          (thread-&gt;thread_state() == _thread_in_native)) &amp;&amp;
2619          exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {
2620       LONG result=Handle_FLT_Exception(exceptionInfo);
2621       if (result==EXCEPTION_CONTINUE_EXECUTION) return result;
2622     }
2623   }
2624 
2625   if (exception_code != EXCEPTION_BREAKPOINT) {
2626     report_error(t, exception_code, pc, exceptionInfo-&gt;ExceptionRecord,
2627                  exceptionInfo-&gt;ContextRecord);
2628   }
2629   return EXCEPTION_CONTINUE_SEARCH;
2630 }
2631 
2632 #ifndef _WIN64
2633 // Special care for fast JNI accessors.
2634 // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in and
2635 // the heap gets shrunk before the field access.
2636 // Need to install our own structured exception handler since native code may
2637 // install its own.
2638 LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {
2639   DWORD exception_code = exceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode;
2640   if (exception_code == EXCEPTION_ACCESS_VIOLATION) {
2641     address pc = (address) exceptionInfo-&gt;ContextRecord-&gt;Eip;
2642     address addr = JNI_FastGetField::find_slowcase_pc(pc);
2643     if (addr != (address)-1) {
2644       return Handle_Exception(exceptionInfo, addr);
2645     }
2646   }
2647   return EXCEPTION_CONTINUE_SEARCH;
2648 }
2649 
2650 #define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \
2651   Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \
2652                                                      jobject obj,           \
2653                                                      jfieldID fieldID) {    \
2654     __try {                                                                 \
2655       return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \
2656                                                                  obj,       \
2657                                                                  fieldID);  \
2658     } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \
2659                                               _exception_info())) {         \
2660     }                                                                       \
2661     return 0;                                                               \
2662   }
2663 
2664 DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)
2665 DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)
2666 DEFINE_FAST_GETFIELD(jchar,    char,   Char)
2667 DEFINE_FAST_GETFIELD(jshort,   short,  Short)
2668 DEFINE_FAST_GETFIELD(jint,     int,    Int)
2669 DEFINE_FAST_GETFIELD(jlong,    long,   Long)
2670 DEFINE_FAST_GETFIELD(jfloat,   float,  Float)
2671 DEFINE_FAST_GETFIELD(jdouble,  double, Double)
2672 
2673 address os::win32::fast_jni_accessor_wrapper(BasicType type) {
2674   switch (type) {
2675   case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;
2676   case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;
2677   case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;
2678   case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;
2679   case T_INT:     return (address)jni_fast_GetIntField_wrapper;
2680   case T_LONG:    return (address)jni_fast_GetLongField_wrapper;
2681   case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;
2682   case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;
2683   default:        ShouldNotReachHere();
2684   }
2685   return (address)-1;
2686 }
2687 #endif
2688 
2689 // Virtual Memory
2690 
2691 int os::vm_page_size() { return os::win32::vm_page_size(); }
2692 int os::vm_allocation_granularity() {
2693   return os::win32::vm_allocation_granularity();
2694 }
2695 
2696 // Windows large page support is available on Windows 2003. In order to use
2697 // large page memory, the administrator must first assign additional privilege
2698 // to the user:
2699 //   + select Control Panel -&gt; Administrative Tools -&gt; Local Security Policy
2700 //   + select Local Policies -&gt; User Rights Assignment
2701 //   + double click &quot;Lock pages in memory&quot;, add users and/or groups
2702 //   + reboot
2703 // Note the above steps are needed for administrator as well, as administrators
2704 // by default do not have the privilege to lock pages in memory.
2705 //
2706 // Note about Windows 2003: although the API supports committing large page
2707 // memory on a page-by-page basis and VirtualAlloc() returns success under this
2708 // scenario, I found through experiment it only uses large page if the entire
2709 // memory region is reserved and committed in a single VirtualAlloc() call.
2710 // This makes Windows large page support more or less like Solaris ISM, in
2711 // that the entire heap must be committed upfront. This probably will change
2712 // in the future, if so the code below needs to be revisited.
2713 
2714 #ifndef MEM_LARGE_PAGES
2715   #define MEM_LARGE_PAGES 0x20000000
2716 #endif
2717 
2718 static HANDLE    _hProcess;
2719 static HANDLE    _hToken;
2720 
2721 // Container for NUMA node list info
2722 class NUMANodeListHolder {
2723  private:
2724   int *_numa_used_node_list;  // allocated below
2725   int _numa_used_node_count;
2726 
2727   void free_node_list() {
2728     FREE_C_HEAP_ARRAY(int, _numa_used_node_list);
2729   }
2730 
2731  public:
2732   NUMANodeListHolder() {
2733     _numa_used_node_count = 0;
2734     _numa_used_node_list = NULL;
2735     // do rest of initialization in build routine (after function pointers are set up)
2736   }
2737 
2738   ~NUMANodeListHolder() {
2739     free_node_list();
2740   }
2741 
2742   bool build() {
2743     DWORD_PTR proc_aff_mask;
2744     DWORD_PTR sys_aff_mask;
2745     if (!GetProcessAffinityMask(GetCurrentProcess(), &amp;proc_aff_mask, &amp;sys_aff_mask)) return false;
2746     ULONG highest_node_number;
2747     if (!GetNumaHighestNodeNumber(&amp;highest_node_number)) return false;
2748     free_node_list();
2749     _numa_used_node_list = NEW_C_HEAP_ARRAY(int, highest_node_number + 1, mtInternal);
2750     for (unsigned int i = 0; i &lt;= highest_node_number; i++) {
2751       ULONGLONG proc_mask_numa_node;
2752       if (!GetNumaNodeProcessorMask(i, &amp;proc_mask_numa_node)) return false;
2753       if ((proc_aff_mask &amp; proc_mask_numa_node)!=0) {
2754         _numa_used_node_list[_numa_used_node_count++] = i;
2755       }
2756     }
2757     return (_numa_used_node_count &gt; 1);
2758   }
2759 
2760   int get_count() { return _numa_used_node_count; }
2761   int get_node_list_entry(int n) {
2762     // for indexes out of range, returns -1
2763     return (n &lt; _numa_used_node_count ? _numa_used_node_list[n] : -1);
2764   }
2765 
2766 } numa_node_list_holder;
2767 
2768 
2769 
2770 static size_t _large_page_size = 0;
2771 
2772 static bool request_lock_memory_privilege() {
2773   _hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
2774                           os::current_process_id());
2775 
2776   LUID luid;
2777   if (_hProcess != NULL &amp;&amp;
2778       OpenProcessToken(_hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;_hToken) &amp;&amp;
2779       LookupPrivilegeValue(NULL, &quot;SeLockMemoryPrivilege&quot;, &amp;luid)) {
2780 
2781     TOKEN_PRIVILEGES tp;
2782     tp.PrivilegeCount = 1;
2783     tp.Privileges[0].Luid = luid;
2784     tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
2785 
2786     // AdjustTokenPrivileges() may return TRUE even when it couldn&#39;t change the
2787     // privilege. Check GetLastError() too. See MSDN document.
2788     if (AdjustTokenPrivileges(_hToken, false, &amp;tp, sizeof(tp), NULL, NULL) &amp;&amp;
2789         (GetLastError() == ERROR_SUCCESS)) {
2790       return true;
2791     }
2792   }
2793 
2794   return false;
2795 }
2796 
2797 static void cleanup_after_large_page_init() {
2798   if (_hProcess) CloseHandle(_hProcess);
2799   _hProcess = NULL;
2800   if (_hToken) CloseHandle(_hToken);
2801   _hToken = NULL;
2802 }
2803 
2804 static bool numa_interleaving_init() {
2805   bool success = false;
2806   bool use_numa_interleaving_specified = !FLAG_IS_DEFAULT(UseNUMAInterleaving);
2807 
2808   // print a warning if UseNUMAInterleaving flag is specified on command line
2809   bool warn_on_failure = use_numa_interleaving_specified;
2810 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2811 
2812   // NUMAInterleaveGranularity cannot be less than vm_allocation_granularity (or _large_page_size if using large pages)
2813   size_t min_interleave_granularity = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2814   NUMAInterleaveGranularity = align_up(NUMAInterleaveGranularity, min_interleave_granularity);
2815 
2816   if (numa_node_list_holder.build()) {
2817     if (log_is_enabled(Debug, os, cpu)) {
2818       Log(os, cpu) log;
2819       log.debug(&quot;NUMA UsedNodeCount=%d, namely &quot;, numa_node_list_holder.get_count());
2820       for (int i = 0; i &lt; numa_node_list_holder.get_count(); i++) {
2821         log.debug(&quot;  %d &quot;, numa_node_list_holder.get_node_list_entry(i));
2822       }
2823     }
2824     success = true;
2825   } else {
2826     WARN(&quot;Process does not cover multiple NUMA nodes.&quot;);
2827   }
2828   if (!success) {
2829     if (use_numa_interleaving_specified) WARN(&quot;...Ignoring UseNUMAInterleaving flag.&quot;);
2830   }
2831   return success;
2832 #undef WARN
2833 }
2834 
2835 // this routine is used whenever we need to reserve a contiguous VA range
2836 // but we need to make separate VirtualAlloc calls for each piece of the range
2837 // Reasons for doing this:
2838 //  * UseLargePagesIndividualAllocation was set (normally only needed on WS2003 but possible to be set otherwise)
2839 //  * UseNUMAInterleaving requires a separate node for each piece
2840 static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,
2841                                          DWORD prot,
2842                                          bool should_inject_error = false) {
2843   char * p_buf;
2844   // note: at setup time we guaranteed that NUMAInterleaveGranularity was aligned up to a page size
2845   size_t page_size = UseLargePages ? _large_page_size : os::vm_allocation_granularity();
2846   size_t chunk_size = UseNUMAInterleaving ? NUMAInterleaveGranularity : page_size;
2847 
2848   // first reserve enough address space in advance since we want to be
2849   // able to break a single contiguous virtual address range into multiple
2850   // large page commits but WS2003 does not allow reserving large page space
2851   // so we just use 4K pages for reserve, this gives us a legal contiguous
2852   // address space. then we will deallocate that reservation, and re alloc
2853   // using large pages
2854   const size_t size_of_reserve = bytes + chunk_size;
2855   if (bytes &gt; size_of_reserve) {
2856     // Overflowed.
2857     return NULL;
2858   }
2859   p_buf = (char *) VirtualAlloc(addr,
2860                                 size_of_reserve,  // size of Reserve
2861                                 MEM_RESERVE,
2862                                 PAGE_READWRITE);
2863   // If reservation failed, return NULL
2864   if (p_buf == NULL) return NULL;
2865   MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);
2866   os::release_memory(p_buf, bytes + chunk_size);
2867 
2868   // we still need to round up to a page boundary (in case we are using large pages)
2869   // but not to a chunk boundary (in case InterleavingGranularity doesn&#39;t align with page size)
2870   // instead we handle this in the bytes_to_rq computation below
2871   p_buf = align_up(p_buf, page_size);
2872 
2873   // now go through and allocate one chunk at a time until all bytes are
2874   // allocated
2875   size_t  bytes_remaining = bytes;
2876   // An overflow of align_up() would have been caught above
2877   // in the calculation of size_of_reserve.
2878   char * next_alloc_addr = p_buf;
2879   HANDLE hProc = GetCurrentProcess();
2880 
2881 #ifdef ASSERT
2882   // Variable for the failure injection
2883   int ran_num = os::random();
2884   size_t fail_after = ran_num % bytes;
2885 #endif
2886 
2887   int count=0;
2888   while (bytes_remaining) {
2889     // select bytes_to_rq to get to the next chunk_size boundary
2890 
2891     size_t bytes_to_rq = MIN2(bytes_remaining, chunk_size - ((size_t)next_alloc_addr % chunk_size));
2892     // Note allocate and commit
2893     char * p_new;
2894 
2895 #ifdef ASSERT
2896     bool inject_error_now = should_inject_error &amp;&amp; (bytes_remaining &lt;= fail_after);
2897 #else
2898     const bool inject_error_now = false;
2899 #endif
2900 
2901     if (inject_error_now) {
2902       p_new = NULL;
2903     } else {
2904       if (!UseNUMAInterleaving) {
2905         p_new = (char *) VirtualAlloc(next_alloc_addr,
2906                                       bytes_to_rq,
2907                                       flags,
2908                                       prot);
2909       } else {
2910         // get the next node to use from the used_node_list
2911         assert(numa_node_list_holder.get_count() &gt; 0, &quot;Multiple NUMA nodes expected&quot;);
2912         DWORD node = numa_node_list_holder.get_node_list_entry(count % numa_node_list_holder.get_count());
2913         p_new = (char *)VirtualAllocExNuma(hProc, next_alloc_addr, bytes_to_rq, flags, prot, node);
2914       }
2915     }
2916 
2917     if (p_new == NULL) {
2918       // Free any allocated pages
2919       if (next_alloc_addr &gt; p_buf) {
2920         // Some memory was committed so release it.
2921         size_t bytes_to_release = bytes - bytes_remaining;
2922         // NMT has yet to record any individual blocks, so it
2923         // need to create a dummy &#39;reserve&#39; record to match
2924         // the release.
2925         MemTracker::record_virtual_memory_reserve((address)p_buf,
2926                                                   bytes_to_release, CALLER_PC);
2927         os::release_memory(p_buf, bytes_to_release);
2928       }
2929 #ifdef ASSERT
2930       if (should_inject_error) {
2931         log_develop_debug(pagesize)(&quot;Reserving pages individually failed.&quot;);
2932       }
2933 #endif
2934       return NULL;
2935     }
2936 
2937     bytes_remaining -= bytes_to_rq;
2938     next_alloc_addr += bytes_to_rq;
2939     count++;
2940   }
2941   // Although the memory is allocated individually, it is returned as one.
2942   // NMT records it as one block.
2943   if ((flags &amp; MEM_COMMIT) != 0) {
2944     MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);
2945   } else {
2946     MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);
2947   }
2948 
2949   // made it this far, success
2950   return p_buf;
2951 }
2952 
2953 
2954 
2955 void os::large_page_init() {
2956   if (!UseLargePages) return;
2957 
2958   // print a warning if any large page related flag is specified on command line
2959   bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages) ||
2960                          !FLAG_IS_DEFAULT(LargePageSizeInBytes);
2961   bool success = false;
2962 
2963 #define WARN(msg) if (warn_on_failure) { warning(msg); }
2964   if (request_lock_memory_privilege()) {
2965     size_t s = GetLargePageMinimum();
2966     if (s) {
2967 #if defined(IA32) || defined(AMD64)
2968       if (s &gt; 4*M || LargePageSizeInBytes &gt; 4*M) {
2969         WARN(&quot;JVM cannot use large pages bigger than 4mb.&quot;);
2970       } else {
2971 #endif
2972         if (LargePageSizeInBytes &amp;&amp; LargePageSizeInBytes % s == 0) {
2973           _large_page_size = LargePageSizeInBytes;
2974         } else {
2975           _large_page_size = s;
2976         }
2977         success = true;
2978 #if defined(IA32) || defined(AMD64)
2979       }
2980 #endif
2981     } else {
2982       WARN(&quot;Large page is not supported by the processor.&quot;);
2983     }
2984   } else {
2985     WARN(&quot;JVM cannot use large page memory because it does not have enough privilege to lock pages in memory.&quot;);
2986   }
2987 #undef WARN
2988 
2989   const size_t default_page_size = (size_t) vm_page_size();
2990   if (success &amp;&amp; _large_page_size &gt; default_page_size) {
2991     _page_sizes[0] = _large_page_size;
2992     _page_sizes[1] = default_page_size;
2993     _page_sizes[2] = 0;
2994   }
2995 
2996   cleanup_after_large_page_init();
2997   UseLargePages = success;
2998 }
2999 
3000 int os::create_file_for_heap(const char* dir) {
3001 
3002   const char name_template[] = &quot;/jvmheap.XXXXXX&quot;;
3003 
3004   size_t fullname_len = strlen(dir) + strlen(name_template);
3005   char *fullname = (char*)os::malloc(fullname_len + 1, mtInternal);
3006   if (fullname == NULL) {
3007     vm_exit_during_initialization(err_msg(&quot;Malloc failed during creation of backing file for heap (%s)&quot;, os::strerror(errno)));
3008     return -1;
3009   }
3010   int n = snprintf(fullname, fullname_len + 1, &quot;%s%s&quot;, dir, name_template);
3011   assert((size_t)n == fullname_len, &quot;Unexpected number of characters in string&quot;);
3012 
3013   os::native_path(fullname);
3014 
3015   char *path = _mktemp(fullname);
3016   if (path == NULL) {
3017     warning(&quot;_mktemp could not create file name from template %s (%s)&quot;, fullname, os::strerror(errno));
3018     os::free(fullname);
3019     return -1;
3020   }
3021 
3022   int fd = _open(path, O_RDWR | O_CREAT | O_TEMPORARY | O_EXCL, S_IWRITE | S_IREAD);
3023 
3024   os::free(fullname);
3025   if (fd &lt; 0) {
3026     warning(&quot;Problem opening file for heap (%s)&quot;, os::strerror(errno));
3027     return -1;
3028   }
3029   return fd;
3030 }
3031 
3032 // If &#39;base&#39; is not NULL, function will return NULL if it cannot get &#39;base&#39;
3033 char* os::map_memory_to_file(char* base, size_t size, int fd) {
3034   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3035 
3036   HANDLE fh = (HANDLE)_get_osfhandle(fd);
3037 #ifdef _LP64
3038   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3039     (DWORD)(size &gt;&gt; 32), (DWORD)(size &amp; 0xFFFFFFFF), NULL);
3040 #else
3041   HANDLE fileMapping = CreateFileMapping(fh, NULL, PAGE_READWRITE,
3042     0, (DWORD)size, NULL);
3043 #endif
3044   if (fileMapping == NULL) {
3045     if (GetLastError() == ERROR_DISK_FULL) {
3046       vm_exit_during_initialization(err_msg(&quot;Could not allocate sufficient disk space for Java heap&quot;));
3047     }
3048     else {
3049       vm_exit_during_initialization(err_msg(&quot;Error in mapping Java heap at the given filesystem directory&quot;));
3050     }
3051 
3052     return NULL;
3053   }
3054 
3055   LPVOID addr = MapViewOfFileEx(fileMapping, FILE_MAP_WRITE, 0, 0, size, base);
3056 
3057   CloseHandle(fileMapping);
3058 
3059   return (char*)addr;
3060 }
3061 
3062 char* os::replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd) {
3063   assert(fd != -1, &quot;File descriptor is not valid&quot;);
3064   assert(base != NULL, &quot;Base address cannot be NULL&quot;);
3065 
3066   release_memory(base, size);
3067   return map_memory_to_file(base, size, fd);
3068 }
3069 
3070 // On win32, one cannot release just a part of reserved memory, it&#39;s an
3071 // all or nothing deal.  When we split a reservation, we must break the
3072 // reservation into two reservations.
3073 void os::pd_split_reserved_memory(char *base, size_t size, size_t split,
3074                                   bool realloc) {
3075   if (size &gt; 0) {
3076     release_memory(base, size);
3077     if (realloc) {
3078       reserve_memory(split, base);
3079     }
3080     if (size != split) {
3081       reserve_memory(size - split, base + split);
3082     }
3083   }
3084 }
3085 
3086 // Multiple threads can race in this code but it&#39;s not possible to unmap small sections of
3087 // virtual space to get requested alignment, like posix-like os&#39;s.
3088 // Windows prevents multiple thread from remapping over each other so this loop is thread-safe.
3089 char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {
3090   assert((alignment &amp; (os::vm_allocation_granularity() - 1)) == 0,
3091          &quot;Alignment must be a multiple of allocation granularity (page size)&quot;);
3092   assert((size &amp; (alignment -1)) == 0, &quot;size must be &#39;alignment&#39; aligned&quot;);
3093 
3094   size_t extra_size = size + alignment;
3095   assert(extra_size &gt;= size, &quot;overflow, size is too large to allow alignment&quot;);
3096 
3097   char* aligned_base = NULL;
3098 
3099   do {
3100     char* extra_base = os::reserve_memory(extra_size, NULL, alignment, file_desc);
3101     if (extra_base == NULL) {
3102       return NULL;
3103     }
3104     // Do manual alignment
3105     aligned_base = align_up(extra_base, alignment);
3106 
3107     if (file_desc != -1) {
3108       os::unmap_memory(extra_base, extra_size);
3109     } else {
3110       os::release_memory(extra_base, extra_size);
3111     }
3112 
3113     aligned_base = os::reserve_memory(size, aligned_base, 0, file_desc);
3114 
3115   } while (aligned_base == NULL);
3116 
3117   return aligned_base;
3118 }
3119 
3120 char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
3121   assert((size_t)addr % os::vm_allocation_granularity() == 0,
3122          &quot;reserve alignment&quot;);
3123   assert(bytes % os::vm_page_size() == 0, &quot;reserve page size&quot;);
3124   char* res;
3125   // note that if UseLargePages is on, all the areas that require interleaving
3126   // will go thru reserve_memory_special rather than thru here.
3127   bool use_individual = (UseNUMAInterleaving &amp;&amp; !UseLargePages);
3128   if (!use_individual) {
3129     res = (char*)VirtualAlloc(addr, bytes, MEM_RESERVE, PAGE_READWRITE);
3130   } else {
3131     elapsedTimer reserveTimer;
3132     if (Verbose &amp;&amp; PrintMiscellaneous) reserveTimer.start();
3133     // in numa interleaving, we have to allocate pages individually
3134     // (well really chunks of NUMAInterleaveGranularity size)
3135     res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);
3136     if (res == NULL) {
3137       warning(&quot;NUMA page allocation failed&quot;);
3138     }
3139     if (Verbose &amp;&amp; PrintMiscellaneous) {
3140       reserveTimer.stop();
3141       tty-&gt;print_cr(&quot;reserve_memory of %Ix bytes took &quot; JLONG_FORMAT &quot; ms (&quot; JLONG_FORMAT &quot; ticks)&quot;, bytes,
3142                     reserveTimer.milliseconds(), reserveTimer.ticks());
3143     }
3144   }
3145   assert(res == NULL || addr == NULL || addr == res,
3146          &quot;Unexpected address from reserve.&quot;);
3147 
3148   return res;
3149 }
3150 
3151 // Reserve memory at an arbitrary address, only if that area is
3152 // available (and not reserved for something else).
3153 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {
3154   // Windows os::reserve_memory() fails of the requested address range is
3155   // not avilable.
3156   return reserve_memory(bytes, requested_addr);
3157 }
3158 
3159 char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {
3160   assert(file_desc &gt;= 0, &quot;file_desc is not valid&quot;);
3161   return map_memory_to_file(requested_addr, bytes, file_desc);
3162 }
3163 
3164 size_t os::large_page_size() {
3165   return _large_page_size;
3166 }
3167 
3168 bool os::can_commit_large_page_memory() {
3169   // Windows only uses large page memory when the entire region is reserved
3170   // and committed in a single VirtualAlloc() call. This may change in the
3171   // future, but with Windows 2003 it&#39;s not possible to commit on demand.
3172   return false;
3173 }
3174 
3175 bool os::can_execute_large_page_memory() {
3176   return true;
3177 }
3178 
3179 char* os::pd_reserve_memory_special(size_t bytes, size_t alignment, char* addr,
3180                                     bool exec) {
3181   assert(UseLargePages, &quot;only for large pages&quot;);
3182 
3183   if (!is_aligned(bytes, os::large_page_size()) || alignment &gt; os::large_page_size()) {
3184     return NULL; // Fallback to small pages.
3185   }
3186 
3187   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
3188   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3189 
3190   // with large pages, there are two cases where we need to use Individual Allocation
3191   // 1) the UseLargePagesIndividualAllocation flag is set (set by default on WS2003)
3192   // 2) NUMA Interleaving is enabled, in which case we use a different node for each page
3193   if (UseLargePagesIndividualAllocation || UseNUMAInterleaving) {
3194     log_debug(pagesize)(&quot;Reserving large pages individually.&quot;);
3195 
3196     char * p_buf = allocate_pages_individually(bytes, addr, flags, prot, LargePagesIndividualAllocationInjectError);
3197     if (p_buf == NULL) {
3198       // give an appropriate warning message
3199       if (UseNUMAInterleaving) {
3200         warning(&quot;NUMA large page allocation failed, UseLargePages flag ignored&quot;);
3201       }
3202       if (UseLargePagesIndividualAllocation) {
3203         warning(&quot;Individually allocated large pages failed, &quot;
3204                 &quot;use -XX:-UseLargePagesIndividualAllocation to turn off&quot;);
3205       }
3206       return NULL;
3207     }
3208 
3209     return p_buf;
3210 
3211   } else {
3212     log_debug(pagesize)(&quot;Reserving large pages in a single large chunk.&quot;);
3213 
3214     // normal policy just allocate it all at once
3215     DWORD flag = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
3216     char * res = (char *)VirtualAlloc(addr, bytes, flag, prot);
3217 
3218     return res;
3219   }
3220 }
3221 
3222 bool os::pd_release_memory_special(char* base, size_t bytes) {
3223   assert(base != NULL, &quot;Sanity check&quot;);
3224   return pd_release_memory(base, bytes);
3225 }
3226 
3227 void os::print_statistics() {
3228 }
3229 
3230 static void warn_fail_commit_memory(char* addr, size_t bytes, bool exec) {
3231   int err = os::get_last_error();
3232   char buf[256];
3233   size_t buf_len = os::lasterror(buf, sizeof(buf));
3234   warning(&quot;INFO: os::commit_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3235           &quot;, %d) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3236           exec, buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3237 }
3238 
3239 bool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {
3240   if (bytes == 0) {
3241     // Don&#39;t bother the OS with noops.
3242     return true;
3243   }
3244   assert((size_t) addr % os::vm_page_size() == 0, &quot;commit on page boundaries&quot;);
3245   assert(bytes % os::vm_page_size() == 0, &quot;commit in page-sized chunks&quot;);
3246   // Don&#39;t attempt to print anything if the OS call fails. We&#39;re
3247   // probably low on resources, so the print itself may cause crashes.
3248 
3249   // unless we have NUMAInterleaving enabled, the range of a commit
3250   // is always within a reserve covered by a single VirtualAlloc
3251   // in that case we can just do a single commit for the requested size
3252   if (!UseNUMAInterleaving) {
3253     if (VirtualAlloc(addr, bytes, MEM_COMMIT, PAGE_READWRITE) == NULL) {
3254       NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3255       return false;
3256     }
3257     if (exec) {
3258       DWORD oldprot;
3259       // Windows doc says to use VirtualProtect to get execute permissions
3260       if (!VirtualProtect(addr, bytes, PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3261         NOT_PRODUCT(warn_fail_commit_memory(addr, bytes, exec);)
3262         return false;
3263       }
3264     }
3265     return true;
3266   } else {
3267 
3268     // when NUMAInterleaving is enabled, the commit might cover a range that
3269     // came from multiple VirtualAlloc reserves (using allocate_pages_individually).
3270     // VirtualQuery can help us determine that.  The RegionSize that VirtualQuery
3271     // returns represents the number of bytes that can be committed in one step.
3272     size_t bytes_remaining = bytes;
3273     char * next_alloc_addr = addr;
3274     while (bytes_remaining &gt; 0) {
3275       MEMORY_BASIC_INFORMATION alloc_info;
3276       VirtualQuery(next_alloc_addr, &amp;alloc_info, sizeof(alloc_info));
3277       size_t bytes_to_rq = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3278       if (VirtualAlloc(next_alloc_addr, bytes_to_rq, MEM_COMMIT,
3279                        PAGE_READWRITE) == NULL) {
3280         NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3281                                             exec);)
3282         return false;
3283       }
3284       if (exec) {
3285         DWORD oldprot;
3286         if (!VirtualProtect(next_alloc_addr, bytes_to_rq,
3287                             PAGE_EXECUTE_READWRITE, &amp;oldprot)) {
3288           NOT_PRODUCT(warn_fail_commit_memory(next_alloc_addr, bytes_to_rq,
3289                                               exec);)
3290           return false;
3291         }
3292       }
3293       bytes_remaining -= bytes_to_rq;
3294       next_alloc_addr += bytes_to_rq;
3295     }
3296   }
3297   // if we made it this far, return true
3298   return true;
3299 }
3300 
3301 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3302                           bool exec) {
3303   // alignment_hint is ignored on this OS
3304   return pd_commit_memory(addr, size, exec);
3305 }
3306 
3307 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
3308                                   const char* mesg) {
3309   assert(mesg != NULL, &quot;mesg must be specified&quot;);
3310   if (!pd_commit_memory(addr, size, exec)) {
3311     warn_fail_commit_memory(addr, size, exec);
3312     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
3313   }
3314 }
3315 
3316 void os::pd_commit_memory_or_exit(char* addr, size_t size,
3317                                   size_t alignment_hint, bool exec,
3318                                   const char* mesg) {
3319   // alignment_hint is ignored on this OS
3320   pd_commit_memory_or_exit(addr, size, exec, mesg);
3321 }
3322 
3323 bool os::pd_uncommit_memory(char* addr, size_t bytes) {
3324   if (bytes == 0) {
3325     // Don&#39;t bother the OS with noops.
3326     return true;
3327   }
3328   assert((size_t) addr % os::vm_page_size() == 0, &quot;uncommit on page boundaries&quot;);
3329   assert(bytes % os::vm_page_size() == 0, &quot;uncommit in page-sized chunks&quot;);
3330   return (VirtualFree(addr, bytes, MEM_DECOMMIT) != 0);
3331 }
3332 
3333 bool os::pd_release_memory(char* addr, size_t bytes) {
3334   return VirtualFree(addr, 0, MEM_RELEASE) != 0;
3335 }
3336 
3337 bool os::pd_create_stack_guard_pages(char* addr, size_t size) {
3338   return os::commit_memory(addr, size, !ExecMem);
3339 }
3340 
3341 bool os::remove_stack_guard_pages(char* addr, size_t size) {
3342   return os::uncommit_memory(addr, size);
3343 }
3344 
3345 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
3346   uint count = 0;
3347   bool ret = false;
3348   size_t bytes_remaining = bytes;
3349   char * next_protect_addr = addr;
3350 
3351   // Use VirtualQuery() to get the chunk size.
3352   while (bytes_remaining) {
3353     MEMORY_BASIC_INFORMATION alloc_info;
3354     if (VirtualQuery(next_protect_addr, &amp;alloc_info, sizeof(alloc_info)) == 0) {
3355       return false;
3356     }
3357 
3358     size_t bytes_to_protect = MIN2(bytes_remaining, (size_t)alloc_info.RegionSize);
3359     // We used different API at allocate_pages_individually() based on UseNUMAInterleaving,
3360     // but we don&#39;t distinguish here as both cases are protected by same API.
3361     ret = VirtualProtect(next_protect_addr, bytes_to_protect, p, old_status) != 0;
3362     warning(&quot;Failed protecting pages individually for chunk #%u&quot;, count);
3363     if (!ret) {
3364       return false;
3365     }
3366 
3367     bytes_remaining -= bytes_to_protect;
3368     next_protect_addr += bytes_to_protect;
3369     count++;
3370   }
3371   return ret;
3372 }
3373 
3374 // Set protections specified
3375 bool os::protect_memory(char* addr, size_t bytes, ProtType prot,
3376                         bool is_committed) {
3377   unsigned int p = 0;
3378   switch (prot) {
3379   case MEM_PROT_NONE: p = PAGE_NOACCESS; break;
3380   case MEM_PROT_READ: p = PAGE_READONLY; break;
3381   case MEM_PROT_RW:   p = PAGE_READWRITE; break;
3382   case MEM_PROT_RWX:  p = PAGE_EXECUTE_READWRITE; break;
3383   default:
3384     ShouldNotReachHere();
3385   }
3386 
3387   DWORD old_status;
3388 
3389   // Strange enough, but on Win32 one can change protection only for committed
3390   // memory, not a big deal anyway, as bytes less or equal than 64K
3391   if (!is_committed) {
3392     commit_memory_or_exit(addr, bytes, prot == MEM_PROT_RWX,
3393                           &quot;cannot commit protection page&quot;);
3394   }
3395   // One cannot use os::guard_memory() here, as on Win32 guard page
3396   // have different (one-shot) semantics, from MSDN on PAGE_GUARD:
3397   //
3398   // Pages in the region become guard pages. Any attempt to access a guard page
3399   // causes the system to raise a STATUS_GUARD_PAGE exception and turn off
3400   // the guard page status. Guard pages thus act as a one-time access alarm.
3401   bool ret;
3402   if (UseNUMAInterleaving) {
3403     // If UseNUMAInterleaving is enabled, the pages may have been allocated a chunk at a time,
3404     // so we must protect the chunks individually.
3405     ret = protect_pages_individually(addr, bytes, p, &amp;old_status);
3406   } else {
3407     ret = VirtualProtect(addr, bytes, p, &amp;old_status) != 0;
3408   }
3409 #ifdef ASSERT
3410   if (!ret) {
3411     int err = os::get_last_error();
3412     char buf[256];
3413     size_t buf_len = os::lasterror(buf, sizeof(buf));
3414     warning(&quot;INFO: os::protect_memory(&quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT
3415           &quot;) failed; error=&#39;%s&#39; (DOS error/errno=%d)&quot;, addr, bytes,
3416           buf_len != 0 ? buf : &quot;&lt;no_error_string&gt;&quot;, err);
3417   }
3418 #endif
3419   return ret;
3420 }
3421 
3422 bool os::guard_memory(char* addr, size_t bytes) {
3423   DWORD old_status;
3424   return VirtualProtect(addr, bytes, PAGE_READWRITE | PAGE_GUARD, &amp;old_status) != 0;
3425 }
3426 
3427 bool os::unguard_memory(char* addr, size_t bytes) {
3428   DWORD old_status;
3429   return VirtualProtect(addr, bytes, PAGE_READWRITE, &amp;old_status) != 0;
3430 }
3431 
3432 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3433 void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }
3434 void os::numa_make_global(char *addr, size_t bytes)    { }
3435 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint)    { }
3436 bool os::numa_topology_changed()                       { return false; }
3437 size_t os::numa_get_groups_num()                       { return MAX2(numa_node_list_holder.get_count(), 1); }
3438 int os::numa_get_group_id()                            { return 0; }
3439 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
3440   if (numa_node_list_holder.get_count() == 0 &amp;&amp; size &gt; 0) {
3441     // Provide an answer for UMA systems
3442     ids[0] = 0;
3443     return 1;
3444   } else {
3445     // check for size bigger than actual groups_num
3446     size = MIN2(size, numa_get_groups_num());
3447     for (int i = 0; i &lt; (int)size; i++) {
3448       ids[i] = numa_node_list_holder.get_node_list_entry(i);
3449     }
3450     return size;
3451   }
3452 }
3453 
3454 int os::numa_get_group_id_for_address(const void* address) {
3455   return 0;
3456 }
3457 
3458 bool os::get_page_info(char *start, page_info* info) {
3459   return false;
3460 }
3461 
3462 char *os::scan_pages(char *start, char* end, page_info* page_expected,
3463                      page_info* page_found) {
3464   return end;
3465 }
3466 
3467 char* os::non_memory_address_word() {
3468   // Must never look like an address returned by reserve_memory,
3469   // even in its subfields (as defined by the CPU immediate fields,
3470   // if the CPU splits constants across multiple instructions).
3471   return (char*)-1;
3472 }
3473 
3474 #define MAX_ERROR_COUNT 100
3475 #define SYS_THREAD_ERROR 0xffffffffUL
3476 
3477 void os::pd_start_thread(Thread* thread) {
3478   DWORD ret = ResumeThread(thread-&gt;osthread()-&gt;thread_handle());
3479   // Returns previous suspend state:
3480   // 0:  Thread was not suspended
3481   // 1:  Thread is running now
3482   // &gt;1: Thread is still suspended.
3483   assert(ret != SYS_THREAD_ERROR, &quot;StartThread failed&quot;); // should propagate back
3484 }
3485 
3486 
3487 // Short sleep, direct OS call.
3488 //
3489 // ms = 0, means allow others (if any) to run.
3490 //
3491 void os::naked_short_sleep(jlong ms) {
3492   assert(ms &lt; 1000, &quot;Un-interruptable sleep, short time use only&quot;);
3493   Sleep(ms);
3494 }
3495 
3496 // Windows does not provide sleep functionality with nanosecond resolution, so we
3497 // try to approximate this with spinning combined with yielding if another thread
3498 // is ready to run on the current processor.
3499 void os::naked_short_nanosleep(jlong ns) {
3500   assert(ns &gt; -1 &amp;&amp; ns &lt; NANOUNITS, &quot;Un-interruptable sleep, short time use only&quot;);
3501 
3502   int64_t start = os::javaTimeNanos();
3503   do {
3504     if (SwitchToThread() == 0) {
3505       // Nothing else is ready to run on this cpu, spin a little
3506       SpinPause();
3507     }
3508   } while (os::javaTimeNanos() - start &lt; ns);
3509 }
3510 
3511 // Sleep forever; naked call to OS-specific sleep; use with CAUTION
3512 void os::infinite_sleep() {
3513   while (true) {    // sleep forever ...
3514     Sleep(100000);  // ... 100 seconds at a time
3515   }
3516 }
3517 
3518 typedef BOOL (WINAPI * STTSignature)(void);
3519 
3520 void os::naked_yield() {
3521   // Consider passing back the return value from SwitchToThread().
3522   SwitchToThread();
3523 }
3524 
3525 // Win32 only gives you access to seven real priorities at a time,
3526 // so we compress Java&#39;s ten down to seven.  It would be better
3527 // if we dynamically adjusted relative priorities.
3528 
3529 int os::java_to_os_priority[CriticalPriority + 1] = {
3530   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3531   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3532   THREAD_PRIORITY_LOWEST,                       // 2
3533   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3534   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3535   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3536   THREAD_PRIORITY_NORMAL,                       // 6
3537   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3538   THREAD_PRIORITY_ABOVE_NORMAL,                 // 8
3539   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3540   THREAD_PRIORITY_HIGHEST,                      // 10 MaxPriority
3541   THREAD_PRIORITY_HIGHEST                       // 11 CriticalPriority
3542 };
3543 
3544 int prio_policy1[CriticalPriority + 1] = {
3545   THREAD_PRIORITY_IDLE,                         // 0  Entry should never be used
3546   THREAD_PRIORITY_LOWEST,                       // 1  MinPriority
3547   THREAD_PRIORITY_LOWEST,                       // 2
3548   THREAD_PRIORITY_BELOW_NORMAL,                 // 3
3549   THREAD_PRIORITY_BELOW_NORMAL,                 // 4
3550   THREAD_PRIORITY_NORMAL,                       // 5  NormPriority
3551   THREAD_PRIORITY_ABOVE_NORMAL,                 // 6
3552   THREAD_PRIORITY_ABOVE_NORMAL,                 // 7
3553   THREAD_PRIORITY_HIGHEST,                      // 8
3554   THREAD_PRIORITY_HIGHEST,                      // 9  NearMaxPriority
3555   THREAD_PRIORITY_TIME_CRITICAL,                // 10 MaxPriority
3556   THREAD_PRIORITY_TIME_CRITICAL                 // 11 CriticalPriority
3557 };
3558 
3559 static int prio_init() {
3560   // If ThreadPriorityPolicy is 1, switch tables
3561   if (ThreadPriorityPolicy == 1) {
3562     int i;
3563     for (i = 0; i &lt; CriticalPriority + 1; i++) {
3564       os::java_to_os_priority[i] = prio_policy1[i];
3565     }
3566   }
3567   if (UseCriticalJavaThreadPriority) {
3568     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
3569   }
3570   return 0;
3571 }
3572 
3573 OSReturn os::set_native_priority(Thread* thread, int priority) {
3574   if (!UseThreadPriorities) return OS_OK;
3575   bool ret = SetThreadPriority(thread-&gt;osthread()-&gt;thread_handle(), priority) != 0;
3576   return ret ? OS_OK : OS_ERR;
3577 }
3578 
3579 OSReturn os::get_native_priority(const Thread* const thread,
3580                                  int* priority_ptr) {
3581   if (!UseThreadPriorities) {
3582     *priority_ptr = java_to_os_priority[NormPriority];
3583     return OS_OK;
3584   }
3585   int os_prio = GetThreadPriority(thread-&gt;osthread()-&gt;thread_handle());
3586   if (os_prio == THREAD_PRIORITY_ERROR_RETURN) {
3587     assert(false, &quot;GetThreadPriority failed&quot;);
3588     return OS_ERR;
3589   }
3590   *priority_ptr = os_prio;
3591   return OS_OK;
3592 }
3593 
3594 // GetCurrentThreadId() returns DWORD
3595 intx os::current_thread_id()  { return GetCurrentThreadId(); }
3596 
3597 static int _initial_pid = 0;
3598 
3599 int os::current_process_id() {
3600   return (_initial_pid ? _initial_pid : _getpid());
3601 }
3602 
3603 int    os::win32::_vm_page_size              = 0;
3604 int    os::win32::_vm_allocation_granularity = 0;
3605 int    os::win32::_processor_type            = 0;
3606 // Processor level is not available on non-NT systems, use vm_version instead
3607 int    os::win32::_processor_level           = 0;
3608 julong os::win32::_physical_memory           = 0;
3609 size_t os::win32::_default_stack_size        = 0;
3610 
3611 intx          os::win32::_os_thread_limit    = 0;
3612 volatile intx os::win32::_os_thread_count    = 0;
3613 
3614 bool   os::win32::_is_windows_server         = false;
3615 
3616 // 6573254
3617 // Currently, the bug is observed across all the supported Windows releases,
3618 // including the latest one (as of this writing - Windows Server 2012 R2)
3619 bool   os::win32::_has_exit_bug              = true;
3620 
3621 void os::win32::initialize_system_info() {
3622   SYSTEM_INFO si;
3623   GetSystemInfo(&amp;si);
3624   _vm_page_size    = si.dwPageSize;
3625   _vm_allocation_granularity = si.dwAllocationGranularity;
3626   _processor_type  = si.dwProcessorType;
3627   _processor_level = si.wProcessorLevel;
3628   set_processor_count(si.dwNumberOfProcessors);
3629 
3630   MEMORYSTATUSEX ms;
3631   ms.dwLength = sizeof(ms);
3632 
3633   // also returns dwAvailPhys (free physical memory bytes), dwTotalVirtual, dwAvailVirtual,
3634   // dwMemoryLoad (% of memory in use)
3635   GlobalMemoryStatusEx(&amp;ms);
3636   _physical_memory = ms.ullTotalPhys;
3637 
3638   if (FLAG_IS_DEFAULT(MaxRAM)) {
3639     // Adjust MaxRAM according to the maximum virtual address space available.
3640     FLAG_SET_DEFAULT(MaxRAM, MIN2(MaxRAM, (uint64_t) ms.ullTotalVirtual));
3641   }
3642 
3643   OSVERSIONINFOEX oi;
3644   oi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
3645   GetVersionEx((OSVERSIONINFO*)&amp;oi);
3646   switch (oi.dwPlatformId) {
3647   case VER_PLATFORM_WIN32_NT:
3648     {
3649       int os_vers = oi.dwMajorVersion * 1000 + oi.dwMinorVersion;
3650       if (oi.wProductType == VER_NT_DOMAIN_CONTROLLER ||
3651           oi.wProductType == VER_NT_SERVER) {
3652         _is_windows_server = true;
3653       }
3654     }
3655     break;
3656   default: fatal(&quot;Unknown platform&quot;);
3657   }
3658 
3659   _default_stack_size = os::current_stack_size();
3660   assert(_default_stack_size &gt; (size_t) _vm_page_size, &quot;invalid stack size&quot;);
3661   assert((_default_stack_size &amp; (_vm_page_size - 1)) == 0,
3662          &quot;stack size not a multiple of page size&quot;);
3663 
3664   initialize_performance_counter();
3665 }
3666 
3667 
3668 HINSTANCE os::win32::load_Windows_dll(const char* name, char *ebuf,
3669                                       int ebuflen) {
3670   char path[MAX_PATH];
3671   DWORD size;
3672   DWORD pathLen = (DWORD)sizeof(path);
3673   HINSTANCE result = NULL;
3674 
3675   // only allow library name without path component
3676   assert(strchr(name, &#39;\\&#39;) == NULL, &quot;path not allowed&quot;);
3677   assert(strchr(name, &#39;:&#39;) == NULL, &quot;path not allowed&quot;);
3678   if (strchr(name, &#39;\\&#39;) != NULL || strchr(name, &#39;:&#39;) != NULL) {
3679     jio_snprintf(ebuf, ebuflen,
3680                  &quot;Invalid parameter while calling os::win32::load_windows_dll(): cannot take path: %s&quot;, name);
3681     return NULL;
3682   }
3683 
3684   // search system directory
3685   if ((size = GetSystemDirectory(path, pathLen)) &gt; 0) {
3686     if (size &gt;= pathLen) {
3687       return NULL; // truncated
3688     }
3689     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3690       return NULL; // truncated
3691     }
3692     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3693       return result;
3694     }
3695   }
3696 
3697   // try Windows directory
3698   if ((size = GetWindowsDirectory(path, pathLen)) &gt; 0) {
3699     if (size &gt;= pathLen) {
3700       return NULL; // truncated
3701     }
3702     if (jio_snprintf(path + size, pathLen - size, &quot;\\%s&quot;, name) == -1) {
3703       return NULL; // truncated
3704     }
3705     if ((result = (HINSTANCE)os::dll_load(path, ebuf, ebuflen)) != NULL) {
3706       return result;
3707     }
3708   }
3709 
3710   jio_snprintf(ebuf, ebuflen,
3711                &quot;os::win32::load_windows_dll() cannot load %s from system directories.&quot;, name);
3712   return NULL;
3713 }
3714 
3715 #define MAXIMUM_THREADS_TO_KEEP (16 * MAXIMUM_WAIT_OBJECTS)
3716 #define EXIT_TIMEOUT 300000 /* 5 minutes */
3717 
3718 static BOOL CALLBACK init_crit_sect_call(PINIT_ONCE, PVOID pcrit_sect, PVOID*) {
3719   InitializeCriticalSection((CRITICAL_SECTION*)pcrit_sect);
3720   return TRUE;
3721 }
3722 
3723 int os::win32::exit_process_or_thread(Ept what, int exit_code) {
3724   // Basic approach:
3725   //  - Each exiting thread registers its intent to exit and then does so.
3726   //  - A thread trying to terminate the process must wait for all
3727   //    threads currently exiting to complete their exit.
3728 
3729   if (os::win32::has_exit_bug()) {
3730     // The array holds handles of the threads that have started exiting by calling
3731     // _endthreadex().
3732     // Should be large enough to avoid blocking the exiting thread due to lack of
3733     // a free slot.
3734     static HANDLE handles[MAXIMUM_THREADS_TO_KEEP];
3735     static int handle_count = 0;
3736 
3737     static INIT_ONCE init_once_crit_sect = INIT_ONCE_STATIC_INIT;
3738     static CRITICAL_SECTION crit_sect;
3739     static volatile DWORD process_exiting = 0;
3740     int i, j;
3741     DWORD res;
3742     HANDLE hproc, hthr;
3743 
3744     // We only attempt to register threads until a process exiting
3745     // thread manages to set the process_exiting flag. Any threads
3746     // that come through here after the process_exiting flag is set
3747     // are unregistered and will be caught in the SuspendThread()
3748     // infinite loop below.
3749     bool registered = false;
3750 
3751     // The first thread that reached this point, initializes the critical section.
3752     if (!InitOnceExecuteOnce(&amp;init_once_crit_sect, init_crit_sect_call, &amp;crit_sect, NULL)) {
3753       warning(&quot;crit_sect initialization failed in %s: %d\n&quot;, __FILE__, __LINE__);
3754     } else if (Atomic::load_acquire(&amp;process_exiting) == 0) {
3755       if (what != EPT_THREAD) {
3756         // Atomically set process_exiting before the critical section
3757         // to increase the visibility between racing threads.
3758         Atomic::cmpxchg(&amp;process_exiting, (DWORD)0, GetCurrentThreadId());
3759       }
3760       EnterCriticalSection(&amp;crit_sect);
3761 
3762       if (what == EPT_THREAD &amp;&amp; Atomic::load_acquire(&amp;process_exiting) == 0) {
3763         // Remove from the array those handles of the threads that have completed exiting.
3764         for (i = 0, j = 0; i &lt; handle_count; ++i) {
3765           res = WaitForSingleObject(handles[i], 0 /* don&#39;t wait */);
3766           if (res == WAIT_TIMEOUT) {
3767             handles[j++] = handles[i];
3768           } else {
3769             if (res == WAIT_FAILED) {
3770               warning(&quot;WaitForSingleObject failed (%u) in %s: %d\n&quot;,
3771                       GetLastError(), __FILE__, __LINE__);
3772             }
3773             // Don&#39;t keep the handle, if we failed waiting for it.
3774             CloseHandle(handles[i]);
3775           }
3776         }
3777 
3778         // If there&#39;s no free slot in the array of the kept handles, we&#39;ll have to
3779         // wait until at least one thread completes exiting.
3780         if ((handle_count = j) == MAXIMUM_THREADS_TO_KEEP) {
3781           // Raise the priority of the oldest exiting thread to increase its chances
3782           // to complete sooner.
3783           SetThreadPriority(handles[0], THREAD_PRIORITY_ABOVE_NORMAL);
3784           res = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, handles, FALSE, EXIT_TIMEOUT);
3785           if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; (WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS)) {
3786             i = (res - WAIT_OBJECT_0);
3787             handle_count = MAXIMUM_THREADS_TO_KEEP - 1;
3788             for (; i &lt; handle_count; ++i) {
3789               handles[i] = handles[i + 1];
3790             }
3791           } else {
3792             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3793                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3794                     GetLastError(), __FILE__, __LINE__);
3795             // Don&#39;t keep handles, if we failed waiting for them.
3796             for (i = 0; i &lt; MAXIMUM_THREADS_TO_KEEP; ++i) {
3797               CloseHandle(handles[i]);
3798             }
3799             handle_count = 0;
3800           }
3801         }
3802 
3803         // Store a duplicate of the current thread handle in the array of handles.
3804         hproc = GetCurrentProcess();
3805         hthr = GetCurrentThread();
3806         if (!DuplicateHandle(hproc, hthr, hproc, &amp;handles[handle_count],
3807                              0, FALSE, DUPLICATE_SAME_ACCESS)) {
3808           warning(&quot;DuplicateHandle failed (%u) in %s: %d\n&quot;,
3809                   GetLastError(), __FILE__, __LINE__);
3810 
3811           // We can&#39;t register this thread (no more handles) so this thread
3812           // may be racing with a thread that is calling exit(). If the thread
3813           // that is calling exit() has managed to set the process_exiting
3814           // flag, then this thread will be caught in the SuspendThread()
3815           // infinite loop below which closes that race. A small timing
3816           // window remains before the process_exiting flag is set, but it
3817           // is only exposed when we are out of handles.
3818         } else {
3819           ++handle_count;
3820           registered = true;
3821 
3822           // The current exiting thread has stored its handle in the array, and now
3823           // should leave the critical section before calling _endthreadex().
3824         }
3825 
3826       } else if (what != EPT_THREAD &amp;&amp; handle_count &gt; 0) {
3827         jlong start_time, finish_time, timeout_left;
3828         // Before ending the process, make sure all the threads that had called
3829         // _endthreadex() completed.
3830 
3831         // Set the priority level of the current thread to the same value as
3832         // the priority level of exiting threads.
3833         // This is to ensure it will be given a fair chance to execute if
3834         // the timeout expires.
3835         hthr = GetCurrentThread();
3836         SetThreadPriority(hthr, THREAD_PRIORITY_ABOVE_NORMAL);
3837         start_time = os::javaTimeNanos();
3838         finish_time = start_time + ((jlong)EXIT_TIMEOUT * 1000000L);
3839         for (i = 0; ; ) {
3840           int portion_count = handle_count - i;
3841           if (portion_count &gt; MAXIMUM_WAIT_OBJECTS) {
3842             portion_count = MAXIMUM_WAIT_OBJECTS;
3843           }
3844           for (j = 0; j &lt; portion_count; ++j) {
3845             SetThreadPriority(handles[i + j], THREAD_PRIORITY_ABOVE_NORMAL);
3846           }
3847           timeout_left = (finish_time - start_time) / 1000000L;
3848           if (timeout_left &lt; 0) {
3849             timeout_left = 0;
3850           }
3851           res = WaitForMultipleObjects(portion_count, handles + i, TRUE, timeout_left);
3852           if (res == WAIT_FAILED || res == WAIT_TIMEOUT) {
3853             warning(&quot;WaitForMultipleObjects %s (%u) in %s: %d\n&quot;,
3854                     (res == WAIT_FAILED ? &quot;failed&quot; : &quot;timed out&quot;),
3855                     GetLastError(), __FILE__, __LINE__);
3856             // Reset portion_count so we close the remaining
3857             // handles due to this error.
3858             portion_count = handle_count - i;
3859           }
3860           for (j = 0; j &lt; portion_count; ++j) {
3861             CloseHandle(handles[i + j]);
3862           }
3863           if ((i += portion_count) &gt;= handle_count) {
3864             break;
3865           }
3866           start_time = os::javaTimeNanos();
3867         }
3868         handle_count = 0;
3869       }
3870 
3871       LeaveCriticalSection(&amp;crit_sect);
3872     }
3873 
3874     if (!registered &amp;&amp;
3875         Atomic::load_acquire(&amp;process_exiting) != 0 &amp;&amp;
3876         process_exiting != GetCurrentThreadId()) {
3877       // Some other thread is about to call exit(), so we don&#39;t let
3878       // the current unregistered thread proceed to exit() or _endthreadex()
3879       while (true) {
3880         SuspendThread(GetCurrentThread());
3881         // Avoid busy-wait loop, if SuspendThread() failed.
3882         Sleep(EXIT_TIMEOUT);
3883       }
3884     }
3885   }
3886 
3887   // We are here if either
3888   // - there&#39;s no &#39;race at exit&#39; bug on this OS release;
3889   // - initialization of the critical section failed (unlikely);
3890   // - the current thread has registered itself and left the critical section;
3891   // - the process-exiting thread has raised the flag and left the critical section.
3892   if (what == EPT_THREAD) {
3893     _endthreadex((unsigned)exit_code);
3894   } else if (what == EPT_PROCESS) {
3895     ::exit(exit_code);
3896   } else {
3897     _exit(exit_code);
3898   }
3899 
3900   // Should not reach here
3901   return exit_code;
3902 }
3903 
3904 #undef EXIT_TIMEOUT
3905 
3906 void os::win32::setmode_streams() {
3907   _setmode(_fileno(stdin), _O_BINARY);
3908   _setmode(_fileno(stdout), _O_BINARY);
3909   _setmode(_fileno(stderr), _O_BINARY);
3910 }
3911 
3912 void os::wait_for_keypress_at_exit(void) {
3913   if (PauseAtExit) {
3914     fprintf(stderr, &quot;Press any key to continue...\n&quot;);
3915     fgetc(stdin);
3916   }
3917 }
3918 
3919 
3920 bool os::message_box(const char* title, const char* message) {
3921   int result = MessageBox(NULL, message, title,
3922                           MB_YESNO | MB_ICONERROR | MB_SYSTEMMODAL | MB_DEFAULT_DESKTOP_ONLY);
3923   return result == IDYES;
3924 }
3925 
3926 #ifndef PRODUCT
3927 #ifndef _WIN64
3928 // Helpers to check whether NX protection is enabled
3929 int nx_exception_filter(_EXCEPTION_POINTERS *pex) {
3930   if (pex-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION &amp;&amp;
3931       pex-&gt;ExceptionRecord-&gt;NumberParameters &gt; 0 &amp;&amp;
3932       pex-&gt;ExceptionRecord-&gt;ExceptionInformation[0] ==
3933       EXCEPTION_INFO_EXEC_VIOLATION) {
3934     return EXCEPTION_EXECUTE_HANDLER;
3935   }
3936   return EXCEPTION_CONTINUE_SEARCH;
3937 }
3938 
3939 void nx_check_protection() {
3940   // If NX is enabled we&#39;ll get an exception calling into code on the stack
3941   char code[] = { (char)0xC3 }; // ret
3942   void *code_ptr = (void *)code;
3943   __try {
3944     __asm call code_ptr
3945   } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {
3946     tty-&gt;print_raw_cr(&quot;NX protection detected.&quot;);
3947   }
3948 }
3949 #endif // _WIN64
3950 #endif // PRODUCT
3951 
3952 // This is called _before_ the global arguments have been parsed
3953 void os::init(void) {
3954   _initial_pid = _getpid();
3955 
3956   init_random(1234567);
3957 
3958   win32::initialize_system_info();
3959   win32::setmode_streams();
3960   init_page_sizes((size_t) win32::vm_page_size());
3961 
3962   // This may be overridden later when argument processing is done.
3963   FLAG_SET_ERGO(UseLargePagesIndividualAllocation, false);
3964 
3965   // Initialize main_process and main_thread
3966   main_process = GetCurrentProcess();  // Remember main_process is a pseudo handle
3967   if (!DuplicateHandle(main_process, GetCurrentThread(), main_process,
3968                        &amp;main_thread, THREAD_ALL_ACCESS, false, 0)) {
3969     fatal(&quot;DuplicateHandle failed\n&quot;);
3970   }
3971   main_thread_id = (int) GetCurrentThreadId();
3972 
3973   // initialize fast thread access - only used for 32-bit
3974   win32::initialize_thread_ptr_offset();
3975 }
3976 
3977 // To install functions for atexit processing
3978 extern &quot;C&quot; {
3979   static void perfMemory_exit_helper() {
3980     perfMemory_exit();
3981   }
3982 }
3983 
3984 static jint initSock();
3985 
3986 // this is called _after_ the global arguments have been parsed
3987 jint os::init_2(void) {
3988 
3989   // This could be set any time but all platforms
3990   // have to set it the same so we have to mirror Solaris.
3991   DEBUG_ONLY(os::set_mutex_init_done();)
3992 
3993   // Setup Windows Exceptions
3994 
3995 #if INCLUDE_AOT
3996   // If AOT is enabled we need to install a vectored exception handler
3997   // in order to forward implicit exceptions from code in AOT
3998   // generated DLLs.  This is necessary since these DLLs are not
3999   // registered for structured exceptions like codecache methods are.
4000   if (AOTLibrary != NULL &amp;&amp; (UseAOT || FLAG_IS_DEFAULT(UseAOT))) {
4001     topLevelVectoredExceptionHandler = AddVectoredExceptionHandler( 1, topLevelVectoredExceptionFilter);
4002   }
4003 #endif
4004 
4005   // for debugging float code generation bugs
4006   if (ForceFloatExceptions) {
4007 #ifndef  _WIN64
4008     static long fp_control_word = 0;
4009     __asm { fstcw fp_control_word }
4010     // see Intel PPro Manual, Vol. 2, p 7-16
4011     const long precision = 0x20;
4012     const long underflow = 0x10;
4013     const long overflow  = 0x08;
4014     const long zero_div  = 0x04;
4015     const long denorm    = 0x02;
4016     const long invalid   = 0x01;
4017     fp_control_word |= invalid;
4018     __asm { fldcw fp_control_word }
4019 #endif
4020   }
4021 
4022   // If stack_commit_size is 0, windows will reserve the default size,
4023   // but only commit a small portion of it.
4024   size_t stack_commit_size = align_up(ThreadStackSize*K, os::vm_page_size());
4025   size_t default_reserve_size = os::win32::default_stack_size();
4026   size_t actual_reserve_size = stack_commit_size;
4027   if (stack_commit_size &lt; default_reserve_size) {
4028     // If stack_commit_size == 0, we want this too
4029     actual_reserve_size = default_reserve_size;
4030   }
4031 
4032   // Check minimum allowable stack size for thread creation and to initialize
4033   // the java system classes, including StackOverflowError - depends on page
4034   // size.  Add two 4K pages for compiler2 recursion in main thread.
4035   // Add in 4*BytesPerWord 4K pages to account for VM stack during
4036   // class initialization depending on 32 or 64 bit VM.
4037   size_t min_stack_allowed =
4038             (size_t)(JavaThread::stack_guard_zone_size() +
4039                      JavaThread::stack_shadow_zone_size() +
4040                      (4*BytesPerWord COMPILER2_PRESENT(+2)) * 4 * K);
4041 
4042   min_stack_allowed = align_up(min_stack_allowed, os::vm_page_size());
4043 
4044   if (actual_reserve_size &lt; min_stack_allowed) {
4045     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
4046                   &quot;Specify at least %dk&quot;,
4047                   min_stack_allowed / K);
4048     return JNI_ERR;
4049   }
4050 
4051   JavaThread::set_stack_size_at_create(stack_commit_size);
4052 
4053   // Calculate theoretical max. size of Threads to guard gainst artifical
4054   // out-of-memory situations, where all available address-space has been
4055   // reserved by thread stacks.
4056   assert(actual_reserve_size != 0, &quot;Must have a stack&quot;);
4057 
4058   // Calculate the thread limit when we should start doing Virtual Memory
4059   // banging. Currently when the threads will have used all but 200Mb of space.
4060   //
4061   // TODO: consider performing a similar calculation for commit size instead
4062   // as reserve size, since on a 64-bit platform we&#39;ll run into that more
4063   // often than running out of virtual memory space.  We can use the
4064   // lower value of the two calculations as the os_thread_limit.
4065   size_t max_address_space = ((size_t)1 &lt;&lt; (BitsPerWord - 1)) - (200 * K * K);
4066   win32::_os_thread_limit = (intx)(max_address_space / actual_reserve_size);
4067 
4068   // at exit methods are called in the reverse order of their registration.
4069   // there is no limit to the number of functions registered. atexit does
4070   // not set errno.
4071 
4072   if (PerfAllowAtExitRegistration) {
4073     // only register atexit functions if PerfAllowAtExitRegistration is set.
4074     // atexit functions can be delayed until process exit time, which
4075     // can be problematic for embedded VM situations. Embedded VMs should
4076     // call DestroyJavaVM() to assure that VM resources are released.
4077 
4078     // note: perfMemory_exit_helper atexit function may be removed in
4079     // the future if the appropriate cleanup code can be added to the
4080     // VM_Exit VMOperation&#39;s doit method.
4081     if (atexit(perfMemory_exit_helper) != 0) {
4082       warning(&quot;os::init_2 atexit(perfMemory_exit_helper) failed&quot;);
4083     }
4084   }
4085 
4086 #ifndef _WIN64
4087   // Print something if NX is enabled (win32 on AMD64)
4088   NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) nx_check_protection());
4089 #endif
4090 
4091   // initialize thread priority policy
4092   prio_init();
4093 
4094   if (UseNUMA &amp;&amp; !ForceNUMA) {
4095     UseNUMA = false; // We don&#39;t fully support this yet
4096   }
4097 
4098   if (UseNUMAInterleaving) {
4099     // first check whether this Windows OS supports VirtualAllocExNuma, if not ignore this flag
4100     bool success = numa_interleaving_init();
4101     if (!success) UseNUMAInterleaving = false;
4102   }
4103 
4104   if (initSock() != JNI_OK) {
4105     return JNI_ERR;
4106   }
4107 
4108   SymbolEngine::recalc_search_path();
4109 
4110   // Initialize data for jdk.internal.misc.Signal
4111   if (!ReduceSignalUsage) {
4112     jdk_misc_signal_init();
4113   }
4114 
4115   return JNI_OK;
4116 }
4117 
4118 // Mark the polling page as unreadable
4119 void os::make_polling_page_unreadable(void) {
4120   DWORD old_status;
4121   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4122                       PAGE_NOACCESS, &amp;old_status)) {
4123     fatal(&quot;Could not disable polling page&quot;);
4124   }
4125 }
4126 
4127 // Mark the polling page as readable
4128 void os::make_polling_page_readable(void) {
4129   DWORD old_status;
4130   if (!VirtualProtect((char *)_polling_page, os::vm_page_size(),
4131                       PAGE_READONLY, &amp;old_status)) {
4132     fatal(&quot;Could not enable polling page&quot;);
4133   }
4134 }
4135 
4136 // combine the high and low DWORD into a ULONGLONG
4137 static ULONGLONG make_double_word(DWORD high_word, DWORD low_word) {
4138   ULONGLONG value = high_word;
4139   value &lt;&lt;= sizeof(high_word) * 8;
4140   value |= low_word;
4141   return value;
4142 }
4143 
4144 // Transfers data from WIN32_FILE_ATTRIBUTE_DATA structure to struct stat
4145 static void file_attribute_data_to_stat(struct stat* sbuf, WIN32_FILE_ATTRIBUTE_DATA file_data) {
4146   ::memset((void*)sbuf, 0, sizeof(struct stat));
4147   sbuf-&gt;st_size = (_off_t)make_double_word(file_data.nFileSizeHigh, file_data.nFileSizeLow);
4148   sbuf-&gt;st_mtime = make_double_word(file_data.ftLastWriteTime.dwHighDateTime,
4149                                   file_data.ftLastWriteTime.dwLowDateTime);
4150   sbuf-&gt;st_ctime = make_double_word(file_data.ftCreationTime.dwHighDateTime,
4151                                   file_data.ftCreationTime.dwLowDateTime);
4152   sbuf-&gt;st_atime = make_double_word(file_data.ftLastAccessTime.dwHighDateTime,
4153                                   file_data.ftLastAccessTime.dwLowDateTime);
4154   if ((file_data.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
4155     sbuf-&gt;st_mode |= S_IFDIR;
4156   } else {
4157     sbuf-&gt;st_mode |= S_IFREG;
4158   }
4159 }
4160 
4161 static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {
4162   // Get required buffer size to convert to Unicode
4163   int unicode_path_len = MultiByteToWideChar(CP_THREAD_ACP,
4164                                              MB_ERR_INVALID_CHARS,
4165                                              char_path, -1,
4166                                              NULL, 0);
4167   if (unicode_path_len == 0) {
4168     return EINVAL;
4169   }
4170 
4171   *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);
4172 
4173   int result = MultiByteToWideChar(CP_THREAD_ACP,
4174                                    MB_ERR_INVALID_CHARS,
4175                                    char_path, -1,
4176                                    *unicode_path, unicode_path_len);
4177   assert(result == unicode_path_len, &quot;length already checked above&quot;);
4178 
4179   return ERROR_SUCCESS;
4180 }
4181 
4182 static errno_t get_full_path(LPCWSTR unicode_path, LPWSTR* full_path) {
4183   // Get required buffer size to convert to full path. The return
4184   // value INCLUDES the terminating null character.
4185   DWORD full_path_len = GetFullPathNameW(unicode_path, 0, NULL, NULL);
4186   if (full_path_len == 0) {
4187     return EINVAL;
4188   }
4189 
4190   *full_path = NEW_C_HEAP_ARRAY(WCHAR, full_path_len, mtInternal);
4191 
4192   // When the buffer has sufficient size, the return value EXCLUDES the
4193   // terminating null character
4194   DWORD result = GetFullPathNameW(unicode_path, full_path_len, *full_path, NULL);
4195   assert(result &lt;= full_path_len, &quot;length already checked above&quot;);
4196 
4197   return ERROR_SUCCESS;
4198 }
4199 
4200 static void set_path_prefix(char* buf, LPWSTR* prefix, int* prefix_off, bool* needs_fullpath) {
4201   *prefix_off = 0;
4202   *needs_fullpath = true;
4203 
4204   if (::isalpha(buf[0]) &amp;&amp; !::IsDBCSLeadByte(buf[0]) &amp;&amp; buf[1] == &#39;:&#39; &amp;&amp; buf[2] == &#39;\\&#39;) {
4205     *prefix = L&quot;\\\\?\\&quot;;
4206   } else if (buf[0] == &#39;\\&#39; &amp;&amp; buf[1] == &#39;\\&#39;) {
4207     if (buf[2] == &#39;?&#39; &amp;&amp; buf[3] == &#39;\\&#39;) {
4208       *prefix = L&quot;&quot;;
4209       *needs_fullpath = false;
4210     } else {
4211       *prefix = L&quot;\\\\?\\UNC&quot;;
4212       *prefix_off = 1; // Overwrite the first char with the prefix, so \\share\path becomes \\?\UNC\share\path
4213     }
4214   } else {
4215     *prefix = L&quot;\\\\?\\&quot;;
4216   }
4217 }
4218 
4219 // Returns the given path as an absolute wide path in unc format. The returned path is NULL
4220 // on error (with err being set accordingly) and should be freed via os::free() otherwise.
4221 // additional_space is the size of space, in wchar_t, the function will additionally add to
4222 // the allocation of return buffer (such that the size of the returned buffer is at least
4223 // wcslen(buf) + 1 + additional_space).
4224 static wchar_t* wide_abs_unc_path(char const* path, errno_t &amp; err, int additional_space = 0) {
4225   if ((path == NULL) || (path[0] == &#39;\0&#39;)) {
4226     err = ENOENT;
4227     return NULL;
4228   }
4229 
4230   // Need to allocate at least room for 3 characters, since os::native_path transforms C: to C:.
4231   size_t buf_len = 1 + MAX2((size_t)3, strlen(path));
4232   char* buf = NEW_C_HEAP_ARRAY(char, buf_len, mtInternal);
4233   strncpy(buf, path, buf_len);
4234   os::native_path(buf);
4235 
4236   LPWSTR prefix = NULL;
4237   int prefix_off = 0;
4238   bool needs_fullpath = true;
4239   set_path_prefix(buf, &amp;prefix, &amp;prefix_off, &amp;needs_fullpath);
4240 
4241   LPWSTR unicode_path = NULL;
4242   err = convert_to_unicode(buf, &amp;unicode_path);
4243   FREE_C_HEAP_ARRAY(char, buf);
4244   if (err != ERROR_SUCCESS) {
4245     return NULL;
4246   }
4247 
4248   LPWSTR converted_path = NULL;
4249   if (needs_fullpath) {
4250     err = get_full_path(unicode_path, &amp;converted_path);
4251   } else {
4252     converted_path = unicode_path;
4253   }
4254 
4255   LPWSTR result = NULL;
4256   if (converted_path != NULL) {
4257     size_t prefix_len = wcslen(prefix);
4258     size_t result_len = prefix_len - prefix_off + wcslen(converted_path) + additional_space + 1;
4259     result = NEW_C_HEAP_ARRAY(WCHAR, result_len, mtInternal);
4260     _snwprintf(result, result_len, L&quot;%s%s&quot;, prefix, &amp;converted_path[prefix_off]);
4261 
4262     // Remove trailing pathsep (not for \\?\&lt;DRIVE&gt;:\, since it would make it relative)
4263     result_len = wcslen(result);
4264     if ((result[result_len - 1] == L&#39;\\&#39;) &amp;&amp;
4265         !(::iswalpha(result[4]) &amp;&amp; result[5] == L&#39;:&#39; &amp;&amp; result_len == 7)) {
4266       result[result_len - 1] = L&#39;\0&#39;;
4267     }
4268   }
4269 
4270   if (converted_path != unicode_path) {
4271     FREE_C_HEAP_ARRAY(WCHAR, converted_path);
4272   }
4273   FREE_C_HEAP_ARRAY(WCHAR, unicode_path);
4274 
4275   return static_cast&lt;wchar_t*&gt;(result); // LPWSTR and wchat_t* are the same type on Windows.
4276 }
4277 
4278 int os::stat(const char *path, struct stat *sbuf) {
4279   errno_t err;
4280   wchar_t* wide_path = wide_abs_unc_path(path, err);
4281 
4282   if (wide_path == NULL) {
4283     errno = err;
4284     return -1;
4285   }
4286 
4287   WIN32_FILE_ATTRIBUTE_DATA file_data;;
4288   BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &amp;file_data);
4289   os::free(wide_path);
4290 
4291   if (!bret) {
4292     errno = ::GetLastError();
4293     return -1;
4294   }
4295 
4296   file_attribute_data_to_stat(sbuf, file_data);
4297   return 0;
4298 }
4299 
4300 static HANDLE create_read_only_file_handle(const char* file) {
4301   errno_t err;
4302   wchar_t* wide_path = wide_abs_unc_path(file, err);
4303 
4304   if (wide_path == NULL) {
4305     errno = err;
4306     return INVALID_HANDLE_VALUE;
4307   }
4308 
4309   HANDLE handle = ::CreateFileW(wide_path, 0, FILE_SHARE_READ,
4310                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4311   os::free(wide_path);
4312 
4313   return handle;
4314 }
4315 
4316 bool os::same_files(const char* file1, const char* file2) {
4317 
4318   if (file1 == NULL &amp;&amp; file2 == NULL) {
4319     return true;
4320   }
4321 
4322   if (file1 == NULL || file2 == NULL) {
4323     return false;
4324   }
4325 
4326   if (strcmp(file1, file2) == 0) {
4327     return true;
4328   }
4329 
4330   HANDLE handle1 = create_read_only_file_handle(file1);
4331   HANDLE handle2 = create_read_only_file_handle(file2);
4332   bool result = false;
4333 
4334   // if we could open both paths...
4335   if (handle1 != INVALID_HANDLE_VALUE &amp;&amp; handle2 != INVALID_HANDLE_VALUE) {
4336     BY_HANDLE_FILE_INFORMATION fileInfo1;
4337     BY_HANDLE_FILE_INFORMATION fileInfo2;
4338     if (::GetFileInformationByHandle(handle1, &amp;fileInfo1) &amp;&amp;
4339       ::GetFileInformationByHandle(handle2, &amp;fileInfo2)) {
4340       // the paths are the same if they refer to the same file (fileindex) on the same volume (volume serial number)
4341       if (fileInfo1.dwVolumeSerialNumber == fileInfo2.dwVolumeSerialNumber &amp;&amp;
4342         fileInfo1.nFileIndexHigh == fileInfo2.nFileIndexHigh &amp;&amp;
4343         fileInfo1.nFileIndexLow == fileInfo2.nFileIndexLow) {
4344         result = true;
4345       }
4346     }
4347   }
4348 
4349   //free the handles
4350   if (handle1 != INVALID_HANDLE_VALUE) {
4351     ::CloseHandle(handle1);
4352   }
4353 
4354   if (handle2 != INVALID_HANDLE_VALUE) {
4355     ::CloseHandle(handle2);
4356   }
4357 
4358   return result;
4359 }
4360 
4361 #define FT2INT64(ft) \
4362   ((jlong)((jlong)(ft).dwHighDateTime &lt;&lt; 32 | (julong)(ft).dwLowDateTime))
4363 
4364 
4365 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
4366 // are used by JVM M&amp;M and JVMTI to get user+sys or user CPU time
4367 // of a thread.
4368 //
4369 // current_thread_cpu_time() and thread_cpu_time(Thread*) returns
4370 // the fast estimate available on the platform.
4371 
4372 // current_thread_cpu_time() is not optimized for Windows yet
4373 jlong os::current_thread_cpu_time() {
4374   // return user + sys since the cost is the same
4375   return os::thread_cpu_time(Thread::current(), true /* user+sys */);
4376 }
4377 
4378 jlong os::thread_cpu_time(Thread* thread) {
4379   // consistent with what current_thread_cpu_time() returns.
4380   return os::thread_cpu_time(thread, true /* user+sys */);
4381 }
4382 
4383 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
4384   return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
4385 }
4386 
4387 jlong os::thread_cpu_time(Thread* thread, bool user_sys_cpu_time) {
4388   // This code is copy from clasic VM -&gt; hpi::sysThreadCPUTime
4389   // If this function changes, os::is_thread_cpu_time_supported() should too
4390   FILETIME CreationTime;
4391   FILETIME ExitTime;
4392   FILETIME KernelTime;
4393   FILETIME UserTime;
4394 
4395   if (GetThreadTimes(thread-&gt;osthread()-&gt;thread_handle(), &amp;CreationTime,
4396                       &amp;ExitTime, &amp;KernelTime, &amp;UserTime) == 0) {
4397     return -1;
4398   } else if (user_sys_cpu_time) {
4399     return (FT2INT64(UserTime) + FT2INT64(KernelTime)) * 100;
4400   } else {
4401     return FT2INT64(UserTime) * 100;
4402   }
4403 }
4404 
4405 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4406   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4407   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4408   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4409   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4410 }
4411 
4412 void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
4413   info_ptr-&gt;max_value = ALL_64_BITS;        // the max value -- all 64 bits
4414   info_ptr-&gt;may_skip_backward = false;      // GetThreadTimes returns absolute time
4415   info_ptr-&gt;may_skip_forward = false;       // GetThreadTimes returns absolute time
4416   info_ptr-&gt;kind = JVMTI_TIMER_TOTAL_CPU;   // user+system time is returned
4417 }
4418 
4419 bool os::is_thread_cpu_time_supported() {
4420   // see os::thread_cpu_time
4421   FILETIME CreationTime;
4422   FILETIME ExitTime;
4423   FILETIME KernelTime;
4424   FILETIME UserTime;
4425 
4426   if (GetThreadTimes(GetCurrentThread(), &amp;CreationTime, &amp;ExitTime,
4427                       &amp;KernelTime, &amp;UserTime) == 0) {
4428     return false;
4429   } else {
4430     return true;
4431   }
4432 }
4433 
4434 // Windows does&#39;t provide a loadavg primitive so this is stubbed out for now.
4435 // It does have primitives (PDH API) to get CPU usage and run queue length.
4436 // &quot;\\Processor(_Total)\\% Processor Time&quot;, &quot;\\System\\Processor Queue Length&quot;
4437 // If we wanted to implement loadavg on Windows, we have a few options:
4438 //
4439 // a) Query CPU usage and run queue length and &quot;fake&quot; an answer by
4440 //    returning the CPU usage if it&#39;s under 100%, and the run queue
4441 //    length otherwise.  It turns out that querying is pretty slow
4442 //    on Windows, on the order of 200 microseconds on a fast machine.
4443 //    Note that on the Windows the CPU usage value is the % usage
4444 //    since the last time the API was called (and the first call
4445 //    returns 100%), so we&#39;d have to deal with that as well.
4446 //
4447 // b) Sample the &quot;fake&quot; answer using a sampling thread and store
4448 //    the answer in a global variable.  The call to loadavg would
4449 //    just return the value of the global, avoiding the slow query.
4450 //
4451 // c) Sample a better answer using exponential decay to smooth the
4452 //    value.  This is basically the algorithm used by UNIX kernels.
4453 //
4454 // Note that sampling thread starvation could affect both (b) and (c).
4455 int os::loadavg(double loadavg[], int nelem) {
4456   return -1;
4457 }
4458 
4459 
4460 // DontYieldALot=false by default: dutifully perform all yields as requested by JVM_Yield()
4461 bool os::dont_yield() {
4462   return DontYieldALot;
4463 }
4464 
4465 int os::open(const char *path, int oflag, int mode) {
4466   errno_t err;
4467   wchar_t* wide_path = wide_abs_unc_path(path, err);
4468 
4469   if (wide_path == NULL) {
4470     errno = err;
4471     return -1;
4472   }
4473   int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);
4474   os::free(wide_path);
4475 
4476   if (fd == -1) {
4477     errno = ::GetLastError();
4478   }
4479 
4480   return fd;
4481 }
4482 
4483 FILE* os::open(int fd, const char* mode) {
4484   return ::_fdopen(fd, mode);
4485 }
4486 
4487 // Is a (classpath) directory empty?
4488 bool os::dir_is_empty(const char* path) {
4489   errno_t err;
4490   wchar_t* wide_path = wide_abs_unc_path(path, err, 2);
4491 
4492   if (wide_path == NULL) {
4493     errno = err;
4494     return false;
4495   }
4496 
4497   // Make sure we end with &quot;\\*&quot;
4498   if (wide_path[wcslen(wide_path) - 1] == L&#39;\\&#39;) {
4499     wcscat(wide_path, L&quot;*&quot;);
4500   } else {
4501     wcscat(wide_path, L&quot;\\*&quot;);
4502   }
4503 
4504   WIN32_FIND_DATAW fd;
4505   HANDLE f = ::FindFirstFileW(wide_path, &amp;fd);
4506   os::free(wide_path);
4507   bool is_empty = true;
4508 
4509   if (f != INVALID_HANDLE_VALUE) {
4510     while (is_empty &amp;&amp; ::FindNextFileW(f, &amp;fd)) {
4511       // An empty directory contains only the current directory file
4512       // and the previous directory file.
4513       if ((wcscmp(fd.cFileName, L&quot;.&quot;) != 0) &amp;&amp;
4514           (wcscmp(fd.cFileName, L&quot;..&quot;) != 0)) {
4515         is_empty = false;
4516       }
4517     }
4518     FindClose(f);
4519   } else {
4520     errno = ::GetLastError();
4521   }
4522 
4523   return is_empty;
4524 }
4525 
4526 // create binary file, rewriting existing file if required
4527 int os::create_binary_file(const char* path, bool rewrite_existing) {
4528   int oflags = _O_CREAT | _O_WRONLY | _O_BINARY;
4529   if (!rewrite_existing) {
4530     oflags |= _O_EXCL;
4531   }
4532   return ::open(path, oflags, _S_IREAD | _S_IWRITE);
4533 }
4534 
4535 // return current position of file pointer
4536 jlong os::current_file_offset(int fd) {
4537   return (jlong)::_lseeki64(fd, (__int64)0L, SEEK_CUR);
4538 }
4539 
4540 // move file pointer to the specified offset
4541 jlong os::seek_to_file_offset(int fd, jlong offset) {
4542   return (jlong)::_lseeki64(fd, (__int64)offset, SEEK_SET);
4543 }
4544 
4545 
4546 jlong os::lseek(int fd, jlong offset, int whence) {
4547   return (jlong) ::_lseeki64(fd, offset, whence);
4548 }
4549 
4550 ssize_t os::read_at(int fd, void *buf, unsigned int nBytes, jlong offset) {
4551   OVERLAPPED ov;
4552   DWORD nread;
4553   BOOL result;
4554 
4555   ZeroMemory(&amp;ov, sizeof(ov));
4556   ov.Offset = (DWORD)offset;
4557   ov.OffsetHigh = (DWORD)(offset &gt;&gt; 32);
4558 
4559   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4560 
4561   result = ReadFile(h, (LPVOID)buf, nBytes, &amp;nread, &amp;ov);
4562 
4563   return result ? nread : 0;
4564 }
4565 
4566 
4567 // This method is a slightly reworked copy of JDK&#39;s sysNativePath
4568 // from src/windows/hpi/src/path_md.c
4569 
4570 // Convert a pathname to native format.  On win32, this involves forcing all
4571 // separators to be &#39;\\&#39; rather than &#39;/&#39; (both are legal inputs, but Win95
4572 // sometimes rejects &#39;/&#39;) and removing redundant separators.  The input path is
4573 // assumed to have been converted into the character encoding used by the local
4574 // system.  Because this might be a double-byte encoding, care is taken to
4575 // treat double-byte lead characters correctly.
4576 //
4577 // This procedure modifies the given path in place, as the result is never
4578 // longer than the original.  There is no error return; this operation always
4579 // succeeds.
4580 char * os::native_path(char *path) {
4581   char *src = path, *dst = path, *end = path;
4582   char *colon = NULL;  // If a drive specifier is found, this will
4583                        // point to the colon following the drive letter
4584 
4585   // Assumption: &#39;/&#39;, &#39;\\&#39;, &#39;:&#39;, and drive letters are never lead bytes
4586   assert(((!::IsDBCSLeadByte(&#39;/&#39;)) &amp;&amp; (!::IsDBCSLeadByte(&#39;\\&#39;))
4587           &amp;&amp; (!::IsDBCSLeadByte(&#39;:&#39;))), &quot;Illegal lead byte&quot;);
4588 
4589   // Check for leading separators
4590 #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)
4591   while (isfilesep(*src)) {
4592     src++;
4593   }
4594 
4595   if (::isalpha(*src) &amp;&amp; !::IsDBCSLeadByte(*src) &amp;&amp; src[1] == &#39;:&#39;) {
4596     // Remove leading separators if followed by drive specifier.  This
4597     // hack is necessary to support file URLs containing drive
4598     // specifiers (e.g., &quot;file://c:/path&quot;).  As a side effect,
4599     // &quot;/c:/path&quot; can be used as an alternative to &quot;c:/path&quot;.
4600     *dst++ = *src++;
4601     colon = dst;
4602     *dst++ = &#39;:&#39;;
4603     src++;
4604   } else {
4605     src = path;
4606     if (isfilesep(src[0]) &amp;&amp; isfilesep(src[1])) {
4607       // UNC pathname: Retain first separator; leave src pointed at
4608       // second separator so that further separators will be collapsed
4609       // into the second separator.  The result will be a pathname
4610       // beginning with &quot;\\\\&quot; followed (most likely) by a host name.
4611       src = dst = path + 1;
4612       path[0] = &#39;\\&#39;;     // Force first separator to &#39;\\&#39;
4613     }
4614   }
4615 
4616   end = dst;
4617 
4618   // Remove redundant separators from remainder of path, forcing all
4619   // separators to be &#39;\\&#39; rather than &#39;/&#39;. Also, single byte space
4620   // characters are removed from the end of the path because those
4621   // are not legal ending characters on this operating system.
4622   //
4623   while (*src != &#39;\0&#39;) {
4624     if (isfilesep(*src)) {
4625       *dst++ = &#39;\\&#39;; src++;
4626       while (isfilesep(*src)) src++;
4627       if (*src == &#39;\0&#39;) {
4628         // Check for trailing separator
4629         end = dst;
4630         if (colon == dst - 2) break;  // &quot;z:\\&quot;
4631         if (dst == path + 1) break;   // &quot;\\&quot;
4632         if (dst == path + 2 &amp;&amp; isfilesep(path[0])) {
4633           // &quot;\\\\&quot; is not collapsed to &quot;\\&quot; because &quot;\\\\&quot; marks the
4634           // beginning of a UNC pathname.  Even though it is not, by
4635           // itself, a valid UNC pathname, we leave it as is in order
4636           // to be consistent with the path canonicalizer as well
4637           // as the win32 APIs, which treat this case as an invalid
4638           // UNC pathname rather than as an alias for the root
4639           // directory of the current drive.
4640           break;
4641         }
4642         end = --dst;  // Path does not denote a root directory, so
4643                       // remove trailing separator
4644         break;
4645       }
4646       end = dst;
4647     } else {
4648       if (::IsDBCSLeadByte(*src)) {  // Copy a double-byte character
4649         *dst++ = *src++;
4650         if (*src) *dst++ = *src++;
4651         end = dst;
4652       } else {  // Copy a single-byte character
4653         char c = *src++;
4654         *dst++ = c;
4655         // Space is not a legal ending character
4656         if (c != &#39; &#39;) end = dst;
4657       }
4658     }
4659   }
4660 
4661   *end = &#39;\0&#39;;
4662 
4663   // For &quot;z:&quot;, add &quot;.&quot; to work around a bug in the C runtime library
4664   if (colon == dst - 1) {
4665     path[2] = &#39;.&#39;;
4666     path[3] = &#39;\0&#39;;
4667   }
4668 
4669   return path;
4670 }
4671 
4672 // This code is a copy of JDK&#39;s sysSetLength
4673 // from src/windows/hpi/src/sys_api_md.c
4674 
4675 int os::ftruncate(int fd, jlong length) {
4676   HANDLE h = (HANDLE)::_get_osfhandle(fd);
4677   long high = (long)(length &gt;&gt; 32);
4678   DWORD ret;
4679 
4680   if (h == (HANDLE)(-1)) {
4681     return -1;
4682   }
4683 
4684   ret = ::SetFilePointer(h, (long)(length), &amp;high, FILE_BEGIN);
4685   if ((ret == 0xFFFFFFFF) &amp;&amp; (::GetLastError() != NO_ERROR)) {
4686     return -1;
4687   }
4688 
4689   if (::SetEndOfFile(h) == FALSE) {
4690     return -1;
4691   }
4692 
4693   return 0;
4694 }
4695 
4696 int os::get_fileno(FILE* fp) {
4697   return _fileno(fp);
4698 }
4699 
4700 // This code is a copy of JDK&#39;s sysSync
4701 // from src/windows/hpi/src/sys_api_md.c
4702 // except for the legacy workaround for a bug in Win 98
4703 
4704 int os::fsync(int fd) {
4705   HANDLE handle = (HANDLE)::_get_osfhandle(fd);
4706 
4707   if ((!::FlushFileBuffers(handle)) &amp;&amp;
4708       (GetLastError() != ERROR_ACCESS_DENIED)) {
4709     // from winerror.h
4710     return -1;
4711   }
4712   return 0;
4713 }
4714 
4715 static int nonSeekAvailable(int, long *);
4716 static int stdinAvailable(int, long *);
4717 
4718 // This code is a copy of JDK&#39;s sysAvailable
4719 // from src/windows/hpi/src/sys_api_md.c
4720 
4721 int os::available(int fd, jlong *bytes) {
4722   jlong cur, end;
4723   struct _stati64 stbuf64;
4724 
4725   if (::_fstati64(fd, &amp;stbuf64) &gt;= 0) {
4726     int mode = stbuf64.st_mode;
4727     if (S_ISCHR(mode) || S_ISFIFO(mode)) {
4728       int ret;
4729       long lpbytes;
4730       if (fd == 0) {
4731         ret = stdinAvailable(fd, &amp;lpbytes);
4732       } else {
4733         ret = nonSeekAvailable(fd, &amp;lpbytes);
4734       }
4735       (*bytes) = (jlong)(lpbytes);
4736       return ret;
4737     }
4738     if ((cur = ::_lseeki64(fd, 0L, SEEK_CUR)) == -1) {
4739       return FALSE;
4740     } else if ((end = ::_lseeki64(fd, 0L, SEEK_END)) == -1) {
4741       return FALSE;
4742     } else if (::_lseeki64(fd, cur, SEEK_SET) == -1) {
4743       return FALSE;
4744     }
4745     *bytes = end - cur;
4746     return TRUE;
4747   } else {
4748     return FALSE;
4749   }
4750 }
4751 
4752 void os::flockfile(FILE* fp) {
4753   _lock_file(fp);
4754 }
4755 
4756 void os::funlockfile(FILE* fp) {
4757   _unlock_file(fp);
4758 }
4759 
4760 // This code is a copy of JDK&#39;s nonSeekAvailable
4761 // from src/windows/hpi/src/sys_api_md.c
4762 
4763 static int nonSeekAvailable(int fd, long *pbytes) {
4764   // This is used for available on non-seekable devices
4765   // (like both named and anonymous pipes, such as pipes
4766   //  connected to an exec&#39;d process).
4767   // Standard Input is a special case.
4768   HANDLE han;
4769 
4770   if ((han = (HANDLE) ::_get_osfhandle(fd)) == (HANDLE)(-1)) {
4771     return FALSE;
4772   }
4773 
4774   if (! ::PeekNamedPipe(han, NULL, 0, NULL, (LPDWORD)pbytes, NULL)) {
4775     // PeekNamedPipe fails when at EOF.  In that case we
4776     // simply make *pbytes = 0 which is consistent with the
4777     // behavior we get on Solaris when an fd is at EOF.
4778     // The only alternative is to raise an Exception,
4779     // which isn&#39;t really warranted.
4780     //
4781     if (::GetLastError() != ERROR_BROKEN_PIPE) {
4782       return FALSE;
4783     }
4784     *pbytes = 0;
4785   }
4786   return TRUE;
4787 }
4788 
4789 #define MAX_INPUT_EVENTS 2000
4790 
4791 // This code is a copy of JDK&#39;s stdinAvailable
4792 // from src/windows/hpi/src/sys_api_md.c
4793 
4794 static int stdinAvailable(int fd, long *pbytes) {
4795   HANDLE han;
4796   DWORD numEventsRead = 0;  // Number of events read from buffer
4797   DWORD numEvents = 0;      // Number of events in buffer
4798   DWORD i = 0;              // Loop index
4799   DWORD curLength = 0;      // Position marker
4800   DWORD actualLength = 0;   // Number of bytes readable
4801   BOOL error = FALSE;       // Error holder
4802   INPUT_RECORD *lpBuffer;   // Pointer to records of input events
4803 
4804   if ((han = ::GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
4805     return FALSE;
4806   }
4807 
4808   // Construct an array of input records in the console buffer
4809   error = ::GetNumberOfConsoleInputEvents(han, &amp;numEvents);
4810   if (error == 0) {
4811     return nonSeekAvailable(fd, pbytes);
4812   }
4813 
4814   // lpBuffer must fit into 64K or else PeekConsoleInput fails
4815   if (numEvents &gt; MAX_INPUT_EVENTS) {
4816     numEvents = MAX_INPUT_EVENTS;
4817   }
4818 
4819   lpBuffer = (INPUT_RECORD *)os::malloc(numEvents * sizeof(INPUT_RECORD), mtInternal);
4820   if (lpBuffer == NULL) {
4821     return FALSE;
4822   }
4823 
4824   error = ::PeekConsoleInput(han, lpBuffer, numEvents, &amp;numEventsRead);
4825   if (error == 0) {
4826     os::free(lpBuffer);
4827     return FALSE;
4828   }
4829 
4830   // Examine input records for the number of bytes available
4831   for (i=0; i&lt;numEvents; i++) {
4832     if (lpBuffer[i].EventType == KEY_EVENT) {
4833 
4834       KEY_EVENT_RECORD *keyRecord = (KEY_EVENT_RECORD *)
4835                                       &amp;(lpBuffer[i].Event);
4836       if (keyRecord-&gt;bKeyDown == TRUE) {
4837         CHAR *keyPressed = (CHAR *) &amp;(keyRecord-&gt;uChar);
4838         curLength++;
4839         if (*keyPressed == &#39;\r&#39;) {
4840           actualLength = curLength;
4841         }
4842       }
4843     }
4844   }
4845 
4846   if (lpBuffer != NULL) {
4847     os::free(lpBuffer);
4848   }
4849 
4850   *pbytes = (long) actualLength;
4851   return TRUE;
4852 }
4853 
4854 // Map a block of memory.
4855 char* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,
4856                         char *addr, size_t bytes, bool read_only,
4857                         bool allow_exec) {
4858   HANDLE hFile;
4859   char* base;
4860 
4861   hFile = CreateFile(file_name, GENERIC_READ, FILE_SHARE_READ, NULL,
4862                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
4863   if (hFile == NULL) {
4864     log_info(os)(&quot;CreateFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4865     return NULL;
4866   }
4867 
4868   if (allow_exec) {
4869     // CreateFileMapping/MapViewOfFileEx can&#39;t map executable memory
4870     // unless it comes from a PE image (which the shared archive is not.)
4871     // Even VirtualProtect refuses to give execute access to mapped memory
4872     // that was not previously executable.
4873     //
4874     // Instead, stick the executable region in anonymous memory.  Yuck.
4875     // Penalty is that ~4 pages will not be shareable - in the future
4876     // we might consider DLLizing the shared archive with a proper PE
4877     // header so that mapping executable + sharing is possible.
4878 
4879     base = (char*) VirtualAlloc(addr, bytes, MEM_COMMIT | MEM_RESERVE,
4880                                 PAGE_READWRITE);
4881     if (base == NULL) {
4882       log_info(os)(&quot;VirtualAlloc() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4883       CloseHandle(hFile);
4884       return NULL;
4885     }
4886 
4887     // Record virtual memory allocation
4888     MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);
4889 
4890     DWORD bytes_read;
4891     OVERLAPPED overlapped;
4892     overlapped.Offset = (DWORD)file_offset;
4893     overlapped.OffsetHigh = 0;
4894     overlapped.hEvent = NULL;
4895     // ReadFile guarantees that if the return value is true, the requested
4896     // number of bytes were read before returning.
4897     bool res = ReadFile(hFile, base, (DWORD)bytes, &amp;bytes_read, &amp;overlapped) != 0;
4898     if (!res) {
4899       log_info(os)(&quot;ReadFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4900       release_memory(base, bytes);
4901       CloseHandle(hFile);
4902       return NULL;
4903     }
4904   } else {
4905     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,
4906                                     NULL /* file_name */);
4907     if (hMap == NULL) {
4908       log_info(os)(&quot;CreateFileMapping() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4909       CloseHandle(hFile);
4910       return NULL;
4911     }
4912 
4913     DWORD access = read_only ? FILE_MAP_READ : FILE_MAP_COPY;
4914     base = (char*)MapViewOfFileEx(hMap, access, 0, (DWORD)file_offset,
4915                                   (DWORD)bytes, addr);
4916     if (base == NULL) {
4917       log_info(os)(&quot;MapViewOfFileEx() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4918       CloseHandle(hMap);
4919       CloseHandle(hFile);
4920       return NULL;
4921     }
4922 
4923     if (CloseHandle(hMap) == 0) {
4924       log_info(os)(&quot;CloseHandle(hMap) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4925       CloseHandle(hFile);
4926       return base;
4927     }
4928   }
4929 
4930   if (allow_exec) {
4931     DWORD old_protect;
4932     DWORD exec_access = read_only ? PAGE_EXECUTE_READ : PAGE_EXECUTE_READWRITE;
4933     bool res = VirtualProtect(base, bytes, exec_access, &amp;old_protect) != 0;
4934 
4935     if (!res) {
4936       log_info(os)(&quot;VirtualProtect() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4937       // Don&#39;t consider this a hard error, on IA32 even if the
4938       // VirtualProtect fails, we should still be able to execute
4939       CloseHandle(hFile);
4940       return base;
4941     }
4942   }
4943 
4944   if (CloseHandle(hFile) == 0) {
4945     log_info(os)(&quot;CloseHandle(hFile) failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4946     return base;
4947   }
4948 
4949   return base;
4950 }
4951 
4952 
4953 // Remap a block of memory.
4954 char* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,
4955                           char *addr, size_t bytes, bool read_only,
4956                           bool allow_exec) {
4957   // This OS does not allow existing memory maps to be remapped so we
4958   // would have to unmap the memory before we remap it.
4959 
4960   // Because there is a small window between unmapping memory and mapping
4961   // it in again with different protections, CDS archives are mapped RW
4962   // on windows, so this function isn&#39;t called.
4963   ShouldNotReachHere();
4964   return NULL;
4965 }
4966 
4967 
4968 // Unmap a block of memory.
4969 // Returns true=success, otherwise false.
4970 
4971 bool os::pd_unmap_memory(char* addr, size_t bytes) {
4972   MEMORY_BASIC_INFORMATION mem_info;
4973   if (VirtualQuery(addr, &amp;mem_info, sizeof(mem_info)) == 0) {
4974     log_info(os)(&quot;VirtualQuery() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4975     return false;
4976   }
4977 
4978   // Executable memory was not mapped using CreateFileMapping/MapViewOfFileEx.
4979   // Instead, executable region was allocated using VirtualAlloc(). See
4980   // pd_map_memory() above.
4981   //
4982   // The following flags should match the &#39;exec_access&#39; flages used for
4983   // VirtualProtect() in pd_map_memory().
4984   if (mem_info.Protect == PAGE_EXECUTE_READ ||
4985       mem_info.Protect == PAGE_EXECUTE_READWRITE) {
4986     return pd_release_memory(addr, bytes);
4987   }
4988 
4989   BOOL result = UnmapViewOfFile(addr);
4990   if (result == 0) {
4991     log_info(os)(&quot;UnmapViewOfFile() failed: GetLastError-&gt;%ld.&quot;, GetLastError());
4992     return false;
4993   }
4994   return true;
4995 }
4996 
4997 void os::pause() {
4998   char filename[MAX_PATH];
4999   if (PauseAtStartupFile &amp;&amp; PauseAtStartupFile[0]) {
5000     jio_snprintf(filename, MAX_PATH, &quot;%s&quot;, PauseAtStartupFile);
5001   } else {
5002     jio_snprintf(filename, MAX_PATH, &quot;./vm.paused.%d&quot;, current_process_id());
5003   }
5004 
5005   int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);
5006   if (fd != -1) {
5007     struct stat buf;
5008     ::close(fd);
5009     while (::stat(filename, &amp;buf) == 0) {
5010       Sleep(100);
5011     }
5012   } else {
5013     jio_fprintf(stderr,
5014                 &quot;Could not open pause file &#39;%s&#39;, continuing immediately.\n&quot;, filename);
5015   }
5016 }
5017 
5018 Thread* os::ThreadCrashProtection::_protected_thread = NULL;
5019 os::ThreadCrashProtection* os::ThreadCrashProtection::_crash_protection = NULL;
5020 volatile intptr_t os::ThreadCrashProtection::_crash_mux = 0;
5021 
5022 os::ThreadCrashProtection::ThreadCrashProtection() {
5023 }
5024 
5025 // See the caveats for this class in os_windows.hpp
5026 // Protects the callback call so that raised OS EXCEPTIONS causes a jump back
5027 // into this method and returns false. If no OS EXCEPTION was raised, returns
5028 // true.
5029 // The callback is supposed to provide the method that should be protected.
5030 //
5031 bool os::ThreadCrashProtection::call(os::CrashProtectionCallback&amp; cb) {
5032 
5033   Thread::muxAcquire(&amp;_crash_mux, &quot;CrashProtection&quot;);
5034 
5035   _protected_thread = Thread::current_or_null();
5036   assert(_protected_thread != NULL, &quot;Cannot crash protect a NULL thread&quot;);
5037 
5038   bool success = true;
5039   __try {
5040     _crash_protection = this;
5041     cb.call();
5042   } __except(EXCEPTION_EXECUTE_HANDLER) {
5043     // only for protection, nothing to do
5044     success = false;
5045   }
5046   _crash_protection = NULL;
5047   _protected_thread = NULL;
5048   Thread::muxRelease(&amp;_crash_mux);
5049   return success;
5050 }
5051 
5052 
5053 class HighResolutionInterval : public CHeapObj&lt;mtThread&gt; {
5054   // The default timer resolution seems to be 10 milliseconds.
5055   // (Where is this written down?)
5056   // If someone wants to sleep for only a fraction of the default,
5057   // then we set the timer resolution down to 1 millisecond for
5058   // the duration of their interval.
5059   // We carefully set the resolution back, since otherwise we
5060   // seem to incur an overhead (3%?) that we don&#39;t need.
5061   // CONSIDER: if ms is small, say 3, then we should run with a high resolution time.
5062   // Buf if ms is large, say 500, or 503, we should avoid the call to timeBeginPeriod().
5063   // Alternatively, we could compute the relative error (503/500 = .6%) and only use
5064   // timeBeginPeriod() if the relative error exceeded some threshold.
5065   // timeBeginPeriod() has been linked to problems with clock drift on win32 systems and
5066   // to decreased efficiency related to increased timer &quot;tick&quot; rates.  We want to minimize
5067   // (a) calls to timeBeginPeriod() and timeEndPeriod() and (b) time spent with high
5068   // resolution timers running.
5069  private:
5070   jlong resolution;
5071  public:
5072   HighResolutionInterval(jlong ms) {
5073     resolution = ms % 10L;
5074     if (resolution != 0) {
5075       MMRESULT result = timeBeginPeriod(1L);
5076     }
5077   }
5078   ~HighResolutionInterval() {
5079     if (resolution != 0) {
5080       MMRESULT result = timeEndPeriod(1L);
5081     }
5082     resolution = 0L;
5083   }
5084 };
5085 
5086 // An Event wraps a win32 &quot;CreateEvent&quot; kernel handle.
5087 //
5088 // We have a number of choices regarding &quot;CreateEvent&quot; win32 handle leakage:
5089 //
5090 // 1:  When a thread dies return the Event to the EventFreeList, clear the ParkHandle
5091 //     field, and call CloseHandle() on the win32 event handle.  Unpark() would
5092 //     need to be modified to tolerate finding a NULL (invalid) win32 event handle.
5093 //     In addition, an unpark() operation might fetch the handle field, but the
5094 //     event could recycle between the fetch and the SetEvent() operation.
5095 //     SetEvent() would either fail because the handle was invalid, or inadvertently work,
5096 //     as the win32 handle value had been recycled.  In an ideal world calling SetEvent()
5097 //     on an stale but recycled handle would be harmless, but in practice this might
5098 //     confuse other non-Sun code, so it&#39;s not a viable approach.
5099 //
5100 // 2:  Once a win32 event handle is associated with an Event, it remains associated
5101 //     with the Event.  The event handle is never closed.  This could be construed
5102 //     as handle leakage, but only up to the maximum # of threads that have been extant
5103 //     at any one time.  This shouldn&#39;t be an issue, as windows platforms typically
5104 //     permit a process to have hundreds of thousands of open handles.
5105 //
5106 // 3:  Same as (1), but periodically, at stop-the-world time, rundown the EventFreeList
5107 //     and release unused handles.
5108 //
5109 // 4:  Add a CRITICAL_SECTION to the Event to protect LD+SetEvent from LD;ST(null);CloseHandle.
5110 //     It&#39;s not clear, however, that we wouldn&#39;t be trading one type of leak for another.
5111 //
5112 // 5.  Use an RCU-like mechanism (Read-Copy Update).
5113 //     Or perhaps something similar to Maged Michael&#39;s &quot;Hazard pointers&quot;.
5114 //
5115 // We use (2).
5116 //
5117 // TODO-FIXME:
5118 // 1.  Reconcile Doug&#39;s JSR166 j.u.c park-unpark with the objectmonitor implementation.
5119 // 2.  Consider wrapping the WaitForSingleObject(Ex) calls in SEH try/finally blocks
5120 //     to recover from (or at least detect) the dreaded Windows 841176 bug.
5121 // 3.  Collapse the JSR166 parker event, and the objectmonitor ParkEvent
5122 //     into a single win32 CreateEvent() handle.
5123 //
5124 // Assumption:
5125 //    Only one parker can exist on an event, which is why we allocate
5126 //    them per-thread. Multiple unparkers can coexist.
5127 //
5128 // _Event transitions in park()
5129 //   -1 =&gt; -1 : illegal
5130 //    1 =&gt;  0 : pass - return immediately
5131 //    0 =&gt; -1 : block; then set _Event to 0 before returning
5132 //
5133 // _Event transitions in unpark()
5134 //    0 =&gt; 1 : just return
5135 //    1 =&gt; 1 : just return
5136 //   -1 =&gt; either 0 or 1; must signal target thread
5137 //         That is, we can safely transition _Event from -1 to either
5138 //         0 or 1.
5139 //
5140 // _Event serves as a restricted-range semaphore.
5141 //   -1 : thread is blocked, i.e. there is a waiter
5142 //    0 : neutral: thread is running or ready,
5143 //        could have been signaled after a wait started
5144 //    1 : signaled - thread is running or ready
5145 //
5146 // Another possible encoding of _Event would be with
5147 // explicit &quot;PARKED&quot; == 01b and &quot;SIGNALED&quot; == 10b bits.
5148 //
5149 
5150 int os::PlatformEvent::park(jlong Millis) {
5151   // Transitions for _Event:
5152   //   -1 =&gt; -1 : illegal
5153   //    1 =&gt;  0 : pass - return immediately
5154   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5155 
5156   guarantee(_ParkHandle != NULL , &quot;Invariant&quot;);
5157   guarantee(Millis &gt; 0          , &quot;Invariant&quot;);
5158 
5159   // CONSIDER: defer assigning a CreateEvent() handle to the Event until
5160   // the initial park() operation.
5161   // Consider: use atomic decrement instead of CAS-loop
5162 
5163   int v;
5164   for (;;) {
5165     v = _Event;
5166     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5167   }
5168   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5169   if (v != 0) return OS_OK;
5170 
5171   // Do this the hard way by blocking ...
5172   // TODO: consider a brief spin here, gated on the success of recent
5173   // spin attempts by this thread.
5174   //
5175   // We decompose long timeouts into series of shorter timed waits.
5176   // Evidently large timo values passed in WaitForSingleObject() are problematic on some
5177   // versions of Windows.  See EventWait() for details.  This may be superstition.  Or not.
5178   // We trust the WAIT_TIMEOUT indication and don&#39;t track the elapsed wait time
5179   // with os::javaTimeNanos().  Furthermore, we assume that spurious returns from
5180   // ::WaitForSingleObject() caused by latent ::setEvent() operations will tend
5181   // to happen early in the wait interval.  Specifically, after a spurious wakeup (rv ==
5182   // WAIT_OBJECT_0 but _Event is still &lt; 0) we don&#39;t bother to recompute Millis to compensate
5183   // for the already waited time.  This policy does not admit any new outcomes.
5184   // In the future, however, we might want to track the accumulated wait time and
5185   // adjust Millis accordingly if we encounter a spurious wakeup.
5186 
5187   const int MAXTIMEOUT = 0x10000000;
5188   DWORD rv = WAIT_TIMEOUT;
5189   while (_Event &lt; 0 &amp;&amp; Millis &gt; 0) {
5190     DWORD prd = Millis;     // set prd = MAX (Millis, MAXTIMEOUT)
5191     if (Millis &gt; MAXTIMEOUT) {
5192       prd = MAXTIMEOUT;
5193     }
5194     HighResolutionInterval *phri = NULL;
5195     if (!ForceTimeHighResolution) {
5196       phri = new HighResolutionInterval(prd);
5197     }
5198     rv = ::WaitForSingleObject(_ParkHandle, prd);
5199     assert(rv == WAIT_OBJECT_0 || rv == WAIT_TIMEOUT, &quot;WaitForSingleObject failed&quot;);
5200     if (rv == WAIT_TIMEOUT) {
5201       Millis -= prd;
5202     }
5203     delete phri; // if it is NULL, harmless
5204   }
5205   v = _Event;
5206   _Event = 0;
5207   // see comment at end of os::PlatformEvent::park() below:
5208   OrderAccess::fence();
5209   // If we encounter a nearly simultanous timeout expiry and unpark()
5210   // we return OS_OK indicating we awoke via unpark().
5211   // Implementor&#39;s license -- returning OS_TIMEOUT would be equally valid, however.
5212   return (v &gt;= 0) ? OS_OK : OS_TIMEOUT;
5213 }
5214 
5215 void os::PlatformEvent::park() {
5216   // Transitions for _Event:
5217   //   -1 =&gt; -1 : illegal
5218   //    1 =&gt;  0 : pass - return immediately
5219   //    0 =&gt; -1 : block; then set _Event to 0 before returning
5220 
5221   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5222   // Invariant: Only the thread associated with the Event/PlatformEvent
5223   // may call park().
5224   // Consider: use atomic decrement instead of CAS-loop
5225   int v;
5226   for (;;) {
5227     v = _Event;
5228     if (Atomic::cmpxchg(&amp;_Event, v, v-1) == v) break;
5229   }
5230   guarantee((v == 0) || (v == 1), &quot;invariant&quot;);
5231   if (v != 0) return;
5232 
5233   // Do this the hard way by blocking ...
5234   // TODO: consider a brief spin here, gated on the success of recent
5235   // spin attempts by this thread.
5236   while (_Event &lt; 0) {
5237     DWORD rv = ::WaitForSingleObject(_ParkHandle, INFINITE);
5238     assert(rv == WAIT_OBJECT_0, &quot;WaitForSingleObject failed&quot;);
5239   }
5240 
5241   // Usually we&#39;ll find _Event == 0 at this point, but as
5242   // an optional optimization we clear it, just in case can
5243   // multiple unpark() operations drove _Event up to 1.
5244   _Event = 0;
5245   OrderAccess::fence();
5246   guarantee(_Event &gt;= 0, &quot;invariant&quot;);
5247 }
5248 
5249 void os::PlatformEvent::unpark() {
5250   guarantee(_ParkHandle != NULL, &quot;Invariant&quot;);
5251 
5252   // Transitions for _Event:
5253   //    0 =&gt; 1 : just return
5254   //    1 =&gt; 1 : just return
5255   //   -1 =&gt; either 0 or 1; must signal target thread
5256   //         That is, we can safely transition _Event from -1 to either
5257   //         0 or 1.
5258   // See also: &quot;Semaphores in Plan 9&quot; by Mullender &amp; Cox
5259   //
5260   // Note: Forcing a transition from &quot;-1&quot; to &quot;1&quot; on an unpark() means
5261   // that it will take two back-to-back park() calls for the owning
5262   // thread to block. This has the benefit of forcing a spurious return
5263   // from the first park() call after an unpark() call which will help
5264   // shake out uses of park() and unpark() without condition variables.
5265 
5266   if (Atomic::xchg(&amp;_Event, 1) &gt;= 0) return;
5267 
5268   ::SetEvent(_ParkHandle);
5269 }
5270 
5271 
5272 // JSR166
5273 // -------------------------------------------------------
5274 
5275 // The Windows implementation of Park is very straightforward: Basic
5276 // operations on Win32 Events turn out to have the right semantics to
5277 // use them directly. We opportunistically resuse the event inherited
5278 // from Monitor.
5279 
5280 void Parker::park(bool isAbsolute, jlong time) {
5281   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5282   // First, demultiplex/decode time arguments
5283   if (time &lt; 0) { // don&#39;t wait
5284     return;
5285   } else if (time == 0 &amp;&amp; !isAbsolute) {
5286     time = INFINITE;
5287   } else if (isAbsolute) {
5288     time -= os::javaTimeMillis(); // convert to relative time
5289     if (time &lt;= 0) {  // already elapsed
5290       return;
5291     }
5292   } else { // relative
5293     time /= 1000000;  // Must coarsen from nanos to millis
5294     if (time == 0) {  // Wait for the minimal time unit if zero
5295       time = 1;
5296     }
5297   }
5298 
5299   JavaThread* thread = JavaThread::current();
5300 
5301   // Don&#39;t wait if interrupted or already triggered
5302   if (thread-&gt;is_interrupted(false) ||
5303       WaitForSingleObject(_ParkEvent, 0) == WAIT_OBJECT_0) {
5304     ResetEvent(_ParkEvent);
5305     return;
5306   } else {
5307     ThreadBlockInVM tbivm(thread);
5308     OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);
5309     thread-&gt;set_suspend_equivalent();
5310 
5311     WaitForSingleObject(_ParkEvent, time);
5312     ResetEvent(_ParkEvent);
5313 
5314     // If externally suspended while waiting, re-suspend
5315     if (thread-&gt;handle_special_suspend_equivalent_condition()) {
5316       thread-&gt;java_suspend_self();
5317     }
5318   }
5319 }
5320 
5321 void Parker::unpark() {
5322   guarantee(_ParkEvent != NULL, &quot;invariant&quot;);
5323   SetEvent(_ParkEvent);
5324 }
5325 
5326 // Platform Monitor implementation
5327 
5328 // Must already be locked
5329 int os::PlatformMonitor::wait(jlong millis) {
5330   assert(millis &gt;= 0, &quot;negative timeout&quot;);
5331   int ret = OS_TIMEOUT;
5332   int status = SleepConditionVariableCS(&amp;_cond, &amp;_mutex,
5333                                         millis == 0 ? INFINITE : millis);
5334   if (status != 0) {
5335     ret = OS_OK;
5336   }
5337   #ifndef PRODUCT
5338   else {
5339     DWORD err = GetLastError();
5340     assert(err == ERROR_TIMEOUT, &quot;SleepConditionVariableCS: %ld:&quot;, err);
5341   }
5342   #endif
5343   return ret;
5344 }
5345 
5346 // Run the specified command in a separate process. Return its exit value,
5347 // or -1 on failure (e.g. can&#39;t create a new process).
5348 int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {
5349   STARTUPINFO si;
5350   PROCESS_INFORMATION pi;
5351   DWORD exit_code;
5352 
5353   char * cmd_string;
5354   const char * cmd_prefix = &quot;cmd /C &quot;;
5355   size_t len = strlen(cmd) + strlen(cmd_prefix) + 1;
5356   cmd_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtInternal);
5357   if (cmd_string == NULL) {
5358     return -1;
5359   }
5360   cmd_string[0] = &#39;\0&#39;;
5361   strcat(cmd_string, cmd_prefix);
5362   strcat(cmd_string, cmd);
5363 
5364   // now replace all &#39;\n&#39; with &#39;&amp;&#39;
5365   char * substring = cmd_string;
5366   while ((substring = strchr(substring, &#39;\n&#39;)) != NULL) {
5367     substring[0] = &#39;&amp;&#39;;
5368     substring++;
5369   }
5370   memset(&amp;si, 0, sizeof(si));
5371   si.cb = sizeof(si);
5372   memset(&amp;pi, 0, sizeof(pi));
5373   BOOL rslt = CreateProcess(NULL,   // executable name - use command line
5374                             cmd_string,    // command line
5375                             NULL,   // process security attribute
5376                             NULL,   // thread security attribute
5377                             TRUE,   // inherits system handles
5378                             0,      // no creation flags
5379                             NULL,   // use parent&#39;s environment block
5380                             NULL,   // use parent&#39;s starting directory
5381                             &amp;si,    // (in) startup information
5382                             &amp;pi);   // (out) process information
5383 
5384   if (rslt) {
5385     // Wait until child process exits.
5386     WaitForSingleObject(pi.hProcess, INFINITE);
5387 
5388     GetExitCodeProcess(pi.hProcess, &amp;exit_code);
5389 
5390     // Close process and thread handles.
5391     CloseHandle(pi.hProcess);
5392     CloseHandle(pi.hThread);
5393   } else {
5394     exit_code = -1;
5395   }
5396 
5397   FREE_C_HEAP_ARRAY(char, cmd_string);
5398   return (int)exit_code;
5399 }
5400 
5401 bool os::find(address addr, outputStream* st) {
5402   int offset = -1;
5403   bool result = false;
5404   char buf[256];
5405   if (os::dll_address_to_library_name(addr, buf, sizeof(buf), &amp;offset)) {
5406     st-&gt;print(PTR_FORMAT &quot; &quot;, addr);
5407     if (strlen(buf) &lt; sizeof(buf) - 1) {
5408       char* p = strrchr(buf, &#39;\\&#39;);
5409       if (p) {
5410         st-&gt;print(&quot;%s&quot;, p + 1);
5411       } else {
5412         st-&gt;print(&quot;%s&quot;, buf);
5413       }
5414     } else {
5415         // The library name is probably truncated. Let&#39;s omit the library name.
5416         // See also JDK-8147512.
5417     }
5418     if (os::dll_address_to_function_name(addr, buf, sizeof(buf), &amp;offset)) {
5419       st-&gt;print(&quot;::%s + 0x%x&quot;, buf, offset);
5420     }
5421     st-&gt;cr();
5422     result = true;
5423   }
5424   return result;
5425 }
5426 
5427 static jint initSock() {
5428   WSADATA wsadata;
5429 
5430   if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
5431     jio_fprintf(stderr, &quot;Could not initialize Winsock (error: %d)\n&quot;,
5432                 ::GetLastError());
5433     return JNI_ERR;
5434   }
5435   return JNI_OK;
5436 }
5437 
5438 struct hostent* os::get_host_by_name(char* name) {
5439   return (struct hostent*)gethostbyname(name);
5440 }
5441 
5442 int os::socket_close(int fd) {
5443   return ::closesocket(fd);
5444 }
5445 
5446 int os::socket(int domain, int type, int protocol) {
5447   return ::socket(domain, type, protocol);
5448 }
5449 
5450 int os::connect(int fd, struct sockaddr* him, socklen_t len) {
5451   return ::connect(fd, him, len);
5452 }
5453 
5454 int os::recv(int fd, char* buf, size_t nBytes, uint flags) {
5455   return ::recv(fd, buf, (int)nBytes, flags);
5456 }
5457 
5458 int os::send(int fd, char* buf, size_t nBytes, uint flags) {
5459   return ::send(fd, buf, (int)nBytes, flags);
5460 }
5461 
5462 int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {
5463   return ::send(fd, buf, (int)nBytes, flags);
5464 }
5465 
5466 // WINDOWS CONTEXT Flags for THREAD_SAMPLING
5467 #if defined(IA32)
5468   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)
5469 #elif defined (AMD64)
5470   #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
5471 #endif
5472 
5473 // returns true if thread could be suspended,
5474 // false otherwise
5475 static bool do_suspend(HANDLE* h) {
5476   if (h != NULL) {
5477     if (SuspendThread(*h) != ~0) {
5478       return true;
5479     }
5480   }
5481   return false;
5482 }
5483 
5484 // resume the thread
5485 // calling resume on an active thread is a no-op
5486 static void do_resume(HANDLE* h) {
5487   if (h != NULL) {
5488     ResumeThread(*h);
5489   }
5490 }
5491 
5492 // retrieve a suspend/resume context capable handle
5493 // from the tid. Caller validates handle return value.
5494 void get_thread_handle_for_extended_context(HANDLE* h,
5495                                             OSThread::thread_id_t tid) {
5496   if (h != NULL) {
5497     *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
5498   }
5499 }
5500 
5501 // Thread sampling implementation
5502 //
5503 void os::SuspendedThreadTask::internal_do_task() {
5504   CONTEXT    ctxt;
5505   HANDLE     h = NULL;
5506 
5507   // get context capable handle for thread
5508   get_thread_handle_for_extended_context(&amp;h, _thread-&gt;osthread()-&gt;thread_id());
5509 
5510   // sanity
5511   if (h == NULL || h == INVALID_HANDLE_VALUE) {
5512     return;
5513   }
5514 
5515   // suspend the thread
5516   if (do_suspend(&amp;h)) {
5517     ctxt.ContextFlags = sampling_context_flags;
5518     // get thread context
5519     GetThreadContext(h, &amp;ctxt);
5520     SuspendedThreadTaskContext context(_thread, &amp;ctxt);
5521     // pass context to Thread Sampling impl
5522     do_task(context);
5523     // resume thread
5524     do_resume(&amp;h);
5525   }
5526 
5527   // close handle
5528   CloseHandle(h);
5529 }
5530 
5531 bool os::start_debugging(char *buf, int buflen) {
5532   int len = (int)strlen(buf);
5533   char *p = &amp;buf[len];
5534 
5535   jio_snprintf(p, buflen-len,
5536              &quot;\n\n&quot;
5537              &quot;Do you want to debug the problem?\n\n&quot;
5538              &quot;To debug, attach Visual Studio to process %d; then switch to thread 0x%x\n&quot;
5539              &quot;Select &#39;Yes&#39; to launch Visual Studio automatically (PATH must include msdev)\n&quot;
5540              &quot;Otherwise, select &#39;No&#39; to abort...&quot;,
5541              os::current_process_id(), os::current_thread_id());
5542 
5543   bool yes = os::message_box(&quot;Unexpected Error&quot;, buf);
5544 
5545   if (yes) {
5546     // os::breakpoint() calls DebugBreak(), which causes a breakpoint
5547     // exception. If VM is running inside a debugger, the debugger will
5548     // catch the exception. Otherwise, the breakpoint exception will reach
5549     // the default windows exception handler, which can spawn a debugger and
5550     // automatically attach to the dying VM.
5551     os::breakpoint();
5552     yes = false;
5553   }
5554   return yes;
5555 }
5556 
5557 void* os::get_default_process_handle() {
5558   return (void*)GetModuleHandle(NULL);
5559 }
5560 
5561 // Builds a platform dependent Agent_OnLoad_&lt;lib_name&gt; function name
5562 // which is used to find statically linked in agents.
5563 // Additionally for windows, takes into account __stdcall names.
5564 // Parameters:
5565 //            sym_name: Symbol in library we are looking for
5566 //            lib_name: Name of library to look in, NULL for shared libs.
5567 //            is_absolute_path == true if lib_name is absolute path to agent
5568 //                                     such as &quot;C:/a/b/L.dll&quot;
5569 //            == false if only the base name of the library is passed in
5570 //               such as &quot;L&quot;
5571 char* os::build_agent_function_name(const char *sym_name, const char *lib_name,
5572                                     bool is_absolute_path) {
5573   char *agent_entry_name;
5574   size_t len;
5575   size_t name_len;
5576   size_t prefix_len = strlen(JNI_LIB_PREFIX);
5577   size_t suffix_len = strlen(JNI_LIB_SUFFIX);
5578   const char *start;
5579 
5580   if (lib_name != NULL) {
5581     len = name_len = strlen(lib_name);
5582     if (is_absolute_path) {
5583       // Need to strip path, prefix and suffix
5584       if ((start = strrchr(lib_name, *os::file_separator())) != NULL) {
5585         lib_name = ++start;
5586       } else {
5587         // Need to check for drive prefix
5588         if ((start = strchr(lib_name, &#39;:&#39;)) != NULL) {
5589           lib_name = ++start;
5590         }
5591       }
5592       if (len &lt;= (prefix_len + suffix_len)) {
5593         return NULL;
5594       }
5595       lib_name += prefix_len;
5596       name_len = strlen(lib_name) - suffix_len;
5597     }
5598   }
5599   len = (lib_name != NULL ? name_len : 0) + strlen(sym_name) + 2;
5600   agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);
5601   if (agent_entry_name == NULL) {
5602     return NULL;
5603   }
5604   if (lib_name != NULL) {
5605     const char *p = strrchr(sym_name, &#39;@&#39;);
5606     if (p != NULL &amp;&amp; p != sym_name) {
5607       // sym_name == _Agent_OnLoad@XX
5608       strncpy(agent_entry_name, sym_name, (p - sym_name));
5609       agent_entry_name[(p-sym_name)] = &#39;\0&#39;;
5610       // agent_entry_name == _Agent_OnLoad
5611       strcat(agent_entry_name, &quot;_&quot;);
5612       strncat(agent_entry_name, lib_name, name_len);
5613       strcat(agent_entry_name, p);
5614       // agent_entry_name == _Agent_OnLoad_lib_name@XX
5615     } else {
5616       strcpy(agent_entry_name, sym_name);
5617       strcat(agent_entry_name, &quot;_&quot;);
5618       strncat(agent_entry_name, lib_name, name_len);
5619     }
5620   } else {
5621     strcpy(agent_entry_name, sym_name);
5622   }
5623   return agent_entry_name;
5624 }
5625 
5626 #ifndef PRODUCT
5627 
5628 // test the code path in reserve_memory_special() that tries to allocate memory in a single
5629 // contiguous memory block at a particular address.
5630 // The test first tries to find a good approximate address to allocate at by using the same
5631 // method to allocate some memory at any address. The test then tries to allocate memory in
5632 // the vicinity (not directly after it to avoid possible by-chance use of that location)
5633 // This is of course only some dodgy assumption, there is no guarantee that the vicinity of
5634 // the previously allocated memory is available for allocation. The only actual failure
5635 // that is reported is when the test tries to allocate at a particular location but gets a
5636 // different valid one. A NULL return value at this point is not considered an error but may
5637 // be legitimate.
5638 void TestReserveMemorySpecial_test() {
5639   if (!UseLargePages) {
5640     return;
5641   }
5642   // save current value of globals
5643   bool old_use_large_pages_individual_allocation = UseLargePagesIndividualAllocation;
5644   bool old_use_numa_interleaving = UseNUMAInterleaving;
5645 
5646   // set globals to make sure we hit the correct code path
5647   UseLargePagesIndividualAllocation = UseNUMAInterleaving = false;
5648 
5649   // do an allocation at an address selected by the OS to get a good one.
5650   const size_t large_allocation_size = os::large_page_size() * 4;
5651   char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), NULL, false);
5652   if (result == NULL) {
5653   } else {
5654     os::release_memory_special(result, large_allocation_size);
5655 
5656     // allocate another page within the recently allocated memory area which seems to be a good location. At least
5657     // we managed to get it once.
5658     const size_t expected_allocation_size = os::large_page_size();
5659     char* expected_location = result + os::large_page_size();
5660     char* actual_location = os::reserve_memory_special(expected_allocation_size, os::large_page_size(), expected_location, false);
5661     if (actual_location == NULL) {
5662     } else {
5663       // release memory
5664       os::release_memory_special(actual_location, expected_allocation_size);
5665       // only now check, after releasing any memory to avoid any leaks.
5666       assert(actual_location == expected_location,
5667              &quot;Failed to allocate memory at requested location &quot; PTR_FORMAT &quot; of size &quot; SIZE_FORMAT &quot;, is &quot; PTR_FORMAT &quot; instead&quot;,
5668              expected_location, expected_allocation_size, actual_location);
5669     }
5670   }
5671 
5672   // restore globals
5673   UseLargePagesIndividualAllocation = old_use_large_pages_individual_allocation;
5674   UseNUMAInterleaving = old_use_numa_interleaving;
5675 }
5676 #endif // PRODUCT
5677 
5678 /*
5679   All the defined signal names for Windows.
5680 
5681   NOTE that not all of these names are accepted by FindSignal!
5682 
5683   For various reasons some of these may be rejected at runtime.
5684 
5685   Here are the names currently accepted by a user of sun.misc.Signal with
5686   1.4.1 (ignoring potential interaction with use of chaining, etc):
5687 
5688      (LIST TBD)
5689 
5690 */
5691 int os::get_signal_number(const char* name) {
5692   static const struct {
5693     const char* name;
5694     int         number;
5695   } siglabels [] =
5696     // derived from version 6.0 VC98/include/signal.h
5697   {&quot;ABRT&quot;,      SIGABRT,        // abnormal termination triggered by abort cl
5698   &quot;FPE&quot;,        SIGFPE,         // floating point exception
5699   &quot;SEGV&quot;,       SIGSEGV,        // segment violation
5700   &quot;INT&quot;,        SIGINT,         // interrupt
5701   &quot;TERM&quot;,       SIGTERM,        // software term signal from kill
5702   &quot;BREAK&quot;,      SIGBREAK,       // Ctrl-Break sequence
5703   &quot;ILL&quot;,        SIGILL};        // illegal instruction
5704   for (unsigned i = 0; i &lt; ARRAY_SIZE(siglabels); ++i) {
5705     if (strcmp(name, siglabels[i].name) == 0) {
5706       return siglabels[i].number;
5707     }
5708   }
5709   return -1;
5710 }
5711 
5712 // Fast current thread access
5713 
5714 int os::win32::_thread_ptr_offset = 0;
5715 
5716 static void call_wrapper_dummy() {}
5717 
5718 // We need to call the os_exception_wrapper once so that it sets
5719 // up the offset from FS of the thread pointer.
5720 void os::win32::initialize_thread_ptr_offset() {
5721   os::os_exception_wrapper((java_call_t)call_wrapper_dummy,
5722                            NULL, methodHandle(), NULL, NULL);
5723 }
5724 
5725 bool os::supports_map_sync() {
5726   return false;
5727 }
    </pre>
  </body>
</html>