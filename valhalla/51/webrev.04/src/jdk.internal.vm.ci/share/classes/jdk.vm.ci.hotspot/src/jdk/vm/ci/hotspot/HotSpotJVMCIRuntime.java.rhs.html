<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.HashMap;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.ServiceLoader;
  45 import java.util.function.Predicate;
  46 
  47 import jdk.vm.ci.code.Architecture;
  48 import jdk.vm.ci.code.CompilationRequestResult;
  49 import jdk.vm.ci.code.CompiledCode;
  50 import jdk.vm.ci.code.InstalledCode;
  51 import jdk.vm.ci.common.InitTimer;
  52 import jdk.vm.ci.common.JVMCIError;
  53 import jdk.vm.ci.common.NativeImageReinitialize;
  54 import jdk.vm.ci.meta.JavaKind;
  55 import jdk.vm.ci.meta.JavaType;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.UnresolvedJavaType;
  58 import jdk.vm.ci.runtime.JVMCI;
  59 import jdk.vm.ci.runtime.JVMCIBackend;
  60 import jdk.vm.ci.runtime.JVMCICompiler;
  61 import jdk.vm.ci.runtime.JVMCICompilerFactory;
  62 import jdk.vm.ci.runtime.JVMCIRuntime;
  63 import jdk.vm.ci.services.JVMCIServiceLocator;
  64 import jdk.vm.ci.services.Services;
  65 
  66 /**
  67  * HotSpot implementation of a JVMCI runtime.
  68  */
  69 public final class HotSpotJVMCIRuntime implements JVMCIRuntime {
  70 
  71     /**
  72      * Singleton instance lazily initialized via double-checked locking.
  73      */
  74     @NativeImageReinitialize private static volatile HotSpotJVMCIRuntime instance;
  75 
  76     private HotSpotResolvedObjectTypeImpl javaLangObject;
  77     private HotSpotResolvedObjectTypeImpl javaLangInvokeMethodHandle;
  78     private HotSpotResolvedObjectTypeImpl constantCallSiteType;
  79     private HotSpotResolvedObjectTypeImpl callSiteType;
  80     private HotSpotResolvedObjectTypeImpl javaLangString;
  81     private HotSpotResolvedObjectTypeImpl javaLangClass;
  82     private HotSpotResolvedObjectTypeImpl throwableType;
  83     private HotSpotResolvedObjectTypeImpl serializableType;
  84     private HotSpotResolvedObjectTypeImpl cloneableType;
  85     private HotSpotResolvedObjectTypeImpl enumType;
<a name="1" id="anc1"></a><span class="line-added">  86     private HotSpotResolvedObjectTypeImpl identityObjectType;</span>
  87 
  88     HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  89         if (javaLangObject == null) {
  90             javaLangObject = (HotSpotResolvedObjectTypeImpl) fromClass(Object.class);
  91         }
  92         return javaLangObject;
  93     }
  94 
  95     HotSpotResolvedObjectTypeImpl getJavaLangString() {
  96         if (javaLangString == null) {
  97             javaLangString = (HotSpotResolvedObjectTypeImpl) fromClass(String.class);
  98         }
  99         return javaLangString;
 100     }
 101 
 102     HotSpotResolvedObjectTypeImpl getJavaLangClass() {
 103         if (javaLangClass == null) {
 104             javaLangClass = (HotSpotResolvedObjectTypeImpl) fromClass(Class.class);
 105         }
 106         return javaLangClass;
 107     }
 108 
 109     HotSpotResolvedObjectTypeImpl getJavaLangCloneable() {
 110         if (cloneableType == null) {
 111             cloneableType = (HotSpotResolvedObjectTypeImpl) fromClass(Cloneable.class);
 112         }
 113         return cloneableType;
 114     }
 115 
 116     HotSpotResolvedObjectTypeImpl getJavaLangSerializable() {
 117         if (serializableType == null) {
 118             serializableType = (HotSpotResolvedObjectTypeImpl) fromClass(Serializable.class);
 119         }
 120         return serializableType;
 121     }
 122 
<a name="2" id="anc2"></a><span class="line-added"> 123     HotSpotResolvedObjectTypeImpl getJavaLangIdentityObject() {</span>
<span class="line-added"> 124         if (identityObjectType == null) {</span>
<span class="line-added"> 125             identityObjectType = (HotSpotResolvedObjectTypeImpl) fromClass(IdentityObject.class);</span>
<span class="line-added"> 126         }</span>
<span class="line-added"> 127         return identityObjectType;</span>
<span class="line-added"> 128     }</span>
<span class="line-added"> 129 </span>
 130     HotSpotResolvedObjectTypeImpl getJavaLangThrowable() {
 131         if (throwableType == null) {
 132             throwableType = (HotSpotResolvedObjectTypeImpl) fromClass(Throwable.class);
 133         }
 134         return throwableType;
 135     }
 136 
 137     HotSpotResolvedObjectTypeImpl getJavaLangEnum() {
 138         if (enumType == null) {
 139             enumType = (HotSpotResolvedObjectTypeImpl) fromClass(Enum.class);
 140         }
 141         return enumType;
 142     }
 143 
 144     HotSpotResolvedObjectTypeImpl getConstantCallSite() {
 145         if (constantCallSiteType == null) {
 146             constantCallSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(ConstantCallSite.class);
 147         }
 148         return constantCallSiteType;
 149     }
 150 
 151     HotSpotResolvedObjectTypeImpl getCallSite() {
 152         if (callSiteType == null) {
 153             callSiteType = (HotSpotResolvedObjectTypeImpl) fromClass(CallSite.class);
 154         }
 155         return callSiteType;
 156     }
 157 
 158     HotSpotResolvedObjectType getMethodHandleClass() {
 159         if (javaLangInvokeMethodHandle == null) {
 160             javaLangInvokeMethodHandle = (HotSpotResolvedObjectTypeImpl) fromClass(MethodHandle.class);
 161         }
 162         return javaLangInvokeMethodHandle;
 163     }
 164 
 165     /**
 166      * Gets the singleton {@link HotSpotJVMCIRuntime} object.
 167      */
 168     @VMEntryPoint
 169     @SuppressWarnings(&quot;try&quot;)
 170     public static HotSpotJVMCIRuntime runtime() {
 171         HotSpotJVMCIRuntime result = instance;
 172         if (result == null) {
 173             // Synchronize on JVMCI.class to avoid deadlock
 174             // between the two JVMCI initialization paths:
 175             // HotSpotJVMCIRuntime.runtime() and JVMCI.getRuntime().
 176             synchronized (JVMCI.class) {
 177                 result = instance;
 178                 if (result == null) {
 179                     try (InitTimer t = timer(&quot;HotSpotJVMCIRuntime.&lt;init&gt;&quot;)) {
 180                         instance = result = new HotSpotJVMCIRuntime();
 181 
 182                         // Can only do eager initialization of the JVMCI compiler
 183                         // once the singleton instance is available.
 184                         if (result.config.getFlag(&quot;EagerJVMCI&quot;, Boolean.class)) {
 185                             result.getCompiler();
 186                         }
 187                     }
 188                     // Ensures JVMCIRuntime::_HotSpotJVMCIRuntime_instance is
 189                     // initialized.
 190                     JVMCI.getRuntime();
 191                 }
 192                 // Make sure all the primitive box caches are populated (required to properly
 193                 // materialize boxed primitives
 194                 // during deoptimization).
 195                 Boolean.valueOf(false);
 196                 Byte.valueOf((byte) 0);
 197                 Short.valueOf((short) 0);
 198                 Character.valueOf((char) 0);
 199                 Integer.valueOf(0);
 200                 Long.valueOf(0);
 201             }
 202         }
 203         return result;
 204     }
 205 
 206     @VMEntryPoint
 207     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 208         return TranslatedException.decodeThrowable(encodedThrowable);
 209     }
 210 
 211     @VMEntryPoint
 212     static String encodeThrowable(Throwable throwable) throws Throwable {
 213         return TranslatedException.encodeThrowable(throwable);
 214     }
 215 
 216     @VMEntryPoint
 217     static String callToString(Object o) {
 218         return o.toString();
 219     }
 220 
 221     /**
 222      * A list of all supported JVMCI options.
 223      */
 224     public enum Option {
 225         // @formatter:off
 226         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 227                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 228                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 229                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 230         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 231         // so that -XX:+JVMCIPrintProperties shows the option.
 232         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 233         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 234         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 235                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 236         TraceMethodDataFilter(String.class, null,
 237                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 238                 &quot;Empty value: trace all methods&quot;,
 239                 &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),
 240         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 241         // @formatter:on
 242 
 243         /**
 244          * The prefix for system properties that are JVMCI options.
 245          */
 246         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 247 
 248         /**
 249          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 250          */
 251         private static final String NULL_VALUE = &quot;NULL&quot;;
 252 
 253         private final Class&lt;?&gt; type;
 254         @NativeImageReinitialize private Object value;
 255         private final Object defaultValue;
 256         private boolean isDefault;
 257         private final String[] helpLines;
 258 
 259         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 260             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 261             this.type = type;
 262             this.defaultValue = defaultValue;
 263             this.helpLines = helpLines;
 264         }
 265 
 266         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
 267         private Object getValue() {
 268             if (value == null) {
 269                 String propertyValue = Services.getSavedProperty(getPropertyName());
 270                 if (propertyValue == null) {
 271                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;
 272                     this.isDefault = true;
 273                 } else {
 274                     if (type == Boolean.class) {
 275                         this.value = Boolean.parseBoolean(propertyValue);
 276                     } else if (type == String.class) {
 277                         this.value = propertyValue;
 278                     } else {
 279                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);
 280                     }
 281                     this.isDefault = false;
 282                 }
 283             }
 284             return value == NULL_VALUE ? null : value;
 285         }
 286 
 287         /**
 288          * Gets the name of system property from which this option gets its value.
 289          */
 290         public String getPropertyName() {
 291             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 292         }
 293 
 294         /**
 295          * Returns the option&#39;s value as boolean.
 296          *
 297          * @return option&#39;s value
 298          */
 299         public boolean getBoolean() {
 300             return (boolean) getValue();
 301         }
 302 
 303         /**
 304          * Returns the option&#39;s value as String.
 305          *
 306          * @return option&#39;s value
 307          */
 308         public String getString() {
 309             return (String) getValue();
 310         }
 311 
 312         private static final int PROPERTY_LINE_WIDTH = 80;
 313         private static final int PROPERTY_HELP_INDENT = 10;
 314 
 315         /**
 316          * Prints a description of the properties used to configure shared JVMCI code.
 317          *
 318          * @param out stream to print to
 319          */
 320         public static void printProperties(PrintStream out) {
 321             out.println(&quot;[JVMCI properties]&quot;);
 322             Option[] values = values();
 323             for (Option option : values) {
 324                 Object value = option.getValue();
 325                 if (value instanceof String) {
 326                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 327                 }
 328 
 329                 String name = option.getPropertyName();
 330                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 331                 String typeName = option.type.getSimpleName();
 332                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 333                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 334                 int linePad = typeStartPos - linePrefix.length();
 335                 if (linePad &gt; 0) {
 336                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 337                 } else {
 338                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 339                 }
 340                 for (String line : option.helpLines) {
 341                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 342                 }
 343             }
 344         }
 345     }
 346 
 347     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 348         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 349         assert factories != null : &quot;sanity&quot;;
 350         for (HotSpotJVMCIBackendFactory factory : factories) {
 351             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 352                 return factory;
 353             }
 354         }
 355 
 356         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 357     }
 358 
 359     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 360 
 361     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 362     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 363         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 364             return cachedHotSpotJVMCIBackendFactories;
 365         }
 366         Iterable&lt;HotSpotJVMCIBackendFactory&gt; result = ServiceLoader.load(HotSpotJVMCIBackendFactory.class, ClassLoader.getSystemClassLoader());
 367         if (IS_BUILDING_NATIVE_IMAGE) {
 368             cachedHotSpotJVMCIBackendFactories = new ArrayList&lt;&gt;();
 369             for (HotSpotJVMCIBackendFactory factory : result) {
 370                 cachedHotSpotJVMCIBackendFactories.add(factory);
 371             }
 372         }
 373         return result;
 374     }
 375 
 376     /**
 377      * Gets the kind of a word value on the {@linkplain #getHostJVMCIBackend() host} backend.
 378      */
 379     public static JavaKind getHostWordKind() {
 380         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
 381     }
 382 
 383     protected final CompilerToVM compilerToVm;
 384 
 385     protected final HotSpotVMConfigStore configStore;
 386     protected final HotSpotVMConfig config;
 387     private final JVMCIBackend hostBackend;
 388 
 389     private final JVMCICompilerFactory compilerFactory;
 390     private final HotSpotJVMCICompilerFactory hsCompilerFactory;
 391     private volatile JVMCICompiler compiler;
 392     protected final HotSpotJVMCIReflection reflection;
 393 
 394     @NativeImageReinitialize private volatile boolean creatingCompiler;
 395 
 396     /**
 397      * Cache for speeding up {@link #fromClass(Class)}.
 398      */
 399     @NativeImageReinitialize private volatile ClassValue&lt;WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt;&gt; resolvedJavaType;
 400 
 401     /**
 402      * To avoid calling ClassValue.remove to refresh the weak reference, which under certain
 403      * circumstances can lead to an infinite loop, we use a permanent holder with a mutable field
 404      * that we refresh.
 405      */
 406     private static class WeakReferenceHolder&lt;T&gt; {
 407         private volatile WeakReference&lt;T&gt; ref;
 408 
 409         WeakReferenceHolder(T value) {
 410             set(value);
 411         }
 412 
 413         void set(T value) {
 414             ref = new WeakReference&lt;&gt;(value);
 415         }
 416 
 417         T get() {
 418             return ref.get();
 419         }
 420     }
 421 
 422     @NativeImageReinitialize private HashMap&lt;Long, WeakReference&lt;ResolvedJavaType&gt;&gt; resolvedJavaTypes;
 423 
 424     /**
 425      * Stores the value set by {@link #excludeFromJVMCICompilation(Module...)} so that it can be
 426      * read from the VM.
 427      */
 428     @SuppressWarnings(&quot;unused&quot;)//
 429     @NativeImageReinitialize private Module[] excludeFromJVMCICompilation;
 430 
 431     private final Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; backends = new HashMap&lt;&gt;();
 432 
 433     private volatile List&lt;HotSpotVMEventListener&gt; vmEventListeners;
 434 
 435     private Iterable&lt;HotSpotVMEventListener&gt; getVmEventListeners() {
 436         if (vmEventListeners == null) {
 437             synchronized (this) {
 438                 if (vmEventListeners == null) {
 439                     vmEventListeners = JVMCIServiceLocator.getProviders(HotSpotVMEventListener.class);
 440                 }
 441             }
 442         }
 443         return vmEventListeners;
 444     }
 445 
 446     @SuppressWarnings(&quot;try&quot;)
 447     private HotSpotJVMCIRuntime() {
 448         compilerToVm = new CompilerToVM();
 449 
 450         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 451             configStore = new HotSpotVMConfigStore(compilerToVm);
 452             config = new HotSpotVMConfig(configStore);
 453         }
 454 
 455         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 456 
 457         PrintStream vmLogStream = null;
 458         if (IS_IN_NATIVE_IMAGE) {
 459             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 460             vmLogStream = new PrintStream(getLogStream());
 461             System.setOut(vmLogStream);
 462             System.setErr(vmLogStream);
 463         }
 464 
 465         String hostArchitecture = config.getHostArchitectureName();
 466 
 467         HotSpotJVMCIBackendFactory factory;
 468         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 469             factory = findFactory(hostArchitecture);
 470         }
 471 
 472         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 473             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 474         }
 475 
 476         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 477         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 478             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 479             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 480                 String name = HotSpotJVMCICompilerFactory.class.getName();
 481                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 482                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 483                 throw new UnsupportedOperationException(msg);
 484             }
 485         } else {
 486             hsCompilerFactory = null;
 487         }
 488 
 489         if (config.getFlag(&quot;JVMCIPrintProperties&quot;, Boolean.class)) {
 490             if (vmLogStream == null) {
 491                 vmLogStream = new PrintStream(getLogStream());
 492             }
 493             Option.printProperties(vmLogStream);
 494             compilerFactory.printProperties(vmLogStream);
 495             System.exit(0);
 496         }
 497 
 498         if (Option.PrintConfig.getBoolean()) {
 499             configStore.printConfig();
 500         }
 501     }
 502 
 503     HotSpotResolvedJavaType createClass(Class&lt;?&gt; javaClass) {
 504         if (javaClass.isPrimitive()) {
 505             return HotSpotResolvedPrimitiveType.forKind(JavaKind.fromJavaClass(javaClass));
 506         }
 507         if (IS_IN_NATIVE_IMAGE) {
 508             try {
 509                 return compilerToVm.lookupType(javaClass.getName().replace(&#39;.&#39;, &#39;/&#39;), null, true);
 510             } catch (ClassNotFoundException e) {
 511                 throw new JVMCIError(e);
 512             }
 513         }
 514         return compilerToVm.lookupClass(javaClass);
 515     }
 516 
 517     private HotSpotResolvedJavaType fromClass0(Class&lt;?&gt; javaClass) {
 518         if (resolvedJavaType == null) {
 519             synchronized (this) {
 520                 if (resolvedJavaType == null) {
 521                     resolvedJavaType = new ClassValue&lt;&gt;() {
 522                         @Override
 523                         protected WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; computeValue(Class&lt;?&gt; type) {
 524                             return new WeakReferenceHolder&lt;&gt;(createClass(type));
 525                         }
 526                     };
 527                 }
 528             }
 529         }
 530 
 531         WeakReferenceHolder&lt;HotSpotResolvedJavaType&gt; ref = resolvedJavaType.get(javaClass);
 532         HotSpotResolvedJavaType javaType = ref.get();
 533         if (javaType == null) {
 534             /*
 535              * If the referent has become null, create a new value and update cached weak reference.
 536              */
 537             javaType = createClass(javaClass);
 538             ref.set(javaType);
 539         }
 540         return javaType;
 541     }
 542 
 543     /**
 544      * Gets the JVMCI mirror for a {@link Class} object.
 545      *
 546      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
 547      */
 548     HotSpotResolvedJavaType fromClass(Class&lt;?&gt; javaClass) {
 549         if (javaClass == null) {
 550             return null;
 551         }
 552         return fromClass0(javaClass);
 553     }
 554 
 555     synchronized HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 556         if (resolvedJavaTypes == null) {
 557             resolvedJavaTypes = new HashMap&lt;&gt;();
 558         }
 559         assert klassPointer != 0;
 560         WeakReference&lt;ResolvedJavaType&gt; klassReference = resolvedJavaTypes.get(klassPointer);
 561         HotSpotResolvedObjectTypeImpl javaType = null;
 562         if (klassReference != null) {
 563             javaType = (HotSpotResolvedObjectTypeImpl) klassReference.get();
 564         }
 565         if (javaType == null) {
 566             javaType = new HotSpotResolvedObjectTypeImpl(klassPointer, signature);
 567             resolvedJavaTypes.put(klassPointer, new WeakReference&lt;&gt;(javaType));
 568         }
 569         return javaType;
 570     }
 571 
 572     private JVMCIBackend registerBackend(JVMCIBackend backend) {
 573         Class&lt;? extends Architecture&gt; arch = backend.getCodeCache().getTarget().arch.getClass();
 574         JVMCIBackend oldValue = backends.put(arch, backend);
 575         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
 576         return backend;
 577     }
 578 
 579     public HotSpotVMConfigStore getConfigStore() {
 580         return configStore;
 581     }
 582 
 583     public HotSpotVMConfig getConfig() {
 584         return config;
 585     }
 586 
 587     public CompilerToVM getCompilerToVM() {
 588         return compilerToVm;
 589     }
 590 
 591     HotSpotJVMCIReflection getReflection() {
 592         return reflection;
 593     }
 594 
 595     /**
 596      * Gets a predicate that determines if a given type can be considered trusted for the purpose of
 597      * intrinsifying methods it declares.
 598      *
 599      * @param compilerLeafClasses classes in the leaves of the module graph comprising the JVMCI
 600      *            compiler.
 601      */
 602     public Predicate&lt;ResolvedJavaType&gt; getIntrinsificationTrustPredicate(Class&lt;?&gt;... compilerLeafClasses) {
 603         return new Predicate&lt;&gt;() {
 604             @Override
 605             public boolean test(ResolvedJavaType type) {
 606                 if (type instanceof HotSpotResolvedObjectTypeImpl) {
 607                     HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) type;
 608                     return compilerToVm.isTrustedForIntrinsics(hsType);
 609                 } else {
 610                     return false;
 611                 }
 612             }
 613         };
 614     }
 615 
 616     /**
 617      * Get the {@link Class} corresponding to {@code type}.
 618      *
 619      * @param type the type for which a {@link Class} is requested
 620      * @return the original Java class corresponding to {@code type} or {@code null} if this runtime
 621      *         does not support mapping {@link ResolvedJavaType} instances to {@link Class}
 622      *         instances
 623      */
 624     public Class&lt;?&gt; getMirror(ResolvedJavaType type) {
 625         if (type instanceof HotSpotResolvedJavaType &amp;&amp; reflection instanceof HotSpotJDKReflection) {
 626             return ((HotSpotJDKReflection) reflection).getMirror((HotSpotResolvedJavaType) type);
 627         }
 628         return null;
 629     }
 630 
 631     @Override
 632     public JVMCICompiler getCompiler() {
 633         if (compiler == null) {
 634             synchronized (this) {
 635                 if (compiler == null) {
 636                     assert !creatingCompiler : &quot;recursive compiler creation&quot;;
 637                     creatingCompiler = true;
 638                     compiler = compilerFactory.createCompiler(this);
 639                     creatingCompiler = false;
 640                 }
 641             }
 642         }
 643         return compiler;
 644     }
 645 
 646     /**
 647      * Converts a name to a Java type. This method attempts to resolve {@code name} to a
 648      * {@link ResolvedJavaType}.
 649      *
 650      * @param name a well formed Java type in {@linkplain JavaType#getName() internal} format
 651      * @param accessingType the context of resolution which must be non-null
 652      * @param resolve specifies whether resolution failure results in an unresolved type being
 653      *            return or a {@link LinkageError} being thrown
 654      * @return a Java type for {@code name} which is guaranteed to be of type
 655      *         {@link ResolvedJavaType} if {@code resolve == true}
 656      * @throws LinkageError if {@code resolve == true} and the resolution failed
 657      * @throws NullPointerException if {@code accessingClass} is {@code null}
 658      */
 659     public JavaType lookupType(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 660         Objects.requireNonNull(accessingType, &quot;cannot resolve type without an accessing class&quot;);
 661         return lookupTypeInternal(name, accessingType, resolve);
 662     }
 663 
 664     JavaType lookupTypeInternal(String name, HotSpotResolvedObjectType accessingType, boolean resolve) {
 665         // If the name represents a primitive type we can short-circuit the lookup.
 666         if (name.length() == 1) {
 667             JavaKind kind = JavaKind.fromPrimitiveOrVoidTypeChar(name.charAt(0));
 668             return HotSpotResolvedPrimitiveType.forKind(kind);
 669         }
 670 
 671         // Resolve non-primitive types in the VM.
 672         HotSpotResolvedObjectTypeImpl hsAccessingType = (HotSpotResolvedObjectTypeImpl) accessingType;
 673         try {
 674             final HotSpotResolvedJavaType klass = compilerToVm.lookupType(name, hsAccessingType, resolve);
 675 
 676             if (klass == null) {
 677                 assert resolve == false : name;
 678                 return UnresolvedJavaType.create(name);
 679             }
 680             return klass;
 681         } catch (ClassNotFoundException e) {
 682             throw (NoClassDefFoundError) new NoClassDefFoundError().initCause(e);
 683         }
 684     }
 685 
 686     @Override
 687     public JVMCIBackend getHostJVMCIBackend() {
 688         return hostBackend;
 689     }
 690 
 691     @Override
 692     public &lt;T extends Architecture&gt; JVMCIBackend getJVMCIBackend(Class&lt;T&gt; arch) {
 693         assert arch != Architecture.class;
 694         return backends.get(arch);
 695     }
 696 
 697     public Map&lt;Class&lt;? extends Architecture&gt;, JVMCIBackend&gt; getJVMCIBackends() {
 698         return Collections.unmodifiableMap(backends);
 699     }
 700 
 701     @SuppressWarnings(&quot;try&quot;)
 702     @VMEntryPoint
 703     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 704         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 705         CompilationRequestResult result = getCompiler().compileMethod(request);
 706         assert result != null : &quot;compileMethod must always return something&quot;;
 707         HotSpotCompilationRequestResult hsResult;
 708         if (result instanceof HotSpotCompilationRequestResult) {
 709             hsResult = (HotSpotCompilationRequestResult) result;
 710         } else {
 711             Object failure = result.getFailure();
 712             if (failure != null) {
 713                 boolean retry = false; // Be conservative with unknown compiler
 714                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 715             } else {
 716                 int inlinedBytecodes = -1;
 717                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 718             }
 719         }
 720         return hsResult;
 721     }
 722 
 723     /**
 724      * Shuts down the runtime.
 725      */
 726     @VMEntryPoint
 727     private void shutdown() throws Exception {
 728         // Cleaners are normally only processed when a new Cleaner is
 729         // instantiated so process all remaining cleaners now.
 730         Cleaner.clean();
 731 
 732         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 733             vmEventListener.notifyShutdown();
 734         }
 735     }
 736 
 737     /**
 738      * Notify on completion of a bootstrap.
 739      */
 740     @VMEntryPoint
 741     private void bootstrapFinished() throws Exception {
 742         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 743             vmEventListener.notifyBootstrapFinished();
 744         }
 745     }
 746 
 747     /**
 748      * Notify on successful install into the CodeCache.
 749      *
 750      * @param hotSpotCodeCacheProvider
 751      * @param installedCode
 752      * @param compiledCode
 753      */
 754     void notifyInstall(HotSpotCodeCacheProvider hotSpotCodeCacheProvider, InstalledCode installedCode, CompiledCode compiledCode) {
 755         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 756             vmEventListener.notifyInstall(hotSpotCodeCacheProvider, installedCode, compiledCode);
 757         }
 758     }
 759 
 760     /**
 761      * Writes {@code length} bytes from {@code bytes} starting at offset {@code offset} to HotSpot&#39;s
 762      * log stream.
 763      *
 764      * @param flush specifies if the log stream should be flushed after writing
 765      * @param canThrow specifies if an error in the {@code bytes}, {@code offset} or {@code length}
 766      *            arguments should result in an exception or a negative return value. If
 767      *            {@code false}, this call will not perform any heap allocation
 768      * @return 0 on success, -1 if {@code bytes == null &amp;&amp; !canThrow}, -2 if {@code !canThrow} and
 769      *         copying would cause access of data outside array bounds
 770      * @throws NullPointerException if {@code bytes == null}
 771      * @throws IndexOutOfBoundsException if copying would cause access of data outside array bounds
 772      */
 773     public int writeDebugOutput(byte[] bytes, int offset, int length, boolean flush, boolean canThrow) {
 774         return compilerToVm.writeDebugOutput(bytes, offset, length, flush, canThrow);
 775     }
 776 
 777     /**
 778      * Gets an output stream that writes to HotSpot&#39;s {@code tty} stream.
 779      */
 780     public OutputStream getLogStream() {
 781         return new OutputStream() {
 782 
 783             @Override
 784             public void write(byte[] b, int off, int len) throws IOException {
 785                 if (b == null) {
 786                     throw new NullPointerException();
 787                 } else if (off &lt; 0 || off &gt; b.length || len &lt; 0 || (off + len) &gt; b.length || (off + len) &lt; 0) {
 788                     throw new IndexOutOfBoundsException();
 789                 } else if (len == 0) {
 790                     return;
 791                 }
 792                 compilerToVm.writeDebugOutput(b, off, len, false, true);
 793             }
 794 
 795             @Override
 796             public void write(int b) throws IOException {
 797                 write(new byte[]{(byte) b}, 0, 1);
 798             }
 799 
 800             @Override
 801             public void flush() throws IOException {
 802                 compilerToVm.flushDebugOutput();
 803             }
 804         };
 805     }
 806 
 807     /**
 808      * Collects the current values of all JVMCI benchmark counters, summed up over all threads.
 809      */
 810     public long[] collectCounters() {
 811         return compilerToVm.collectCounters();
 812     }
 813 
 814     /**
 815      * @return the current number of per thread counters. May be set through
 816      *         {@code -XX:JVMCICompilerSize=} command line option or the
 817      *         {@link #setCountersSize(int)} call.
 818      */
 819     public int getCountersSize() {
 820         return compilerToVm.getCountersSize();
 821     }
 822 
 823     /**
 824      * Enlarge the number of per thread counters available. Requires a safepoint so
 825      * resizing should be rare to avoid performance effects.
 826      *
 827      * @param newSize
 828      */
 829     public void setCountersSize(int newSize) {
 830         compilerToVm.setCountersSize(newSize);
 831     }
 832 
 833     /**
 834      * The offset from the origin of an array to the first element.
 835      *
 836      * @return the offset in bytes
 837      */
 838     public int getArrayBaseOffset(JavaKind kind) {
 839         switch (kind) {
 840             case Boolean:
 841                 return compilerToVm.ARRAY_BOOLEAN_BASE_OFFSET;
 842             case Byte:
 843                 return compilerToVm.ARRAY_BYTE_BASE_OFFSET;
 844             case Char:
 845                 return compilerToVm.ARRAY_CHAR_BASE_OFFSET;
 846             case Short:
 847                 return compilerToVm.ARRAY_SHORT_BASE_OFFSET;
 848             case Int:
 849                 return compilerToVm.ARRAY_INT_BASE_OFFSET;
 850             case Long:
 851                 return compilerToVm.ARRAY_LONG_BASE_OFFSET;
 852             case Float:
 853                 return compilerToVm.ARRAY_FLOAT_BASE_OFFSET;
 854             case Double:
 855                 return compilerToVm.ARRAY_DOUBLE_BASE_OFFSET;
 856             case Object:
 857                 return compilerToVm.ARRAY_OBJECT_BASE_OFFSET;
 858             default:
 859                 throw new JVMCIError(&quot;%s&quot;, kind);
 860         }
 861 
 862     }
 863 
 864     /**
 865      * The scale used for the index when accessing elements of an array of this kind.
 866      *
 867      * @return the scale in order to convert the index into a byte offset
 868      */
 869     public int getArrayIndexScale(JavaKind kind) {
 870         switch (kind) {
 871             case Boolean:
 872                 return compilerToVm.ARRAY_BOOLEAN_INDEX_SCALE;
 873             case Byte:
 874                 return compilerToVm.ARRAY_BYTE_INDEX_SCALE;
 875             case Char:
 876                 return compilerToVm.ARRAY_CHAR_INDEX_SCALE;
 877             case Short:
 878                 return compilerToVm.ARRAY_SHORT_INDEX_SCALE;
 879             case Int:
 880                 return compilerToVm.ARRAY_INT_INDEX_SCALE;
 881             case Long:
 882                 return compilerToVm.ARRAY_LONG_INDEX_SCALE;
 883             case Float:
 884                 return compilerToVm.ARRAY_FLOAT_INDEX_SCALE;
 885             case Double:
 886                 return compilerToVm.ARRAY_DOUBLE_INDEX_SCALE;
 887             case Object:
 888                 return compilerToVm.ARRAY_OBJECT_INDEX_SCALE;
 889             default:
 890                 throw new JVMCIError(&quot;%s&quot;, kind);
 891 
 892         }
 893     }
 894 
 895     /**
 896      * Links each native method in {@code clazz} to an implementation in the JVMCI shared library.
 897      * &lt;p&gt;
 898      * A use case for this is a JVMCI compiler implementation that offers an API to Java code
 899      * executing in HotSpot to exercise functionality (mostly) in the JVMCI shared library. For
 900      * example:
 901      *
 902      * &lt;pre&gt;
 903      * package com.jcompile;
 904      *
 905      * import java.lang.reflect.Method;
 906      *
 907      * public static class JCompile {
 908      *     static {
 909      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 910      *     }
 911      *     public static boolean compile(Method method, String[] options) {
 912      *         // Convert to simpler data types for passing/serializing across native interface
 913      *         long metaspaceMethodHandle = getHandle(method);
 914      *         char[] opts = convertToCharArray(options);
 915      *         return compile(metaspaceMethodHandle, opts);
 916      *     }
 917      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 918      *
 919      *     private static long getHandle(Method method) { ... }
 920      *     private static char[] convertToCharArray(String[] a) { ... }
 921      * }
 922      * &lt;/pre&gt;
 923      *
 924      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
 925      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}
 926      * implementation will be exported as the following JNI-compatible symbol:
 927      *
 928      * &lt;pre&gt;
 929      * Java_com_jcompile_JCompile_compile0
 930      * &lt;/pre&gt;
 931      *
 932      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
 933      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
 934      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
 935      *
 936      *
 937      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing
 938      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3
 939      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})
 940      * @throws NullPointerException if {@code clazz == null}
 941      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 942      *             {@code -XX:-UseJVMCINativeLibrary})
 943      * @throws IllegalStateException if the current execution context is the JVMCI shared library
 944      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
 945      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
 946      *             (no matching JNI symbol or the native method is already linked to a different
 947      *             address)
 948      */
 949     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
 950         return compilerToVm.registerNativeMethods(clazz);
 951     }
 952 
 953     /**
 954      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
 955      * objects can be translated are:
 956      * &lt;ul&gt;
 957      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
 958      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
 959      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
 960      * &lt;li&gt;{@link IndirectHotSpotObjectConstantImpl},&lt;/li&gt;
 961      * &lt;li&gt;{@link DirectHotSpotObjectConstantImpl} and&lt;/li&gt;
 962      * &lt;li&gt;{@link HotSpotNmethod}&lt;/li&gt;
 963      * &lt;/ul&gt;
 964      *
 965      * This mechanism can be used to pass and return values between the HotSpot and JVMCI shared
 966      * library runtimes. In the receiving runtime, the value can be converted back to an object with
 967      * {@link #unhand(Class, long)}.
 968      *
 969      * @param obj an object for which an equivalent instance in the peer runtime is requested
 970      * @return a JNI global reference to the mirror of {@code obj} in the peer runtime
 971      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 972      *             {@code -XX:-UseJVMCINativeLibrary})
 973      * @throws IllegalArgumentException if {@code obj} is not of a translatable type
 974      *
 975      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;
 976      */
 977     public long translate(Object obj) {
 978         return compilerToVm.translate(obj);
 979     }
 980 
 981     /**
 982      * Dereferences and returns the object referred to by the JNI global reference {@code handle}.
 983      * The global reference is deleted prior to returning. Any further use of {@code handle} is
 984      * invalid.
 985      *
 986      * @param handle a JNI global reference to an object in the current runtime
 987      * @return the object referred to by {@code handle}
 988      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 989      *             {@code -XX:-UseJVMCINativeLibrary})
 990      * @throws ClassCastException if the returned object cannot be cast to {@code type}
 991      *
 992      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#global_and_local_references&quot;
 993      *
 994      */
 995     public &lt;T&gt; T unhand(Class&lt;T&gt; type, long handle) {
 996         return type.cast(compilerToVm.unhand(handle));
 997     }
 998 
 999     /**
1000      * Determines if the current thread is attached to the peer runtime.
1001      *
1002      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1003      *             {@code -XX:-UseJVMCINativeLibrary})
1004      * @throws IllegalStateException if the peer runtime has not been initialized
1005      */
1006     public boolean isCurrentThreadAttached() {
1007         return compilerToVm.isCurrentThreadAttached();
1008     }
1009 
1010     /**
1011      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1012      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1013      */
1014     public long getCurrentJavaThread() {
1015         return compilerToVm.getCurrentJavaThread();
1016     }
1017 
1018     /**
1019      * Ensures the current thread is attached to the peer runtime.
1020      *
1021      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1022      * @return {@code true} if this call attached the current thread, {@code false} if the current
1023      *         thread was already attached
1024      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1025      *             {@code -XX:-UseJVMCINativeLibrary})
1026      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1027      *             error while trying to attach the thread
1028      */
1029     public boolean attachCurrentThread(boolean asDaemon) {
1030         return compilerToVm.attachCurrentThread(asDaemon);
1031     }
1032 
1033     /**
1034      * Detaches the current thread from the peer runtime.
1035      *
1036      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1037      *             {@code -XX:-UseJVMCINativeLibrary})
1038      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1039      *             thread is not attached or if there is an error while trying to detach the thread
1040      */
1041     public void detachCurrentThread() {
1042         compilerToVm.detachCurrentThread();
1043     }
1044 
1045     /**
1046      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1047      * with {@link #compileMethod}.
1048      *
1049      * @param modules the set of modules containing JVMCI compiler classes
1050      */
1051     public void excludeFromJVMCICompilation(Module...modules) {
1052         this.excludeFromJVMCICompilation = modules.clone();
1053     }
1054 
1055     /**
1056      * Calls {@link System#exit(int)} in HotSpot&#39;s runtime.
1057      */
1058     public void exitHotSpot(int status) {
1059         if (!IS_IN_NATIVE_IMAGE) {
1060             System.exit(status);
1061         }
1062         compilerToVm.callSystemExit(status);
1063     }
1064 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>