<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
 111     private final boolean allowYieldStatement;
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
 135         Preview preview = Preview.instance(context);
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
 166     }
 167 
 168     private static Symbol bestOf(Symbol s1,
 169                                  Symbol s2) {
 170         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 171     }
 172 
 173     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 174     enum VerboseResolutionMode {
 175         SUCCESS(&quot;success&quot;),
 176         FAILURE(&quot;failure&quot;),
 177         APPLICABLE(&quot;applicable&quot;),
 178         INAPPLICABLE(&quot;inapplicable&quot;),
 179         DEFERRED_INST(&quot;deferred-inference&quot;),
 180         PREDEF(&quot;predef&quot;),
 181         OBJECT_INIT(&quot;object-init&quot;),
 182         INTERNAL(&quot;internal&quot;);
 183 
 184         final String opt;
 185 
 186         private VerboseResolutionMode(String opt) {
 187             this.opt = opt;
 188         }
 189 
 190         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 191             String s = opts.get(&quot;debug.verboseResolution&quot;);
 192             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 193             if (s == null) return res;
 194             if (s.contains(&quot;all&quot;)) {
 195                 res = EnumSet.allOf(VerboseResolutionMode.class);
 196             }
 197             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 198             for (VerboseResolutionMode mode : values()) {
 199                 if (args.contains(mode.opt)) {
 200                     res.add(mode);
 201                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 202                     res.remove(mode);
 203                 }
 204             }
 205             return res;
 206         }
 207     }
 208 
 209     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 210             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 211         boolean success = !bestSoFar.kind.isResolutionError();
 212 
 213         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 214             return;
 215         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 216             return;
 217         }
 218 
 219         if (bestSoFar.name == names.init &amp;&amp;
 220                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 221                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 222             return; //skip diags for Object constructor resolution
 223         } else if (site == syms.predefClass.type &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 225             return; //skip spurious diags for predef symbols (i.e. operators)
 226         } else if (currentResolutionContext.internalResolution &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 228             return;
 229         }
 230 
 231         int pos = 0;
 232         int mostSpecificPos = -1;
 233         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 234         for (Candidate c : currentResolutionContext.candidates) {
 235             if (currentResolutionContext.step != c.step ||
 236                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 237                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 238                 continue;
 239             } else {
 240                 subDiags.append(c.isApplicable() ?
 241                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 242                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 243                 if (c.sym == bestSoFar)
 244                     mostSpecificPos = pos;
 245                 pos++;
 246             }
 247         }
 248         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 249         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 250         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 251                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 252                 methodArguments(argtypes2),
 253                 methodArguments(typeargtypes));
 254         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 255         log.report(d);
 256     }
 257 
 258     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 259         JCDiagnostic subDiag = null;
 260         if (sym.type.hasTag(FORALL)) {
 261             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 262         }
 263 
 264         String key = subDiag == null ?
 265                 &quot;applicable.method.found&quot; :
 266                 &quot;applicable.method.found.1&quot;;
 267 
 268         return diags.fragment(key, pos, sym, subDiag);
 269     }
 270 
 271     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 272         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 273     }
 274     // &lt;/editor-fold&gt;
 275 
 276 /* ************************************************************************
 277  * Identifier resolution
 278  *************************************************************************/
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
 299     /** Is class accessible in given environment?
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
 320         boolean isAccessible = false;
 321         switch ((short)(c.flags() &amp; AccessFlags)) {
 322             case PRIVATE:
 323                 isAccessible =
 324                     env.enclClass.sym.outermostClass() ==
 325                     c.owner.outermostClass();
 326                 break;
 327             case 0:
 328                 isAccessible =
 329                     env.toplevel.packge == c.owner // fast special case
 330                     ||
 331                     env.toplevel.packge == c.packge();
 332                 break;
 333             default: // error recovery
 334                 isAccessible = true;
 335                 break;
 336             case PUBLIC:
 337                 if (allowModules) {
 338                     ModuleSymbol currModule = env.toplevel.modle;
 339                     currModule.complete();
 340                     PackageSymbol p = c.packge();
 341                     isAccessible =
 342                         currModule == p.modle ||
 343                         currModule.visiblePackages.get(p.fullname) == p ||
 344                         p == syms.rootPackage ||
 345                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 346                 } else {
 347                     isAccessible = true;
 348                 }
 349                 break;
 350             case PROTECTED:
 351                 isAccessible =
 352                     env.toplevel.packge == c.owner // fast special case
 353                     ||
 354                     env.toplevel.packge == c.packge()
 355                     ||
 356                     isInnerSubClass(env.enclClass.sym, c.owner);
 357                 break;
 358         }
 359         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 360             isAccessible :
 361             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 362     }
 363     //where
 364         /** Is given class a subclass of given base class, or an inner class
 365          *  of a subclass?
 366          *  Return null if no such class exists.
 367          *  @param c     The class which is the subclass or is contained in it.
 368          *  @param base  The base class
 369          */
 370         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 371             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 372                 c = c.owner.enclClass();
 373             }
 374             return c != null;
 375         }
 376 
 377     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 378         return isAccessible(env, t, false);
 379     }
 380 
 381     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 382         return (t.hasTag(ARRAY))
 383             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 384             : isAccessible(env, t.tsym, checkInner);
 385     }
 386 
 387     /** Is symbol accessible as a member of given type in given environment?
 388      *  @param env    The current environment.
 389      *  @param site   The type of which the tested symbol is regarded
 390      *                as a member.
 391      *  @param sym    The symbol.
 392      */
 393     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 394         return isAccessible(env, site, sym, false);
 395     }
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 397         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 398 
 399         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 400            to refer to an inaccessible type
 401         */
 402         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 403             return true;
 404 
 405         if (env.info.visitingServiceImplementation &amp;&amp;
 406             env.toplevel.modle == sym.packge().modle) {
 407             return true;
 408         }
 409 
 410         ClassSymbol enclosingCsym = env.enclClass.sym;
 411         if (sym.kind == MTH || sym.kind == VAR) {
 412             /* If any inline types are involved, ask the same question in the reference universe,
 413                where the hierarchy is navigable
 414             */
 415             if (site.isValue())
 416                 site = site.referenceProjection();
 417             if (sym.owner.isValue())
 418                 sym = sym.referenceProjection();
 419             if (env.enclClass.sym.isValue())
 420                 env.enclClass.sym = env.enclClass.sym.referenceProjection();
 421         }
 422         try {
 423             switch ((short)(sym.flags() &amp; AccessFlags)) {
 424                 case PRIVATE:
 425                     return
 426                             (env.enclClass.sym == sym.owner // fast special case
 427                                     ||
 428                                     env.enclClass.sym.outermostClass() ==
 429                                             sym.owner.outermostClass())
 430                                     &amp;&amp;
 431                                     sym.isInheritedIn(site.tsym, types);
 432                 case 0:
 433                     return
 434                             (env.toplevel.packge == sym.owner.owner // fast special case
 435                                     ||
 436                                     env.toplevel.packge == sym.packge())
 437                                     &amp;&amp;
 438                                     isAccessible(env, site, checkInner)
 439                                     &amp;&amp;
 440                                     sym.isInheritedIn(site.tsym, types)
 441                                     &amp;&amp;
 442                                     notOverriddenIn(site, sym);
 443                 case PROTECTED:
 444                     return
 445                             (env.toplevel.packge == sym.owner.owner // fast special case
 446                                     ||
 447                                     env.toplevel.packge == sym.packge()
 448                                     ||
 449                                     isProtectedAccessible(sym, env.enclClass.sym, site)
 450                                     ||
 451                                     // OK to select instance method or field from &#39;super&#39; or type name
 452                                     // (but type names should be disallowed elsewhere!)
 453                                     env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 454                                     &amp;&amp;
 455                                     isAccessible(env, site, checkInner)
 456                                     &amp;&amp;
 457                                     notOverriddenIn(site, sym);
 458                 default: // this case includes erroneous combinations as well
 459                     return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 460             }
 461         } finally {
 462             env.enclClass.sym = enclosingCsym;
 463         }
 464     }
 465     //where
 466     /* `sym&#39; is accessible only if not overridden by
 467      * another symbol which is a member of `site&#39;
 468      * (because, if it is overridden, `sym&#39; is not strictly
 469      * speaking a member of `site&#39;). A polymorphic signature method
 470      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 471      */
 472     private boolean notOverriddenIn(Type site, Symbol sym) {
 473         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 474             return true;
 475 
 476         /* If any inline types are involved, ask the same question in the reference universe,
 477            where the hierarchy is navigable
 478         */
 479         if (site.isValue())
 480             site = site.referenceProjection();
 481         if (sym.owner.isValue())
 482             sym = sym.referenceProjection();
 483 
 484         Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 485         return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 486                 !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 487     }
 488     //where
 489         /** Is given protected symbol accessible if it is selected from given site
 490          *  and the selection takes place in given class?
 491          *  @param sym     The symbol with protected access
 492          *  @param c       The class where the access takes place
 493          *  @site          The type of the qualifier
 494          */
 495         private
 496         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 497             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 498             while (c != null &amp;&amp;
 499                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 500                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 501                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 502                      // only to instance fields and methods -- types are excluded
 503                      // regardless of whether they are declared &#39;static&#39; or not.
 504                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 505                 c = c.owner.enclClass();
 506             return c != null;
 507         }
 508 
 509     /**
 510      * Performs a recursive scan of a type looking for accessibility problems
 511      * from current attribution environment
 512      */
 513     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 514         accessibilityChecker.visit(t, env);
 515     }
 516 
 517     /**
 518      * Accessibility type-visitor
 519      */
 520     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 521             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 522 
 523         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 524             for (Type t : ts) {
 525                 visit(t, env);
 526             }
 527         }
 528 
 529         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 530             return null;
 531         }
 532 
 533         @Override
 534         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 535             visit(t.elemtype, env);
 536             return null;
 537         }
 538 
 539         @Override
 540         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 541             visit(t.getTypeArguments(), env);
 542             if (!isAccessible(env, t, true)) {
 543                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 544             }
 545             return null;
 546         }
 547 
 548         @Override
 549         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 550             visit(t.type, env);
 551             return null;
 552         }
 553 
 554         @Override
 555         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 556             visit(t.getParameterTypes(), env);
 557             visit(t.getReturnType(), env);
 558             visit(t.getThrownTypes(), env);
 559             return null;
 560         }
 561     };
 562 
 563     /** Try to instantiate the type of a method so that it fits
 564      *  given type arguments and argument types. If successful, return
 565      *  the method&#39;s instantiated type, else return null.
 566      *  The instantiation will take into account an additional leading
 567      *  formal parameter if the method is an instance method seen as a member
 568      *  of an under determined site. In this case, we treat site as an additional
 569      *  parameter and the parameters of the class containing the method as
 570      *  additional type variables that get instantiated.
 571      *
 572      *  @param env         The current environment
 573      *  @param site        The type of which the method is a member.
 574      *  @param m           The method symbol.
 575      *  @param argtypes    The invocation&#39;s given value arguments.
 576      *  @param typeargtypes    The invocation&#39;s given type arguments.
 577      *  @param allowBoxing Allow boxing conversions of arguments.
 578      *  @param useVarargs Box trailing arguments into an array for varargs.
 579      */
 580     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 581                         Type site,
 582                         Symbol m,
 583                         ResultInfo resultInfo,
 584                         List&lt;Type&gt; argtypes,
 585                         List&lt;Type&gt; typeargtypes,
 586                         boolean allowBoxing,
 587                         boolean useVarargs,
 588                         Warner warn) throws Infer.InferenceException {
 589         Type mt = types.memberType(site, m);
 590         // tvars is the list of formal type variables for which type arguments
 591         // need to inferred.
 592         List&lt;Type&gt; tvars = List.nil();
 593         if (typeargtypes == null) typeargtypes = List.nil();
 594         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 595             // This is not a polymorphic method, but typeargs are supplied
 596             // which is fine, see JLS 15.12.2.1
 597         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 598             ForAll pmt = (ForAll) mt;
 599             if (typeargtypes.length() != pmt.tvars.length())
 600                  // not enough args
 601                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 602             // Check type arguments are within bounds
 603             List&lt;Type&gt; formals = pmt.tvars;
 604             List&lt;Type&gt; actuals = typeargtypes;
 605             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 606                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 607                                                 pmt.tvars, typeargtypes);
 608                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 609                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 610                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 611                     }
 612                 }
 613                 formals = formals.tail;
 614                 actuals = actuals.tail;
 615             }
 616             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 617         } else if (mt.hasTag(FORALL)) {
 618             ForAll pmt = (ForAll) mt;
 619             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 620             tvars = tvars.appendList(tvars1);
 621             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 622         }
 623 
 624         // find out whether we need to go the slow route via infer
 625         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 626         for (List&lt;Type&gt; l = argtypes;
 627              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 628              l = l.tail) {
 629             if (l.head.hasTag(FORALL)) instNeeded = true;
 630         }
 631 
 632         if (instNeeded) {
 633             return infer.instantiateMethod(env,
 634                                     tvars,
 635                                     (MethodType)mt,
 636                                     resultInfo,
 637                                     (MethodSymbol)m,
 638                                     argtypes,
 639                                     allowBoxing,
 640                                     useVarargs,
 641                                     currentResolutionContext,
 642                                     warn);
 643         }
 644 
 645         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 646         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 647                                 argtypes, mt.getParameterTypes(), warn);
 648         dc.complete();
 649         return mt;
 650     }
 651 
 652     Type checkMethod(Env&lt;AttrContext&gt; env,
 653                      Type site,
 654                      Symbol m,
 655                      ResultInfo resultInfo,
 656                      List&lt;Type&gt; argtypes,
 657                      List&lt;Type&gt; typeargtypes,
 658                      Warner warn) {
 659         MethodResolutionContext prevContext = currentResolutionContext;
 660         try {
 661             currentResolutionContext = new MethodResolutionContext();
 662             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 663                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 664             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 665                 //method/constructor references need special check class
 666                 //to handle inference variables in &#39;argtypes&#39; (might happen
 667                 //during an unsticking round)
 668                 currentResolutionContext.methodCheck =
 669                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 670             }
 671             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 672             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 673                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 674         }
 675         finally {
 676             currentResolutionContext = prevContext;
 677         }
 678     }
 679 
 680     /** Same but returns null instead throwing a NoInstanceException
 681      */
 682     Type instantiate(Env&lt;AttrContext&gt; env,
 683                      Type site,
 684                      Symbol m,
 685                      ResultInfo resultInfo,
 686                      List&lt;Type&gt; argtypes,
 687                      List&lt;Type&gt; typeargtypes,
 688                      boolean allowBoxing,
 689                      boolean useVarargs,
 690                      Warner warn) {
 691         try {
 692             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 693                                   allowBoxing, useVarargs, warn);
 694         } catch (InapplicableMethodException ex) {
 695             return null;
 696         }
 697     }
 698 
 699     /**
 700      * This interface defines an entry point that should be used to perform a
 701      * method check. A method check usually consist in determining as to whether
 702      * a set of types (actuals) is compatible with another set of types (formals).
 703      * Since the notion of compatibility can vary depending on the circumstances,
 704      * this interfaces allows to easily add new pluggable method check routines.
 705      */
 706     interface MethodCheck {
 707         /**
 708          * Main method check routine. A method check usually consist in determining
 709          * as to whether a set of types (actuals) is compatible with another set of
 710          * types (formals). If an incompatibility is found, an unchecked exception
 711          * is assumed to be thrown.
 712          */
 713         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 714                                 DeferredAttrContext deferredAttrContext,
 715                                 List&lt;Type&gt; argtypes,
 716                                 List&lt;Type&gt; formals,
 717                                 Warner warn);
 718 
 719         /**
 720          * Retrieve the method check object that will be used during a
 721          * most specific check.
 722          */
 723         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 724     }
 725 
 726     /**
 727      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 728      */
 729     enum MethodCheckDiag {
 730         /**
 731          * Actuals and formals differs in length.
 732          */
 733         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 734         /**
 735          * An actual is incompatible with a formal.
 736          */
 737         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 738         /**
 739          * An actual is incompatible with the varargs element type.
 740          */
 741         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 742         /**
 743          * The varargs element type is inaccessible.
 744          */
 745         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 746 
 747         final String basicKey;
 748         final String inferKey;
 749 
 750         MethodCheckDiag(String basicKey, String inferKey) {
 751             this.basicKey = basicKey;
 752             this.inferKey = inferKey;
 753         }
 754 
 755         String regex() {
 756             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 757         }
 758     }
 759 
 760     /**
 761      * Dummy method check object. All methods are deemed applicable, regardless
 762      * of their formal parameter types.
 763      */
 764     MethodCheck nilMethodCheck = new MethodCheck() {
 765         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 766             //do nothing - method always applicable regardless of actuals
 767         }
 768 
 769         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 770             return this;
 771         }
 772     };
 773 
 774     /**
 775      * Base class for &#39;real&#39; method checks. The class defines the logic for
 776      * iterating through formals and actuals and provides and entry point
 777      * that can be used by subclasses in order to define the actual check logic.
 778      */
 779     abstract class AbstractMethodCheck implements MethodCheck {
 780         @Override
 781         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 782                                     DeferredAttrContext deferredAttrContext,
 783                                     List&lt;Type&gt; argtypes,
 784                                     List&lt;Type&gt; formals,
 785                                     Warner warn) {
 786             //should we expand formals?
 787             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 788             JCTree callTree = treeForDiagnostics(env);
 789             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 790 
 791             //inference context used during this method check
 792             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 793 
 794             Type varargsFormal = useVarargs ? formals.last() : null;
 795 
 796             if (varargsFormal == null &amp;&amp;
 797                     argtypes.size() != formals.size()) {
 798                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 799             }
 800 
 801             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 802                 DiagnosticPosition pos = trees != null ? trees.head : null;
 803                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 804                 argtypes = argtypes.tail;
 805                 formals = formals.tail;
 806                 trees = trees != null ? trees.tail : trees;
 807             }
 808 
 809             if (formals.head != varargsFormal) {
 810                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 811             }
 812 
 813             if (useVarargs) {
 814                 //note: if applicability check is triggered by most specific test,
 815                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 816                 final Type elt = types.elemtype(varargsFormal);
 817                 while (argtypes.nonEmpty()) {
 818                     DiagnosticPosition pos = trees != null ? trees.head : null;
 819                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 820                     argtypes = argtypes.tail;
 821                     trees = trees != null ? trees.tail : trees;
 822                 }
 823             }
 824         }
 825 
 826             // where
 827             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 828                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 829             }
 830 
 831         /**
 832          * Does the actual argument conforms to the corresponding formal?
 833          */
 834         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 835 
 836         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 837             boolean inferDiag = inferenceContext != infer.emptyContext;
 838             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 839                 Object[] args2 = new Object[args.length + 1];
 840                 System.arraycopy(args, 0, args2, 1, args.length);
 841                 args2[0] = inferenceContext.inferenceVars();
 842                 args = args2;
 843             }
 844             String key = inferDiag ? diag.inferKey : diag.basicKey;
 845             throw inferDiag ?
 846                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 847                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 848         }
 849 
 850         /**
 851          * To eliminate the overhead associated with allocating an exception object in such an
 852          * hot execution path, we use flyweight pattern - and share the same exception instance
 853          * across multiple method check failures.
 854          */
 855         class SharedInapplicableMethodException extends InapplicableMethodException {
 856             private static final long serialVersionUID = 0;
 857 
 858             SharedInapplicableMethodException() {
 859                 super(null);
 860             }
 861 
 862             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 863                 this.diagnostic = details;
 864                 return this;
 865             }
 866         }
 867 
 868         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 869 
 870         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 871             return nilMethodCheck;
 872         }
 873 
 874     }
 875 
 876     /**
 877      * Arity-based method check. A method is applicable if the number of actuals
 878      * supplied conforms to the method signature.
 879      */
 880     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 881         @Override
 882         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 883             //do nothing - actual always compatible to formals
 884         }
 885 
 886         @Override
 887         public String toString() {
 888             return &quot;arityMethodCheck&quot;;
 889         }
 890     };
 891 
 892     /**
 893      * Main method applicability routine. Given a list of actual types A,
 894      * a list of formal types F, determines whether the types in A are
 895      * compatible (by method invocation conversion) with the types in F.
 896      *
 897      * Since this routine is shared between overload resolution and method
 898      * type-inference, a (possibly empty) inference context is used to convert
 899      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 900      * check so that constraints can be propagated and collected.
 901      *
 902      * Moreover, if one or more types in A is a deferred type, this routine uses
 903      * DeferredAttr in order to perform deferred attribution. If one or more actual
 904      * deferred types are stuck, they are placed in a queue and revisited later
 905      * after the remainder of the arguments have been seen. If this is not sufficient
 906      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 907      *
 908      * A method check handler (see above) is used in order to report errors.
 909      */
 910     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 911 
 912         @Override
 913         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 914             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 915             mresult.check(pos, actual);
 916         }
 917 
 918         @Override
 919         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 920                                     DeferredAttrContext deferredAttrContext,
 921                                     List&lt;Type&gt; argtypes,
 922                                     List&lt;Type&gt; formals,
 923                                     Warner warn) {
 924             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 925             // should we check varargs element type accessibility?
 926             if (deferredAttrContext.phase.isVarargsRequired()) {
 927                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 928                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 929                 }
 930             }
 931         }
 932 
 933         /**
 934          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 935          * varargs element type of either the method invocation type signature (after inference completes)
 936          * or the method declaration signature (before inference completes).
 937          */
 938         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 939             if (inferenceContext.free(t)) {
 940                 inferenceContext.addFreeTypeListener(List.of(t),
 941                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 942             } else {
 943                 if (!isAccessible(env, types.erasure(t))) {
 944                     Symbol location = env.enclClass.sym;
 945                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 946                 }
 947             }
 948         }
 949 
 950         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 951                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 952             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 953                 MethodCheckDiag methodDiag = varargsCheck ?
 954                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 955 
 956                 @Override
 957                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 958                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 959                 }
 960             };
 961             return new MethodResultInfo(to, checkContext);
 962         }
 963 
 964         @Override
 965         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 966             return new MostSpecificCheck(actuals);
 967         }
 968 
 969         @Override
 970         public String toString() {
 971             return &quot;resolveMethodCheck&quot;;
 972         }
 973     };
 974 
 975     /**
 976      * This class handles method reference applicability checks; since during
 977      * these checks it&#39;s sometime possible to have inference variables on
 978      * the actual argument types list, the method applicability check must be
 979      * extended so that inference variables are &#39;opened&#39; as needed.
 980      */
 981     class MethodReferenceCheck extends AbstractMethodCheck {
 982 
 983         InferenceContext pendingInferenceContext;
 984 
 985         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 986             this.pendingInferenceContext = pendingInferenceContext;
 987         }
 988 
 989         @Override
 990         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 991             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 992             mresult.check(pos, actual);
 993         }
 994 
 995         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 996                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 997             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 998                 MethodCheckDiag methodDiag = varargsCheck ?
 999                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
1000 
1001                 @Override
1002                 public boolean compatible(Type found, Type req, Warner warn) {
1003                     found = pendingInferenceContext.asUndetVar(found);
1004                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
1005                         req = types.boxedClass(req).type;
1006                     }
1007                     return super.compatible(found, req, warn);
1008                 }
1009 
1010                 @Override
1011                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1012                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
1013                 }
1014             };
1015             return new MethodResultInfo(to, checkContext);
1016         }
1017 
1018         @Override
1019         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1020             return new MostSpecificCheck(actuals);
1021         }
1022 
1023         @Override
1024         public String toString() {
1025             return &quot;MethodReferenceCheck&quot;;
1026         }
1027     }
1028 
1029     /**
1030      * Check context to be used during method applicability checks. A method check
1031      * context might contain inference variables.
1032      */
1033     abstract class MethodCheckContext implements CheckContext {
1034 
1035         boolean strict;
1036         DeferredAttrContext deferredAttrContext;
1037         Warner rsWarner;
1038 
1039         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1040            this.strict = strict;
1041            this.deferredAttrContext = deferredAttrContext;
1042            this.rsWarner = rsWarner;
1043         }
1044 
1045         public boolean compatible(Type found, Type req, Warner warn) {
1046             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1047             return strict ?
1048                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1049                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1050         }
1051 
1052         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1053             throw new InapplicableMethodException(details);
1054         }
1055 
1056         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1057             return rsWarner;
1058         }
1059 
1060         public InferenceContext inferenceContext() {
1061             return deferredAttrContext.inferenceContext;
1062         }
1063 
1064         public DeferredAttrContext deferredAttrContext() {
1065             return deferredAttrContext;
1066         }
1067 
1068         @Override
1069         public String toString() {
1070             return &quot;MethodCheckContext&quot;;
1071         }
1072     }
1073 
1074     /**
1075      * ResultInfo class to be used during method applicability checks. Check
1076      * for deferred types goes through special path.
1077      */
1078     class MethodResultInfo extends ResultInfo {
1079 
1080         public MethodResultInfo(Type pt, CheckContext checkContext) {
1081             attr.super(KindSelector.VAL, pt, checkContext);
1082         }
1083 
1084         @Override
1085         protected Type check(DiagnosticPosition pos, Type found) {
1086             if (found.hasTag(DEFERRED)) {
1087                 DeferredType dt = (DeferredType)found;
1088                 return dt.check(this);
1089             } else {
1090                 Type uResult = U(found);
1091                 Type capturedType = pos == null || pos.getTree() == null ?
1092                         types.capture(uResult) :
1093                         checkContext.inferenceContext()
1094                             .cachedCapture(pos.getTree(), uResult, true);
1095                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1096             }
1097         }
1098 
1099         /**
1100          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1101          * given an actual argument type, the method check is performed
1102          * on its upper bound. This leads to inconsistencies when an
1103          * argument type is checked against itself. For example, given
1104          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1105          * so we need to guard against that.
1106          */
1107         private Type U(Type found) {
1108             return found == pt ?
1109                     found : types.cvarUpperBound(found);
1110         }
1111 
1112         @Override
1113         protected MethodResultInfo dup(Type newPt) {
1114             return new MethodResultInfo(newPt, checkContext);
1115         }
1116 
1117         @Override
1118         protected ResultInfo dup(CheckContext newContext) {
1119             return new MethodResultInfo(pt, newContext);
1120         }
1121 
1122         @Override
1123         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1124             return new MethodResultInfo(newPt, newContext);
1125         }
1126     }
1127 
1128     /**
1129      * Most specific method applicability routine. Given a list of actual types A,
1130      * a list of formal types F1, and a list of formal types F2, the routine determines
1131      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1132      * argument types A.
1133      */
1134     class MostSpecificCheck implements MethodCheck {
1135 
1136         List&lt;Type&gt; actuals;
1137 
1138         MostSpecificCheck(List&lt;Type&gt; actuals) {
1139             this.actuals = actuals;
1140         }
1141 
1142         @Override
1143         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1144                                     DeferredAttrContext deferredAttrContext,
1145                                     List&lt;Type&gt; formals1,
1146                                     List&lt;Type&gt; formals2,
1147                                     Warner warn) {
1148             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1149             while (formals2.nonEmpty()) {
1150                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1151                 mresult.check(null, formals1.head);
1152                 formals1 = formals1.tail;
1153                 formals2 = formals2.tail;
1154                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1155             }
1156         }
1157 
1158        /**
1159         * Create a method check context to be used during the most specific applicability check
1160         */
1161         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1162                Warner rsWarner, Type actual) {
1163             return attr.new ResultInfo(KindSelector.VAL, to,
1164                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1165         }
1166 
1167         /**
1168          * Subclass of method check context class that implements most specific
1169          * method conversion. If the actual type under analysis is a deferred type
1170          * a full blown structural analysis is carried out.
1171          */
1172         class MostSpecificCheckContext extends MethodCheckContext {
1173 
1174             Type actual;
1175 
1176             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1177                 super(true, deferredAttrContext, rsWarner);
1178                 this.actual = actual;
1179             }
1180 
1181             public boolean compatible(Type found, Type req, Warner warn) {
1182                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1183                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1184                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1185                     DeferredType dt = (DeferredType) actual;
1186                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1187                     if (speculativeTree != deferredAttr.stuckTree) {
1188                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1189                     }
1190                 }
1191                 return compatibleBySubtyping(found, req);
1192             }
1193 
1194             private boolean compatibleBySubtyping(Type found, Type req) {
1195                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1196                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1197                 }
1198                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1199             }
1200 
1201             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1202             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1203                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1204                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1205                        unrelatedInterfaces(t, s);
1206             }
1207 
1208             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1209             private boolean unrelatedInterfaces(Type t, Type s) {
1210                 if (t.isCompound()) {
1211                     for (Type ti : types.interfaces(t)) {
1212                         if (!unrelatedInterfaces(ti, s)) {
1213                             return false;
1214                         }
1215                     }
1216                     return true;
1217                 } else if (s.isCompound()) {
1218                     for (Type si : types.interfaces(s)) {
1219                         if (!unrelatedInterfaces(t, si)) {
1220                             return false;
1221                         }
1222                     }
1223                     return true;
1224                 } else {
1225                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1226                 }
1227             }
1228 
1229             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1230             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1231                 Type tDesc = types.findDescriptorType(types.capture(t));
1232                 Type tDescNoCapture = types.findDescriptorType(t);
1233                 Type sDesc = types.findDescriptorType(s);
1234                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1235                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1236                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1237 
1238                 // compare type parameters
1239                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1240                     return false;
1241                 }
1242                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1243                 List&lt;Type&gt; tIter = tTypeParams;
1244                 List&lt;Type&gt; sIter = sTypeParams;
1245                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1246                     Type tBound = tIter.head.getUpperBound();
1247                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1248                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1249                         return false;
1250                     }
1251                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1252                         return false;
1253                     }
1254                     tIter = tIter.tail;
1255                     sIter = sIter.tail;
1256                 }
1257                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1258                     return false;
1259                 }
1260 
1261                 // compare parameters
1262                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1263                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1264                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1265                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1266                     Type tParam = tParams.head;
1267                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1268                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1269                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1270                         return false;
1271                     }
1272                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1273                         return false;
1274                     }
1275                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1276                         return false;
1277                     }
1278                     tParams = tParams.tail;
1279                     tParamsNoCapture = tParamsNoCapture.tail;
1280                     sParams = sParams.tail;
1281                 }
1282                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1283                     return false;
1284                 }
1285 
1286                 // compare returns
1287                 Type tRet = tDesc.getReturnType();
1288                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1289                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1290                     return false;
1291                 }
1292                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1293                 msc.scan(tree);
1294                 return msc.result;
1295             }
1296 
1297             /**
1298              * Tests whether one functional interface type can be considered more specific
1299              * than another unrelated functional interface type for the scanned expression.
1300              */
1301             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1302 
1303                 final Type tRet;
1304                 final Type sRet;
1305                 boolean result;
1306 
1307                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1308                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1309                     this.tRet = tRet;
1310                     this.sRet = sRet;
1311                     result = true;
1312                 }
1313 
1314                 @Override
1315                 void skip(JCTree tree) {
1316                     result &amp;= false;
1317                 }
1318 
1319                 @Override
1320                 public void visitConditional(JCConditional tree) {
1321                     scan(asExpr(tree.truepart));
1322                     scan(asExpr(tree.falsepart));
1323                 }
1324 
1325                 @Override
1326                 public void visitReference(JCMemberReference tree) {
1327                     if (sRet.hasTag(VOID)) {
1328                         result &amp;= true;
1329                     } else if (tRet.hasTag(VOID)) {
1330                         result &amp;= false;
1331                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1332                         boolean retValIsPrimitive =
1333                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1334                                 tree.sym.type.getReturnType().isPrimitive();
1335                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1336                                   (retValIsPrimitive != sRet.isPrimitive());
1337                     } else {
1338                         result &amp;= compatibleBySubtyping(tRet, sRet);
1339                     }
1340                 }
1341 
1342                 @Override
1343                 public void visitParens(JCParens tree) {
1344                     scan(asExpr(tree.expr));
1345                 }
1346 
1347                 @Override
1348                 public void visitLambda(JCLambda tree) {
1349                     if (sRet.hasTag(VOID)) {
1350                         result &amp;= true;
1351                     } else if (tRet.hasTag(VOID)) {
1352                         result &amp;= false;
1353                     } else {
1354                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1355                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1356                             for (JCExpression expr : lambdaResults) {
1357                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1358                             }
1359                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1360                             for (JCExpression expr : lambdaResults) {
1361                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1362                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1363                                         (retValIsPrimitive != sRet.isPrimitive());
1364                             }
1365                         } else {
1366                             result &amp;= compatibleBySubtyping(tRet, sRet);
1367                         }
1368                     }
1369                 }
1370                 //where
1371 
1372                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1373                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1374                         return List.of(asExpr((JCExpression) lambda.body));
1375                     } else {
1376                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1377                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1378                                 new DeferredAttr.LambdaReturnScanner() {
1379                                     @Override
1380                                     public void visitReturn(JCReturn tree) {
1381                                         if (tree.expr != null) {
1382                                             buffer.append(asExpr(tree.expr));
1383                                         }
1384                                     }
1385                                 };
1386                         lambdaScanner.scan(lambda.body);
1387                         return buffer.toList();
1388                     }
1389                 }
1390 
1391                 private JCExpression asExpr(JCExpression expr) {
1392                     if (expr.type.hasTag(DEFERRED)) {
1393                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1394                         if (speculativeTree != deferredAttr.stuckTree) {
1395                             expr = (JCExpression)speculativeTree;
1396                         }
1397                     }
1398                     return expr;
1399                 }
1400             }
1401 
1402         }
1403 
1404         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1405             Assert.error(&quot;Cannot get here!&quot;);
1406             return null;
1407         }
1408     }
1409 
1410     public static class InapplicableMethodException extends RuntimeException {
1411         private static final long serialVersionUID = 0;
1412 
1413         transient JCDiagnostic diagnostic;
1414 
1415         InapplicableMethodException(JCDiagnostic diag) {
1416             this.diagnostic = diag;
1417         }
1418 
1419         public JCDiagnostic getDiagnostic() {
1420             return diagnostic;
1421         }
1422     }
1423 
1424 /* ***************************************************************************
1425  *  Symbol lookup
1426  *  the following naming conventions for arguments are used
1427  *
1428  *       env      is the environment where the symbol was mentioned
1429  *       site     is the type of which the symbol is a member
1430  *       name     is the symbol&#39;s name
1431  *                if no arguments are given
1432  *       argtypes are the value arguments, if we search for a method
1433  *
1434  *  If no symbol was found, a ResolveError detailing the problem is returned.
1435  ****************************************************************************/
1436 
1437     /** Find field. Synthetic fields are always skipped.
1438      *  @param env     The current environment.
1439      *  @param site    The original type from where the selection takes place.
1440      *  @param name    The name of the field.
1441      *  @param c       The class to search for the field. This is always
1442      *                 a superclass or implemented interface of site&#39;s class.
1443      */
1444     Symbol findField(Env&lt;AttrContext&gt; env,
1445                      Type site,
1446                      Name name,
1447                      TypeSymbol c) {
1448         while (c.type.hasTag(TYPEVAR))
1449             c = c.type.getUpperBound().tsym;
1450         Symbol bestSoFar = varNotFound;
1451         Symbol sym;
1452         for (Symbol s : c.members().getSymbolsByName(name)) {
1453             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1454                 return isAccessible(env, site, s)
1455                     ? s : new AccessError(env, site, s);
1456             }
1457         }
1458         Type st = types.supertype(c.type);
1459         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1460             sym = findField(env, site, name, st.tsym);
1461             bestSoFar = bestOf(bestSoFar, sym);
1462         }
1463         for (List&lt;Type&gt; l = types.interfaces(c.type);
1464              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1465              l = l.tail) {
1466             sym = findField(env, site, name, l.head.tsym);
1467             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1468                 sym.owner != bestSoFar.owner)
1469                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1470             else
1471                 bestSoFar = bestOf(bestSoFar, sym);
1472         }
1473         return bestSoFar;
1474     }
1475 
1476     /** Resolve a field identifier, throw a fatal error if not found.
1477      *  @param pos       The position to use for error reporting.
1478      *  @param env       The environment current at the method invocation.
1479      *  @param site      The type of the qualifying expression, in which
1480      *                   identifier is searched.
1481      *  @param name      The identifier&#39;s name.
1482      */
1483     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1484                                           Type site, Name name) {
1485         Symbol sym = findField(env, site, name, site.tsym);
1486         if (sym.kind == VAR) return (VarSymbol)sym;
1487         else throw new FatalError(
1488                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1489     }
1490 
1491     /** Find unqualified variable or field with given name.
1492      *  Synthetic fields always skipped.
1493      *  @param env     The current environment.
1494      *  @param name    The name of the variable or field.
1495      */
1496     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1497         Symbol bestSoFar = varNotFound;
1498         Env&lt;AttrContext&gt; env1 = env;
1499         boolean staticOnly = false;
1500         while (env1.outer != null) {
1501             Symbol sym = null;
1502             if (isStatic(env1)) staticOnly = true;
1503             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1504                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1505                     sym = s;
1506                     break;
1507                 }
1508             }
1509             if (sym == null) {
1510                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1511             }
1512             if (sym.exists()) {
1513                 if (staticOnly &amp;&amp;
1514                     sym.kind == VAR &amp;&amp;
1515                         // if it is a field
1516                         (sym.owner.kind == TYP ||
1517                         // or it is a local variable but it is not declared inside of the static local type
1518                         // only records so far, then error
1519                         (sym.owner.kind == MTH) &amp;&amp;
1520                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;
1521                         sym.enclClass() != env.enclClass.sym) &amp;&amp;
1522                     (sym.flags() &amp; STATIC) == 0)
1523                     return new StaticError(sym);
1524                 else
1525                     return sym;
1526             } else {
1527                 bestSoFar = bestOf(bestSoFar, sym);
1528             }
1529 
1530             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1531             env1 = env1.outer;
1532         }
1533 
1534         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1535         if (sym.exists())
1536             return sym;
1537         if (bestSoFar.exists())
1538             return bestSoFar;
1539 
1540         Symbol origin = null;
1541         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1542             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1543                 if (currentSymbol.kind != VAR)
1544                     continue;
1545                 // invariant: sym.kind == Symbol.Kind.VAR
1546                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1547                     currentSymbol.owner != bestSoFar.owner)
1548                     return new AmbiguityError(bestSoFar, currentSymbol);
1549                 else if (!bestSoFar.kind.betterThan(VAR)) {
1550                     origin = sc.getOrigin(currentSymbol).owner;
1551                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1552                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1553                 }
1554             }
1555             if (bestSoFar.exists()) break;
1556         }
1557         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1558             return bestSoFar.clone(origin);
1559         else
1560             return bestSoFar;
1561     }
1562 
1563     Warner noteWarner = new Warner();
1564 
1565     /** Select the best method for a call site among two choices.
1566      *  @param env              The current environment.
1567      *  @param site             The original type from where the
1568      *                          selection takes place.
1569      *  @param argtypes         The invocation&#39;s value arguments,
1570      *  @param typeargtypes     The invocation&#39;s type arguments,
1571      *  @param sym              Proposed new best match.
1572      *  @param bestSoFar        Previously found best match.
1573      *  @param allowBoxing Allow boxing conversions of arguments.
1574      *  @param useVarargs Box trailing arguments into an array for varargs.
1575      */
1576     @SuppressWarnings(&quot;fallthrough&quot;)
1577     Symbol selectBest(Env&lt;AttrContext&gt; env,
1578                       Type site,
1579                       List&lt;Type&gt; argtypes,
1580                       List&lt;Type&gt; typeargtypes,
1581                       Symbol sym,
1582                       Symbol bestSoFar,
1583                       boolean allowBoxing,
1584                       boolean useVarargs) {
1585         if (sym.kind == ERR ||
1586                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1587                 !notOverriddenIn(site, sym)) {
1588             return bestSoFar;
1589         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1590             return bestSoFar.kind.isResolutionError() ?
1591                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1592                     bestSoFar;
1593         }
1594         Assert.check(!sym.kind.isResolutionError());
1595         try {
1596             types.noWarnings.clear();
1597             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1598                                allowBoxing, useVarargs, types.noWarnings);
1599             currentResolutionContext.addApplicableCandidate(sym, mt);
1600         } catch (InapplicableMethodException ex) {
1601             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1602             switch (bestSoFar.kind) {
1603                 case ABSENT_MTH:
1604                     return new InapplicableSymbolError(currentResolutionContext);
1605                 case WRONG_MTH:
1606                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1607                 default:
1608                     return bestSoFar;
1609             }
1610         }
1611         if (!isAccessible(env, site, sym)) {
1612             return (bestSoFar.kind == ABSENT_MTH)
1613                 ? new AccessError(env, site, sym)
1614                 : bestSoFar;
1615         }
1616         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1617             ? sym
1618             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1619     }
1620 
1621     /* Return the most specific of the two methods for a call,
1622      *  given that both are accessible and applicable.
1623      *  @param m1               A new candidate for most specific.
1624      *  @param m2               The previous most specific candidate.
1625      *  @param env              The current environment.
1626      *  @param site             The original type from where the selection
1627      *                          takes place.
1628      *  @param allowBoxing Allow boxing conversions of arguments.
1629      *  @param useVarargs Box trailing arguments into an array for varargs.
1630      */
1631     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1632                         Symbol m2,
1633                         Env&lt;AttrContext&gt; env,
1634                         final Type site,
1635                         boolean useVarargs) {
1636         switch (m2.kind) {
1637         case MTH:
1638             if (m1 == m2) return m1;
1639             boolean m1SignatureMoreSpecific =
1640                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1641             boolean m2SignatureMoreSpecific =
1642                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1643             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1644                 Type mt1 = types.memberType(site, m1);
1645                 Type mt2 = types.memberType(site, m2);
1646                 if (!types.overrideEquivalent(mt1, mt2))
1647                     return ambiguityError(m1, m2);
1648 
1649                 // same signature; select (a) the non-bridge method, or
1650                 // (b) the one that overrides the other, or (c) the concrete
1651                 // one, or (d) merge both abstract signatures
1652                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1653                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1654 
1655                 if (m1.baseSymbol() == m2.baseSymbol()) {
1656                     // this is the same imported symbol which has been cloned twice.
1657                     // Return the first one (either will do).
1658                     return m1;
1659                 }
1660 
1661                 // if one overrides or hides the other, use it
1662                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1663                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1664                 // the two owners can never be the same if the target methods are compiled from source,
1665                 // but we need to protect against cases where the methods are defined in some classfile
1666                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1667                 if (m1Owner != m2Owner) {
1668                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1669                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1670                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1671                         m1.overrides(m2, m1Owner, types, false))
1672                         return m1;
1673                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1674                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1675                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1676                         m2.overrides(m1, m2Owner, types, false))
1677                         return m2;
1678                 }
1679                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1680                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1681                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1682                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1683                 // both abstract or both concrete
1684                 return ambiguityError(m1, m2);
1685             }
1686             if (m1SignatureMoreSpecific) return m1;
1687             if (m2SignatureMoreSpecific) return m2;
1688             return ambiguityError(m1, m2);
1689         case AMBIGUOUS:
1690             //compare m1 to ambiguous methods in m2
1691             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1692             boolean m1MoreSpecificThanAnyAmbiguous = true;
1693             boolean allAmbiguousMoreSpecificThanM1 = true;
1694             for (Symbol s : e.ambiguousSyms) {
1695                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1696                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1697                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1698             }
1699             if (m1MoreSpecificThanAnyAmbiguous)
1700                 return m1;
1701             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1702             //more specific than m1, add it as a new ambiguous method:
1703             if (!allAmbiguousMoreSpecificThanM1)
1704                 e.addAmbiguousSymbol(m1);
1705             return e;
1706         default:
1707             throw new AssertionError();
1708         }
1709     }
1710     //where
1711     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1712         noteWarner.clear();
1713         int maxLength = Math.max(
1714                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1715                             m2.type.getParameterTypes().length());
1716         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1717         try {
1718             currentResolutionContext = new MethodResolutionContext();
1719             currentResolutionContext.step = prevResolutionContext.step;
1720             currentResolutionContext.methodCheck =
1721                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1722             Type mst = instantiate(env, site, m2, null,
1723                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1724                     false, useVarargs, noteWarner);
1725             return mst != null &amp;&amp;
1726                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1727         } finally {
1728             currentResolutionContext = prevResolutionContext;
1729         }
1730     }
1731 
1732     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1733         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1734             Type varargsElem = types.elemtype(args.last());
1735             if (varargsElem == null) {
1736                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1737             }
1738             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1739             while (newArgs.length() &lt; length) {
1740                 newArgs = newArgs.append(newArgs.last());
1741             }
1742             return newArgs;
1743         } else {
1744             return args;
1745         }
1746     }
1747     //where
1748     Symbol ambiguityError(Symbol m1, Symbol m2) {
1749         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1750             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1751         } else {
1752             return new AmbiguityError(m1, m2);
1753         }
1754     }
1755 
1756     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1757             Type site,
1758             Name name,
1759             List&lt;Type&gt; argtypes,
1760             List&lt;Type&gt; typeargtypes,
1761             Scope sc,
1762             Symbol bestSoFar,
1763             boolean allowBoxing,
1764             boolean useVarargs,
1765             boolean abstractok) {
1766         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1767             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1768                     bestSoFar, allowBoxing, useVarargs);
1769         }
1770         return bestSoFar;
1771     }
1772     //where
1773         class LookupFilter implements Filter&lt;Symbol&gt; {
1774 
1775             boolean abstractOk;
1776 
1777             LookupFilter(boolean abstractOk) {
1778                 this.abstractOk = abstractOk;
1779             }
1780 
1781             public boolean accepts(Symbol s) {
1782                 long flags = s.flags();
1783                 return s.kind == MTH &amp;&amp;
1784                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1785                         (abstractOk ||
1786                         (flags &amp; DEFAULT) != 0 ||
1787                         (flags &amp; ABSTRACT) == 0);
1788             }
1789         }
1790 
1791     /** Find best qualified method matching given name, type and value
1792      *  arguments.
1793      *  @param env       The current environment.
1794      *  @param site      The original type from where the selection
1795      *                   takes place.
1796      *  @param name      The method&#39;s name.
1797      *  @param argtypes  The method&#39;s value arguments.
1798      *  @param typeargtypes The method&#39;s type arguments
1799      *  @param allowBoxing Allow boxing conversions of arguments.
1800      *  @param useVarargs Box trailing arguments into an array for varargs.
1801      */
1802     Symbol findMethod(Env&lt;AttrContext&gt; env,
1803                       Type site,
1804                       Name name,
1805                       List&lt;Type&gt; argtypes,
1806                       List&lt;Type&gt; typeargtypes,
1807                       boolean allowBoxing,
1808                       boolean useVarargs) {
1809         Symbol bestSoFar = methodNotFound;
1810         bestSoFar = findMethod(env,
1811                           site,
1812                           name,
1813                           argtypes,
1814                           typeargtypes,
1815                           site.tsym.type,
1816                           bestSoFar,
1817                           allowBoxing,
1818                           useVarargs);
1819         return bestSoFar;
1820     }
1821     // where
1822     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1823                               Type site,
1824                               Name name,
1825                               List&lt;Type&gt; argtypes,
1826                               List&lt;Type&gt; typeargtypes,
1827                               Type intype,
1828                               Symbol bestSoFar,
1829                               boolean allowBoxing,
1830                               boolean useVarargs) {
1831         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1832         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1833 
1834         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1835         for (TypeSymbol s : superclasses(intype)) {
1836             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1837                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1838             if (name == names.init) return bestSoFar;
1839             iphase = (iphase == null) ? null : iphase.update(s, this);
1840             if (iphase != null) {
1841                 for (Type itype : types.interfaces(s.type)) {
1842                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1843                 }
1844             }
1845         }
1846 
1847         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1848                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1849                 bestSoFar : methodNotFound;
1850 
1851         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1852             //keep searching for abstract methods
1853             for (Type itype : itypes[iphase2.ordinal()]) {
1854                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1855                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1856                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1857                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1858                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1859                 if (concrete != bestSoFar &amp;&amp;
1860                     concrete.kind.isValid() &amp;&amp;
1861                     bestSoFar.kind.isValid() &amp;&amp;
1862                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1863                     //this is an hack - as javac does not do full membership checks
1864                     //most specific ends up comparing abstract methods that might have
1865                     //been implemented by some concrete method in a subclass and,
1866                     //because of raw override, it is possible for an abstract method
1867                     //to be more specific than the concrete method - so we need
1868                     //to explicitly call that out (see CR 6178365)
1869                     bestSoFar = concrete;
1870                 }
1871             }
1872         }
1873         return bestSoFar;
1874     }
1875 
1876     enum InterfaceLookupPhase {
1877         ABSTRACT_OK() {
1878             @Override
1879             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1880                 //We should not look for abstract methods if receiver is a concrete class
1881                 //(as concrete classes are expected to implement all abstracts coming
1882                 //from superinterfaces)
1883                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1884                     return this;
1885                 } else {
1886                     return DEFAULT_OK;
1887                 }
1888             }
1889         },
1890         DEFAULT_OK() {
1891             @Override
1892             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1893                 return this;
1894             }
1895         };
1896 
1897         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1898     }
1899 
1900     /**
1901      * Return an Iterable object to scan the superclasses of a given type.
1902      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1903      * access more supertypes than strictly needed (as this could trigger completion
1904      * errors if some of the not-needed supertypes are missing/ill-formed).
1905      */
1906     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1907         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1908 
1909             List&lt;TypeSymbol&gt; seen = List.nil();
1910             TypeSymbol currentSym = symbolFor(intype);
1911             TypeSymbol prevSym = null;
1912 
1913             public boolean hasNext() {
1914                 if (currentSym == syms.noSymbol) {
1915                     currentSym = symbolFor(types.supertype(prevSym.type));
1916                 }
1917                 return currentSym != null;
1918             }
1919 
1920             public TypeSymbol next() {
1921                 prevSym = currentSym;
1922                 currentSym = syms.noSymbol;
1923                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1924                 return prevSym;
1925             }
1926 
1927             public void remove() {
1928                 throw new UnsupportedOperationException();
1929             }
1930 
1931             TypeSymbol symbolFor(Type t) {
1932                 if (!t.hasTag(CLASS) &amp;&amp;
1933                         !t.hasTag(TYPEVAR)) {
1934                     return null;
1935                 }
1936                 t = types.skipTypeVars(t, false);
1937                 if (seen.contains(t.tsym)) {
1938                     //degenerate case in which we have a circular
1939                     //class hierarchy - because of ill-formed classfiles
1940                     return null;
1941                 }
1942                 seen = seen.prepend(t.tsym);
1943                 return t.tsym;
1944             }
1945         };
1946     }
1947 
1948     /** Find unqualified method matching given name, type and value arguments.
1949      *  @param env       The current environment.
1950      *  @param name      The method&#39;s name.
1951      *  @param argtypes  The method&#39;s value arguments.
1952      *  @param typeargtypes  The method&#39;s type arguments.
1953      *  @param allowBoxing Allow boxing conversions of arguments.
1954      *  @param useVarargs Box trailing arguments into an array for varargs.
1955      */
1956     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1957                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1958                    boolean allowBoxing, boolean useVarargs) {
1959         Symbol bestSoFar = methodNotFound;
1960         Env&lt;AttrContext&gt; env1 = env;
1961         boolean staticOnly = false;
1962         while (env1.outer != null) {
1963             if (isStatic(env1)) staticOnly = true;
1964             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1965             env1.info.preferredTreeForDiagnostics = env.tree;
1966             try {
1967                 Symbol sym = findMethod(
1968                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1969                     allowBoxing, useVarargs);
1970                 if (sym.exists()) {
1971                     if (staticOnly &amp;&amp;
1972                         sym.kind == MTH &amp;&amp;
1973                         sym.owner.kind == TYP &amp;&amp;
1974                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1975                     else return sym;
1976                 } else {
1977                     bestSoFar = bestOf(bestSoFar, sym);
1978                 }
1979             } finally {
1980                 env1.info.preferredTreeForDiagnostics = null;
1981             }
1982             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1983             env1 = env1.outer;
1984         }
1985 
1986         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1987                                 typeargtypes, allowBoxing, useVarargs);
1988         if (sym.exists())
1989             return sym;
1990 
1991         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1992             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1993             if (currentSym.kind == MTH) {
1994                 if (currentSym.owner.type != origin.type)
1995                     currentSym = currentSym.clone(origin);
1996                 if (!isAccessible(env, origin.type, currentSym))
1997                     currentSym = new AccessError(env, origin.type, currentSym);
1998                 bestSoFar = selectBest(env, origin.type,
1999                                        argtypes, typeargtypes,
2000                                        currentSym, bestSoFar,
2001                                        allowBoxing, useVarargs);
2002             }
2003         }
2004         if (bestSoFar.exists())
2005             return bestSoFar;
2006 
2007         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
2008             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
2009             if (currentSym.kind == MTH) {
2010                 if (currentSym.owner.type != origin.type)
2011                     currentSym = currentSym.clone(origin);
2012                 if (!isAccessible(env, origin.type, currentSym))
2013                     currentSym = new AccessError(env, origin.type, currentSym);
2014                 bestSoFar = selectBest(env, origin.type,
2015                                        argtypes, typeargtypes,
2016                                        currentSym, bestSoFar,
2017                                        allowBoxing, useVarargs);
2018             }
2019         }
2020         return bestSoFar;
2021     }
2022 
2023     /** Load toplevel or member class with given fully qualified name and
2024      *  verify that it is accessible.
2025      *  @param env       The current environment.
2026      *  @param name      The fully qualified name of the class to be loaded.
2027      */
2028     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2029         try {
2030             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2031             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2032         } catch (ClassFinder.BadClassFile err) {
2033             return new BadClassFileError(err);
2034         } catch (CompletionFailure ex) {
2035             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2036 
2037             if (candidate != null) {
2038                 return candidate;
2039             }
2040 
2041             return typeNotFound;
2042         }
2043     }
2044 
2045     public interface RecoveryLoadClass {
2046         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2047     }
2048 
2049     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2050 
2051     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2052         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2053             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2054             return lookupInvisibleSymbol(env, name,
2055                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2056                                                                            c -&gt; syms.getClassesForName(c)
2057                                                                                     .iterator()),
2058                                          (ms, n) -&gt; {
2059                 for (Name candidate : candidates) {
2060                     try {
2061                         return finder.loadClass(ms, candidate);
2062                     } catch (CompletionFailure cf) {
2063                         //ignore
2064                     }
2065                 }
2066                 return null;
2067             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2068         }
2069     };
2070 
2071     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2072         Scope importScope = env.toplevel.namedImportScope;
2073         Symbol existing = importScope.findFirst(Convert.shortName(name),
2074                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2075 
2076         if (existing != null) {
2077             return new InvisibleSymbolError(env, true, existing);
2078         }
2079         return null;
2080     };
2081 
2082     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2083         Scope importScope = env.toplevel.starImportScope;
2084         Symbol existing = importScope.findFirst(Convert.shortName(name),
2085                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2086 
2087         if (existing != null) {
2088             try {
2089                 existing = finder.loadClass(existing.packge().modle, name);
2090 
2091                 return new InvisibleSymbolError(env, true, existing);
2092             } catch (CompletionFailure cf) {
2093                 //ignore
2094             }
2095         }
2096 
2097         return null;
2098     };
2099 
2100     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2101         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2102 
2103         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2104             if (pack.members().isEmpty()) {
2105                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2106                     sym.complete();
2107                     return !sym.members().isEmpty();
2108                 }, pack);
2109             }
2110         }
2111 
2112         return pack;
2113     }
2114 
2115     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2116         if (!env.tree.hasTag(IMPORT))
2117             return false;
2118 
2119         JCTree qualid = ((JCImport) env.tree).qualid;
2120 
2121         if (!qualid.hasTag(SELECT))
2122             return false;
2123 
2124         if (TreeInfo.name(qualid) != names.asterisk)
2125             return false;
2126 
2127         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2128     }
2129 
2130     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2131                                                             Name name,
2132                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2133                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2134                                                             Predicate&lt;S&gt; validate,
2135                                                             Symbol defaultResult) {
2136         //even if a class/package cannot be found in the current module and among packages in modules
2137         //it depends on that are exported for any or this module, the class/package may exist internally
2138         //in some of these modules, or may exist in a module on which this module does not depend.
2139         //Provide better diagnostic in such cases by looking for the class in any module:
2140         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2141 
2142         for (S sym : candidates) {
2143             if (validate.test(sym))
2144                 return createInvisibleSymbolError(env, sym);
2145         }
2146 
2147         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2148 
2149         recoverableModules.add(syms.unnamedModule);
2150         recoverableModules.remove(env.toplevel.modle);
2151 
2152         for (ModuleSymbol ms : recoverableModules) {
2153             //avoid overly eager completing classes from source-based modules, as those
2154             //may not be completable with the current compiler settings:
2155             if (ms.sourceLocation == null) {
2156                 if (ms.classLocation == null) {
2157                     ms = moduleFinder.findModule(ms);
2158                 }
2159 
2160                 if (ms.kind != ERR) {
2161                     S sym = load.apply(ms, name);
2162 
2163                     if (sym != null &amp;&amp; validate.test(sym)) {
2164                         return createInvisibleSymbolError(env, sym);
2165                     }
2166                 }
2167             }
2168         }
2169 
2170         return defaultResult;
2171     }
2172 
2173     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2174         if (symbolPackageVisible(env, sym)) {
2175             return new AccessError(env, null, sym);
2176         } else {
2177             return new InvisibleSymbolError(env, false, sym);
2178         }
2179     }
2180 
2181     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2182         ModuleSymbol envMod = env.toplevel.modle;
2183         PackageSymbol symPack = sym.packge();
2184         return envMod == symPack.modle ||
2185                envMod.visiblePackages.containsKey(symPack.fullname);
2186     }
2187 
2188     /**
2189      * Find a type declared in a scope (not inherited).  Return null
2190      * if none is found.
2191      *  @param env       The current environment.
2192      *  @param site      The original type from where the selection takes
2193      *                   place.
2194      *  @param name      The type&#39;s name.
2195      *  @param c         The class to search for the member type. This is
2196      *                   always a superclass or implemented interface of
2197      *                   site&#39;s class.
2198      */
2199     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2200                                    Type site,
2201                                    Name name,
2202                                    TypeSymbol c) {
2203         for (Symbol sym : c.members().getSymbolsByName(name)) {
2204             if (sym.kind == TYP) {
2205                 return isAccessible(env, site, sym)
2206                     ? sym
2207                     : new AccessError(env, site, sym);
2208             }
2209         }
2210         return typeNotFound;
2211     }
2212 
2213     /** Find a member type inherited from a superclass or interface.
2214      *  @param env       The current environment.
2215      *  @param site      The original type from where the selection takes
2216      *                   place.
2217      *  @param name      The type&#39;s name.
2218      *  @param c         The class to search for the member type. This is
2219      *                   always a superclass or implemented interface of
2220      *                   site&#39;s class.
2221      */
2222     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2223                                    Type site,
2224                                    Name name,
2225                                    TypeSymbol c) {
2226         Symbol bestSoFar = typeNotFound;
2227         Symbol sym;
2228         Type st = types.supertype(c.type);
2229         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2230             sym = findMemberType(env, site, name, st.tsym);
2231             bestSoFar = bestOf(bestSoFar, sym);
2232         }
2233         for (List&lt;Type&gt; l = types.interfaces(c.type);
2234              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2235              l = l.tail) {
2236             sym = findMemberType(env, site, name, l.head.tsym);
2237             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2238                 !sym.kind.isResolutionError() &amp;&amp;
2239                 sym.owner != bestSoFar.owner)
2240                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2241             else
2242                 bestSoFar = bestOf(bestSoFar, sym);
2243         }
2244         return bestSoFar;
2245     }
2246 
2247     /** Find qualified member type.
2248      *  @param env       The current environment.
2249      *  @param site      The original type from where the selection takes
2250      *                   place.
2251      *  @param name      The type&#39;s name.
2252      *  @param c         The class to search for the member type. This is
2253      *                   always a superclass or implemented interface of
2254      *                   site&#39;s class.
2255      */
2256     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2257                           Type site,
2258                           Name name,
2259                           TypeSymbol c) {
2260         return findMemberTypeInternal(env,site, name, c);
2261     }
2262 
2263     /** Find qualified member type.
2264      *  @param env       The current environment.
2265      *  @param site      The original type from where the selection takes
2266      *                   place.
2267      *  @param name      The type&#39;s name.
2268      *  @param c         The class to search for the member type. This is
2269      *                   always a superclass or implemented interface of
2270      *                   site&#39;s class.
2271      */
2272     Symbol findMemberTypeInternal(Env&lt;AttrContext&gt; env,
2273                           Type site,
2274                           Name name,
2275                           TypeSymbol c) {
2276         Symbol sym = findImmediateMemberType(env, site, name, c);
2277 
2278         if (sym != typeNotFound)
2279             return sym;
2280 
2281         return findInheritedMemberType(env, site, name, c);
2282 
2283     }
2284 
2285     /** Find a global type in given scope and load corresponding class.
2286      *  @param env       The current environment.
2287      *  @param scope     The scope in which to look for the type.
2288      *  @param name      The type&#39;s name.
2289      */
2290     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2291         Symbol bestSoFar = typeNotFound;
2292         for (Symbol s : scope.getSymbolsByName(name)) {
2293             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2294             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2295                 bestSoFar != sym)
2296                 return new AmbiguityError(bestSoFar, sym);
2297             else
2298                 bestSoFar = bestOf(bestSoFar, sym);
2299         }
2300         return bestSoFar;
2301     }
2302 
2303     Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
2304         for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
2305             if (sym.kind == TYP) {
2306                 if (staticOnly &amp;&amp;
2307                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2308                     sym.owner.kind == TYP)
2309                     return new StaticError(sym);
2310                 return sym;
2311             }
2312         }
2313         return typeNotFound;
2314     }
2315 
2316     /** Find an unqualified type symbol.
2317      *  @param env       The current environment.
2318      *  @param name      The type&#39;s name.
2319      */
2320     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2321         return findTypeInternal(env, name);
2322     }
2323 
2324     /** Find an unqualified type symbol.
2325      *  @param env       The current environment.
2326      *  @param name      The type&#39;s name.
2327      */
2328     Symbol findTypeInternal(Env&lt;AttrContext&gt; env, Name name) {
2329         if (name == names.empty)
2330             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2331         Symbol bestSoFar = typeNotFound;
2332         Symbol sym;
2333         boolean staticOnly = false;
2334         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2335             if (isStatic(env1)) staticOnly = true;
2336             // First, look for a type variable and the first member type
2337             final Symbol tyvar = findTypeVar(env1, name, staticOnly);
2338             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2339                                           name, env1.enclClass.sym);
2340 
2341             // Return the type variable if we have it, and have no
2342             // immediate member, OR the type variable is for a method.
2343             if (tyvar != typeNotFound) {
2344                 if (env.baseClause || sym == typeNotFound ||
2345                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2346                      tyvar.owner.kind == MTH)) {
2347                     return tyvar;
2348                 }
2349             }
2350 
2351             // If the environment is a class def, finish up,
2352             // otherwise, do the entire findMemberType
2353             if (sym == typeNotFound)
2354                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2355                                               name, env1.enclClass.sym);
2356 
2357             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2358                 sym.type.hasTag(CLASS) &amp;&amp;
2359                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2360                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2361                 sym.type.getEnclosingType().isParameterized())
2362                 return new StaticError(sym);
2363             else if (sym.exists()) return sym;
2364             else bestSoFar = bestOf(bestSoFar, sym);
2365 
2366             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2367             if ((encl.sym.flags() &amp; STATIC) != 0)
2368                 staticOnly = true;
2369         }
2370 
2371         if (!env.tree.hasTag(IMPORT)) {
2372             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2373             if (sym.exists()) return sym;
2374             else bestSoFar = bestOf(bestSoFar, sym);
2375 
2376             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2377             if (sym.exists()) return sym;
2378             else bestSoFar = bestOf(bestSoFar, sym);
2379 
2380             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2381             if (sym.exists()) return sym;
2382             else bestSoFar = bestOf(bestSoFar, sym);
2383 
2384             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2385             if (sym.exists()) return sym;
2386             else bestSoFar = bestOf(bestSoFar, sym);
2387         }
2388 
2389         return bestSoFar;
2390     }
2391 
2392     /** Find an unqualified identifier which matches a specified kind set.
2393      *  @param pos       position on which report warnings, if any;
2394      *                   null warnings should not be reported
2395      *  @param env       The current environment.
2396      *  @param name      The identifier&#39;s name.
2397      *  @param kind      Indicates the possible symbol kinds
2398      *                   (a subset of VAL, TYP, PCK).
2399      */
2400     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2401         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2402     }
2403 
2404     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2405         Symbol bestSoFar = typeNotFound;
2406         Symbol sym;
2407 
2408         if (kind.contains(KindSelector.VAL)) {
2409             sym = findVar(env, name);
2410             if (sym.exists()) return sym;
2411             else bestSoFar = bestOf(bestSoFar, sym);
2412         }
2413 
2414         if (kind.contains(KindSelector.TYP)) {
2415             sym = findType(env, name);
2416 
2417             if (sym.exists()) return sym;
2418             else bestSoFar = bestOf(bestSoFar, sym);
2419         }
2420 
2421         if (kind.contains(KindSelector.PCK))
2422             return lookupPackage(env, name);
2423         else return bestSoFar;
2424     }
2425 
2426     /** Find an identifier in a package which matches a specified kind set.
2427      *  @param pos       position on which report warnings, if any;
2428      *                   null warnings should not be reported
2429      *  @param env       The current environment.
2430      *  @param name      The identifier&#39;s name.
2431      *  @param kind      Indicates the possible symbol kinds
2432      *                   (a nonempty subset of TYP, PCK).
2433      */
2434     Symbol findIdentInPackage(DiagnosticPosition pos,
2435                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2436                               Name name, KindSelector kind) {
2437         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
2438     }
2439 
2440     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2441                               Name name, KindSelector kind) {
2442         Name fullname = TypeSymbol.formFullName(name, pck);
2443         Symbol bestSoFar = typeNotFound;
2444         if (kind.contains(KindSelector.TYP)) {
2445             RecoveryLoadClass recoveryLoadClass =
2446                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2447                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2448                         doRecoveryLoadClass : noRecovery;
2449             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2450             if (sym.exists()) {
2451                 // don&#39;t allow programs to use flatnames
2452                 if (name == sym.name) return sym;
2453             }
2454             else bestSoFar = bestOf(bestSoFar, sym);
2455         }
2456         if (kind.contains(KindSelector.PCK)) {
2457             return lookupPackage(env, fullname);
2458         }
2459         return bestSoFar;
2460     }
2461 
2462     /** Find an identifier among the members of a given type `site&#39;.
2463      *  @param pos       position on which report warnings, if any;
2464      *                   null warnings should not be reported
2465      *  @param env       The current environment.
2466      *  @param site      The type containing the symbol to be found.
2467      *  @param name      The identifier&#39;s name.
2468      *  @param kind      Indicates the possible symbol kinds
2469      *                   (a subset of VAL, TYP).
2470      */
2471     Symbol findIdentInType(DiagnosticPosition pos,
2472                            Env&lt;AttrContext&gt; env, Type site,
2473                            Name name, KindSelector kind) {
2474         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2475     }
2476 
2477     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2478                            Name name, KindSelector kind) {
2479         Symbol bestSoFar = typeNotFound;
2480         Symbol sym;
2481         if (kind.contains(KindSelector.VAL)) {
2482             sym = findField(env, site, name, site.tsym);
2483             if (sym.exists()) return sym;
2484             else bestSoFar = bestOf(bestSoFar, sym);
2485         }
2486 
2487         if (kind.contains(KindSelector.TYP)) {
2488             sym = findMemberType(env, site, name, site.tsym);
2489             if (sym.exists()) return sym;
2490             else bestSoFar = bestOf(bestSoFar, sym);
2491         }
2492         return bestSoFar;
2493     }
2494 
2495     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2496         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2497             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2498                 bestSoFar = new BadRestrictedTypeError(names.var);
2499             } else if (name.equals(names.yield)) {
2500                 if (allowYieldStatement) {
2501                     bestSoFar = new BadRestrictedTypeError(names.yield);
2502                 } else if (pos != null) {
2503                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2504                 }
2505             }
2506         }
2507         return bestSoFar;
2508     }
2509 
2510 /* ***************************************************************************
2511  *  Access checking
2512  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2513  *  an error message in the process
2514  ****************************************************************************/
2515 
2516     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2517      *  else pass through unchanged,
2518      *  additional arguments duplicate what has been used in trying to find the
2519      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2520      *  expect misses to happen frequently.
2521      *
2522      *  @param sym       The symbol that was found, or a ResolveError.
2523      *  @param pos       The position to use for error reporting.
2524      *  @param location  The symbol the served as a context for this lookup
2525      *  @param site      The original type from where the selection took place.
2526      *  @param name      The symbol&#39;s name.
2527      *  @param qualified Did we get here through a qualified expression resolution?
2528      *  @param argtypes  The invocation&#39;s value arguments,
2529      *                   if we looked for a method.
2530      *  @param typeargtypes  The invocation&#39;s type arguments,
2531      *                   if we looked for a method.
2532      *  @param logResolveHelper helper class used to log resolve errors
2533      */
2534     Symbol accessInternal(Symbol sym,
2535                   DiagnosticPosition pos,
2536                   Symbol location,
2537                   Type site,
2538                   Name name,
2539                   boolean qualified,
2540                   List&lt;Type&gt; argtypes,
2541                   List&lt;Type&gt; typeargtypes,
2542                   LogResolveHelper logResolveHelper) {
2543         if (sym.kind.isResolutionError()) {
2544             ResolveError errSym = (ResolveError)sym.baseSymbol();
2545             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2546             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2547             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2548                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2549             }
2550         }
2551         return sym;
2552     }
2553 
2554     /**
2555      * Variant of the generalized access routine, to be used for generating method
2556      * resolution diagnostics
2557      */
2558     Symbol accessMethod(Symbol sym,
2559                   DiagnosticPosition pos,
2560                   Symbol location,
2561                   Type site,
2562                   Name name,
2563                   boolean qualified,
2564                   List&lt;Type&gt; argtypes,
2565                   List&lt;Type&gt; typeargtypes) {
2566         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2567     }
2568 
2569     /** Same as original accessMethod(), but without location.
2570      */
2571     Symbol accessMethod(Symbol sym,
2572                   DiagnosticPosition pos,
2573                   Type site,
2574                   Name name,
2575                   boolean qualified,
2576                   List&lt;Type&gt; argtypes,
2577                   List&lt;Type&gt; typeargtypes) {
2578         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2579     }
2580 
2581     /**
2582      * Variant of the generalized access routine, to be used for generating variable,
2583      * type resolution diagnostics
2584      */
2585     Symbol accessBase(Symbol sym,
2586                   DiagnosticPosition pos,
2587                   Symbol location,
2588                   Type site,
2589                   Name name,
2590                   boolean qualified) {
2591         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2592     }
2593 
2594     /** Same as original accessBase(), but without location.
2595      */
2596     Symbol accessBase(Symbol sym,
2597                   DiagnosticPosition pos,
2598                   Type site,
2599                   Name name,
2600                   boolean qualified) {
2601         return accessBase(sym, pos, site.tsym, site, name, qualified);
2602     }
2603 
2604     interface LogResolveHelper {
2605         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2606         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2607     }
2608 
2609     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2610         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2611             return !site.isErroneous();
2612         }
2613         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2614             return argtypes;
2615         }
2616     };
2617 
2618     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2619         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2620             return !site.isErroneous() &amp;&amp;
2621                         !Type.isErroneous(argtypes) &amp;&amp;
2622                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2623         }
2624         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2625             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2626         }
2627     };
2628 
2629     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2630 
2631         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2632             deferredAttr.super(mode, msym, step);
2633         }
2634 
2635         @Override
2636         protected Type typeOf(DeferredType dt, Type pt) {
2637             Type res = super.typeOf(dt, pt);
2638             if (!res.isErroneous()) {
2639                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2640                     case LAMBDA:
2641                     case REFERENCE:
2642                         return dt;
2643                     case CONDEXPR:
2644                         return res == Type.recoveryType ?
2645                                 dt : res;
2646                 }
2647             }
2648             return res;
2649         }
2650     }
2651 
2652     /** Check that sym is not an abstract method.
2653      */
2654     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2655         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2656             log.error(pos,
2657                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2658     }
2659 
2660 /* ***************************************************************************
2661  *  Name resolution
2662  *  Naming conventions are as for symbol lookup
2663  *  Unlike the find... methods these methods will report access errors
2664  ****************************************************************************/
2665 
2666     /** Resolve an unqualified (non-method) identifier.
2667      *  @param pos       The position to use for error reporting.
2668      *  @param env       The environment current at the identifier use.
2669      *  @param name      The identifier&#39;s name.
2670      *  @param kind      The set of admissible symbol kinds for the identifier.
2671      */
2672     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2673                         Name name, KindSelector kind) {
2674         return accessBase(
2675             findIdent(pos, env, name, kind),
2676             pos, env.enclClass.sym.type, name, false);
2677     }
2678 
2679     /** Resolve an unqualified method identifier.
2680      *  @param pos       The position to use for error reporting.
2681      *  @param env       The environment current at the method invocation.
2682      *  @param name      The identifier&#39;s name.
2683      *  @param argtypes  The types of the invocation&#39;s value arguments.
2684      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2685      */
2686     Symbol resolveMethod(DiagnosticPosition pos,
2687                          Env&lt;AttrContext&gt; env,
2688                          Name name,
2689                          List&lt;Type&gt; argtypes,
2690                          List&lt;Type&gt; typeargtypes) {
2691         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2692                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2693                     @Override
2694                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2695                         return findFun(env, name, argtypes, typeargtypes,
2696                                 phase.isBoxingRequired(),
2697                                 phase.isVarargsRequired());
2698                     }});
2699     }
2700 
2701     /** Resolve a qualified method identifier
2702      *  @param pos       The position to use for error reporting.
2703      *  @param env       The environment current at the method invocation.
2704      *  @param site      The type of the qualifying expression, in which
2705      *                   identifier is searched.
2706      *  @param name      The identifier&#39;s name.
2707      *  @param argtypes  The types of the invocation&#39;s value arguments.
2708      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2709      */
2710     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2711                                   Type site, Name name, List&lt;Type&gt; argtypes,
2712                                   List&lt;Type&gt; typeargtypes) {
2713         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2714     }
2715     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2716                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2717                                   List&lt;Type&gt; typeargtypes) {
2718         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2719     }
2720     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2721                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2722                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2723                                   List&lt;Type&gt; typeargtypes) {
2724         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2725             @Override
2726             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2727                 return findMethod(env, site, name, argtypes, typeargtypes,
2728                         phase.isBoxingRequired(),
2729                         phase.isVarargsRequired());
2730             }
2731             @Override
2732             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2733                 if (sym.kind.isResolutionError()) {
2734                     sym = super.access(env, pos, location, sym);
2735                 } else {
2736                     MethodSymbol msym = (MethodSymbol)sym;
2737                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2738                         env.info.pendingResolutionPhase = BASIC;
2739                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2740                     }
2741                 }
2742                 return sym;
2743             }
2744         });
2745     }
2746 
2747     /** Find or create an implicit method of exactly the given type (after erasure).
2748      *  Searches in a side table, not the main scope of the site.
2749      *  This emulates the lookup process required by JSR 292 in JVM.
2750      *  @param env       Attribution environment
2751      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2752      *  @param argtypes  The required argument types
2753      */
2754     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2755                                             final Symbol spMethod,
2756                                             List&lt;Type&gt; argtypes) {
2757         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2758                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2759         return findPolymorphicSignatureInstance(spMethod, mtype);
2760     }
2761 
2762     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2763                                             Type mtype) {
2764         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2765             // Check that there is already a method symbol for the method
2766             // type and owner
2767             if (types.isSameType(mtype, sym.type) &amp;&amp;
2768                 spMethod.owner == sym.owner) {
2769                 return sym;
2770             }
2771         }
2772 
2773         // Create the desired method
2774         // Retain static modifier is to support invocations to
2775         // MethodHandle.linkTo* methods
2776         long flags = ABSTRACT | HYPOTHETICAL |
2777                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2778         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2779             @Override
2780             public Symbol baseSymbol() {
2781                 return spMethod;
2782             }
2783         };
2784         if (!mtype.isErroneous()) { // Cache only if kosher.
2785             polymorphicSignatureScope.enter(msym);
2786         }
2787         return msym;
2788     }
2789 
2790     /** Resolve a qualified method identifier, throw a fatal error if not
2791      *  found.
2792      *  @param pos       The position to use for error reporting.
2793      *  @param env       The environment current at the method invocation.
2794      *  @param site      The type of the qualifying expression, in which
2795      *                   identifier is searched.
2796      *  @param name      The identifier&#39;s name.
2797      *  @param argtypes  The types of the invocation&#39;s value arguments.
2798      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2799      */
2800     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2801                                         Type site, Name name,
2802                                         List&lt;Type&gt; argtypes,
2803                                         List&lt;Type&gt; typeargtypes) {
2804         MethodResolutionContext resolveContext = new MethodResolutionContext();
2805         resolveContext.internalResolution = true;
2806         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2807                 site, name, argtypes, typeargtypes);
2808         if (sym.kind == MTH) return (MethodSymbol)sym;
2809         else throw new FatalError(
2810                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2811     }
2812 
2813     /** Resolve constructor.
2814      *  @param pos       The position to use for error reporting.
2815      *  @param env       The environment current at the constructor invocation.
2816      *  @param site      The type of class for which a constructor is searched.
2817      *  @param argtypes  The types of the constructor invocation&#39;s value
2818      *                   arguments.
2819      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2820      *                   arguments.
2821      */
2822     Symbol resolveConstructor(DiagnosticPosition pos,
2823                               Env&lt;AttrContext&gt; env,
2824                               Type site,
2825                               List&lt;Type&gt; argtypes,
2826                               List&lt;Type&gt; typeargtypes) {
2827         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2828     }
2829 
2830     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2831                               final DiagnosticPosition pos,
2832                               Env&lt;AttrContext&gt; env,
2833                               Type site,
2834                               List&lt;Type&gt; argtypes,
2835                               List&lt;Type&gt; typeargtypes) {
2836         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2837             @Override
2838             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2839                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2840                         phase.isBoxingRequired(),
2841                         phase.isVarargsRequired());
2842             }
2843         });
2844     }
2845 
2846     /** Resolve a constructor, throw a fatal error if not found.
2847      *  @param pos       The position to use for error reporting.
2848      *  @param env       The environment current at the method invocation.
2849      *  @param site      The type to be constructed.
2850      *  @param argtypes  The types of the invocation&#39;s value arguments.
2851      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2852      */
2853     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2854                                         Type site,
2855                                         List&lt;Type&gt; argtypes,
2856                                         List&lt;Type&gt; typeargtypes) {
2857         MethodResolutionContext resolveContext = new MethodResolutionContext();
2858         resolveContext.internalResolution = true;
2859         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2860         if (sym.kind == MTH) return (MethodSymbol)sym;
2861         else throw new FatalError(
2862                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2863     }
2864 
2865     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2866                               Type site, List&lt;Type&gt; argtypes,
2867                               List&lt;Type&gt; typeargtypes,
2868                               boolean allowBoxing,
2869                               boolean useVarargs) {
2870         Symbol sym = findMethod(env, site,
2871                                     names.init, argtypes,
2872                                     typeargtypes, allowBoxing,
2873                                     useVarargs);
2874         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2875         chk.checkPreview(pos, sym);
2876         return sym;
2877     }
2878 
2879     /** Resolve constructor using diamond inference.
2880      *  @param pos       The position to use for error reporting.
2881      *  @param env       The environment current at the constructor invocation.
2882      *  @param site      The type of class for which a constructor is searched.
2883      *                   The scope of this class has been touched in attribution.
2884      *  @param argtypes  The types of the constructor invocation&#39;s value
2885      *                   arguments.
2886      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2887      *                   arguments.
2888      */
2889     Symbol resolveDiamond(DiagnosticPosition pos,
2890                               Env&lt;AttrContext&gt; env,
2891                               Type site,
2892                               List&lt;Type&gt; argtypes,
2893                               List&lt;Type&gt; typeargtypes) {
2894         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2895                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2896                     @Override
2897                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2898                         return findDiamond(env, site, argtypes, typeargtypes,
2899                                 phase.isBoxingRequired(),
2900                                 phase.isVarargsRequired());
2901                     }
2902                     @Override
2903                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2904                         if (sym.kind.isResolutionError()) {
2905                             if (sym.kind != WRONG_MTH &amp;&amp;
2906                                 sym.kind != WRONG_MTHS) {
2907                                 sym = super.access(env, pos, location, sym);
2908                             } else {
2909                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2910                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2911                                                 null;
2912                                 sym = new DiamondError(sym, currentResolutionContext);
2913                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2914                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2915                             }
2916                         }
2917                         return sym;
2918                     }});
2919     }
2920 
2921     /** This method scans all the constructor symbol in a given class scope -
2922      *  assuming that the original scope contains a constructor of the kind:
2923      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2924      *  a method check is executed against the modified constructor type:
2925      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2926      *  inference. The inferred return type of the synthetic constructor IS
2927      *  the inferred type for the diamond operator.
2928      */
2929     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2930                               Type site,
2931                               List&lt;Type&gt; argtypes,
2932                               List&lt;Type&gt; typeargtypes,
2933                               boolean allowBoxing,
2934                               boolean useVarargs) {
2935         Symbol bestSoFar = methodNotFound;
2936         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2937         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2938             //- System.out.println(&quot; e &quot; + e.sym);
2939             if (sym.kind == MTH &amp;&amp;
2940                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2941                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2942                             ((ForAll)sym.type).tvars :
2943                             List.nil();
2944                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2945                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2946                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2947                         @Override
2948                         public Symbol baseSymbol() {
2949                             return sym;
2950                         }
2951                     };
<a name="1" id="anc1"></a><span class="line-added">2952                     ClassSymbol refProjection = newConstr.owner.isValue() ?</span>
<span class="line-added">2953                                                      (ClassSymbol) newConstr.owner.referenceProjection() : null;</span>
<span class="line-added">2954                     if (refProjection != null) {</span>
<span class="line-added">2955                         MethodSymbol clone = newConstr.clone(refProjection);</span>
<span class="line-added">2956                         clone.projection = newConstr;</span>
<span class="line-added">2957                         newConstr.projection = clone;</span>
<span class="line-added">2958                     }</span>
2959                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2960                             newConstr,
2961                             bestSoFar,
2962                             allowBoxing,
2963                             useVarargs);
2964             }
2965         }
2966         return bestSoFar;
2967     }
2968 
2969     Symbol getMemberReference(DiagnosticPosition pos,
2970             Env&lt;AttrContext&gt; env,
2971             JCMemberReference referenceTree,
2972             Type site,
2973             Name name) {
2974 
2975         site = types.capture(site);
2976 
2977         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2978                 referenceTree, site, name, List.nil(), null, VARARITY);
2979 
2980         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2981         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2982                 nilMethodCheck, lookupHelper);
2983 
2984         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2985 
2986         return sym;
2987     }
2988 
2989     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2990                                   Type site,
2991                                   Name name,
2992                                   List&lt;Type&gt; argtypes,
2993                                   List&lt;Type&gt; typeargtypes,
2994                                   MethodResolutionPhase maxPhase) {
2995         if (!name.equals(names.init)) {
2996             //method reference
2997             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2998         } else if (site.hasTag(ARRAY)) {
2999             //array constructor reference
3000             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
3001         } else {
3002             //class constructor reference
3003             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
3004         }
3005     }
3006 
3007     /**
3008      * Resolution of member references is typically done as a single
3009      * overload resolution step, where the argument types A are inferred from
3010      * the target functional descriptor.
3011      *
3012      * If the member reference is a method reference with a type qualifier,
3013      * a two-step lookup process is performed. The first step uses the
3014      * expected argument list A, while the second step discards the first
3015      * type from A (which is treated as a receiver type).
3016      *
3017      * There are two cases in which inference is performed: (i) if the member
3018      * reference is a constructor reference and the qualifier type is raw - in
3019      * which case diamond inference is used to infer a parameterization for the
3020      * type qualifier; (ii) if the member reference is an unbound reference
3021      * where the type qualifier is raw - in that case, during the unbound lookup
3022      * the receiver argument type is used to infer an instantiation for the raw
3023      * qualifier type.
3024      *
3025      * When a multi-step resolution process is exploited, the process of picking
3026      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
3027      *
3028      * This routine returns a pair (T,S), where S is the member reference symbol,
3029      * and T is the type of the class in which S is defined. This is necessary as
3030      * the type T might be dynamically inferred (i.e. if constructor reference
3031      * has a raw qualifier).
3032      */
3033     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3034                                   JCMemberReference referenceTree,
3035                                   Type site,
3036                                   Name name,
3037                                   List&lt;Type&gt; argtypes,
3038                                   List&lt;Type&gt; typeargtypes,
3039                                   Type descriptor,
3040                                   MethodCheck methodCheck,
3041                                   InferenceContext inferenceContext,
3042                                   ReferenceChooser referenceChooser) {
3043 
3044         //step 1 - bound lookup
3045         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3046                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3047         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3048         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3049         boundSearchResolveContext.methodCheck = methodCheck;
3050         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3051                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3052         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3053 
3054         //step 2 - unbound lookup
3055         Symbol unboundSym = methodNotFound;
3056         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3057         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3058         ReferenceLookupResult unboundRes = referenceNotFound;
3059         if (unboundLookupHelper != null) {
3060             MethodResolutionContext unboundSearchResolveContext =
3061                     new MethodResolutionContext();
3062             unboundSearchResolveContext.methodCheck = methodCheck;
3063             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3064                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3065             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3066         }
3067 
3068         //merge results
3069         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3070         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3071         res = new Pair&lt;&gt;(bestRes.sym,
3072                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3073         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3074                 unboundEnv.info.pendingResolutionPhase :
3075                 boundEnv.info.pendingResolutionPhase;
3076 
3077         if (!res.fst.kind.isResolutionError()) {
3078             //handle sigpoly method references
3079             MethodSymbol msym = (MethodSymbol)res.fst;
3080             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3081                 env.info.pendingResolutionPhase = BASIC;
3082                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3083             }
3084         }
3085 
3086         return res;
3087     }
3088 
3089     /**
3090      * This class is used to represent a method reference lookup result. It keeps track of two
3091      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3092      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3093      */
3094     static class ReferenceLookupResult {
3095 
3096         /**
3097          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3098          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3099          * depending on whether all applicable candidates are static or non-static methods,
3100          * respectively. If a successful lookup has both static and non-static applicable methods,
3101          * its kind is set to BOTH.
3102          */
3103         enum StaticKind {
3104             STATIC,
3105             NON_STATIC,
3106             BOTH,
3107             UNDEFINED;
3108 
3109             /**
3110              * Retrieve the static kind associated with a given (method) symbol.
3111              */
3112             static StaticKind from(Symbol s) {
3113                 return s.isStatic() ?
3114                         STATIC : NON_STATIC;
3115             }
3116 
3117             /**
3118              * Merge two static kinds together.
3119              */
3120             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3121                 if (sk1 == UNDEFINED) {
3122                     return sk2;
3123                 } else if (sk2 == UNDEFINED) {
3124                     return sk1;
3125                 } else {
3126                     return sk1 == sk2 ? sk1 : BOTH;
3127                 }
3128             }
3129         }
3130 
3131         /** The static kind. */
3132         StaticKind staticKind;
3133 
3134         /** The lookup result. */
3135         Symbol sym;
3136 
3137         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3138             this(sym, staticKind(sym, resolutionContext));
3139         }
3140 
3141         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3142             this.staticKind = staticKind;
3143             this.sym = sym;
3144         }
3145 
3146         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3147             switch (sym.kind) {
3148                 case MTH:
3149                 case AMBIGUOUS:
3150                     return resolutionContext.candidates.stream()
3151                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3152                             .map(c -&gt; StaticKind.from(c.sym))
3153                             .reduce(StaticKind::reduce)
3154                             .orElse(StaticKind.UNDEFINED);
3155                 default:
3156                     return StaticKind.UNDEFINED;
3157             }
3158         }
3159 
3160         /**
3161          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3162          */
3163         boolean isSuccess() {
3164             return staticKind != StaticKind.UNDEFINED;
3165         }
3166 
3167         /**
3168          * Does this result have given static kind?
3169          */
3170         boolean hasKind(StaticKind sk) {
3171             return this.staticKind == sk;
3172         }
3173 
3174         /**
3175          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3176          * some &#39;better&#39; result) ?
3177          */
3178         boolean canIgnore() {
3179             switch (sym.kind) {
3180                 case ABSENT_MTH:
3181                     return true;
3182                 case WRONG_MTH:
3183                     InapplicableSymbolError errSym =
3184                             (InapplicableSymbolError)sym.baseSymbol();
3185                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3186                             .matches(errSym.errCandidate().snd);
3187                 case WRONG_MTHS:
3188                     InapplicableSymbolsError errSyms =
3189                             (InapplicableSymbolsError)sym.baseSymbol();
3190                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3191                 default:
3192                     return false;
3193             }
3194         }
3195 
3196         static ReferenceLookupResult error(Symbol sym) {
3197             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3198         }
3199     }
3200 
3201     /**
3202      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3203      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3204      * result of method reference resolution.
3205      */
3206     abstract class ReferenceChooser {
3207         /**
3208          * Generate a result from a pair of lookup result objects. This method delegates to the
3209          * appropriate result generation routine.
3210          */
3211         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3212             return unboundRes != referenceNotFound ?
3213                     unboundResult(boundRes, unboundRes) :
3214                     boundResult(boundRes);
3215         }
3216 
3217         /**
3218          * Generate a symbol from a given bound lookup result.
3219          */
3220         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3221 
3222         /**
3223          * Generate a symbol from a pair of bound/unbound lookup results.
3224          */
3225         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3226     }
3227 
3228     /**
3229      * This chooser implements the selection strategy used during a full lookup; this logic
3230      * is described in JLS SE 8 (15.3.2).
3231      */
3232     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3233 
3234         @Override
3235         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3236             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3237                     boundRes : //the search produces a non-static method
3238                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3239         }
3240 
3241         @Override
3242         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3243             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3244                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3245                 //the first search produces a static method and no non-static method is applicable
3246                 //during the second search
3247                 return boundRes;
3248             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3249                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3250                 //the second search produces a non-static method and no static method is applicable
3251                 //during the first search
3252                 return unboundRes;
3253             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3254                 //both searches produce some result; ambiguity (error recovery)
3255                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3256             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3257                 //Both searches failed to produce a result with correct staticness (i.e. first search
3258                 //produces an non-static method). Alternatively, a given search produced a result
3259                 //with the right staticness, but the other search has applicable methods with wrong
3260                 //staticness (error recovery)
3261                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3262                         boundRes.sym : unboundRes.sym, true));
3263             } else {
3264                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3265                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3266                         unboundRes : boundRes;
3267             }
3268         }
3269     };
3270 
3271     /**
3272      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3273      * is described in JLS SE 8 (15.12.2.1).
3274      */
3275     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3276 
3277         @Override
3278         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3279             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3280                     boundRes : //the search has at least one applicable non-static method
3281                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3282         }
3283 
3284         @Override
3285         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3286             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3287                 //the first search has at least one applicable static method
3288                 return boundRes;
3289             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3290                 //the second search has at least one applicable non-static method
3291                 return unboundRes;
3292             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3293                 //either the first search produces a non-static method, or second search produces
3294                 //a non-static method (error recovery)
3295                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3296                         boundRes.sym : unboundRes.sym, true));
3297             } else {
3298                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3299                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3300                         unboundRes : boundRes;
3301             }
3302         }
3303     };
3304 
3305     /**
3306      * Helper for defining custom method-like lookup logic; a lookup helper
3307      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3308      * lookup result (this step might result in compiler diagnostics to be generated)
3309      */
3310     abstract class LookupHelper {
3311 
3312         /** name of the symbol to lookup */
3313         Name name;
3314 
3315         /** location in which the lookup takes place */
3316         Type site;
3317 
3318         /** actual types used during the lookup */
3319         List&lt;Type&gt; argtypes;
3320 
3321         /** type arguments used during the lookup */
3322         List&lt;Type&gt; typeargtypes;
3323 
3324         /** Max overload resolution phase handled by this helper */
3325         MethodResolutionPhase maxPhase;
3326 
3327         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3328             this.name = name;
3329             this.site = site;
3330             this.argtypes = argtypes;
3331             this.typeargtypes = typeargtypes;
3332             this.maxPhase = maxPhase;
3333         }
3334 
3335         /**
3336          * Should lookup stop at given phase with given result
3337          */
3338         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3339             return phase.ordinal() &gt; maxPhase.ordinal() ||
3340                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3341         }
3342 
3343         /**
3344          * Search for a symbol under a given overload resolution phase - this method
3345          * is usually called several times, once per each overload resolution phase
3346          */
3347         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3348 
3349         /**
3350          * Dump overload resolution info
3351          */
3352         void debug(DiagnosticPosition pos, Symbol sym) {
3353             //do nothing
3354         }
3355 
3356         /**
3357          * Validate the result of the lookup
3358          */
3359         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3360     }
3361 
3362     abstract class BasicLookupHelper extends LookupHelper {
3363 
3364         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3365             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3366         }
3367 
3368         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3369             super(name, site, argtypes, typeargtypes, maxPhase);
3370         }
3371 
3372         @Override
3373         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3374             Symbol sym = doLookup(env, phase);
3375             if (sym.kind == AMBIGUOUS) {
3376                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3377                 sym = a_err.mergeAbstracts(site);
3378             }
3379             return sym;
3380         }
3381 
3382         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3383 
3384         @Override
3385         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3386             if (sym.kind.isResolutionError()) {
3387                 //if nothing is found return the &#39;first&#39; error
3388                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3389             }
3390             return sym;
3391         }
3392 
3393         @Override
3394         void debug(DiagnosticPosition pos, Symbol sym) {
3395             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3396         }
3397     }
3398 
3399     /**
3400      * Helper class for member reference lookup. A reference lookup helper
3401      * defines the basic logic for member reference lookup; a method gives
3402      * access to an &#39;unbound&#39; helper used to perform an unbound member
3403      * reference lookup.
3404      */
3405     abstract class ReferenceLookupHelper extends LookupHelper {
3406 
3407         /** The member reference tree */
3408         JCMemberReference referenceTree;
3409 
3410         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3411                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3412             super(name, site, argtypes, typeargtypes, maxPhase);
3413             this.referenceTree = referenceTree;
3414         }
3415 
3416         /**
3417          * Returns an unbound version of this lookup helper. By default, this
3418          * method returns an dummy lookup helper.
3419          */
3420         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3421             return null;
3422         }
3423 
3424         /**
3425          * Get the kind of the member reference
3426          */
3427         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3428 
3429         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3430             if (sym.kind == AMBIGUOUS) {
3431                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3432                 sym = a_err.mergeAbstracts(site);
3433             }
3434             //skip error reporting
3435             return sym;
3436         }
3437     }
3438 
3439     /**
3440      * Helper class for method reference lookup. The lookup logic is based
3441      * upon Resolve.findMethod; in certain cases, this helper class has a
3442      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3443      * In such cases, non-static lookup results are thrown away.
3444      */
3445     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3446 
3447         /** The original method reference lookup site. */
3448         Type originalSite;
3449 
3450         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3451                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3452             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3453             this.originalSite = site;
3454         }
3455 
3456         @Override
3457         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3458             return findMethod(env, site, name, argtypes, typeargtypes,
3459                     phase.isBoxingRequired(), phase.isVarargsRequired());
3460         }
3461 
3462         @Override
3463         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3464             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3465                 if (argtypes.nonEmpty() &amp;&amp;
3466                         (argtypes.head.hasTag(NONE) ||
3467                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3468                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3469                             originalSite, argtypes, typeargtypes, maxPhase);
3470                 } else {
3471                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3472                         @Override
3473                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3474                             return this;
3475                         }
3476 
3477                         @Override
3478                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3479                             return methodNotFound;
3480                         }
3481 
3482                         @Override
3483                         ReferenceKind referenceKind(Symbol sym) {
3484                             Assert.error();
3485                             return null;
3486                         }
3487                     };
3488                 }
3489             } else {
3490                 return super.unboundLookup(inferenceContext);
3491             }
3492         }
3493 
3494         @Override
3495         ReferenceKind referenceKind(Symbol sym) {
3496             if (sym.isStatic()) {
3497                 return ReferenceKind.STATIC;
3498             } else {
3499                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3500                 return selName != null &amp;&amp; selName == names._super ?
3501                         ReferenceKind.SUPER :
3502                         ReferenceKind.BOUND;
3503             }
3504         }
3505     }
3506 
3507     /**
3508      * Helper class for unbound method reference lookup. Essentially the same
3509      * as the basic method reference lookup helper; main difference is that static
3510      * lookup results are thrown away. If qualifier type is raw, an attempt to
3511      * infer a parameterized type is made using the first actual argument (that
3512      * would otherwise be ignored during the lookup).
3513      */
3514     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3515 
3516         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3517                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3518             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3519             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3520                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3521                 this.site = types.skipTypeVars(asSuperSite, true);
3522             }
3523         }
3524 
3525         @Override
3526         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3527             return this;
3528         }
3529 
3530         @Override
3531         ReferenceKind referenceKind(Symbol sym) {
3532             return ReferenceKind.UNBOUND;
3533         }
3534     }
3535 
3536     /**
3537      * Helper class for array constructor lookup; an array constructor lookup
3538      * is simulated by looking up a method that returns the array type specified
3539      * as qualifier, and that accepts a single int parameter (size of the array).
3540      */
3541     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3542 
3543         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3544                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3545             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3546         }
3547 
3548         @Override
3549         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3550             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3551             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3552             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3553             sc.enter(arrayConstr);
3554             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3555         }
3556 
3557         @Override
3558         ReferenceKind referenceKind(Symbol sym) {
3559             return ReferenceKind.ARRAY_CTOR;
3560         }
3561     }
3562 
3563     /**
3564      * Helper class for constructor reference lookup. The lookup logic is based
3565      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3566      * whether the constructor reference needs diamond inference (this is the case
3567      * if the qualifier type is raw). A special erroneous symbol is returned
3568      * if the lookup returns the constructor of an inner class and there&#39;s no
3569      * enclosing instance in scope.
3570      */
3571     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3572 
3573         boolean needsInference;
3574 
3575         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3576                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3577             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3578             if (site.isRaw()) {
3579                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3580                 needsInference = true;
3581             }
3582         }
3583 
3584         @Override
3585         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3586             Symbol sym = needsInference ?
3587                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3588                 findMethod(env, site, name, argtypes, typeargtypes,
3589                         phase.isBoxingRequired(), phase.isVarargsRequired());
3590             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3591         }
3592 
3593         @Override
3594         ReferenceKind referenceKind(Symbol sym) {
3595             return site.getEnclosingType().hasTag(NONE) ?
3596                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3597         }
3598     }
3599 
3600     /**
3601      * Main overload resolution routine. On each overload resolution step, a
3602      * lookup helper class is used to perform the method/constructor lookup;
3603      * at the end of the lookup, the helper is used to validate the results
3604      * (this last step might trigger overload resolution diagnostics).
3605      */
3606     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3607         MethodResolutionContext resolveContext = new MethodResolutionContext();
3608         resolveContext.methodCheck = methodCheck;
3609         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3610     }
3611 
3612     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3613             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3614         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3615         try {
3616             Symbol bestSoFar = methodNotFound;
3617             currentResolutionContext = resolveContext;
3618             for (MethodResolutionPhase phase : methodResolutionSteps) {
3619                 if (lookupHelper.shouldStop(bestSoFar, phase))
3620                     break;
3621                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3622                 Symbol prevBest = bestSoFar;
3623                 currentResolutionContext.step = phase;
3624                 Symbol sym = lookupHelper.lookup(env, phase);
3625                 lookupHelper.debug(pos, sym);
3626                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3627                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3628             }
3629             return lookupHelper.access(env, pos, location, bestSoFar);
3630         } finally {
3631             currentResolutionContext = prevResolutionContext;
3632         }
3633     }
3634 
3635     /**
3636      * Resolve `c.name&#39; where name == this or name == super.
3637      * @param pos           The position to use for error reporting.
3638      * @param env           The environment current at the expression.
3639      * @param c             The qualifier.
3640      * @param name          The identifier&#39;s name.
3641      */
3642     Symbol resolveSelf(DiagnosticPosition pos,
3643                        Env&lt;AttrContext&gt; env,
3644                        TypeSymbol c,
3645                        Name name) {
3646         Env&lt;AttrContext&gt; env1 = env;
3647         boolean staticOnly = false;
3648         while (env1.outer != null) {
3649             if (isStatic(env1)) staticOnly = true;
3650             if (env1.enclClass.sym == c) {
3651                 Symbol sym = env1.info.scope.findFirst(name);
3652                 if (sym != null) {
3653                     if (staticOnly) sym = new StaticError(sym);
3654                     return accessBase(sym, pos, env.enclClass.sym.type,
3655                                   name, true);
3656                 }
3657             }
3658             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3659             env1 = env1.outer;
3660         }
3661         if (c.isInterface() &amp;&amp;
3662             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3663             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3664             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3665             for (Type t : pruneInterfaces(env.enclClass.type)) {
3666                 if (t.tsym == c) {
3667                     env.info.defaultSuperCallSite = t;
3668                     return new VarSymbol(0, names._super,
3669                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3670                 }
3671             }
3672             //find a direct super type that is a subtype of &#39;c&#39;
3673             for (Type i : types.directSupertypes(env.enclClass.type)) {
3674                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3675                     log.error(pos,
3676                               Errors.IllegalDefaultSuperCall(c,
3677                                                              Fragments.RedundantSupertype(c, i)));
3678                     return syms.errSymbol;
3679                 }
3680             }
3681             Assert.error();
3682         }
3683         log.error(pos, Errors.NotEnclClass(c));
3684         return syms.errSymbol;
3685     }
3686     //where
3687     private List&lt;Type&gt; pruneInterfaces(Type t) {
3688         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3689         for (Type t1 : types.interfaces(t)) {
3690             boolean shouldAdd = true;
3691             for (Type t2 : types.directSupertypes(t)) {
3692                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3693                     shouldAdd = false;
3694                 }
3695             }
3696             if (shouldAdd) {
3697                 result.append(t1);
3698             }
3699         }
3700         return result.toList();
3701     }
3702 
3703 
3704     /**
3705      * Resolve `c.this&#39; for an enclosing class c that contains the
3706      * named member.
3707      * @param pos           The position to use for error reporting.
3708      * @param env           The environment current at the expression.
3709      * @param member        The member that must be contained in the result.
3710      */
3711     Symbol resolveSelfContaining(DiagnosticPosition pos,
3712                                  Env&lt;AttrContext&gt; env,
3713                                  Symbol member,
3714                                  boolean isSuperCall) {
3715         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3716         if (sym == null) {
3717             log.error(pos, Errors.EnclClassRequired(member));
3718             return syms.errSymbol;
3719         } else {
3720             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3721         }
3722     }
3723 
3724     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3725         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3726             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3727             return encl == null || encl.kind.isResolutionError();
3728         }
3729         return false;
3730     }
3731 
3732     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3733                                  Symbol member,
3734                                  boolean isSuperCall) {
3735         Name name = names._this;
3736         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3737         boolean staticOnly = false;
3738         if (env1 != null) {
3739             while (env1 != null &amp;&amp; env1.outer != null) {
3740                 if (isStatic(env1)) staticOnly = true;
3741                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3742                     Symbol sym = env1.info.scope.findFirst(name);
3743                     if (sym != null) {
3744                         if (staticOnly) sym = new StaticError(sym);
3745                         return sym;
3746                     }
3747                 }
3748                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3749                     staticOnly = true;
3750                 env1 = env1.outer;
3751             }
3752         }
3753         return null;
3754     }
3755 
3756     /**
3757      * Resolve an appropriate implicit this instance for t&#39;s container.
3758      * JLS 8.8.5.1 and 15.9.2
3759      */
3760     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3761         return resolveImplicitThis(pos, env, t, false);
3762     }
3763 
3764     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3765         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3766                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3767                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3768         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3769             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3770         }
3771         return thisType;
3772     }
3773 
3774 /* ***************************************************************************
3775  *  ResolveError classes, indicating error situations when accessing symbols
3776  ****************************************************************************/
3777 
3778     //used by TransTypes when checking target type of synthetic cast
3779     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3780         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3781         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3782     }
3783     //where
3784     private void logResolveError(ResolveError error,
3785             DiagnosticPosition pos,
3786             Symbol location,
3787             Type site,
3788             Name name,
3789             List&lt;Type&gt; argtypes,
3790             List&lt;Type&gt; typeargtypes) {
3791         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3792                 pos, location, site, name, argtypes, typeargtypes);
3793         if (d != null) {
3794             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3795             log.report(d);
3796         }
3797     }
3798 
3799     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3800 
3801     public Object methodArguments(List&lt;Type&gt; argtypes) {
3802         if (argtypes == null || argtypes.isEmpty()) {
3803             return noArgs;
3804         } else {
3805             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3806             for (Type t : argtypes) {
3807                 if (t.hasTag(DEFERRED)) {
3808                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3809                 } else {
3810                     diagArgs.append(t);
3811                 }
3812             }
3813             return diagArgs;
3814         }
3815     }
3816 
3817     /**
3818      * Root class for resolution errors. Subclass of ResolveError
3819      * represent a different kinds of resolution error - as such they must
3820      * specify how they map into concrete compiler diagnostics.
3821      */
3822     abstract class ResolveError extends Symbol {
3823 
3824         /** The name of the kind of error, for debugging only. */
3825         final String debugName;
3826 
3827         ResolveError(Kind kind, String debugName) {
3828             super(kind, 0, null, null, null);
3829             this.debugName = debugName;
3830         }
3831 
3832         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3833         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3834             throw new AssertionError();
3835         }
3836 
3837         @Override
3838         public String toString() {
3839             return debugName;
3840         }
3841 
3842         @Override
3843         public boolean exists() {
3844             return false;
3845         }
3846 
3847         @Override
3848         public boolean isStatic() {
3849             return false;
3850         }
3851 
3852         /**
3853          * Create an external representation for this erroneous symbol to be
3854          * used during attribution - by default this returns the symbol of a
3855          * brand new error type which stores the original type found
3856          * during resolution.
3857          *
3858          * @param name     the name used during resolution
3859          * @param location the location from which the symbol is accessed
3860          */
3861         protected Symbol access(Name name, TypeSymbol location) {
3862             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3863         }
3864 
3865         /**
3866          * Create a diagnostic representing this resolution error.
3867          *
3868          * @param dkind     The kind of the diagnostic to be created (e.g error).
3869          * @param pos       The position to be used for error reporting.
3870          * @param site      The original type from where the selection took place.
3871          * @param name      The name of the symbol to be resolved.
3872          * @param argtypes  The invocation&#39;s value arguments,
3873          *                  if we looked for a method.
3874          * @param typeargtypes  The invocation&#39;s type arguments,
3875          *                      if we looked for a method.
3876          */
3877         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3878                 DiagnosticPosition pos,
3879                 Symbol location,
3880                 Type site,
3881                 Name name,
3882                 List&lt;Type&gt; argtypes,
3883                 List&lt;Type&gt; typeargtypes);
3884     }
3885 
3886     /**
3887      * This class is the root class of all resolution errors caused by
3888      * an invalid symbol being found during resolution.
3889      */
3890     abstract class InvalidSymbolError extends ResolveError {
3891 
3892         /** The invalid symbol found during resolution */
3893         Symbol sym;
3894 
3895         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3896             super(kind, debugName);
3897             this.sym = sym;
3898         }
3899 
3900         @Override
3901         public boolean exists() {
3902             return true;
3903         }
3904 
3905         @Override
3906         public String toString() {
3907              return super.toString() + &quot; wrongSym=&quot; + sym;
3908         }
3909 
3910         @Override
3911         public Symbol access(Name name, TypeSymbol location) {
3912             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3913                 return types.createErrorType(name, location, sym.type).tsym;
3914             else
3915                 return sym;
3916         }
3917     }
3918 
3919     class BadRestrictedTypeError extends ResolveError {
3920         private final Name typeName;
3921         BadRestrictedTypeError(Name typeName) {
3922             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3923             this.typeName = typeName;
3924         }
3925 
3926         @Override
3927         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3928             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3929         }
3930     }
3931 
3932     /**
3933      * InvalidSymbolError error class indicating that a symbol matching a
3934      * given name does not exists in a given site.
3935      */
3936     class SymbolNotFoundError extends ResolveError {
3937 
3938         SymbolNotFoundError(Kind kind) {
3939             this(kind, &quot;symbol not found error&quot;);
3940         }
3941 
3942         SymbolNotFoundError(Kind kind, String debugName) {
3943             super(kind, debugName);
3944         }
3945 
3946         @Override
3947         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3948                 DiagnosticPosition pos,
3949                 Symbol location,
3950                 Type site,
3951                 Name name,
3952                 List&lt;Type&gt; argtypes,
3953                 List&lt;Type&gt; typeargtypes) {
3954             argtypes = argtypes == null ? List.nil() : argtypes;
3955             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3956             if (name == names.error)
3957                 return null;
3958 
3959             boolean hasLocation = false;
3960             if (location == null) {
3961                 location = site.tsym;
3962             }
3963             if (!location.name.isEmpty()) {
3964                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3965                     return diags.create(dkind, log.currentSource(), pos,
3966                         &quot;doesnt.exist&quot;, location);
3967                 }
3968                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3969                         !location.name.equals(names._super);
3970             }
3971             boolean isConstructor = name == names.init;
3972             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3973             Name idname = isConstructor ? site.tsym.name : name;
3974             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3975             if (hasLocation) {
3976                 return diags.create(dkind, log.currentSource(), pos,
3977                         errKey, kindname, idname, //symbol kindname, name
3978                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3979                         getLocationDiag(location, site)); //location kindname, type
3980             }
3981             else {
3982                 return diags.create(dkind, log.currentSource(), pos,
3983                         errKey, kindname, idname, //symbol kindname, name
3984                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3985             }
3986         }
3987         //where
3988         private Object args(List&lt;Type&gt; args) {
3989             return args.isEmpty() ? args : methodArguments(args);
3990         }
3991 
3992         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3993             String key = &quot;cant.resolve&quot;;
3994             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3995             switch (kindname) {
3996                 case METHOD:
3997                 case CONSTRUCTOR: {
3998                     suffix += &quot;.args&quot;;
3999                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
4000                 }
4001             }
4002             return key + suffix;
4003         }
4004         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
4005             if (location.kind == VAR) {
4006                 return diags.fragment(Fragments.Location1(kindName(location),
4007                                                           location,
4008                                                           location.type));
4009             } else {
4010                 return diags.fragment(Fragments.Location(typeKindName(site),
4011                                       site,
4012                                       null));
4013             }
4014         }
4015     }
4016 
4017     /**
4018      * InvalidSymbolError error class indicating that a given symbol
4019      * (either a method, a constructor or an operand) is not applicable
4020      * given an actual arguments/type argument list.
4021      */
4022     class InapplicableSymbolError extends ResolveError {
4023 
4024         protected MethodResolutionContext resolveContext;
4025 
4026         InapplicableSymbolError(MethodResolutionContext context) {
4027             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
4028         }
4029 
4030         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
4031             super(kind, debugName);
4032             this.resolveContext = context;
4033         }
4034 
4035         @Override
4036         public String toString() {
4037             return super.toString();
4038         }
4039 
4040         @Override
4041         public boolean exists() {
4042             return true;
4043         }
4044 
4045         @Override
4046         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4047                 DiagnosticPosition pos,
4048                 Symbol location,
4049                 Type site,
4050                 Name name,
4051                 List&lt;Type&gt; argtypes,
4052                 List&lt;Type&gt; typeargtypes) {
4053             if (name == names.error)
4054                 return null;
4055 
4056             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4057             if (compactMethodDiags) {
4058                 JCDiagnostic simpleDiag =
4059                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4060                 if (simpleDiag != null) {
4061                     return simpleDiag;
4062                 }
4063             }
4064             Symbol ws = c.fst.asMemberOf(site, types);
4065             return diags.create(dkind, log.currentSource(), pos,
4066                       &quot;cant.apply.symbol&quot;,
4067                       kindName(ws),
4068                       ws.name == names.init ? ws.owner.name : ws.name,
4069                       methodArguments(ws.type.getParameterTypes()),
4070                       methodArguments(argtypes),
4071                       kindName(ws.owner),
4072                       ws.owner.type,
4073                       c.snd);
4074         }
4075 
4076         @Override
4077         public Symbol access(Name name, TypeSymbol location) {
4078             Symbol sym = bestCandidate();
4079             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4080         }
4081 
4082         protected Symbol bestCandidate() {
4083             return errCandidate().fst;
4084         }
4085 
4086         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4087             Candidate bestSoFar = null;
4088             for (Candidate c : resolveContext.candidates) {
4089                 if (c.isApplicable()) continue;
4090                 bestSoFar = c;
4091             }
4092             Assert.checkNonNull(bestSoFar);
4093             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4094         }
4095     }
4096 
4097     /**
4098      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4099      * is not applicable given an actual arguments/type argument list.
4100      */
4101     class InapplicableSymbolsError extends InapplicableSymbolError {
4102 
4103         InapplicableSymbolsError(MethodResolutionContext context) {
4104             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4105         }
4106 
4107         @Override
4108         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4109                 DiagnosticPosition pos,
4110                 Symbol location,
4111                 Type site,
4112                 Name name,
4113                 List&lt;Type&gt; argtypes,
4114                 List&lt;Type&gt; typeargtypes) {
4115             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4116             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4117                     filterCandidates(candidatesMap) :
4118                     mapCandidates();
4119             if (filteredCandidates.isEmpty()) {
4120                 filteredCandidates = candidatesMap;
4121             }
4122             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4123             if (filteredCandidates.size() &gt; 1) {
4124                 JCDiagnostic err = diags.create(dkind,
4125                         null,
4126                         truncatedDiag ?
4127                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4128                             EnumSet.noneOf(DiagnosticFlag.class),
4129                         log.currentSource(),
4130                         pos,
4131                         &quot;cant.apply.symbols&quot;,
4132                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4133                         name == names.init ? site.tsym.name : name,
4134                         methodArguments(argtypes));
4135                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4136             } else if (filteredCandidates.size() == 1) {
4137                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4138                                 filteredCandidates.entrySet().iterator().next();
4139                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4140                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4141                     @Override
4142                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4143                         return p;
4144                     }
4145                 }.getDiagnostic(dkind, pos,
4146                     location, site, name, argtypes, typeargtypes);
4147                 if (truncatedDiag) {
4148                     d.setFlag(DiagnosticFlag.COMPRESSED);
4149                 }
4150                 return d;
4151             } else {
4152                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4153                     location, site, name, argtypes, typeargtypes);
4154             }
4155         }
4156         //where
4157             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4158                 MostSpecificMap candidates = new MostSpecificMap();
4159                 for (Candidate c : resolveContext.candidates) {
4160                     if (c.isApplicable()) continue;
4161                     candidates.put(c);
4162                 }
4163                 return candidates;
4164             }
4165 
4166             @SuppressWarnings(&quot;serial&quot;)
4167             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4168                 private void put(Candidate c) {
4169                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4170                     for (Symbol s : keySet()) {
4171                         if (s == c.sym) {
4172                             continue;
4173                         }
4174                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4175                             overridden.add(s);
4176                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4177                             return;
4178                         }
4179                     }
4180                     for (Symbol s : overridden) {
4181                         remove(s);
4182                     }
4183                     put(c.sym, c.details);
4184                 }
4185             }
4186 
4187             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4188                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4189                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4190                     JCDiagnostic d = _entry.getValue();
4191                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4192                         candidates.put(_entry.getKey(), d);
4193                     }
4194                 }
4195                 return candidates;
4196             }
4197 
4198             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4199                 List&lt;JCDiagnostic&gt; details = List.nil();
4200                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4201                     Symbol sym = _entry.getKey();
4202                     JCDiagnostic detailDiag =
4203                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4204                                                                         sym.location(site, types),
4205                                                                         sym.asMemberOf(site, types),
4206                                                                         _entry.getValue()));
4207                     details = details.prepend(detailDiag);
4208                 }
4209                 //typically members are visited in reverse order (see Scope)
4210                 //so we need to reverse the candidate list so that candidates
4211                 //conform to source order
4212                 return details;
4213             }
4214 
4215         @Override
4216         protected Symbol bestCandidate() {
4217             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4218             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4219             if (filteredCandidates.size() == 1) {
4220                 return filteredCandidates.keySet().iterator().next();
4221             }
4222             return null;
4223         }
4224     }
4225 
4226     /**
4227      * DiamondError error class indicating that a constructor symbol is not applicable
4228      * given an actual arguments/type argument list using diamond inference.
4229      */
4230     class DiamondError extends InapplicableSymbolError {
4231 
4232         Symbol sym;
4233 
4234         public DiamondError(Symbol sym, MethodResolutionContext context) {
4235             super(sym.kind, &quot;diamondError&quot;, context);
4236             this.sym = sym;
4237         }
4238 
4239         JCDiagnostic getDetails() {
4240             return (sym.kind == WRONG_MTH) ?
4241                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4242                     null;
4243         }
4244 
4245         @Override
4246         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4247                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4248             JCDiagnostic details = getDetails();
4249             if (details != null &amp;&amp; compactMethodDiags) {
4250                 JCDiagnostic simpleDiag =
4251                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4252                 if (simpleDiag != null) {
4253                     return simpleDiag;
4254                 }
4255             }
4256             String key = details == null ?
4257                 &quot;cant.apply.diamond&quot; :
4258                 &quot;cant.apply.diamond.1&quot;;
4259             return diags.create(dkind, log.currentSource(), pos, key,
4260                     Fragments.Diamond(site.tsym), details);
4261         }
4262     }
4263 
4264     /**
4265      * An InvalidSymbolError error class indicating that a symbol is not
4266      * accessible from a given site
4267      */
4268     class AccessError extends InvalidSymbolError {
4269 
4270         private Env&lt;AttrContext&gt; env;
4271         private Type site;
4272 
4273         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4274             super(HIDDEN, sym, &quot;access error&quot;);
4275             this.env = env;
4276             this.site = site;
4277         }
4278 
4279         @Override
4280         public boolean exists() {
4281             return false;
4282         }
4283 
4284         @Override
4285         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4286                 DiagnosticPosition pos,
4287                 Symbol location,
4288                 Type site,
4289                 Name name,
4290                 List&lt;Type&gt; argtypes,
4291                 List&lt;Type&gt; typeargtypes) {
4292             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4293                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4294                         pos, location, site, name, argtypes, typeargtypes);
4295             }
4296             else if ((sym.flags() &amp; PUBLIC) != 0
4297                 || (env != null &amp;&amp; this.site != null
4298                     &amp;&amp; !isAccessible(env, this.site))) {
4299                 if (sym.owner.kind == PCK) {
4300                     return diags.create(dkind, log.currentSource(),
4301                             pos, &quot;not.def.access.package.cant.access&quot;,
4302                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4303                 } else if (   sym.packge() != syms.rootPackage
4304                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4305                     return diags.create(dkind, log.currentSource(),
4306                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4307                             sym, sym.location(), sym.location().packge(),
4308                             inaccessiblePackageReason(env, sym.packge()));
4309                 } else {
4310                     return diags.create(dkind, log.currentSource(),
4311                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4312                         sym, sym.location());
4313                 }
4314             }
4315             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4316                 return diags.create(dkind, log.currentSource(),
4317                         pos, &quot;report.access&quot;, sym,
4318                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4319                         sym.location());
4320             }
4321             else {
4322                 return diags.create(dkind, log.currentSource(),
4323                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4324             }
4325         }
4326 
4327         private String toString(Type type) {
4328             StringBuilder sb = new StringBuilder();
4329             sb.append(type);
4330             if (type != null) {
4331                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4332                 if (type.tsym != null)
4333                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4334                 sb.append(&quot;]&quot;);
4335             }
4336             return sb.toString();
4337         }
4338     }
4339 
4340     class InvisibleSymbolError extends InvalidSymbolError {
4341 
4342         private final Env&lt;AttrContext&gt; env;
4343         private final boolean suppressError;
4344 
4345         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4346             super(HIDDEN, sym, &quot;invisible class error&quot;);
4347             this.env = env;
4348             this.suppressError = suppressError;
4349             this.name = sym.name;
4350         }
4351 
4352         @Override
4353         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4354                 DiagnosticPosition pos,
4355                 Symbol location,
4356                 Type site,
4357                 Name name,
4358                 List&lt;Type&gt; argtypes,
4359                 List&lt;Type&gt; typeargtypes) {
4360             if (suppressError)
4361                 return null;
4362 
4363             if (sym.kind == PCK) {
4364                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4365                 return diags.create(dkind, log.currentSource(),
4366                         pos, &quot;package.not.visible&quot;, sym, details);
4367             }
4368 
4369             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4370 
4371             if (pos.getTree() != null) {
4372                 Symbol o = sym;
4373                 JCTree tree = pos.getTree();
4374 
4375                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4376                     o = o.owner;
4377                     tree = ((JCFieldAccess) tree).selected;
4378                 }
4379 
4380                 if (o.kind == PCK) {
4381                     pos = tree.pos();
4382 
4383                     return diags.create(dkind, log.currentSource(),
4384                             pos, &quot;package.not.visible&quot;, o, details);
4385                 }
4386             }
4387 
4388             return diags.create(dkind, log.currentSource(),
4389                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4390         }
4391     }
4392 
4393     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4394         //no dependency:
4395         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4396             //does not read:
4397             if (sym.modle != syms.unnamedModule) {
4398                 if (env.toplevel.modle != syms.unnamedModule) {
4399                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4400                                                                             sym,
4401                                                                             sym.modle));
4402                 } else {
4403                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4404                                                                                        sym.modle));
4405                 }
4406             } else {
4407                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4408                                                                                env.toplevel.modle));
4409             }
4410         } else {
4411             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4412                 //not exported to this module:
4413                 if (env.toplevel.modle != syms.unnamedModule) {
4414                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4415                                                                                     sym.modle,
4416                                                                                     env.toplevel.modle));
4417                 } else {
4418                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4419                                                                                                sym.modle));
4420                 }
4421             } else {
4422                 //not exported:
4423                 if (env.toplevel.modle != syms.unnamedModule) {
4424                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4425                                                                             sym.modle));
4426                 } else {
4427                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4428                                                                                        sym.modle));
4429                 }
4430             }
4431         }
4432     }
4433 
4434     /**
4435      * InvalidSymbolError error class indicating that an instance member
4436      * has erroneously been accessed from a static context.
4437      */
4438     class StaticError extends InvalidSymbolError {
4439 
4440         StaticError(Symbol sym) {
4441             super(STATICERR, sym, &quot;static error&quot;);
4442         }
4443 
4444         @Override
4445         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4446                 DiagnosticPosition pos,
4447                 Symbol location,
4448                 Type site,
4449                 Name name,
4450                 List&lt;Type&gt; argtypes,
4451                 List&lt;Type&gt; typeargtypes) {
4452             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4453                 ? types.erasure(sym.type).tsym
4454                 : sym);
4455             return diags.create(dkind, log.currentSource(), pos,
4456                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4457         }
4458     }
4459 
4460     /**
4461      * InvalidSymbolError error class indicating that a pair of symbols
4462      * (either methods, constructors or operands) are ambiguous
4463      * given an actual arguments/type argument list.
4464      */
4465     class AmbiguityError extends ResolveError {
4466 
4467         /** The other maximally specific symbol */
4468         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4469 
4470         @Override
4471         public boolean exists() {
4472             return true;
4473         }
4474 
4475         AmbiguityError(Symbol sym1, Symbol sym2) {
4476             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4477             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4478         }
4479 
4480         private List&lt;Symbol&gt; flatten(Symbol sym) {
4481             if (sym.kind == AMBIGUOUS) {
4482                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4483             } else {
4484                 return List.of(sym);
4485             }
4486         }
4487 
4488         AmbiguityError addAmbiguousSymbol(Symbol s) {
4489             ambiguousSyms = ambiguousSyms.prepend(s);
4490             return this;
4491         }
4492 
4493         @Override
4494         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4495                 DiagnosticPosition pos,
4496                 Symbol location,
4497                 Type site,
4498                 Name name,
4499                 List&lt;Type&gt; argtypes,
4500                 List&lt;Type&gt; typeargtypes) {
4501             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4502             Symbol s1 = diagSyms.head;
4503             Symbol s2 = diagSyms.tail.head;
4504             Name sname = s1.name;
4505             if (sname == names.init) sname = s1.owner.name;
4506             return diags.create(dkind, log.currentSource(),
4507                     pos, &quot;ref.ambiguous&quot;, sname,
4508                     kindName(s1),
4509                     s1,
4510                     s1.location(site, types),
4511                     kindName(s2),
4512                     s2,
4513                     s2.location(site, types));
4514         }
4515 
4516         /**
4517          * If multiple applicable methods are found during overload and none of them
4518          * is more specific than the others, attempt to merge their signatures.
4519          */
4520         Symbol mergeAbstracts(Type site) {
4521             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4522             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4523         }
4524 
4525         @Override
4526         protected Symbol access(Name name, TypeSymbol location) {
4527             Symbol firstAmbiguity = ambiguousSyms.last();
4528             return firstAmbiguity.kind == TYP ?
4529                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4530                     firstAmbiguity;
4531         }
4532     }
4533 
4534     class BadVarargsMethod extends ResolveError {
4535 
4536         ResolveError delegatedError;
4537 
4538         BadVarargsMethod(ResolveError delegatedError) {
4539             super(delegatedError.kind, &quot;badVarargs&quot;);
4540             this.delegatedError = delegatedError;
4541         }
4542 
4543         @Override
4544         public Symbol baseSymbol() {
4545             return delegatedError.baseSymbol();
4546         }
4547 
4548         @Override
4549         protected Symbol access(Name name, TypeSymbol location) {
4550             return delegatedError.access(name, location);
4551         }
4552 
4553         @Override
4554         public boolean exists() {
4555             return true;
4556         }
4557 
4558         @Override
4559         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4560             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4561         }
4562     }
4563 
4564     /**
4565      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4566      * but with the wrong staticness.
4567      */
4568     class BadMethodReferenceError extends StaticError {
4569 
4570         boolean unboundLookup;
4571 
4572         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4573             super(sym);
4574             this.unboundLookup = unboundLookup;
4575         }
4576 
4577         @Override
4578         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4579             final String key;
4580             if (!unboundLookup) {
4581                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4582             } else if (sym.isStatic()) {
4583                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4584             } else {
4585                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4586             }
4587             return sym.kind.isResolutionError() ?
4588                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4589                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4590         }
4591     }
4592 
4593     /**
4594      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4595      * but pointing to a class for which an enclosing instance is not available.
4596      */
4597     class BadConstructorReferenceError extends InvalidSymbolError {
4598 
4599         public BadConstructorReferenceError(Symbol sym) {
4600             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4601         }
4602 
4603         @Override
4604         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4605            return diags.create(dkind, log.currentSource(), pos,
4606                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4607         }
4608     }
4609 
4610     class BadClassFileError extends InvalidSymbolError {
4611 
4612         private final CompletionFailure ex;
4613 
4614         public BadClassFileError(CompletionFailure ex) {
4615             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4616             this.name = sym.name;
4617             this.ex = ex;
4618         }
4619 
4620         @Override
4621         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4622             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4623                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4624 
4625             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4626             return d;
4627         }
4628 
4629     }
4630 
4631     /**
4632      * Helper class for method resolution diagnostic simplification.
4633      * Certain resolution diagnostic are rewritten as simpler diagnostic
4634      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4635      * is stripped away, as it doesn&#39;t carry additional info. The logic
4636      * for matching a given diagnostic is given in terms of a template
4637      * hierarchy: a diagnostic template can be specified programmatically,
4638      * so that only certain diagnostics are matched. Each templete is then
4639      * associated with a rewriter object that carries out the task of rewtiting
4640      * the diagnostic to a simpler one.
4641      */
4642     static class MethodResolutionDiagHelper {
4643 
4644         /**
4645          * A diagnostic rewriter transforms a method resolution diagnostic
4646          * into a simpler one
4647          */
4648         interface DiagnosticRewriter {
4649             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4650                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4651                     DiagnosticType preferredKind, JCDiagnostic d);
4652         }
4653 
4654         /**
4655          * A diagnostic template is made up of two ingredients: (i) a regular
4656          * expression for matching a diagnostic key and (ii) a list of sub-templates
4657          * for matching diagnostic arguments.
4658          */
4659         static class Template {
4660 
4661             /** regex used to match diag key */
4662             String regex;
4663 
4664             /** templates used to match diagnostic args */
4665             Template[] subTemplates;
4666 
4667             Template(String key, Template... subTemplates) {
4668                 this.regex = key;
4669                 this.subTemplates = subTemplates;
4670             }
4671 
4672             /**
4673              * Returns true if the regex matches the diagnostic key and if
4674              * all diagnostic arguments are matches by corresponding sub-templates.
4675              */
4676             boolean matches(Object o) {
4677                 JCDiagnostic d = (JCDiagnostic)o;
4678                 Object[] args = d.getArgs();
4679                 if (!d.getCode().matches(regex) ||
4680                         subTemplates.length != d.getArgs().length) {
4681                     return false;
4682                 }
4683                 for (int i = 0; i &lt; args.length ; i++) {
4684                     if (!subTemplates[i].matches(args[i])) {
4685                         return false;
4686                     }
4687                 }
4688                 return true;
4689             }
4690         }
4691 
4692         /**
4693          * Common rewriter for all argument mismatch simplifications.
4694          */
4695         static class ArgMismatchRewriter implements DiagnosticRewriter {
4696 
4697             /** the index of the subdiagnostic to be used as primary. */
4698             int causeIndex;
4699 
4700             public ArgMismatchRewriter(int causeIndex) {
4701                 this.causeIndex = causeIndex;
4702             }
4703 
4704             @Override
4705             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4706                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4707                     DiagnosticType preferredKind, JCDiagnostic d) {
4708                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4709                 DiagnosticPosition pos = d.getDiagnosticPosition();
4710                 if (pos == null) {
4711                     pos = preferredPos;
4712                 }
4713                 return diags.create(preferredKind, preferredSource, pos,
4714                         &quot;prob.found.req&quot;, cause);
4715             }
4716         }
4717 
4718         /** a dummy template that match any diagnostic argument */
4719         static final Template skip = new Template(&quot;&quot;) {
4720             @Override
4721             boolean matches(Object d) {
4722                 return true;
4723             }
4724         };
4725 
4726         /** template for matching inference-free arguments mismatch failures */
4727         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4728 
4729         /** template for matching inference related arguments mismatch failures */
4730         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4731             @Override
4732             boolean matches(Object o) {
4733                 if (!super.matches(o)) {
4734                     return false;
4735                 }
4736                 JCDiagnostic d = (JCDiagnostic)o;
4737                 @SuppressWarnings(&quot;unchecked&quot;)
4738                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4739                 return !containsAny(d, tvars);
4740             }
4741 
4742             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4743                 if (o instanceof Type) {
4744                     return ((Type)o).containsAny(ts);
4745                 } else if (o instanceof JCDiagnostic) {
4746                     return containsAny((JCDiagnostic)o, ts);
4747                 } else {
4748                     return false;
4749                 }
4750             };
4751 
4752             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4753                 return Stream.of(d.getArgs())
4754                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4755             }
4756         };
4757 
4758         /** rewriter map used for method resolution simplification */
4759         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4760 
4761         static {
4762             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4763             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4764         }
4765 
4766         /**
4767          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4768          * and rewrite it accordingly.
4769          */
4770         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4771                                     DiagnosticType dkind, JCDiagnostic d) {
4772             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4773                 if (_entry.getKey().matches(d)) {
4774                     JCDiagnostic simpleDiag =
4775                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4776                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4777                     return simpleDiag;
4778                 }
4779             }
4780             return null;
4781         }
4782     }
4783 
4784     enum MethodResolutionPhase {
4785         BASIC(false, false),
4786         BOX(true, false),
4787         VARARITY(true, true) {
4788             @Override
4789             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4790                 //Check invariants (see {@code LookupHelper.shouldStop})
4791                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4792                 if (!sym.kind.isResolutionError()) {
4793                     //varargs resolution successful
4794                     return sym;
4795                 } else {
4796                     //pick best error
4797                     switch (bestSoFar.kind) {
4798                         case WRONG_MTH:
4799                         case WRONG_MTHS:
4800                             //Override previous errors if they were caused by argument mismatch.
4801                             //This generally means preferring current symbols - but we need to pay
4802                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4803                             //than the previous rounds, and adjust that accordingly.
4804                             switch (sym.kind) {
4805                                 case WRONG_MTH:
4806                                     //if the previous round matched more than one method, return that
4807                                     //result instead
4808                                     return bestSoFar.kind == WRONG_MTHS ?
4809                                             bestSoFar : sym;
4810                                 case ABSENT_MTH:
4811                                     //do not override erroneous symbol if the arity lookup did not
4812                                     //match any method
4813                                     return bestSoFar;
4814                                 case WRONG_MTHS:
4815                                 default:
4816                                     //safe to override
4817                                     return sym;
4818                             }
4819                         default:
4820                             //otherwise, return first error
4821                             return bestSoFar;
4822                     }
4823                 }
4824             }
4825         };
4826 
4827         final boolean isBoxingRequired;
4828         final boolean isVarargsRequired;
4829 
4830         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4831            this.isBoxingRequired = isBoxingRequired;
4832            this.isVarargsRequired = isVarargsRequired;
4833         }
4834 
4835         public boolean isBoxingRequired() {
4836             return isBoxingRequired;
4837         }
4838 
4839         public boolean isVarargsRequired() {
4840             return isVarargsRequired;
4841         }
4842 
4843         public Symbol mergeResults(Symbol prev, Symbol sym) {
4844             return sym;
4845         }
4846     }
4847 
4848     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4849 
4850     /**
4851      * A resolution context is used to keep track of intermediate results of
4852      * overload resolution, such as list of method that are not applicable
4853      * (used to generate more precise diagnostics) and so on. Resolution contexts
4854      * can be nested - this means that when each overload resolution routine should
4855      * work within the resolution context it created.
4856      */
4857     class MethodResolutionContext {
4858 
4859         private List&lt;Candidate&gt; candidates = List.nil();
4860 
4861         MethodResolutionPhase step = null;
4862 
4863         MethodCheck methodCheck = resolveMethodCheck;
4864 
4865         private boolean internalResolution = false;
4866         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4867 
4868         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4869             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4870             candidates = candidates.append(c);
4871         }
4872 
4873         void addApplicableCandidate(Symbol sym, Type mtype) {
4874             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4875             candidates = candidates.append(c);
4876         }
4877 
4878         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4879             DeferredAttrContext parent = (pendingResult == null)
4880                 ? deferredAttr.emptyDeferredAttrContext
4881                 : pendingResult.checkContext.deferredAttrContext();
4882             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4883                     inferenceContext, parent, warn);
4884         }
4885 
4886         /**
4887          * This class represents an overload resolution candidate. There are two
4888          * kinds of candidates: applicable methods and inapplicable methods;
4889          * applicable methods have a pointer to the instantiated method type,
4890          * while inapplicable candidates contain further details about the
4891          * reason why the method has been considered inapplicable.
4892          */
4893         @SuppressWarnings(&quot;overrides&quot;)
4894         class Candidate {
4895 
4896             final MethodResolutionPhase step;
4897             final Symbol sym;
4898             final JCDiagnostic details;
4899             final Type mtype;
4900 
4901             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4902                 this.step = step;
4903                 this.sym = sym;
4904                 this.details = details;
4905                 this.mtype = mtype;
4906             }
4907 
4908             boolean isApplicable() {
4909                 return mtype != null;
4910             }
4911         }
4912 
4913         DeferredAttr.AttrMode attrMode() {
4914             return attrMode;
4915         }
4916 
4917         boolean internal() {
4918             return internalResolution;
4919         }
4920     }
4921 
4922     MethodResolutionContext currentResolutionContext = null;
4923 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>