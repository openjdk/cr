<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InaccessibleObjectException;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.lang.reflect.RecordComponent;
  39 import java.lang.reflect.UndeclaredThrowableException;
  40 import java.lang.reflect.Member;
  41 import java.lang.reflect.Method;
  42 import java.lang.reflect.Modifier;
  43 import java.lang.reflect.Proxy;
  44 import java.security.AccessControlContext;
  45 import java.security.AccessController;
  46 import java.security.MessageDigest;
  47 import java.security.NoSuchAlgorithmException;
  48 import java.security.PermissionCollection;
  49 import java.security.Permissions;
  50 import java.security.PrivilegedAction;
  51 import java.security.PrivilegedActionException;
  52 import java.security.PrivilegedExceptionAction;
  53 import java.security.ProtectionDomain;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashSet;
  59 import java.util.Set;
  60 import java.util.concurrent.ConcurrentHashMap;
  61 import java.util.concurrent.ConcurrentMap;
  62 import jdk.internal.misc.Unsafe;
  63 import jdk.internal.reflect.CallerSensitive;
  64 import jdk.internal.reflect.Reflection;
  65 import jdk.internal.reflect.ReflectionFactory;
  66 import jdk.internal.access.SharedSecrets;
  67 import jdk.internal.access.JavaSecurityAccess;
  68 import sun.reflect.misc.ReflectUtil;
  69 import static java.io.ObjectStreamField.*;
  70 
  71 /**
  72  * Serialization&#39;s descriptor for classes.  It contains the name and
  73  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  74  * loaded in this Java VM can be found/created using the lookup method.
  75  *
  76  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  77  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  78  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  79  *
  80  * @author      Mike Warres
  81  * @author      Roger Riggs
  82  * @see ObjectStreamField
  83  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  84  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  85  * @since   1.1
  86  */
  87 public class ObjectStreamClass implements Serializable {
  88 
  89     /** serialPersistentFields value indicating no serializable fields */
  90     public static final ObjectStreamField[] NO_FIELDS =
  91         new ObjectStreamField[0];
  92 
  93     @java.io.Serial
  94     private static final long serialVersionUID = -6120832682080437368L;
  95     @java.io.Serial
  96     private static final ObjectStreamField[] serialPersistentFields =
  97         NO_FIELDS;
  98 
  99     /** reflection factory for obtaining serialization constructors */
 100     private static final ReflectionFactory reflFactory =
 101         AccessController.doPrivileged(
 102             new ReflectionFactory.GetReflectionFactoryAction());
 103 
 104     private static class Caches {
 105         /** cache mapping local classes -&gt; descriptors */
 106         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
 107             new ConcurrentHashMap&lt;&gt;();
 108 
 109         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 110         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 111             new ConcurrentHashMap&lt;&gt;();
 112 
 113         /** queue for WeakReferences to local classes */
 114         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 115             new ReferenceQueue&lt;&gt;();
 116         /** queue for WeakReferences to field reflectors keys */
 117         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 118             new ReferenceQueue&lt;&gt;();
 119     }
 120 
 121     /** class associated with this descriptor (if any) */
 122     private Class&lt;?&gt; cl;
 123     /** name of class represented by this descriptor */
 124     private String name;
 125     /** serialVersionUID of represented class (null if not computed yet) */
 126     private volatile Long suid;
 127 
 128     /** true if represents dynamic proxy class */
 129     private boolean isProxy;
 130     /** true if represents enum type */
 131     private boolean isEnum;
 132     /** true if represents record type */
 133     private boolean isRecord;
 134     /** true if represented class implements Serializable */
 135     private boolean serializable;
 136     /** true if represented class implements Externalizable */
 137     private boolean externalizable;
 138     /** true if desc has data written by class-defined writeObject method */
 139     private boolean hasWriteObjectData;
 140     /**
 141      * true if desc has externalizable data written in block data format; this
 142      * must be true by default to accommodate ObjectInputStream subclasses which
 143      * override readClassDescriptor() to return class descriptors obtained from
 144      * ObjectStreamClass.lookup() (see 4461737)
 145      */
 146     private boolean hasBlockExternalData = true;
 147 
 148     /**
 149      * Contains information about InvalidClassException instances to be thrown
 150      * when attempting operations on an invalid class. Note that instances of
 151      * this class are immutable and are potentially shared among
 152      * ObjectStreamClass instances.
 153      */
 154     private static class ExceptionInfo {
 155         private final String className;
 156         private final String message;
 157 
 158         ExceptionInfo(String cn, String msg) {
 159             className = cn;
 160             message = msg;
 161         }
 162 
 163         /**
 164          * Returns (does not throw) an InvalidClassException instance created
 165          * from the information in this object, suitable for being thrown by
 166          * the caller.
 167          */
 168         InvalidClassException newInvalidClassException() {
 169             return new InvalidClassException(className, message);
 170         }
 171     }
 172 
 173     /** exception (if any) thrown while attempting to resolve class */
 174     private ClassNotFoundException resolveEx;
 175     /** exception (if any) to throw if non-enum deserialization attempted */
 176     private ExceptionInfo deserializeEx;
 177     /** exception (if any) to throw if non-enum serialization attempted */
 178     private ExceptionInfo serializeEx;
 179     /** exception (if any) to throw if default serialization attempted */
 180     private ExceptionInfo defaultSerializeEx;
 181 
 182     /** serializable fields */
 183     private ObjectStreamField[] fields;
 184     /** aggregate marshalled size of primitive fields */
 185     private int primDataSize;
 186     /** number of non-primitive fields */
 187     private int numObjFields;
 188     /** reflector for setting/getting serializable field values */
 189     private FieldReflector fieldRefl;
 190     /** data layout of serialized objects described by this class desc */
 191     private volatile ClassDataSlot[] dataLayout;
 192 
 193     /** serialization-appropriate constructor, or null if none */
 194     private Constructor&lt;?&gt; cons;
 195     /** record canonical constructor, or null */
 196     private MethodHandle canonicalCtr;
 197     /** protection domains that need to be checked when calling the constructor */
 198     private ProtectionDomain[] domains;
 199 
 200     /** class-defined writeObject method, or null if none */
 201     private Method writeObjectMethod;
 202     /** class-defined readObject method, or null if none */
 203     private Method readObjectMethod;
 204     /** class-defined readObjectNoData method, or null if none */
 205     private Method readObjectNoDataMethod;
 206     /** class-defined writeReplace method, or null if none */
 207     private Method writeReplaceMethod;
 208     /** class-defined readResolve method, or null if none */
 209     private Method readResolveMethod;
 210 
 211     /** local class descriptor for represented class (may point to self) */
 212     private ObjectStreamClass localDesc;
 213     /** superclass descriptor appearing in stream */
 214     private ObjectStreamClass superDesc;
 215 
 216     /** true if, and only if, the object has been correctly initialized */
 217     private boolean initialized;
 218 
 219     /**
 220      * Initializes native code.
 221      */
 222     private static native void initNative();
 223     static {
 224         initNative();
 225     }
 226 
 227     /**
 228      * Find the descriptor for a class that can be serialized.  Creates an
 229      * ObjectStreamClass instance if one does not exist yet for class. Null is
 230      * returned if the specified class does not implement java.io.Serializable
 231      * or java.io.Externalizable.
 232      *
 233      * @param   cl class for which to get the descriptor
 234      * @return  the class descriptor for the specified class
 235      */
 236     public static ObjectStreamClass lookup(Class&lt;?&gt; cl) {
 237         return lookup(cl, false);
 238     }
 239 
 240     /**
 241      * Returns the descriptor for any class, regardless of whether it
 242      * implements {@link Serializable}.
 243      *
 244      * @param        cl class for which to get the descriptor
 245      * @return       the class descriptor for the specified class
 246      * @since 1.6
 247      */
 248     public static ObjectStreamClass lookupAny(Class&lt;?&gt; cl) {
 249         return lookup(cl, true);
 250     }
 251 
 252     /**
 253      * Returns the name of the class described by this descriptor.
 254      * This method returns the name of the class in the format that
 255      * is used by the {@link Class#getName} method.
 256      *
 257      * @return a string representing the name of the class
 258      */
 259     public String getName() {
 260         return name;
 261     }
 262 
 263     /**
 264      * Return the serialVersionUID for this class.  The serialVersionUID
 265      * defines a set of classes all with the same name that have evolved from a
 266      * common root class and agree to be serialized and deserialized using a
 267      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 268      *
 269      * @return  the SUID of the class described by this descriptor
 270      */
 271     public long getSerialVersionUID() {
 272         // REMIND: synchronize instead of relying on volatile?
 273         if (suid == null) {
 274             if (isRecord)
 275                 return 0L;
 276 
 277             suid = AccessController.doPrivileged(
 278                 new PrivilegedAction&lt;Long&gt;() {
 279                     public Long run() {
 280                         return computeDefaultSUID(cl);
 281                     }
 282                 }
 283             );
 284         }
 285         return suid.longValue();
 286     }
 287 
 288     /**
 289      * Return the class in the local VM that this version is mapped to.  Null
 290      * is returned if there is no corresponding local class.
 291      *
 292      * @return  the {@code Class} instance that this descriptor represents
 293      */
 294     @CallerSensitive
 295     public Class&lt;?&gt; forClass() {
 296         if (cl == null) {
 297             return null;
 298         }
 299         requireInitialized();
 300         if (System.getSecurityManager() != null) {
 301             Class&lt;?&gt; caller = Reflection.getCallerClass();
 302             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 303                 ReflectUtil.checkPackageAccess(cl);
 304             }
 305         }
 306         return cl;
 307     }
 308 
 309     /**
 310      * Return an array of the fields of this serializable class.
 311      *
 312      * @return  an array containing an element for each persistent field of
 313      *          this class. Returns an array of length zero if there are no
 314      *          fields.
 315      * @since 1.2
 316      */
 317     public ObjectStreamField[] getFields() {
 318         return getFields(true);
 319     }
 320 
 321     /**
 322      * Get the field of this class by name.
 323      *
 324      * @param   name the name of the data field to look for
 325      * @return  The ObjectStreamField object of the named field or null if
 326      *          there is no such named field.
 327      */
 328     public ObjectStreamField getField(String name) {
 329         return getField(name, null);
 330     }
 331 
 332     /**
 333      * Return a string describing this ObjectStreamClass.
 334      */
 335     public String toString() {
 336         return name + &quot;: static final long serialVersionUID = &quot; +
 337             getSerialVersionUID() + &quot;L;&quot;;
 338     }
 339 
 340     /**
 341      * Looks up and returns class descriptor for given class, or null if class
 342      * is non-serializable and &quot;all&quot; is set to false.
 343      *
 344      * @param   cl class to look up
 345      * @param   all if true, return descriptors for all classes; if false, only
 346      *          return descriptors for serializable classes
 347      */
 348     static ObjectStreamClass lookup(Class&lt;?&gt; cl, boolean all) {
 349         if (!(all || Serializable.class.isAssignableFrom(cl))) {
 350             return null;
 351         }
 352         processQueue(Caches.localDescsQueue, Caches.localDescs);
 353         WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);
 354         Reference&lt;?&gt; ref = Caches.localDescs.get(key);
 355         Object entry = null;
 356         if (ref != null) {
 357             entry = ref.get();
 358         }
 359         EntryFuture future = null;
 360         if (entry == null) {
 361             EntryFuture newEntry = new EntryFuture();
 362             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
 363             do {
 364                 if (ref != null) {
 365                     Caches.localDescs.remove(key, ref);
 366                 }
 367                 ref = Caches.localDescs.putIfAbsent(key, newRef);
 368                 if (ref != null) {
 369                     entry = ref.get();
 370                 }
 371             } while (ref != null &amp;&amp; entry == null);
 372             if (entry == null) {
 373                 future = newEntry;
 374             }
 375         }
 376 
 377         if (entry instanceof ObjectStreamClass) {  // check common case first
 378             return (ObjectStreamClass) entry;
 379         }
 380         if (entry instanceof EntryFuture) {
 381             future = (EntryFuture) entry;
 382             if (future.getOwner() == Thread.currentThread()) {
 383                 /*
 384                  * Handle nested call situation described by 4803747: waiting
 385                  * for future value to be set by a lookup() call further up the
 386                  * stack will result in deadlock, so calculate and set the
 387                  * future value here instead.
 388                  */
 389                 entry = null;
 390             } else {
 391                 entry = future.get();
 392             }
 393         }
 394         if (entry == null) {
 395             try {
 396                 entry = new ObjectStreamClass(cl);
 397             } catch (Throwable th) {
 398                 entry = th;
 399             }
 400             if (future.set(entry)) {
 401                 Caches.localDescs.put(key, new SoftReference&lt;&gt;(entry));
 402             } else {
 403                 // nested lookup call already set future
 404                 entry = future.get();
 405             }
 406         }
 407 
 408         if (entry instanceof ObjectStreamClass) {
 409             return (ObjectStreamClass) entry;
 410         } else if (entry instanceof RuntimeException) {
 411             throw (RuntimeException) entry;
 412         } else if (entry instanceof Error) {
 413             throw (Error) entry;
 414         } else {
 415             throw new InternalError(&quot;unexpected entry: &quot; + entry);
 416         }
 417     }
 418 
 419     /**
 420      * Placeholder used in class descriptor and field reflector lookup tables
 421      * for an entry in the process of being initialized.  (Internal) callers
 422      * which receive an EntryFuture belonging to another thread as the result
 423      * of a lookup should call the get() method of the EntryFuture; this will
 424      * return the actual entry once it is ready for use and has been set().  To
 425      * conserve objects, EntryFutures synchronize on themselves.
 426      */
 427     private static class EntryFuture {
 428 
 429         private static final Object unset = new Object();
 430         private final Thread owner = Thread.currentThread();
 431         private Object entry = unset;
 432 
 433         /**
 434          * Attempts to set the value contained by this EntryFuture.  If the
 435          * EntryFuture&#39;s value has not been set already, then the value is
 436          * saved, any callers blocked in the get() method are notified, and
 437          * true is returned.  If the value has already been set, then no saving
 438          * or notification occurs, and false is returned.
 439          */
 440         synchronized boolean set(Object entry) {
 441             if (this.entry != unset) {
 442                 return false;
 443             }
 444             this.entry = entry;
 445             notifyAll();
 446             return true;
 447         }
 448 
 449         /**
 450          * Returns the value contained by this EntryFuture, blocking if
 451          * necessary until a value is set.
 452          */
 453         synchronized Object get() {
 454             boolean interrupted = false;
 455             while (entry == unset) {
 456                 try {
 457                     wait();
 458                 } catch (InterruptedException ex) {
 459                     interrupted = true;
 460                 }
 461             }
 462             if (interrupted) {
 463                 AccessController.doPrivileged(
 464                     new PrivilegedAction&lt;&gt;() {
 465                         public Void run() {
 466                             Thread.currentThread().interrupt();
 467                             return null;
 468                         }
 469                     }
 470                 );
 471             }
 472             return entry;
 473         }
 474 
 475         /**
 476          * Returns the thread that created this EntryFuture.
 477          */
 478         Thread getOwner() {
 479             return owner;
 480         }
 481     }
 482 
 483     @SuppressWarnings(&quot;preview&quot;)
 484     private static boolean isRecord(Class&lt;?&gt; cls) {
 485         return cls.isRecord();
 486     }
 487 
 488     /**
 489      * Creates local class descriptor representing given class.
 490      */
 491     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 492         this.cl = cl;
 493         name = cl.getName();
 494         isProxy = Proxy.isProxyClass(cl);
 495         isEnum = Enum.class.isAssignableFrom(cl);
 496         boolean isInlineClass = cl.isInlineClass();
 497         isRecord = isRecord(cl);
 498         serializable = Serializable.class.isAssignableFrom(cl);
 499         externalizable = Externalizable.class.isAssignableFrom(cl);
 500 
 501         Class&lt;?&gt; superCl = cl.getSuperclass();
 502         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 503         localDesc = this;
 504 
 505         if (serializable) {
 506             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 507                 public Void run() {
 508                     if (isEnum) {
 509                         suid = Long.valueOf(0);
 510                         fields = NO_FIELDS;
 511                         return null;
 512                     }
 513                     if (cl.isArray()) {
 514                         fields = NO_FIELDS;
 515                         return null;
 516                     }
 517 
 518                     suid = getDeclaredSUID(cl);
 519                     try {
 520                         fields = getSerialFields(cl);
 521                         computeFieldOffsets();
 522                     } catch (InvalidClassException e) {
 523                         serializeEx = deserializeEx =
 524                             new ExceptionInfo(e.classname, e.getMessage());
 525                         fields = NO_FIELDS;
 526                     }
 527 
 528                     if (isRecord) {
 529                         canonicalCtr = canonicalRecordCtr(cl);
 530                     } else if (externalizable) {
 531                         cons = getExternalizableConstructor(cl);
 532                     } else {
 533                         cons = getSerializableConstructor(cl);
 534                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 535                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 536                             Void.TYPE);
 537                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 538                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 539                             Void.TYPE);
 540                         readObjectNoDataMethod = getPrivateMethod(
 541                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 542                         hasWriteObjectData = (writeObjectMethod != null);
 543                     }
 544                     domains = getProtectionDomains(cons, cl);
 545                     writeReplaceMethod = getInheritableMethod(
 546                         cl, &quot;writeReplace&quot;, null, Object.class);
 547                     readResolveMethod = getInheritableMethod(
 548                         cl, &quot;readResolve&quot;, null, Object.class);
 549                     return null;
 550                 }
 551             });
 552         } else {
 553             suid = Long.valueOf(0);
 554             fields = NO_FIELDS;
 555         }
 556 
 557         try {
 558             fieldRefl = getReflector(fields, this);
 559         } catch (InvalidClassException ex) {
 560             // field mismatches impossible when matching local fields vs. self
 561             throw new InternalError(ex);
 562         }
 563 
 564         if (deserializeEx == null) {
 565             if (isEnum) {
 566                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
 567             } else if (isInlineClass &amp;&amp; writeReplaceMethod == null) {
 568                 deserializeEx = new ExceptionInfo(name, &quot;inline class&quot;);
 569             } else if (cons == null &amp;&amp; !isRecord) {
 570                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 571             }
 572         }
 573         if (isRecord &amp;&amp; canonicalCtr == null) {
 574             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);
 575         } else {
 576             for (int i = 0; i &lt; fields.length; i++) {
 577                 if (fields[i].getField() == null) {
 578                     defaultSerializeEx = new ExceptionInfo(
 579                         name, &quot;unmatched serializable field(s) declared&quot;);
 580                 }
 581             }
 582         }
 583         initialized = true;
 584     }
 585 
 586     /**
 587      * Creates blank class descriptor which should be initialized via a
 588      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 589      */
 590     ObjectStreamClass() {
 591     }
 592 
 593     /**
 594      * Creates a PermissionDomain that grants no permission.
 595      */
 596     private ProtectionDomain noPermissionsDomain() {
 597         PermissionCollection perms = new Permissions();
 598         perms.setReadOnly();
 599         return new ProtectionDomain(null, perms);
 600     }
 601 
 602     /**
 603      * Aggregate the ProtectionDomains of all the classes that separate
 604      * a concrete class {@code cl} from its ancestor&#39;s class declaring
 605      * a constructor {@code cons}.
 606      *
 607      * If {@code cl} is defined by the boot loader, or the constructor
 608      * {@code cons} is declared by {@code cl}, or if there is no security
 609      * manager, then this method does nothing and {@code null} is returned.
 610      *
 611      * @param cons A constructor declared by {@code cl} or one of its
 612      *             ancestors.
 613      * @param cl A concrete class, which is either the class declaring
 614      *           the constructor {@code cons}, or a serializable subclass
 615      *           of that class.
 616      * @return An array of ProtectionDomain representing the set of
 617      *         ProtectionDomain that separate the concrete class {@code cl}
 618      *         from its ancestor&#39;s declaring {@code cons}, or {@code null}.
 619      */
 620     private ProtectionDomain[] getProtectionDomains(Constructor&lt;?&gt; cons,
 621                                                     Class&lt;?&gt; cl) {
 622         ProtectionDomain[] domains = null;
 623         if (cons != null &amp;&amp; cl.getClassLoader() != null
 624                 &amp;&amp; System.getSecurityManager() != null) {
 625             Class&lt;?&gt; cls = cl;
 626             Class&lt;?&gt; fnscl = cons.getDeclaringClass();
 627             Set&lt;ProtectionDomain&gt; pds = null;
 628             while (cls != fnscl) {
 629                 ProtectionDomain pd = cls.getProtectionDomain();
 630                 if (pd != null) {
 631                     if (pds == null) pds = new HashSet&lt;&gt;();
 632                     pds.add(pd);
 633                 }
 634                 cls = cls.getSuperclass();
 635                 if (cls == null) {
 636                     // that&#39;s not supposed to happen
 637                     // make a ProtectionDomain with no permission.
 638                     // should we throw instead?
 639                     if (pds == null) pds = new HashSet&lt;&gt;();
 640                     else pds.clear();
 641                     pds.add(noPermissionsDomain());
 642                     break;
 643                 }
 644             }
 645             if (pds != null) {
 646                 domains = pds.toArray(new ProtectionDomain[0]);
 647             }
 648         }
 649         return domains;
 650     }
 651 
 652     /**
 653      * Initializes class descriptor representing a proxy class.
 654      */
 655     void initProxy(Class&lt;?&gt; cl,
 656                    ClassNotFoundException resolveEx,
 657                    ObjectStreamClass superDesc)
 658         throws InvalidClassException
 659     {
 660         ObjectStreamClass osc = null;
 661         if (cl != null) {
 662             osc = lookup(cl, true);
 663             if (!osc.isProxy) {
 664                 throw new InvalidClassException(
 665                     &quot;cannot bind proxy descriptor to a non-proxy class&quot;);
 666             }
 667         }
 668         this.cl = cl;
 669         this.resolveEx = resolveEx;
 670         this.superDesc = superDesc;
 671         isProxy = true;
 672         serializable = true;
 673         suid = Long.valueOf(0);
 674         fields = NO_FIELDS;
 675         if (osc != null) {
 676             localDesc = osc;
 677             name = localDesc.name;
 678             externalizable = localDesc.externalizable;
 679             writeReplaceMethod = localDesc.writeReplaceMethod;
 680             readResolveMethod = localDesc.readResolveMethod;
 681             deserializeEx = localDesc.deserializeEx;
 682             domains = localDesc.domains;
 683             cons = localDesc.cons;
 684         }
 685         fieldRefl = getReflector(fields, localDesc);
 686         initialized = true;
 687     }
 688 
 689     /**
 690      * Initializes class descriptor representing a non-proxy class.
 691      */
 692     void initNonProxy(ObjectStreamClass model,
 693                       Class&lt;?&gt; cl,
 694                       ClassNotFoundException resolveEx,
 695                       ObjectStreamClass superDesc)
 696         throws InvalidClassException
 697     {
 698         long suid = Long.valueOf(model.getSerialVersionUID());
 699         ObjectStreamClass osc = null;
 700         if (cl != null) {
 701             osc = lookup(cl, true);
 702             if (osc.isProxy) {
 703                 throw new InvalidClassException(
 704                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 705             }
 706             if (model.isEnum != osc.isEnum) {
 707                 throw new InvalidClassException(model.isEnum ?
 708                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 709                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 710             }
 711 
 712             if (model.serializable == osc.serializable &amp;&amp;
 713                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;
 714                     suid != osc.getSerialVersionUID()) {
 715                 throw new InvalidClassException(osc.name,
 716                         &quot;local class incompatible: &quot; +
 717                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 718                                 &quot;, local class serialVersionUID = &quot; +
 719                                 osc.getSerialVersionUID());
 720             }
 721 
 722             if (!classNamesEqual(model.name, osc.name)) {
 723                 throw new InvalidClassException(osc.name,
 724                         &quot;local class name incompatible with stream class &quot; +
 725                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 726             }
 727 
 728             if (!model.isEnum) {
 729                 if ((model.serializable == osc.serializable) &amp;&amp;
 730                         (model.externalizable != osc.externalizable)) {
 731                     throw new InvalidClassException(osc.name,
 732                             &quot;Serializable incompatible with Externalizable&quot;);
 733                 }
 734 
 735                 if ((model.serializable != osc.serializable) ||
 736                         (model.externalizable != osc.externalizable) ||
 737                         !(model.serializable || model.externalizable)) {
 738                     deserializeEx = new ExceptionInfo(
 739                             osc.name, &quot;class invalid for deserialization&quot;);
 740                 }
 741             }
 742         }
 743 
 744         this.cl = cl;
 745         if (cl != null) {
 746             this.isRecord = isRecord(cl);
 747             this.canonicalCtr = osc.canonicalCtr;
 748         }
 749         this.resolveEx = resolveEx;
 750         this.superDesc = superDesc;
 751         name = model.name;
 752         this.suid = suid;
 753         isProxy = false;
 754         isEnum = model.isEnum;
 755         serializable = model.serializable;
 756         externalizable = model.externalizable;
 757         hasBlockExternalData = model.hasBlockExternalData;
 758         hasWriteObjectData = model.hasWriteObjectData;
 759         fields = model.fields;
 760         primDataSize = model.primDataSize;
 761         numObjFields = model.numObjFields;
 762 
 763         if (osc != null) {
 764             localDesc = osc;
 765             writeObjectMethod = localDesc.writeObjectMethod;
 766             readObjectMethod = localDesc.readObjectMethod;
 767             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 768             writeReplaceMethod = localDesc.writeReplaceMethod;
 769             readResolveMethod = localDesc.readResolveMethod;
 770             if (deserializeEx == null) {
 771                 deserializeEx = localDesc.deserializeEx;
 772             }
 773             domains = localDesc.domains;
 774             assert isRecord(cl) ? localDesc.cons == null : true;
 775             cons = localDesc.cons;
 776         }
 777 
 778         fieldRefl = getReflector(fields, localDesc);
 779         // reassign to matched fields so as to reflect local unshared settings
 780         fields = fieldRefl.getFields();
 781 
 782         initialized = true;
 783     }
 784 
 785     /**
 786      * Reads non-proxy class descriptor information from given input stream.
 787      * The resulting class descriptor is not fully functional; it can only be
 788      * used as input to the ObjectInputStream.resolveClass() and
 789      * ObjectStreamClass.initNonProxy() methods.
 790      */
 791     void readNonProxy(ObjectInputStream in)
 792         throws IOException, ClassNotFoundException
 793     {
 794         name = in.readUTF();
 795         suid = Long.valueOf(in.readLong());
 796         isProxy = false;
 797 
 798         byte flags = in.readByte();
 799         hasWriteObjectData =
 800             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 801         hasBlockExternalData =
 802             ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
 803         externalizable =
 804             ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
 805         boolean sflag =
 806             ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
 807         if (externalizable &amp;&amp; sflag) {
 808             throw new InvalidClassException(
 809                 name, &quot;serializable and externalizable flags conflict&quot;);
 810         }
 811         serializable = externalizable || sflag;
 812         isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0);
 813         if (isEnum &amp;&amp; suid.longValue() != 0L) {
 814             throw new InvalidClassException(name,
 815                 &quot;enum descriptor has non-zero serialVersionUID: &quot; + suid);
 816         }
 817 
 818         int numFields = in.readShort();
 819         if (isEnum &amp;&amp; numFields != 0) {
 820             throw new InvalidClassException(name,
 821                 &quot;enum descriptor has non-zero field count: &quot; + numFields);
 822         }
 823         fields = (numFields &gt; 0) ?
 824             new ObjectStreamField[numFields] : NO_FIELDS;
 825         for (int i = 0; i &lt; numFields; i++) {
 826             char tcode = (char) in.readByte();
 827             String fname = in.readUTF();
 828             String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
 829                 in.readTypeString() : new String(new char[] { tcode });
 830             try {
 831                 fields[i] = new ObjectStreamField(fname, signature, false);
 832             } catch (RuntimeException e) {
 833                 throw (IOException) new InvalidClassException(name,
 834                     &quot;invalid descriptor for field &quot; + fname).initCause(e);
 835             }
 836         }
 837         computeFieldOffsets();
 838     }
 839 
 840     /**
 841      * Writes non-proxy class descriptor information to given output stream.
 842      */
 843     void writeNonProxy(ObjectOutputStream out) throws IOException {
 844         out.writeUTF(name);
 845         out.writeLong(getSerialVersionUID());
 846 
 847         byte flags = 0;
 848         if (externalizable) {
 849             flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
 850             int protocol = out.getProtocolVersion();
 851             if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
 852                 flags |= ObjectStreamConstants.SC_BLOCK_DATA;
 853             }
 854         } else if (serializable) {
 855             flags |= ObjectStreamConstants.SC_SERIALIZABLE;
 856         }
 857         if (hasWriteObjectData) {
 858             flags |= ObjectStreamConstants.SC_WRITE_METHOD;
 859         }
 860         if (isEnum) {
 861             flags |= ObjectStreamConstants.SC_ENUM;
 862         }
 863         out.writeByte(flags);
 864 
 865         out.writeShort(fields.length);
 866         for (int i = 0; i &lt; fields.length; i++) {
 867             ObjectStreamField f = fields[i];
 868             out.writeByte(f.getTypeCode());
 869             out.writeUTF(f.getName());
 870             if (!f.isPrimitive()) {
 871                 out.writeTypeString(f.getTypeString());
 872             }
 873         }
 874     }
 875 
 876     /**
 877      * Returns ClassNotFoundException (if any) thrown while attempting to
 878      * resolve local class corresponding to this class descriptor.
 879      */
 880     ClassNotFoundException getResolveException() {
 881         return resolveEx;
 882     }
 883 
 884     /**
 885      * Throws InternalError if not initialized.
 886      */
 887     private final void requireInitialized() {
 888         if (!initialized)
 889             throw new InternalError(&quot;Unexpected call when not initialized&quot;);
 890     }
 891 
 892     /**
 893      * Throws InvalidClassException if not initialized.
 894      * To be called in cases where an uninitialized class descriptor indicates
 895      * a problem in the serialization stream.
 896      */
 897     final void checkInitialized() throws InvalidClassException {
 898         if (!initialized) {
 899             throw new InvalidClassException(&quot;Class descriptor should be initialized&quot;);
 900         }
 901     }
 902 
 903     /**
 904      * Throws an InvalidClassException if object instances referencing this
 905      * class descriptor should not be allowed to deserialize.  This method does
 906      * not apply to deserialization of enum constants.
 907      */
 908     void checkDeserialize() throws InvalidClassException {
 909         requireInitialized();
 910         if (deserializeEx != null) {
 911             throw deserializeEx.newInvalidClassException();
 912         }
 913     }
 914 
 915     /**
 916      * Throws an InvalidClassException if objects whose class is represented by
 917      * this descriptor should not be allowed to serialize.  This method does
 918      * not apply to serialization of enum constants.
 919      */
 920     void checkSerialize() throws InvalidClassException {
 921         requireInitialized();
 922         if (serializeEx != null) {
 923             throw serializeEx.newInvalidClassException();
 924         }
 925     }
 926 
 927     /**
 928      * Throws an InvalidClassException if objects whose class is represented by
 929      * this descriptor should not be permitted to use default serialization
 930      * (e.g., if the class declares serializable fields that do not correspond
 931      * to actual fields, and hence must use the GetField API).  This method
 932      * does not apply to deserialization of enum constants.
 933      */
 934     void checkDefaultSerialize() throws InvalidClassException {
 935         requireInitialized();
 936         if (defaultSerializeEx != null) {
 937             throw defaultSerializeEx.newInvalidClassException();
 938         }
 939     }
 940 
 941     /**
 942      * Returns superclass descriptor.  Note that on the receiving side, the
 943      * superclass descriptor may be bound to a class that is not a superclass
 944      * of the subclass descriptor&#39;s bound class.
 945      */
 946     ObjectStreamClass getSuperDesc() {
 947         requireInitialized();
 948         return superDesc;
 949     }
 950 
 951     /**
 952      * Returns the &quot;local&quot; class descriptor for the class associated with this
 953      * class descriptor (i.e., the result of
 954      * ObjectStreamClass.lookup(this.forClass())) or null if there is no class
 955      * associated with this descriptor.
 956      */
 957     ObjectStreamClass getLocalDesc() {
 958         requireInitialized();
 959         return localDesc;
 960     }
 961 
 962     /**
 963      * Returns arrays of ObjectStreamFields representing the serializable
 964      * fields of the represented class.  If copy is true, a clone of this class
 965      * descriptor&#39;s field array is returned, otherwise the array itself is
 966      * returned.
 967      */
 968     ObjectStreamField[] getFields(boolean copy) {
 969         return copy ? fields.clone() : fields;
 970     }
 971 
 972     /**
 973      * Looks up a serializable field of the represented class by name and type.
 974      * A specified type of null matches all types, Object.class matches all
 975      * non-primitive types, and any other non-null type matches assignable
 976      * types only.  Returns matching field, or null if no match found.
 977      */
 978     ObjectStreamField getField(String name, Class&lt;?&gt; type) {
 979         for (int i = 0; i &lt; fields.length; i++) {
 980             ObjectStreamField f = fields[i];
 981             if (f.getName().equals(name)) {
 982                 if (type == null ||
 983                     (type == Object.class &amp;&amp; !f.isPrimitive()))
 984                 {
 985                     return f;
 986                 }
 987                 Class&lt;?&gt; ftype = f.getType();
 988                 if (ftype != null &amp;&amp; type.isAssignableFrom(ftype)) {
 989                     return f;
 990                 }
 991             }
 992         }
 993         return null;
 994     }
 995 
 996     /**
 997      * Returns true if class descriptor represents a dynamic proxy class, false
 998      * otherwise.
 999      */
1000     boolean isProxy() {
1001         requireInitialized();
1002         return isProxy;
1003     }
1004 
1005     /**
1006      * Returns true if class descriptor represents an enum type, false
1007      * otherwise.
1008      */
1009     boolean isEnum() {
1010         requireInitialized();
1011         return isEnum;
1012     }
1013 
1014     /**
1015      * Returns true if class descriptor represents a record type, false
1016      * otherwise.
1017      */
1018     boolean isRecord() {
1019         requireInitialized();
1020         return isRecord;
1021     }
1022 
1023     /**
1024      * Returns true if represented class implements Externalizable, false
1025      * otherwise.
1026      */
1027     boolean isExternalizable() {
1028         requireInitialized();
1029         return externalizable;
1030     }
1031 
1032     /**
1033      * Returns true if represented class implements Serializable, false
1034      * otherwise.
1035      */
1036     boolean isSerializable() {
1037         requireInitialized();
1038         return serializable;
1039     }
1040 
1041     /**
1042      * Returns true if class descriptor represents externalizable class that
1043      * has written its data in 1.2 (block data) format, false otherwise.
1044      */
1045     boolean hasBlockExternalData() {
1046         requireInitialized();
1047         return hasBlockExternalData;
1048     }
1049 
1050     /**
1051      * Returns true if class descriptor represents serializable (but not
1052      * externalizable) class which has written its data via a custom
1053      * writeObject() method, false otherwise.
1054      */
1055     boolean hasWriteObjectData() {
1056         requireInitialized();
1057         return hasWriteObjectData;
1058     }
1059 
1060     /**
1061      * Returns true if represented class is serializable/externalizable and can
1062      * be instantiated by the serialization runtime--i.e., if it is
1063      * externalizable and defines a public no-arg constructor, or if it is
1064      * non-externalizable and its first non-serializable superclass defines an
1065      * accessible no-arg constructor.  Otherwise, returns false.
1066      */
1067     boolean isInstantiable() {
1068         requireInitialized();
1069         return (cons != null);
1070     }
1071 
1072     /**
1073      * Returns true if represented class is serializable (but not
1074      * externalizable) and defines a conformant writeObject method.  Otherwise,
1075      * returns false.
1076      */
1077     boolean hasWriteObjectMethod() {
1078         requireInitialized();
1079         return (writeObjectMethod != null);
1080     }
1081 
1082     /**
1083      * Returns true if represented class is serializable (but not
1084      * externalizable) and defines a conformant readObject method.  Otherwise,
1085      * returns false.
1086      */
1087     boolean hasReadObjectMethod() {
1088         requireInitialized();
1089         return (readObjectMethod != null);
1090     }
1091 
1092     /**
1093      * Returns true if represented class is serializable (but not
1094      * externalizable) and defines a conformant readObjectNoData method.
1095      * Otherwise, returns false.
1096      */
1097     boolean hasReadObjectNoDataMethod() {
1098         requireInitialized();
1099         return (readObjectNoDataMethod != null);
1100     }
1101 
1102     /**
1103      * Returns true if represented class is serializable or externalizable and
1104      * defines a conformant writeReplace method.  Otherwise, returns false.
1105      */
1106     boolean hasWriteReplaceMethod() {
1107         requireInitialized();
1108         return (writeReplaceMethod != null);
1109     }
1110 
1111     /**
1112      * Returns true if represented class is serializable or externalizable and
1113      * defines a conformant readResolve method.  Otherwise, returns false.
1114      */
1115     boolean hasReadResolveMethod() {
1116         requireInitialized();
1117         return (readResolveMethod != null);
1118     }
1119 
1120     /**
1121      * Creates a new instance of the represented class.  If the class is
1122      * externalizable, invokes its public no-arg constructor; otherwise, if the
1123      * class is serializable, invokes the no-arg constructor of the first
1124      * non-serializable superclass.  Throws UnsupportedOperationException if
1125      * this class descriptor is not associated with a class, if the associated
1126      * class is non-serializable or if the appropriate no-arg constructor is
1127      * inaccessible/unavailable.
1128      */
1129     Object newInstance()
1130         throws InstantiationException, InvocationTargetException,
1131                UnsupportedOperationException
1132     {
1133         requireInitialized();
1134         if (cons != null) {
1135             try {
1136                 if (domains == null || domains.length == 0) {
1137                     return cons.newInstance();
1138                 } else {
1139                     JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();
1140                     PrivilegedAction&lt;?&gt; pea = () -&gt; {
1141                         try {
1142                             return cons.newInstance();
1143                         } catch (InstantiationException
1144                                  | InvocationTargetException
1145                                  | IllegalAccessException x) {
1146                             throw new UndeclaredThrowableException(x);
1147                         }
1148                     }; // Can&#39;t use PrivilegedExceptionAction with jsa
1149                     try {
1150                         return jsa.doIntersectionPrivilege(pea,
1151                                    AccessController.getContext(),
1152                                    new AccessControlContext(domains));
1153                     } catch (UndeclaredThrowableException x) {
1154                         Throwable cause = x.getCause();
1155                         if (cause instanceof InstantiationException)
1156                             throw (InstantiationException) cause;
1157                         if (cause instanceof InvocationTargetException)
1158                             throw (InvocationTargetException) cause;
1159                         if (cause instanceof IllegalAccessException)
1160                             throw (IllegalAccessException) cause;
1161                         // not supposed to happen
1162                         throw x;
1163                     }
1164                 }
1165             } catch (IllegalAccessException ex) {
1166                 // should not occur, as access checks have been suppressed
1167                 throw new InternalError(ex);
1168             } catch (InstantiationError err) {
1169                 var ex = new InstantiationException();
1170                 ex.initCause(err);
1171                 throw ex;
1172             }
1173         } else {
1174             throw new UnsupportedOperationException();
1175         }
1176     }
1177 
1178     /**
1179      * Invokes the writeObject method of the represented serializable class.
1180      * Throws UnsupportedOperationException if this class descriptor is not
1181      * associated with a class, or if the class is externalizable,
1182      * non-serializable or does not define writeObject.
1183      */
1184     void invokeWriteObject(Object obj, ObjectOutputStream out)
1185         throws IOException, UnsupportedOperationException
1186     {
1187         requireInitialized();
1188         if (writeObjectMethod != null) {
1189             try {
1190                 writeObjectMethod.invoke(obj, new Object[]{ out });
1191             } catch (InvocationTargetException ex) {
1192                 Throwable th = ex.getTargetException();
1193                 if (th instanceof IOException) {
1194                     throw (IOException) th;
1195                 } else {
1196                     throwMiscException(th);
1197                 }
1198             } catch (IllegalAccessException ex) {
1199                 // should not occur, as access checks have been suppressed
1200                 throw new InternalError(ex);
1201             }
1202         } else {
1203             throw new UnsupportedOperationException();
1204         }
1205     }
1206 
1207     /**
1208      * Invokes the readObject method of the represented serializable class.
1209      * Throws UnsupportedOperationException if this class descriptor is not
1210      * associated with a class, or if the class is externalizable,
1211      * non-serializable or does not define readObject.
1212      */
1213     void invokeReadObject(Object obj, ObjectInputStream in)
1214         throws ClassNotFoundException, IOException,
1215                UnsupportedOperationException
1216     {
1217         requireInitialized();
1218         if (readObjectMethod != null) {
1219             try {
1220                 readObjectMethod.invoke(obj, new Object[]{ in });
1221             } catch (InvocationTargetException ex) {
1222                 Throwable th = ex.getTargetException();
1223                 if (th instanceof ClassNotFoundException) {
1224                     throw (ClassNotFoundException) th;
1225                 } else if (th instanceof IOException) {
1226                     throw (IOException) th;
1227                 } else {
1228                     throwMiscException(th);
1229                 }
1230             } catch (IllegalAccessException ex) {
1231                 // should not occur, as access checks have been suppressed
1232                 throw new InternalError(ex);
1233             }
1234         } else {
1235             throw new UnsupportedOperationException();
1236         }
1237     }
1238 
1239     /**
1240      * Invokes the readObjectNoData method of the represented serializable
1241      * class.  Throws UnsupportedOperationException if this class descriptor is
1242      * not associated with a class, or if the class is externalizable,
1243      * non-serializable or does not define readObjectNoData.
1244      */
1245     void invokeReadObjectNoData(Object obj)
1246         throws IOException, UnsupportedOperationException
1247     {
1248         requireInitialized();
1249         if (readObjectNoDataMethod != null) {
1250             try {
1251                 readObjectNoDataMethod.invoke(obj, (Object[]) null);
1252             } catch (InvocationTargetException ex) {
1253                 Throwable th = ex.getTargetException();
1254                 if (th instanceof ObjectStreamException) {
1255                     throw (ObjectStreamException) th;
1256                 } else {
1257                     throwMiscException(th);
1258                 }
1259             } catch (IllegalAccessException ex) {
1260                 // should not occur, as access checks have been suppressed
1261                 throw new InternalError(ex);
1262             }
1263         } else {
1264             throw new UnsupportedOperationException();
1265         }
1266     }
1267 
1268     /**
1269      * Invokes the writeReplace method of the represented serializable class and
1270      * returns the result.  Throws UnsupportedOperationException if this class
1271      * descriptor is not associated with a class, or if the class is
1272      * non-serializable or does not define writeReplace.
1273      */
1274     Object invokeWriteReplace(Object obj)
1275         throws IOException, UnsupportedOperationException
1276     {
1277         requireInitialized();
1278         if (writeReplaceMethod != null) {
1279             try {
1280                 return writeReplaceMethod.invoke(obj, (Object[]) null);
1281             } catch (InvocationTargetException ex) {
1282                 Throwable th = ex.getTargetException();
1283                 if (th instanceof ObjectStreamException) {
1284                     throw (ObjectStreamException) th;
1285                 } else {
1286                     throwMiscException(th);
1287                     throw new InternalError(th);  // never reached
1288                 }
1289             } catch (IllegalAccessException ex) {
1290                 // should not occur, as access checks have been suppressed
1291                 throw new InternalError(ex);
1292             }
1293         } else {
1294             throw new UnsupportedOperationException();
1295         }
1296     }
1297 
1298     /**
1299      * Invokes the readResolve method of the represented serializable class and
1300      * returns the result.  Throws UnsupportedOperationException if this class
1301      * descriptor is not associated with a class, or if the class is
1302      * non-serializable or does not define readResolve.
1303      */
1304     Object invokeReadResolve(Object obj)
1305         throws IOException, UnsupportedOperationException
1306     {
1307         requireInitialized();
1308         if (readResolveMethod != null) {
1309             try {
1310                 return readResolveMethod.invoke(obj, (Object[]) null);
1311             } catch (InvocationTargetException ex) {
1312                 Throwable th = ex.getTargetException();
1313                 if (th instanceof ObjectStreamException) {
1314                     throw (ObjectStreamException) th;
1315                 } else {
1316                     throwMiscException(th);
1317                     throw new InternalError(th);  // never reached
1318                 }
1319             } catch (IllegalAccessException ex) {
1320                 // should not occur, as access checks have been suppressed
1321                 throw new InternalError(ex);
1322             }
1323         } else {
1324             throw new UnsupportedOperationException();
1325         }
1326     }
1327 
1328     /**
1329      * Class representing the portion of an object&#39;s serialized form allotted
1330      * to data described by a given class descriptor.  If &quot;hasData&quot; is false,
1331      * the object&#39;s serialized form does not contain data associated with the
1332      * class descriptor.
1333      */
1334     static class ClassDataSlot {
1335 
1336         /** class descriptor &quot;occupying&quot; this slot */
1337         final ObjectStreamClass desc;
1338         /** true if serialized form includes data for this slot&#39;s descriptor */
1339         final boolean hasData;
1340 
1341         ClassDataSlot(ObjectStreamClass desc, boolean hasData) {
1342             this.desc = desc;
1343             this.hasData = hasData;
1344         }
1345     }
1346 
1347     /**
1348      * Returns array of ClassDataSlot instances representing the data layout
1349      * (including superclass data) for serialized objects described by this
1350      * class descriptor.  ClassDataSlots are ordered by inheritance with those
1351      * containing &quot;higher&quot; superclasses appearing first.  The final
1352      * ClassDataSlot contains a reference to this descriptor.
1353      */
1354     ClassDataSlot[] getClassDataLayout() throws InvalidClassException {
1355         // REMIND: synchronize instead of relying on volatile?
1356         if (dataLayout == null) {
1357             dataLayout = getClassDataLayout0();
1358         }
1359         return dataLayout;
1360     }
1361 
1362     private ClassDataSlot[] getClassDataLayout0()
1363         throws InvalidClassException
1364     {
1365         ArrayList&lt;ClassDataSlot&gt; slots = new ArrayList&lt;&gt;();
1366         Class&lt;?&gt; start = cl, end = cl;
1367 
1368         // locate closest non-serializable superclass
1369         while (end != null &amp;&amp; Serializable.class.isAssignableFrom(end)) {
1370             end = end.getSuperclass();
1371         }
1372 
1373         HashSet&lt;String&gt; oscNames = new HashSet&lt;&gt;(3);
1374 
1375         for (ObjectStreamClass d = this; d != null; d = d.superDesc) {
1376             if (oscNames.contains(d.name)) {
1377                 throw new InvalidClassException(&quot;Circular reference.&quot;);
1378             } else {
1379                 oscNames.add(d.name);
1380             }
1381 
1382             // search up inheritance hierarchy for class with matching name
1383             String searchName = (d.cl != null) ? d.cl.getName() : d.name;
1384             Class&lt;?&gt; match = null;
1385             for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1386                 if (searchName.equals(c.getName())) {
1387                     match = c;
1388                     break;
1389                 }
1390             }
1391 
1392             // add &quot;no data&quot; slot for each unmatched class below match
1393             if (match != null) {
1394                 for (Class&lt;?&gt; c = start; c != match; c = c.getSuperclass()) {
1395                     slots.add(new ClassDataSlot(
1396                         ObjectStreamClass.lookup(c, true), false));
1397                 }
1398                 start = match.getSuperclass();
1399             }
1400 
1401             // record descriptor/class pairing
1402             slots.add(new ClassDataSlot(d.getVariantFor(match), true));
1403         }
1404 
1405         // add &quot;no data&quot; slot for any leftover unmatched classes
1406         for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1407             slots.add(new ClassDataSlot(
1408                 ObjectStreamClass.lookup(c, true), false));
1409         }
1410 
1411         // order slots from superclass -&gt; subclass
1412         Collections.reverse(slots);
1413         return slots.toArray(new ClassDataSlot[slots.size()]);
1414     }
1415 
1416     /**
1417      * Returns aggregate size (in bytes) of marshalled primitive field values
1418      * for represented class.
1419      */
1420     int getPrimDataSize() {
1421         return primDataSize;
1422     }
1423 
1424     /**
1425      * Returns number of non-primitive serializable fields of represented
1426      * class.
1427      */
1428     int getNumObjFields() {
1429         return numObjFields;
1430     }
1431 
1432     /**
1433      * Fetches the serializable primitive field values of object obj and
1434      * marshals them into byte array buf starting at offset 0.  It is the
1435      * responsibility of the caller to ensure that obj is of the proper type if
1436      * non-null.
1437      */
1438     void getPrimFieldValues(Object obj, byte[] buf) {
1439         fieldRefl.getPrimFieldValues(obj, buf);
1440     }
1441 
1442     /**
1443      * Sets the serializable primitive fields of object obj using values
1444      * unmarshalled from byte array buf starting at offset 0.  It is the
1445      * responsibility of the caller to ensure that obj is of the proper type if
1446      * non-null.
1447      */
1448     void setPrimFieldValues(Object obj, byte[] buf) {
1449         fieldRefl.setPrimFieldValues(obj, buf);
1450     }
1451 
1452     /**
1453      * Fetches the serializable object field values of object obj and stores
1454      * them in array vals starting at offset 0.  It is the responsibility of
1455      * the caller to ensure that obj is of the proper type if non-null.
1456      */
1457     void getObjFieldValues(Object obj, Object[] vals) {
1458         fieldRefl.getObjFieldValues(obj, vals);
1459     }
1460 
1461     /**
1462      * Checks that the given values, from array vals starting at offset 0,
1463      * are assignable to the given serializable object fields.
1464      * @throws ClassCastException if any value is not assignable
1465      */
1466     void checkObjFieldValueTypes(Object obj, Object[] vals) {
1467         fieldRefl.checkObjectFieldValueTypes(obj, vals);
1468     }
1469 
1470     /**
1471      * Sets the serializable object fields of object obj using values from
1472      * array vals starting at offset 0.  It is the responsibility of the caller
1473      * to ensure that obj is of the proper type if non-null.
1474      */
1475     void setObjFieldValues(Object obj, Object[] vals) {
1476         fieldRefl.setObjFieldValues(obj, vals);
1477     }
1478 
1479     /**
1480      * Calculates and sets serializable field offsets, as well as primitive
1481      * data size and object field count totals.  Throws InvalidClassException
1482      * if fields are illegally ordered.
1483      */
1484     private void computeFieldOffsets() throws InvalidClassException {
1485         primDataSize = 0;
1486         numObjFields = 0;
1487         int firstObjIndex = -1;
1488 
1489         for (int i = 0; i &lt; fields.length; i++) {
1490             ObjectStreamField f = fields[i];
1491             switch (f.getTypeCode()) {
1492                 case &#39;Z&#39;:
1493                 case &#39;B&#39;:
1494                     f.setOffset(primDataSize++);
1495                     break;
1496 
1497                 case &#39;C&#39;:
1498                 case &#39;S&#39;:
1499                     f.setOffset(primDataSize);
1500                     primDataSize += 2;
1501                     break;
1502 
1503                 case &#39;I&#39;:
1504                 case &#39;F&#39;:
1505                     f.setOffset(primDataSize);
1506                     primDataSize += 4;
1507                     break;
1508 
1509                 case &#39;J&#39;:
1510                 case &#39;D&#39;:
1511                     f.setOffset(primDataSize);
1512                     primDataSize += 8;
1513                     break;
1514 
1515                 case &#39;[&#39;:
1516                 case &#39;L&#39;:
1517                     f.setOffset(numObjFields++);
1518                     if (firstObjIndex == -1) {
1519                         firstObjIndex = i;
1520                     }
1521                     break;
1522 
1523                 default:
1524                     throw new InternalError();
1525             }
1526         }
1527         if (firstObjIndex != -1 &amp;&amp;
1528             firstObjIndex + numObjFields != fields.length)
1529         {
1530             throw new InvalidClassException(name, &quot;illegal field order&quot;);
1531         }
1532     }
1533 
1534     /**
1535      * If given class is the same as the class associated with this class
1536      * descriptor, returns reference to this class descriptor.  Otherwise,
1537      * returns variant of this class descriptor bound to given class.
1538      */
1539     private ObjectStreamClass getVariantFor(Class&lt;?&gt; cl)
1540         throws InvalidClassException
1541     {
1542         if (this.cl == cl) {
1543             return this;
1544         }
1545         ObjectStreamClass desc = new ObjectStreamClass();
1546         if (isProxy) {
1547             desc.initProxy(cl, null, superDesc);
1548         } else {
1549             desc.initNonProxy(this, cl, null, superDesc);
1550         }
1551         return desc;
1552     }
1553 
1554     /**
1555      * Returns public no-arg constructor of given class, or null if none found.
1556      * Access checks are disabled on the returned constructor (if any), since
1557      * the defining class may still be non-public.
1558      */
1559     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1560         try {
1561             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1562             cons.setAccessible(true);
1563             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1564                 cons : null;
1565         } catch (NoSuchMethodException | InaccessibleObjectException ex) {
1566             return null;
1567         }
1568     }
1569 
1570     /**
1571      * Returns subclass-accessible no-arg constructor of first non-serializable
1572      * superclass, or null if none found.  Access checks are disabled on the
1573      * returned constructor (if any).
1574      */
1575     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1576         return reflFactory.newConstructorForSerialization(cl);
1577     }
1578 
1579     /**
1580      * Returns the canonical constructor for the given record class, or null if
1581      * the not found ( which should never happen for correctly generated record
1582      * classes ).
1583      */
1584     @SuppressWarnings(&quot;preview&quot;)
1585     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {
1586         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;
1587         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {
1588             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())
1589                                           .map(RecordComponent::getType)
1590                                           .toArray(Class&lt;?&gt;[]::new);
1591             try {
1592                 Constructor&lt;?&gt; ctr = cls.getDeclaredConstructor(paramTypes);
1593                 ctr.setAccessible(true);
1594                 return MethodHandles.lookup().unreflectConstructor(ctr);
1595             } catch (IllegalAccessException | NoSuchMethodException e) {
1596                 return null;
1597             }
1598         };
1599         return AccessController.doPrivileged(pa);
1600     }
1601 
1602     /**
1603      * Returns the canonical constructor, if the local class equivalent of this
1604      * stream class descriptor is a record class, otherwise null.
1605      */
1606     MethodHandle getRecordConstructor() {
1607         return canonicalCtr;
1608     }
1609 
1610     /**
1611      * Returns non-static, non-abstract method with given signature provided it
1612      * is defined by or accessible (via inheritance) by the given class, or
1613      * null if no match found.  Access checks are disabled on the returned
1614      * method (if any).
1615      */
1616     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1617                                                Class&lt;?&gt;[] argTypes,
1618                                                Class&lt;?&gt; returnType)
1619     {
1620         Method meth = null;
1621         Class&lt;?&gt; defCl = cl;
1622         while (defCl != null) {
1623             try {
1624                 meth = defCl.getDeclaredMethod(name, argTypes);
1625                 break;
1626             } catch (NoSuchMethodException ex) {
1627                 defCl = defCl.getSuperclass();
1628             }
1629         }
1630 
1631         if ((meth == null) || (meth.getReturnType() != returnType)) {
1632             return null;
1633         }
1634         meth.setAccessible(true);
1635         int mods = meth.getModifiers();
1636         if ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
1637             return null;
1638         } else if ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
1639             return meth;
1640         } else if ((mods &amp; Modifier.PRIVATE) != 0) {
1641             return (cl == defCl) ? meth : null;
1642         } else {
1643             return packageEquals(cl, defCl) ? meth : null;
1644         }
1645     }
1646 
1647     /**
1648      * Returns non-static private method with given signature defined by given
1649      * class, or null if none found.  Access checks are disabled on the
1650      * returned method (if any).
1651      */
1652     private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,
1653                                            Class&lt;?&gt;[] argTypes,
1654                                            Class&lt;?&gt; returnType)
1655     {
1656         try {
1657             Method meth = cl.getDeclaredMethod(name, argTypes);
1658             meth.setAccessible(true);
1659             int mods = meth.getModifiers();
1660             return ((meth.getReturnType() == returnType) &amp;&amp;
1661                     ((mods &amp; Modifier.STATIC) == 0) &amp;&amp;
1662                     ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;
1663         } catch (NoSuchMethodException ex) {
1664             return null;
1665         }
1666     }
1667 
1668     /**
1669      * Returns true if classes are defined in the same runtime package, false
1670      * otherwise.
1671      */
1672     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
1673         return (cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
1674                 cl1.getPackageName().equals(cl2.getPackageName()));
1675     }
1676 
1677     /**
1678      * Compares class names for equality, ignoring package names.  Returns true
1679      * if class names equal, false otherwise.
1680      */
1681     private static boolean classNamesEqual(String name1, String name2) {
1682         int idx1 = name1.lastIndexOf(&#39;.&#39;) + 1;
1683         int idx2 = name2.lastIndexOf(&#39;.&#39;) + 1;
1684         int len1 = name1.length() - idx1;
1685         int len2 = name2.length() - idx2;
1686         return len1 == len2 &amp;&amp;
1687                 name1.regionMatches(idx1, name2, idx2, len1);
1688     }
1689 
1690     /**
1691      * Returns JVM type signature for given list of parameters and return type.
1692      */
1693     private static String getMethodSignature(Class&lt;?&gt;[] paramTypes,
1694                                              Class&lt;?&gt; retType)
1695     {
1696         StringBuilder sb = new StringBuilder();
1697         sb.append(&#39;(&#39;);
1698         for (int i = 0; i &lt; paramTypes.length; i++) {
1699             appendClassSignature(sb, paramTypes[i]);
1700         }
1701         sb.append(&#39;)&#39;);
1702         appendClassSignature(sb, retType);
1703         return sb.toString();
1704     }
1705 
1706     /**
1707      * Convenience method for throwing an exception that is either a
1708      * RuntimeException, Error, or of some unexpected type (in which case it is
1709      * wrapped inside an IOException).
1710      */
1711     private static void throwMiscException(Throwable th) throws IOException {
1712         if (th instanceof RuntimeException) {
1713             throw (RuntimeException) th;
1714         } else if (th instanceof Error) {
1715             throw (Error) th;
1716         } else {
1717             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1718             ex.initCause(th);
1719             throw ex;
1720         }
1721     }
1722 
1723     /**
1724      * Returns ObjectStreamField array describing the serializable fields of
1725      * the given class.  Serializable fields backed by an actual field of the
1726      * class are represented by ObjectStreamFields with corresponding non-null
1727      * Field objects.  Throws InvalidClassException if the (explicitly
1728      * declared) serializable fields are invalid.
1729      */
1730     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1731         throws InvalidClassException
1732     {
1733         if (!Serializable.class.isAssignableFrom(cl))
1734             return NO_FIELDS;
1735 
1736         ObjectStreamField[] fields;
1737         if (isRecord(cl)) {
1738             fields = getDefaultSerialFields(cl);
1739             Arrays.sort(fields);
1740         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;
1741             !Proxy.isProxyClass(cl) &amp;&amp;
1742                    !cl.isInterface()) {
1743             if ((fields = getDeclaredSerialFields(cl)) == null) {
1744                 fields = getDefaultSerialFields(cl);
1745             }
1746             Arrays.sort(fields);
1747         } else {
1748             fields = NO_FIELDS;
1749         }
1750         return fields;
1751     }
1752 
1753     /**
1754      * Returns serializable fields of given class as defined explicitly by a
1755      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1756      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1757      * by an actual field of the class are represented by ObjectStreamFields
1758      * with corresponding non-null Field objects.  For compatibility with past
1759      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1760      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1761      * InvalidClassException if the declared serializable fields are
1762      * invalid--e.g., if multiple fields share the same name.
1763      */
1764     private static ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)
1765         throws InvalidClassException
1766     {
1767         ObjectStreamField[] serialPersistentFields = null;
1768         try {
1769             Field f = cl.getDeclaredField(&quot;serialPersistentFields&quot;);
1770             int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;
1771             if ((f.getModifiers() &amp; mask) == mask) {
1772                 f.setAccessible(true);
1773                 serialPersistentFields = (ObjectStreamField[]) f.get(null);
1774             }
1775         } catch (Exception ex) {
1776         }
1777         if (serialPersistentFields == null) {
1778             return null;
1779         } else if (serialPersistentFields.length == 0) {
1780             return NO_FIELDS;
1781         }
1782 
1783         ObjectStreamField[] boundFields =
1784             new ObjectStreamField[serialPersistentFields.length];
1785         Set&lt;String&gt; fieldNames = new HashSet&lt;&gt;(serialPersistentFields.length);
1786 
1787         for (int i = 0; i &lt; serialPersistentFields.length; i++) {
1788             ObjectStreamField spf = serialPersistentFields[i];
1789 
1790             String fname = spf.getName();
1791             if (fieldNames.contains(fname)) {
1792                 throw new InvalidClassException(
1793                     &quot;multiple serializable fields named &quot; + fname);
1794             }
1795             fieldNames.add(fname);
1796 
1797             try {
1798                 Field f = cl.getDeclaredField(fname);
1799                 if ((f.getType() == spf.getType()) &amp;&amp;
1800                     ((f.getModifiers() &amp; Modifier.STATIC) == 0))
1801                 {
1802                     boundFields[i] =
1803                         new ObjectStreamField(f, spf.isUnshared(), true);
1804                 }
1805             } catch (NoSuchFieldException ex) {
1806             }
1807             if (boundFields[i] == null) {
1808                 boundFields[i] = new ObjectStreamField(
1809                     fname, spf.getType(), spf.isUnshared());
1810             }
1811         }
1812         return boundFields;
1813     }
1814 
1815     /**
1816      * Returns array of ObjectStreamFields corresponding to all non-static
1817      * non-transient fields declared by given class.  Each ObjectStreamField
1818      * contains a Field object for the field it represents.  If no default
1819      * serializable fields exist, NO_FIELDS is returned.
1820      */
1821     private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {
1822         Field[] clFields = cl.getDeclaredFields();
1823         ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();
1824         int mask = Modifier.STATIC | Modifier.TRANSIENT;
1825 
1826         for (int i = 0; i &lt; clFields.length; i++) {
1827             if ((clFields[i].getModifiers() &amp; mask) == 0) {
1828                 list.add(new ObjectStreamField(clFields[i], false, true));
1829             }
1830         }
1831         int size = list.size();
1832         return (size == 0) ? NO_FIELDS :
1833             list.toArray(new ObjectStreamField[size]);
1834     }
1835 
1836     /**
1837      * Returns explicit serial version UID value declared by given class, or
1838      * null if none.
1839      */
1840     private static Long getDeclaredSUID(Class&lt;?&gt; cl) {
1841         try {
1842             Field f = cl.getDeclaredField(&quot;serialVersionUID&quot;);
1843             int mask = Modifier.STATIC | Modifier.FINAL;
1844             if ((f.getModifiers() &amp; mask) == mask) {
1845                 f.setAccessible(true);
1846                 return Long.valueOf(f.getLong(null));
1847             }
1848         } catch (Exception ex) {
1849         }
1850         return null;
1851     }
1852 
1853     /**
1854      * Computes the default serial version UID value for the given class.
1855      */
1856     private static long computeDefaultSUID(Class&lt;?&gt; cl) {
1857         if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))
1858         {
1859             return 0L;
1860         }
1861 
1862         try {
1863             ByteArrayOutputStream bout = new ByteArrayOutputStream();
1864             DataOutputStream dout = new DataOutputStream(bout);
1865 
1866             dout.writeUTF(cl.getName());
1867 
1868             int classMods = cl.getModifiers() &amp;
1869                 (Modifier.PUBLIC | Modifier.FINAL |
1870                  Modifier.INTERFACE | Modifier.ABSTRACT);
1871 
1872             /*
1873              * compensate for javac bug in which ABSTRACT bit was set for an
1874              * interface only if the interface declared methods
1875              */
1876             Method[] methods = cl.getDeclaredMethods();
1877             if ((classMods &amp; Modifier.INTERFACE) != 0) {
1878                 classMods = (methods.length &gt; 0) ?
1879                     (classMods | Modifier.ABSTRACT) :
1880                     (classMods &amp; ~Modifier.ABSTRACT);
1881             }
1882             dout.writeInt(classMods);
1883 
1884             if (!cl.isArray()) {
1885                 /*
1886                  * compensate for change in 1.2FCS in which
1887                  * Class.getInterfaces() was modified to return Cloneable and
1888                  * Serializable for array classes.
1889                  */
1890                 Class&lt;?&gt;[] interfaces = cl.getInterfaces();
1891                 String[] ifaceNames = new String[interfaces.length];
1892                 for (int i = 0; i &lt; interfaces.length; i++) {
1893                     ifaceNames[i] = interfaces[i].getName();
1894                 }
1895                 Arrays.sort(ifaceNames);
1896                 // Skip IdentityObject to keep the computed SVUID the same.
1897                 for (int i = 0; i &lt; ifaceNames.length; i++) {
1898                     if (!&quot;java.lang.IdentityObject&quot;.equals(ifaceNames[i]))
1899                         dout.writeUTF(ifaceNames[i]);
1900                 }
1901             }
1902 
1903             Field[] fields = cl.getDeclaredFields();
1904             MemberSignature[] fieldSigs = new MemberSignature[fields.length];
1905             for (int i = 0; i &lt; fields.length; i++) {
1906                 fieldSigs[i] = new MemberSignature(fields[i]);
1907             }
1908             Arrays.sort(fieldSigs, new Comparator&lt;&gt;() {
1909                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1910                     return ms1.name.compareTo(ms2.name);
1911                 }
1912             });
1913             for (int i = 0; i &lt; fieldSigs.length; i++) {
1914                 MemberSignature sig = fieldSigs[i];
1915                 int mods = sig.member.getModifiers() &amp;
1916                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1917                      Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |
1918                      Modifier.TRANSIENT);
1919                 if (((mods &amp; Modifier.PRIVATE) == 0) ||
1920                     ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == 0))
1921                 {
1922                     dout.writeUTF(sig.name);
1923                     dout.writeInt(mods);
1924                     dout.writeUTF(sig.signature);
1925                 }
1926             }
1927 
1928             if (hasStaticInitializer(cl)) {
1929                 dout.writeUTF(&quot;&lt;clinit&gt;&quot;);
1930                 dout.writeInt(Modifier.STATIC);
1931                 dout.writeUTF(&quot;()V&quot;);
1932             }
1933 
1934             Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();
1935             MemberSignature[] consSigs = new MemberSignature[cons.length];
1936             for (int i = 0; i &lt; cons.length; i++) {
1937                 consSigs[i] = new MemberSignature(cons[i]);
1938             }
1939             Arrays.sort(consSigs, new Comparator&lt;&gt;() {
1940                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1941                     return ms1.signature.compareTo(ms2.signature);
1942                 }
1943             });
1944             for (int i = 0; i &lt; consSigs.length; i++) {
1945                 MemberSignature sig = consSigs[i];
1946                 int mods = sig.member.getModifiers() &amp;
1947                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1948                      Modifier.STATIC | Modifier.FINAL |
1949                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1950                      Modifier.ABSTRACT | Modifier.STRICT);
1951                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1952                     dout.writeUTF(&quot;&lt;init&gt;&quot;);
1953                     dout.writeInt(mods);
1954                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1955                 }
1956             }
1957 
1958             MemberSignature[] methSigs = new MemberSignature[methods.length];
1959             for (int i = 0; i &lt; methods.length; i++) {
1960                 methSigs[i] = new MemberSignature(methods[i]);
1961             }
1962             Arrays.sort(methSigs, new Comparator&lt;&gt;() {
1963                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1964                     int comp = ms1.name.compareTo(ms2.name);
1965                     if (comp == 0) {
1966                         comp = ms1.signature.compareTo(ms2.signature);
1967                     }
1968                     return comp;
1969                 }
1970             });
1971             for (int i = 0; i &lt; methSigs.length; i++) {
1972                 MemberSignature sig = methSigs[i];
1973                 int mods = sig.member.getModifiers() &amp;
1974                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1975                      Modifier.STATIC | Modifier.FINAL |
1976                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1977                      Modifier.ABSTRACT | Modifier.STRICT);
1978                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1979                     dout.writeUTF(sig.name);
1980                     dout.writeInt(mods);
1981                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1982                 }
1983             }
1984 
1985             dout.flush();
1986 
1987             MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
1988             byte[] hashBytes = md.digest(bout.toByteArray());
1989             long hash = 0;
1990             for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {
1991                 hash = (hash &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);
1992             }
1993             return hash;
1994         } catch (IOException ex) {
1995             throw new InternalError(ex);
1996         } catch (NoSuchAlgorithmException ex) {
1997             throw new SecurityException(ex.getMessage());
1998         }
1999     }
2000 
2001     /**
2002      * Returns true if the given class defines a static initializer method,
2003      * false otherwise.
2004      */
2005     private static native boolean hasStaticInitializer(Class&lt;?&gt; cl);
2006 
2007     /**
2008      * Class for computing and caching field/constructor/method signatures
2009      * during serialVersionUID calculation.
2010      */
2011     private static class MemberSignature {
2012 
2013         public final Member member;
2014         public final String name;
2015         public final String signature;
2016 
2017         public MemberSignature(Field field) {
2018             member = field;
2019             name = field.getName();
2020             signature = getClassSignature(field.getType());
2021         }
2022 
2023         public MemberSignature(Constructor&lt;?&gt; cons) {
2024             member = cons;
2025             name = cons.getName();
2026             signature = getMethodSignature(
2027                 cons.getParameterTypes(), Void.TYPE);
2028         }
2029 
2030         public MemberSignature(Method meth) {
2031             member = meth;
2032             name = meth.getName();
2033             signature = getMethodSignature(
2034                 meth.getParameterTypes(), meth.getReturnType());
2035         }
2036     }
2037 
2038     /**
2039      * Class for setting and retrieving serializable field values in batch.
2040      */
2041     // REMIND: dynamically generate these?
2042     private static class FieldReflector {
2043 
2044         /** handle for performing unsafe operations */
2045         private static final Unsafe unsafe = Unsafe.getUnsafe();
2046 
2047         /** fields to operate on */
2048         private final ObjectStreamField[] fields;
2049         /** number of primitive fields */
2050         private final int numPrimFields;
2051         /** unsafe field keys for reading fields - may contain dupes */
2052         private final long[] readKeys;
2053         /** unsafe fields keys for writing fields - no dupes */
2054         private final long[] writeKeys;
2055         /** field data offsets */
2056         private final int[] offsets;
2057         /** field type codes */
2058         private final char[] typeCodes;
2059         /** field types */
2060         private final Class&lt;?&gt;[] types;
2061 
2062         /**
2063          * Constructs FieldReflector capable of setting/getting values from the
2064          * subset of fields whose ObjectStreamFields contain non-null
2065          * reflective Field objects.  ObjectStreamFields with null Fields are
2066          * treated as filler, for which get operations return default values
2067          * and set operations discard given values.
2068          */
2069         FieldReflector(ObjectStreamField[] fields) {
2070             this.fields = fields;
2071             int nfields = fields.length;
2072             readKeys = new long[nfields];
2073             writeKeys = new long[nfields];
2074             offsets = new int[nfields];
2075             typeCodes = new char[nfields];
2076             ArrayList&lt;Class&lt;?&gt;&gt; typeList = new ArrayList&lt;&gt;();
2077             Set&lt;Long&gt; usedKeys = new HashSet&lt;&gt;();
2078 
2079 
2080             for (int i = 0; i &lt; nfields; i++) {
2081                 ObjectStreamField f = fields[i];
2082                 Field rf = f.getField();
2083                 long key = (rf != null) ?
2084                     unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;
2085                 readKeys[i] = key;
2086                 writeKeys[i] = usedKeys.add(key) ?
2087                     key : Unsafe.INVALID_FIELD_OFFSET;
2088                 offsets[i] = f.getOffset();
2089                 typeCodes[i] = f.getTypeCode();
2090                 if (!f.isPrimitive()) {
2091                     typeList.add((rf != null) ? rf.getType() : null);
2092                 }
2093             }
2094 
2095             types = typeList.toArray(new Class&lt;?&gt;[typeList.size()]);
2096             numPrimFields = nfields - types.length;
2097         }
2098 
2099         /**
2100          * Returns list of ObjectStreamFields representing fields operated on
2101          * by this reflector.  The shared/unshared values and Field objects
2102          * contained by ObjectStreamFields in the list reflect their bindings
2103          * to locally defined serializable fields.
2104          */
2105         ObjectStreamField[] getFields() {
2106             return fields;
2107         }
2108 
2109         /**
2110          * Fetches the serializable primitive field values of object obj and
2111          * marshals them into byte array buf starting at offset 0.  The caller
2112          * is responsible for ensuring that obj is of the proper type.
2113          */
2114         void getPrimFieldValues(Object obj, byte[] buf) {
2115             if (obj == null) {
2116                 throw new NullPointerException();
2117             }
2118             /* assuming checkDefaultSerialize() has been called on the class
2119              * descriptor this FieldReflector was obtained from, no field keys
2120              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2121              */
2122             for (int i = 0; i &lt; numPrimFields; i++) {
2123                 long key = readKeys[i];
2124                 int off = offsets[i];
2125                 switch (typeCodes[i]) {
2126                     case &#39;Z&#39;:
2127                         Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));
2128                         break;
2129 
2130                     case &#39;B&#39;:
2131                         buf[off] = unsafe.getByte(obj, key);
2132                         break;
2133 
2134                     case &#39;C&#39;:
2135                         Bits.putChar(buf, off, unsafe.getChar(obj, key));
2136                         break;
2137 
2138                     case &#39;S&#39;:
2139                         Bits.putShort(buf, off, unsafe.getShort(obj, key));
2140                         break;
2141 
2142                     case &#39;I&#39;:
2143                         Bits.putInt(buf, off, unsafe.getInt(obj, key));
2144                         break;
2145 
2146                     case &#39;F&#39;:
2147                         Bits.putFloat(buf, off, unsafe.getFloat(obj, key));
2148                         break;
2149 
2150                     case &#39;J&#39;:
2151                         Bits.putLong(buf, off, unsafe.getLong(obj, key));
2152                         break;
2153 
2154                     case &#39;D&#39;:
2155                         Bits.putDouble(buf, off, unsafe.getDouble(obj, key));
2156                         break;
2157 
2158                     default:
2159                         throw new InternalError();
2160                 }
2161             }
2162         }
2163 
2164         /**
2165          * Sets the serializable primitive fields of object obj using values
2166          * unmarshalled from byte array buf starting at offset 0.  The caller
2167          * is responsible for ensuring that obj is of the proper type.
2168          */
2169         void setPrimFieldValues(Object obj, byte[] buf) {
2170             if (obj == null) {
2171                 throw new NullPointerException();
2172             }
2173             for (int i = 0; i &lt; numPrimFields; i++) {
2174                 long key = writeKeys[i];
2175                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2176                     continue;           // discard value
2177                 }
2178                 int off = offsets[i];
2179                 switch (typeCodes[i]) {
2180                     case &#39;Z&#39;:
2181                         unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));
2182                         break;
2183 
2184                     case &#39;B&#39;:
2185                         unsafe.putByte(obj, key, buf[off]);
2186                         break;
2187 
2188                     case &#39;C&#39;:
2189                         unsafe.putChar(obj, key, Bits.getChar(buf, off));
2190                         break;
2191 
2192                     case &#39;S&#39;:
2193                         unsafe.putShort(obj, key, Bits.getShort(buf, off));
2194                         break;
2195 
2196                     case &#39;I&#39;:
2197                         unsafe.putInt(obj, key, Bits.getInt(buf, off));
2198                         break;
2199 
2200                     case &#39;F&#39;:
2201                         unsafe.putFloat(obj, key, Bits.getFloat(buf, off));
2202                         break;
2203 
2204                     case &#39;J&#39;:
2205                         unsafe.putLong(obj, key, Bits.getLong(buf, off));
2206                         break;
2207 
2208                     case &#39;D&#39;:
2209                         unsafe.putDouble(obj, key, Bits.getDouble(buf, off));
2210                         break;
2211 
2212                     default:
2213                         throw new InternalError();
2214                 }
2215             }
2216         }
2217 
2218         /**
2219          * Fetches the serializable object field values of object obj and
2220          * stores them in array vals starting at offset 0.  The caller is
2221          * responsible for ensuring that obj is of the proper type.
2222          */
2223         void getObjFieldValues(Object obj, Object[] vals) {
2224             if (obj == null) {
2225                 throw new NullPointerException();
2226             }
2227             /* assuming checkDefaultSerialize() has been called on the class
2228              * descriptor this FieldReflector was obtained from, no field keys
2229              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2230              */
2231             for (int i = numPrimFields; i &lt; fields.length; i++) {
2232                 switch (typeCodes[i]) {
2233                     case &#39;L&#39;:
2234                     case &#39;[&#39;:
2235                         vals[offsets[i]] = unsafe.getReference(obj, readKeys[i]);
2236                         break;
2237 
2238                     default:
2239                         throw new InternalError();
2240                 }
2241             }
2242         }
2243 
2244         /**
2245          * Checks that the given values, from array vals starting at offset 0,
2246          * are assignable to the given serializable object fields.
2247          * @throws ClassCastException if any value is not assignable
2248          */
2249         void checkObjectFieldValueTypes(Object obj, Object[] vals) {
2250             setObjFieldValues(obj, vals, true);
2251         }
2252 
2253         /**
2254          * Sets the serializable object fields of object obj using values from
2255          * array vals starting at offset 0.  The caller is responsible for
2256          * ensuring that obj is of the proper type; however, attempts to set a
2257          * field with a value of the wrong type will trigger an appropriate
2258          * ClassCastException.
2259          */
2260         void setObjFieldValues(Object obj, Object[] vals) {
2261             setObjFieldValues(obj, vals, false);
2262         }
2263 
2264         private void setObjFieldValues(Object obj, Object[] vals, boolean dryRun) {
2265             if (obj == null) {
2266                 throw new NullPointerException();
2267             }
2268             for (int i = numPrimFields; i &lt; fields.length; i++) {
2269                 long key = writeKeys[i];
2270                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2271                     continue;           // discard value
2272                 }
2273                 switch (typeCodes[i]) {
2274                     case &#39;L&#39;:
2275                     case &#39;[&#39;:
2276                         Object val = vals[offsets[i]];
2277                         if (val != null &amp;&amp;
2278                             !types[i - numPrimFields].isInstance(val))
2279                         {
2280                             Field f = fields[i].getField();
2281                             throw new ClassCastException(
2282                                 &quot;cannot assign instance of &quot; +
2283                                 val.getClass().getName() + &quot; to field &quot; +
2284                                 f.getDeclaringClass().getName() + &quot;.&quot; +
2285                                 f.getName() + &quot; of type &quot; +
2286                                 f.getType().getName() + &quot; in instance of &quot; +
2287                                 obj.getClass().getName());
2288                         }
2289                         if (!dryRun)
2290                             unsafe.putReference(obj, key, val);
2291                         break;
2292 
2293                     default:
2294                         throw new InternalError();
2295                 }
2296             }
2297         }
2298     }
2299 
2300     /**
2301      * Matches given set of serializable fields with serializable fields
2302      * described by the given local class descriptor, and returns a
2303      * FieldReflector instance capable of setting/getting values from the
2304      * subset of fields that match (non-matching fields are treated as filler,
2305      * for which get operations return default values and set operations
2306      * discard given values).  Throws InvalidClassException if unresolvable
2307      * type conflicts exist between the two sets of fields.
2308      */
2309     private static FieldReflector getReflector(ObjectStreamField[] fields,
2310                                                ObjectStreamClass localDesc)
2311         throws InvalidClassException
2312     {
2313         // class irrelevant if no fields
2314         Class&lt;?&gt; cl = (localDesc != null &amp;&amp; fields.length &gt; 0) ?
2315             localDesc.cl : null;
2316         processQueue(Caches.reflectorsQueue, Caches.reflectors);
2317         FieldReflectorKey key = new FieldReflectorKey(cl, fields,
2318                                                       Caches.reflectorsQueue);
2319         Reference&lt;?&gt; ref = Caches.reflectors.get(key);
2320         Object entry = null;
2321         if (ref != null) {
2322             entry = ref.get();
2323         }
2324         EntryFuture future = null;
2325         if (entry == null) {
2326             EntryFuture newEntry = new EntryFuture();
2327             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
2328             do {
2329                 if (ref != null) {
2330                     Caches.reflectors.remove(key, ref);
2331                 }
2332                 ref = Caches.reflectors.putIfAbsent(key, newRef);
2333                 if (ref != null) {
2334                     entry = ref.get();
2335                 }
2336             } while (ref != null &amp;&amp; entry == null);
2337             if (entry == null) {
2338                 future = newEntry;
2339             }
2340         }
2341 
2342         if (entry instanceof FieldReflector) {  // check common case first
2343             return (FieldReflector) entry;
2344         } else if (entry instanceof EntryFuture) {
2345             entry = ((EntryFuture) entry).get();
2346         } else if (entry == null) {
2347             try {
2348                 entry = new FieldReflector(matchFields(fields, localDesc));
2349             } catch (Throwable th) {
2350                 entry = th;
2351             }
2352             future.set(entry);
2353             Caches.reflectors.put(key, new SoftReference&lt;&gt;(entry));
2354         }
2355 
2356         if (entry instanceof FieldReflector) {
2357             return (FieldReflector) entry;
2358         } else if (entry instanceof InvalidClassException) {
2359             throw (InvalidClassException) entry;
2360         } else if (entry instanceof RuntimeException) {
2361             throw (RuntimeException) entry;
2362         } else if (entry instanceof Error) {
2363             throw (Error) entry;
2364         } else {
2365             throw new InternalError(&quot;unexpected entry: &quot; + entry);
2366         }
2367     }
2368 
2369     /**
2370      * FieldReflector cache lookup key.  Keys are considered equal if they
2371      * refer to the same class and equivalent field formats.
2372      */
2373     private static class FieldReflectorKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2374 
2375         private final String[] sigs;
2376         private final int hash;
2377         private final boolean nullClass;
2378 
2379         FieldReflectorKey(Class&lt;?&gt; cl, ObjectStreamField[] fields,
2380                           ReferenceQueue&lt;Class&lt;?&gt;&gt; queue)
2381         {
2382             super(cl, queue);
2383             nullClass = (cl == null);
2384             sigs = new String[2 * fields.length];
2385             for (int i = 0, j = 0; i &lt; fields.length; i++) {
2386                 ObjectStreamField f = fields[i];
2387                 sigs[j++] = f.getName();
2388                 sigs[j++] = f.getSignature();
2389             }
2390             hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);
2391         }
2392 
2393         public int hashCode() {
2394             return hash;
2395         }
2396 
2397         public boolean equals(Object obj) {
2398             if (obj == this) {
2399                 return true;
2400             }
2401 
2402             if (obj instanceof FieldReflectorKey) {
2403                 FieldReflectorKey other = (FieldReflectorKey) obj;
2404                 Class&lt;?&gt; referent;
2405                 return (nullClass ? other.nullClass
2406                                   : ((referent = get()) != null) &amp;&amp;
2407                                     (referent == other.get())) &amp;&amp;
2408                         Arrays.equals(sigs, other.sigs);
2409             } else {
2410                 return false;
2411             }
2412         }
2413     }
2414 
2415     /**
2416      * Matches given set of serializable fields with serializable fields
2417      * obtained from the given local class descriptor (which contain bindings
2418      * to reflective Field objects).  Returns list of ObjectStreamFields in
2419      * which each ObjectStreamField whose signature matches that of a local
2420      * field contains a Field object for that field; unmatched
2421      * ObjectStreamFields contain null Field objects.  Shared/unshared settings
2422      * of the returned ObjectStreamFields also reflect those of matched local
2423      * ObjectStreamFields.  Throws InvalidClassException if unresolvable type
2424      * conflicts exist between the two sets of fields.
2425      */
2426     private static ObjectStreamField[] matchFields(ObjectStreamField[] fields,
2427                                                    ObjectStreamClass localDesc)
2428         throws InvalidClassException
2429     {
2430         ObjectStreamField[] localFields = (localDesc != null) ?
2431             localDesc.fields : NO_FIELDS;
2432 
2433         /*
2434          * Even if fields == localFields, we cannot simply return localFields
2435          * here.  In previous implementations of serialization,
2436          * ObjectStreamField.getType() returned Object.class if the
2437          * ObjectStreamField represented a non-primitive field and belonged to
2438          * a non-local class descriptor.  To preserve this (questionable)
2439          * behavior, the ObjectStreamField instances returned by matchFields
2440          * cannot report non-primitive types other than Object.class; hence
2441          * localFields cannot be returned directly.
2442          */
2443 
2444         ObjectStreamField[] matches = new ObjectStreamField[fields.length];
2445         for (int i = 0; i &lt; fields.length; i++) {
2446             ObjectStreamField f = fields[i], m = null;
2447             for (int j = 0; j &lt; localFields.length; j++) {
2448                 ObjectStreamField lf = localFields[j];
2449                 if (f.getName().equals(lf.getName())) {
2450                     if ((f.isPrimitive() || lf.isPrimitive()) &amp;&amp;
2451                         f.getTypeCode() != lf.getTypeCode())
2452                     {
2453                         throw new InvalidClassException(localDesc.name,
2454                             &quot;incompatible types for field &quot; + f.getName());
2455                     }
2456                     if (lf.getField() != null) {
2457                         m = new ObjectStreamField(
2458                             lf.getField(), lf.isUnshared(), false);
2459                     } else {
2460                         m = new ObjectStreamField(
2461                             lf.getName(), lf.getSignature(), lf.isUnshared());
2462                     }
2463                 }
2464             }
2465             if (m == null) {
2466                 m = new ObjectStreamField(
2467                     f.getName(), f.getSignature(), false);
2468             }
2469             m.setOffset(f.getOffset());
2470             matches[i] = m;
2471         }
2472         return matches;
2473     }
2474 
2475     /**
2476      * Removes from the specified map any keys that have been enqueued
2477      * on the specified reference queue.
2478      */
2479     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2480                              ConcurrentMap&lt;? extends
2481                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2482     {
2483         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2484         while((ref = queue.poll()) != null) {
2485             map.remove(ref);
2486         }
2487     }
2488 
2489     /**
2490      *  Weak key for Class objects.
2491      *
2492      **/
2493     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2494         /**
2495          * saved value of the referent&#39;s identity hash code, to maintain
2496          * a consistent hash code after the referent has been cleared
2497          */
2498         private final int hash;
2499 
2500         /**
2501          * Create a new WeakClassKey to the given object, registered
2502          * with a queue.
2503          */
2504         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2505             super(cl, refQueue);
2506             hash = System.identityHashCode(cl);
2507         }
2508 
2509         /**
2510          * Returns the identity hash code of the original referent.
2511          */
2512         public int hashCode() {
2513             return hash;
2514         }
2515 
2516         /**
2517          * Returns true if the given object is this identical
2518          * WeakClassKey instance, or, if this object&#39;s referent has not
2519          * been cleared, if the given object is another WeakClassKey
2520          * instance with the identical non-null referent as this one.
2521          */
2522         public boolean equals(Object obj) {
2523             if (obj == this) {
2524                 return true;
2525             }
2526 
2527             if (obj instanceof WeakClassKey) {
2528                 Object referent = get();
2529                 return (referent != null) &amp;&amp;
2530                        (referent == ((WeakClassKey) obj).get());
2531             } else {
2532                 return false;
2533             }
2534         }
2535     }
2536 
2537     /** Record specific support for retrieving and binding stream field values. */
2538     static final class RecordSupport {
2539 
2540         /** Binds the given stream field values to the given method handle. */
2541         @SuppressWarnings(&quot;preview&quot;)
2542         static MethodHandle bindCtrValues(MethodHandle ctrMH,
2543                                           ObjectStreamClass desc,
2544                                           ObjectInputStream.FieldValues fieldValues) {
2545             RecordComponent[] recordComponents;
2546             try {
2547                 Class&lt;?&gt; cls = desc.forClass();
2548                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2549                 recordComponents = AccessController.doPrivileged(pa);
2550             } catch (PrivilegedActionException e) {
2551                 throw new InternalError(e.getCause());
2552             }
2553 
2554             Object[] args = new Object[recordComponents.length];
2555             for (int i = 0; i &lt; recordComponents.length; i++) {
2556                 String name = recordComponents[i].getName();
2557                 Class&lt;?&gt; type= recordComponents[i].getType();
2558                 Object o = streamFieldValue(name, type, desc, fieldValues);
2559                 args[i] = o;
2560             }
2561 
2562             return MethodHandles.insertArguments(ctrMH, 0, args);
2563         }
2564 
2565         /** Returns the number of primitive fields for the given descriptor. */
2566         private static int numberPrimValues(ObjectStreamClass desc) {
2567             ObjectStreamField[] fields = desc.getFields();
2568             int primValueCount = 0;
2569             for (int i = 0; i &lt; fields.length; i++) {
2570                 if (fields[i].isPrimitive())
2571                     primValueCount++;
2572                 else
2573                     break;  // can be no more
2574             }
2575             return primValueCount;
2576         }
2577 
2578         /** Returns the default value for the given type. */
2579         private static Object defaultValueFor(Class&lt;?&gt; pType) {
2580             if (pType == Integer.TYPE)
2581                 return 0;
2582             else if (pType == Byte.TYPE)
2583                 return (byte)0;
2584             else if (pType == Long.TYPE)
2585                 return 0L;
2586             else if (pType == Float.TYPE)
2587                 return 0.0f;
2588             else if (pType == Double.TYPE)
2589                 return 0.0d;
2590             else if (pType == Short.TYPE)
2591                 return (short)0;
2592             else if (pType == Character.TYPE)
2593                 return &#39;\u0000&#39;;
2594             else if (pType == Boolean.TYPE)
2595                 return false;
2596             else
2597                 return null;
2598         }
2599 
2600         /**
2601          * Returns the stream field value for the given name. The default value
2602          * for the given type is returned if the field value is absent.
2603          */
2604         private static Object streamFieldValue(String pName,
2605                                                Class&lt;?&gt; pType,
2606                                                ObjectStreamClass desc,
2607                                                ObjectInputStream.FieldValues fieldValues) {
2608             ObjectStreamField[] fields = desc.getFields();
2609 
2610             for (int i = 0; i &lt; fields.length; i++) {
2611                 ObjectStreamField f = fields[i];
2612                 String fName = f.getName();
2613                 if (!fName.equals(pName))
2614                     continue;
2615 
2616                 Class&lt;?&gt; fType = f.getField().getType();
2617                 if (!pType.isAssignableFrom(fType))
2618                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2619 
2620                 if (f.isPrimitive()) {
2621                     if (pType == Integer.TYPE)
2622                         return Bits.getInt(fieldValues.primValues, f.getOffset());
2623                     else if (fType == Byte.TYPE)
2624                         return fieldValues.primValues[f.getOffset()];
2625                     else if (fType == Long.TYPE)
2626                         return Bits.getLong(fieldValues.primValues, f.getOffset());
2627                     else if (fType == Float.TYPE)
2628                         return Bits.getFloat(fieldValues.primValues, f.getOffset());
2629                     else if (fType == Double.TYPE)
2630                         return Bits.getDouble(fieldValues.primValues, f.getOffset());
2631                     else if (fType == Short.TYPE)
2632                         return Bits.getShort(fieldValues.primValues, f.getOffset());
2633                     else if (fType == Character.TYPE)
2634                         return Bits.getChar(fieldValues.primValues, f.getOffset());
2635                     else if (fType == Boolean.TYPE)
2636                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());
2637                     else
2638                         throw new InternalError(&quot;Unexpected type: &quot; + fType);
2639                 } else { // reference
2640                     return fieldValues.objValues[i - numberPrimValues(desc)];
2641                 }
2642             }
2643 
2644             return defaultValueFor(pType);
2645         }
2646     }
2647 }
    </pre>
  </body>
</html>