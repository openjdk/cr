<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.Arrays;
  38 import java.util.Comparator;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 import jdk.vm.ci.meta.UnresolvedJavaField;
  55 import jdk.vm.ci.meta.UnresolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not
  59  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is
  60  * maintained by a reference to the {@link Class} instance.
  61  */
  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {
  63 
  64     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  65     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  66     private static final SortByOffset fieldSortingMethod = new SortByOffset();
  67 
  68     /**
  69      * The Java class this type represents.
  70      */
  71     private final long metadataPointer;
  72 
  73     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  74     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
  75     private volatile HotSpotResolvedJavaField[] instanceFields;
  76     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;
  77     private HotSpotConstantPool constantPool;
  78     private final JavaConstant mirror;
  79     private HotSpotResolvedObjectTypeImpl superClass;
  80 
  81     /**
  82      * Managed exclusively by {@link HotSpotJDKReflection#getField}.
  83      */
  84     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  85 
  86     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  87         return runtime().getJavaLangObject();
  88     }
  89 
  90     /**
  91      * Gets the JVMCI mirror from a HotSpot type.
  92      *
  93      * Called from the VM.
  94      *
  95      * @param klassPointer a native pointer to the Klass*
  96      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  97      */
  98     @SuppressWarnings(&quot;unused&quot;)
  99     @VMEntryPoint
 100     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 101         return runtime().fromMetaspace(klassPointer, signature);
 102     }
 103 
 104     /**
 105      * Creates the JVMCI mirror for a {@link Class} object.
 106      *
 107      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 108      * {@link Class} type.
 109      * &lt;/p&gt;
 110      *
 111      * @param metadataPointer the Klass* to create the mirror for
 112      */
 113     @SuppressWarnings(&quot;try&quot;)
 114     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {
 115         super(name);
 116         assert metadataPointer != 0;
 117         this.metadataPointer = metadataPointer;
 118 
 119         // The mirror object must be in the global scope since
 120         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes
 121         // and live across more than one compilation.
 122         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {
 123             this.mirror = runtime().compilerToVm.getJavaMirror(this);
 124             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();
 125         }
 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
 132         long metaspacePointer = getMetaspacePointer();
 133         if (metaspacePointer == 0) {
 134             throw new NullPointerException(&quot;Klass* is null&quot;);
 135         }
 136         return metaspacePointer;
 137     }
 138 
 139     @Override
 140     public long getMetaspacePointer() {
 141         return metadataPointer;
 142     }
 143 
 144     @Override
 145     public int getModifiers() {
 146         if (isArray()) {
 147             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 148         } else {
 149             return getAccessFlags() &amp; jvmClassModifiers();
 150         }
 151     }
 152 
 153     public int getAccessFlags() {
 154         HotSpotVMConfig config = config();
 155         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 156     }
 157 
 158     @Override
 159     public ResolvedJavaType getComponentType() {
 160         return runtime().compilerToVm.getComponentType(this);
 161     }
 162 
 163     @Override
 164     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 165         if (isLeaf()) {
 166             // No assumptions are required.
 167             return new AssumptionResult&lt;&gt;(this);
 168         }
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             ResolvedJavaType elementalType = getElementalType();
 172             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 173             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 174                 /*
 175                  * If the elementType is leaf then the array is leaf under the same assumptions but
 176                  * only if the element type is exactly the leaf type. The element type can be
 177                  * abstract even if there is only one implementor of the abstract type.
 178                  */
 179                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 180                 result.add(elementType);
 181                 return result;
 182             }
 183             return null;
 184         } else if (isInterface()) {
 185             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 186             /*
 187              * If the implementor field contains itself that indicates that the interface has more
 188              * than one implementors (see: InstanceKlass::add_implementor).
 189              */
 190             if (implementor == null || implementor.equals(this)) {
 191                 return null;
 192             }
 193 
 194             assert !implementor.isInterface();
 195             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 196                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 197                 if (leafConcreteSubtype != null) {
 198                     assert !leafConcreteSubtype.getResult().equals(implementor);
 199                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 200                     // Accumulate leaf assumptions and return the combined result.
 201                     newResult.add(leafConcreteSubtype);
 202                     return newResult;
 203                 }
 204                 return null;
 205             }
 206             return concreteSubtype(implementor);
 207         } else {
 208             HotSpotResolvedObjectTypeImpl type = this;
 209             while (type.isAbstract()) {
 210                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 211                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 212                     return null;
 213                 }
 214                 type = subklass;
 215             }
 216             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 217                 return null;
 218             }
 219             if (this.isAbstract()) {
 220                 return concreteSubtype(type);
 221             } else {
 222                 assert this.equals(type);
 223                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 224             }
 225         }
 226     }
 227 
 228     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 229         if (type.isLeaf()) {
 230             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 231         } else {
 232             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 233         }
 234     }
 235 
 236     /**
 237      * Returns if type {@code type} is a leaf class. This is the case if the
 238      * {@code Klass::_subklass} field of the underlying class is zero.
 239      *
 240      * @return true if the type is a leaf class
 241      */
 242     private boolean isLeafClass() {
 243         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 244     }
 245 
 246     /**
 247      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 248      * type {@code type}.
 249      *
 250      * @return value of the subklass field as metaspace klass pointer
 251      */
 252     private HotSpotResolvedObjectTypeImpl getSubklass() {
 253         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 258         if (isInterface()) {
 259             return null;
 260         }
 261         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();
 262         if (this.equals(javaLangObject)) {
 263             return null;
 264         }
 265         if (isArray()) {
 266             return javaLangObject;
 267         }
 268 
 269         // Cache result of native call
 270         if (superClass == null) {
 271             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);
 272         }
 273         return superClass;
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
 279             if (isArray()) {
 280                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[3];
 281                 types[0] = runtime().getJavaLangCloneable();
 282                 types[1] = runtime().getJavaLangSerializable();
 283                 types[2] = runtime().getJavaLangIdentityObject();
 284                 this.interfaces = types;
 285             } else {
 286                 interfaces = runtime().compilerToVm.getInterfaces(this);
 287             }
 288         }
 289         return interfaces;
 290     }
 291 
 292     @Override
 293     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 294         if (!isInterface()) {
 295             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 296         }
 297         return compilerToVM().getImplementor(this);
 298     }
 299 
 300     @Override
 301     public HotSpotResolvedObjectTypeImpl getSupertype() {
 302         if (isArray()) {
 303             ResolvedJavaType componentType = getComponentType();
 304             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {
 305                 return getJavaLangObject();
 306             }
 307             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();
 308             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();
 309         }
 310         if (isInterface()) {
 311             return getJavaLangObject();
 312         }
 313         return getSuperclass();
 314     }
 315 
 316     @Override
 317     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 318         if (otherType.isPrimitive()) {
 319             return null;
 320         } else {
 321             HotSpotResolvedObjectTypeImpl t1 = this;
 322             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 323             while (true) {
 324                 if (t1.isAssignableFrom(t2)) {
 325                     return t1;
 326                 }
 327                 if (t2.isAssignableFrom(t1)) {
 328                     return t2;
 329                 }
 330                 t1 = t1.getSupertype();
 331                 t2 = t2.getSupertype();
 332             }
 333         }
 334     }
 335 
 336     @Override
 337     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 338         assert !isArray();
 339         if (!compilerToVM().hasFinalizableSubclass(this)) {
 340             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 341         }
 342         return new AssumptionResult&lt;&gt;(true);
 343     }
 344 
 345     @Override
 346     public boolean hasFinalizer() {
 347         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 348     }
 349 
 350     @Override
 351     public boolean isArray() {
 352         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;
 353     }
 354 
 355     @Override
 356     public boolean isEnum() {
 357         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();
 358         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());
 359     }
 360 
 361     @Override
 362     public boolean isInitialized() {
 363         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 364     }
 365 
 366     @Override
 367     public boolean isBeingInitialized() {
 368         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;
 369     }
 370 
 371     @Override
 372     public boolean isLinked() {
 373         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 374     }
 375 
 376     /**
 377      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 378      * klass.
 379      *
 380      * @return state field value of this type
 381      */
 382     private int getInitState() {
 383         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 384         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 385     }
 386 
 387     @Override
 388     public void initialize() {
 389         if (!isInitialized()) {
 390             runtime().compilerToVm.ensureInitialized(this);
 391             assert isInitialized() || isBeingInitialized();
 392         }
 393     }
 394 
 395     @Override
 396     public boolean isInstance(JavaConstant obj) {
 397         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 398             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);
 399         }
 400         return false;
 401     }
 402 
 403     @Override
 404     public boolean isInstanceClass() {
 405         return !isArray() &amp;&amp; !isInterface();
 406     }
 407 
 408     @Override
 409     public boolean isInterface() {
 410         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;
 411     }
 412 
 413     @Override
 414     public boolean isAssignableFrom(ResolvedJavaType other) {
 415         assert other != null;
 416         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 417             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 418             return runtime().reflection.isAssignableFrom(this, otherType);
 419         }
 420         return false;
 421     }
 422 
 423     @Override
 424     public ResolvedJavaType getHostClass() {
 425         if (isArray()) {
 426             return null;
 427         }
 428         return compilerToVM().getHostClass(this);
 429     }
 430 
 431     @Override
 432     public boolean isJavaLangObject() {
 433         return getName().equals(&quot;Ljava/lang/Object;&quot;);
 434     }
 435 
 436     @Override
 437     public JavaKind getJavaKind() {
 438         return JavaKind.Object;
 439     }
 440 
 441     @Override
 442     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 443         assert !callerType.isArray();
 444         if (isInterface()) {
 445             // Methods can only be resolved against concrete types
 446             return null;
 447         }
 448         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 449             return method;
 450         }
 451         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 452             return null;
 453         }
 454         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 455         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 456         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 457     }
 458 
 459     @Override
 460     public HotSpotConstantPool getConstantPool() {
 461         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 462             /*
 463              * If the pointer to the ConstantPool has changed since this was last read refresh the
 464              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 465              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 466              * use the shared copy instead of creating their own instance.
 467              */
 468             constantPool = compilerToVM().getConstantPool(this);
 469         }
 470         return constantPool;
 471     }
 472 
 473     /**
 474      * Gets the instance size of this type. If an instance of this type cannot be fast path
 475      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 476      * be called if this is an array or interface type.
 477      */
 478     @Override
 479     public int instanceSize() {
 480         assert !isArray();
 481         assert !isInterface();
 482 
 483         HotSpotVMConfig config = config();
 484         final int layoutHelper = layoutHelper();
 485         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 486 
 487         // See: Klass::layout_helper_size_in_bytes
 488         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 489 
 490         // See: Klass::layout_helper_needs_slow_path
 491         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 492 
 493         return needsSlowPath ? -size : size;
 494     }
 495 
 496     @Override
 497     public int layoutHelper() {
 498         HotSpotVMConfig config = config();
 499         assert getMetaspaceKlass() != 0 : getName();
 500         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 501     }
 502 
 503     @Override
 504     public long getFingerprint() {
 505         return compilerToVM().getFingerprint(getMetaspaceKlass());
 506     }
 507 
 508     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {
 509         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);
 510         // Maintain cache as array.
 511         if (methodCacheArray == null) {
 512             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 513         }
 514 
 515         int i = 0;
 516         for (; i &lt; methodCacheArray.length; ++i) {
 517             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 518             if (curMethod == null) {
 519                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 520                 methodCacheArray[i] = newMethod;
 521                 return newMethod;
 522             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {
 523                 return curMethod;
 524             }
 525         }
 526 
 527         // Fall-back to hash table.
 528         if (methodCacheHashMap == null) {
 529             methodCacheHashMap = new HashMap&lt;&gt;();
 530         }
 531 
 532         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 533         if (lookupResult == null) {
 534             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 535             methodCacheHashMap.put(metaspaceMethod, newMethod);
 536             return newMethod;
 537         } else {
 538             return lookupResult;
 539         }
 540     }
 541 
 542     @Override
 543     public int getVtableLength() {
 544         HotSpotVMConfig config = config();
 545         if (isInterface() || isArray()) {
 546             /* Everything has the core vtable of java.lang.Object */
 547             return config.baseVtableLength();
 548         }
 549         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 550         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 551         return result;
 552     }
 553 
 554     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 555         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 556     }
 557 
 558     @Override
 559     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 560         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 561         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 562         /*
 563          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 564          * holder, usually because of phis, so make sure that the type is related to the declared
 565          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 566          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 567          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 568          */
 569         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 570             if (hmethod.canBeStaticallyBound()) {
 571                 // No assumptions are required.
 572                 return new AssumptionResult&lt;&gt;(hmethod);
 573             }
 574             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 575             if (result != null) {
 576                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 577             }
 578             return null;
 579         }
 580         /*
 581          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 582          * the correct method for the subtype.
 583          */
 584         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 585         if (resolvedMethod == null) {
 586             // The type isn&#39;t known to implement the method.
 587             return null;
 588         }
 589         if (resolvedMethod.canBeStaticallyBound()) {
 590             // No assumptions are required.
 591             return new AssumptionResult&lt;&gt;(resolvedMethod);
 592         }
 593 
 594         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 595         if (result != null) {
 596             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 597         }
 598         return null;
 599     }
 600 
 601     FieldInfo createFieldInfo(int index) {
 602         return new FieldInfo(index);
 603     }
 604 
 605     public void ensureInitialized() {
 606         runtime().compilerToVm.ensureInitialized(this);
 607     }
 608 
 609     @Override
 610     public boolean equals(Object obj) {
 611         if (obj == this) {
 612             return true;
 613         }
 614         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {
 615             return false;
 616         }
 617         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;
 618         return getMetaspaceKlass() == that.getMetaspaceKlass();
 619     }
 620 
 621     @Override
 622     JavaConstant getJavaMirror() {
 623         return mirror;
 624     }
 625 
 626     /**
 627      * This class represents the field information for one field contained in the fields array of an
 628      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 629      */
 630     class FieldInfo {
 631         /**
 632          * Native pointer into the array of Java shorts.
 633          */
 634         private final long metaspaceData;
 635 
 636         /**
 637          * Creates a field info for the field in the fields array at index {@code index}.
 638          *
 639          * @param index index to the fields array
 640          */
 641         FieldInfo(int index) {
 642             HotSpotVMConfig config = config();
 643             // Get Klass::_fields
 644             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 645             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
 646             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 647             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 648         }
 649 
 650         private int getAccessFlags() {
 651             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 652         }
 653 
 654         private int getNameIndex() {
 655             return readFieldSlot(config().fieldInfoNameIndexOffset);
 656         }
 657 
 658         private int getSignatureIndex() {
 659             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 660         }
 661 
 662         public int getOffset() {
 663             HotSpotVMConfig config = config();
 664             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 665             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 666             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 667             return offset;
 668         }
 669 
 670         /**
 671          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 672          * on top an array of Java shorts.
 673          */
 674         private int readFieldSlot(int index) {
 675             int offset = Short.BYTES * index;
 676             return UNSAFE.getChar(metaspaceData + offset);
 677         }
 678 
 679         /**
 680          * Returns the name of this field as a {@link String}. If the field is an internal field the
 681          * name index is pointing into the vmSymbols table.
 682          */
 683         public String getName() {
 684             final int nameIndex = getNameIndex();
 685             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 686         }
 687 
 688         /**
 689          * Returns the signature of this field as {@link String}. If the field is an internal field
 690          * the signature index is pointing into the vmSymbols table.
 691          */
 692         public String getSignature() {
 693             final int signatureIndex = getSignatureIndex();
 694             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 695         }
 696 
 697         public JavaType getType() {
 698             String signature = getSignature();
 699             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 700         }
 701 
 702         private boolean isInternal() {
 703             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 704         }
 705 
 706         public boolean isStatic() {
 707             return Modifier.isStatic(getAccessFlags());
 708         }
 709 
 710         public boolean hasGenericSignature() {
 711             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 712         }
 713     }
 714 
 715     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {
 716         public int compare(ResolvedJavaField a, ResolvedJavaField b) {
 717             return a.getOffset() - b.getOffset();
 718         }
 719     }
 720 
 721     @Override
 722     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 723         if (instanceFields == null) {
 724             if (isArray() || isInterface()) {
 725                 instanceFields = NO_FIELDS;
 726             } else {
 727                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 728                 if (getSuperclass() != null) {
 729                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 730                 }
 731                 instanceFields = getFields(false, prepend);
 732             }
 733         }
 734         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 735             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 736             if (superClassFieldCount == instanceFields.length) {
 737                 // This class does not have any instance fields of its own.
 738                 return NO_FIELDS;
 739             } else if (superClassFieldCount != 0) {
 740                 // Fields of the current class can be interleaved with fields of its super-classes
 741                 // but the array of fields to be returned must be sorted by increasing offset
 742                 // This code populates the array, then applies the sorting function
 743                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
 744                 int i = 0;
 745                 for (HotSpotResolvedJavaField f : instanceFields) {
 746                     if (f.getDeclaringClass() == this) {
 747                         result[i++] = f;
 748                     }
 749                 }
 750                 Arrays.sort(result, fieldSortingMethod);
 751                 return result;
 752             } else {
 753                 // The super classes of this class do not have any instance fields.
 754             }
 755         }
 756         return instanceFields;
 757     }
 758 
 759     @Override
 760     public ResolvedJavaField[] getStaticFields() {
 761         if (isArray()) {
 762             return new HotSpotResolvedJavaField[0];
 763         } else {
 764             return getFields(true, NO_FIELDS);
 765         }
 766     }
 767 
 768     /**
 769      * Gets the instance or static fields of this class.
 770      *
 771      * @param retrieveStaticFields specifies whether to return instance or static fields
 772      * @param prepend an array to be prepended to the returned result
 773      */
 774     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
 775         HotSpotVMConfig config = config();
 776         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 777         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 778         int resultCount = 0;
 779         int index = 0;
 780         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 781             FieldInfo field = new FieldInfo(index);
 782             if (field.hasGenericSignature()) {
 783                 metaspaceFieldsLength--;
 784             }
 785 
 786             if (field.isStatic() == retrieveStaticFields) {
 787                 resultCount++;
 788             }
 789         }
 790 
 791         if (resultCount == 0) {
 792             return prepend;
 793         }
 794 
 795         int prependLength = prepend.length;
 796         resultCount += prependLength;
 797 
 798         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 799         if (prependLength != 0) {
 800             System.arraycopy(prepend, 0, result, 0, prependLength);
 801         }
 802 
 803         // Fields of the current class can be interleaved with fields of its super-classes
 804         // but the array of fields to be returned must be sorted by increasing offset
 805         // This code populates the array, then applies the sorting function
 806         int resultIndex = prependLength;
 807         for (int i = 0; i &lt; index; ++i) {
 808             FieldInfo field = new FieldInfo(i);
 809             if (field.isStatic() == retrieveStaticFields) {
 810                 int offset = field.getOffset();
 811                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
 812                 result[resultIndex++] = resolvedJavaField;
 813             }
 814         }
 815         Arrays.sort(result, fieldSortingMethod);
 816         return result;
 817     }
 818 
 819     @Override
 820     public String getSourceFileName() {
 821         if (isArray()) {
 822             return null;
 823         }
 824         return getConstantPool().getSourceFileName();
 825     }
 826 
 827     @Override
 828     public Annotation[] getAnnotations() {
 829         return runtime().reflection.getAnnotations(this);
 830     }
 831 
 832     @Override
 833     public Annotation[] getDeclaredAnnotations() {
 834         return runtime().reflection.getDeclaredAnnotations(this);
 835     }
 836 
 837     @Override
 838     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 839         return runtime().reflection.getAnnotation(this, annotationClass);
 840     }
 841 
 842     /**
 843      * Performs a fast-path check that this type is resolved in the context of a given accessing
 844      * class. A negative result does not mean this type is not resolved with respect to
 845      * {@code accessingClass}. That can only be determined by
 846      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 847      * re-resolving} the type.
 848      */
 849     @Override
 850     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 851         assert accessingClass != null;
 852         ResolvedJavaType elementType = getElementalType();
 853         if (elementType.isPrimitive()) {
 854             // Primitive type resolution is context free.
 855             return true;
 856         }
 857         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {
 858             // Classes in a java.* package defined by the boot class loader are always resolved.
 859             return true;
 860         }
 861         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);
 862         return hasSameClassLoader(otherMirror);
 863     }
 864 
 865     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {
 866         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(
 867                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);
 868     }
 869 
 870     @Override
 871     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 872         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 873             return this;
 874         }
 875         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 876         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 877     }
 878 
 879     /**
 880      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 881      */
 882     @Override
 883     public Constant klass() {
 884         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 885     }
 886 
 887     @Override
 888     public boolean isPrimaryType() {
 889         return config().secondarySuperCacheOffset != superCheckOffset();
 890     }
 891 
 892     @Override
 893     public int superCheckOffset() {
 894         HotSpotVMConfig config = config();
 895         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 896     }
 897 
 898     @Override
 899     public long prototypeMarkWord() {
 900         HotSpotVMConfig config = config();
 901         if (isArray()) {
 902             return config.arrayPrototypeMarkWord();
 903         } else {
 904             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 905         }
 906     }
 907 
 908     @Override
 909     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 910         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 911         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 912     }
 913 
 914     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 915         ResolvedJavaField[] declaredFields = getStaticFields();
 916         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 917     }
 918 
 919     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 920         for (ResolvedJavaField field : declaredFields) {
 921             long resolvedFieldOffset = field.getOffset();
 922             // @formatter:off
 923             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;
 924                     expectedEntryKind.isPrimitive() &amp;&amp;
 925                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 926                     field.getJavaKind().isPrimitive()) {
 927                 resolvedFieldOffset +=
 928                         field.getJavaKind().getByteCount() -
 929                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 930             }
 931             if (resolvedFieldOffset == offset) {
 932                 return field;
 933             }
 934             // @formatter:on
 935         }
 936         return null;
 937     }
 938 
 939     @Override
 940     public boolean isLocal() {
 941         return runtime().reflection.isLocalClass(this);
 942     }
 943 
 944     @Override
 945     public boolean isMember() {
 946         return runtime().reflection.isMemberClass(this);
 947     }
 948 
 949     @Override
 950     public HotSpotResolvedObjectType getEnclosingType() {
 951         return runtime().reflection.getEnclosingClass(this);
 952     }
 953 
 954     @Override
 955     public ResolvedJavaMethod[] getDeclaredConstructors() {
 956         return runtime().compilerToVm.getDeclaredConstructors(this);
 957     }
 958 
 959     @Override
 960     public ResolvedJavaMethod[] getDeclaredMethods() {
 961         return runtime().compilerToVm.getDeclaredMethods(this);
 962     }
 963 
 964     @Override
 965     public ResolvedJavaMethod getClassInitializer() {
 966         if (!isArray()) {
 967             return compilerToVM().getClassInitializer(this);
 968         }
 969         return null;
 970     }
 971 
 972     @Override
 973     public String toString() {
 974         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 975     }
 976 
 977     @Override
 978     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 979         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
 980         if (javaType instanceof ResolvedJavaType) {
 981             return (ResolvedJavaType) javaType;
 982         }
 983         return null;
 984     }
 985 
 986     @Override
 987     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
 988         for (ResolvedJavaField field : getInstanceFields(false)) {
 989             if (field.getName().equals(unresolvedJavaField.getName())) {
 990                 return field;
 991             }
 992         }
 993         for (ResolvedJavaField field : getStaticFields()) {
 994             if (field.getName().equals(unresolvedJavaField.getName())) {
 995                 return field;
 996             }
 997         }
 998         throw new InternalError(unresolvedJavaField.toString());
 999     }
1000 
1001     @Override
1002     public boolean isCloneableWithAllocation() {
1003         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
1004     }
1005 
1006     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {
1007         return runtime().reflection.readFieldValue(this, field, isVolatile);
1008     }
1009 
1010     private int getMiscFlags() {
1011         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
1012     }
1013 
1014     @Override
1015     public boolean isUnsafeAnonymous() {
1016         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
1017     }
1018 
1019 }
    </pre>
  </body>
</html>