<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciFlatArrayKlass.hpp&quot;
  27 #include &quot;ci/ciField.hpp&quot;
  28 #include &quot;ci/ciInlineKlass.hpp&quot;
  29 #include &quot;ci/ciMethodData.hpp&quot;
  30 #include &quot;ci/ciTypeFlow.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/instanceKlass.hpp&quot;
  38 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/typeArrayKlass.hpp&quot;
  41 #include &quot;opto/matcher.hpp&quot;
  42 #include &quot;opto/node.hpp&quot;
  43 #include &quot;opto/opcodes.hpp&quot;
  44 #include &quot;opto/type.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 // Portions of code courtesy of Clifford Click
  48 
  49 // Optimization - Graph Style
  50 
  51 // Dictionary of types shared among compilations.
  52 Dict* Type::_shared_type_dict = NULL;
  53 const Type::Offset Type::Offset::top(Type::OffsetTop);
  54 const Type::Offset Type::Offset::bottom(Type::OffsetBot);
  55 
  56 const Type::Offset Type::Offset::meet(const Type::Offset other) const {
  57   // Either is &#39;TOP&#39; offset?  Return the other offset!
  58   int offset = other._offset;
  59   if (_offset == OffsetTop) return Offset(offset);
  60   if (offset == OffsetTop) return Offset(_offset);
  61   // If either is different, return &#39;BOTTOM&#39; offset
  62   if (_offset != offset) return bottom;
  63   return Offset(_offset);
  64 }
  65 
  66 const Type::Offset Type::Offset::dual() const {
  67   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
  68   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
  69   return Offset(_offset);               // Map everything else into self
  70 }
  71 
  72 const Type::Offset Type::Offset::add(intptr_t offset) const {
  73   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
  74   if (_offset == OffsetTop || offset == OffsetTop) return top;
  75   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
  76   if (_offset == OffsetBot || offset == OffsetBot) return bottom;
  77   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
  78   offset += (intptr_t)_offset;
  79   if (offset != (int)offset || offset == OffsetTop) return bottom;
  80 
  81   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
  82   // It is possible to construct a negative offset during PhaseCCP
  83 
  84   return Offset((int)offset);        // Sum valid offsets
  85 }
  86 
  87 void Type::Offset::dump2(outputStream *st) const {
  88   if (_offset == 0) {
  89     return;
  90   } else if (_offset == OffsetTop) {
  91     st-&gt;print(&quot;+top&quot;);
  92   }
  93   else if (_offset == OffsetBot) {
  94     st-&gt;print(&quot;+bot&quot;);
  95   } else if (_offset) {
  96     st-&gt;print(&quot;+%d&quot;, _offset);
  97   }
  98 }
  99 
 100 // Array which maps compiler types to Basic Types
 101 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 102   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 103   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 104   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 105   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 106   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 107   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 108   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 109   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 110   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 111   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 112 
 113 #if defined(PPC64)
 114   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 115   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 116   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 117   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 118   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 119 #elif defined(S390)
 120   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 121   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 122   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 123   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 124   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 125 #else // all other
 126   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 127   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 128   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 129   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 130   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 131 #endif
 132   { Bad,             T_INLINE_TYPE, &quot;inline:&quot;,      false, Node::NotAMachineReg, relocInfo::none          },  // InlineType
 133   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 134   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 135   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 136   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 137   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 138   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 139   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 140   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 141   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 142   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 143   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 144   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 145   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 146   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 147   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 148   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 149   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 150   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 151 };
 152 
 153 // Map ideal registers (machine types) to ideal types
 154 const Type *Type::mreg2type[_last_machine_leaf];
 155 
 156 // Map basic types to canonical Type* pointers.
 157 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 158 
 159 // Map basic types to constant-zero Types.
 160 const Type* Type::            _zero_type[T_CONFLICT+1];
 161 
 162 // Map basic types to array-body alias types.
 163 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 164 
 165 //=============================================================================
 166 // Convenience common pre-built types.
 167 const Type *Type::ABIO;         // State-of-machine only
 168 const Type *Type::BOTTOM;       // All values
 169 const Type *Type::CONTROL;      // Control only
 170 const Type *Type::DOUBLE;       // All doubles
 171 const Type *Type::FLOAT;        // All floats
 172 const Type *Type::HALF;         // Placeholder half of doublewide type
 173 const Type *Type::MEMORY;       // Abstract store only
 174 const Type *Type::RETURN_ADDRESS;
 175 const Type *Type::TOP;          // No values in set
 176 
 177 //------------------------------get_const_type---------------------------
 178 const Type* Type::get_const_type(ciType* type) {
 179   if (type == NULL) {
 180     return NULL;
 181   } else if (type-&gt;is_primitive_type()) {
 182     return get_const_basic_type(type-&gt;basic_type());
 183   } else {
 184     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 185   }
 186 }
 187 
 188 //---------------------------array_element_basic_type---------------------------------
 189 // Mapping to the array element&#39;s basic type.
 190 BasicType Type::array_element_basic_type() const {
 191   BasicType bt = basic_type();
 192   if (bt == T_INT) {
 193     if (this == TypeInt::INT)   return T_INT;
 194     if (this == TypeInt::CHAR)  return T_CHAR;
 195     if (this == TypeInt::BYTE)  return T_BYTE;
 196     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 197     if (this == TypeInt::SHORT) return T_SHORT;
 198     return T_VOID;
 199   }
 200   return bt;
 201 }
 202 
 203 // For two instance arrays of same dimension, return the base element types.
 204 // Otherwise or if the arrays have different dimensions, return NULL.
 205 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 206                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 207 
 208   if (e1) *e1 = NULL;
 209   if (e2) *e2 = NULL;
 210   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 211   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 212 
 213   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 214     // Handle multidimensional arrays
 215     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 216     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 217     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 218       a1tap = a1tp-&gt;is_aryptr();
 219       a2tap = a2tp-&gt;is_aryptr();
 220       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 221       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 222     }
 223     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 224       if (e1) *e1 = a1tp-&gt;is_instptr();
 225       if (e2) *e2 = a2tp-&gt;is_instptr();
 226     }
 227   }
 228 }
 229 
 230 //---------------------------get_typeflow_type---------------------------------
 231 // Import a type produced by ciTypeFlow.
 232 const Type* Type::get_typeflow_type(ciType* type) {
 233   switch (type-&gt;basic_type()) {
 234 
 235   case ciTypeFlow::StateVector::T_BOTTOM:
 236     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 237     return Type::BOTTOM;
 238 
 239   case ciTypeFlow::StateVector::T_TOP:
 240     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 241     return Type::TOP;
 242 
 243   case ciTypeFlow::StateVector::T_NULL:
 244     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 245     return TypePtr::NULL_PTR;
 246 
 247   case ciTypeFlow::StateVector::T_LONG2:
 248     // The ciTypeFlow pass pushes a long, then the half.
 249     // We do the same.
 250     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 251     return TypeInt::TOP;
 252 
 253   case ciTypeFlow::StateVector::T_DOUBLE2:
 254     // The ciTypeFlow pass pushes double, then the half.
 255     // Our convention is the same.
 256     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 257     return Type::TOP;
 258 
 259   case T_ADDRESS:
 260     assert(type-&gt;is_return_address(), &quot;&quot;);
 261     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 262 
 263   case T_INLINE_TYPE: {
 264     ciInlineKlass* vk = type-&gt;as_inline_klass();
 265     if (vk-&gt;is_scalarizable()) {
 266       return TypeInlineType::make(vk);
 267     } else {
 268       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(TypePtr::NOTNULL);
 269     }
 270   }
 271 
 272   default:
 273     // make sure we did not mix up the cases:
 274     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 275     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 276     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 277     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 278     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 279     assert(!type-&gt;is_return_address(), &quot;&quot;);
 280 
 281     return Type::get_const_type(type);
 282   }
 283 }
 284 
 285 
 286 //-----------------------make_from_constant------------------------------------
 287 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 288                                      int stable_dimension, bool is_narrow_oop,
 289                                      bool is_autobox_cache) {
 290   switch (constant.basic_type()) {
 291     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 292     case T_CHAR:     return TypeInt::make(constant.as_char());
 293     case T_BYTE:     return TypeInt::make(constant.as_byte());
 294     case T_SHORT:    return TypeInt::make(constant.as_short());
 295     case T_INT:      return TypeInt::make(constant.as_int());
 296     case T_LONG:     return TypeLong::make(constant.as_long());
 297     case T_FLOAT:    return TypeF::make(constant.as_float());
 298     case T_DOUBLE:   return TypeD::make(constant.as_double());
 299     case T_ARRAY:
 300     case T_INLINE_TYPE:
 301     case T_OBJECT: {
 302         const Type* con_type = NULL;
 303         ciObject* oop_constant = constant.as_object();
 304         if (oop_constant-&gt;is_null_object()) {
 305           con_type = Type::get_zero_type(T_OBJECT);
 306         } else {
 307           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 308           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 309           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 310             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 311           }
 312           if (stable_dimension &gt; 0) {
 313             assert(FoldStableValues, &quot;sanity&quot;);
 314             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 315             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 316           }
 317         }
 318         if (is_narrow_oop) {
 319           con_type = con_type-&gt;make_narrowoop();
 320         }
 321         return con_type;
 322       }
 323     case T_ILLEGAL:
 324       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 325       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 326       return NULL;
 327     default:
 328       // Fall through to failure
 329       return NULL;
 330   }
 331 }
 332 
 333 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 334   BasicType conbt = con.basic_type();
 335   switch (conbt) {
 336     case T_BOOLEAN: conbt = T_BYTE;   break;
 337     case T_ARRAY:   conbt = T_OBJECT; break;
 338     case T_INLINE_TYPE: conbt = T_OBJECT; break;
 339     default:                          break;
 340   }
 341   switch (loadbt) {
 342     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 343     case T_NARROWOOP: loadbt = T_OBJECT; break;
 344     case T_ARRAY:     loadbt = T_OBJECT; break;
 345     case T_INLINE_TYPE: loadbt = T_OBJECT; break;
 346     case T_ADDRESS:   loadbt = T_OBJECT; break;
 347     default:                             break;
 348   }
 349   if (conbt == loadbt) {
 350     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 351       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 352       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 353     } else {
 354       return con;
 355     }
 356   }
 357   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 358     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 359     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 360   }
 361   return ciConstant(); // T_ILLEGAL
 362 }
 363 
 364 // Try to constant-fold a stable array element.
 365 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 366                                                    BasicType loadbt, bool is_unsigned_load) {
 367   // Decode the results of GraphKit::array_element_address.
 368   ciConstant element_value = array-&gt;element_value_by_offset(off);
 369   if (element_value.basic_type() == T_ILLEGAL) {
 370     return NULL; // wrong offset
 371   }
 372   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 373 
 374   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 375          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 376 
 377   if (con.is_valid() &amp;&amp;          // not a mismatched access
 378       !con.is_null_or_zero()) {  // not a default value
 379     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 380     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 381   }
 382   return NULL;
 383 }
 384 
 385 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 386   ciField* field;
 387   ciType* type = holder-&gt;java_mirror_type();
 388   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 389     // Static field
 390     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 391   } else {
 392     // Instance field
 393     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 394   }
 395   if (field == NULL) {
 396     return NULL; // Wrong offset
 397   }
 398   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 399 }
 400 
 401 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 402                                            BasicType loadbt, bool is_unsigned_load) {
 403   if (!field-&gt;is_constant()) {
 404     return NULL; // Non-constant field
 405   }
 406   ciConstant field_value;
 407   if (field-&gt;is_static()) {
 408     // final static field
 409     field_value = field-&gt;constant_value();
 410   } else if (holder != NULL) {
 411     // final or stable non-static field
 412     // Treat final non-static fields of trusted classes (classes in
 413     // java.lang.invoke and sun.invoke packages and subpackages) as
 414     // compile time constants.
 415     field_value = field-&gt;constant_value_of(holder);
 416   }
 417   if (!field_value.is_valid()) {
 418     return NULL; // Not a constant
 419   }
 420 
 421   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 422 
 423   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 424          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 425 
 426   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 427   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 428   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 429 
 430   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 431                                             stable_dimension, is_narrow_oop,
 432                                             field-&gt;is_autobox_cache());
 433   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 434     ciCallSite* call_site = holder-&gt;as_call_site();
 435     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 436       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 437       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 438     }
 439   }
 440   return con_type;
 441 }
 442 
 443 //------------------------------make-------------------------------------------
 444 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 445 // and look for an existing copy in the type dictionary.
 446 const Type *Type::make( enum TYPES t ) {
 447   return (new Type(t))-&gt;hashcons();
 448 }
 449 
 450 //------------------------------cmp--------------------------------------------
 451 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 452   if( t1-&gt;_base != t2-&gt;_base )
 453     return 1;                   // Missed badly
 454   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 455   return !t1-&gt;eq(t2);           // Return ZERO if equal
 456 }
 457 
 458 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 459   if (!include_speculative) {
 460     return remove_speculative();
 461   }
 462   return this;
 463 }
 464 
 465 //------------------------------hash-------------------------------------------
 466 int Type::uhash( const Type *const t ) {
 467   return t-&gt;hash();
 468 }
 469 
 470 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 471 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 472 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 473 
 474 //--------------------------Initialize_shared----------------------------------
 475 void Type::Initialize_shared(Compile* current) {
 476   // This method does not need to be locked because the first system
 477   // compilations (stub compilations) occur serially.  If they are
 478   // changed to proceed in parallel, then this section will need
 479   // locking.
 480 
 481   Arena* save = current-&gt;type_arena();
 482   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 483 
 484   current-&gt;set_type_arena(shared_type_arena);
 485   _shared_type_dict =
 486     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 487                                   shared_type_arena, 128 );
 488   current-&gt;set_type_dict(_shared_type_dict);
 489 
 490   // Make shared pre-built types.
 491   CONTROL = make(Control);      // Control only
 492   TOP     = make(Top);          // No values in set
 493   MEMORY  = make(Memory);       // Abstract store only
 494   ABIO    = make(Abio);         // State-of-machine only
 495   RETURN_ADDRESS=make(Return_Address);
 496   FLOAT   = make(FloatBot);     // All floats
 497   DOUBLE  = make(DoubleBot);    // All doubles
 498   BOTTOM  = make(Bottom);       // Everything
 499   HALF    = make(Half);         // Placeholder half of doublewide type
 500 
 501   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 502   TypeF::ONE  = TypeF::make(1.0); // Float 1
 503   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 504   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 505 
 506   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 507   TypeD::ONE  = TypeD::make(1.0); // Double 1
 508   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 509   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 510 
 511   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 512   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 513   TypeInt::ONE     = TypeInt::make( 1);  //  1
 514   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 515   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 516   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 517   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 518   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 519   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 520   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 521   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 522   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 523   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 524   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 525   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 526   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 527   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 528   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 529   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 530   // CmpL is overloaded both as the bytecode computation returning
 531   // a trinary (-1,0,+1) integer result AND as an efficient long
 532   // compare returning optimizer ideal-type flags.
 533   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 534   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 535   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 536   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 537   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 538 
 539   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 540   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 541   TypeLong::ONE     = TypeLong::make( 1);        //  1
 542   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 543   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 544   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 545   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 546   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 547 
 548   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 549   fboth[0] = Type::CONTROL;
 550   fboth[1] = Type::CONTROL;
 551   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 552 
 553   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 554   ffalse[0] = Type::CONTROL;
 555   ffalse[1] = Type::TOP;
 556   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 557 
 558   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 559   fneither[0] = Type::TOP;
 560   fneither[1] = Type::TOP;
 561   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 562 
 563   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 564   ftrue[0] = Type::TOP;
 565   ftrue[1] = Type::CONTROL;
 566   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 567 
 568   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 569   floop[0] = Type::CONTROL;
 570   floop[1] = TypeInt::INT;
 571   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 572 
 573   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 574   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 575   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 576 
 577   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 578   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 579 
 580   const Type **fmembar = TypeTuple::fields(0);
 581   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 582 
 583   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 584   fsc[0] = TypeInt::CC;
 585   fsc[1] = Type::MEMORY;
 586   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 587 
 588   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 589   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 590   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 591   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 592                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 593   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 594                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 595   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 596 
 597   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 598 
 599   TypeInlineType::BOTTOM = TypeInlineType::make(NULL);
 600 
 601   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 602   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 603 
 604   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 605 
 606   mreg2type[Op_Node] = Type::BOTTOM;
 607   mreg2type[Op_Set ] = 0;
 608   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 609   mreg2type[Op_RegI] = TypeInt::INT;
 610   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 611   mreg2type[Op_RegF] = Type::FLOAT;
 612   mreg2type[Op_RegD] = Type::DOUBLE;
 613   mreg2type[Op_RegL] = TypeLong::LONG;
 614   mreg2type[Op_RegFlags] = TypeInt::CC;
 615 
 616   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 617 
 618   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 619 
 620 #ifdef _LP64
 621   if (UseCompressedOops) {
 622     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 623     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 624   } else
 625 #endif
 626   {
 627     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 628     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 629   }
 630   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 631   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 632   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 633   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 634   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 635   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 636   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 637   TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 638 
 639   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 640   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 641   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 642   TypeAryPtr::_array_body_type[T_INLINE_TYPE] = TypeAryPtr::OOPS;
 643   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 644   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 645   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 646   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 647   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 648   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 649   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 650   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 651   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 652 
 653   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 654   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 655 
 656   const Type **fi2c = TypeTuple::fields(2);
 657   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 658   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 659   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 660 
 661   const Type **intpair = TypeTuple::fields(2);
 662   intpair[0] = TypeInt::INT;
 663   intpair[1] = TypeInt::INT;
 664   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 665 
 666   const Type **longpair = TypeTuple::fields(2);
 667   longpair[0] = TypeLong::LONG;
 668   longpair[1] = TypeLong::LONG;
 669   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 670 
 671   const Type **intccpair = TypeTuple::fields(2);
 672   intccpair[0] = TypeInt::INT;
 673   intccpair[1] = TypeInt::CC;
 674   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 675 
 676   const Type **longccpair = TypeTuple::fields(2);
 677   longccpair[0] = TypeLong::LONG;
 678   longccpair[1] = TypeInt::CC;
 679   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 680 
 681   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 682   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 683   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 684   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 685   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 686   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 687   _const_basic_type[T_INT]         = TypeInt::INT;
 688   _const_basic_type[T_LONG]        = TypeLong::LONG;
 689   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 690   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 691   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 692   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 693   _const_basic_type[T_INLINE_TYPE] = TypeInstPtr::BOTTOM;
 694   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 695   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 696   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 697 
 698   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 699   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 700   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 701   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 702   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 703   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 704   _zero_type[T_INT]         = TypeInt::ZERO;
 705   _zero_type[T_LONG]        = TypeLong::ZERO;
 706   _zero_type[T_FLOAT]       = TypeF::ZERO;
 707   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 708   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 709   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 710   _zero_type[T_INLINE_TYPE] = TypePtr::NULL_PTR;
 711   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 712   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 713 
 714   // get_zero_type() should not happen for T_CONFLICT
 715   _zero_type[T_CONFLICT]= NULL;
 716 
 717   // Vector predefined types, it needs initialized _const_basic_type[].
 718   if (Matcher::vector_size_supported(T_BYTE,4)) {
 719     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 720   }
 721   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 722     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 723   }
 724   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 725     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 728     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 731     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 732   }
 733   mreg2type[Op_VecS] = TypeVect::VECTS;
 734   mreg2type[Op_VecD] = TypeVect::VECTD;
 735   mreg2type[Op_VecX] = TypeVect::VECTX;
 736   mreg2type[Op_VecY] = TypeVect::VECTY;
 737   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 738 
 739   // Restore working type arena.
 740   current-&gt;set_type_arena(save);
 741   current-&gt;set_type_dict(NULL);
 742 }
 743 
 744 //------------------------------Initialize-------------------------------------
 745 void Type::Initialize(Compile* current) {
 746   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 747 
 748   if (_shared_type_dict == NULL) {
 749     Initialize_shared(current);
 750   }
 751 
 752   Arena* type_arena = current-&gt;type_arena();
 753 
 754   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 755   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 756   current-&gt;set_type_dict(tdic);
 757 
 758   // Transfer the shared types.
 759   DictI i(_shared_type_dict);
 760   for( ; i.test(); ++i ) {
 761     Type* t = (Type*)i._value;
 762     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 763   }
 764 }
 765 
 766 //------------------------------hashcons---------------------------------------
 767 // Do the hash-cons trick.  If the Type already exists in the type table,
 768 // delete the current Type and return the existing Type.  Otherwise stick the
 769 // current Type in the Type table.
 770 const Type *Type::hashcons(void) {
 771   debug_only(base());           // Check the assertion in Type::base().
 772   // Look up the Type in the Type dictionary
 773   Dict *tdic = type_dict();
 774   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 775   if( old ) {                   // Pre-existing Type?
 776     if( old != this )           // Yes, this guy is not the pre-existing?
 777       delete this;              // Yes, Nuke this guy
 778     assert( old-&gt;_dual, &quot;&quot; );
 779     return old;                 // Return pre-existing
 780   }
 781 
 782   // Every type has a dual (to make my lattice symmetric).
 783   // Since we just discovered a new Type, compute its dual right now.
 784   assert( !_dual, &quot;&quot; );         // No dual yet
 785   _dual = xdual();              // Compute the dual
 786   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 787     if (_dual != this) {
 788       delete _dual;
 789       _dual = this;
 790     }
 791     return this;
 792   }
 793   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 794   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 795   // New Type, insert into Type table
 796   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 797   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 798 #ifdef ASSERT
 799   Type *dual_dual = (Type*)_dual-&gt;xdual();
 800   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 801   delete dual_dual;
 802 #endif
 803   return this;                  // Return new Type
 804 }
 805 
 806 //------------------------------eq---------------------------------------------
 807 // Structural equality check for Type representations
 808 bool Type::eq( const Type * ) const {
 809   return true;                  // Nothing else can go wrong
 810 }
 811 
 812 //------------------------------hash-------------------------------------------
 813 // Type-specific hashing function.
 814 int Type::hash(void) const {
 815   return _base;
 816 }
 817 
 818 //------------------------------is_finite--------------------------------------
 819 // Has a finite value
 820 bool Type::is_finite() const {
 821   return false;
 822 }
 823 
 824 //------------------------------is_nan-----------------------------------------
 825 // Is not a number (NaN)
 826 bool Type::is_nan()    const {
 827   return false;
 828 }
 829 
 830 //----------------------interface_vs_oop---------------------------------------
 831 #ifdef ASSERT
 832 bool Type::interface_vs_oop_helper(const Type *t) const {
 833   bool result = false;
 834 
 835   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 836   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 837   if( this_ptr == NULL || t_ptr == NULL )
 838     return result;
 839 
 840   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 841   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 842   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 843     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 844     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 845     result = this_interface ^ t_interface;
 846   }
 847 
 848   return result;
 849 }
 850 
 851 bool Type::interface_vs_oop(const Type *t) const {
 852   if (interface_vs_oop_helper(t)) {
 853     return true;
 854   }
 855   // Now check the speculative parts as well
 856   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 857   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 858   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 859     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 860       return true;
 861     }
 862     return false;
 863   }
 864   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 865     return true;
 866   }
 867   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 868     return true;
 869   }
 870   return false;
 871 }
 872 
 873 #endif
 874 
 875 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 876 #ifdef ASSERT
 877   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 878   const Type* dual_join = mt-&gt;_dual;
 879   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 880   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 881 
 882   // Interface meet Oop is Not Symmetric:
 883   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 884   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 885 
 886   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {
 887     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 888     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 889     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 890     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 891 
 892     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 893     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 894     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 895 
 896     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 897     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 898 
 899     fatal(&quot;meet not symmetric&quot; );
 900   }
 901 #endif
 902 }
 903 
 904 //------------------------------meet-------------------------------------------
 905 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 906 // commutative and the lattice is symmetric.
 907 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 908   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 909     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 910     return result-&gt;make_narrowoop();
 911   }
 912   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 913     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 914     return result-&gt;make_narrowklass();
 915   }
 916 
 917   const Type *this_t = maybe_remove_speculative(include_speculative);
 918   t = t-&gt;maybe_remove_speculative(include_speculative);
 919 
 920   const Type *mt = this_t-&gt;xmeet(t);
 921 #ifdef ASSERT
 922   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 923   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 924   Compile* C = Compile::current();
 925   if (!C-&gt;_type_verify_symmetry) {
 926     return mt;
 927   }
 928   this_t-&gt;check_symmetrical(t, mt);
 929   // In the case of an array, computing the meet above, caused the
 930   // computation of the meet of the elements which at verification
 931   // time caused the computation of the meet of the dual of the
 932   // elements. Computing the meet of the dual of the arrays here
 933   // causes the meet of the dual of the elements to be computed which
 934   // would cause the meet of the dual of the dual of the elements,
 935   // that is the meet of the elements already computed above to be
 936   // computed. Avoid redundant computations by requesting no
 937   // verification.
 938   C-&gt;_type_verify_symmetry = false;
 939   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);
 940   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);
 941   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);
 942   C-&gt;_type_verify_symmetry = true;
 943 #endif
 944   return mt;
 945 }
 946 
 947 //------------------------------xmeet------------------------------------------
 948 // Compute the MEET of two types.  It returns a new Type object.
 949 const Type *Type::xmeet( const Type *t ) const {
 950   // Perform a fast test for common case; meeting the same types together.
 951   if( this == t ) return this;  // Meeting same type-rep?
 952 
 953   // Meeting TOP with anything?
 954   if( _base == Top ) return t;
 955 
 956   // Meeting BOTTOM with anything?
 957   if( _base == Bottom ) return BOTTOM;
 958 
 959   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 960   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 961   switch (t-&gt;base()) {  // Switch on original type
 962 
 963   // Cut in half the number of cases I must handle.  Only need cases for when
 964   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 965   case FloatCon:
 966   case DoubleCon:
 967   case Int:
 968   case Long:
 969     return t-&gt;xmeet(this);
 970 
 971   case OopPtr:
 972     return t-&gt;xmeet(this);
 973 
 974   case InstPtr:
 975     return t-&gt;xmeet(this);
 976 
 977   case MetadataPtr:
 978   case KlassPtr:
 979     return t-&gt;xmeet(this);
 980 
 981   case AryPtr:
 982     return t-&gt;xmeet(this);
 983 
 984   case NarrowOop:
 985     return t-&gt;xmeet(this);
 986 
 987   case NarrowKlass:
 988     return t-&gt;xmeet(this);
 989 
 990   case InlineType:
 991     return t-&gt;xmeet(this);
 992 
 993   case Bad:                     // Type check
 994   default:                      // Bogus type not in lattice
 995     typerr(t);
 996     return Type::BOTTOM;
 997 
 998   case Bottom:                  // Ye Olde Default
 999     return t;
1000 
1001   case FloatTop:
1002     if( _base == FloatTop ) return this;
1003   case FloatBot:                // Float
1004     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1005     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1006     typerr(t);
1007     return Type::BOTTOM;
1008 
1009   case DoubleTop:
1010     if( _base == DoubleTop ) return this;
1011   case DoubleBot:               // Double
1012     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
1013     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
1014     typerr(t);
1015     return Type::BOTTOM;
1016 
1017   // These next few cases must match exactly or it is a compile-time error.
1018   case Control:                 // Control of code
1019   case Abio:                    // State of world outside of program
1020   case Memory:
1021     if( _base == t-&gt;_base )  return this;
1022     typerr(t);
1023     return Type::BOTTOM;
1024 
1025   case Top:                     // Top of the lattice
1026     return this;
1027   }
1028 
1029   // The type is unchanged
1030   return this;
1031 }
1032 
1033 //-----------------------------filter------------------------------------------
1034 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
1035   const Type* ft = join_helper(kills, include_speculative);
1036   if (ft-&gt;empty())
1037     return Type::TOP;           // Canonical empty value
1038   return ft;
1039 }
1040 
1041 //------------------------------xdual------------------------------------------
1042 // Compute dual right now.
1043 const Type::TYPES Type::dual_type[Type::lastype] = {
1044   Bad,          // Bad
1045   Control,      // Control
1046   Bottom,       // Top
1047   Bad,          // Int - handled in v-call
1048   Bad,          // Long - handled in v-call
1049   Half,         // Half
1050   Bad,          // NarrowOop - handled in v-call
1051   Bad,          // NarrowKlass - handled in v-call
1052 
1053   Bad,          // Tuple - handled in v-call
1054   Bad,          // Array - handled in v-call
1055   Bad,          // VectorS - handled in v-call
1056   Bad,          // VectorD - handled in v-call
1057   Bad,          // VectorX - handled in v-call
1058   Bad,          // VectorY - handled in v-call
1059   Bad,          // VectorZ - handled in v-call
1060   Bad,          // InlineType - handled in v-call
1061 
1062   Bad,          // AnyPtr - handled in v-call
1063   Bad,          // RawPtr - handled in v-call
1064   Bad,          // OopPtr - handled in v-call
1065   Bad,          // InstPtr - handled in v-call
1066   Bad,          // AryPtr - handled in v-call
1067 
1068   Bad,          //  MetadataPtr - handled in v-call
1069   Bad,          // KlassPtr - handled in v-call
1070 
1071   Bad,          // Function - handled in v-call
1072   Abio,         // Abio
1073   Return_Address,// Return_Address
1074   Memory,       // Memory
1075   FloatBot,     // FloatTop
1076   FloatCon,     // FloatCon
1077   FloatTop,     // FloatBot
1078   DoubleBot,    // DoubleTop
1079   DoubleCon,    // DoubleCon
1080   DoubleTop,    // DoubleBot
1081   Top           // Bottom
1082 };
1083 
1084 const Type *Type::xdual() const {
1085   // Note: the base() accessor asserts the sanity of _base.
1086   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1087   return new Type(_type_info[_base].dual_type);
1088 }
1089 
1090 //------------------------------has_memory-------------------------------------
1091 bool Type::has_memory() const {
1092   Type::TYPES tx = base();
1093   if (tx == Memory) return true;
1094   if (tx == Tuple) {
1095     const TypeTuple *t = is_tuple();
1096     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1097       tx = t-&gt;field_at(i)-&gt;base();
1098       if (tx == Memory)  return true;
1099     }
1100   }
1101   return false;
1102 }
1103 
1104 #ifndef PRODUCT
1105 //------------------------------dump2------------------------------------------
1106 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1107   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1108 }
1109 
1110 //------------------------------dump-------------------------------------------
1111 void Type::dump_on(outputStream *st) const {
1112   ResourceMark rm;
1113   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1114   dump2(d,1, st);
1115   if (is_ptr_to_narrowoop()) {
1116     st-&gt;print(&quot; [narrow]&quot;);
1117   } else if (is_ptr_to_narrowklass()) {
1118     st-&gt;print(&quot; [narrowklass]&quot;);
1119   }
1120 }
1121 
1122 //-----------------------------------------------------------------------------
1123 const char* Type::str(const Type* t) {
1124   stringStream ss;
1125   t-&gt;dump_on(&amp;ss);
1126   return ss.as_string();
1127 }
1128 #endif
1129 
1130 //------------------------------singleton--------------------------------------
1131 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1132 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1133 bool Type::singleton(void) const {
1134   return _base == Top || _base == Half;
1135 }
1136 
1137 //------------------------------empty------------------------------------------
1138 // TRUE if Type is a type with no values, FALSE otherwise.
1139 bool Type::empty(void) const {
1140   switch (_base) {
1141   case DoubleTop:
1142   case FloatTop:
1143   case Top:
1144     return true;
1145 
1146   case Half:
1147   case Abio:
1148   case Return_Address:
1149   case Memory:
1150   case Bottom:
1151   case FloatBot:
1152   case DoubleBot:
1153     return false;  // never a singleton, therefore never empty
1154 
1155   default:
1156     ShouldNotReachHere();
1157     return false;
1158   }
1159 }
1160 
1161 //------------------------------dump_stats-------------------------------------
1162 // Dump collected statistics to stderr
1163 #ifndef PRODUCT
1164 void Type::dump_stats() {
1165   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1166 }
1167 #endif
1168 
1169 //------------------------------typerr-----------------------------------------
1170 void Type::typerr( const Type *t ) const {
1171 #ifndef PRODUCT
1172   tty-&gt;print(&quot;\nError mixing types: &quot;);
1173   dump();
1174   tty-&gt;print(&quot; and &quot;);
1175   t-&gt;dump();
1176   tty-&gt;print(&quot;\n&quot;);
1177 #endif
1178   ShouldNotReachHere();
1179 }
1180 
1181 
1182 //=============================================================================
1183 // Convenience common pre-built types.
1184 const TypeF *TypeF::ZERO;       // Floating point zero
1185 const TypeF *TypeF::ONE;        // Floating point one
1186 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1187 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1188 
1189 //------------------------------make-------------------------------------------
1190 // Create a float constant
1191 const TypeF *TypeF::make(float f) {
1192   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1193 }
1194 
1195 //------------------------------meet-------------------------------------------
1196 // Compute the MEET of two types.  It returns a new Type object.
1197 const Type *TypeF::xmeet( const Type *t ) const {
1198   // Perform a fast test for common case; meeting the same types together.
1199   if( this == t ) return this;  // Meeting same type-rep?
1200 
1201   // Current &quot;this-&gt;_base&quot; is FloatCon
1202   switch (t-&gt;base()) {          // Switch on original type
1203   case AnyPtr:                  // Mixing with oops happens when javac
1204   case RawPtr:                  // reuses local variables
1205   case OopPtr:
1206   case InstPtr:
1207   case AryPtr:
1208   case MetadataPtr:
1209   case KlassPtr:
1210   case NarrowOop:
1211   case NarrowKlass:
1212   case Int:
1213   case Long:
1214   case DoubleTop:
1215   case DoubleCon:
1216   case DoubleBot:
1217   case Bottom:                  // Ye Olde Default
1218     return Type::BOTTOM;
1219 
1220   case FloatBot:
1221     return t;
1222 
1223   default:                      // All else is a mistake
1224     typerr(t);
1225 
1226   case FloatCon:                // Float-constant vs Float-constant?
1227     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1228                                 // must compare bitwise as positive zero, negative zero and NaN have
1229                                 // all the same representation in C++
1230       return FLOAT;             // Return generic float
1231                                 // Equal constants
1232   case Top:
1233   case FloatTop:
1234     break;                      // Return the float constant
1235   }
1236   return this;                  // Return the float constant
1237 }
1238 
1239 //------------------------------xdual------------------------------------------
1240 // Dual: symmetric
1241 const Type *TypeF::xdual() const {
1242   return this;
1243 }
1244 
1245 //------------------------------eq---------------------------------------------
1246 // Structural equality check for Type representations
1247 bool TypeF::eq(const Type *t) const {
1248   // Bitwise comparison to distinguish between +/-0. These values must be treated
1249   // as different to be consistent with C1 and the interpreter.
1250   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1251 }
1252 
1253 //------------------------------hash-------------------------------------------
1254 // Type-specific hashing function.
1255 int TypeF::hash(void) const {
1256   return *(int*)(&amp;_f);
1257 }
1258 
1259 //------------------------------is_finite--------------------------------------
1260 // Has a finite value
1261 bool TypeF::is_finite() const {
1262   return g_isfinite(getf()) != 0;
1263 }
1264 
1265 //------------------------------is_nan-----------------------------------------
1266 // Is not a number (NaN)
1267 bool TypeF::is_nan()    const {
1268   return g_isnan(getf()) != 0;
1269 }
1270 
1271 //------------------------------dump2------------------------------------------
1272 // Dump float constant Type
1273 #ifndef PRODUCT
1274 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1275   Type::dump2(d,depth, st);
1276   st-&gt;print(&quot;%f&quot;, _f);
1277 }
1278 #endif
1279 
1280 //------------------------------singleton--------------------------------------
1281 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1282 // constants (Ldi nodes).  Singletons are integer, float or double constants
1283 // or a single symbol.
1284 bool TypeF::singleton(void) const {
1285   return true;                  // Always a singleton
1286 }
1287 
1288 bool TypeF::empty(void) const {
1289   return false;                 // always exactly a singleton
1290 }
1291 
1292 //=============================================================================
1293 // Convenience common pre-built types.
1294 const TypeD *TypeD::ZERO;       // Floating point zero
1295 const TypeD *TypeD::ONE;        // Floating point one
1296 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1297 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1298 
1299 //------------------------------make-------------------------------------------
1300 const TypeD *TypeD::make(double d) {
1301   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1302 }
1303 
1304 //------------------------------meet-------------------------------------------
1305 // Compute the MEET of two types.  It returns a new Type object.
1306 const Type *TypeD::xmeet( const Type *t ) const {
1307   // Perform a fast test for common case; meeting the same types together.
1308   if( this == t ) return this;  // Meeting same type-rep?
1309 
1310   // Current &quot;this-&gt;_base&quot; is DoubleCon
1311   switch (t-&gt;base()) {          // Switch on original type
1312   case AnyPtr:                  // Mixing with oops happens when javac
1313   case RawPtr:                  // reuses local variables
1314   case OopPtr:
1315   case InstPtr:
1316   case AryPtr:
1317   case MetadataPtr:
1318   case KlassPtr:
1319   case NarrowOop:
1320   case NarrowKlass:
1321   case Int:
1322   case Long:
1323   case FloatTop:
1324   case FloatCon:
1325   case FloatBot:
1326   case Bottom:                  // Ye Olde Default
1327     return Type::BOTTOM;
1328 
1329   case DoubleBot:
1330     return t;
1331 
1332   default:                      // All else is a mistake
1333     typerr(t);
1334 
1335   case DoubleCon:               // Double-constant vs Double-constant?
1336     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1337       return DOUBLE;            // Return generic double
1338   case Top:
1339   case DoubleTop:
1340     break;
1341   }
1342   return this;                  // Return the double constant
1343 }
1344 
1345 //------------------------------xdual------------------------------------------
1346 // Dual: symmetric
1347 const Type *TypeD::xdual() const {
1348   return this;
1349 }
1350 
1351 //------------------------------eq---------------------------------------------
1352 // Structural equality check for Type representations
1353 bool TypeD::eq(const Type *t) const {
1354   // Bitwise comparison to distinguish between +/-0. These values must be treated
1355   // as different to be consistent with C1 and the interpreter.
1356   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1357 }
1358 
1359 //------------------------------hash-------------------------------------------
1360 // Type-specific hashing function.
1361 int TypeD::hash(void) const {
1362   return *(int*)(&amp;_d);
1363 }
1364 
1365 //------------------------------is_finite--------------------------------------
1366 // Has a finite value
1367 bool TypeD::is_finite() const {
1368   return g_isfinite(getd()) != 0;
1369 }
1370 
1371 //------------------------------is_nan-----------------------------------------
1372 // Is not a number (NaN)
1373 bool TypeD::is_nan()    const {
1374   return g_isnan(getd()) != 0;
1375 }
1376 
1377 //------------------------------dump2------------------------------------------
1378 // Dump double constant Type
1379 #ifndef PRODUCT
1380 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1381   Type::dump2(d,depth,st);
1382   st-&gt;print(&quot;%f&quot;, _d);
1383 }
1384 #endif
1385 
1386 //------------------------------singleton--------------------------------------
1387 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1388 // constants (Ldi nodes).  Singletons are integer, float or double constants
1389 // or a single symbol.
1390 bool TypeD::singleton(void) const {
1391   return true;                  // Always a singleton
1392 }
1393 
1394 bool TypeD::empty(void) const {
1395   return false;                 // always exactly a singleton
1396 }
1397 
1398 //=============================================================================
1399 // Convience common pre-built types.
1400 const TypeInt *TypeInt::MINUS_1;// -1
1401 const TypeInt *TypeInt::ZERO;   // 0
1402 const TypeInt *TypeInt::ONE;    // 1
1403 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1404 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1405 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1406 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1407 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1408 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1409 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1410 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1411 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1412 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1413 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1414 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1415 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1416 const TypeInt *TypeInt::INT;    // 32-bit integers
1417 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1418 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1419 
1420 //------------------------------TypeInt----------------------------------------
1421 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1422 }
1423 
1424 //------------------------------make-------------------------------------------
1425 const TypeInt *TypeInt::make( jint lo ) {
1426   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1427 }
1428 
1429 static int normalize_int_widen( jint lo, jint hi, int w ) {
1430   // Certain normalizations keep us sane when comparing types.
1431   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1432   if (lo &lt;= hi) {
1433     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1434     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1435   } else {
1436     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1437     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1438   }
1439   return w;
1440 }
1441 
1442 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1443   w = normalize_int_widen(lo, hi, w);
1444   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1445 }
1446 
1447 //------------------------------meet-------------------------------------------
1448 // Compute the MEET of two types.  It returns a new Type representation object
1449 // with reference count equal to the number of Types pointing at it.
1450 // Caller should wrap a Types around it.
1451 const Type *TypeInt::xmeet( const Type *t ) const {
1452   // Perform a fast test for common case; meeting the same types together.
1453   if( this == t ) return this;  // Meeting same type?
1454 
1455   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1456   switch (t-&gt;base()) {          // Switch on original type
1457   case AnyPtr:                  // Mixing with oops happens when javac
1458   case RawPtr:                  // reuses local variables
1459   case OopPtr:
1460   case InstPtr:
1461   case AryPtr:
1462   case MetadataPtr:
1463   case KlassPtr:
1464   case NarrowOop:
1465   case NarrowKlass:
1466   case Long:
1467   case FloatTop:
1468   case FloatCon:
1469   case FloatBot:
1470   case DoubleTop:
1471   case DoubleCon:
1472   case DoubleBot:
1473   case Bottom:                  // Ye Olde Default
1474     return Type::BOTTOM;
1475   default:                      // All else is a mistake
1476     typerr(t);
1477   case Top:                     // No change
1478     return this;
1479   case Int:                     // Int vs Int?
1480     break;
1481   }
1482 
1483   // Expand covered set
1484   const TypeInt *r = t-&gt;is_int();
1485   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1486 }
1487 
1488 //------------------------------xdual------------------------------------------
1489 // Dual: reverse hi &amp; lo; flip widen
1490 const Type *TypeInt::xdual() const {
1491   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1492   return new TypeInt(_hi,_lo,w);
1493 }
1494 
1495 //------------------------------widen------------------------------------------
1496 // Only happens for optimistic top-down optimizations.
1497 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1498   // Coming from TOP or such; no widening
1499   if( old-&gt;base() != Int ) return this;
1500   const TypeInt *ot = old-&gt;is_int();
1501 
1502   // If new guy is equal to old guy, no widening
1503   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1504     return old;
1505 
1506   // If new guy contains old, then we widened
1507   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1508     // New contains old
1509     // If new guy is already wider than old, no widening
1510     if( _widen &gt; ot-&gt;_widen ) return this;
1511     // If old guy was a constant, do not bother
1512     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1513     // Now widen new guy.
1514     // Check for widening too far
1515     if (_widen == WidenMax) {
1516       int max = max_jint;
1517       int min = min_jint;
1518       if (limit-&gt;isa_int()) {
1519         max = limit-&gt;is_int()-&gt;_hi;
1520         min = limit-&gt;is_int()-&gt;_lo;
1521       }
1522       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1523         // If neither endpoint is extremal yet, push out the endpoint
1524         // which is closer to its respective limit.
1525         if (_lo &gt;= 0 ||                 // easy common case
1526             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1527           // Try to widen to an unsigned range type of 31 bits:
1528           return make(_lo, max, WidenMax);
1529         } else {
1530           return make(min, _hi, WidenMax);
1531         }
1532       }
1533       return TypeInt::INT;
1534     }
1535     // Returned widened new guy
1536     return make(_lo,_hi,_widen+1);
1537   }
1538 
1539   // If old guy contains new, then we probably widened too far &amp; dropped to
1540   // bottom.  Return the wider fellow.
1541   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1542     return old;
1543 
1544   //fatal(&quot;Integer value range is not subset&quot;);
1545   //return this;
1546   return TypeInt::INT;
1547 }
1548 
1549 //------------------------------narrow---------------------------------------
1550 // Only happens for pessimistic optimizations.
1551 const Type *TypeInt::narrow( const Type *old ) const {
1552   if (_lo &gt;= _hi)  return this;   // already narrow enough
1553   if (old == NULL)  return this;
1554   const TypeInt* ot = old-&gt;isa_int();
1555   if (ot == NULL)  return this;
1556   jint olo = ot-&gt;_lo;
1557   jint ohi = ot-&gt;_hi;
1558 
1559   // If new guy is equal to old guy, no narrowing
1560   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1561 
1562   // If old guy was maximum range, allow the narrowing
1563   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1564 
1565   if (_lo &lt; olo || _hi &gt; ohi)
1566     return this;                // doesn&#39;t narrow; pretty wierd
1567 
1568   // The new type narrows the old type, so look for a &quot;death march&quot;.
1569   // See comments on PhaseTransform::saturate.
1570   juint nrange = (juint)_hi - _lo;
1571   juint orange = (juint)ohi - olo;
1572   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1573     // Use the new type only if the range shrinks a lot.
1574     // We do not want the optimizer computing 2^31 point by point.
1575     return old;
1576   }
1577 
1578   return this;
1579 }
1580 
1581 //-----------------------------filter------------------------------------------
1582 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1583   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1584   if (ft == NULL || ft-&gt;empty())
1585     return Type::TOP;           // Canonical empty value
1586   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1587     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1588     // The widen bits must be allowed to run freely through the graph.
1589     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1590   }
1591   return ft;
1592 }
1593 
1594 //------------------------------eq---------------------------------------------
1595 // Structural equality check for Type representations
1596 bool TypeInt::eq( const Type *t ) const {
1597   const TypeInt *r = t-&gt;is_int(); // Handy access
1598   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1599 }
1600 
1601 //------------------------------hash-------------------------------------------
1602 // Type-specific hashing function.
1603 int TypeInt::hash(void) const {
1604   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1605 }
1606 
1607 //------------------------------is_finite--------------------------------------
1608 // Has a finite value
1609 bool TypeInt::is_finite() const {
1610   return true;
1611 }
1612 
1613 //------------------------------dump2------------------------------------------
1614 // Dump TypeInt
1615 #ifndef PRODUCT
1616 static const char* intname(char* buf, jint n) {
1617   if (n == min_jint)
1618     return &quot;min&quot;;
1619   else if (n &lt; min_jint + 10000)
1620     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1621   else if (n == max_jint)
1622     return &quot;max&quot;;
1623   else if (n &gt; max_jint - 10000)
1624     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1625   else
1626     sprintf(buf, INT32_FORMAT, n);
1627   return buf;
1628 }
1629 
1630 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1631   char buf[40], buf2[40];
1632   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1633     st-&gt;print(&quot;int&quot;);
1634   else if (is_con())
1635     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1636   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1637     st-&gt;print(&quot;bool&quot;);
1638   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1639     st-&gt;print(&quot;byte&quot;);
1640   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1641     st-&gt;print(&quot;char&quot;);
1642   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1643     st-&gt;print(&quot;short&quot;);
1644   else if (_hi == max_jint)
1645     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1646   else if (_lo == min_jint)
1647     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1648   else
1649     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1650 
1651   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1652     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1653 }
1654 #endif
1655 
1656 //------------------------------singleton--------------------------------------
1657 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1658 // constants.
1659 bool TypeInt::singleton(void) const {
1660   return _lo &gt;= _hi;
1661 }
1662 
1663 bool TypeInt::empty(void) const {
1664   return _lo &gt; _hi;
1665 }
1666 
1667 //=============================================================================
1668 // Convenience common pre-built types.
1669 const TypeLong *TypeLong::MINUS_1;// -1
1670 const TypeLong *TypeLong::ZERO; // 0
1671 const TypeLong *TypeLong::ONE;  // 1
1672 const TypeLong *TypeLong::POS;  // &gt;=0
1673 const TypeLong *TypeLong::LONG; // 64-bit integers
1674 const TypeLong *TypeLong::INT;  // 32-bit subrange
1675 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1676 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1677 
1678 //------------------------------TypeLong---------------------------------------
1679 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1680 }
1681 
1682 //------------------------------make-------------------------------------------
1683 const TypeLong *TypeLong::make( jlong lo ) {
1684   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1685 }
1686 
1687 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1688   // Certain normalizations keep us sane when comparing types.
1689   // The &#39;SMALLINT&#39; covers constants.
1690   if (lo &lt;= hi) {
1691     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1692     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1693   } else {
1694     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1695     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1696   }
1697   return w;
1698 }
1699 
1700 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1701   w = normalize_long_widen(lo, hi, w);
1702   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1703 }
1704 
1705 
1706 //------------------------------meet-------------------------------------------
1707 // Compute the MEET of two types.  It returns a new Type representation object
1708 // with reference count equal to the number of Types pointing at it.
1709 // Caller should wrap a Types around it.
1710 const Type *TypeLong::xmeet( const Type *t ) const {
1711   // Perform a fast test for common case; meeting the same types together.
1712   if( this == t ) return this;  // Meeting same type?
1713 
1714   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1715   switch (t-&gt;base()) {          // Switch on original type
1716   case AnyPtr:                  // Mixing with oops happens when javac
1717   case RawPtr:                  // reuses local variables
1718   case OopPtr:
1719   case InstPtr:
1720   case AryPtr:
1721   case MetadataPtr:
1722   case KlassPtr:
1723   case NarrowOop:
1724   case NarrowKlass:
1725   case Int:
1726   case FloatTop:
1727   case FloatCon:
1728   case FloatBot:
1729   case DoubleTop:
1730   case DoubleCon:
1731   case DoubleBot:
1732   case Bottom:                  // Ye Olde Default
1733     return Type::BOTTOM;
1734   default:                      // All else is a mistake
1735     typerr(t);
1736   case Top:                     // No change
1737     return this;
1738   case Long:                    // Long vs Long?
1739     break;
1740   }
1741 
1742   // Expand covered set
1743   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1744   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1745 }
1746 
1747 //------------------------------xdual------------------------------------------
1748 // Dual: reverse hi &amp; lo; flip widen
1749 const Type *TypeLong::xdual() const {
1750   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1751   return new TypeLong(_hi,_lo,w);
1752 }
1753 
1754 //------------------------------widen------------------------------------------
1755 // Only happens for optimistic top-down optimizations.
1756 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1757   // Coming from TOP or such; no widening
1758   if( old-&gt;base() != Long ) return this;
1759   const TypeLong *ot = old-&gt;is_long();
1760 
1761   // If new guy is equal to old guy, no widening
1762   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1763     return old;
1764 
1765   // If new guy contains old, then we widened
1766   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1767     // New contains old
1768     // If new guy is already wider than old, no widening
1769     if( _widen &gt; ot-&gt;_widen ) return this;
1770     // If old guy was a constant, do not bother
1771     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1772     // Now widen new guy.
1773     // Check for widening too far
1774     if (_widen == WidenMax) {
1775       jlong max = max_jlong;
1776       jlong min = min_jlong;
1777       if (limit-&gt;isa_long()) {
1778         max = limit-&gt;is_long()-&gt;_hi;
1779         min = limit-&gt;is_long()-&gt;_lo;
1780       }
1781       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1782         // If neither endpoint is extremal yet, push out the endpoint
1783         // which is closer to its respective limit.
1784         if (_lo &gt;= 0 ||                 // easy common case
1785             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1786           // Try to widen to an unsigned range type of 32/63 bits:
1787           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1788             return make(_lo, max_juint, WidenMax);
1789           else
1790             return make(_lo, max, WidenMax);
1791         } else {
1792           return make(min, _hi, WidenMax);
1793         }
1794       }
1795       return TypeLong::LONG;
1796     }
1797     // Returned widened new guy
1798     return make(_lo,_hi,_widen+1);
1799   }
1800 
1801   // If old guy contains new, then we probably widened too far &amp; dropped to
1802   // bottom.  Return the wider fellow.
1803   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1804     return old;
1805 
1806   //  fatal(&quot;Long value range is not subset&quot;);
1807   // return this;
1808   return TypeLong::LONG;
1809 }
1810 
1811 //------------------------------narrow----------------------------------------
1812 // Only happens for pessimistic optimizations.
1813 const Type *TypeLong::narrow( const Type *old ) const {
1814   if (_lo &gt;= _hi)  return this;   // already narrow enough
1815   if (old == NULL)  return this;
1816   const TypeLong* ot = old-&gt;isa_long();
1817   if (ot == NULL)  return this;
1818   jlong olo = ot-&gt;_lo;
1819   jlong ohi = ot-&gt;_hi;
1820 
1821   // If new guy is equal to old guy, no narrowing
1822   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1823 
1824   // If old guy was maximum range, allow the narrowing
1825   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1826 
1827   if (_lo &lt; olo || _hi &gt; ohi)
1828     return this;                // doesn&#39;t narrow; pretty wierd
1829 
1830   // The new type narrows the old type, so look for a &quot;death march&quot;.
1831   // See comments on PhaseTransform::saturate.
1832   julong nrange = _hi - _lo;
1833   julong orange = ohi - olo;
1834   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1835     // Use the new type only if the range shrinks a lot.
1836     // We do not want the optimizer computing 2^31 point by point.
1837     return old;
1838   }
1839 
1840   return this;
1841 }
1842 
1843 //-----------------------------filter------------------------------------------
1844 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1845   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1846   if (ft == NULL || ft-&gt;empty())
1847     return Type::TOP;           // Canonical empty value
1848   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1849     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1850     // The widen bits must be allowed to run freely through the graph.
1851     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1852   }
1853   return ft;
1854 }
1855 
1856 //------------------------------eq---------------------------------------------
1857 // Structural equality check for Type representations
1858 bool TypeLong::eq( const Type *t ) const {
1859   const TypeLong *r = t-&gt;is_long(); // Handy access
1860   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1861 }
1862 
1863 //------------------------------hash-------------------------------------------
1864 // Type-specific hashing function.
1865 int TypeLong::hash(void) const {
1866   return (int)(_lo+_hi+_widen+(int)Type::Long);
1867 }
1868 
1869 //------------------------------is_finite--------------------------------------
1870 // Has a finite value
1871 bool TypeLong::is_finite() const {
1872   return true;
1873 }
1874 
1875 //------------------------------dump2------------------------------------------
1876 // Dump TypeLong
1877 #ifndef PRODUCT
1878 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1879   if (n &gt; x) {
1880     if (n &gt;= x + 10000)  return NULL;
1881     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1882   } else if (n &lt; x) {
1883     if (n &lt;= x - 10000)  return NULL;
1884     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1885   } else {
1886     return xname;
1887   }
1888   return buf;
1889 }
1890 
1891 static const char* longname(char* buf, jlong n) {
1892   const char* str;
1893   if (n == min_jlong)
1894     return &quot;min&quot;;
1895   else if (n &lt; min_jlong + 10000)
1896     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1897   else if (n == max_jlong)
1898     return &quot;max&quot;;
1899   else if (n &gt; max_jlong - 10000)
1900     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1901   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1902     return str;
1903   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1904     return str;
1905   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1906     return str;
1907   else
1908     sprintf(buf, JLONG_FORMAT, n);
1909   return buf;
1910 }
1911 
1912 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1913   char buf[80], buf2[80];
1914   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1915     st-&gt;print(&quot;long&quot;);
1916   else if (is_con())
1917     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1918   else if (_hi == max_jlong)
1919     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1920   else if (_lo == min_jlong)
1921     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1922   else
1923     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1924 
1925   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1926     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1927 }
1928 #endif
1929 
1930 //------------------------------singleton--------------------------------------
1931 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1932 // constants
1933 bool TypeLong::singleton(void) const {
1934   return _lo &gt;= _hi;
1935 }
1936 
1937 bool TypeLong::empty(void) const {
1938   return _lo &gt; _hi;
1939 }
1940 
1941 //=============================================================================
1942 // Convenience common pre-built types.
1943 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1944 const TypeTuple *TypeTuple::IFFALSE;
1945 const TypeTuple *TypeTuple::IFTRUE;
1946 const TypeTuple *TypeTuple::IFNEITHER;
1947 const TypeTuple *TypeTuple::LOOPBODY;
1948 const TypeTuple *TypeTuple::MEMBAR;
1949 const TypeTuple *TypeTuple::STORECONDITIONAL;
1950 const TypeTuple *TypeTuple::START_I2C;
1951 const TypeTuple *TypeTuple::INT_PAIR;
1952 const TypeTuple *TypeTuple::LONG_PAIR;
1953 const TypeTuple *TypeTuple::INT_CC_PAIR;
1954 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1955 
1956 static void collect_inline_fields(ciInlineKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {
1957   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1958     ciField* field = vk-&gt;nonstatic_field_at(j);
1959     BasicType bt = field-&gt;type()-&gt;basic_type();
1960     const Type* ft = Type::get_const_type(field-&gt;type());
1961     field_array[pos++] = ft;
1962     if (type2size[bt] == 2) {
1963       field_array[pos++] = Type::HALF;
1964     }
1965     // Skip reserved arguments
1966     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1967       field_array[pos++] = Type::get_const_basic_type(bt);
1968       if (type2size[bt] == 2) {
1969         field_array[pos++] = Type::HALF;
1970       }
1971     }
1972   }
1973 }
1974 
1975 //------------------------------make-------------------------------------------
1976 // Make a TypeTuple from the range of a method signature
1977 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1978   ciType* return_type = sig-&gt;return_type();
1979   uint arg_cnt = return_type-&gt;size();
1980   if (ret_vt_fields) {
1981     arg_cnt = return_type-&gt;as_inline_klass()-&gt;inline_arg_slots() + 1;
1982   }
1983 
1984   const Type **field_array = fields(arg_cnt);
1985   switch (return_type-&gt;basic_type()) {
1986   case T_LONG:
1987     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1988     field_array[TypeFunc::Parms+1] = Type::HALF;
1989     break;
1990   case T_DOUBLE:
1991     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1992     field_array[TypeFunc::Parms+1] = Type::HALF;
1993     break;
1994   case T_OBJECT:
1995   case T_ARRAY:
1996   case T_BOOLEAN:
1997   case T_CHAR:
1998   case T_FLOAT:
1999   case T_BYTE:
2000   case T_SHORT:
2001   case T_INT:
2002     field_array[TypeFunc::Parms] = get_const_type(return_type);
2003     break;
2004   case T_INLINE_TYPE:
2005     if (ret_vt_fields) {
2006       uint pos = TypeFunc::Parms;
2007       field_array[pos] = TypePtr::BOTTOM;
2008       pos++;
2009       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
2010       collect_inline_fields(return_type-&gt;as_inline_klass(), field_array, pos, sig);
2011     } else {
2012       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(TypePtr::NOTNULL);
2013     }
2014     break;
2015   case T_VOID:
2016     break;
2017   default:
2018     ShouldNotReachHere();
2019   }
2020   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2021 }
2022 
2023 // Make a TypeTuple from the domain of a method signature
2024 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2025   ciSignature* sig = method-&gt;signature();
2026   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2027 
2028   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2029   if (vt_fields_as_args) {
2030     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2031       arg_cnt += type2size[(*sig_cc)._bt];
2032     }
2033     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2034   }
2035 
2036   uint pos = TypeFunc::Parms;
2037   const Type** field_array = fields(arg_cnt);
2038   if (!method-&gt;is_static()) {
2039     ciInstanceKlass* recv = method-&gt;holder();
2040     if (vt_fields_as_args &amp;&amp; recv-&gt;is_inlinetype() &amp;&amp; recv-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {
2041       collect_inline_fields(recv-&gt;as_inline_klass(), field_array, pos, sig_cc);
2042     } else {
2043       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2044       if (vt_fields_as_args) {
2045         ++sig_cc;
2046       }
2047     }
2048   }
2049 
2050   int i = 0;
2051   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2052     ciType* type = sig-&gt;type_at(i);
2053     BasicType bt = type-&gt;basic_type();
2054     bool is_flattened = false;
2055 
2056     switch (bt) {
2057     case T_LONG:
2058       field_array[pos++] = TypeLong::LONG;
2059       field_array[pos++] = Type::HALF;
2060       break;
2061     case T_DOUBLE:
2062       field_array[pos++] = Type::DOUBLE;
2063       field_array[pos++] = Type::HALF;
2064       break;
2065     case T_OBJECT:
2066     case T_ARRAY:
2067     case T_FLOAT:
2068     case T_INT:
2069       field_array[pos++] = get_const_type(type);
2070       break;
2071     case T_BOOLEAN:
2072     case T_CHAR:
2073     case T_BYTE:
2074     case T_SHORT:
2075       field_array[pos++] = TypeInt::INT;
2076       break;
2077     case T_INLINE_TYPE: {
2078       if (vt_fields_as_args &amp;&amp; type-&gt;as_inline_klass()-&gt;can_be_passed_as_fields()) {
2079         is_flattened = true;
2080         collect_inline_fields(type-&gt;as_inline_klass(), field_array, pos, sig_cc);
2081       } else {
2082         field_array[pos++] = get_const_type(type)-&gt;join_speculative(TypePtr::NOTNULL);
2083       }
2084       break;
2085     }
2086     default:
2087       ShouldNotReachHere();
2088     }
2089     // Skip reserved arguments
2090     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2091       field_array[pos++] = Type::get_const_basic_type(bt);
2092       if (type2size[bt] == 2) {
2093         field_array[pos++] = Type::HALF;
2094       }
2095     }
2096     i++;
2097   }
2098   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2099 
2100   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2101 }
2102 
2103 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2104   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2105 }
2106 
2107 //------------------------------fields-----------------------------------------
2108 // Subroutine call type with space allocated for argument types
2109 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2110 const Type **TypeTuple::fields( uint arg_cnt ) {
2111   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2112   flds[TypeFunc::Control  ] = Type::CONTROL;
2113   flds[TypeFunc::I_O      ] = Type::ABIO;
2114   flds[TypeFunc::Memory   ] = Type::MEMORY;
2115   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2116   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2117 
2118   return flds;
2119 }
2120 
2121 //------------------------------meet-------------------------------------------
2122 // Compute the MEET of two types.  It returns a new Type object.
2123 const Type *TypeTuple::xmeet( const Type *t ) const {
2124   // Perform a fast test for common case; meeting the same types together.
2125   if( this == t ) return this;  // Meeting same type-rep?
2126 
2127   // Current &quot;this-&gt;_base&quot; is Tuple
2128   switch (t-&gt;base()) {          // switch on original type
2129 
2130   case Bottom:                  // Ye Olde Default
2131     return t;
2132 
2133   default:                      // All else is a mistake
2134     typerr(t);
2135 
2136   case Tuple: {                 // Meeting 2 signatures?
2137     const TypeTuple *x = t-&gt;is_tuple();
2138     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2139     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2140     for( uint i=0; i&lt;_cnt; i++ )
2141       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2142     return TypeTuple::make(_cnt,fields);
2143   }
2144   case Top:
2145     break;
2146   }
2147   return this;                  // Return the double constant
2148 }
2149 
2150 //------------------------------xdual------------------------------------------
2151 // Dual: compute field-by-field dual
2152 const Type *TypeTuple::xdual() const {
2153   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2154   for( uint i=0; i&lt;_cnt; i++ )
2155     fields[i] = _fields[i]-&gt;dual();
2156   return new TypeTuple(_cnt,fields);
2157 }
2158 
2159 //------------------------------eq---------------------------------------------
2160 // Structural equality check for Type representations
2161 bool TypeTuple::eq( const Type *t ) const {
2162   const TypeTuple *s = (const TypeTuple *)t;
2163   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2164   for (uint i = 0; i &lt; _cnt; i++)
2165     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2166       return false;             // Missed
2167   return true;
2168 }
2169 
2170 //------------------------------hash-------------------------------------------
2171 // Type-specific hashing function.
2172 int TypeTuple::hash(void) const {
2173   intptr_t sum = _cnt;
2174   for( uint i=0; i&lt;_cnt; i++ )
2175     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2176   return sum;
2177 }
2178 
2179 //------------------------------dump2------------------------------------------
2180 // Dump signature Type
2181 #ifndef PRODUCT
2182 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2183   st-&gt;print(&quot;{&quot;);
2184   if( !depth || d[this] ) {     // Check for recursive print
2185     st-&gt;print(&quot;...}&quot;);
2186     return;
2187   }
2188   d.Insert((void*)this, (void*)this);   // Stop recursion
2189   if( _cnt ) {
2190     uint i;
2191     for( i=0; i&lt;_cnt-1; i++ ) {
2192       st-&gt;print(&quot;%d:&quot;, i);
2193       _fields[i]-&gt;dump2(d, depth-1, st);
2194       st-&gt;print(&quot;, &quot;);
2195     }
2196     st-&gt;print(&quot;%d:&quot;, i);
2197     _fields[i]-&gt;dump2(d, depth-1, st);
2198   }
2199   st-&gt;print(&quot;}&quot;);
2200 }
2201 #endif
2202 
2203 //------------------------------singleton--------------------------------------
2204 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2205 // constants (Ldi nodes).  Singletons are integer, float or double constants
2206 // or a single symbol.
2207 bool TypeTuple::singleton(void) const {
2208   return false;                 // Never a singleton
2209 }
2210 
2211 bool TypeTuple::empty(void) const {
2212   for( uint i=0; i&lt;_cnt; i++ ) {
2213     if (_fields[i]-&gt;empty())  return true;
2214   }
2215   return false;
2216 }
2217 
2218 //=============================================================================
2219 // Convenience common pre-built types.
2220 
2221 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2222   // Certain normalizations keep us sane when comparing types.
2223   // We do not want arrayOop variables to differ only by the wideness
2224   // of their index types.  Pick minimum wideness, since that is the
2225   // forced wideness of small ranges anyway.
2226   if (size-&gt;_widen != Type::WidenMin)
2227     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2228   else
2229     return size;
2230 }
2231 
2232 //------------------------------make-------------------------------------------
2233 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,
2234                              bool not_flat, bool not_null_free) {
2235   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2236     elem = elem-&gt;make_narrowoop();
2237   }
2238   size = normalize_array_size(size);
2239   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();
2240 }
2241 
2242 //------------------------------meet-------------------------------------------
2243 // Compute the MEET of two types.  It returns a new Type object.
2244 const Type *TypeAry::xmeet( const Type *t ) const {
2245   // Perform a fast test for common case; meeting the same types together.
2246   if( this == t ) return this;  // Meeting same type-rep?
2247 
2248   // Current &quot;this-&gt;_base&quot; is Ary
2249   switch (t-&gt;base()) {          // switch on original type
2250 
2251   case Bottom:                  // Ye Olde Default
2252     return t;
2253 
2254   default:                      // All else is a mistake
2255     typerr(t);
2256 
2257   case Array: {                 // Meeting 2 arrays?
2258     const TypeAry *a = t-&gt;is_ary();
2259     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2260                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2261                          _stable &amp;&amp; a-&gt;_stable,
2262                          _not_flat &amp;&amp; a-&gt;_not_flat,
2263                          _not_null_free &amp;&amp; a-&gt;_not_null_free);
2264   }
2265   case Top:
2266     break;
2267   }
2268   return this;                  // Return the double constant
2269 }
2270 
2271 //------------------------------xdual------------------------------------------
2272 // Dual: compute field-by-field dual
2273 const Type *TypeAry::xdual() const {
2274   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2275   size_dual = normalize_array_size(size_dual);
2276   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);
2277 }
2278 
2279 //------------------------------eq---------------------------------------------
2280 // Structural equality check for Type representations
2281 bool TypeAry::eq( const Type *t ) const {
2282   const TypeAry *a = (const TypeAry*)t;
2283   return _elem == a-&gt;_elem &amp;&amp;
2284     _stable == a-&gt;_stable &amp;&amp;
2285     _size == a-&gt;_size &amp;&amp;
2286     _not_flat == a-&gt;_not_flat &amp;&amp;
2287     _not_null_free == a-&gt;_not_null_free;
2288 
2289 }
2290 
2291 //------------------------------hash-------------------------------------------
2292 // Type-specific hashing function.
2293 int TypeAry::hash(void) const {
2294   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2295 }
2296 
2297 /**
2298  * Return same type without a speculative part in the element
2299  */
2300 const Type* TypeAry::remove_speculative() const {
2301   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);
2302 }
2303 
2304 /**
2305  * Return same type with cleaned up speculative part of element
2306  */
2307 const Type* TypeAry::cleanup_speculative() const {
2308   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);
2309 }
2310 
2311 /**
2312  * Return same type but with a different inline depth (used for speculation)
2313  *
2314  * @param depth  depth to meet with
2315  */
2316 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2317   if (!UseInlineDepthForSpeculativeTypes) {
2318     return this;
2319   }
2320   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2321 }
2322 
2323 //----------------------interface_vs_oop---------------------------------------
2324 #ifdef ASSERT
2325 bool TypeAry::interface_vs_oop(const Type *t) const {
2326   const TypeAry* t_ary = t-&gt;is_ary();
2327   if (t_ary) {
2328     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2329     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2330     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2331       return this_ptr-&gt;interface_vs_oop(t_ptr);
2332     }
2333   }
2334   return false;
2335 }
2336 #endif
2337 
2338 //------------------------------dump2------------------------------------------
2339 #ifndef PRODUCT
2340 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2341   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2342   if (Verbose) {
2343     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);
2344     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);
2345   }
2346   _elem-&gt;dump2(d, depth, st);
2347   st-&gt;print(&quot;[&quot;);
2348   _size-&gt;dump2(d, depth, st);
2349   st-&gt;print(&quot;]&quot;);
2350 }
2351 #endif
2352 
2353 //------------------------------singleton--------------------------------------
2354 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2355 // constants (Ldi nodes).  Singletons are integer, float or double constants
2356 // or a single symbol.
2357 bool TypeAry::singleton(void) const {
2358   return false;                 // Never a singleton
2359 }
2360 
2361 bool TypeAry::empty(void) const {
2362   return _elem-&gt;empty() || _size-&gt;empty();
2363 }
2364 
2365 //--------------------------ary_must_be_exact----------------------------------
2366 bool TypeAry::ary_must_be_exact() const {
2367   if (!UseExactTypes)       return false;
2368   // This logic looks at the element type of an array, and returns true
2369   // if the element type is either a primitive or a final instance class.
2370   // In such cases, an array built on this ary must have no subclasses.
2371   if (_elem == BOTTOM)      return false;  // general array not exact
2372   if (_elem == TOP   )      return false;  // inverted general array not exact
2373   const TypeOopPtr*  toop = NULL;
2374   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2375     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2376   } else {
2377     toop = _elem-&gt;isa_oopptr();
2378   }
2379   if (!toop)                return true;   // a primitive type, like int
2380   ciKlass* tklass = toop-&gt;klass();
2381   if (tklass == NULL)       return false;  // unloaded class
2382   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2383   const TypeInstPtr* tinst;
2384   if (_elem-&gt;isa_narrowoop())
2385     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2386   else
2387     tinst = _elem-&gt;isa_instptr();
2388   if (tinst)
2389     return tklass-&gt;as_instance_klass()-&gt;is_final();
2390   const TypeAryPtr*  tap;
2391   if (_elem-&gt;isa_narrowoop())
2392     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2393   else
2394     tap = _elem-&gt;isa_aryptr();
2395   if (tap)
2396     return tap-&gt;ary()-&gt;ary_must_be_exact();
2397   return false;
2398 }
2399 
2400 //==============================TypeInlineType=======================================
2401 
2402 const TypeInlineType *TypeInlineType::BOTTOM;
2403 
2404 //------------------------------make-------------------------------------------
2405 const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {
2406   return (TypeInlineType*)(new TypeInlineType(vk, larval))-&gt;hashcons();
2407 }
2408 
2409 //------------------------------meet-------------------------------------------
2410 // Compute the MEET of two types.  It returns a new Type object.
2411 const Type* TypeInlineType::xmeet(const Type* t) const {
2412   // Perform a fast test for common case; meeting the same types together.
2413   if(this == t) return this;  // Meeting same type-rep?
2414 
2415   // Current &quot;this-&gt;_base&quot; is InlineType
2416   switch (t-&gt;base()) {          // switch on original type
2417 
2418   case Int:
2419   case Long:
2420   case FloatTop:
2421   case FloatCon:
2422   case FloatBot:
2423   case DoubleTop:
2424   case DoubleCon:
2425   case DoubleBot:
2426   case NarrowKlass:
2427   case Bottom:
2428     return Type::BOTTOM;
2429 
2430   case OopPtr:
2431   case MetadataPtr:
2432   case KlassPtr:
2433   case RawPtr:
2434     return TypePtr::BOTTOM;
2435 
2436   case Top:
2437     return this;
2438 
2439   case NarrowOop: {
2440     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2441     if (res-&gt;isa_ptr()) {
2442       return res-&gt;make_narrowoop();
2443     }
2444     return res;
2445   }
2446 
2447   case AryPtr:
2448   case InstPtr: {
2449     return t-&gt;xmeet(this);
2450   }
2451 
2452   case InlineType: {
2453     // All inline types inherit from Object
2454     const TypeInlineType* other = t-&gt;is_inlinetype();
2455     if (_vk == NULL) {
2456       return this;
2457     } else if (other-&gt;_vk == NULL) {
2458       return other;
2459     } else if (_vk == other-&gt;_vk) {
2460       if (_larval == other-&gt;_larval ||
2461           !_larval) {
2462         return this;
2463       } else {
2464         return t;
2465       }
2466     }
2467     return TypeInstPtr::NOTNULL;
2468   }
2469 
2470   default:                      // All else is a mistake
2471     typerr(t);
2472 
2473   }
2474   return this;
2475 }
2476 
2477 //------------------------------xdual------------------------------------------
2478 const Type* TypeInlineType::xdual() const {
2479   return this;
2480 }
2481 
2482 //------------------------------eq---------------------------------------------
2483 // Structural equality check for Type representations
2484 bool TypeInlineType::eq(const Type* t) const {
2485   const TypeInlineType* vt = t-&gt;is_inlinetype();
2486   return (_vk == vt-&gt;inline_klass() &amp;&amp; _larval == vt-&gt;larval());
2487 }
2488 
2489 //------------------------------hash-------------------------------------------
2490 // Type-specific hashing function.
2491 int TypeInlineType::hash(void) const {
2492   return (intptr_t)_vk;
2493 }
2494 
2495 //------------------------------singleton--------------------------------------
2496 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
2497 bool TypeInlineType::singleton(void) const {
2498   return false;
2499 }
2500 
2501 //------------------------------empty------------------------------------------
2502 // TRUE if Type is a type with no values, FALSE otherwise.
2503 bool TypeInlineType::empty(void) const {
2504   return false;
2505 }
2506 
2507 //------------------------------dump2------------------------------------------
2508 #ifndef PRODUCT
2509 void TypeInlineType::dump2(Dict &amp;d, uint depth, outputStream* st) const {
2510   if (_vk == NULL) {
2511     st-&gt;print(&quot;BOTTOM inlinetype&quot;);
2512     return;
2513   }
2514   int count = _vk-&gt;nof_declared_nonstatic_fields();
2515   st-&gt;print(&quot;inlinetype[%d]:{&quot;, count);
2516   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2517   for (int i = 1; i &lt; count; ++i) {
2518     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2519   }
2520   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2521 }
2522 #endif
2523 
2524 //==============================TypeVect=======================================
2525 // Convenience common pre-built types.
2526 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2527 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2528 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2529 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2530 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2531 
2532 //------------------------------make-------------------------------------------
2533 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2534   BasicType elem_bt = elem-&gt;array_element_basic_type();
2535   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2536   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2537   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2538   int size = length * type2aelembytes(elem_bt);
2539   switch (Matcher::vector_ideal_reg(size)) {
2540   case Op_VecS:
2541     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2542   case Op_RegL:
2543   case Op_VecD:
2544   case Op_RegD:
2545     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2546   case Op_VecX:
2547     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2548   case Op_VecY:
2549     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2550   case Op_VecZ:
2551     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2552   }
2553  ShouldNotReachHere();
2554   return NULL;
2555 }
2556 
2557 //------------------------------meet-------------------------------------------
2558 // Compute the MEET of two types.  It returns a new Type object.
2559 const Type *TypeVect::xmeet( const Type *t ) const {
2560   // Perform a fast test for common case; meeting the same types together.
2561   if( this == t ) return this;  // Meeting same type-rep?
2562 
2563   // Current &quot;this-&gt;_base&quot; is Vector
2564   switch (t-&gt;base()) {          // switch on original type
2565 
2566   case Bottom:                  // Ye Olde Default
2567     return t;
2568 
2569   default:                      // All else is a mistake
2570     typerr(t);
2571 
2572   case VectorS:
2573   case VectorD:
2574   case VectorX:
2575   case VectorY:
2576   case VectorZ: {                // Meeting 2 vectors?
2577     const TypeVect* v = t-&gt;is_vect();
2578     assert(  base() == v-&gt;base(), &quot;&quot;);
2579     assert(length() == v-&gt;length(), &quot;&quot;);
2580     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2581     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2582   }
2583   case Top:
2584     break;
2585   }
2586   return this;
2587 }
2588 
2589 //------------------------------xdual------------------------------------------
2590 // Dual: compute field-by-field dual
2591 const Type *TypeVect::xdual() const {
2592   return new TypeVect(base(), _elem-&gt;dual(), _length);
2593 }
2594 
2595 //------------------------------eq---------------------------------------------
2596 // Structural equality check for Type representations
2597 bool TypeVect::eq(const Type *t) const {
2598   const TypeVect *v = t-&gt;is_vect();
2599   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2600 }
2601 
2602 //------------------------------hash-------------------------------------------
2603 // Type-specific hashing function.
2604 int TypeVect::hash(void) const {
2605   return (intptr_t)_elem + (intptr_t)_length;
2606 }
2607 
2608 //------------------------------singleton--------------------------------------
2609 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2610 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2611 // constant value (when vector is created with Replicate code).
2612 bool TypeVect::singleton(void) const {
2613 // There is no Con node for vectors yet.
2614 //  return _elem-&gt;singleton();
2615   return false;
2616 }
2617 
2618 bool TypeVect::empty(void) const {
2619   return _elem-&gt;empty();
2620 }
2621 
2622 //------------------------------dump2------------------------------------------
2623 #ifndef PRODUCT
2624 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2625   switch (base()) {
2626   case VectorS:
2627     st-&gt;print(&quot;vectors[&quot;); break;
2628   case VectorD:
2629     st-&gt;print(&quot;vectord[&quot;); break;
2630   case VectorX:
2631     st-&gt;print(&quot;vectorx[&quot;); break;
2632   case VectorY:
2633     st-&gt;print(&quot;vectory[&quot;); break;
2634   case VectorZ:
2635     st-&gt;print(&quot;vectorz[&quot;); break;
2636   default:
2637     ShouldNotReachHere();
2638   }
2639   st-&gt;print(&quot;%d]:{&quot;, _length);
2640   _elem-&gt;dump2(d, depth, st);
2641   st-&gt;print(&quot;}&quot;);
2642 }
2643 #endif
2644 
2645 
2646 //=============================================================================
2647 // Convenience common pre-built types.
2648 const TypePtr *TypePtr::NULL_PTR;
2649 const TypePtr *TypePtr::NOTNULL;
2650 const TypePtr *TypePtr::BOTTOM;
2651 
2652 //------------------------------meet-------------------------------------------
2653 // Meet over the PTR enum
2654 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2655   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2656   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2657   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2658   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2659   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2660   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2661   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2662 };
2663 
2664 //------------------------------make-------------------------------------------
2665 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {
2666   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2667 }
2668 
2669 //------------------------------cast_to_ptr_type-------------------------------
2670 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2671   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2672   if( ptr == _ptr ) return this;
2673   return make(_base, ptr, _offset, _speculative, _inline_depth);
2674 }
2675 
2676 //------------------------------get_con----------------------------------------
2677 intptr_t TypePtr::get_con() const {
2678   assert( _ptr == Null, &quot;&quot; );
2679   return offset();
2680 }
2681 
2682 //------------------------------meet-------------------------------------------
2683 // Compute the MEET of two types.  It returns a new Type object.
2684 const Type *TypePtr::xmeet(const Type *t) const {
2685   const Type* res = xmeet_helper(t);
2686   if (res-&gt;isa_ptr() == NULL) {
2687     return res;
2688   }
2689 
2690   const TypePtr* res_ptr = res-&gt;is_ptr();
2691   if (res_ptr-&gt;speculative() != NULL) {
2692     // type-&gt;speculative() == NULL means that speculation is no better
2693     // than type, i.e. type-&gt;speculative() == type. So there are 2
2694     // ways to represent the fact that we have no useful speculative
2695     // data and we should use a single one to be able to test for
2696     // equality between types. Check whether type-&gt;speculative() ==
2697     // type and set speculative to NULL if it is the case.
2698     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2699       return res_ptr-&gt;remove_speculative();
2700     }
2701   }
2702 
2703   return res;
2704 }
2705 
2706 const Type *TypePtr::xmeet_helper(const Type *t) const {
2707   // Perform a fast test for common case; meeting the same types together.
2708   if( this == t ) return this;  // Meeting same type-rep?
2709 
2710   // Current &quot;this-&gt;_base&quot; is AnyPtr
2711   switch (t-&gt;base()) {          // switch on original type
2712   case Int:                     // Mixing ints &amp; oops happens when javac
2713   case Long:                    // reuses local variables
2714   case FloatTop:
2715   case FloatCon:
2716   case FloatBot:
2717   case DoubleTop:
2718   case DoubleCon:
2719   case DoubleBot:
2720   case NarrowOop:
2721   case NarrowKlass:
2722   case Bottom:                  // Ye Olde Default
2723     return Type::BOTTOM;
2724   case Top:
2725     return this;
2726 
2727   case AnyPtr: {                // Meeting to AnyPtrs
2728     const TypePtr *tp = t-&gt;is_ptr();
2729     const TypePtr* speculative = xmeet_speculative(tp);
2730     int depth = meet_inline_depth(tp-&gt;inline_depth());
2731     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2732   }
2733   case RawPtr:                  // For these, flip the call around to cut down
2734   case OopPtr:
2735   case InstPtr:                 // on the cases I have to handle.
2736   case AryPtr:
2737   case MetadataPtr:
2738   case KlassPtr:
2739     return t-&gt;xmeet(this);      // Call in reverse direction
2740   default:                      // All else is a mistake
2741     typerr(t);
2742 
2743   }
2744   return this;
2745 }
2746 
2747 //------------------------------meet_offset------------------------------------
2748 Type::Offset TypePtr::meet_offset(int offset) const {
2749   return _offset.meet(Offset(offset));
2750 }
2751 
2752 //------------------------------dual_offset------------------------------------
2753 Type::Offset TypePtr::dual_offset() const {
2754   return _offset.dual();
2755 }
2756 
2757 //------------------------------xdual------------------------------------------
2758 // Dual: compute field-by-field dual
2759 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2760   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2761 };
2762 const Type *TypePtr::xdual() const {
2763   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2764 }
2765 
2766 //------------------------------xadd_offset------------------------------------
2767 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {
2768   return _offset.add(offset);
2769 }
2770 
2771 //------------------------------add_offset-------------------------------------
2772 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2773   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2774 }
2775 
2776 //------------------------------eq---------------------------------------------
2777 // Structural equality check for Type representations
2778 bool TypePtr::eq( const Type *t ) const {
2779   const TypePtr *a = (const TypePtr*)t;
2780   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2781 }
2782 
2783 //------------------------------hash-------------------------------------------
2784 // Type-specific hashing function.
2785 int TypePtr::hash(void) const {
2786   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));
2787 ;
2788 }
2789 
2790 /**
2791  * Return same type without a speculative part
2792  */
2793 const Type* TypePtr::remove_speculative() const {
2794   if (_speculative == NULL) {
2795     return this;
2796   }
2797   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2798   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2799 }
2800 
2801 /**
2802  * Return same type but drop speculative part if we know we won&#39;t use
2803  * it
2804  */
2805 const Type* TypePtr::cleanup_speculative() const {
2806   if (speculative() == NULL) {
2807     return this;
2808   }
2809   const Type* no_spec = remove_speculative();
2810   // If this is NULL_PTR then we don&#39;t need the speculative type
2811   // (with_inline_depth in case the current type inline depth is
2812   // InlineDepthTop)
2813   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2814     return no_spec;
2815   }
2816   if (above_centerline(speculative()-&gt;ptr())) {
2817     return no_spec;
2818   }
2819   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2820   // If the speculative may be null and is an inexact klass then it
2821   // doesn&#39;t help
2822   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2823       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2824     return no_spec;
2825   }
2826   return this;
2827 }
2828 
2829 /**
2830  * dual of the speculative part of the type
2831  */
2832 const TypePtr* TypePtr::dual_speculative() const {
2833   if (_speculative == NULL) {
2834     return NULL;
2835   }
2836   return _speculative-&gt;dual()-&gt;is_ptr();
2837 }
2838 
2839 /**
2840  * meet of the speculative parts of 2 types
2841  *
2842  * @param other  type to meet with
2843  */
2844 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2845   bool this_has_spec = (_speculative != NULL);
2846   bool other_has_spec = (other-&gt;speculative() != NULL);
2847 
2848   if (!this_has_spec &amp;&amp; !other_has_spec) {
2849     return NULL;
2850   }
2851 
2852   // If we are at a point where control flow meets and one branch has
2853   // a speculative type and the other has not, we meet the speculative
2854   // type of one branch with the actual type of the other. If the
2855   // actual type is exact and the speculative is as well, then the
2856   // result is a speculative type which is exact and we can continue
2857   // speculation further.
2858   const TypePtr* this_spec = _speculative;
2859   const TypePtr* other_spec = other-&gt;speculative();
2860 
2861   if (!this_has_spec) {
2862     this_spec = this;
2863   }
2864 
2865   if (!other_has_spec) {
2866     other_spec = other;
2867   }
2868 
2869   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2870 }
2871 
2872 /**
2873  * dual of the inline depth for this type (used for speculation)
2874  */
2875 int TypePtr::dual_inline_depth() const {
2876   return -inline_depth();
2877 }
2878 
2879 /**
2880  * meet of 2 inline depths (used for speculation)
2881  *
2882  * @param depth  depth to meet with
2883  */
2884 int TypePtr::meet_inline_depth(int depth) const {
2885   return MAX2(inline_depth(), depth);
2886 }
2887 
2888 /**
2889  * Are the speculative parts of 2 types equal?
2890  *
2891  * @param other  type to compare this one to
2892  */
2893 bool TypePtr::eq_speculative(const TypePtr* other) const {
2894   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2895     return _speculative == other-&gt;speculative();
2896   }
2897 
2898   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2899     return false;
2900   }
2901 
2902   return _speculative-&gt;eq(other-&gt;speculative());
2903 }
2904 
2905 /**
2906  * Hash of the speculative part of the type
2907  */
2908 int TypePtr::hash_speculative() const {
2909   if (_speculative == NULL) {
2910     return 0;
2911   }
2912 
2913   return _speculative-&gt;hash();
2914 }
2915 
2916 /**
2917  * add offset to the speculative part of the type
2918  *
2919  * @param offset  offset to add
2920  */
2921 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2922   if (_speculative == NULL) {
2923     return NULL;
2924   }
2925   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2926 }
2927 
2928 /**
2929  * return exact klass from the speculative type if there&#39;s one
2930  */
2931 ciKlass* TypePtr::speculative_type() const {
2932   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2933     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2934     if (speculative-&gt;klass_is_exact()) {
2935       return speculative-&gt;klass();
2936     }
2937   }
2938   return NULL;
2939 }
2940 
2941 /**
2942  * return true if speculative type may be null
2943  */
2944 bool TypePtr::speculative_maybe_null() const {
2945   if (_speculative != NULL) {
2946     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2947     return speculative-&gt;maybe_null();
2948   }
2949   return true;
2950 }
2951 
2952 bool TypePtr::speculative_always_null() const {
2953   if (_speculative != NULL) {
2954     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2955     return speculative == TypePtr::NULL_PTR;
2956   }
2957   return false;
2958 }
2959 
2960 /**
2961  * Same as TypePtr::speculative_type() but return the klass only if
2962  * the speculative tells us is not null
2963  */
2964 ciKlass* TypePtr::speculative_type_not_null() const {
2965   if (speculative_maybe_null()) {
2966     return NULL;
2967   }
2968   return speculative_type();
2969 }
2970 
2971 /**
2972  * Check whether new profiling would improve speculative type
2973  *
2974  * @param   exact_kls    class from profiling
2975  * @param   inline_depth inlining depth of profile point
2976  *
2977  * @return  true if type profile is valuable
2978  */
2979 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2980   // no profiling?
2981   if (exact_kls == NULL) {
2982     return false;
2983   }
2984   if (speculative() == TypePtr::NULL_PTR) {
2985     return false;
2986   }
2987   // no speculative type or non exact speculative type?
2988   if (speculative_type() == NULL) {
2989     return true;
2990   }
2991   // If the node already has an exact speculative type keep it,
2992   // unless it was provided by profiling that is at a deeper
2993   // inlining level. Profiling at a higher inlining depth is
2994   // expected to be less accurate.
2995   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2996     return false;
2997   }
2998   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2999   return inline_depth &lt; _speculative-&gt;inline_depth();
3000 }
3001 
3002 /**
3003  * Check whether new profiling would improve ptr (= tells us it is non
3004  * null)
3005  *
3006  * @param   ptr_kind always null or not null?
3007  *
3008  * @return  true if ptr profile is valuable
3009  */
3010 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
3011   // profiling doesn&#39;t tell us anything useful
3012   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
3013     return false;
3014   }
3015   // We already know this is not null
3016   if (!this-&gt;maybe_null()) {
3017     return false;
3018   }
3019   // We already know the speculative type cannot be null
3020   if (!speculative_maybe_null()) {
3021     return false;
3022   }
3023   // We already know this is always null
3024   if (this == TypePtr::NULL_PTR) {
3025     return false;
3026   }
3027   // We already know the speculative type is always null
3028   if (speculative_always_null()) {
3029     return false;
3030   }
3031   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3032     return false;
3033   }
3034   return true;
3035 }
3036 
3037 //------------------------------dump2------------------------------------------
3038 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3039   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3040 };
3041 
3042 #ifndef PRODUCT
3043 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3044   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3045   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
3046   _offset.dump2(st);
3047   dump_inline_depth(st);
3048   dump_speculative(st);
3049 }
3050 
3051 /**
3052  *dump the speculative part of the type
3053  */
3054 void TypePtr::dump_speculative(outputStream *st) const {
3055   if (_speculative != NULL) {
3056     st-&gt;print(&quot; (speculative=&quot;);
3057     _speculative-&gt;dump_on(st);
3058     st-&gt;print(&quot;)&quot;);
3059   }
3060 }
3061 
3062 /**
3063  *dump the inline depth of the type
3064  */
3065 void TypePtr::dump_inline_depth(outputStream *st) const {
3066   if (_inline_depth != InlineDepthBottom) {
3067     if (_inline_depth == InlineDepthTop) {
3068       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3069     } else {
3070       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3071     }
3072   }
3073 }
3074 #endif
3075 
3076 //------------------------------singleton--------------------------------------
3077 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3078 // constants
3079 bool TypePtr::singleton(void) const {
3080   // TopPTR, Null, AnyNull, Constant are all singletons
3081   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);
3082 }
3083 
3084 bool TypePtr::empty(void) const {
3085   return (_offset == Offset::top) || above_centerline(_ptr);
3086 }
3087 
3088 //=============================================================================
3089 // Convenience common pre-built types.
3090 const TypeRawPtr *TypeRawPtr::BOTTOM;
3091 const TypeRawPtr *TypeRawPtr::NOTNULL;
3092 
3093 //------------------------------make-------------------------------------------
3094 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3095   assert( ptr != Constant, &quot;what is the constant?&quot; );
3096   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3097   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3098 }
3099 
3100 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3101   assert( bits, &quot;Use TypePtr for NULL&quot; );
3102   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3103 }
3104 
3105 //------------------------------cast_to_ptr_type-------------------------------
3106 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
3107   assert( ptr != Constant, &quot;what is the constant?&quot; );
3108   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3109   assert( _bits==0, &quot;Why cast a constant address?&quot;);
3110   if( ptr == _ptr ) return this;
3111   return make(ptr);
3112 }
3113 
3114 //------------------------------get_con----------------------------------------
3115 intptr_t TypeRawPtr::get_con() const {
3116   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3117   return (intptr_t)_bits;
3118 }
3119 
3120 //------------------------------meet-------------------------------------------
3121 // Compute the MEET of two types.  It returns a new Type object.
3122 const Type *TypeRawPtr::xmeet( const Type *t ) const {
3123   // Perform a fast test for common case; meeting the same types together.
3124   if( this == t ) return this;  // Meeting same type-rep?
3125 
3126   // Current &quot;this-&gt;_base&quot; is RawPtr
3127   switch( t-&gt;base() ) {         // switch on original type
3128   case Bottom:                  // Ye Olde Default
3129     return t;
3130   case Top:
3131     return this;
3132   case AnyPtr:                  // Meeting to AnyPtrs
3133     break;
3134   case RawPtr: {                // might be top, bot, any/not or constant
3135     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
3136     enum PTR ptr = meet_ptr( tptr );
3137     if( ptr == Constant ) {     // Cannot be equal constants, so...
3138       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
3139       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
3140       ptr = NotNull;            // Fall down in lattice
3141     }
3142     return make( ptr );
3143   }
3144 
3145   case OopPtr:
3146   case InstPtr:
3147   case AryPtr:
3148   case MetadataPtr:
3149   case KlassPtr:
3150     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3151   default:                      // All else is a mistake
3152     typerr(t);
3153   }
3154 
3155   // Found an AnyPtr type vs self-RawPtr type
3156   const TypePtr *tp = t-&gt;is_ptr();
3157   switch (tp-&gt;ptr()) {
3158   case TypePtr::TopPTR:  return this;
3159   case TypePtr::BotPTR:  return t;
3160   case TypePtr::Null:
3161     if( _ptr == TypePtr::TopPTR ) return t;
3162     return TypeRawPtr::BOTTOM;
3163   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
3164   case TypePtr::AnyNull:
3165     if( _ptr == TypePtr::Constant) return this;
3166     return make( meet_ptr(TypePtr::AnyNull) );
3167   default: ShouldNotReachHere();
3168   }
3169   return this;
3170 }
3171 
3172 //------------------------------xdual------------------------------------------
3173 // Dual: compute field-by-field dual
3174 const Type *TypeRawPtr::xdual() const {
3175   return new TypeRawPtr( dual_ptr(), _bits );
3176 }
3177 
3178 //------------------------------add_offset-------------------------------------
3179 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
3180   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
3181   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
3182   if( offset == 0 ) return this; // No change
3183   switch (_ptr) {
3184   case TypePtr::TopPTR:
3185   case TypePtr::BotPTR:
3186   case TypePtr::NotNull:
3187     return this;
3188   case TypePtr::Null:
3189   case TypePtr::Constant: {
3190     address bits = _bits+offset;
3191     if ( bits == 0 ) return TypePtr::NULL_PTR;
3192     return make( bits );
3193   }
3194   default:  ShouldNotReachHere();
3195   }
3196   return NULL;                  // Lint noise
3197 }
3198 
3199 //------------------------------eq---------------------------------------------
3200 // Structural equality check for Type representations
3201 bool TypeRawPtr::eq( const Type *t ) const {
3202   const TypeRawPtr *a = (const TypeRawPtr*)t;
3203   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
3204 }
3205 
3206 //------------------------------hash-------------------------------------------
3207 // Type-specific hashing function.
3208 int TypeRawPtr::hash(void) const {
3209   return (intptr_t)_bits + TypePtr::hash();
3210 }
3211 
3212 //------------------------------dump2------------------------------------------
3213 #ifndef PRODUCT
3214 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3215   if( _ptr == Constant )
3216     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3217   else
3218     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3219 }
3220 #endif
3221 
3222 //=============================================================================
3223 // Convenience common pre-built type.
3224 const TypeOopPtr *TypeOopPtr::BOTTOM;
3225 
3226 //------------------------------TypeOopPtr-------------------------------------
3227 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
3228                        int instance_id, const TypePtr* speculative, int inline_depth)
3229   : TypePtr(t, ptr, offset, speculative, inline_depth),
3230     _const_oop(o), _klass(k),
3231     _klass_is_exact(xk),
3232     _is_ptr_to_narrowoop(false),
3233     _is_ptr_to_narrowklass(false),
3234     _is_ptr_to_boxed_value(false),
3235     _instance_id(instance_id) {
3236   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3237       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3238     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3239   }
3240 #ifdef _LP64
3241   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3242     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3243       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3244     } else if (klass() == NULL) {
3245       // Array with unknown body type
3246       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3247       _is_ptr_to_narrowoop = UseCompressedOops;
3248     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3249       if (klass()-&gt;is_obj_array_klass()) {
3250         _is_ptr_to_narrowoop = true;
3251       } else if (klass()-&gt;is_flat_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3252         // Check if the field of the inline type array element contains oops
3253         ciInlineKlass* vk = klass()-&gt;as_flat_array_klass()-&gt;element_klass()-&gt;as_inline_klass();
3254         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3255         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3256         assert(field != NULL, &quot;missing field&quot;);
3257         BasicType bt = field-&gt;layout_type();
3258         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_INLINE_TYPE);
3259       }
3260     } else if (klass()-&gt;is_instance_klass()) {
3261       if (this-&gt;isa_klassptr()) {
3262         // Perm objects don&#39;t use compressed references
3263       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3264         // unsafe access
3265         _is_ptr_to_narrowoop = UseCompressedOops;
3266       } else { // exclude unsafe ops
3267         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3268         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3269             (this-&gt;offset() == java_lang_Class::klass_offset() ||
3270              this-&gt;offset() == java_lang_Class::array_klass_offset())) {
3271           // Special hidden fields from the Class.
3272           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3273           _is_ptr_to_narrowoop = false;
3274         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3275                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3276           // Static fields
3277           assert(o != NULL, &quot;must be constant&quot;);
3278           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3279           BasicType basic_elem_type;
3280           if (ik-&gt;is_inlinetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_inline_klass()-&gt;default_value_offset()) {
3281             // Special hidden field that contains the oop of the default inline type
3282             basic_elem_type = T_INLINE_TYPE;
3283           } else {
3284             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3285             assert(field != NULL, &quot;missing field&quot;);
3286             basic_elem_type = field-&gt;layout_type();
3287           }
3288           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3289         } else {
3290           // Instance fields which contains a compressed oop references.
3291           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3292           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3293           if (field != NULL) {
3294             BasicType basic_elem_type = field-&gt;layout_type();
3295             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3296           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3297             // Compile::find_alias_type() cast exactness on all types to verify
3298             // that it does not affect alias type.
3299             _is_ptr_to_narrowoop = UseCompressedOops;
3300           } else {
3301             // Type for the copy start in LibraryCallKit::inline_native_clone().
3302             _is_ptr_to_narrowoop = UseCompressedOops;
3303           }
3304         }
3305       }
3306     }
3307   }
3308 #endif
3309 }
3310 
3311 //------------------------------make-------------------------------------------
3312 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,
3313                                    const TypePtr* speculative, int inline_depth) {
3314   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3315   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3316   bool      xk = false;
3317   ciObject* o = NULL;
3318   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();
3319 }
3320 
3321 
3322 //------------------------------cast_to_ptr_type-------------------------------
3323 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3324   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3325   if( ptr == _ptr ) return this;
3326   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3327 }
3328 
3329 //-----------------------------cast_to_instance_id----------------------------
3330 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3331   // There are no instances of a general oop.
3332   // Return self unchanged.
3333   return this;
3334 }
3335 
3336 //-----------------------------cast_to_exactness-------------------------------
3337 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3338   // There is no such thing as an exact general oop.
3339   // Return self unchanged.
3340   return this;
3341 }
3342 
3343 
3344 //------------------------------as_klass_type----------------------------------
3345 // Return the klass type corresponding to this instance or array type.
3346 // It is the type that is loaded from an object of this type.
3347 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3348   ciKlass* k = klass();
3349   bool    xk = klass_is_exact();
3350   if (k == NULL)
3351     return TypeKlassPtr::OBJECT;
3352   else
3353     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());
3354 }
3355 
3356 //------------------------------meet-------------------------------------------
3357 // Compute the MEET of two types.  It returns a new Type object.
3358 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3359   // Perform a fast test for common case; meeting the same types together.
3360   if( this == t ) return this;  // Meeting same type-rep?
3361 
3362   // Current &quot;this-&gt;_base&quot; is OopPtr
3363   switch (t-&gt;base()) {          // switch on original type
3364 
3365   case Int:                     // Mixing ints &amp; oops happens when javac
3366   case Long:                    // reuses local variables
3367   case FloatTop:
3368   case FloatCon:
3369   case FloatBot:
3370   case DoubleTop:
3371   case DoubleCon:
3372   case DoubleBot:
3373   case NarrowOop:
3374   case NarrowKlass:
3375   case Bottom:                  // Ye Olde Default
3376     return Type::BOTTOM;
3377   case Top:
3378     return this;
3379 
3380   default:                      // All else is a mistake
3381     typerr(t);
3382 
3383   case RawPtr:
3384   case MetadataPtr:
3385   case KlassPtr:
3386     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3387 
3388   case AnyPtr: {
3389     // Found an AnyPtr type vs self-OopPtr type
3390     const TypePtr *tp = t-&gt;is_ptr();
3391     Offset offset = meet_offset(tp-&gt;offset());
3392     PTR ptr = meet_ptr(tp-&gt;ptr());
3393     const TypePtr* speculative = xmeet_speculative(tp);
3394     int depth = meet_inline_depth(tp-&gt;inline_depth());
3395     switch (tp-&gt;ptr()) {
3396     case Null:
3397       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3398       // else fall through:
3399     case TopPTR:
3400     case AnyNull: {
3401       int instance_id = meet_instance_id(InstanceTop);
3402       return make(ptr, offset, instance_id, speculative, depth);
3403     }
3404     case BotPTR:
3405     case NotNull:
3406       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3407     default: typerr(t);
3408     }
3409   }
3410 
3411   case OopPtr: {                 // Meeting to other OopPtrs
3412     const TypeOopPtr *tp = t-&gt;is_oopptr();
3413     int instance_id = meet_instance_id(tp-&gt;instance_id());
3414     const TypePtr* speculative = xmeet_speculative(tp);
3415     int depth = meet_inline_depth(tp-&gt;inline_depth());
3416     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3417   }
3418 
3419   case InstPtr:                  // For these, flip the call around to cut down
3420   case AryPtr:
3421     return t-&gt;xmeet(this);      // Call in reverse direction
3422 
3423   } // End of switch
3424   return this;                  // Return the double constant
3425 }
3426 
3427 
3428 //------------------------------xdual------------------------------------------
3429 // Dual of a pure heap pointer.  No relevant klass or oop information.
3430 const Type *TypeOopPtr::xdual() const {
3431   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3432   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3433   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3434 }
3435 
3436 //--------------------------make_from_klass_common-----------------------------
3437 // Computes the element-type given a klass.
3438 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3439   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
3440     Compile* C = Compile::current();
3441     Dependencies* deps = C-&gt;dependencies();
3442     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3443     // Element is an instance
3444     bool klass_is_exact = false;
3445     if (klass-&gt;is_loaded()) {
3446       // Try to set klass_is_exact.
3447       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3448       klass_is_exact = ik-&gt;is_final();
3449       if (!klass_is_exact &amp;&amp; klass_change
3450           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3451         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3452         if (sub != NULL) {
3453           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3454           klass = ik = sub;
3455           klass_is_exact = sub-&gt;is_final();
3456         }
3457       }
3458       if (!klass_is_exact &amp;&amp; try_for_exact
3459           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3460         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3461           // Add a dependence; if concrete subclass added we need to recompile
3462           deps-&gt;assert_leaf_type(ik);
3463           klass_is_exact = true;
3464         }
3465       }
3466     }
3467     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3468   } else if (klass-&gt;is_obj_array_klass()) {
3469     // Element is an object or inline type array. Recursively call ourself.
3470     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ false, try_for_exact);
3471     if (etype-&gt;is_inlinetypeptr()) {
3472       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3473     }
3474     // Determine null-free/flattened properties
3475     const TypeOopPtr* exact_etype = etype;
3476     if (etype-&gt;can_be_inline_type()) {
3477       // Use exact type if element can be an inline type
3478       exact_etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), /* klass_change= */ true, /* try_for_exact= */ true);
3479     }
3480     bool not_null_free = !exact_etype-&gt;can_be_inline_type();
3481     bool not_flat = !UseFlatArray || not_null_free || (exact_etype-&gt;is_inlinetypeptr() &amp;&amp; !exact_etype-&gt;inline_klass()-&gt;flatten_array());
3482 
3483     bool xk = etype-&gt;klass_is_exact();
3484     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3485     // We used to pass NotNull in here, asserting that the sub-arrays
3486     // are all not-null.  This is not true in generally, as code can
3487     // slam NULLs down in the subarrays.
3488     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3489     return arr;
3490   } else if (klass-&gt;is_type_array_klass()) {
3491     // Element is an typeArray
3492     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3493     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3494                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3495     // We used to pass NotNull in here, asserting that the array pointer
3496     // is not-null. That was not true in general.
3497     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3498     return arr;
3499   } else if (klass-&gt;is_flat_array_klass()) {
3500     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();
3501     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);
3502     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3503     return arr;
3504   } else {
3505     ShouldNotReachHere();
3506     return NULL;
3507   }
3508 }
3509 
3510 //------------------------------make_from_constant-----------------------------
3511 // Make a java pointer from an oop constant
3512 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3513   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3514 
3515   const bool make_constant = require_constant || o-&gt;should_be_constant();
3516 
3517   ciKlass* klass = o-&gt;klass();
3518   if (klass-&gt;is_instance_klass() || klass-&gt;is_inlinetype()) {
3519     // Element is an instance or inline type
3520     if (make_constant) {
3521       return TypeInstPtr::make(o);
3522     } else {
3523       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3524     }
3525   } else if (klass-&gt;is_obj_array_klass()) {
3526     // Element is an object array. Recursively call ourself.
3527     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3528     bool null_free = false;
3529     if (etype-&gt;is_inlinetypeptr()) {
3530       null_free = true;
3531       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3532     }
3533     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3534                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3535     // We used to pass NotNull in here, asserting that the sub-arrays
3536     // are all not-null.  This is not true in generally, as code can
3537     // slam NULLs down in the subarrays.
3538     if (make_constant) {
3539       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3540     } else {
3541       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3542     }
3543   } else if (klass-&gt;is_type_array_klass()) {
3544     // Element is an typeArray
3545     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3546     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3547                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3548     // We used to pass NotNull in here, asserting that the array pointer
3549     // is not-null. That was not true in general.
3550     if (make_constant) {
3551       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3552     } else {
3553       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3554     }
3555   } else if (klass-&gt;is_flat_array_klass()) {
3556     ciInlineKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_inline_klass();
3557     const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));
3558     // We used to pass NotNull in here, asserting that the sub-arrays
3559     // are all not-null.  This is not true in generally, as code can
3560     // slam NULLs down in the subarrays.
3561     if (make_constant) {
3562       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3563     } else {
3564       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3565     }
3566   }
3567 
3568   fatal(&quot;unhandled object type&quot;);
3569   return NULL;
3570 }
3571 
3572 //------------------------------get_con----------------------------------------
3573 intptr_t TypeOopPtr::get_con() const {
3574   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3575   assert(offset() &gt;= 0, &quot;&quot;);
3576 
3577   if (offset() != 0) {
3578     // After being ported to the compiler interface, the compiler no longer
3579     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3580     // to a handle at compile time.  This handle is embedded in the generated
3581     // code and dereferenced at the time the nmethod is made.  Until that time,
3582     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3583     // have access to the addresses!).  This does not seem to currently happen,
3584     // but this assertion here is to help prevent its occurence.
3585     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3586     ShouldNotReachHere();
3587   }
3588 
3589   return (intptr_t)const_oop()-&gt;constant_encoding();
3590 }
3591 
3592 
3593 //-----------------------------filter------------------------------------------
3594 // Do not allow interface-vs.-noninterface joins to collapse to top.
3595 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3596 
3597   const Type* ft = join_helper(kills, include_speculative);
3598   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3599   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3600 
3601   if (ft-&gt;empty()) {
3602     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3603     // interface.  This can happen because the bytecodes do not contain
3604     // enough type info to distinguish a Java-level interface variable
3605     // from a Java-level object variable.  If we meet 2 classes which
3606     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3607     // doesn&#39;t implement I, we have no way to tell if the result should
3608     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3609     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3610     // uplift the type.
3611     if (!empty()) {
3612       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3613         return kills;           // Uplift to interface
3614       }
3615       // Also check for evil cases of &#39;this&#39; being a class array
3616       // and &#39;kills&#39; expecting an array of interfaces.
3617       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3618       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3619         return kills;           // Uplift to array of interface
3620       }
3621     }
3622 
3623     return Type::TOP;           // Canonical empty value
3624   }
3625 
3626   // If we have an interface-typed Phi or cast and we narrow to a class type,
3627   // the join should report back the class.  However, if we have a J/L/Object
3628   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3629   // join report an interface back out.  This isn&#39;t possible but happens
3630   // because the type system doesn&#39;t interact well with interfaces.
3631   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3632       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3633       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3634     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3635     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3636   }
3637 
3638   return ft;
3639 }
3640 
3641 //------------------------------eq---------------------------------------------
3642 // Structural equality check for Type representations
3643 bool TypeOopPtr::eq( const Type *t ) const {
3644   const TypeOopPtr *a = (const TypeOopPtr*)t;
3645   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3646       _instance_id != a-&gt;_instance_id)  return false;
3647   ciObject* one = const_oop();
3648   ciObject* two = a-&gt;const_oop();
3649   if (one == NULL || two == NULL) {
3650     return (one == two) &amp;&amp; TypePtr::eq(t);
3651   } else {
3652     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3653   }
3654 }
3655 
3656 //------------------------------hash-------------------------------------------
3657 // Type-specific hashing function.
3658 int TypeOopPtr::hash(void) const {
3659   return
3660     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3661              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3662 }
3663 
3664 //------------------------------dump2------------------------------------------
3665 #ifndef PRODUCT
3666 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3667   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3668   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3669   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3670   _offset.dump2(st);
3671   if (_instance_id == InstanceTop)
3672     st-&gt;print(&quot;,iid=top&quot;);
3673   else if (_instance_id != InstanceBot)
3674     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3675 
3676   dump_inline_depth(st);
3677   dump_speculative(st);
3678 }
3679 #endif
3680 
3681 //------------------------------singleton--------------------------------------
3682 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3683 // constants
3684 bool TypeOopPtr::singleton(void) const {
3685   // detune optimizer to not generate constant oop + constant offset as a constant!
3686   // TopPTR, Null, AnyNull, Constant are all singletons
3687   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
3688 }
3689 
3690 //------------------------------add_offset-------------------------------------
3691 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3692   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3693 }
3694 
3695 /**
3696  * Return same type without a speculative part
3697  */
3698 const Type* TypeOopPtr::remove_speculative() const {
3699   if (_speculative == NULL) {
3700     return this;
3701   }
3702   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3703   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3704 }
3705 
3706 /**
3707  * Return same type but drop speculative part if we know we won&#39;t use
3708  * it
3709  */
3710 const Type* TypeOopPtr::cleanup_speculative() const {
3711   // If the klass is exact and the ptr is not null then there&#39;s
3712   // nothing that the speculative type can help us with
3713   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3714     return remove_speculative();
3715   }
3716   return TypePtr::cleanup_speculative();
3717 }
3718 
3719 /**
3720  * Return same type but with a different inline depth (used for speculation)
3721  *
3722  * @param depth  depth to meet with
3723  */
3724 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3725   if (!UseInlineDepthForSpeculativeTypes) {
3726     return this;
3727   }
3728   return make(_ptr, _offset, _instance_id, _speculative, depth);
3729 }
3730 
3731 //------------------------------with_instance_id--------------------------------
3732 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3733   assert(_instance_id != -1, &quot;should be known&quot;);
3734   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3735 }
3736 
3737 //------------------------------meet_instance_id--------------------------------
3738 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3739   // Either is &#39;TOP&#39; instance?  Return the other instance!
3740   if( _instance_id == InstanceTop ) return  instance_id;
3741   if(  instance_id == InstanceTop ) return _instance_id;
3742   // If either is different, return &#39;BOTTOM&#39; instance
3743   if( _instance_id != instance_id ) return InstanceBot;
3744   return _instance_id;
3745 }
3746 
3747 //------------------------------dual_instance_id--------------------------------
3748 int TypeOopPtr::dual_instance_id( ) const {
3749   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3750   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3751   return _instance_id;              // Map everything else into self
3752 }
3753 
3754 /**
3755  * Check whether new profiling would improve speculative type
3756  *
3757  * @param   exact_kls    class from profiling
3758  * @param   inline_depth inlining depth of profile point
3759  *
3760  * @return  true if type profile is valuable
3761  */
3762 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3763   // no way to improve an already exact type
3764   if (klass_is_exact()) {
3765     return false;
3766   }
3767   return TypePtr::would_improve_type(exact_kls, inline_depth);
3768 }
3769 
3770 //=============================================================================
3771 // Convenience common pre-built types.
3772 const TypeInstPtr *TypeInstPtr::NOTNULL;
3773 const TypeInstPtr *TypeInstPtr::BOTTOM;
3774 const TypeInstPtr *TypeInstPtr::MIRROR;
3775 const TypeInstPtr *TypeInstPtr::MARK;
3776 const TypeInstPtr *TypeInstPtr::KLASS;
3777 
3778 //------------------------------TypeInstPtr-------------------------------------
3779 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3780                          bool flat_array, int instance_id, const TypePtr* speculative,
3781                          int inline_depth)
3782   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3783     _name(k-&gt;name()), _flat_array(flat_array) {
3784    assert(k != NULL &amp;&amp;
3785           (k-&gt;is_loaded() || o == NULL),
3786           &quot;cannot have constants with non-loaded klass&quot;);
3787    assert(!klass()-&gt;is_inlinetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
3788    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);
3789 };
3790 
3791 //------------------------------make-------------------------------------------
3792 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3793                                      ciKlass* k,
3794                                      bool xk,
3795                                      ciObject* o,
3796                                      Offset offset,
3797                                      bool flat_array,
3798                                      int instance_id,
3799                                      const TypePtr* speculative,
3800                                      int inline_depth) {
3801   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3802   // Either const_oop() is NULL or else ptr is Constant
3803   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3804           &quot;constant pointers must have a value supplied&quot; );
3805   // Ptr is never Null
3806   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3807 
3808   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3809   if (!UseExactTypes)  xk = false;
3810   if (ptr == Constant) {
3811     // Note:  This case includes meta-object constants, such as methods.
3812     xk = true;
3813   } else if (k-&gt;is_loaded()) {
3814     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3815     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3816     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3817   }
3818 
3819   // Now hash this baby
3820   TypeInstPtr *result =
3821     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();
3822 
3823   return result;
3824 }
3825 
3826 /**
3827  *  Create constant type for a constant boxed value
3828  */
3829 const Type* TypeInstPtr::get_const_boxed_value() const {
3830   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3831   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3832   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3833   BasicType bt = constant.basic_type();
3834   switch (bt) {
3835     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3836     case T_INT:      return TypeInt::make(constant.as_int());
3837     case T_CHAR:     return TypeInt::make(constant.as_char());
3838     case T_BYTE:     return TypeInt::make(constant.as_byte());
3839     case T_SHORT:    return TypeInt::make(constant.as_short());
3840     case T_FLOAT:    return TypeF::make(constant.as_float());
3841     case T_DOUBLE:   return TypeD::make(constant.as_double());
3842     case T_LONG:     return TypeLong::make(constant.as_long());
3843     default:         break;
3844   }
3845   fatal(&quot;Invalid boxed inline type &#39;%s&#39;&quot;, type2name(bt));
3846   return NULL;
3847 }
3848 
3849 //------------------------------cast_to_ptr_type-------------------------------
3850 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3851   if( ptr == _ptr ) return this;
3852   // Reconstruct _sig info here since not a problem with later lazy
3853   // construction, _sig will show up on demand.
3854   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3855 }
3856 
3857 
3858 //-----------------------------cast_to_exactness-------------------------------
3859 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3860   if( klass_is_exact == _klass_is_exact ) return this;
3861   if (!UseExactTypes)  return this;
3862   if (!_klass-&gt;is_loaded())  return this;
3863   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3864   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3865   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3866   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3867 }
3868 
3869 //-----------------------------cast_to_instance_id----------------------------
3870 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3871   if( instance_id == _instance_id ) return this;
3872   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);
3873 }
3874 
3875 //------------------------------xmeet_unloaded---------------------------------
3876 // Compute the MEET of two InstPtrs when at least one is unloaded.
3877 // Assume classes are different since called after check for same name/class-loader
3878 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3879     Offset off = meet_offset(tinst-&gt;offset());
3880     PTR ptr = meet_ptr(tinst-&gt;ptr());
3881     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3882     const TypePtr* speculative = xmeet_speculative(tinst);
3883     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3884 
3885     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3886     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3887     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3888       //
3889       // Meet unloaded class with java/lang/Object
3890       //
3891       // Meet
3892       //          |                     Unloaded Class
3893       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3894       //  ===================================================================
3895       //   TOP    | ..........................Unloaded......................|
3896       //  AnyNull |  U-AN    |................Unloaded......................|
3897       // Constant | ... O-NN .................................. |   O-BOT   |
3898       //  NotNull | ... O-NN .................................. |   O-BOT   |
3899       //  BOTTOM  | ........................Object-BOTTOM ..................|
3900       //
3901       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3902       //
3903       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3904       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }
3905       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3906       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3907         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3908         else                                      { return TypeInstPtr::NOTNULL; }
3909       }
3910       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3911 
3912       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3913     }
3914 
3915     // Both are unloaded, not the same class, not Object
3916     // Or meet unloaded with a different loaded class, not java/lang/Object
3917     if( ptr != TypePtr::BotPTR ) {
3918       return TypeInstPtr::NOTNULL;
3919     }
3920     return TypeInstPtr::BOTTOM;
3921 }
3922 
3923 
3924 //------------------------------meet-------------------------------------------
3925 // Compute the MEET of two types.  It returns a new Type object.
3926 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3927   // Perform a fast test for common case; meeting the same types together.
3928   if( this == t ) return this;  // Meeting same type-rep?
3929 
3930   // Current &quot;this-&gt;_base&quot; is Pointer
3931   switch (t-&gt;base()) {          // switch on original type
3932 
3933   case Int:                     // Mixing ints &amp; oops happens when javac
3934   case Long:                    // reuses local variables
3935   case FloatTop:
3936   case FloatCon:
3937   case FloatBot:
3938   case DoubleTop:
3939   case DoubleCon:
3940   case DoubleBot:
3941   case NarrowOop:
3942   case NarrowKlass:
3943   case Bottom:                  // Ye Olde Default
3944     return Type::BOTTOM;
3945   case Top:
3946     return this;
3947 
3948   default:                      // All else is a mistake
3949     typerr(t);
3950 
3951   case MetadataPtr:
3952   case KlassPtr:
3953   case RawPtr: return TypePtr::BOTTOM;
3954 
3955   case AryPtr: {                // All arrays inherit from Object class
3956     const TypeAryPtr *tp = t-&gt;is_aryptr();
3957     Offset offset = meet_offset(tp-&gt;offset());
3958     PTR ptr = meet_ptr(tp-&gt;ptr());
3959     int instance_id = meet_instance_id(tp-&gt;instance_id());
3960     const TypePtr* speculative = xmeet_speculative(tp);
3961     int depth = meet_inline_depth(tp-&gt;inline_depth());
3962     switch (ptr) {
3963     case TopPTR:
3964     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3965       // For instances when a subclass meets a superclass we fall
3966       // below the centerline when the superclass is exact. We need to
3967       // do the same here.
3968       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {
3969         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3970       } else {
3971         // cannot subclass, so the meet has to fall badly below the centerline
3972         ptr = NotNull;
3973         instance_id = InstanceBot;
3974         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3975       }
3976     case Constant:
3977     case NotNull:
3978     case BotPTR:                // Fall down to object klass
3979       // LCA is object_klass, but if we subclass from the top we can do better
3980       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3981         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3982         // then we can subclass in the Java class hierarchy.
3983         // For instances when a subclass meets a superclass we fall
3984         // below the centerline when the superclass is exact. We need
3985         // to do the same here.
3986         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact() &amp;&amp; !flat_array()) {
3987           // that is, tp&#39;s array type is a subtype of my klass
3988           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3989                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3990         }
3991       }
3992       // The other case cannot happen, since I cannot be a subtype of an array.
3993       // The meet falls down to Object class below centerline.
3994       if( ptr == Constant )
3995          ptr = NotNull;
3996       instance_id = InstanceBot;
3997       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3998     default: typerr(t);
3999     }
4000   }
4001 
4002   case OopPtr: {                // Meeting to OopPtrs
4003     // Found a OopPtr type vs self-InstPtr type
4004     const TypeOopPtr *tp = t-&gt;is_oopptr();
4005     Offset offset = meet_offset(tp-&gt;offset());
4006     PTR ptr = meet_ptr(tp-&gt;ptr());
4007     switch (tp-&gt;ptr()) {
4008     case TopPTR:
4009     case AnyNull: {
4010       int instance_id = meet_instance_id(InstanceTop);
4011       const TypePtr* speculative = xmeet_speculative(tp);
4012       int depth = meet_inline_depth(tp-&gt;inline_depth());
4013       return make(ptr, klass(), klass_is_exact(),
4014                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4015     }
4016     case NotNull:
4017     case BotPTR: {
4018       int instance_id = meet_instance_id(tp-&gt;instance_id());
4019       const TypePtr* speculative = xmeet_speculative(tp);
4020       int depth = meet_inline_depth(tp-&gt;inline_depth());
4021       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4022     }
4023     default: typerr(t);
4024     }
4025   }
4026 
4027   case AnyPtr: {                // Meeting to AnyPtrs
4028     // Found an AnyPtr type vs self-InstPtr type
4029     const TypePtr *tp = t-&gt;is_ptr();
4030     Offset offset = meet_offset(tp-&gt;offset());
4031     PTR ptr = meet_ptr(tp-&gt;ptr());
4032     int instance_id = meet_instance_id(InstanceTop);
4033     const TypePtr* speculative = xmeet_speculative(tp);
4034     int depth = meet_inline_depth(tp-&gt;inline_depth());
4035     switch (tp-&gt;ptr()) {
4036     case Null:
4037       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4038       // else fall through to AnyNull
4039     case TopPTR:
4040     case AnyNull: {
4041       return make(ptr, klass(), klass_is_exact(),
4042                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4043     }
4044     case NotNull:
4045     case BotPTR:
4046       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4047     default: typerr(t);
4048     }
4049   }
4050 
4051   /*
4052                  A-top         }
4053                /   |   \       }  Tops
4054            B-top A-any C-top   }
4055               | /  |  \ |      }  Any-nulls
4056            B-any   |   C-any   }
4057               |    |    |
4058            B-con A-con C-con   } constants; not comparable across classes
4059               |    |    |
4060            B-not   |   C-not   }
4061               | \  |  / |      }  not-nulls
4062            B-bot A-not C-bot   }
4063                \   |   /       }  Bottoms
4064                  A-bot         }
4065   */
4066 
4067   case InstPtr: {                // Meeting 2 Oops?
4068     // Found an InstPtr sub-type vs self-InstPtr type
4069     const TypeInstPtr *tinst = t-&gt;is_instptr();
4070     Offset off = meet_offset( tinst-&gt;offset() );
4071     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4072     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4073     const TypePtr* speculative = xmeet_speculative(tinst);
4074     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4075 
4076     // Check for easy case; klasses are equal (and perhaps not loaded!)
4077     // If we have constants, then we created oops so classes are loaded
4078     // and we can handle the constants further down.  This case handles
4079     // both-not-loaded or both-loaded classes
4080     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
4081         flat_array() == tinst-&gt;flat_array()) {
4082       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);
4083     }
4084 
4085     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4086     ciKlass* tinst_klass = tinst-&gt;klass();
4087     ciKlass* this_klass  = this-&gt;klass();
4088     bool tinst_xk = tinst-&gt;klass_is_exact();
4089     bool this_xk  = this-&gt;klass_is_exact();
4090     bool tinst_flat_array = tinst-&gt;flat_array();
4091     bool this_flat_array  = this-&gt;flat_array();
4092     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4093       // One of these classes has not been loaded
4094       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4095 #ifndef PRODUCT
4096       if( PrintOpto &amp;&amp; Verbose ) {
4097         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4098         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4099         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4100       }
4101 #endif
4102       return unloaded_meet;
4103     }
4104 
4105     // Handle mixing oops and interfaces first.
4106     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4107                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4108       ciKlass *tmp = tinst_klass; // Swap interface around
4109       tinst_klass = this_klass;
4110       this_klass = tmp;
4111       bool tmp2 = tinst_xk;
4112       tinst_xk = this_xk;
4113       this_xk = tmp2;
4114       tmp2 = tinst_flat_array;
4115       tinst_flat_array = this_flat_array;
4116       this_flat_array = tmp2;
4117     }
4118     if (tinst_klass-&gt;is_interface() &amp;&amp;
4119         !(this_klass-&gt;is_interface() ||
4120           // Treat java/lang/Object as an honorary interface,
4121           // because we need a bottom for the interface hierarchy.
4122           this_klass == ciEnv::current()-&gt;Object_klass())) {
4123       // Oop meets interface!
4124 
4125       // See if the oop subtypes (implements) interface.
4126       ciKlass *k;
4127       bool xk;
4128       bool flat_array;
4129       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4130         // Oop indeed subtypes.  Now keep oop or interface depending
4131         // on whether we are both above the centerline or either is
4132         // below the centerline.  If we are on the centerline
4133         // (e.g., Constant vs. AnyNull interface), use the constant.
4134         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4135         // If we are keeping this_klass, keep its exactness too.
4136         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
4137         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;
4138       } else {                  // Does not implement, fall to Object
4139         // Oop does not implement interface, so mixing falls to Object
4140         // just like the verifier does (if both are above the
4141         // centerline fall to interface)
4142         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4143         xk = above_centerline(ptr) ? tinst_xk : false;
4144         flat_array = above_centerline(ptr) ? tinst_flat_array : false;
4145         // Watch out for Constant vs. AnyNull interface.
4146         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4147         instance_id = InstanceBot;
4148       }
4149       ciObject* o = NULL;  // the Constant value, if any
4150       if (ptr == Constant) {
4151         // Find out which constant.
4152         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4153       }
4154       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4155     }
4156 
4157     // Either oop vs oop or interface vs interface or interface vs Object
4158 
4159     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4160     // If we split one up &amp; one down AND they subtype, take the down man.
4161     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4162     // If both are up and they subtype, take the subtype class.
4163     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4164     // If both are down and they subtype, take the supertype class.
4165     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4166     // Constants treated as down.
4167 
4168     // Now, reorder the above list; observe that both-down+subtype is also
4169     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4170     // If we split one up &amp; one down AND they subtype, take the down man.
4171     // If both are up and they subtype, take the subtype class.
4172 
4173     // If both are down and they subtype, &quot;fall hard&quot;.
4174     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4175     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4176     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4177 
4178     // If a proper subtype is exact, and we return it, we return it exactly.
4179     // If a proper supertype is exact, there can be no subtyping relationship!
4180     // If both types are equal to the subtype, exactness is and-ed below the
4181     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4182 
4183     // Check for subtyping:
4184     ciKlass *subtype = NULL;
4185     bool subtype_exact = false;
4186     bool flat_array = false;
4187     if (tinst_klass-&gt;equals(this_klass)) {
4188       subtype = this_klass;
4189       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4190       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
4191     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {
4192       subtype = this_klass;     // Pick subtyping class
4193       subtype_exact = this_xk;
4194       flat_array = this_flat_array;
4195     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {
4196       subtype = tinst_klass;    // Pick subtyping class
4197       subtype_exact = tinst_xk;
4198       flat_array = tinst_flat_array;
4199     }
4200 
4201     if (subtype) {
4202       if (above_centerline(ptr)) { // both are up?
4203         this_klass = tinst_klass = subtype;
4204         this_xk = tinst_xk = subtype_exact;
4205         this_flat_array = tinst_flat_array = flat_array;
4206       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
4207         this_klass = tinst_klass; // tinst is down; keep down man
4208         this_xk = tinst_xk;
4209         this_flat_array = tinst_flat_array;
4210       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
4211         tinst_klass = this_klass; // this is down; keep down man
4212         tinst_xk = this_xk;
4213         tinst_flat_array = this_flat_array;
4214       } else {
4215         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4216         this_flat_array = flat_array;
4217       }
4218     }
4219 
4220     // Check for classes now being equal
4221     if (tinst_klass-&gt;equals(this_klass)) {
4222       // If the klasses are equal, the constants may still differ.  Fall to
4223       // NotNull if they do (neither constant is NULL; that is a special case
4224       // handled elsewhere).
4225       ciObject* o = NULL;             // Assume not constant when done
4226       ciObject* this_oop  = const_oop();
4227       ciObject* tinst_oop = tinst-&gt;const_oop();
4228       if( ptr == Constant ) {
4229         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4230             this_oop-&gt;equals(tinst_oop) )
4231           o = this_oop;
4232         else if (above_centerline(this -&gt;_ptr))
4233           o = tinst_oop;
4234         else if (above_centerline(tinst -&gt;_ptr))
4235           o = this_oop;
4236         else
4237           ptr = NotNull;
4238       }
4239       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4240     } // Else classes are not equal
4241 
4242     // Since klasses are different, we require a LCA in the Java
4243     // class hierarchy - which means we have to fall to at least NotNull.
4244     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4245       ptr = NotNull;
4246 
4247     instance_id = InstanceBot;
4248 
4249     // Now we find the LCA of Java classes
4250     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4251     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4252   } // End of case InstPtr
4253 
4254   case InlineType: {
4255     const TypeInlineType* tv = t-&gt;is_inlinetype();
4256     if (above_centerline(ptr())) {
4257       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {
4258         return t;
4259       } else {
4260         return TypeInstPtr::NOTNULL;
4261       }
4262     } else {
4263       PTR ptr = this-&gt;_ptr;
4264       if (ptr == Constant) {
4265         ptr = NotNull;
4266       }
4267       if (tv-&gt;inline_klass()-&gt;is_subtype_of(_klass)) {
4268         return TypeInstPtr::make(ptr, _klass);
4269       } else {
4270         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4271       }
4272     }
4273   }
4274 
4275   } // End of switch
4276   return this;                  // Return the double constant
4277 }
4278 
4279 
4280 //------------------------java_mirror_type--------------------------------------
4281 ciType* TypeInstPtr::java_mirror_type() const {
4282   // must be a singleton type
4283   if( const_oop() == NULL )  return NULL;
4284 
4285   // must be of type java.lang.Class
4286   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4287   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
4288 }
4289 
4290 
4291 //------------------------------xdual------------------------------------------
4292 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4293 // inheritance mechanism.
4294 const Type *TypeInstPtr::xdual() const {
4295   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4296 }
4297 
4298 //------------------------------eq---------------------------------------------
4299 // Structural equality check for Type representations
4300 bool TypeInstPtr::eq( const Type *t ) const {
4301   const TypeInstPtr *p = t-&gt;is_instptr();
4302   return
4303     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4304     flat_array() == p-&gt;flat_array() &amp;&amp;
4305     TypeOopPtr::eq(p);          // Check sub-type stuff
4306 }
4307 
4308 //------------------------------hash-------------------------------------------
4309 // Type-specific hashing function.
4310 int TypeInstPtr::hash(void) const {
4311   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());
4312   return hash;
4313 }
4314 
4315 //------------------------------dump2------------------------------------------
4316 // Dump oop Type
4317 #ifndef PRODUCT
4318 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4319   // Print the name of the klass.
4320   klass()-&gt;print_name_on(st);
4321 
4322   switch( _ptr ) {
4323   case Constant:
4324     // TO DO: Make CI print the hex address of the underlying oop.
4325     if (WizardMode || Verbose) {
4326       const_oop()-&gt;print_oop(st);
4327     }
4328   case BotPTR:
4329     if (!WizardMode &amp;&amp; !Verbose) {
4330       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4331       break;
4332     }
4333   case TopPTR:
4334   case AnyNull:
4335   case NotNull:
4336     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4337     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4338     break;
4339   default:
4340     break;
4341   }
4342 
4343   _offset.dump2(st);
4344 
4345   st-&gt;print(&quot; *&quot;);
4346 
4347   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {
4348     st-&gt;print(&quot; (flatten array)&quot;);
4349   }
4350 
4351   if (_instance_id == InstanceTop)
4352     st-&gt;print(&quot;,iid=top&quot;);
4353   else if (_instance_id != InstanceBot)
4354     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4355 
4356   dump_inline_depth(st);
4357   dump_speculative(st);
4358 }
4359 #endif
4360 
4361 //------------------------------add_offset-------------------------------------
4362 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4363   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4364               _instance_id, add_offset_speculative(offset), _inline_depth);
4365 }
4366 
4367 const Type *TypeInstPtr::remove_speculative() const {
4368   if (_speculative == NULL) {
4369     return this;
4370   }
4371   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4372   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),
4373               _instance_id, NULL, _inline_depth);
4374 }
4375 
4376 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4377   if (!UseInlineDepthForSpeculativeTypes) {
4378     return this;
4379   }
4380   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);
4381 }
4382 
4383 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4384   assert(is_known_instance(), &quot;should be known&quot;);
4385   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4386 }
4387 
4388 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4389   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4390 }
4391 
4392 
4393 //=============================================================================
4394 // Convenience common pre-built types.
4395 const TypeAryPtr *TypeAryPtr::RANGE;
4396 const TypeAryPtr *TypeAryPtr::OOPS;
4397 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4398 const TypeAryPtr *TypeAryPtr::BYTES;
4399 const TypeAryPtr *TypeAryPtr::SHORTS;
4400 const TypeAryPtr *TypeAryPtr::CHARS;
4401 const TypeAryPtr *TypeAryPtr::INTS;
4402 const TypeAryPtr *TypeAryPtr::LONGS;
4403 const TypeAryPtr *TypeAryPtr::FLOATS;
4404 const TypeAryPtr *TypeAryPtr::DOUBLES;
4405 const TypeAryPtr *TypeAryPtr::INLINES;
4406 
4407 //------------------------------make-------------------------------------------
4408 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4409                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4410   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4411          &quot;integral arrays must be pre-equipped with a class&quot;);
4412   if (!xk) xk = ary-&gt;ary_must_be_exact();
4413   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4414   if (!UseExactTypes)  xk = (ptr == Constant);
4415   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4416 }
4417 
4418 //------------------------------make-------------------------------------------
4419 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4420                                    int instance_id, const TypePtr* speculative, int inline_depth,
4421                                    bool is_autobox_cache) {
4422   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4423          &quot;integral arrays must be pre-equipped with a class&quot;);
4424   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4425   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4426   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4427   if (!UseExactTypes)  xk = (ptr == Constant);
4428   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4429 }
4430 
4431 //------------------------------cast_to_ptr_type-------------------------------
4432 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4433   if( ptr == _ptr ) return this;
4434   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4435 }
4436 
4437 
4438 //-----------------------------cast_to_exactness-------------------------------
4439 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4440   if( klass_is_exact == _klass_is_exact ) return this;
4441   if (!UseExactTypes)  return this;
4442   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4443 
4444   const TypeAry* new_ary = _ary;
4445   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {
4446     // An object array can&#39;t be flat or null-free if the klass is exact
4447     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);
4448   }
4449   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4450 }
4451 
4452 //-----------------------------cast_to_instance_id----------------------------
4453 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4454   if( instance_id == _instance_id ) return this;
4455   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);
4456 }
4457 
4458 
4459 //-----------------------------max_array_length-------------------------------
4460 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4461 jint TypeAryPtr::max_array_length(BasicType etype) {
4462   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4463     if (etype == T_NARROWOOP) {
4464       etype = T_OBJECT;
4465     } else if (etype == T_ILLEGAL) { // bottom[]
4466       etype = T_BYTE; // will produce conservatively high value
4467     } else {
4468       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4469     }
4470   }
4471   return arrayOopDesc::max_array_length(etype);
4472 }
4473 
4474 //-----------------------------narrow_size_type-------------------------------
4475 // Narrow the given size type to the index range for the given array base type.
4476 // Return NULL if the resulting int type becomes empty.
4477 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4478   jint hi = size-&gt;_hi;
4479   jint lo = size-&gt;_lo;
4480   jint min_lo = 0;
4481   jint max_hi = max_array_length(elem()-&gt;basic_type());
4482   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4483   bool chg = false;
4484   if (lo &lt; min_lo) {
4485     lo = min_lo;
4486     if (size-&gt;is_con()) {
4487       hi = lo;
4488     }
4489     chg = true;
4490   }
4491   if (hi &gt; max_hi) {
4492     hi = max_hi;
4493     if (size-&gt;is_con()) {
4494       lo = hi;
4495     }
4496     chg = true;
4497   }
4498   // Negative length arrays will produce weird intermediate dead fast-path code
4499   if (lo &gt; hi)
4500     return TypeInt::ZERO;
4501   if (!chg)
4502     return size;
4503   return TypeInt::make(lo, hi, Type::WidenMin);
4504 }
4505 
4506 //-------------------------------cast_to_size----------------------------------
4507 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4508   assert(new_size != NULL, &quot;&quot;);
4509   new_size = narrow_size_type(new_size);
4510   if (new_size == size())  return this;
4511   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());
4512   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4513 }
4514 
4515 //-------------------------------cast_to_not_flat------------------------------
4516 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4517   if (not_flat == is_not_flat()) {
4518     return this;
4519   }
4520   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4521   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4522 }
4523 
4524 //-------------------------------cast_to_not_null_free-------------------------
4525 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4526   if (not_null_free == is_not_null_free()) {
4527     return this;
4528   }
4529   // Not null free implies not flat
4530   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4531   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4532 }
4533 
4534 //------------------------------cast_to_stable---------------------------------
4535 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4536   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4537     return this;
4538 
4539   const Type* elem = this-&gt;elem();
4540   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4541 
4542   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4543     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4544     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4545   }
4546 
4547   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4548 
4549   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4550 }
4551 
4552 //-----------------------------stable_dimension--------------------------------
4553 int TypeAryPtr::stable_dimension() const {
4554   if (!is_stable())  return 0;
4555   int dim = 1;
4556   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4557   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4558     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4559   return dim;
4560 }
4561 
4562 //----------------------cast_to_autobox_cache-----------------------------------
4563 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4564   if (is_autobox_cache() == cache)  return this;
4565   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4566   if (etype == NULL)  return this;
4567   // The pointers in the autobox arrays are always non-null.
4568   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4569   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4570   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());
4571   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);
4572 }
4573 
4574 //------------------------------eq---------------------------------------------
4575 // Structural equality check for Type representations
4576 bool TypeAryPtr::eq( const Type *t ) const {
4577   const TypeAryPtr *p = t-&gt;is_aryptr();
4578   return
4579     _ary == p-&gt;_ary &amp;&amp;  // Check array
4580     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts
4581     _field_offset == p-&gt;_field_offset;
4582 }
4583 
4584 //------------------------------hash-------------------------------------------
4585 // Type-specific hashing function.
4586 int TypeAryPtr::hash(void) const {
4587   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();
4588 }
4589 
4590 //------------------------------meet-------------------------------------------
4591 // Compute the MEET of two types.  It returns a new Type object.
4592 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4593   // Perform a fast test for common case; meeting the same types together.
4594   if( this == t ) return this;  // Meeting same type-rep?
4595   // Current &quot;this-&gt;_base&quot; is Pointer
4596   switch (t-&gt;base()) {          // switch on original type
4597 
4598   // Mixing ints &amp; oops happens when javac reuses local variables
4599   case Int:
4600   case Long:
4601   case FloatTop:
4602   case FloatCon:
4603   case FloatBot:
4604   case DoubleTop:
4605   case DoubleCon:
4606   case DoubleBot:
4607   case NarrowOop:
4608   case NarrowKlass:
4609   case Bottom:                  // Ye Olde Default
4610     return Type::BOTTOM;
4611   case Top:
4612     return this;
4613 
4614   default:                      // All else is a mistake
4615     typerr(t);
4616 
4617   case OopPtr: {                // Meeting to OopPtrs
4618     // Found a OopPtr type vs self-AryPtr type
4619     const TypeOopPtr *tp = t-&gt;is_oopptr();
4620     Offset offset = meet_offset(tp-&gt;offset());
4621     PTR ptr = meet_ptr(tp-&gt;ptr());
4622     int depth = meet_inline_depth(tp-&gt;inline_depth());
4623     const TypePtr* speculative = xmeet_speculative(tp);
4624     switch (tp-&gt;ptr()) {
4625     case TopPTR:
4626     case AnyNull: {
4627       int instance_id = meet_instance_id(InstanceTop);
4628       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4629                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4630     }
4631     case BotPTR:
4632     case NotNull: {
4633       int instance_id = meet_instance_id(tp-&gt;instance_id());
4634       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4635     }
4636     default: ShouldNotReachHere();
4637     }
4638   }
4639 
4640   case AnyPtr: {                // Meeting two AnyPtrs
4641     // Found an AnyPtr type vs self-AryPtr type
4642     const TypePtr *tp = t-&gt;is_ptr();
4643     Offset offset = meet_offset(tp-&gt;offset());
4644     PTR ptr = meet_ptr(tp-&gt;ptr());
4645     const TypePtr* speculative = xmeet_speculative(tp);
4646     int depth = meet_inline_depth(tp-&gt;inline_depth());
4647     switch (tp-&gt;ptr()) {
4648     case TopPTR:
4649       return this;
4650     case BotPTR:
4651     case NotNull:
4652       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4653     case Null:
4654       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4655       // else fall through to AnyNull
4656     case AnyNull: {
4657       int instance_id = meet_instance_id(InstanceTop);
4658       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4659                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4660     }
4661     default: ShouldNotReachHere();
4662     }
4663   }
4664 
4665   case MetadataPtr:
4666   case KlassPtr:
4667   case RawPtr: return TypePtr::BOTTOM;
4668 
4669   case AryPtr: {                // Meeting 2 references?
4670     const TypeAryPtr *tap = t-&gt;is_aryptr();
4671     Offset off = meet_offset(tap-&gt;offset());
4672     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4673     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4674     PTR ptr = meet_ptr(tap-&gt;ptr());
4675     int instance_id = meet_instance_id(tap-&gt;instance_id());
4676     const TypePtr* speculative = xmeet_speculative(tap);
4677     int depth = meet_inline_depth(tap-&gt;inline_depth());
4678     ciKlass* lazy_klass = NULL;
4679     if (tary-&gt;_elem-&gt;isa_int()) {
4680       // Integral array element types have irrelevant lattice relations.
4681       // It is the klass that determines array layout, not the element type.
4682       if (_klass == NULL)
4683         lazy_klass = tap-&gt;_klass;
4684       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4685         lazy_klass = _klass;
4686       } else {
4687         // Something like byte[int+] meets char[int+].
4688         // This must fall to bottom, not (int[-128..65535])[int+].
4689         instance_id = InstanceBot;
4690         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4691       }
4692     } else // Non integral arrays.
4693       // Must fall to bottom if exact klasses in upper lattice
4694       // are not equal or super klass is exact.
4695       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4696           // meet with top[] and bottom[] are processed further down:
4697           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4698           // both are exact and not equal:
4699           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4700            // &#39;tap&#39; is exact and super or unrelated:
4701            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4702            // &#39;this&#39; is exact and super or unrelated:
4703            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4704       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4705         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4706       }
4707       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4708     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp; klass()-&gt;is_flat_array_klass() != tap-&gt;klass()-&gt;is_flat_array_klass()) {
4709       // Meeting flattened inline type array with non-flattened array. Adjust (field) offset accordingly.
4710       if (tary-&gt;_elem-&gt;isa_inlinetype()) {
4711         // Result is flattened
4712         off = Offset(elem()-&gt;isa_inlinetype() ? offset() : tap-&gt;offset());
4713         field_off = elem()-&gt;isa_inlinetype() ? field_offset() : tap-&gt;field_offset();
4714       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4715         // Result is non-flattened
4716         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4717         field_off = Offset::bottom;
4718       }
4719     }
4720 
4721     bool xk = false;
4722     switch (tap-&gt;ptr()) {
4723     case AnyNull:
4724     case TopPTR:
4725       // Compute new klass on demand, do not use tap-&gt;_klass
4726       if (below_centerline(this-&gt;_ptr)) {
4727         xk = this-&gt;_klass_is_exact;
4728       } else {
4729         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4730       }
4731       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4732     case Constant: {
4733       ciObject* o = const_oop();
4734       if( _ptr == Constant ) {
4735         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4736           xk = (klass() == tap-&gt;klass());
4737           ptr = NotNull;
4738           o = NULL;
4739           instance_id = InstanceBot;
4740         } else {
4741           xk = true;
4742         }
4743       } else if(above_centerline(_ptr)) {
4744         o = tap-&gt;const_oop();
4745         xk = true;
4746       } else {
4747         // Only precise for identical arrays
4748         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4749       }
4750       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4751     }
4752     case NotNull:
4753     case BotPTR:
4754       // Compute new klass on demand, do not use tap-&gt;_klass
4755       if (above_centerline(this-&gt;_ptr))
4756             xk = tap-&gt;_klass_is_exact;
4757       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4758               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4759       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4760     default: ShouldNotReachHere();
4761     }
4762   }
4763 
4764   // All arrays inherit from Object class
4765   case InstPtr: {
4766     const TypeInstPtr *tp = t-&gt;is_instptr();
4767     Offset offset = meet_offset(tp-&gt;offset());
4768     PTR ptr = meet_ptr(tp-&gt;ptr());
4769     int instance_id = meet_instance_id(tp-&gt;instance_id());
4770     const TypePtr* speculative = xmeet_speculative(tp);
4771     int depth = meet_inline_depth(tp-&gt;inline_depth());
4772     switch (ptr) {
4773     case TopPTR:
4774     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4775       // For instances when a subclass meets a superclass we fall
4776       // below the centerline when the superclass is exact. We need to
4777       // do the same here.
4778       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4779         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4780       } else {
4781         // cannot subclass, so the meet has to fall badly below the centerline
4782         ptr = NotNull;
4783         instance_id = InstanceBot;
4784         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4785       }
4786     case Constant:
4787     case NotNull:
4788     case BotPTR:                // Fall down to object klass
4789       // LCA is object_klass, but if we subclass from the top we can do better
4790       if (above_centerline(tp-&gt;ptr())) {
4791         // If &#39;tp&#39;  is above the centerline and it is Object class
4792         // then we can subclass in the Java class hierarchy.
4793         // For instances when a subclass meets a superclass we fall
4794         // below the centerline when the superclass is exact. We need
4795         // to do the same here.
4796         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact() &amp;&amp; !tp-&gt;flat_array()) {
4797           // that is, my array type is a subtype of &#39;tp&#39; klass
4798           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4799                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4800         }
4801       }
4802       // The other case cannot happen, since t cannot be a subtype of an array.
4803       // The meet falls down to Object class below centerline.
4804       if( ptr == Constant )
4805          ptr = NotNull;
4806       instance_id = InstanceBot;
4807       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4808     default: typerr(t);
4809     }
4810   }
4811 
4812   case InlineType: {
4813     const TypeInlineType* tv = t-&gt;is_inlinetype();
4814     if (above_centerline(ptr())) {
4815       return TypeInstPtr::NOTNULL;
4816     } else {
4817       PTR ptr = this-&gt;_ptr;
4818       if (ptr == Constant) {
4819         ptr = NotNull;
4820       }
4821       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4822     }
4823   }
4824   }
4825   return this;                  // Lint noise
4826 }
4827 
4828 //------------------------------xdual------------------------------------------
4829 // Dual: compute field-by-field dual
4830 const Type *TypeAryPtr::xdual() const {
4831   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4832 }
4833 
4834 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4835   return _field_offset.meet(offset);
4836 }
4837 
4838 //------------------------------dual_offset------------------------------------
4839 Type::Offset TypeAryPtr::dual_field_offset() const {
4840   return _field_offset.dual();
4841 }
4842 
4843 //----------------------interface_vs_oop---------------------------------------
4844 #ifdef ASSERT
4845 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4846   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4847   if (t_aryptr) {
4848     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4849   }
4850   return false;
4851 }
4852 #endif
4853 
4854 //------------------------------dump2------------------------------------------
4855 #ifndef PRODUCT
4856 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4857   _ary-&gt;dump2(d,depth,st);
4858   switch( _ptr ) {
4859   case Constant:
4860     const_oop()-&gt;print(st);
4861     break;
4862   case BotPTR:
4863     if (!WizardMode &amp;&amp; !Verbose) {
4864       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4865       break;
4866     }
4867   case TopPTR:
4868   case AnyNull:
4869   case NotNull:
4870     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4871     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4872     break;
4873   default:
4874     break;
4875   }
4876 
4877   if (elem()-&gt;isa_inlinetype()) {
4878     st-&gt;print(&quot;(&quot;);
4879     _field_offset.dump2(st);
4880     st-&gt;print(&quot;)&quot;);
4881   }
4882   if (offset() != 0) {
4883     int header_size = objArrayOopDesc::header_size() * wordSize;
4884     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4885     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4886     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4887     else {
4888       BasicType basic_elem_type = elem()-&gt;basic_type();
4889       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4890       int elem_size = type2aelembytes(basic_elem_type);
4891       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4892     }
4893   }
4894   st-&gt;print(&quot; *&quot;);
4895   if (_instance_id == InstanceTop)
4896     st-&gt;print(&quot;,iid=top&quot;);
4897   else if (_instance_id != InstanceBot)
4898     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4899 
4900   dump_inline_depth(st);
4901   dump_speculative(st);
4902 }
4903 #endif
4904 
4905 bool TypeAryPtr::empty(void) const {
4906   if (_ary-&gt;empty())       return true;
4907   return TypeOopPtr::empty();
4908 }
4909 
4910 //------------------------------add_offset-------------------------------------
4911 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4912   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);
4913 }
4914 
4915 const Type *TypeAryPtr::remove_speculative() const {
4916   if (_speculative == NULL) {
4917     return this;
4918   }
4919   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4920   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);
4921 }
4922 
4923 const Type* TypeAryPtr::cleanup_speculative() const {
4924   if (speculative() == NULL) {
4925     return this;
4926   }
4927   // Keep speculative part if it contains information about flat-/nullability
4928   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();
4929   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {
4930     return this;
4931   }
4932   return TypeOopPtr::cleanup_speculative();
4933 }
4934 
4935 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4936   if (!UseInlineDepthForSpeculativeTypes) {
4937     return this;
4938   }
4939   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4940 }
4941 
4942 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4943   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4944 }
4945 
4946 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4947   int adj = 0;
4948   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4949     const Type* elemtype = elem();
4950     if (elemtype-&gt;isa_inlinetype()) {
4951       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4952         adj = _offset.get();
4953         offset += _offset.get();
4954       }
4955       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4956       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4957         offset += _field_offset.get();
4958         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4959           offset += header;
4960         }
4961       }
4962       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
4963         // Try to get the field of the inline type array element we are pointing to
4964         ciKlass* arytype_klass = klass();
4965         ciFlatArrayKlass* vak = arytype_klass-&gt;as_flat_array_klass();
4966         ciInlineKlass* vk = vak-&gt;element_klass()-&gt;as_inline_klass();
4967         int shift = vak-&gt;log2_element_size();
4968         int mask = (1 &lt;&lt; shift) - 1;
4969         intptr_t field_offset = ((offset - header) &amp; mask);
4970         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4971         if (field == NULL) {
4972           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4973           return add_offset(offset);
4974         } else {
4975           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4976         }
4977       }
4978     }
4979   }
4980   return add_offset(offset - adj);
4981 }
4982 
4983 // Return offset incremented by field_offset for flattened inline type arrays
4984 const int TypeAryPtr::flattened_offset() const {
4985   int offset = _offset.get();
4986   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
4987       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
4988     offset += _field_offset.get();
4989   }
4990   return offset;
4991 }
4992 
4993 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4994   assert(is_known_instance(), &quot;should be known&quot;);
4995   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
4996 }
4997 
4998 //=============================================================================
4999 
5000 
5001 //------------------------------hash-------------------------------------------
5002 // Type-specific hashing function.
5003 int TypeNarrowPtr::hash(void) const {
5004   return _ptrtype-&gt;hash() + 7;
5005 }
5006 
5007 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
5008   return _ptrtype-&gt;singleton();
5009 }
5010 
5011 bool TypeNarrowPtr::empty(void) const {
5012   return _ptrtype-&gt;empty();
5013 }
5014 
5015 intptr_t TypeNarrowPtr::get_con() const {
5016   return _ptrtype-&gt;get_con();
5017 }
5018 
5019 bool TypeNarrowPtr::eq( const Type *t ) const {
5020   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
5021   if (tc != NULL) {
5022     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
5023       return false;
5024     }
5025     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
5026   }
5027   return false;
5028 }
5029 
5030 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
5031   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
5032   return make_same_narrowptr(odual);
5033 }
5034 
5035 
5036 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
5037   if (isa_same_narrowptr(kills)) {
5038     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
5039     if (ft-&gt;empty())
5040       return Type::TOP;           // Canonical empty value
5041     if (ft-&gt;isa_ptr()) {
5042       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
5043     }
5044     return ft;
5045   } else if (kills-&gt;isa_ptr()) {
5046     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
5047     if (ft-&gt;empty())
5048       return Type::TOP;           // Canonical empty value
5049     return ft;
5050   } else {
5051     return Type::TOP;
5052   }
5053 }
5054 
5055 //------------------------------xmeet------------------------------------------
5056 // Compute the MEET of two types.  It returns a new Type object.
5057 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
5058   // Perform a fast test for common case; meeting the same types together.
5059   if( this == t ) return this;  // Meeting same type-rep?
5060 
5061   if (t-&gt;base() == base()) {
5062     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
5063     if (result-&gt;isa_ptr()) {
5064       return make_hash_same_narrowptr(result-&gt;is_ptr());
5065     }
5066     return result;
5067   }
5068 
5069   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5070   switch (t-&gt;base()) {          // switch on original type
5071 
5072   case Int:                     // Mixing ints &amp; oops happens when javac
5073   case Long:                    // reuses local variables
5074   case FloatTop:
5075   case FloatCon:
5076   case FloatBot:
5077   case DoubleTop:
5078   case DoubleCon:
5079   case DoubleBot:
5080   case AnyPtr:
5081   case RawPtr:
5082   case OopPtr:
5083   case InstPtr:
5084   case AryPtr:
5085   case MetadataPtr:
5086   case KlassPtr:
5087   case NarrowOop:
5088   case NarrowKlass:
5089   case Bottom:                  // Ye Olde Default
5090     return Type::BOTTOM;
5091   case Top:
5092     return this;
5093 
5094   case InlineType:
5095     return t-&gt;xmeet(this);
5096 
5097   default:                      // All else is a mistake
5098     typerr(t);
5099 
5100   } // End of switch
5101 
5102   return this;
5103 }
5104 
5105 #ifndef PRODUCT
5106 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5107   _ptrtype-&gt;dump2(d, depth, st);
5108 }
5109 #endif
5110 
5111 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5112 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5113 
5114 
5115 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5116   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
5117 }
5118 
5119 const Type* TypeNarrowOop::remove_speculative() const {
5120   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
5121 }
5122 
5123 const Type* TypeNarrowOop::cleanup_speculative() const {
5124   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
5125 }
5126 
5127 #ifndef PRODUCT
5128 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5129   st-&gt;print(&quot;narrowoop: &quot;);
5130   TypeNarrowPtr::dump2(d, depth, st);
5131 }
5132 #endif
5133 
5134 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
5135 
5136 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
5137   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
5138 }
5139 
5140 #ifndef PRODUCT
5141 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5142   st-&gt;print(&quot;narrowklass: &quot;);
5143   TypeNarrowPtr::dump2(d, depth, st);
5144 }
5145 #endif
5146 
5147 
5148 //------------------------------eq---------------------------------------------
5149 // Structural equality check for Type representations
5150 bool TypeMetadataPtr::eq( const Type *t ) const {
5151   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
5152   ciMetadata* one = metadata();
5153   ciMetadata* two = a-&gt;metadata();
5154   if (one == NULL || two == NULL) {
5155     return (one == two) &amp;&amp; TypePtr::eq(t);
5156   } else {
5157     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5158   }
5159 }
5160 
5161 //------------------------------hash-------------------------------------------
5162 // Type-specific hashing function.
5163 int TypeMetadataPtr::hash(void) const {
5164   return
5165     (metadata() ? metadata()-&gt;hash() : 0) +
5166     TypePtr::hash();
5167 }
5168 
5169 //------------------------------singleton--------------------------------------
5170 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5171 // constants
5172 bool TypeMetadataPtr::singleton(void) const {
5173   // detune optimizer to not generate constant metadata + constant offset as a constant!
5174   // TopPTR, Null, AnyNull, Constant are all singletons
5175   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5176 }
5177 
5178 //------------------------------add_offset-------------------------------------
5179 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5180   return make( _ptr, _metadata, xadd_offset(offset));
5181 }
5182 
5183 //-----------------------------filter------------------------------------------
5184 // Do not allow interface-vs.-noninterface joins to collapse to top.
5185 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5186   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5187   if (ft == NULL || ft-&gt;empty())
5188     return Type::TOP;           // Canonical empty value
5189   return ft;
5190 }
5191 
5192  //------------------------------get_con----------------------------------------
5193 intptr_t TypeMetadataPtr::get_con() const {
5194   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5195   assert(offset() &gt;= 0, &quot;&quot;);
5196 
5197   if (offset() != 0) {
5198     // After being ported to the compiler interface, the compiler no longer
5199     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5200     // to a handle at compile time.  This handle is embedded in the generated
5201     // code and dereferenced at the time the nmethod is made.  Until that time,
5202     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5203     // have access to the addresses!).  This does not seem to currently happen,
5204     // but this assertion here is to help prevent its occurence.
5205     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5206     ShouldNotReachHere();
5207   }
5208 
5209   return (intptr_t)metadata()-&gt;constant_encoding();
5210 }
5211 
5212 //------------------------------cast_to_ptr_type-------------------------------
5213 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5214   if( ptr == _ptr ) return this;
5215   return make(ptr, metadata(), _offset);
5216 }
5217 
5218 //------------------------------meet-------------------------------------------
5219 // Compute the MEET of two types.  It returns a new Type object.
5220 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
5221   // Perform a fast test for common case; meeting the same types together.
5222   if( this == t ) return this;  // Meeting same type-rep?
5223 
5224   // Current &quot;this-&gt;_base&quot; is OopPtr
5225   switch (t-&gt;base()) {          // switch on original type
5226 
5227   case Int:                     // Mixing ints &amp; oops happens when javac
5228   case Long:                    // reuses local variables
5229   case FloatTop:
5230   case FloatCon:
5231   case FloatBot:
5232   case DoubleTop:
5233   case DoubleCon:
5234   case DoubleBot:
5235   case NarrowOop:
5236   case NarrowKlass:
5237   case Bottom:                  // Ye Olde Default
5238     return Type::BOTTOM;
5239   case Top:
5240     return this;
5241 
5242   default:                      // All else is a mistake
5243     typerr(t);
5244 
5245   case AnyPtr: {
5246     // Found an AnyPtr type vs self-OopPtr type
5247     const TypePtr *tp = t-&gt;is_ptr();
5248     Offset offset = meet_offset(tp-&gt;offset());
5249     PTR ptr = meet_ptr(tp-&gt;ptr());
5250     switch (tp-&gt;ptr()) {
5251     case Null:
5252       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5253       // else fall through:
5254     case TopPTR:
5255     case AnyNull: {
5256       return make(ptr, _metadata, offset);
5257     }
5258     case BotPTR:
5259     case NotNull:
5260       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5261     default: typerr(t);
5262     }
5263   }
5264 
5265   case RawPtr:
5266   case KlassPtr:
5267   case OopPtr:
5268   case InstPtr:
5269   case AryPtr:
5270     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5271 
5272   case MetadataPtr: {
5273     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
5274     Offset offset = meet_offset(tp-&gt;offset());
5275     PTR tptr = tp-&gt;ptr();
5276     PTR ptr = meet_ptr(tptr);
5277     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5278     if (tptr == TopPTR || _ptr == TopPTR ||
5279         metadata()-&gt;equals(tp-&gt;metadata())) {
5280       return make(ptr, md, offset);
5281     }
5282     // metadata is different
5283     if( ptr == Constant ) {  // Cannot be equal constants, so...
5284       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5285       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5286       ptr = NotNull;            // Fall down in lattice
5287     }
5288     return make(ptr, NULL, offset);
5289     break;
5290   }
5291   } // End of switch
5292   return this;                  // Return the double constant
5293 }
5294 
5295 
5296 //------------------------------xdual------------------------------------------
5297 // Dual of a pure metadata pointer.
5298 const Type *TypeMetadataPtr::xdual() const {
5299   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5300 }
5301 
5302 //------------------------------dump2------------------------------------------
5303 #ifndef PRODUCT
5304 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5305   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5306   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
5307   switch (offset()) {
5308   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5309   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5310   case         0: break;
5311   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;
5312   }
5313 }
5314 #endif
5315 
5316 
5317 //=============================================================================
5318 // Convenience common pre-built type.
5319 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5320 
5321 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):
5322   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5323 }
5324 
5325 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
5326   return make(Constant, m, Offset(0));
5327 }
5328 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5329   return make(Constant, m, Offset(0));
5330 }
5331 
5332 //------------------------------make-------------------------------------------
5333 // Create a meta data constant
5334 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5335   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5336   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5337 }
5338 
5339 
5340 //=============================================================================
5341 // Convenience common pre-built types.
5342 
5343 // Not-null object klass or below
5344 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5345 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5346 
5347 //------------------------------TypeKlassPtr-----------------------------------
5348 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5349   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
5350    assert(!klass-&gt;is_inlinetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
5351    assert(!flat_array || can_be_inline_type(), &quot;incorrect flatten array bit&quot;);
5352 }
5353 
5354 //------------------------------make-------------------------------------------
5355 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5356 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5357   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5358   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5359 }
5360 
5361 //------------------------------eq---------------------------------------------
5362 // Structural equality check for Type representations
5363 bool TypeKlassPtr::eq( const Type *t ) const {
5364   const TypeKlassPtr *p = t-&gt;is_klassptr();
5365   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5366 }
5367 
5368 //------------------------------hash-------------------------------------------
5369 // Type-specific hashing function.
5370 int TypeKlassPtr::hash(void) const {
5371   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
5372 }
5373 
5374 //------------------------------singleton--------------------------------------
5375 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5376 // constants
5377 bool TypeKlassPtr::singleton(void) const {
5378   // detune optimizer to not generate constant klass + constant offset as a constant!
5379   // TopPTR, Null, AnyNull, Constant are all singletons
5380   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5381 }
5382 
5383 // Do not allow interface-vs.-noninterface joins to collapse to top.
5384 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5385   // logic here mirrors the one from TypeOopPtr::filter. See comments
5386   // there.
5387   const Type* ft = join_helper(kills, include_speculative);
5388   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5389   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5390 
5391   if (ft-&gt;empty()) {
5392     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
5393       return kills;             // Uplift to interface
5394 
5395     return Type::TOP;           // Canonical empty value
5396   }
5397 
5398   // Interface klass type could be exact in opposite to interface type,
5399   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5400   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5401       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5402       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5403       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5404     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5405   }
5406 
5407   return ft;
5408 }
5409 
5410 //----------------------compute_klass------------------------------------------
5411 // Compute the defining klass for this class
5412 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5413   // Compute _klass based on element type.
5414   ciKlass* k_ary = NULL;
5415   const TypeAryPtr *tary;
5416   const Type* el = elem();
5417   if (el-&gt;isa_narrowoop()) {
5418     el = el-&gt;make_ptr();
5419   }
5420 
5421   // Get element klass
5422   if (el-&gt;isa_instptr()) {
5423     // Compute object array klass from element klass
5424     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass());
5425   } else if (el-&gt;isa_inlinetype()) {
5426     // If element type is TypeInlineType::BOTTOM, inline_klass() will be null.
5427     if (el-&gt;inline_klass() != NULL) {
5428       k_ary = ciArrayKlass::make(el-&gt;inline_klass());
5429     }
5430   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5431     // Compute array klass from element klass
5432     ciKlass* k_elem = tary-&gt;klass();
5433     // If element type is something like bottom[], k_elem will be null.
5434     if (k_elem != NULL)
5435       k_ary = ciObjArrayKlass::make(k_elem);
5436   } else if ((el-&gt;base() == Type::Top) ||
5437              (el-&gt;base() == Type::Bottom)) {
5438     // element type of Bottom occurs from meet of basic type
5439     // and object; Top occurs when doing join on Bottom.
5440     // Leave k_ary at NULL.
5441   } else {
5442     // Cannot compute array klass directly from basic type,
5443     // since subtypes of TypeInt all have basic type T_INT.
5444 #ifdef ASSERT
5445     if (verify &amp;&amp; el-&gt;isa_int()) {
5446       // Check simple cases when verifying klass.
5447       BasicType bt = T_ILLEGAL;
5448       if (el == TypeInt::BYTE) {
5449         bt = T_BYTE;
5450       } else if (el == TypeInt::SHORT) {
5451         bt = T_SHORT;
5452       } else if (el == TypeInt::CHAR) {
5453         bt = T_CHAR;
5454       } else if (el == TypeInt::INT) {
5455         bt = T_INT;
5456       } else {
5457         return _klass; // just return specified klass
5458       }
5459       return ciTypeArrayKlass::make(bt);
5460     }
5461 #endif
5462     assert(!el-&gt;isa_int(),
5463            &quot;integral arrays must be pre-equipped with a class&quot;);
5464     // Compute array klass directly from basic type
5465     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5466   }
5467   return k_ary;
5468 }
5469 
5470 //------------------------------klass------------------------------------------
5471 // Return the defining klass for this class
5472 ciKlass* TypeAryPtr::klass() const {
5473   if( _klass ) return _klass;   // Return cached value, if possible
5474 
5475   // Oops, need to compute _klass and cache it
5476   ciKlass* k_ary = compute_klass();
5477 
5478   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5479     // The _klass field acts as a cache of the underlying
5480     // ciKlass for this array type.  In order to set the field,
5481     // we need to cast away const-ness.
5482     //
5483     // IMPORTANT NOTE: we *never* set the _klass field for the
5484     // type TypeAryPtr::OOPS.  This Type is shared between all
5485     // active compilations.  However, the ciKlass which represents
5486     // this Type is *not* shared between compilations, so caching
5487     // this value would result in fetching a dangling pointer.
5488     //
5489     // Recomputing the underlying ciKlass for each request is
5490     // a bit less efficient than caching, but calls to
5491     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5492     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5493     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5494         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5495       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5496     }
5497   }
5498   return k_ary;
5499 }
5500 
5501 
5502 //------------------------------add_offset-------------------------------------
5503 // Access internals of klass object
5504 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5505   return make(_ptr, klass(), xadd_offset(offset), flat_array());
5506 }
5507 
5508 //------------------------------cast_to_ptr_type-------------------------------
5509 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5510   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5511   if( ptr == _ptr ) return this;
5512   return make(ptr, _klass, _offset, _flat_array);
5513 }
5514 
5515 
5516 //-----------------------------cast_to_exactness-------------------------------
5517 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5518   if( klass_is_exact == _klass_is_exact ) return this;
5519   if (!UseExactTypes)  return this;
5520   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5521 }
5522 
5523 
5524 //-----------------------------as_instance_type--------------------------------
5525 // Corresponding type for an instance of the given class.
5526 // It will be NotNull, and exact if and only if the klass type is exact.
5527 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5528   ciKlass* k = klass();
5529   assert(k != NULL, &quot;klass should not be NULL&quot;);
5530   bool    xk = klass_is_exact();
5531   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5532   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5533   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5534   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5535   if (flat_array() &amp;&amp; !klass()-&gt;is_inlinetype()) {
5536     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5537   }
5538   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5539 }
5540 
5541 
5542 //------------------------------xmeet------------------------------------------
5543 // Compute the MEET of two types, return a new Type object.
5544 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5545   // Perform a fast test for common case; meeting the same types together.
5546   if( this == t ) return this;  // Meeting same type-rep?
5547 
5548   // Current &quot;this-&gt;_base&quot; is Pointer
5549   switch (t-&gt;base()) {          // switch on original type
5550 
5551   case Int:                     // Mixing ints &amp; oops happens when javac
5552   case Long:                    // reuses local variables
5553   case FloatTop:
5554   case FloatCon:
5555   case FloatBot:
5556   case DoubleTop:
5557   case DoubleCon:
5558   case DoubleBot:
5559   case NarrowOop:
5560   case NarrowKlass:
5561   case Bottom:                  // Ye Olde Default
5562     return Type::BOTTOM;
5563   case Top:
5564     return this;
5565 
5566   default:                      // All else is a mistake
5567     typerr(t);
5568 
5569   case AnyPtr: {                // Meeting to AnyPtrs
5570     // Found an AnyPtr type vs self-KlassPtr type
5571     const TypePtr *tp = t-&gt;is_ptr();
5572     Offset offset = meet_offset(tp-&gt;offset());
5573     PTR ptr = meet_ptr(tp-&gt;ptr());
5574     switch (tp-&gt;ptr()) {
5575     case TopPTR:
5576       return this;
5577     case Null:
5578       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5579     case AnyNull:
5580       return make(ptr, klass(), offset, flat_array());
5581     case BotPTR:
5582     case NotNull:
5583       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5584     default: typerr(t);
5585     }
5586   }
5587 
5588   case RawPtr:
5589   case MetadataPtr:
5590   case OopPtr:
5591   case AryPtr:                  // Meet with AryPtr
5592   case InstPtr:                 // Meet with InstPtr
5593     return TypePtr::BOTTOM;
5594 
5595   //
5596   //             A-top         }
5597   //           /   |   \       }  Tops
5598   //       B-top A-any C-top   }
5599   //          | /  |  \ |      }  Any-nulls
5600   //       B-any   |   C-any   }
5601   //          |    |    |
5602   //       B-con A-con C-con   } constants; not comparable across classes
5603   //          |    |    |
5604   //       B-not   |   C-not   }
5605   //          | \  |  / |      }  not-nulls
5606   //       B-bot A-not C-bot   }
5607   //           \   |   /       }  Bottoms
5608   //             A-bot         }
5609   //
5610 
5611   case KlassPtr: {  // Meet two KlassPtr types
5612     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5613     Offset  off  = meet_offset(tkls-&gt;offset());
5614     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5615 
5616     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5617       ciKlass* k = NULL;
5618       if (ptr == Constant) {
5619         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5620       }
5621       return make(ptr, k, off, false);
5622     }
5623 
5624     // Check for easy case; klasses are equal (and perhaps not loaded!)
5625     // If we have constants, then we created oops so classes are loaded
5626     // and we can handle the constants further down.  This case handles
5627     // not-loaded classes
5628     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {
5629       return make(ptr, klass(), off, flat_array());
5630     }
5631 
5632     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5633     ciKlass* tkls_klass = tkls-&gt;klass();
5634     ciKlass* this_klass = this-&gt;klass();
5635     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5636     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5637     bool tkls_flat_array = tkls-&gt;flat_array();
5638     bool this_flat_array  = this-&gt;flat_array();
5639     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);
5640 
5641     // If &#39;this&#39; type is above the centerline and is a superclass of the
5642     // other, we can treat &#39;this&#39; as having the same type as the other.
5643     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5644         tkls_klass-&gt;is_subtype_of(this_klass)) {
5645       this_klass = tkls_klass;
5646     }
5647     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5648     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5649     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5650         this_klass-&gt;is_subtype_of(tkls_klass)) {
5651       tkls_klass = this_klass;
5652     }
5653 
5654     // Check for classes now being equal
5655     if (tkls_klass-&gt;equals(this_klass)) {
5656       // If the klasses are equal, the constants may still differ.  Fall to
5657       // NotNull if they do (neither constant is NULL; that is a special case
5658       // handled elsewhere).
5659       if( ptr == Constant ) {
5660         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5661             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5662         else if (above_centerline(this-&gt;ptr()));
5663         else if (above_centerline(tkls-&gt;ptr()));
5664         else
5665           ptr = NotNull;
5666       }
5667       return make(ptr, this_klass, off, flat_array);
5668     } // Else classes are not equal
5669 
5670     // Since klasses are different, we require the LCA in the Java
5671     // class hierarchy - which means we have to fall to at least NotNull.
5672     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5673       ptr = NotNull;
5674     // Now we find the LCA of Java classes
5675     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5676     return   make(ptr, k, off, k-&gt;is_inlinetype() &amp;&amp; k-&gt;flatten_array());
5677   } // End of case KlassPtr
5678 
5679   } // End of switch
5680   return this;                  // Return the double constant
5681 }
5682 
5683 //------------------------------xdual------------------------------------------
5684 // Dual: compute field-by-field dual
5685 const Type    *TypeKlassPtr::xdual() const {
5686   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5687 }
5688 
5689 //------------------------------get_con----------------------------------------
5690 intptr_t TypeKlassPtr::get_con() const {
5691   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5692   assert(offset() &gt;= 0, &quot;&quot;);
5693 
5694   if (offset() != 0) {
5695     // After being ported to the compiler interface, the compiler no longer
5696     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5697     // to a handle at compile time.  This handle is embedded in the generated
5698     // code and dereferenced at the time the nmethod is made.  Until that time,
5699     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5700     // have access to the addresses!).  This does not seem to currently happen,
5701     // but this assertion here is to help prevent its occurence.
5702     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5703     ShouldNotReachHere();
5704   }
5705 
5706   return (intptr_t)klass()-&gt;constant_encoding();
5707 }
5708 //------------------------------dump2------------------------------------------
5709 // Dump Klass Type
5710 #ifndef PRODUCT
5711 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5712   switch( _ptr ) {
5713   case Constant:
5714     st-&gt;print(&quot;precise &quot;);
5715   case NotNull:
5716     {
5717       if (klass() != NULL) {
5718         const char* name = klass()-&gt;name()-&gt;as_utf8();
5719         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5720       } else {
5721         st-&gt;print(&quot;klass BOTTOM&quot;);
5722       }
5723     }
5724   case BotPTR:
5725     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5726   case TopPTR:
5727   case AnyNull:
5728     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5729     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5730     break;
5731   default:
5732     break;
5733   }
5734 
5735   _offset.dump2(st);
5736 
5737   st-&gt;print(&quot; *&quot;);
5738 }
5739 #endif
5740 
5741 
5742 
5743 //=============================================================================
5744 // Convenience common pre-built types.
5745 
5746 //------------------------------make-------------------------------------------
5747 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,
5748                                const TypeTuple *range_sig, const TypeTuple *range_cc) {
5749   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();
5750 }
5751 
5752 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5753   return make(domain, domain, range, range);
5754 }
5755 
5756 //------------------------------osr_domain-----------------------------
5757 const TypeTuple* osr_domain() {
5758   const Type **fields = TypeTuple::fields(2);
5759   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5760   return TypeTuple::make(TypeFunc::Parms+1, fields);
5761 }
5762 
5763 //------------------------------make-------------------------------------------
5764 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5765   Compile* C = Compile::current();
5766   const TypeFunc* tf = NULL;
5767   if (!is_osr_compilation) {
5768     tf = C-&gt;last_tf(method); // check cache
5769     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5770   }
5771   // Inline types are not passed/returned by reference, instead each field of
5772   // the inline type is passed/returned as an argument. We maintain two views of
5773   // the argument/return list here: one based on the signature (with an inline
5774   // type argument/return as a single slot), one based on the actual calling
5775   // convention (with an inline type argument/return as a list of its fields).
5776   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5777   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5778   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5779   ciSignature* sig = method-&gt;signature();
5780   bool has_scalar_ret = sig-&gt;return_type()-&gt;is_inlinetype() &amp;&amp; sig-&gt;return_type()-&gt;as_inline_klass()-&gt;can_be_returned_as_fields();
5781   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5782   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5783   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5784   if (!is_osr_compilation) {
5785     C-&gt;set_last_tf(method, tf);  // fill cache
5786   }
5787   return tf;
5788 }
5789 
5790 //------------------------------meet-------------------------------------------
5791 // Compute the MEET of two types.  It returns a new Type object.
5792 const Type *TypeFunc::xmeet( const Type *t ) const {
5793   // Perform a fast test for common case; meeting the same types together.
5794   if( this == t ) return this;  // Meeting same type-rep?
5795 
5796   // Current &quot;this-&gt;_base&quot; is Func
5797   switch (t-&gt;base()) {          // switch on original type
5798 
5799   case Bottom:                  // Ye Olde Default
5800     return t;
5801 
5802   default:                      // All else is a mistake
5803     typerr(t);
5804 
5805   case Top:
5806     break;
5807   }
5808   return this;                  // Return the double constant
5809 }
5810 
5811 //------------------------------xdual------------------------------------------
5812 // Dual: compute field-by-field dual
5813 const Type *TypeFunc::xdual() const {
5814   return this;
5815 }
5816 
5817 //------------------------------eq---------------------------------------------
5818 // Structural equality check for Type representations
5819 bool TypeFunc::eq( const Type *t ) const {
5820   const TypeFunc *a = (const TypeFunc*)t;
5821   return _domain_sig == a-&gt;_domain_sig &amp;&amp;
5822     _domain_cc == a-&gt;_domain_cc &amp;&amp;
5823     _range_sig == a-&gt;_range_sig &amp;&amp;
5824     _range_cc == a-&gt;_range_cc;
5825 }
5826 
5827 //------------------------------hash-------------------------------------------
5828 // Type-specific hashing function.
5829 int TypeFunc::hash(void) const {
5830   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;
5831 }
5832 
5833 //------------------------------dump2------------------------------------------
5834 // Dump Function Type
5835 #ifndef PRODUCT
5836 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5837   if( _range_sig-&gt;cnt() &lt;= Parms )
5838     st-&gt;print(&quot;void&quot;);
5839   else {
5840     uint i;
5841     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {
5842       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5843       st-&gt;print(&quot;/&quot;);
5844     }
5845     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5846   }
5847   st-&gt;print(&quot; &quot;);
5848   st-&gt;print(&quot;( &quot;);
5849   if( !depth || d[this] ) {     // Check for recursive dump
5850     st-&gt;print(&quot;...)&quot;);
5851     return;
5852   }
5853   d.Insert((void*)this,(void*)this);    // Stop recursion
5854   if (Parms &lt; _domain_sig-&gt;cnt())
5855     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5856   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {
5857     st-&gt;print(&quot;, &quot;);
5858     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5859   }
5860   st-&gt;print(&quot; )&quot;);
5861 }
5862 #endif
5863 
5864 //------------------------------singleton--------------------------------------
5865 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5866 // constants (Ldi nodes).  Singletons are integer, float or double constants
5867 // or a single symbol.
5868 bool TypeFunc::singleton(void) const {
5869   return false;                 // Never a singleton
5870 }
5871 
5872 bool TypeFunc::empty(void) const {
5873   return false;                 // Never empty
5874 }
5875 
5876 
5877 BasicType TypeFunc::return_type() const{
5878   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {
5879     return T_VOID;
5880   }
5881   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5882 }
    </pre>
  </body>
</html>