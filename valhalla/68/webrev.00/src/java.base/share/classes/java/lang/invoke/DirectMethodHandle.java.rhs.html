<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/DirectMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.misc.Unsafe;
  29 import jdk.internal.vm.annotation.ForceInline;
  30 import jdk.internal.vm.annotation.Stable;
  31 import sun.invoke.util.ValueConversions;
  32 import sun.invoke.util.VerifyAccess;
  33 import sun.invoke.util.VerifyType;
  34 import sun.invoke.util.Wrapper;
  35 
  36 import java.lang.ref.WeakReference;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 
  40 import static java.lang.invoke.LambdaForm.*;
  41 import static java.lang.invoke.LambdaForm.Kind.*;
  42 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  44 import static java.lang.invoke.MethodHandleStatics.newInternalError;
  45 import static java.lang.invoke.MethodTypeForm.*;
  46 
  47 /**
  48  * The flavor of method handle which implements a constant reference
  49  * to a class member.
  50  * @author jrose
  51  */
  52 class DirectMethodHandle extends MethodHandle {
  53     final MemberName member;
  54     final boolean crackable;
  55 
  56     // Constructors and factory methods in this class *must* be package scoped or private.
  57     private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member, boolean crackable) {
  58         super(mtype, form);
  59         if (!member.isResolved())  throw new InternalError();
  60 
  61         if (member.getDeclaringClass().isInterface() &amp;&amp;
  62             member.getReferenceKind() == REF_invokeInterface &amp;&amp;
  63             member.isMethod() &amp;&amp; !member.isAbstract()) {
  64             // Check for corner case: invokeinterface of Object method
  65             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
  66             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
  67             if (m != null &amp;&amp; m.isPublic()) {
  68                 assert(member.getReferenceKind() == m.getReferenceKind());  // else this.form is wrong
  69                 member = m;
  70             }
  71         }
  72 
  73         this.member = member;
  74         this.crackable = crackable;
  75     }
  76 
  77     // Factory methods:
  78     static DirectMethodHandle make(byte refKind, Class&lt;?&gt; refc, MemberName member, Class&lt;?&gt; callerClass) {
  79         MethodType mtype = member.getMethodOrFieldType();
  80         if (!member.isStatic()) {
  81             if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())
  82                 throw new InternalError(member.toString());
  83             mtype = mtype.insertParameterTypes(0, refc);
  84         }
  85         if (!member.isField()) {
  86             // refKind reflects the original type of lookup via findSpecial or
  87             // findVirtual etc.
  88             switch (refKind) {
  89                 case REF_invokeSpecial: {
  90                     member = member.asSpecial();
  91                     // if caller is an interface we need to adapt to get the
  92                     // receiver check inserted
  93                     if (callerClass == null) {
  94                         throw new InternalError(&quot;callerClass must not be null for REF_invokeSpecial&quot;);
  95                     }
  96                     LambdaForm lform = preparedLambdaForm(member, callerClass.isInterface());
  97                     return new Special(mtype, lform, member, true, callerClass);
  98                 }
  99                 case REF_invokeInterface: {
 100                     // for interfaces we always need the receiver typecheck,
 101                     // so we always pass &#39;true&#39; to ensure we adapt if needed
 102                     // to include the REF_invokeSpecial case
 103                     LambdaForm lform = preparedLambdaForm(member, true);
 104                     return new Interface(mtype, lform, member, true, refc);
 105                 }
 106                 default: {
 107                     LambdaForm lform = preparedLambdaForm(member);
 108                     return new DirectMethodHandle(mtype, lform, member, true);
 109                 }
 110             }
 111         } else {
 112             LambdaForm lform = preparedFieldLambdaForm(member);
 113             if (member.isStatic()) {
 114                 long offset = MethodHandleNatives.staticFieldOffset(member);
 115                 Object base = MethodHandleNatives.staticFieldBase(member);
<a name="1" id="anc1"></a><span class="line-modified"> 116                 return member.isInlineableField() ? new InlineStaticAccessor(mtype, lform, member, true, base, offset)</span>
<span class="line-modified"> 117                                                   : new StaticAccessor(mtype, lform, member, true, base, offset);</span>
 118             } else {
 119                 long offset = MethodHandleNatives.objectFieldOffset(member);
 120                 assert(offset == (int)offset);
<a name="2" id="anc2"></a><span class="line-modified"> 121                 return  member.isInlineableField() ? new InlineAccessor(mtype, lform, member, true, (int)offset)</span>
<span class="line-modified"> 122                                                    : new Accessor(mtype, lform, member, true, (int)offset);</span>
 123             }
 124         }
 125     }
 126     static DirectMethodHandle make(Class&lt;?&gt; refc, MemberName member) {
 127         byte refKind = member.getReferenceKind();
 128         if (refKind == REF_invokeSpecial)
 129             refKind =  REF_invokeVirtual;
 130         return make(refKind, refc, member, null /* no callerClass context */);
 131     }
 132     static DirectMethodHandle make(MemberName member) {
 133         if (member.isObjectConstructor() &amp;&amp; member.getReturnType() == void.class)
 134             return makeAllocator(member);
 135         return make(member.getDeclaringClass(), member);
 136     }
 137     private static DirectMethodHandle makeAllocator(MemberName ctor) {
 138         assert(ctor.isObjectConstructor() &amp;&amp; !ctor.getDeclaringClass().isInlineClass()) : ctor;
 139 
 140         Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();
 141         ctor = ctor.asObjectConstructor();
 142         assert(ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;
 143         MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);
 144         LambdaForm lform = preparedLambdaForm(ctor);
 145         MemberName init = ctor.asSpecial();
 146         assert(init.getMethodType().returnType() == void.class);
 147         return new Constructor(mtype, lform, ctor, true, init, instanceClass);
 148     }
 149 
 150     @Override
 151     BoundMethodHandle rebind() {
 152         return BoundMethodHandle.makeReinvoker(this);
 153     }
 154 
 155     @Override
 156     MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 157         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
 158         return new DirectMethodHandle(mt, lf, member, crackable);
 159     }
 160 
 161     @Override
 162     MethodHandle viewAsType(MethodType newType, boolean strict) {
 163         // No actual conversions, just a new view of the same method.
 164         // However, we must not expose a DMH that is crackable into a
 165         // MethodHandleInfo, so we return a cloned, uncrackable DMH
 166         assert(viewAsTypeChecks(newType, strict));
 167         assert(this.getClass() == DirectMethodHandle.class);  // must override in subclasses
 168         return new DirectMethodHandle(newType, form, member, false);
 169     }
 170 
 171     @Override
 172     boolean isCrackable() {
 173         return crackable;
 174     }
 175 
 176     @Override
 177     String internalProperties() {
 178         return &quot;\n&amp; DMH.MN=&quot;+internalMemberName();
 179     }
 180 
 181     //// Implementation methods.
 182     @Override
 183     @ForceInline
 184     MemberName internalMemberName() {
 185         return member;
 186     }
 187 
 188     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
 189 
 190     /**
 191      * Create a LF which can invoke the given method.
 192      * Cache and share this structure among all methods with
 193      * the same basicType and refKind.
 194      */
 195     private static LambdaForm preparedLambdaForm(MemberName m, boolean adaptToSpecialIfc) {
 196         assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead
 197         MethodType mtype = m.getInvocationType().basicType();
 198         assert(!m.isMethodHandleInvoke()) : m;
 199         int which;
 200         // MemberName.getReferenceKind represents the JVM optimized form of the call
 201         // as distinct from the &quot;kind&quot; passed to DMH.make which represents the original
 202         // bytecode-equivalent request. Specifically private/final methods that use a direct
 203         // call have getReferenceKind adapted to REF_invokeSpecial, even though the actual
 204         // invocation mode may be invokevirtual or invokeinterface.
 205         switch (m.getReferenceKind()) {
 206         case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;
 207         case REF_invokeStatic:     which = LF_INVSTATIC;     break;
 208         case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;
 209         case REF_invokeInterface:  which = LF_INVINTERFACE;  break;
 210         case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;
 211         default:  throw new InternalError(m.toString());
 212         }
 213         if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {
 214             // precompute the barrier-free version:
 215             preparedLambdaForm(mtype, which);
 216             which = LF_INVSTATIC_INIT;
 217         }
 218         if (which == LF_INVSPECIAL &amp;&amp; adaptToSpecialIfc) {
 219             which = LF_INVSPECIAL_IFC;
 220         }
 221         LambdaForm lform = preparedLambdaForm(mtype, which);
 222         maybeCompile(lform, m);
 223         assert(lform.methodType().dropParameterTypes(0, 1)
 224                 .equals(m.getInvocationType().basicType()))
 225                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 226         return lform;
 227     }
 228 
 229     private static LambdaForm preparedLambdaForm(MemberName m) {
 230         return preparedLambdaForm(m, false);
 231     }
 232 
 233     private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
 234         LambdaForm lform = mtype.form().cachedLambdaForm(which);
 235         if (lform != null)  return lform;
 236         lform = makePreparedLambdaForm(mtype, which);
 237         return mtype.form().setCachedLambdaForm(which, lform);
 238     }
 239 
 240     static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
 241         boolean needsInit = (which == LF_INVSTATIC_INIT);
 242         boolean doesAlloc = (which == LF_NEWINVSPECIAL);
 243         boolean needsReceiverCheck = (which == LF_INVINTERFACE ||
 244                                       which == LF_INVSPECIAL_IFC);
 245 
 246         String linkerName;
 247         LambdaForm.Kind kind;
 248         switch (which) {
 249         case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;   kind = DIRECT_INVOKE_VIRTUAL;     break;
 250         case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC;      break;
 251         case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;    kind = DIRECT_INVOKE_STATIC_INIT; break;
 252         case LF_INVSPECIAL_IFC:linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL_IFC; break;
 253         case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_INVOKE_SPECIAL;     break;
 254         case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;; kind = DIRECT_INVOKE_INTERFACE;   break;
 255         case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;   kind = DIRECT_NEW_INVOKE_SPECIAL; break;
 256         default:  throw new InternalError(&quot;which=&quot;+which);
 257         }
 258 
 259         MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);
 260         if (doesAlloc)
 261             mtypeWithArg = mtypeWithArg
 262                     .insertParameterTypes(0, Object.class)  // insert newly allocated obj
 263                     .changeReturnType(void.class);          // &lt;init&gt; returns void
 264         MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);
 265         try {
 266             linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
 267         } catch (ReflectiveOperationException ex) {
 268             throw newInternalError(ex);
 269         }
 270         final int DMH_THIS    = 0;
 271         final int ARG_BASE    = 1;
 272         final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();
 273         int nameCursor = ARG_LIMIT;
 274         final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);
 275         final int GET_MEMBER  = nameCursor++;
 276         final int CHECK_RECEIVER = (needsReceiverCheck ? nameCursor++ : -1);
 277         final int LINKER_CALL = nameCursor++;
 278         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 279         assert(names.length == nameCursor);
 280         if (doesAlloc) {
 281             // names = { argx,y,z,... new C, init method }
 282             names[NEW_OBJ] = new Name(getFunction(NF_allocateInstance), names[DMH_THIS]);
 283             names[GET_MEMBER] = new Name(getFunction(NF_constructorMethod), names[DMH_THIS]);
 284         } else if (needsInit) {
 285             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberNameEnsureInit), names[DMH_THIS]);
 286         } else {
 287             names[GET_MEMBER] = new Name(getFunction(NF_internalMemberName), names[DMH_THIS]);
 288         }
 289         assert(findDirectMethodHandle(names[GET_MEMBER]) == names[DMH_THIS]);
 290         Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);
 291         if (needsReceiverCheck) {
 292             names[CHECK_RECEIVER] = new Name(getFunction(NF_checkReceiver), names[DMH_THIS], names[ARG_BASE]);
 293             outArgs[0] = names[CHECK_RECEIVER];
 294         }
 295         assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!
 296         int result = LAST_RESULT;
 297         if (doesAlloc) {
 298             assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one
 299             System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);
 300             outArgs[0] = names[NEW_OBJ];
 301             result = NEW_OBJ;
 302         }
 303         names[LINKER_CALL] = new Name(linker, outArgs);
 304         LambdaForm lform = new LambdaForm(ARG_LIMIT, names, result, kind);
 305 
 306         // This is a tricky bit of code.  Don&#39;t send it through the LF interpreter.
 307         lform.compileToBytecode();
 308         return lform;
 309     }
 310 
 311     /* assert */ static Object findDirectMethodHandle(Name name) {
 312         if (name.function.equals(getFunction(NF_internalMemberName)) ||
 313             name.function.equals(getFunction(NF_internalMemberNameEnsureInit)) ||
 314             name.function.equals(getFunction(NF_constructorMethod))) {
 315             assert(name.arguments.length == 1);
 316             return name.arguments[0];
 317         }
 318         return null;
 319     }
 320 
 321     private static void maybeCompile(LambdaForm lform, MemberName m) {
 322         if (lform.vmentry == null &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))
 323             // Help along bootstrapping...
 324             lform.compileToBytecode();
 325     }
 326 
 327     /** Static wrapper for DirectMethodHandle.internalMemberName. */
 328     @ForceInline
 329     /*non-public*/
 330     static Object internalMemberName(Object mh) {
 331         return ((DirectMethodHandle)mh).member;
 332     }
 333 
 334     /** Static wrapper for DirectMethodHandle.internalMemberName.
 335      * This one also forces initialization.
 336      */
 337     /*non-public*/
 338     static Object internalMemberNameEnsureInit(Object mh) {
 339         DirectMethodHandle dmh = (DirectMethodHandle)mh;
 340         dmh.ensureInitialized();
 341         return dmh.member;
 342     }
 343 
 344     /*non-public*/
 345     static boolean shouldBeInitialized(MemberName member) {
 346         switch (member.getReferenceKind()) {
 347         case REF_invokeStatic:
 348         case REF_getStatic:
 349         case REF_putStatic:
 350         case REF_newInvokeSpecial:
 351             break;
 352         default:
 353             // No need to initialize the class on this kind of member.
 354             return false;
 355         }
 356         Class&lt;?&gt; cls = member.getDeclaringClass();
 357         if (cls == ValueConversions.class ||
 358             cls == MethodHandleImpl.class ||
 359             cls == Invokers.class) {
 360             // These guys have lots of &lt;clinit&gt; DMH creation but we know
 361             // the MHs will not be used until the system is booted.
 362             return false;
 363         }
 364         if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||
 365             VerifyAccess.isSamePackage(ValueConversions.class, cls)) {
 366             // It is a system class.  It is probably in the process of
 367             // being initialized, but we will help it along just to be safe.
 368             if (UNSAFE.shouldBeInitialized(cls)) {
 369                 UNSAFE.ensureClassInitialized(cls);
 370             }
 371             return false;
 372         }
 373         return UNSAFE.shouldBeInitialized(cls);
 374     }
 375 
 376     private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {
 377         @Override
 378         protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
 379             UNSAFE.ensureClassInitialized(type);
 380             if (UNSAFE.shouldBeInitialized(type))
 381                 // If the previous call didn&#39;t block, this can happen.
 382                 // We are executing inside &lt;clinit&gt;.
 383                 return new WeakReference&lt;&gt;(Thread.currentThread());
 384             return null;
 385         }
 386         static final EnsureInitialized INSTANCE = new EnsureInitialized();
 387     }
 388 
 389     private void ensureInitialized() {
 390         if (checkInitialized(member)) {
 391             // The coast is clear.  Delete the &lt;clinit&gt; barrier.
 392             if (member.isField())
 393                 updateForm(preparedFieldLambdaForm(member));
 394             else
 395                 updateForm(preparedLambdaForm(member));
 396         }
 397     }
 398     private static boolean checkInitialized(MemberName member) {
 399         Class&lt;?&gt; defc = member.getDeclaringClass();
 400         WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);
 401         if (ref == null) {
 402             return true;  // the final state
 403         }
 404         Thread clinitThread = ref.get();
 405         // Somebody may still be running defc.&lt;clinit&gt;.
 406         if (clinitThread == Thread.currentThread()) {
 407             // If anybody is running defc.&lt;clinit&gt;, it is this thread.
 408             if (UNSAFE.shouldBeInitialized(defc))
 409                 // Yes, we are running it; keep the barrier for now.
 410                 return false;
 411         } else {
 412             // We are in a random thread.  Block.
 413             UNSAFE.ensureClassInitialized(defc);
 414         }
 415         assert(!UNSAFE.shouldBeInitialized(defc));
 416         // put it into the final state
 417         EnsureInitialized.INSTANCE.remove(defc);
 418         return true;
 419     }
 420 
 421     /*non-public*/
 422     static void ensureInitialized(Object mh) {
 423         ((DirectMethodHandle)mh).ensureInitialized();
 424     }
 425 
 426     /** This subclass represents invokespecial instructions. */
 427     static class Special extends DirectMethodHandle {
 428         private final Class&lt;?&gt; caller;
 429         private Special(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; caller) {
 430             super(mtype, form, member, crackable);
 431             this.caller = caller;
 432         }
 433         @Override
 434         boolean isInvokeSpecial() {
 435             return true;
 436         }
 437         @Override
 438         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 439             return new Special(mt, lf, member, crackable, caller);
 440         }
 441         @Override
 442         MethodHandle viewAsType(MethodType newType, boolean strict) {
 443             assert(viewAsTypeChecks(newType, strict));
 444             return new Special(newType, form, member, false, caller);
 445         }
 446         Object checkReceiver(Object recv) {
 447             if (!caller.isInstance(recv)) {
 448                 String msg = String.format(&quot;Receiver class %s is not a subclass of caller class %s&quot;,
 449                                            recv.getClass().getName(), caller.getName());
 450                 throw new IncompatibleClassChangeError(msg);
 451             }
 452             return recv;
 453         }
 454     }
 455 
 456     /** This subclass represents invokeinterface instructions. */
 457     static class Interface extends DirectMethodHandle {
 458         private final Class&lt;?&gt; refc;
 459         private Interface(MethodType mtype, LambdaForm form, MemberName member, boolean crackable, Class&lt;?&gt; refc) {
 460             super(mtype, form, member, crackable);
 461             assert(refc.isInterface()) : refc;
 462             this.refc = refc;
 463         }
 464         @Override
 465         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 466             return new Interface(mt, lf, member, crackable, refc);
 467         }
 468         @Override
 469         MethodHandle viewAsType(MethodType newType, boolean strict) {
 470             assert(viewAsTypeChecks(newType, strict));
 471             return new Interface(newType, form, member, false, refc);
 472         }
 473         @Override
 474         Object checkReceiver(Object recv) {
 475             if (!refc.isInstance(recv)) {
 476                 String msg = String.format(&quot;Receiver class %s does not implement the requested interface %s&quot;,
 477                                            recv.getClass().getName(), refc.getName());
 478                 throw new IncompatibleClassChangeError(msg);
 479             }
 480             return recv;
 481         }
 482     }
 483 
 484     /** Used for interface receiver type checks, by Interface and Special modes. */
 485     Object checkReceiver(Object recv) {
 486         throw new InternalError(&quot;Should only be invoked on a subclass&quot;);
 487     }
 488 
 489     /** This subclass handles constructor references. */
 490     static class Constructor extends DirectMethodHandle {
 491         final MemberName initMethod;
 492         final Class&lt;?&gt;   instanceClass;
 493 
 494         private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
 495                             boolean crackable, MemberName initMethod, Class&lt;?&gt; instanceClass) {
 496             super(mtype, form, constructor, crackable);
 497             this.initMethod = initMethod;
 498             this.instanceClass = instanceClass;
 499             assert(initMethod.isResolved());
 500         }
 501         @Override
 502         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
 503             return new Constructor(mt, lf, member, crackable, initMethod, instanceClass);
 504         }
 505         @Override
 506         MethodHandle viewAsType(MethodType newType, boolean strict) {
 507             assert(viewAsTypeChecks(newType, strict));
 508             return new Constructor(newType, form, member, false, initMethod, instanceClass);
 509         }
 510     }
 511 
 512     /*non-public*/
 513     static Object constructorMethod(Object mh) {
 514         Constructor dmh = (Constructor)mh;
 515         return dmh.initMethod;
 516     }
 517 
 518     /*non-public*/
 519     static Object allocateInstance(Object mh) throws InstantiationException {
 520         Constructor dmh = (Constructor)mh;
 521         return UNSAFE.allocateInstance(dmh.instanceClass);
 522     }
 523 
 524     /** This subclass handles non-static field references. */
<a name="3" id="anc3"></a><span class="line-modified"> 525     static class Accessor extends DirectMethodHandle {</span>
 526         final Class&lt;?&gt; fieldType;
 527         final int      fieldOffset;
 528         private Accessor(MethodType mtype, LambdaForm form, MemberName member,
 529                          boolean crackable, int fieldOffset) {
 530             super(mtype, form, member, crackable);
 531             this.fieldType   = member.getFieldType();
 532             this.fieldOffset = fieldOffset;
 533         }
<a name="4" id="anc4"></a>









 534 
 535         @Override Object checkCast(Object obj) {
 536             return fieldType.cast(obj);
 537         }
 538         @Override
 539         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="5" id="anc5"></a><span class="line-modified"> 540             return new Accessor(mt, lf, member, crackable, fieldOffset);</span>
 541         }
 542         @Override
 543         MethodHandle viewAsType(MethodType newType, boolean strict) {
 544             assert(viewAsTypeChecks(newType, strict));
<a name="6" id="anc6"></a><span class="line-modified"> 545             return new Accessor(newType, form, member, false, fieldOffset);</span>
 546         }
 547     }
 548 
 549     /** This subclass handles non-static field references of inline type */
 550     static class InlineAccessor extends Accessor {
 551         private InlineAccessor(MethodType mtype, LambdaForm form, MemberName member,
<a name="7" id="anc7"></a><span class="line-modified"> 552                                boolean crackable, int fieldOffset) {</span>
<span class="line-modified"> 553             super(mtype, form, member, crackable, fieldOffset);</span>
 554         }
 555 
 556         @Override Object checkCast(Object obj) {
 557             return fieldType.cast(Objects.requireNonNull(obj));
 558         }
 559         @Override
 560         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="8" id="anc8"></a><span class="line-modified"> 561             return new InlineAccessor(mt, lf, member, crackable, fieldOffset);</span>
<span class="line-added"> 562         }</span>
<span class="line-added"> 563         @Override</span>
<span class="line-added"> 564         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 565             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 566             return new InlineAccessor(newType, form, member, false, fieldOffset);</span>
 567         }
 568     }
 569 
 570     @ForceInline
 571     /*non-public*/
 572     static long fieldOffset(Object accessorObj) {
 573         // Note: We return a long because that is what Unsafe.getObject likes.
 574         // We store a plain int because it is more compact.
 575         return ((Accessor)accessorObj).fieldOffset;
 576     }
 577 
 578     @ForceInline
 579     /*non-public*/
 580     static Object checkBase(Object obj) {
 581         // Note that the object&#39;s class has already been verified,
 582         // since the parameter type of the Accessor method handle
 583         // is either member.getDeclaringClass or a subclass.
 584         // This was verified in DirectMethodHandle.make.
 585         // Therefore, the only remaining check is for null.
 586         // Since this check is *not* guaranteed by Unsafe.getInt
 587         // and its siblings, we need to make an explicit one here.
 588         return Objects.requireNonNull(obj);
 589     }
 590 
<a name="9" id="anc9"></a><span class="line-modified"> 591     static class StaticAccessor extends DirectMethodHandle {</span>
 592         final Class&lt;?&gt; fieldType;
 593         final Object staticBase;
 594         final long staticOffset;
 595 
 596         private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
 597                                boolean crackable, Object staticBase, long staticOffset) {
 598             super(mtype, form, member, crackable);
 599             this.fieldType    = member.getFieldType();
 600             this.staticBase   = staticBase;
 601             this.staticOffset = staticOffset;
 602         }
<a name="10" id="anc10"></a>









 603 
<a name="11" id="anc11"></a>
 604         @Override Object checkCast(Object obj) {
 605             return fieldType.cast(obj);
 606         }
 607         @Override
 608         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="12" id="anc12"></a><span class="line-modified"> 609             return new StaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
 610         }
 611         @Override
 612         MethodHandle viewAsType(MethodType newType, boolean strict) {
 613             assert(viewAsTypeChecks(newType, strict));
<a name="13" id="anc13"></a><span class="line-modified"> 614             return new StaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
 615         }
 616     }
 617 
 618     /** This subclass handles static field references of inline type . */
 619     static class InlineStaticAccessor extends StaticAccessor {
 620         private InlineStaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
<a name="14" id="anc14"></a><span class="line-modified"> 621                                      boolean crackable, Object staticBase, long staticOffset) {</span>
<span class="line-modified"> 622             super(mtype, form, member, crackable, staticBase, staticOffset);</span>
 623         }
 624 
 625         // zero-default inline type is not-nullable
 626         @Override Object checkCast(Object obj) {
 627             assert fieldType.isInlineClass() : &quot;null-default inline type not yet supported&quot;;
 628             return fieldType.cast(Objects.requireNonNull(obj));
 629         }
 630         @Override
 631         MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<a name="15" id="anc15"></a><span class="line-modified"> 632             return new InlineStaticAccessor(mt, lf, member, crackable, staticBase, staticOffset);</span>
<span class="line-added"> 633         }</span>
<span class="line-added"> 634         @Override</span>
<span class="line-added"> 635         MethodHandle viewAsType(MethodType newType, boolean strict) {</span>
<span class="line-added"> 636             assert(viewAsTypeChecks(newType, strict));</span>
<span class="line-added"> 637             return new InlineStaticAccessor(newType, form, member, false, staticBase, staticOffset);</span>
 638         }
 639     }
 640 
 641     @ForceInline
 642     /*non-public*/
 643     static Object nullCheck(Object obj) {
 644         return Objects.requireNonNull(obj);
 645     }
 646 
 647     @ForceInline
 648     /*non-public*/
 649     static Object staticBase(Object accessorObj) {
 650         return ((StaticAccessor)accessorObj).staticBase;
 651     }
 652 
 653     @ForceInline
 654     /*non-public*/
 655     static long staticOffset(Object accessorObj) {
 656         return ((StaticAccessor)accessorObj).staticOffset;
 657     }
 658 
 659     @ForceInline
 660     /*non-public*/
 661     static Object checkCast(Object mh, Object obj) {
 662         return ((DirectMethodHandle) mh).checkCast(obj);
 663     }
 664 
 665     @ForceInline
 666     /*non-public*/ static Class&lt;?&gt; fieldType(Object accessorObj) {
 667         return ((Accessor) accessorObj).fieldType;
 668     }
 669 
 670     @ForceInline
 671     /*non-public*/ static Class&lt;?&gt; staticFieldType(Object accessorObj) {
 672         return ((StaticAccessor) accessorObj).fieldType;
 673     }
 674 
 675     Object checkCast(Object obj) {
 676         return member.getReturnType().cast(obj);
 677     }
 678 
 679     // Caching machinery for field accessors:
 680     static final byte
 681             AF_GETFIELD        = 0,
 682             AF_PUTFIELD        = 1,
 683             AF_GETSTATIC       = 2,
 684             AF_PUTSTATIC       = 3,
 685             AF_GETSTATIC_INIT  = 4,
 686             AF_PUTSTATIC_INIT  = 5,
 687             AF_LIMIT           = 6;
 688     // Enumerate the different field kinds using Wrapper,
 689     // with an extra case added for checked references and value field access
 690     static final int
 691             FT_LAST_WRAPPER     = Wrapper.COUNT-1,
 692             FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),
 693             FT_CHECKED_REF      = FT_LAST_WRAPPER+1,
 694             FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  // flattened and non-flattened
 695             FT_LIMIT            = FT_LAST_WRAPPER+4;
 696     private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, int ftypeKind) {
 697         return ((formOp * FT_LIMIT * 2)
 698                 + (isVolatile ? FT_LIMIT : 0)
 699                 + (isFlatValue ? 1 : 0)
 700                 + ftypeKind);
 701     }
 702     @Stable
 703     private static final LambdaForm[] ACCESSOR_FORMS
 704             = new LambdaForm[afIndex(AF_LIMIT, false, false, 0)];
 705     static int ftypeKind(Class&lt;?&gt; ftype, boolean isValue) {
 706         if (ftype.isPrimitive())
 707             return Wrapper.forPrimitiveType(ftype).ordinal();
 708         else if (VerifyType.isNullReferenceConversion(Object.class, ftype)) {
 709             return FT_UNCHECKED_REF;
 710         } else
 711             // null check for value type in addition to check cast
 712             return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;
 713     }
 714 
 715     /**
 716      * Create a LF which can access the given field.
 717      * Cache and share this structure among all fields with
 718      * the same basicType and refKind.
 719      */
 720     private static LambdaForm preparedFieldLambdaForm(MemberName m) {
 721         Class&lt;?&gt; ftype = m.getFieldType();
 722         byte formOp;
 723         switch (m.getReferenceKind()) {
 724         case REF_getField:      formOp = AF_GETFIELD;    break;
 725         case REF_putField:      formOp = AF_PUTFIELD;    break;
 726         case REF_getStatic:     formOp = AF_GETSTATIC;   break;
 727         case REF_putStatic:     formOp = AF_PUTSTATIC;   break;
 728         default:  throw new InternalError(m.toString());
 729         }
 730         if (shouldBeInitialized(m)) {
 731             // precompute the barrier-free version:
<a name="16" id="anc16"></a><span class="line-modified"> 732             preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
 733             assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==
 734                    (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
 735             formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);
 736         }
<a name="17" id="anc17"></a><span class="line-modified"> 737         LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlattened(), ftype);</span>
 738         maybeCompile(lform, m);
 739         assert(lform.methodType().dropParameterTypes(0, 1)
 740                 .equals(m.getInvocationType().basicType()))
 741                 : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());
 742         return lform;
 743     }
 744 
 745     private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, Class&lt;?&gt; ftype) {
 746         int ftypeKind = ftypeKind(ftype, isValue);
 747         int afIndex = afIndex(formOp, isVolatile, isFlatValue, ftypeKind);
 748         LambdaForm lform = ACCESSOR_FORMS[afIndex];
 749         if (lform != null)  return lform;
 750         lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlatValue, ftypeKind);
 751         ACCESSOR_FORMS[afIndex] = lform;  // don&#39;t bother with a CAS
 752         return lform;
 753     }
 754 
 755     private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();
 756 
 757     private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlatValue, Wrapper wrapper) {
 758         if (isGetter) {
 759             if (isVolatile) {
 760                 switch (wrapper) {
 761                     case BOOLEAN: return GET_BOOLEAN_VOLATILE;
 762                     case BYTE:    return GET_BYTE_VOLATILE;
 763                     case SHORT:   return GET_SHORT_VOLATILE;
 764                     case CHAR:    return GET_CHAR_VOLATILE;
 765                     case INT:     return GET_INT_VOLATILE;
 766                     case LONG:    return GET_LONG_VOLATILE;
 767                     case FLOAT:   return GET_FLOAT_VOLATILE;
 768                     case DOUBLE:  return GET_DOUBLE_VOLATILE;
 769                     case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;
 770                 }
 771             } else {
 772                 switch (wrapper) {
 773                     case BOOLEAN: return GET_BOOLEAN;
 774                     case BYTE:    return GET_BYTE;
 775                     case SHORT:   return GET_SHORT;
 776                     case CHAR:    return GET_CHAR;
 777                     case INT:     return GET_INT;
 778                     case LONG:    return GET_LONG;
 779                     case FLOAT:   return GET_FLOAT;
 780                     case DOUBLE:  return GET_DOUBLE;
 781                     case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;
 782                 }
 783             }
 784         } else {
 785             if (isVolatile) {
 786                 switch (wrapper) {
 787                     case BOOLEAN: return PUT_BOOLEAN_VOLATILE;
 788                     case BYTE:    return PUT_BYTE_VOLATILE;
 789                     case SHORT:   return PUT_SHORT_VOLATILE;
 790                     case CHAR:    return PUT_CHAR_VOLATILE;
 791                     case INT:     return PUT_INT_VOLATILE;
 792                     case LONG:    return PUT_LONG_VOLATILE;
 793                     case FLOAT:   return PUT_FLOAT_VOLATILE;
 794                     case DOUBLE:  return PUT_DOUBLE_VOLATILE;
 795                     case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;
 796                 }
 797             } else {
 798                 switch (wrapper) {
 799                     case BOOLEAN: return PUT_BOOLEAN;
 800                     case BYTE:    return PUT_BYTE;
 801                     case SHORT:   return PUT_SHORT;
 802                     case CHAR:    return PUT_CHAR;
 803                     case INT:     return PUT_INT;
 804                     case LONG:    return PUT_LONG;
 805                     case FLOAT:   return PUT_FLOAT;
 806                     case DOUBLE:  return PUT_DOUBLE;
 807                     case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;
 808                 }
 809             }
 810         }
 811         throw new AssertionError(&quot;Invalid arguments&quot;);
 812     }
 813 
 814     /** invoked by GenerateJLIClassesHelper */
 815     static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {
 816         return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);
 817     }
 818 
 819     private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, boolean isValue, boolean isFlatValue, int ftypeKind) {
 820         boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);
 821         boolean isStatic  = (formOp &gt;= AF_GETSTATIC);
 822         boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);
 823         boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);
 824         Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);
 825         Class&lt;?&gt; ft = fw.primitiveType();
 826         assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);
 827 
 828         // getObject, putIntVolatile, etc.
 829         Kind kind = getFieldKind(isGetter, isVolatile, isFlatValue, fw);
 830 
 831         MethodType linkerType;
 832         boolean hasValueTypeArg = isGetter ? isValue : isFlatValue;
 833         if (isGetter) {
 834             linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)
 835                                  : MethodType.methodType(ft, Object.class, long.class);
 836         } else {
 837             linkerType = isFlatValue ? MethodType.methodType(void.class, Object.class, long.class, Class.class, ft)
 838                                      : MethodType.methodType(void.class, Object.class, long.class, ft);
 839         }
 840         MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);
 841         try {
 842             linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);
 843         } catch (ReflectiveOperationException ex) {
 844             throw newInternalError(ex);
 845         }
 846 
 847         // What is the external type of the lambda form?
 848         MethodType mtype;
 849         if (isGetter)
 850             mtype = MethodType.methodType(ft);
 851         else
 852             mtype = MethodType.methodType(void.class, ft);
 853         mtype = mtype.basicType();  // erase short to int, etc.
 854         if (!isStatic)
 855             mtype = mtype.insertParameterTypes(0, Object.class);
 856         final int DMH_THIS  = 0;
 857         final int ARG_BASE  = 1;
 858         final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
 859         // if this is for non-static access, the base pointer is stored at this index:
 860         final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;
 861         // if this is for write access, the value to be written is stored at this index:
 862         final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;
 863         int nameCursor = ARG_LIMIT;
 864         final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any
 865         final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.
 866         final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);
 867         final int U_HOLDER  = nameCursor++;  // UNSAFE holder
 868         final int INIT_BAR  = (needsInit ? nameCursor++ : -1);
 869         final int VALUE_TYPE = (hasValueTypeArg ? nameCursor++ : -1);
 870         final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);
 871         final int LINKER_CALL = nameCursor++;
 872         final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);
 873         final int RESULT    = nameCursor-1;  // either the call or the cast
 874         Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
 875         if (needsInit)
 876             names[INIT_BAR] = new Name(getFunction(NF_ensureInitialized), names[DMH_THIS]);
 877         if (needsCast &amp;&amp; !isGetter)
 878             names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);
 879         Object[] outArgs = new Object[1 + linkerType.parameterCount()];
 880         assert (outArgs.length == (isGetter ? 3 : 4) + (hasValueTypeArg ? 1 : 0));
 881         outArgs[0] = names[U_HOLDER] = new Name(getFunction(NF_UNSAFE));
 882         if (isStatic) {
 883             outArgs[1] = names[F_HOLDER]  = new Name(getFunction(NF_staticBase), names[DMH_THIS]);
 884             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_staticOffset), names[DMH_THIS]);
 885         } else {
 886             outArgs[1] = names[OBJ_CHECK] = new Name(getFunction(NF_checkBase), names[OBJ_BASE]);
 887             outArgs[2] = names[F_OFFSET]  = new Name(getFunction(NF_fieldOffset), names[DMH_THIS]);
 888         }
 889         int x = 3;
 890         if (hasValueTypeArg) {
 891             outArgs[x++] = names[VALUE_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])
 892                                                         : new Name(getFunction(NF_fieldType), names[DMH_THIS]);
 893         }
 894         if (!isGetter) {
 895             outArgs[x] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);
 896         }
 897         for (Object a : outArgs)  assert(a != null);
 898         names[LINKER_CALL] = new Name(linker, outArgs);
 899         if (needsCast &amp;&amp; isGetter)
 900             names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);
 901         for (Name n : names)  assert(n != null);
 902 
 903         LambdaForm form;
 904         if (needsCast || needsInit) {
 905             // can&#39;t use the pre-generated form when casting and/or initializing
 906             form = new LambdaForm(ARG_LIMIT, names, RESULT);
 907         } else {
 908             form = new LambdaForm(ARG_LIMIT, names, RESULT, kind);
 909         }
 910 
 911         if (LambdaForm.debugNames()) {
 912             // add some detail to the lambdaForm debugname,
 913             // significant only for debugging
 914             StringBuilder nameBuilder = new StringBuilder(kind.methodName);
 915             if (isStatic) {
 916                 nameBuilder.append(&quot;Static&quot;);
 917             } else {
 918                 nameBuilder.append(&quot;Field&quot;);
 919             }
 920             if (needsCast) {
 921                 nameBuilder.append(&quot;Cast&quot;);
 922             }
 923             if (needsInit) {
 924                 nameBuilder.append(&quot;Init&quot;);
 925             }
 926             LambdaForm.associateWithDebugName(form, nameBuilder.toString());
 927         }
 928         return form;
 929     }
 930 
 931     /**
 932      * Pre-initialized NamedFunctions for bootstrapping purposes.
 933      */
 934     static final byte NF_internalMemberName = 0,
 935             NF_internalMemberNameEnsureInit = 1,
 936             NF_ensureInitialized = 2,
 937             NF_fieldOffset = 3,
 938             NF_checkBase = 4,
 939             NF_staticBase = 5,
 940             NF_staticOffset = 6,
 941             NF_checkCast = 7,
 942             NF_allocateInstance = 8,
 943             NF_constructorMethod = 9,
 944             NF_UNSAFE = 10,
 945             NF_checkReceiver = 11,
 946             NF_fieldType = 12,
 947             NF_staticFieldType = 13,
 948             NF_LIMIT = 14;
 949 
 950     private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
 951 
 952     private static NamedFunction getFunction(byte func) {
 953         NamedFunction nf = NFS[func];
 954         if (nf != null) {
 955             return nf;
 956         }
 957         // Each nf must be statically invocable or we get tied up in our bootstraps.
 958         nf = NFS[func] = createFunction(func);
 959         assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf));
 960         return nf;
 961     }
 962 
 963     private static final MethodType CLS_OBJ_TYPE = MethodType.methodType(Class.class, Object.class);
 964 
 965     private static final MethodType OBJ_OBJ_TYPE = MethodType.methodType(Object.class, Object.class);
 966 
 967     private static final MethodType LONG_OBJ_TYPE = MethodType.methodType(long.class, Object.class);
 968 
 969     private static NamedFunction createFunction(byte func) {
 970         try {
 971             switch (func) {
 972                 case NF_internalMemberName:
 973                     return getNamedFunction(&quot;internalMemberName&quot;, OBJ_OBJ_TYPE);
 974                 case NF_internalMemberNameEnsureInit:
 975                     return getNamedFunction(&quot;internalMemberNameEnsureInit&quot;, OBJ_OBJ_TYPE);
 976                 case NF_ensureInitialized:
 977                     return getNamedFunction(&quot;ensureInitialized&quot;, MethodType.methodType(void.class, Object.class));
 978                 case NF_fieldOffset:
 979                     return getNamedFunction(&quot;fieldOffset&quot;, LONG_OBJ_TYPE);
 980                 case NF_checkBase:
 981                     return getNamedFunction(&quot;checkBase&quot;, OBJ_OBJ_TYPE);
 982                 case NF_staticBase:
 983                     return getNamedFunction(&quot;staticBase&quot;, OBJ_OBJ_TYPE);
 984                 case NF_staticOffset:
 985                     return getNamedFunction(&quot;staticOffset&quot;, LONG_OBJ_TYPE);
 986                 case NF_checkCast:
 987                     return getNamedFunction(&quot;checkCast&quot;, MethodType.methodType(Object.class, Object.class, Object.class));
 988                 case NF_allocateInstance:
 989                     return getNamedFunction(&quot;allocateInstance&quot;, OBJ_OBJ_TYPE);
 990                 case NF_constructorMethod:
 991                     return getNamedFunction(&quot;constructorMethod&quot;, OBJ_OBJ_TYPE);
 992                 case NF_UNSAFE:
 993                     MemberName member = new MemberName(MethodHandleStatics.class, &quot;UNSAFE&quot;, Unsafe.class, REF_getField);
 994                     return new NamedFunction(
 995                             MemberName.getFactory()
 996                                     .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));
 997                 case NF_checkReceiver:
 998                     member = new MemberName(DirectMethodHandle.class, &quot;checkReceiver&quot;, OBJ_OBJ_TYPE, REF_invokeVirtual);
 999                     return new NamedFunction(
1000                         MemberName.getFactory()
1001                             .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));
1002                 case NF_fieldType:
1003                     return getNamedFunction(&quot;fieldType&quot;, CLS_OBJ_TYPE);
1004                 case NF_staticFieldType:
1005                     return getNamedFunction(&quot;staticFieldType&quot;, CLS_OBJ_TYPE);
1006                 default:
1007                     throw newInternalError(&quot;Unknown function: &quot; + func);
1008             }
1009         } catch (ReflectiveOperationException ex) {
1010             throw newInternalError(ex);
1011         }
1012     }
1013 
1014     private static NamedFunction getNamedFunction(String name, MethodType type)
1015         throws ReflectiveOperationException
1016     {
1017         MemberName member = new MemberName(DirectMethodHandle.class, name, type, REF_invokeStatic);
1018         return new NamedFunction(
1019             MemberName.getFactory()
1020                 .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));
1021     }
1022 
1023     static {
1024         // The Holder class will contain pre-generated DirectMethodHandles resolved
1025         // speculatively using MemberName.getFactory().resolveOrNull. However, that
1026         // doesn&#39;t initialize the class, which subtly breaks inlining etc. By forcing
1027         // initialization of the Holder class we avoid these issues.
1028         UNSAFE.ensureClassInitialized(Holder.class);
1029     }
1030 
1031     /* Placeholder class for DirectMethodHandles generated ahead of time */
1032     final class Holder {}
1033 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>