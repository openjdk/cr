<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 111,20 ***</span>
       */
      static class Constants {
          Constants() { } // static only
  
          static final int
<span class="line-modified">!             MN_IS_METHOD           = 0x00010000, // method (not constructor)</span>
<span class="line-modified">!             MN_IS_CONSTRUCTOR      = 0x00020000, // constructor</span>
<span class="line-modified">!             MN_IS_FIELD            = 0x00040000, // field</span>
<span class="line-modified">!             MN_IS_TYPE             = 0x00080000, // nested type</span>
<span class="line-modified">!             MN_CALLER_SENSITIVE    = 0x00100000, // @CallerSensitive annotation detected</span>
<span class="line-modified">!             MN_REFERENCE_KIND_SHIFT = 24, // refKind</span>
<span class="line-modified">!             MN_REFERENCE_KIND_MASK = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,</span>
              // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
<span class="line-modified">!             MN_SEARCH_SUPERCLASSES = 0x00100000,</span>
<span class="line-modified">!             MN_SEARCH_INTERFACES   = 0x00200000;</span>
  
          /**
           * Constant pool reference-kind codes, as used by CONSTANT_MethodHandle CP entries.
           */
          static final byte
<span class="line-new-header">--- 111,20 ---</span>
       */
      static class Constants {
          Constants() { } // static only
  
          static final int
<span class="line-modified">!             MN_IS_METHOD             = 0x00010000, // method (not object constructor)</span>
<span class="line-modified">!             MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // object constructor</span>
<span class="line-modified">!             MN_IS_FIELD              = 0x00040000, // field</span>
<span class="line-modified">!             MN_IS_TYPE               = 0x00080000, // nested type</span>
<span class="line-modified">!             MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected</span>
<span class="line-modified">!             MN_REFERENCE_KIND_SHIFT  = 24, // refKind</span>
<span class="line-modified">!             MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,</span>
              // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
<span class="line-modified">!             MN_SEARCH_SUPERCLASSES   = 0x00100000,</span>
<span class="line-modified">!             MN_SEARCH_INTERFACES     = 0x00200000;</span>
  
          /**
           * Constant pool reference-kind codes, as used by CONSTANT_MethodHandle CP entries.
           */
          static final byte
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,11 ***</span>
          return refKindIsField(refKind) &amp;&amp; !refKindIsGetter(refKind);
      }
      static boolean refKindIsMethod(byte refKind) {
          return !refKindIsField(refKind) &amp;&amp; (refKind != REF_newInvokeSpecial);
      }
<span class="line-modified">!     static boolean refKindIsConstructor(byte refKind) {</span>
          return (refKind == REF_newInvokeSpecial);
      }
      static boolean refKindHasReceiver(byte refKind) {
          assert(refKindIsValid(refKind));
          return (refKind &amp; 1) != 0;
<span class="line-new-header">--- 165,11 ---</span>
          return refKindIsField(refKind) &amp;&amp; !refKindIsGetter(refKind);
      }
      static boolean refKindIsMethod(byte refKind) {
          return !refKindIsField(refKind) &amp;&amp; (refKind != REF_newInvokeSpecial);
      }
<span class="line-modified">!     static boolean refKindIsObjectConstructor(byte refKind) {</span>
          return (refKind == REF_newInvokeSpecial);
      }
      static boolean refKindHasReceiver(byte refKind) {
          assert(refKindIsValid(refKind));
          return (refKind &amp; 1) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,16 ***</span>
          StringBuilder sb = new StringBuilder(prefix.length() + guardType.parameterCount());
  
          sb.append(prefix);
          for (int i = 1; i &lt; guardType.parameterCount() - 1; i++) {
              Class&lt;?&gt; pt = guardType.parameterType(i);
<span class="line-modified">!             sb.append(getCharType(pt));</span>
          }
<span class="line-modified">!         sb.append(&#39;_&#39;).append(getCharType(guardType.returnType()));</span>
          return sb.toString();
      }
<span class="line-modified">!     static char getCharType(Class&lt;?&gt; pt) {</span>
          return Wrapper.forBasicType(pt).basicTypeChar();
      }
      static NoSuchMethodError newNoSuchMethodErrorOnVarHandle(String name, MethodType mtype) {
          return new NoSuchMethodError(&quot;VarHandle.&quot; + name + mtype);
      }
<span class="line-new-header">--- 574,16 ---</span>
          StringBuilder sb = new StringBuilder(prefix.length() + guardType.parameterCount());
  
          sb.append(prefix);
          for (int i = 1; i &lt; guardType.parameterCount() - 1; i++) {
              Class&lt;?&gt; pt = guardType.parameterType(i);
<span class="line-modified">!             sb.append(getCharErasedType(pt));</span>
          }
<span class="line-modified">!         sb.append(&#39;_&#39;).append(getCharErasedType(guardType.returnType()));</span>
          return sb.toString();
      }
<span class="line-modified">!     static char getCharErasedType(Class&lt;?&gt; pt) {</span>
          return Wrapper.forBasicType(pt).basicTypeChar();
      }
      static NoSuchMethodError newNoSuchMethodErrorOnVarHandle(String name, MethodType mtype) {
          return new NoSuchMethodError(&quot;VarHandle.&quot; + name + mtype);
      }
</pre>
<center><a href="InvokerBytecodeGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>