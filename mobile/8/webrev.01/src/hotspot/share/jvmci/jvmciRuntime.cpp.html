<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/javaClasses.inline.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;compiler/compileBroker.hpp&quot;
  28 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  29 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  30 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  31 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  32 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  33 #include &quot;jvmci/metadataHandles.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/constantPool.inline.hpp&quot;
  38 #include &quot;oops/method.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  42 #include &quot;runtime/atomic.hpp&quot;
  43 #include &quot;runtime/biasedLocking.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/frame.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #if INCLUDE_G1GC
  50 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  51 #endif // INCLUDE_G1GC
  52 
  53 // Simple helper to see if the caller of a runtime stub which
  54 // entered the VM has been deoptimized
  55 
  56 static bool caller_is_deopted() {
  57   JavaThread* thread = JavaThread::current();
  58   RegisterMap reg_map(thread, false);
  59   frame runtime_frame = thread-&gt;last_frame();
  60   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  62   return caller_frame.is_deoptimized_frame();
  63 }
  64 
  65 // Stress deoptimization
  66 static void deopt_caller() {
  67   if ( !caller_is_deopted()) {
  68     JavaThread* thread = JavaThread::current();
  69     RegisterMap reg_map(thread, false);
  70     frame runtime_frame = thread-&gt;last_frame();
  71     frame caller_frame = runtime_frame.sender(&amp;reg_map);
  72     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
  73     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
  74   }
  75 }
  76 
  77 // Manages a scope for a JVMCI runtime call that attempts a heap allocation.
  78 // If there is a pending exception upon closing the scope and the runtime
  79 // call is of the variety where allocation failure returns NULL without an
  80 // exception, the following action is taken:
  81 //   1. The pending exception is cleared
  82 //   2. NULL is written to JavaThread::_vm_result
  83 //   3. Checks that an OutOfMemoryError is Universe::out_of_memory_error_retry().
  84 class RetryableAllocationMark: public StackObj {
  85  private:
  86   JavaThread* _thread;
  87  public:
  88   RetryableAllocationMark(JavaThread* thread, bool activate) {
  89     if (activate) {
  90       assert(!thread-&gt;in_retryable_allocation(), &quot;retryable allocation scope is non-reentrant&quot;);
  91       _thread = thread;
  92       _thread-&gt;set_in_retryable_allocation(true);
  93     } else {
  94       _thread = NULL;
  95     }
  96   }
  97   ~RetryableAllocationMark() {
  98     if (_thread != NULL) {
  99       _thread-&gt;set_in_retryable_allocation(false);
 100       JavaThread* THREAD = _thread;
 101       if (HAS_PENDING_EXCEPTION) {
 102         oop ex = PENDING_EXCEPTION;
 103         CLEAR_PENDING_EXCEPTION;
 104         oop retry_oome = Universe::out_of_memory_error_retry();
 105         if (ex-&gt;is_a(retry_oome-&gt;klass()) &amp;&amp; retry_oome != ex) {
 106           ResourceMark rm;
 107           fatal(&quot;Unexpected exception in scope of retryable allocation: &quot; INTPTR_FORMAT &quot; of type %s&quot;, p2i(ex), ex-&gt;klass()-&gt;external_name());
 108         }
 109         _thread-&gt;set_vm_result(NULL);
 110       }
 111     }
 112   }
 113 };
 114 
 115 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_instance_common(JavaThread* thread, Klass* klass, bool null_on_fail))
 116   JRT_BLOCK;
 117   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 118   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 119   InstanceKlass* h = InstanceKlass::cast(klass);
 120   {
 121     RetryableAllocationMark ram(thread, null_on_fail);
 122     h-&gt;check_valid_for_instantiation(true, CHECK);
 123     oop obj;
 124     if (null_on_fail) {
 125       if (!h-&gt;is_initialized()) {
 126         // Cannot re-execute class initialization without side effects
 127         // so return without attempting the initialization
 128         return;
 129       }
 130     } else {
 131       // make sure klass is initialized
 132       h-&gt;initialize(CHECK);
 133     }
 134     // allocate instance and return via TLS
 135     obj = h-&gt;allocate_instance(CHECK);
 136     thread-&gt;set_vm_result(obj);
 137   }
 138   JRT_BLOCK_END;
 139   SharedRuntime::on_slowpath_allocation_exit(thread);
 140 JRT_END
 141 
 142 JRT_BLOCK_ENTRY(void, JVMCIRuntime::new_array_common(JavaThread* thread, Klass* array_klass, jint length, bool null_on_fail))
 143   JRT_BLOCK;
 144   // Note: no handle for klass needed since they are not used
 145   //       anymore after new_objArray() and no GC can happen before.
 146   //       (This may have to change if this code changes!)
 147   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 148   oop obj;
 149   if (array_klass-&gt;is_typeArray_klass()) {
 150     BasicType elt_type = TypeArrayKlass::cast(array_klass)-&gt;element_type();
 151     RetryableAllocationMark ram(thread, null_on_fail);
 152     obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 153   } else {
 154     Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
 155     Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();
 156     RetryableAllocationMark ram(thread, null_on_fail);
 157     obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 158   }
 159   thread-&gt;set_vm_result(obj);
 160   // This is pretty rare but this runtime patch is stressful to deoptimization
 161   // if we deoptimize here so force a deopt to stress the path.
 162   if (DeoptimizeALot) {
 163     static int deopts = 0;
 164     // Alternate between deoptimizing and raising an error (which will also cause a deopt)
 165     if (deopts++ % 2 == 0) {
 166       if (null_on_fail) {
 167         return;
 168       } else {
 169         ResourceMark rm(THREAD);
 170         THROW(vmSymbols::java_lang_OutOfMemoryError());
 171       }
 172     } else {
 173       deopt_caller();
 174     }
 175   }
 176   JRT_BLOCK_END;
 177   SharedRuntime::on_slowpath_allocation_exit(thread);
 178 JRT_END
 179 
 180 JRT_ENTRY(void, JVMCIRuntime::new_multi_array_common(JavaThread* thread, Klass* klass, int rank, jint* dims, bool null_on_fail))
 181   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 182   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 183   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 184   RetryableAllocationMark ram(thread, null_on_fail);
 185   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 186   thread-&gt;set_vm_result(obj);
 187 JRT_END
 188 
 189 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_array_common(JavaThread* thread, oopDesc* element_mirror, jint length, bool null_on_fail))
 190   RetryableAllocationMark ram(thread, null_on_fail);
 191   oop obj = Reflection::reflect_new_array(element_mirror, length, CHECK);
 192   thread-&gt;set_vm_result(obj);
 193 JRT_END
 194 
 195 JRT_ENTRY(void, JVMCIRuntime::dynamic_new_instance_common(JavaThread* thread, oopDesc* type_mirror, bool null_on_fail))
 196   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));
 197 
 198   if (klass == NULL) {
 199     ResourceMark rm(THREAD);
 200     THROW(vmSymbols::java_lang_InstantiationException());
 201   }
 202   RetryableAllocationMark ram(thread, null_on_fail);
 203 
 204   // Create new instance (the receiver)
 205   klass-&gt;check_valid_for_instantiation(false, CHECK);
 206 
 207   if (null_on_fail) {
 208     if (!klass-&gt;is_initialized()) {
 209       // Cannot re-execute class initialization without side effects
 210       // so return without attempting the initialization
 211       return;
 212     }
 213   } else {
 214     // Make sure klass gets initialized
 215     klass-&gt;initialize(CHECK);
 216   }
 217 
 218   oop obj = klass-&gt;allocate_instance(CHECK);
 219   thread-&gt;set_vm_result(obj);
 220 JRT_END
 221 
 222 extern void vm_exit(int code);
 223 
 224 // Enter this method from compiled code handler below. This is where we transition
 225 // to VM mode. This is done as a helper routine so that the method called directly
 226 // from compiled code does not have to transition to VM. This allows the entry
 227 // method to see if the nmethod that we have just looked up a handler for has
 228 // been deoptimized while we were in the vm. This simplifies the assembly code
 229 // cpu directories.
 230 //
 231 // We are entering here from exception stub (via the entry method below)
 232 // If there is a compiled exception handler in this method, we will continue there;
 233 // otherwise we will unwind the stack and continue at the caller of top frame method
 234 // Note: we enter in Java using a special JRT wrapper. This wrapper allows us to
 235 // control the area where we can allow a safepoint. After we exit the safepoint area we can
 236 // check to see if the handler we are going to return is now in a nmethod that has
 237 // been deoptimized. If that is the case we return the deopt blob
 238 // unpack_with_exception entry instead. This makes life for the exception blob easier
 239 // because making that same check and diverting is painful from assembly language.
 240 JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, CompiledMethod*&amp; cm))
 241   // Reset method handle flag.
 242   thread-&gt;set_is_method_handle_return(false);
 243 
 244   Handle exception(thread, ex);
 245   cm = CodeCache::find_compiled(pc);
 246   assert(cm != NULL, &quot;this is not a compiled method&quot;);
 247   // Adjust the pc as needed/
 248   if (cm-&gt;is_deopt_pc(pc)) {
 249     RegisterMap map(thread, false);
 250     frame exception_frame = thread-&gt;last_frame().sender(&amp;map);
 251     // if the frame isn&#39;t deopted then pc must not correspond to the caller of last_frame
 252     assert(exception_frame.is_deoptimized_frame(), &quot;must be deopted&quot;);
 253     pc = exception_frame.pc();
 254   }
 255 #ifdef ASSERT
 256   assert(exception.not_null(), &quot;NULL exceptions should be handled by throw_exception&quot;);
 257   assert(oopDesc::is_oop(exception()), &quot;just checking&quot;);
 258   // Check that exception is a subclass of Throwable, otherwise we have a VerifyError
 259   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
 260     if (ExitVMOnVerifyError) vm_exit(-1);
 261     ShouldNotReachHere();
 262   }
 263 #endif
 264 
 265   // Check the stack guard pages and reenable them if necessary and there is
 266   // enough space on the stack to do so.  Use fast exceptions only if the guard
 267   // pages are enabled.
 268   bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 269   if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 270 
 271   if (JvmtiExport::can_post_on_exceptions()) {
 272     // To ensure correct notification of exception catches and throws
 273     // we have to deoptimize here.  If we attempted to notify the
 274     // catches and throws during this exception lookup it&#39;s possible
 275     // we could deoptimize on the way out of the VM and end back in
 276     // the interpreter at the throw site.  This would result in double
 277     // notifications since the interpreter would also notify about
 278     // these same catches and throws as it unwound the frame.
 279 
 280     RegisterMap reg_map(thread);
 281     frame stub_frame = thread-&gt;last_frame();
 282     frame caller_frame = stub_frame.sender(&amp;reg_map);
 283 
 284     // We don&#39;t really want to deoptimize the nmethod itself since we
 285     // can actually continue in the exception handler ourselves but I
 286     // don&#39;t see an easy way to have the desired effect.
 287     Deoptimization::deoptimize_frame(thread, caller_frame.id(), Deoptimization::Reason_constraint);
 288     assert(caller_is_deopted(), &quot;Must be deoptimized&quot;);
 289 
 290     return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 291   }
 292 
 293   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
 294   if (guard_pages_enabled) {
 295     address fast_continuation = cm-&gt;handler_for_exception_and_pc(exception, pc);
 296     if (fast_continuation != NULL) {
 297       // Set flag if return address is a method handle call site.
 298       thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 299       return fast_continuation;
 300     }
 301   }
 302 
 303   // If the stack guard pages are enabled, check whether there is a handler in
 304   // the current method.  Otherwise (guard pages disabled), force an unwind and
 305   // skip the exception cache update (i.e., just leave continuation==NULL).
 306   address continuation = NULL;
 307   if (guard_pages_enabled) {
 308 
 309     // New exception handling mechanism can support inlined methods
 310     // with exception handlers since the mappings are from PC to PC
 311 
 312     // debugging support
 313     // tracing
 314     if (log_is_enabled(Info, exceptions)) {
 315       ResourceMark rm;
 316       stringStream tempst;
 317       assert(cm-&gt;method() != NULL, &quot;Unexpected null method()&quot;);
 318       tempst.print(&quot;compiled method &lt;%s&gt;\n&quot;
 319                    &quot; at PC&quot; INTPTR_FORMAT &quot; for thread &quot; INTPTR_FORMAT,
 320                    cm-&gt;method()-&gt;print_value_string(), p2i(pc), p2i(thread));
 321       Exceptions::log_exception(exception, tempst.as_string());
 322     }
 323     // for AbortVMOnException flag
 324     NOT_PRODUCT(Exceptions::debug_check_abort(exception));
 325 
 326     // Clear out the exception oop and pc since looking up an
 327     // exception handler can cause class loading, which might throw an
 328     // exception and those fields are expected to be clear during
 329     // normal bytecode execution.
 330     thread-&gt;clear_exception_oop_and_pc();
 331 
 332     bool recursive_exception = false;
 333     continuation = SharedRuntime::compute_compiled_exc_handler(cm, pc, exception, false, false, recursive_exception);
 334     // If an exception was thrown during exception dispatch, the exception oop may have changed
 335     thread-&gt;set_exception_oop(exception());
 336     thread-&gt;set_exception_pc(pc);
 337 
 338     // The exception cache is used only for non-implicit exceptions
 339     // Update the exception cache only when another exception did
 340     // occur during the computation of the compiled exception handler
 341     // (e.g., when loading the class of the catch type).
 342     // Checking for exception oop equality is not
 343     // sufficient because some exceptions are pre-allocated and reused.
 344     if (continuation != NULL &amp;&amp; !recursive_exception &amp;&amp; !SharedRuntime::deopt_blob()-&gt;contains(continuation)) {
 345       cm-&gt;add_handler_for_exception_and_pc(exception, pc, continuation);
 346     }
 347   }
 348 
 349   // Set flag if return address is a method handle call site.
 350   thread-&gt;set_is_method_handle_return(cm-&gt;is_method_handle_return(pc));
 351 
 352   if (log_is_enabled(Info, exceptions)) {
 353     ResourceMark rm;
 354     log_info(exceptions)(&quot;Thread &quot; PTR_FORMAT &quot; continuing at PC &quot; PTR_FORMAT
 355                          &quot; for exception thrown at PC &quot; PTR_FORMAT,
 356                          p2i(thread), p2i(continuation), p2i(pc));
 357   }
 358 
 359   return continuation;
 360 JRT_END
 361 
 362 // Enter this method from compiled code only if there is a Java exception handler
 363 // in the method handling the exception.
 364 // We are entering here from exception stub. We don&#39;t do a normal VM transition here.
 365 // We do it in a helper. This is so we can check to see if the nmethod we have just
 366 // searched for an exception handler has been deoptimized in the meantime.
 367 address JVMCIRuntime::exception_handler_for_pc(JavaThread* thread) {
 368   oop exception = thread-&gt;exception_oop();
 369   address pc = thread-&gt;exception_pc();
 370   // Still in Java mode
 371   DEBUG_ONLY(ResetNoHandleMark rnhm);
 372   CompiledMethod* cm = NULL;
 373   address continuation = NULL;
 374   {
 375     // Enter VM mode by calling the helper
 376     ResetNoHandleMark rnhm;
 377     continuation = exception_handler_for_pc_helper(thread, exception, pc, cm);
 378   }
 379   // Back in JAVA, use no oops DON&#39;T safepoint
 380 
 381   // Now check to see if the compiled method we were called from is now deoptimized.
 382   // If so we must return to the deopt blob and deoptimize the nmethod
 383   if (cm != NULL &amp;&amp; caller_is_deopted()) {
 384     continuation = SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
 385   }
 386 
 387   assert(continuation != NULL, &quot;no handler found&quot;);
 388   return continuation;
 389 }
 390 
 391 JRT_BLOCK_ENTRY(void, JVMCIRuntime::monitorenter(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 392   SharedRuntime::monitor_enter_helper(obj, lock, thread);
 393 JRT_END
 394 
 395 JRT_LEAF(void, JVMCIRuntime::monitorexit(JavaThread* thread, oopDesc* obj, BasicLock* lock))
 396   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 397   assert(oopDesc::is_oop(obj), &quot;invalid lock object pointer dected&quot;);
 398   SharedRuntime::monitor_exit_helper(obj, lock, thread);
 399 JRT_END
 400 
 401 // Object.notify() fast path, caller does slow path
 402 JRT_LEAF(jboolean, JVMCIRuntime::object_notify(JavaThread *thread, oopDesc* obj))
 403 
 404   // Very few notify/notifyAll operations find any threads on the waitset, so
 405   // the dominant fast-path is to simply return.
 406   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 407   // reduce lock hold times.
 408   if (!SafepointSynchronize::is_synchronizing()) {
 409     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 410       return true;
 411     }
 412   }
 413   return false; // caller must perform slow path
 414 
 415 JRT_END
 416 
 417 // Object.notifyAll() fast path, caller does slow path
 418 JRT_LEAF(jboolean, JVMCIRuntime::object_notifyAll(JavaThread *thread, oopDesc* obj))
 419 
 420   if (!SafepointSynchronize::is_synchronizing() ) {
 421     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 422       return true;
 423     }
 424   }
 425   return false; // caller must perform slow path
 426 
 427 JRT_END
 428 
 429 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message))
 430   JRT_BLOCK;
 431   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 432   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 433   JRT_BLOCK_END;
 434   return caller_is_deopted();
 435 JRT_END
 436 
 437 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass))
 438   JRT_BLOCK;
 439   ResourceMark rm(thread);
 440   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 441   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, klass-&gt;external_name());
 442   JRT_BLOCK_END;
 443   return caller_is_deopted();
 444 JRT_END
 445 
 446 JRT_BLOCK_ENTRY(int, JVMCIRuntime::throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass))
 447   JRT_BLOCK;
 448   ResourceMark rm(thread);
 449   const char* message = SharedRuntime::generate_class_cast_message(caster_klass, target_klass);
 450   TempNewSymbol symbol = SymbolTable::new_symbol(exception);
 451   SharedRuntime::throw_and_post_jvmti_exception(thread, symbol, message);
 452   JRT_BLOCK_END;
 453   return caller_is_deopted();
 454 JRT_END
 455 
 456 JRT_LEAF(void, JVMCIRuntime::log_object(JavaThread* thread, oopDesc* obj, bool as_string, bool newline))
 457   ttyLocker ttyl;
 458 
 459   if (obj == NULL) {
 460     tty-&gt;print(&quot;NULL&quot;);
 461   } else if (oopDesc::is_oop_or_null(obj, true) &amp;&amp; (!as_string || !java_lang_String::is_instance(obj))) {
 462     if (oopDesc::is_oop_or_null(obj, true)) {
 463       char buf[O_BUFLEN];
 464       tty-&gt;print(&quot;%s@&quot; INTPTR_FORMAT, obj-&gt;klass()-&gt;name()-&gt;as_C_string(buf, O_BUFLEN), p2i(obj));
 465     } else {
 466       tty-&gt;print(INTPTR_FORMAT, p2i(obj));
 467     }
 468   } else {
 469     ResourceMark rm;
 470     assert(obj != NULL &amp;&amp; java_lang_String::is_instance(obj), &quot;must be&quot;);
 471     char *buf = java_lang_String::as_utf8_string(obj);
 472     tty-&gt;print_raw(buf);
 473   }
 474   if (newline) {
 475     tty-&gt;cr();
 476   }
 477 JRT_END
 478 
 479 #if INCLUDE_G1GC
 480 
 481 JRT_LEAF(void, JVMCIRuntime::write_barrier_pre(JavaThread* thread, oopDesc* obj))
 482   G1ThreadLocalData::satb_mark_queue(thread).enqueue(obj);
 483 JRT_END
 484 
 485 JRT_LEAF(void, JVMCIRuntime::write_barrier_post(JavaThread* thread, void* card_addr))
 486   G1ThreadLocalData::dirty_card_queue(thread).enqueue(card_addr);
 487 JRT_END
 488 
 489 #endif // INCLUDE_G1GC
 490 
 491 JRT_LEAF(jboolean, JVMCIRuntime::validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child))
 492   bool ret = true;
 493   if(!Universe::heap()-&gt;is_in(parent)) {
 494     tty-&gt;print_cr(&quot;Parent Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(parent));
 495     parent-&gt;print();
 496     ret=false;
 497   }
 498   if(!Universe::heap()-&gt;is_in(child)) {
 499     tty-&gt;print_cr(&quot;Child Object &quot; INTPTR_FORMAT &quot; not in heap&quot;, p2i(child));
 500     child-&gt;print();
 501     ret=false;
 502   }
 503   return (jint)ret;
 504 JRT_END
 505 
 506 JRT_ENTRY(void, JVMCIRuntime::vm_error(JavaThread* thread, jlong where, jlong format, jlong value))
 507   ResourceMark rm;
 508   const char *error_msg = where == 0L ? &quot;&lt;internal JVMCI error&gt;&quot; : (char*) (address) where;
 509   char *detail_msg = NULL;
 510   if (format != 0L) {
 511     const char* buf = (char*) (address) format;
 512     size_t detail_msg_length = strlen(buf) * 2;
 513     detail_msg = (char *) NEW_RESOURCE_ARRAY(u_char, detail_msg_length);
 514     jio_snprintf(detail_msg, detail_msg_length, buf, value);
 515   }
 516   report_vm_error(__FILE__, __LINE__, error_msg, &quot;%s&quot;, detail_msg);
 517 JRT_END
 518 
 519 JRT_LEAF(oopDesc*, JVMCIRuntime::load_and_clear_exception(JavaThread* thread))
 520   oop exception = thread-&gt;exception_oop();
 521   assert(exception != NULL, &quot;npe&quot;);
 522   thread-&gt;set_exception_oop(NULL);
 523   thread-&gt;set_exception_pc(0);
 524   return exception;
 525 JRT_END
 526 
 527 PRAGMA_DIAG_PUSH
 528 PRAGMA_FORMAT_NONLITERAL_IGNORED
 529 JRT_LEAF(void, JVMCIRuntime::log_printf(JavaThread* thread, const char* format, jlong v1, jlong v2, jlong v3))
 530   ResourceMark rm;
 531   tty-&gt;print(format, v1, v2, v3);
 532 JRT_END
 533 PRAGMA_DIAG_POP
 534 
 535 static void decipher(jlong v, bool ignoreZero) {
 536   if (v != 0 || !ignoreZero) {
 537     void* p = (void *)(address) v;
 538     CodeBlob* cb = CodeCache::find_blob(p);
 539     if (cb) {
 540       if (cb-&gt;is_nmethod()) {
 541         char buf[O_BUFLEN];
 542         tty-&gt;print(&quot;%s [&quot; INTPTR_FORMAT &quot;+&quot; JLONG_FORMAT &quot;]&quot;, cb-&gt;as_nmethod_or_null()-&gt;method()-&gt;name_and_sig_as_C_string(buf, O_BUFLEN), p2i(cb-&gt;code_begin()), (jlong)((address)v - cb-&gt;code_begin()));
 543         return;
 544       }
 545       cb-&gt;print_value_on(tty);
 546       return;
 547     }
 548     if (Universe::heap()-&gt;is_in(p)) {
 549       oop obj = oop(p);
 550       obj-&gt;print_value_on(tty);
 551       return;
 552     }
 553     tty-&gt;print(INTPTR_FORMAT &quot; [long: &quot; JLONG_FORMAT &quot;, double %lf, char %c]&quot;,p2i((void *)v), (jlong)v, (jdouble)v, (char)v);
 554   }
 555 }
 556 
 557 PRAGMA_DIAG_PUSH
 558 PRAGMA_FORMAT_NONLITERAL_IGNORED
 559 JRT_LEAF(void, JVMCIRuntime::vm_message(jboolean vmError, jlong format, jlong v1, jlong v2, jlong v3))
 560   ResourceMark rm;
 561   const char *buf = (const char*) (address) format;
 562   if (vmError) {
 563     if (buf != NULL) {
 564       fatal(buf, v1, v2, v3);
 565     } else {
 566       fatal(&quot;&lt;anonymous error&gt;&quot;);
 567     }
 568   } else if (buf != NULL) {
 569     tty-&gt;print(buf, v1, v2, v3);
 570   } else {
 571     assert(v2 == 0, &quot;v2 != 0&quot;);
 572     assert(v3 == 0, &quot;v3 != 0&quot;);
 573     decipher(v1, false);
 574   }
 575 JRT_END
 576 PRAGMA_DIAG_POP
 577 
 578 JRT_LEAF(void, JVMCIRuntime::log_primitive(JavaThread* thread, jchar typeChar, jlong value, jboolean newline))
 579   union {
 580       jlong l;
 581       jdouble d;
 582       jfloat f;
 583   } uu;
 584   uu.l = value;
 585   switch (typeChar) {
 586     case &#39;Z&#39;: tty-&gt;print(value == 0 ? &quot;false&quot; : &quot;true&quot;); break;
 587     case &#39;B&#39;: tty-&gt;print(&quot;%d&quot;, (jbyte) value); break;
 588     case &#39;C&#39;: tty-&gt;print(&quot;%c&quot;, (jchar) value); break;
 589     case &#39;S&#39;: tty-&gt;print(&quot;%d&quot;, (jshort) value); break;
 590     case &#39;I&#39;: tty-&gt;print(&quot;%d&quot;, (jint) value); break;
 591     case &#39;F&#39;: tty-&gt;print(&quot;%f&quot;, uu.f); break;
 592     case &#39;J&#39;: tty-&gt;print(JLONG_FORMAT, value); break;
 593     case &#39;D&#39;: tty-&gt;print(&quot;%lf&quot;, uu.d); break;
 594     default: assert(false, &quot;unknown typeChar&quot;); break;
 595   }
 596   if (newline) {
 597     tty-&gt;cr();
 598   }
 599 JRT_END
 600 
 601 JRT_ENTRY(jint, JVMCIRuntime::identity_hash_code(JavaThread* thread, oopDesc* obj))
 602   return (jint) obj-&gt;identity_hash();
 603 JRT_END
 604 
 605 JRT_ENTRY(jint, JVMCIRuntime::test_deoptimize_call_int(JavaThread* thread, int value))
 606   deopt_caller();
 607   return (jint) value;
 608 JRT_END
 609 
 610 
 611 // private static JVMCIRuntime JVMCI.initializeRuntime()
 612 JVM_ENTRY_NO_ENV(jobject, JVM_GetJVMCIRuntime(JNIEnv *env, jclass c))
 613   JNI_JVMCIENV(thread, env);
 614   if (!EnableJVMCI) {
 615     JVMCI_THROW_MSG_NULL(InternalError, &quot;JVMCI is not enabled&quot;);
 616   }
 617   JVMCIENV-&gt;runtime()-&gt;initialize_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 618   JVMCIObject runtime = JVMCIENV-&gt;runtime()-&gt;get_HotSpotJVMCIRuntime(JVMCI_CHECK_NULL);
 619   return JVMCIENV-&gt;get_jobject(runtime);
 620 JVM_END
 621 
 622 void JVMCIRuntime::call_getCompiler(TRAPS) {
 623   THREAD_JVMCIENV(JavaThread::current());
 624   JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);
 625   initialize(JVMCIENV);
 626   JVMCIENV-&gt;call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);
 627 }
 628 
 629 void JVMCINMethodData::initialize(
 630   int nmethod_mirror_index,
 631   const char* name,
 632   FailedSpeculation** failed_speculations)
 633 {
 634   _failed_speculations = failed_speculations;
 635   _nmethod_mirror_index = nmethod_mirror_index;
 636   if (name != NULL) {
 637     _has_name = true;
 638     char* dest = (char*) this-&gt;name();
 639     strcpy(dest, name);
 640   } else {
 641     _has_name = false;
 642   }
 643 }
 644 
 645 void JVMCINMethodData::add_failed_speculation(nmethod* nm, jlong speculation) {
 646   uint index = (speculation &gt;&gt; 32) &amp; 0xFFFFFFFF;
 647   int length = (int) speculation;
 648   if (index + length &gt; (uint) nm-&gt;speculations_size()) {
 649     fatal(INTPTR_FORMAT &quot;[index: %d, length: %d] out of bounds wrt encoded speculations of length %u&quot;, speculation, index, length, nm-&gt;speculations_size());
 650   }
 651   address data = nm-&gt;speculations_begin() + index;
 652   FailedSpeculation::add_failed_speculation(nm, _failed_speculations, data, length);
 653 }
 654 
 655 oop JVMCINMethodData::get_nmethod_mirror(nmethod* nm, bool phantom_ref) {
 656   if (_nmethod_mirror_index == -1) {
 657     return NULL;
 658   }
 659   if (phantom_ref) {
 660     return nm-&gt;oop_at_phantom(_nmethod_mirror_index);
 661   } else {
 662     return nm-&gt;oop_at(_nmethod_mirror_index);
 663   }
 664 }
 665 
 666 void JVMCINMethodData::set_nmethod_mirror(nmethod* nm, oop new_mirror) {
 667   assert(_nmethod_mirror_index != -1, &quot;cannot set JVMCI mirror for nmethod&quot;);
 668   oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 669   assert(new_mirror != NULL, &quot;use clear_nmethod_mirror to clear the mirror&quot;);
 670   assert(*addr == NULL, &quot;cannot overwrite non-null mirror&quot;);
 671 
 672   *addr = new_mirror;
 673 
 674   // Since we&#39;ve patched some oops in the nmethod,
 675   // (re)register it with the heap.
 676   Universe::heap()-&gt;register_nmethod(nm);
 677 }
 678 
 679 void JVMCINMethodData::clear_nmethod_mirror(nmethod* nm) {
 680   if (_nmethod_mirror_index != -1) {
 681     oop* addr = nm-&gt;oop_addr_at(_nmethod_mirror_index);
 682     *addr = NULL;
 683   }
 684 }
 685 
 686 void JVMCINMethodData::invalidate_nmethod_mirror(nmethod* nm) {
 687   oop nmethod_mirror = get_nmethod_mirror(nm, /* phantom_ref */ false);
 688   if (nmethod_mirror == NULL) {
 689     return;
 690   }
 691 
 692   // Update the values in the mirror if it still refers to nm.
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
 713 JVMCIRuntime::JVMCIRuntime(int id) {
 714   _init_state = uninitialized;
 715   _shared_library_javavm = NULL;
 716   _id = id;
 717   _metadata_handles = new MetadataHandles();
 718   JVMCI_event_1(&quot;created new JVMCI runtime %d (&quot; PTR_FORMAT &quot;)&quot;, id, p2i(this));
 719 }
 720 
 721 // Handles to objects in the Hotspot heap.
 722 static OopStorage* object_handles() {
 723   return OopStorageSet::vm_global();
 724 }
 725 
 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {
 727   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);
 728   assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);
 729   oop* ptr = object_handles()-&gt;allocate();
 730   jobject res = NULL;
 731   if (ptr != NULL) {
 732     assert(*ptr == NULL, &quot;invariant&quot;);
 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());
 734     res = reinterpret_cast&lt;jobject&gt;(ptr);
 735   } else {
 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,
 737                           &quot;Cannot create JVMCI oop handle&quot;);
 738   }
 739   MutexLocker ml(JVMCI_lock);
 740   return res;
 741 }
 742 
 743 void JVMCIRuntime::destroy_global(jobject handle) {
 744   // Assert before nulling out, for better debugging.
 745   assert(is_global_handle(handle), &quot;precondition&quot;);
 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);
 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);
 748   object_handles()-&gt;release(oop_ptr);
 749   MutexLocker ml(JVMCI_lock);
 750 }
 751 
 752 bool JVMCIRuntime::is_global_handle(jobject handle) {
 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);
 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
 755 }
 756 
 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {
 758   MutexLocker ml(JVMCI_lock);
 759   return _metadata_handles-&gt;allocate_handle(handle);
 760 }
 761 
 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {
 763   MutexLocker ml(JVMCI_lock);
 764   return _metadata_handles-&gt;allocate_handle(handle);
 765 }
 766 
 767 void JVMCIRuntime::release_handle(jmetadata handle) {
 768   MutexLocker ml(JVMCI_lock);
 769   _metadata_handles-&gt;chain_free_list(handle);
 770 }
 771 
 772 // Function for redirecting shared library JavaVM output to tty
 773 static void _log(const char* buf, size_t count) {
 774   tty-&gt;write((char*) buf, count);
 775 }
 776 
 777 // Function for shared library JavaVM to flush tty
 778 static void _flush_log() {
 779   tty-&gt;flush();
 780 }
 781 
 782 // Function for shared library JavaVM to exit HotSpot on a fatal error
 783 static void _fatal() {
 784   fatal(&quot;Fatal error in JVMCI shared library&quot;);
 785 }
 786 
 787 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {
 788   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
 789   if (javaVM == NULL) {
 790     MutexLocker locker(JVMCI_lock);
 791     // Check again under JVMCI_lock
 792     javaVM = (JavaVM*) _shared_library_javavm;
 793     if (javaVM != NULL) {
 794       return NULL;
 795     }
 796     char* sl_path;
 797     void* sl_handle = JVMCI::get_shared_library(sl_path, true);
 798 
 799     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);
 800     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);
 801 
 802     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, &quot;JNI_CreateJavaVM&quot;));
 803     if (JNI_CreateJavaVM == NULL) {
 804       vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, sl_path);
 805     }
 806 
 807     ResourceMark rm;
 808     JavaVMInitArgs vm_args;
 809     vm_args.version = JNI_VERSION_1_2;
 810     vm_args.ignoreUnrecognized = JNI_TRUE;
 811     JavaVMOption options[4];
 812     jlong javaVM_id = 0;
 813 
 814     // Protocol: JVMCI shared library JavaVM should support a non-standard &quot;_javavm_id&quot;
 815     // option whose extraInfo info field is a pointer to which a unique id for the
 816     // JavaVM should be written.
 817     options[0].optionString = (char*) &quot;_javavm_id&quot;;
 818     options[0].extraInfo = &amp;javaVM_id;
 819 
 820     options[1].optionString = (char*) &quot;_log&quot;;
 821     options[1].extraInfo = (void*) _log;
 822     options[2].optionString = (char*) &quot;_flush_log&quot;;
 823     options[2].extraInfo = (void*) _flush_log;
 824     options[3].optionString = (char*) &quot;_fatal&quot;;
 825     options[3].extraInfo = (void*) _fatal;
 826 
 827     vm_args.version = JNI_VERSION_1_2;
 828     vm_args.options = options;
 829     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);
 830 
 831     JNIEnv* env = NULL;
 832     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);
 833     if (result == JNI_OK) {
 834       guarantee(env != NULL, &quot;missing env&quot;);
 835       _shared_library_javavm = javaVM;
 836       JVMCI_event_1(&quot;created JavaVM[%ld]@&quot; PTR_FORMAT &quot; for JVMCI runtime %d&quot;, javaVM_id, p2i(javaVM), _id);
 837       return env;
 838     } else {
 839       vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), sl_path);
 840     }
 841   }
 842   return NULL;
 843 }
 844 
 845 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {
 846   if (info != NULL) {
 847     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);
 848     if (info_oop-&gt;length() &lt; 4) {
 849       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg(&quot;%d &lt; 4&quot;, info_oop-&gt;length()));
 850     }
 851     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
 852     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);
 853     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
 854     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
 855     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
 856   }
 857 }
 858 
 859 #define JAVAVM_CALL_BLOCK                                             \
 860   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, &quot;npe&quot;); \
 861   ThreadToNativeFromVM ttnfv(thread);                                 \
 862   JavaVM* javavm = (JavaVM*) _shared_library_javavm;
 863 
 864 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {
 865   JAVAVM_CALL_BLOCK
 866   return javavm-&gt;AttachCurrentThread(penv, args);
 867 }
 868 
 869 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {
 870   JAVAVM_CALL_BLOCK
 871   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);
 872 }
 873 
 874 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {
 875   JAVAVM_CALL_BLOCK
 876   return javavm-&gt;DetachCurrentThread();
 877 }
 878 
 879 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {
 880   JAVAVM_CALL_BLOCK
 881   return javavm-&gt;GetEnv(penv, version);
 882 }
 883 #undef JAVAVM_CALL_BLOCK                                             \
 884 
 885 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 886   if (is_HotSpotJVMCIRuntime_initialized()) {
 887     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 888       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);
 889     }
 890   }
 891 
 892   initialize(JVMCIENV);
 893 
 894   // This should only be called in the context of the JVMCI class being initialized
 895   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 896 
 897   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
 898   JVMCI::_is_initialized = true;
 899 }
 900 
 901 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
 902   // Check first without JVMCI_lock
 903   if (_init_state == fully_initialized) {
 904     return;
 905   }
 906 
 907   MutexLocker locker(JVMCI_lock);
 908   // Check again under JVMCI_lock
 909   if (_init_state == fully_initialized) {
 910     return;
 911   }
 912 
 913   while (_init_state == being_initialized) {
 914     JVMCI_event_1(&quot;waiting for initialization of JVMCI runtime %d&quot;, _id);
 915     JVMCI_lock-&gt;wait();
 916     if (_init_state == fully_initialized) {
 917       JVMCI_event_1(&quot;done waiting for initialization of JVMCI runtime %d&quot;, _id);
 918       return;
 919     }
 920   }
 921 
 922   JVMCI_event_1(&quot;initializing JVMCI runtime %d&quot;, _id);
 923   _init_state = being_initialized;
 924 
 925   {
 926     MutexUnlocker unlock(JVMCI_lock);
 927 
 928     HandleMark hm;
 929     ResourceMark rm;
 930     JavaThread* THREAD = JavaThread::current();
 931     if (JVMCIENV-&gt;is_hotspot()) {
 932       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 933     } else {
 934       JNIAccessMark jni(JVMCIENV);
 935 
 936       JNIJVMCI::initialize_ids(jni.env());
 937       if (jni()-&gt;ExceptionCheck()) {
 938         jni()-&gt;ExceptionDescribe();
 939         fatal(&quot;JNI exception during init&quot;);
 940       }
 941     }
 942 
 943     if (!JVMCIENV-&gt;is_hotspot()) {
 944       JNIAccessMark jni(JVMCIENV, THREAD);
 945       JNIJVMCI::register_natives(jni.env());
 946     }
 947     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 948     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 949     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 950     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 951     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 952     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 953     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 954     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 955     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 956 
 957     if (!JVMCIENV-&gt;is_hotspot()) {
 958       JVMCIENV-&gt;copy_saved_properties();
 959     }
 960   }
 961 
 962   _init_state = fully_initialized;
 963   JVMCI_event_1(&quot;initialized JVMCI runtime %d&quot;, _id);
 964   JVMCI_lock-&gt;notify_all();
 965 }
 966 
 967 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 968   Thread* THREAD = Thread::current();
 969   // These primitive types are long lived and are created before the runtime is fully set up
 970   // so skip registering them for scanning.
 971   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 972   if (JVMCIENV-&gt;is_hotspot()) {
 973     JavaValue result(T_OBJECT);
 974     JavaCallArguments args;
 975     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 976     args.push_int(type2char(type));
 977     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 978 
 979     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 980   } else {
 981     JNIAccessMark jni(JVMCIENV);
 982     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 983                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
 984                                            mirror.as_jobject(), type2char(type));
 985     if (jni()-&gt;ExceptionCheck()) {
 986       return JVMCIObject();
 987     }
 988     return JVMCIENV-&gt;wrap(result);
 989   }
 990 }
 991 
 992 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 993   if (!is_HotSpotJVMCIRuntime_initialized()) {
 994     initialize(JVMCI_CHECK);
 995     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 996   }
 997 }
 998 
 999 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
1000   initialize(JVMCIENV);
1001   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
1002   return _HotSpotJVMCIRuntime_instance;
1003 }
1004 
1005 // private static void CompilerToVM.registerNatives()
1006 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
1007   JNI_JVMCIENV(thread, env);
1008 
1009   if (!EnableJVMCI) {
1010     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
1011   }
1012 
1013   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
1014 
1015   {
1016     ResourceMark rm;
1017     HandleMark hm(thread);
1018     ThreadToNativeFromVM trans(thread);
1019 
1020     // Ensure _non_oop_bits is initialized
1021     Universe::non_oop_word();
1022 
1023     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1024       if (!env-&gt;ExceptionCheck()) {
1025         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1026           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1027             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1028             break;
1029           }
1030         }
1031       } else {
1032         env-&gt;ExceptionDescribe();
1033       }
1034       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);
1035     }
1036   }
1037 JVM_END
1038 
1039 
1040 void JVMCIRuntime::shutdown() {
1041   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
1042     JVMCI_event_1(&quot;shutting down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);
1043     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);
1044     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;
1045     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
1046     JVMCI_event_1(&quot;shut down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);
1047   }
1048 }
1049 
1050 void JVMCIRuntime::bootstrap_finished(TRAPS) {
1051   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
1052     THREAD_JVMCIENV(JavaThread::current());
1053     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1054   }
1055 }
1056 
1057 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1058   if (HAS_PENDING_EXCEPTION) {
1059     Handle exception(THREAD, PENDING_EXCEPTION);
1060     const char* exception_file = THREAD-&gt;exception_file();
1061     int exception_line = THREAD-&gt;exception_line();
1062     CLEAR_PENDING_EXCEPTION;
1063     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1064       // Don&#39;t print anything if we are being killed.
1065     } else {
1066       java_lang_Throwable::print_stack_trace(exception, tty);
1067 
1068       // Clear and ignore any exceptions raised during printing
1069       CLEAR_PENDING_EXCEPTION;
1070     }
1071     if (!clear) {
1072       THREAD-&gt;set_pending_exception(exception(), exception_file, exception_line);
1073     }
1074   }
1075 }
1076 
1077 
1078 void JVMCIRuntime::exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message) {
1079   JavaThread* THREAD = JavaThread::current();
1080 
1081   static volatile int report_error = 0;
1082   if (!report_error &amp;&amp; Atomic::cmpxchg(&amp;report_error, 0, 1) == 0) {
1083     // Only report an error once
1084     tty-&gt;print_raw_cr(message);
1085     if (JVMCIENV != NULL) {
1086       JVMCIENV-&gt;describe_pending_exception(true);
1087     } else {
1088       describe_pending_hotspot_exception(THREAD, true);
1089     }
1090   } else {
1091     // Allow error reporting thread to print the stack trace.
1092     THREAD-&gt;sleep(200);
1093   }
1094 
1095   before_exit(THREAD);
1096   vm_exit(-1);
1097 }
1098 
1099 // ------------------------------------------------------------------
1100 // Note: the logic of this method should mirror the logic of
1101 // constantPoolOopDesc::verify_constant_pool_resolve.
1102 bool JVMCIRuntime::check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass) {
1103   if (accessing_klass-&gt;is_objArray_klass()) {
1104     accessing_klass = ObjArrayKlass::cast(accessing_klass)-&gt;bottom_klass();
1105   }
1106   if (!accessing_klass-&gt;is_instance_klass()) {
1107     return true;
1108   }
1109 
1110   if (resolved_klass-&gt;is_objArray_klass()) {
1111     // Find the element klass, if this is an array.
1112     resolved_klass = ObjArrayKlass::cast(resolved_klass)-&gt;bottom_klass();
1113   }
1114   if (resolved_klass-&gt;is_instance_klass()) {
1115     Reflection::VerifyClassAccessResults result =
1116       Reflection::verify_class_access(accessing_klass, InstanceKlass::cast(resolved_klass), true);
1117     return result == Reflection::ACCESS_OK;
1118   }
1119   return true;
1120 }
1121 
1122 // ------------------------------------------------------------------
1123 Klass* JVMCIRuntime::get_klass_by_name_impl(Klass*&amp; accessing_klass,
1124                                           const constantPoolHandle&amp; cpool,
1125                                           Symbol* sym,
1126                                           bool require_local) {
1127   JVMCI_EXCEPTION_CONTEXT;
1128 
1129   // Now we need to check the SystemDictionary
1130   if (sym-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;
1131       sym-&gt;char_at(sym-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {
1132     // This is a name from a signature.  Strip off the trimmings.
1133     // Call recursive to keep scope of strippedsym.
1134     TempNewSymbol strippedsym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1135                                                         sym-&gt;utf8_length()-2);
1136     return get_klass_by_name_impl(accessing_klass, cpool, strippedsym, require_local);
1137   }
1138 
1139   Handle loader(THREAD, (oop)NULL);
1140   Handle domain(THREAD, (oop)NULL);
1141   if (accessing_klass != NULL) {
1142     loader = Handle(THREAD, accessing_klass-&gt;class_loader());
1143     domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
1144   }
1145 
1146   Klass* found_klass;
1147   {
1148     ttyUnlocker ttyul;  // release tty lock to avoid ordering problems
1149     MutexLocker ml(Compile_lock);
1150     if (!require_local) {
1151       found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, CHECK_NULL);
1152     } else {
1153       found_klass = SystemDictionary::find_instance_or_array_klass(sym, loader, domain, CHECK_NULL);
1154     }
1155   }
1156 
1157   // If we fail to find an array klass, look again for its element type.
1158   // The element type may be available either locally or via constraints.
1159   // In either case, if we can find the element type in the system dictionary,
1160   // we must build an array type around it.  The CI requires array klasses
1161   // to be loaded if their element klasses are loaded, except when memory
1162   // is exhausted.
1163   if (sym-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;
1164       (sym-&gt;char_at(1) == JVM_SIGNATURE_ARRAY || sym-&gt;char_at(1) == JVM_SIGNATURE_CLASS)) {
1165     // We have an unloaded array.
1166     // Build it on the fly if the element class exists.
1167     TempNewSymbol elem_sym = SymbolTable::new_symbol(sym-&gt;as_utf8()+1,
1168                                                      sym-&gt;utf8_length()-1);
1169 
1170     // Get element Klass recursively.
1171     Klass* elem_klass =
1172       get_klass_by_name_impl(accessing_klass,
1173                              cpool,
1174                              elem_sym,
1175                              require_local);
1176     if (elem_klass != NULL) {
1177       // Now make an array for it
1178       return elem_klass-&gt;array_klass(THREAD);
1179     }
1180   }
1181 
1182   if (found_klass == NULL &amp;&amp; !cpool.is_null() &amp;&amp; cpool-&gt;has_preresolution()) {
1183     // Look inside the constant pool for pre-resolved class entries.
1184     for (int i = cpool-&gt;length() - 1; i &gt;= 1; i--) {
1185       if (cpool-&gt;tag_at(i).is_klass()) {
1186         Klass*  kls = cpool-&gt;resolved_klass_at(i);
1187         if (kls-&gt;name() == sym) {
1188           return kls;
1189         }
1190       }
1191     }
1192   }
1193 
1194   return found_klass;
1195 }
1196 
1197 // ------------------------------------------------------------------
1198 Klass* JVMCIRuntime::get_klass_by_name(Klass* accessing_klass,
1199                                   Symbol* klass_name,
1200                                   bool require_local) {
1201   ResourceMark rm;
1202   constantPoolHandle cpool;
1203   return get_klass_by_name_impl(accessing_klass,
1204                                                  cpool,
1205                                                  klass_name,
1206                                                  require_local);
1207 }
1208 
1209 // ------------------------------------------------------------------
1210 // Implementation of get_klass_by_index.
1211 Klass* JVMCIRuntime::get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
1212                                         int index,
1213                                         bool&amp; is_accessible,
1214                                         Klass* accessor) {
1215   JVMCI_EXCEPTION_CONTEXT;
1216   Klass* klass = ConstantPool::klass_at_if_loaded(cpool, index);
1217   Symbol* klass_name = NULL;
1218   if (klass == NULL) {
1219     klass_name = cpool-&gt;klass_name_at(index);
1220   }
1221 
1222   if (klass == NULL) {
1223     // Not found in constant pool.  Use the name to do the lookup.
1224     Klass* k = get_klass_by_name_impl(accessor,
1225                                         cpool,
1226                                         klass_name,
1227                                         false);
1228     // Calculate accessibility the hard way.
1229     if (k == NULL) {
1230       is_accessible = false;
1231     } else if (k-&gt;class_loader() != accessor-&gt;class_loader() &amp;&amp;
1232                get_klass_by_name_impl(accessor, cpool, k-&gt;name(), true) == NULL) {
1233       // Loaded only remotely.  Not linked yet.
1234       is_accessible = false;
1235     } else {
1236       // Linked locally, and we must also check public/private, etc.
1237       is_accessible = check_klass_accessibility(accessor, k);
1238     }
1239     if (!is_accessible) {
1240       return NULL;
1241     }
1242     return k;
1243   }
1244 
1245   // It is known to be accessible, since it was found in the constant pool.
1246   is_accessible = true;
1247   return klass;
1248 }
1249 
1250 // ------------------------------------------------------------------
1251 // Get a klass from the constant pool.
1252 Klass* JVMCIRuntime::get_klass_by_index(const constantPoolHandle&amp; cpool,
1253                                    int index,
1254                                    bool&amp; is_accessible,
1255                                    Klass* accessor) {
1256   ResourceMark rm;
1257   Klass* result = get_klass_by_index_impl(cpool, index, is_accessible, accessor);
1258   return result;
1259 }
1260 
1261 // ------------------------------------------------------------------
1262 // Implementation of get_field_by_index.
1263 //
1264 // Implementation note: the results of field lookups are cached
1265 // in the accessor klass.
1266 void JVMCIRuntime::get_field_by_index_impl(InstanceKlass* klass, fieldDescriptor&amp; field_desc,
1267                                         int index) {
1268   JVMCI_EXCEPTION_CONTEXT;
1269 
1270   assert(klass-&gt;is_linked(), &quot;must be linked before using its constant-pool&quot;);
1271 
1272   constantPoolHandle cpool(thread, klass-&gt;constants());
1273 
1274   // Get the field&#39;s name, signature, and type.
1275   Symbol* name  = cpool-&gt;name_ref_at(index);
1276 
1277   int nt_index = cpool-&gt;name_and_type_ref_index_at(index);
1278   int sig_index = cpool-&gt;signature_ref_index_at(nt_index);
1279   Symbol* signature = cpool-&gt;symbol_at(sig_index);
1280 
1281   // Get the field&#39;s declared holder.
1282   int holder_index = cpool-&gt;klass_ref_index_at(index);
1283   bool holder_is_accessible;
1284   Klass* declared_holder = get_klass_by_index(cpool, holder_index,
1285                                                holder_is_accessible,
1286                                                klass);
1287 
1288   // The declared holder of this field may not have been loaded.
1289   // Bail out with partial field information.
1290   if (!holder_is_accessible) {
1291     return;
1292   }
1293 
1294 
1295   // Perform the field lookup.
1296   Klass*  canonical_holder =
1297     InstanceKlass::cast(declared_holder)-&gt;find_field(name, signature, &amp;field_desc);
1298   if (canonical_holder == NULL) {
1299     return;
1300   }
1301 
1302   assert(canonical_holder == field_desc.field_holder(), &quot;just checking&quot;);
1303 }
1304 
1305 // ------------------------------------------------------------------
1306 // Get a field by index from a klass&#39;s constant pool.
1307 void JVMCIRuntime::get_field_by_index(InstanceKlass* accessor, fieldDescriptor&amp; fd, int index) {
1308   ResourceMark rm;
1309   return get_field_by_index_impl(accessor, fd, index);
1310 }
1311 
1312 // ------------------------------------------------------------------
1313 // Perform an appropriate method lookup based on accessor, holder,
1314 // name, signature, and bytecode.
1315 Method* JVMCIRuntime::lookup_method(InstanceKlass* accessor,
1316                                     Klass*        holder,
1317                                     Symbol*       name,
1318                                     Symbol*       sig,
1319                                     Bytecodes::Code bc,
1320                                     constantTag   tag) {
1321   // Accessibility checks are performed in JVMCIEnv::get_method_by_index_impl().
1322   assert(check_klass_accessibility(accessor, holder), &quot;holder not accessible&quot;);
1323 
1324   Method* dest_method;
1325   LinkInfo link_info(holder, name, sig, accessor, LinkInfo::needs_access_check, tag);
1326   switch (bc) {
1327   case Bytecodes::_invokestatic:
1328     dest_method =
1329       LinkResolver::resolve_static_call_or_null(link_info);
1330     break;
1331   case Bytecodes::_invokespecial:
1332     dest_method =
1333       LinkResolver::resolve_special_call_or_null(link_info);
1334     break;
1335   case Bytecodes::_invokeinterface:
1336     dest_method =
1337       LinkResolver::linktime_resolve_interface_method_or_null(link_info);
1338     break;
1339   case Bytecodes::_invokevirtual:
1340     dest_method =
1341       LinkResolver::linktime_resolve_virtual_method_or_null(link_info);
1342     break;
1343   default: ShouldNotReachHere();
1344   }
1345 
1346   return dest_method;
1347 }
1348 
1349 
1350 // ------------------------------------------------------------------
1351 Method* JVMCIRuntime::get_method_by_index_impl(const constantPoolHandle&amp; cpool,
1352                                                int index, Bytecodes::Code bc,
1353                                                InstanceKlass* accessor) {
1354   if (bc == Bytecodes::_invokedynamic) {
1355     ConstantPoolCacheEntry* cpce = cpool-&gt;invokedynamic_cp_cache_entry_at(index);
1356     bool is_resolved = !cpce-&gt;is_f1_null();
1357     if (is_resolved) {
1358       // Get the invoker Method* from the constant pool.
1359       // (The appendix argument, if any, will be noted in the method&#39;s signature.)
1360       Method* adapter = cpce-&gt;f1_as_method();
1361       return adapter;
1362     }
1363 
1364     return NULL;
1365   }
1366 
1367   int holder_index = cpool-&gt;klass_ref_index_at(index);
1368   bool holder_is_accessible;
1369   Klass* holder = get_klass_by_index_impl(cpool, holder_index, holder_is_accessible, accessor);
1370 
1371   // Get the method&#39;s name and signature.
1372   Symbol* name_sym = cpool-&gt;name_ref_at(index);
1373   Symbol* sig_sym  = cpool-&gt;signature_ref_at(index);
1374 
1375   if (cpool-&gt;has_preresolution()
1376       || ((holder == SystemDictionary::MethodHandle_klass() || holder == SystemDictionary::VarHandle_klass()) &amp;&amp;
1377           MethodHandles::is_signature_polymorphic_name(holder, name_sym))) {
1378     // Short-circuit lookups for JSR 292-related call sites.
1379     // That is, do not rely only on name-based lookups, because they may fail
1380     // if the names are not resolvable in the boot class loader (7056328).
1381     switch (bc) {
1382     case Bytecodes::_invokevirtual:
1383     case Bytecodes::_invokeinterface:
1384     case Bytecodes::_invokespecial:
1385     case Bytecodes::_invokestatic:
1386       {
1387         Method* m = ConstantPool::method_at_if_loaded(cpool, index);
1388         if (m != NULL) {
1389           return m;
1390         }
1391       }
1392       break;
1393     default:
1394       break;
1395     }
1396   }
1397 
1398   if (holder_is_accessible) { // Our declared holder is loaded.
1399     constantTag tag = cpool-&gt;tag_ref_at(index);
1400     Method* m = lookup_method(accessor, holder, name_sym, sig_sym, bc, tag);
1401     if (m != NULL) {
1402       // We found the method.
1403       return m;
1404     }
1405   }
1406 
1407   // Either the declared holder was not loaded, or the method could
1408   // not be found.
1409 
1410   return NULL;
1411 }
1412 
1413 // ------------------------------------------------------------------
1414 InstanceKlass* JVMCIRuntime::get_instance_klass_for_declared_method_holder(Klass* method_holder) {
1415   // For the case of &lt;array&gt;.clone(), the method holder can be an ArrayKlass*
1416   // instead of an InstanceKlass*.  For that case simply pretend that the
1417   // declared holder is Object.clone since that&#39;s where the call will bottom out.
1418   if (method_holder-&gt;is_instance_klass()) {
1419     return InstanceKlass::cast(method_holder);
1420   } else if (method_holder-&gt;is_array_klass()) {
1421     return SystemDictionary::Object_klass();
1422   } else {
1423     ShouldNotReachHere();
1424   }
1425   return NULL;
1426 }
1427 
1428 
1429 // ------------------------------------------------------------------
1430 Method* JVMCIRuntime::get_method_by_index(const constantPoolHandle&amp; cpool,
1431                                      int index, Bytecodes::Code bc,
1432                                      InstanceKlass* accessor) {
1433   ResourceMark rm;
1434   return get_method_by_index_impl(cpool, index, bc, accessor);
1435 }
1436 
1437 // ------------------------------------------------------------------
1438 // Check for changes to the system dictionary during compilation
1439 // class loads, evolution, breakpoints
1440 JVMCI::CodeInstallResult JVMCIRuntime::validate_compile_task_dependencies(Dependencies* dependencies, JVMCICompileState* compile_state, char** failure_detail) {
1441   // If JVMTI capabilities were enabled during compile, the compilation is invalidated.
1442   if (compile_state != NULL &amp;&amp; compile_state-&gt;jvmti_state_changed()) {
1443     *failure_detail = (char*) &quot;Jvmti state change during compilation invalidated dependencies&quot;;
1444     return JVMCI::dependencies_failed;
1445   }
1446 
1447   CompileTask* task = compile_state == NULL ? NULL : compile_state-&gt;task();
1448   Dependencies::DepType result = dependencies-&gt;validate_dependencies(task, failure_detail);
1449   if (result == Dependencies::end_marker) {
1450     return JVMCI::ok;
1451   }
1452 
1453   return JVMCI::dependencies_failed;
1454 }
1455 
1456 // Reports a pending exception and exits the VM.
1457 static void fatal_exception_in_compile(JVMCIEnv* JVMCIENV, JavaThread* thread, const char* msg) {
1458   // Only report a fatal JVMCI compilation exception once
1459   static volatile int report_init_failure = 0;
1460   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1461       tty-&gt;print_cr(&quot;%s:&quot;, msg);
1462       JVMCIENV-&gt;describe_pending_exception(true);
1463   }
1464   JVMCIENV-&gt;clear_pending_exception();
1465   before_exit(thread);
1466   vm_exit(-1);
1467 }
1468 
1469 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1470   JVMCI_EXCEPTION_CONTEXT
1471 
1472   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1473 
1474   bool is_osr = entry_bci != InvocationEntryBci;
1475   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1476     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1477     // and we know that there are no endless loops
1478     compile_state-&gt;set_failure(true, &quot;No OSR during bootstrap&quot;);
1479     return;
1480   }
1481   if (JVMCI::in_shutdown()) {
1482     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
1483     return;
1484   }
1485 
1486   HandleMark hm;
1487   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1488   if (JVMCIENV-&gt;has_pending_exception()) {
1489     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);
1490   }
1491   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1492   if (JVMCIENV-&gt;has_pending_exception()) {
1493     JVMCIENV-&gt;describe_pending_exception(true);
1494     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);
1495     return;
1496   }
1497 
1498   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1499                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1500   if (!JVMCIENV-&gt;has_pending_exception()) {
1501     if (result_object.is_non_null()) {
1502       JVMCIObject failure_message = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_failureMessage(result_object);
1503       if (failure_message.is_non_null()) {
1504         // Copy failure reason into resource memory first ...
1505         const char* failure_reason = JVMCIENV-&gt;as_utf8_string(failure_message);
1506         // ... and then into the C heap.
1507         failure_reason = os::strdup(failure_reason, mtJVMCI);
1508         bool retryable = JVMCIENV-&gt;get_HotSpotCompilationRequestResult_retry(result_object) != 0;
1509         compile_state-&gt;set_failure(retryable, failure_reason, true);
1510       } else {
1511         if (compile_state-&gt;task()-&gt;code() == NULL) {
1512           compile_state-&gt;set_failure(true, &quot;no nmethod produced&quot;);
1513         } else {
1514           compile_state-&gt;task()-&gt;set_num_inlined_bytecodes(JVMCIENV-&gt;get_HotSpotCompilationRequestResult_inlinedBytecodes(result_object));
1515           compiler-&gt;inc_methods_compiled();
1516         }
1517       }
1518     } else {
1519       assert(false, &quot;JVMCICompiler.compileMethod should always return non-null&quot;);
1520     }
1521   } else {
1522     // An uncaught exception here implies failure during compiler initialization.
1523     // The only sensible thing to do here is to exit the VM.
1524     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during JVMCI compiler initialization&quot;);
1525   }
1526   if (compiler-&gt;is_bootstrapping()) {
1527     compiler-&gt;set_bootstrap_compilation_request_handled();
1528   }
1529 }
1530 
1531 
1532 // ------------------------------------------------------------------
1533 JVMCI::CodeInstallResult JVMCIRuntime::register_method(JVMCIEnv* JVMCIENV,
1534                                 const methodHandle&amp; method,
1535                                 nmethod*&amp; nm,
1536                                 int entry_bci,
1537                                 CodeOffsets* offsets,
1538                                 int orig_pc_offset,
1539                                 CodeBuffer* code_buffer,
1540                                 int frame_words,
1541                                 OopMapSet* oop_map_set,
1542                                 ExceptionHandlerTable* handler_table,
1543                                 ImplicitExceptionTable* implicit_exception_table,
1544                                 AbstractCompiler* compiler,
1545                                 DebugInformationRecorder* debug_info,
1546                                 Dependencies* dependencies,
1547                                 int compile_id,
1548                                 bool has_unsafe_access,
1549                                 bool has_wide_vector,
1550                                 JVMCIObject compiled_code,
1551                                 JVMCIObject nmethod_mirror,
1552                                 FailedSpeculation** failed_speculations,
1553                                 char* speculations,
1554                                 int speculations_len) {
1555   JVMCI_EXCEPTION_CONTEXT;
1556   nm = NULL;
1557   int comp_level = CompLevel_full_optimization;
1558   char* failure_detail = NULL;
1559 
1560   bool install_default = JVMCIENV-&gt;get_HotSpotNmethod_isDefault(nmethod_mirror) != 0;
1561   assert(JVMCIENV-&gt;isa_HotSpotNmethod(nmethod_mirror), &quot;must be&quot;);
1562   JVMCIObject name = JVMCIENV-&gt;get_InstalledCode_name(nmethod_mirror);
1563   const char* nmethod_mirror_name = name.is_null() ? NULL : JVMCIENV-&gt;as_utf8_string(name);
1564   int nmethod_mirror_index;
1565   if (!install_default) {
1566     // Reserve or initialize mirror slot in the oops table.
1567     OopRecorder* oop_recorder = debug_info-&gt;oop_recorder();
1568     nmethod_mirror_index = oop_recorder-&gt;allocate_oop_index(nmethod_mirror.is_hotspot() ? nmethod_mirror.as_jobject() : NULL);
1569   } else {
1570     // A default HotSpotNmethod mirror is never tracked by the nmethod
1571     nmethod_mirror_index = -1;
1572   }
1573 
1574   JVMCI::CodeInstallResult result;
1575   {
1576     // To prevent compile queue updates.
1577     MutexLocker locker(THREAD, MethodCompileQueue_lock);
1578 
1579     // Prevent SystemDictionary::add_to_hierarchy from running
1580     // and invalidating our dependencies until we install this method.
1581     MutexLocker ml(Compile_lock);
1582 
1583     // Encode the dependencies now, so we can check them right away.
1584     dependencies-&gt;encode_content_bytes();
1585 
1586     // Record the dependencies for the current compile in the log
1587     if (LogCompilation) {
1588       for (Dependencies::DepStream deps(dependencies); deps.next(); ) {
1589         deps.log_dependency();
1590       }
1591     }
1592 
1593     // Check for {class loads, evolution, breakpoints} during compilation
1594     result = validate_compile_task_dependencies(dependencies, JVMCIENV-&gt;compile_state(), &amp;failure_detail);
1595     if (result != JVMCI::ok) {
1596       // While not a true deoptimization, it is a preemptive decompile.
1597       MethodData* mdp = method()-&gt;method_data();
1598       if (mdp != NULL) {
1599         mdp-&gt;inc_decompile_count();
1600 #ifdef ASSERT
1601         if (mdp-&gt;decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
1602           ResourceMark m;
1603           tty-&gt;print_cr(&quot;WARN: endless recompilation of %s. Method was set to not compilable.&quot;, method()-&gt;name_and_sig_as_C_string());
1604         }
1605 #endif
1606       }
1607 
1608       // All buffers in the CodeBuffer are allocated in the CodeCache.
1609       // If the code buffer is created on each compile attempt
1610       // as in C2, then it must be freed.
1611       //code_buffer-&gt;free_blob();
1612     } else {
1613       nm =  nmethod::new_nmethod(method,
1614                                  compile_id,
1615                                  entry_bci,
1616                                  offsets,
1617                                  orig_pc_offset,
1618                                  debug_info, dependencies, code_buffer,
1619                                  frame_words, oop_map_set,
1620                                  handler_table, implicit_exception_table,
1621                                  compiler, comp_level,
1622                                  speculations, speculations_len,
1623                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
1624 
1625 
1626       // Free codeBlobs
1627       if (nm == NULL) {
1628         // The CodeCache is full.  Print out warning and disable compilation.
1629         {
1630           MutexUnlocker ml(Compile_lock);
1631           MutexUnlocker locker(MethodCompileQueue_lock);
1632           CompileBroker::handle_full_code_cache(CodeCache::get_code_blob_type(comp_level));
1633         }
1634       } else {
1635         nm-&gt;set_has_unsafe_access(has_unsafe_access);
1636         nm-&gt;set_has_wide_vectors(has_wide_vector);
1637 
1638         // Record successful registration.
1639         // (Put nm into the task handle *before* publishing to the Java heap.)
1640         if (JVMCIENV-&gt;compile_state() != NULL) {
1641           JVMCIENV-&gt;compile_state()-&gt;task()-&gt;set_code(nm);
1642         }
1643 
1644         JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
1645         assert(data != NULL, &quot;must be&quot;);
1646         if (install_default) {
1647           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == NULL, &quot;must be&quot;);
1648           if (entry_bci == InvocationEntryBci) {
1649             if (TieredCompilation) {
1650               // If there is an old version we&#39;re done with it
1651               CompiledMethod* old = method-&gt;code();
1652               if (TraceMethodReplacement &amp;&amp; old != NULL) {
1653                 ResourceMark rm;
1654                 char *method_name = method-&gt;name_and_sig_as_C_string();
1655                 tty-&gt;print_cr(&quot;Replacing method %s&quot;, method_name);
1656               }
1657               if (old != NULL ) {
1658                 old-&gt;make_not_entrant();
1659               }
1660             }
1661 
1662             LogTarget(Info, nmethod, install) lt;
1663             if (lt.is_enabled()) {
1664               ResourceMark rm;
1665               char *method_name = method-&gt;name_and_sig_as_C_string();
1666               lt.print(&quot;Installing method (%d) %s [entry point: %p]&quot;,
1667                         comp_level, method_name, nm-&gt;entry_point());
1668             }
1669             // Allow the code to be executed
1670             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1671             if (nm-&gt;make_in_use()) {
1672               method-&gt;set_code(method, nm);
1673             }
1674           } else {
1675             LogTarget(Info, nmethod, install) lt;
1676             if (lt.is_enabled()) {
1677               ResourceMark rm;
1678               char *method_name = method-&gt;name_and_sig_as_C_string();
1679               lt.print(&quot;Installing osr method (%d) %s @ %d&quot;,
1680                         comp_level, method_name, entry_bci);
1681             }
1682             MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1683             if (nm-&gt;make_in_use()) {
1684               InstanceKlass::cast(method-&gt;method_holder())-&gt;add_osr_nmethod(nm);
1685             }
1686           }
1687         } else {
1688           assert(!nmethod_mirror.is_hotspot() || data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) == HotSpotJVMCI::resolve(nmethod_mirror), &quot;must be&quot;);
1689         }
1690       }
1691       result = nm != NULL ? JVMCI::ok :JVMCI::cache_full;
1692     }
1693   }
1694 
1695   // String creation must be done outside lock
1696   if (failure_detail != NULL) {
1697     // A failure to allocate the string is silently ignored.
1698     JVMCIObject message = JVMCIENV-&gt;create_string(failure_detail, JVMCIENV);
1699     JVMCIENV-&gt;set_HotSpotCompiledNmethod_installationFailureMessage(compiled_code, message);
1700   }
1701 
1702   // JVMTI -- compiled method notification (must be done outside lock)
1703   if (nm != NULL) {
1704     nm-&gt;post_compiled_method_load_event();
1705   }
1706 
1707   return result;
1708 }
    </pre>
  </body>
</html>