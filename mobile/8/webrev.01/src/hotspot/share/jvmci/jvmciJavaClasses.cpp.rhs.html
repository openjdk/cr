<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciJavaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/symbolTable.hpp&quot;
 26 #include &quot;interpreter/linkResolver.hpp&quot;
 27 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
 28 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
 29 #include &quot;jvmci/jvmciRuntime.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;
 31 #include &quot;runtime/jniHandles.inline.hpp&quot;
 32 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 33 
 34 // ------------------------------------------------------------------
 35 
 36 oop HotSpotJVMCI::resolve(JVMCIObject obj) {
 37   return JNIHandles::resolve(obj.as_jobject());
 38 }
 39 
 40 arrayOop HotSpotJVMCI::resolve(JVMCIArray obj) {
 41   return (arrayOop) JNIHandles::resolve(obj.as_jobject());
 42 }
 43 
 44 objArrayOop HotSpotJVMCI::resolve(JVMCIObjectArray obj) {
 45   return (objArrayOop) JNIHandles::resolve(obj.as_jobject());
 46 }
 47 
 48 typeArrayOop HotSpotJVMCI::resolve(JVMCIPrimitiveArray obj) {
 49   return (typeArrayOop) JNIHandles::resolve(obj.as_jobject());
 50 }
 51 
 52 JVMCIObject HotSpotJVMCI::wrap(oop obj) {
 53   assert(Thread::current()-&gt;is_Java_thread(), &quot;must be&quot;);
 54   return JVMCIObject(JNIHandles::make_local(obj), true);
 55 }
 56 
 57 /**
 58  * Computes the field offset of a static or instance field.
 59  * It looks up the name and signature symbols without creating new ones;
 60  * all the symbols of these classes need to be already loaded.
 61  */
 62 void HotSpotJVMCI::compute_offset(int &amp;dest_offset, Klass* klass, const char* name, const char* signature, bool static_field, TRAPS) {
 63   InstanceKlass* ik = InstanceKlass::cast(klass);
 64   Symbol* name_symbol = SymbolTable::probe(name, (int)strlen(name));
 65   Symbol* signature_symbol = SymbolTable::probe(signature, (int)strlen(signature));
 66   if (name_symbol == NULL || signature_symbol == NULL) {
 67 #ifndef PRODUCT
 68     ik-&gt;print_on(tty);
 69 #endif
 70     fatal(&quot;symbol with name %s and signature %s was not found in symbol table (klass=%s)&quot;, name, signature, klass-&gt;name()-&gt;as_C_string());
 71   }
 72 
 73   fieldDescriptor fd;
 74   if (!ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd)) {
 75     ResourceMark rm;
 76     fatal(&quot;Could not find field %s.%s with signature %s&quot;, ik-&gt;external_name(), name, signature);
 77   }
 78   guarantee(fd.is_static() == static_field, &quot;static/instance mismatch&quot;);
 79   dest_offset = fd.offset();
 80   assert(dest_offset != 0, &quot;must be valid offset&quot;);
 81   if (static_field) {
 82     // Must ensure classes for static fields are initialized as the
 83     // accessor itself does not include a class initialization check.
 84     ik-&gt;initialize(CHECK);
 85   }
<a name="1" id="anc1"></a><span class="line-added"> 86   JVMCI_event_2(&quot;   field offset for %s %s.%s = %d&quot;, signature, ik-&gt;external_name(), name, dest_offset);</span>
 87 }
 88 
 89 #ifndef PRODUCT
 90 static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {
 91   Method* method;
 92   LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::skip_access_check);
 93   if (strcmp(call_type, &quot;call_static&quot;) == 0) {
 94     method = LinkResolver::resolve_static_call_or_null(link_info);
 95   } else if (strcmp(call_type, &quot;call_virtual&quot;) == 0) {
 96     method = LinkResolver::resolve_virtual_call_or_null(resolved_klass, link_info);
 97   } else if (strcmp(call_type, &quot;call_special&quot;) == 0) {
 98     method = LinkResolver::resolve_special_call_or_null(link_info);
 99   } else {
100     fatal(&quot;Unknown or unsupported call type: %s&quot;, call_type);
101   }
102   if (method == NULL) {
103     fatal(&quot;Could not resolve %s.%s%s&quot;, resolved_klass-&gt;external_name(), method_name-&gt;as_C_string(), method_signature-&gt;as_C_string());
104   }
105 }
106 #endif
107 
108 jclass JNIJVMCI::_box_classes[T_CONFLICT+1];
109 jclass JNIJVMCI::_byte_array;
110 jfieldID JNIJVMCI::_box_fields[T_CONFLICT+1];
111 jmethodID JNIJVMCI::_box_constructors[T_CONFLICT+1];
112 jmethodID JNIJVMCI::_Class_getName_method;
113 
114 jmethodID JNIJVMCI::_HotSpotResolvedJavaMethodImpl_fromMetaspace_method;
115 jmethodID JNIJVMCI::_HotSpotConstantPool_fromMetaspace_method;
116 jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;
117 jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;
118 
119 #define START_CLASS(className, fullClassName)                          { \
120   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \
<a name="2" id="anc2"></a><span class="line-modified">121   className::_klass = InstanceKlass::cast(k);                                     \</span>
<span class="line-added">122   JVMCI_event_2(&quot; klass for %s = &quot; PTR_FORMAT, k-&gt;external_name(), p2i(k));       \</span>
123   className::_klass-&gt;initialize(CHECK);
124 
125 #define END_CLASS }
126 
127 #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);
128 #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)
129 #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)
130 #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)
131 #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)
132 #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)
133 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)
134 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
135 #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)
136 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)
137 #ifdef PRODUCT
138 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
139 #define CONSTRUCTOR(className, signature)
140 #else
141 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
142   check_resolve_method(#hsCallType, k, vmSymbols::methodName##_name(), vmSymbols::signatureSymbolName(), CHECK);
143 #define CONSTRUCTOR(className, signature) { \
144   TempNewSymbol sig = SymbolTable::new_symbol(signature); \
145   check_resolve_method(&quot;call_special&quot;, k, vmSymbols::object_initializer_name(), sig, CHECK); \
146   }
147 #endif
148 /**
149  * Computes and initializes the offsets used by HotSpotJVMCI.
150  */
151 void HotSpotJVMCI::compute_offsets(TRAPS) {
152   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
153 }
154 
155 #undef START_CLASS
156 #undef END_CLASS
157 #undef METHOD
158 #undef CONSTRUCTOR
159 #undef FIELD
160 #undef CHAR_FIELD
161 #undef INT_FIELD
162 #undef BOOLEAN_FIELD
163 #undef LONG_FIELD
164 #undef FLOAT_FIELD
165 #undef OBJECT_FIELD
166 #undef PRIMARRAY_FIELD
167 #undef OBJECTARRAY_FIELD
168 #undef STATIC_FIELD
169 #undef STATIC_OBJECT_FIELD
170 #undef STATIC_OBJECTARRAY_FIELD
171 #undef STATIC_INT_FIELD
172 #undef STATIC_BOOLEAN_FIELD
173 #undef EMPTY_CAST
174 
175 // ------------------------------------------------------------------
176 
177 #define START_CLASS(className, fullClassName)                                           \
178   void HotSpotJVMCI::className::initialize(JVMCI_TRAPS) {                               \
179     Thread* THREAD = Thread::current();                                                 \
180     className::klass()-&gt;initialize(CHECK);                                              \
181   }                                                                                     \
182   bool HotSpotJVMCI::className::is_instance(JVMCIEnv* env, JVMCIObject object) {        \
183     return resolve(object)-&gt;is_a(className::klass());                                   \
184   }                                                                                     \
185   void HotSpotJVMCI::className::check(oop obj, const char* field_name, int offset) {    \
186     assert(obj != NULL, &quot;NULL field access of %s.%s&quot;, #className, field_name); \
187     assert(obj-&gt;is_a(className::klass()), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, obj-&gt;klass()-&gt;external_name()); \
188     assert(offset != 0, &quot;must be valid offset&quot;);                                        \
189   }                                                                                     \
190   InstanceKlass* HotSpotJVMCI::className::_klass = NULL;
191 
192 #define END_CLASS
193 
194 #define FIELD(className, name, type, accessor, cast)                     \
195   type HotSpotJVMCI::className::name(JVMCIEnv* env, oop obj)               { className::check(obj, #name, className::_##name##_offset); return cast obj-&gt;accessor(className::_##name##_offset); } \
196   void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, oop obj, type x) { className::check(obj, #name, className::_##name##_offset); obj-&gt;accessor##_put(className::_##name##_offset, x); }
197 
198 #define EMPTY_CAST
199 #define CHAR_FIELD(className, name) FIELD(className, name, jchar, char_field, EMPTY_CAST)
200 #define INT_FIELD(className, name) FIELD(className, name, jint, int_field, EMPTY_CAST)
201 #define BOOLEAN_FIELD(className, name) FIELD(className, name, jboolean, bool_field, EMPTY_CAST)
202 #define LONG_FIELD(className, name) FIELD(className, name, jlong, long_field, EMPTY_CAST)
203 #define FLOAT_FIELD(className, name) FIELD(className, name, jfloat, float_field, EMPTY_CAST)
204 
205 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, oop, obj_field, EMPTY_CAST)
206 #define OBJECTARRAY_FIELD(className, name, signature) FIELD(className, name, objArrayOop, obj_field, (objArrayOop))
207 #define PRIMARRAY_FIELD(className, name, signature) FIELD(className, name, typeArrayOop, obj_field, (typeArrayOop))
208 #define STATIC_OBJECT_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, oop)
209 #define STATIC_OBJECTARRAY_FIELD(className, name, signature) STATIC_OOPISH_FIELD(className, name, objArrayOop)
210 #define STATIC_OOPISH_FIELD(className, name, type)                                                                        \
211     type HotSpotJVMCI::className::name(JVMCIEnv* env) {                                                                   \
212       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \
213       InstanceKlass* ik = className::klass();                                                                             \
214       oop base = ik-&gt;static_field_base_raw();                                                                             \
215       oop result = HeapAccess&lt;&gt;::oop_load_at(base, className::_##name##_offset);                                          \
216       return type(result);                                                                                                \
217     }                                                                                                                     \
218     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, type x) {                                                     \
219       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \
220       assert(className::klass() != NULL, &quot;Class not yet loaded: &quot; #className);                                            \
221       InstanceKlass* ik = className::klass();                                                                             \
222       oop base = ik-&gt;static_field_base_raw();                                                                             \
223       HeapAccess&lt;&gt;::oop_store_at(base, className::_##name##_offset, x);                                                   \
224     }
225 #define STATIC_PRIMITIVE_FIELD(className, name, jtypename)                                                                \
226     jtypename HotSpotJVMCI::className::get_##name(JVMCIEnv* env) {                                                        \
227       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \
228       InstanceKlass* ik = className::klass();                                                                             \
229       oop base = ik-&gt;static_field_base_raw();                                                                             \
230       return HeapAccess&lt;&gt;::load_at(base, className::_##name##_offset);                                                    \
231     }                                                                                                                     \
232     void HotSpotJVMCI::className::set_##name(JVMCIEnv* env, jtypename x) {                                                \
233       assert(className::klass() != NULL &amp;&amp; className::klass()-&gt;is_linked(), &quot;Class not yet linked: &quot; #className);         \
234       InstanceKlass* ik = className::klass();                                                                             \
235       oop base = ik-&gt;static_field_base_raw();                                                                             \
236       HeapAccess&lt;&gt;::store_at(base, _##name##_offset, x);                                                                  \
237     }
238 
239 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint)
240 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean)
241 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
242 #define CONSTRUCTOR(className, signature)
243 
244 /**
245  * Generates the method and field definitions for the classes in HotSpotJVMCI. For example:
246  *
247  * void HotSpotJVMCI::Architecture::initialize(JVMCIEnv* env) { ... }
248  * bool HotSpotJVMCI::Architecture::is_instance(JVMCIEnv* env, JVMCIObject object) { ... }
249  * void HotSpotJVMCI::Architecture::check(oop obj, const char* field_name, int offset) { ... }
250  *  oop HotSpotJVMCI::Architecture::wordKind(JVMCIEnv* env, oop obj) { ... }
251  * void HotSpotJVMCI::Architecture::set_wordKind(JVMCIEnv* env, oop obj, oop x) { ... }
252  *
253  * InstanceKlass *HotSpotJVMCI::Architecture::_klass = NULL;
254  */
255 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
256 
257 #undef START_CLASS
258 #undef END_CLASS
259 #undef METHOD
260 #undef CONSTRUCTOR
261 #undef FIELD
262 #undef CHAR_FIELD
263 #undef INT_FIELD
264 #undef BOOLEAN_FIELD
265 #undef LONG_FIELD
266 #undef FLOAT_FIELD
267 #undef OBJECT_FIELD
268 #undef PRIMARRAY_FIELD
269 #undef OBJECTARRAY_FIELD
270 #undef STATIC_OOPISH_FIELD
271 #undef STATIC_OBJECT_FIELD
272 #undef STATIC_OBJECTARRAY_FIELD
273 #undef STATIC_INT_FIELD
274 #undef STATIC_BOOLEAN_FIELD
275 #undef STATIC_PRIMITIVE_FIELD
276 #undef EMPTY_CAST
277 
278 /**
279  * Initializes the JNI id of a field. As per the JNI specification,
280  * this ensures the declaring class is initialized.
281  */
282 void JNIJVMCI::initialize_field_id(JNIEnv* env, jfieldID &amp;fieldid, jclass clazz, const char* class_name, const char* name, const char* signature, bool static_field) {
283   if (JVMCILibDumpJNIConfig != NULL) {
284     fileStream* st = JVMCIGlobals::get_jni_config_file();
285     st-&gt;print_cr(&quot;field %s %s %s&quot;, class_name, name, signature);
286     return;
287   }
288   if (env-&gt;ExceptionCheck()) {
289     return;
290   }
<a name="3" id="anc3"></a><span class="line-added">291   jfieldID current = fieldid;</span>
292   if (static_field) {
293     // Class initialization barrier
294     fieldid = env-&gt;GetStaticFieldID(clazz, name, signature);
295   } else {
296     // Class initialization barrier
297     fieldid = env-&gt;GetFieldID(clazz, name, signature);
298   }
<a name="4" id="anc4"></a><span class="line-added">299   JVMCI_event_2(&quot;   jfieldID for %s %s.%s = &quot; PTR_FORMAT, signature, class_name, name, p2i(fieldid));</span>
300 
301   if (env-&gt;ExceptionCheck()) {
302     env-&gt;ExceptionDescribe();
303     env-&gt;ExceptionClear();
304     ResourceMark rm;
305     Thread* THREAD = Thread::current();
306     fatal(&quot;Could not find field %s.%s with signature %s&quot;, class_name, name, signature);
307   }
308 }
309 
310 #define START_CLASS(className, fullClassName) {                                             \
311   current_class_name = vmSymbols::fullClassName()-&gt;as_C_string();                           \
312   if (JVMCILibDumpJNIConfig != NULL) {                                                      \
313     fileStream* st = JVMCIGlobals::get_jni_config_file();                                   \
314     st-&gt;print_cr(&quot;class %s&quot;, current_class_name);                                           \
315   } else {                                                                                  \
316     jclass k = env-&gt;FindClass(current_class_name);                                          \
317     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, current_class_name);                        \
318     assert(k != NULL, #fullClassName &quot; not initialized&quot;);                                   \
<a name="5" id="anc5"></a><span class="line-modified">319     k = (jclass) env-&gt;NewGlobalRef(k);                                                      \</span>
<span class="line-added">320     JVMCI_event_2(&quot; jclass for %s = &quot; PTR_FORMAT, current_class_name, p2i(k));              \</span>
<span class="line-added">321     className::_class = k;                                                                  \</span>
322   }
323 
324 #define END_CLASS current_class_name = NULL; }
325 
326 #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);
327 #define CHAR_FIELD(className, name) FIELD(className, name, &quot;C&quot;, false)
328 #define INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, false)
329 #define BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, false)
330 #define LONG_FIELD(className, name) FIELD(className, name, &quot;J&quot;, false)
331 #define FLOAT_FIELD(className, name) FIELD(className, name, &quot;F&quot;, false)
332 #define OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, false)
333 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
334 #define STATIC_INT_FIELD(className, name) FIELD(className, name, &quot;I&quot;, true)
335 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, &quot;Z&quot;, true)
336 
337 #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \
<a name="6" id="anc6"></a><span class="line-modified">338     if (JVMCILibDumpJNIConfig != NULL) {                                                       \</span>
<span class="line-modified">339       fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \</span>
<span class="line-modified">340       st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, methodName, signature);              \</span>
<span class="line-modified">341     } else {                                                                                   \</span>
<span class="line-modified">342       jmethodID current = dst;                                                                 \</span>
<span class="line-modified">343       dst = env-&gt;jniGetMethod(clazz, methodName, signature);                                   \</span>
<span class="line-modified">344       JVMCI_EXCEPTION_CHECK(env, #jniGetMethod &quot;(%s.%s%s)&quot;,                                    \</span>
<span class="line-modified">345                   current_class_name, methodName, signature);                                  \</span>
<span class="line-added">346       assert(dst != NULL, &quot;uninitialized&quot;);                                                    \</span>
<span class="line-added">347       JVMCI_event_2(&quot;   jmethodID for %s.%s%s = &quot; PTR_FORMAT,                                  \</span>
<span class="line-added">348                   current_class_name, methodName, signature, p2i(dst));                        \</span>
<span class="line-added">349     }</span>
350 
351 #define GET_JNI_CONSTRUCTOR(clazz, signature) \
352   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, &quot;&lt;init&gt;&quot;, signature) \
353 
354 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
355      GET_JNI_METHOD(jniGetMethod,                                        \
356                     className::_##methodName##_method,                   \
357                     className::clazz(),                                  \
358                     vmSymbols::methodName##_name()-&gt;as_C_string(),       \
359                     vmSymbols::signatureSymbolName()-&gt;as_C_string())
360 
361 #define CONSTRUCTOR(className, signature) \
362   GET_JNI_CONSTRUCTOR(className, signature)
363 
364 extern &quot;C&quot; {
365   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
366   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
367 }
368 
369 // Dumps symbols for public &lt;init&gt;() and &lt;init&gt;(String) methods of
370 // non-abstract Throwable subtypes known by the VM. This is to
371 // support the use of reflection in jdk.vm.ci.hotspot.TranslatedException.create().
372 class ThrowableInitDumper : public SymbolClosure {
373  private:
374   fileStream* _st;
375  public:
376   ThrowableInitDumper(fileStream* st)     { _st = st; }
377   void do_symbol(Symbol** p) {
378     Thread* THREAD = Thread::current();
379     Symbol* name = *p;
380     if (name == NULL) {
381       return;
382     }
383     Klass* k = SystemDictionary::resolve_or_null(name, CHECK_EXIT);
384     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
385       InstanceKlass* iklass = InstanceKlass::cast(k);
386       if (iklass-&gt;is_subclass_of(SystemDictionary::Throwable_klass()) &amp;&amp; iklass-&gt;is_public() &amp;&amp; !iklass-&gt;is_abstract()) {
387         const char* class_name = NULL;
388         Array&lt;Method*&gt;* methods = iklass-&gt;methods();
389         for (int i = 0; i &lt; methods-&gt;length(); i++) {
390           Method* m = methods-&gt;at(i);
391           if (m-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
392               m-&gt;is_public() &amp;&amp;
393               (m-&gt;signature() == vmSymbols::void_method_signature() || m-&gt;signature() == vmSymbols::string_void_signature())) {
394             if (class_name == NULL) {
395               class_name = name-&gt;as_C_string();
396               _st-&gt;print_cr(&quot;class %s&quot;, class_name);
397             }
398             _st-&gt;print_cr(&quot;method %s %s %s&quot;, class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string());
399           }
400         }
401       }
402     }
403   }
404 };
405 
406 #define IN_CLASS(fullClassName) current_class_name = vmSymbols::fullClassName()-&gt;as_C_string()
407 /**
408  * Initializes the JNI method and field ids used in JNIJVMCI.
409  */
410 void JNIJVMCI::initialize_ids(JNIEnv* env) {
411   ResourceMark rm;
412   const char* current_class_name = NULL;
413   JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, OBJECT_FIELD, OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECT_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
414 
415   IN_CLASS(java_lang_Class);
416   GET_JNI_METHOD(GetMethodID, _Class_getName_method, Class::_class, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
417 
418   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedPrimitiveType);
419   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedPrimitiveType_fromMetaspace_method, HotSpotResolvedPrimitiveType::_class,
420                                                                                           vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
421                                                                                           vmSymbols::primitive_fromMetaspace_signature()-&gt;as_C_string());
422   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl);
423   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedObjectTypeImpl_fromMetaspace_method, HotSpotResolvedObjectTypeImpl::_class,
424                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
425                                                                                            vmSymbols::klass_fromMetaspace_signature()-&gt;as_C_string());
426   IN_CLASS(jdk_vm_ci_hotspot_HotSpotConstantPool);
427   GET_JNI_METHOD(GetStaticMethodID, _HotSpotConstantPool_fromMetaspace_method, HotSpotConstantPool::_class,
428                                                                                   vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
429                                                                                   vmSymbols::constantPool_fromMetaspace_signature()-&gt;as_C_string());
430   IN_CLASS(jdk_vm_ci_hotspot_HotSpotResolvedJavaMethodImpl);
431   GET_JNI_METHOD(GetStaticMethodID, _HotSpotResolvedJavaMethodImpl_fromMetaspace_method, HotSpotResolvedJavaMethodImpl::_class,
432                                                                                            vmSymbols::fromMetaspace_name()-&gt;as_C_string(),
433                                                                                            vmSymbols::method_fromMetaspace_signature()-&gt;as_C_string());
434 
435 #define BOX_CLASSES(generate)     \
436   generate(Boolean, T_BOOLEAN, Z) \
437   generate(Byte, T_BYTE, B)       \
438   generate(Character, T_CHAR, C)  \
439   generate(Short, T_SHORT, S)     \
440   generate(Integer, T_INT, I)     \
441   generate(Long, T_LONG, J)       \
442   generate(Float, T_FLOAT, F)     \
443   generate(Double, T_DOUBLE, D)   \
444 
445 #define DO_BOX_CLASS(klass, basicType, type) \
446   current_class_name = &quot;java/lang/&quot; #klass;                                                                       \
447   if (JVMCILibDumpJNIConfig == NULL) {                                                                            \
448     _box_classes[basicType] = env-&gt;FindClass(&quot;java/lang/&quot; #klass);                                                \
449     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass(%s)&quot;, #klass);                                                          \
450     _box_classes[basicType] = (jclass) env-&gt;NewGlobalRef(_box_classes[basicType]);                                \
451     assert(_box_classes[basicType] != NULL, &quot;uninitialized&quot;);                                                     \
452     _box_fields[basicType] = env-&gt;GetFieldID(_box_classes[basicType], &quot;value&quot;, #type);                            \
453     JVMCI_EXCEPTION_CHECK(env, &quot;GetFieldID(%s, value, %s)&quot;, #klass, #type);                                       \
454     GET_JNI_METHOD(GetMethodID, _box_constructors[basicType], _box_classes[basicType], &quot;&lt;init&gt;&quot;, &quot;(&quot; #type &quot;)V&quot;); \
455   } else {                                                                                                        \
456     fileStream* st = JVMCIGlobals::get_jni_config_file();                                                         \
457     st-&gt;print_cr(&quot;field %s value %s&quot;, current_class_name, #type);                                                 \
458     st-&gt;print_cr(&quot;method %s &lt;init&gt; (%s)V&quot;, current_class_name, #type);                                            \
459   }
460 
461   BOX_CLASSES(DO_BOX_CLASS);
462 
463   if (JVMCILibDumpJNIConfig == NULL) {
464     _byte_array = env-&gt;FindClass(&quot;[B&quot;);
465     JVMCI_EXCEPTION_CHECK(env, &quot;FindClass([B)&quot;);
466     _byte_array = (jclass) env-&gt;NewGlobalRef(_byte_array);
467     assert(_byte_array != NULL, &quot;uninitialized&quot;);
468   } else {
469     fileStream* st = JVMCIGlobals::get_jni_config_file();
470     st-&gt;print_cr(&quot;class [B&quot;);
471   }
472 
473 #define DUMP_ALL_NATIVE_METHODS(class_symbol) do {                                                                  \
474   current_class_name = class_symbol-&gt;as_C_string();                                                                 \
475   Klass* k = SystemDictionary::resolve_or_fail(class_symbol, true, CHECK_EXIT);                                     \
476   InstanceKlass* iklass = InstanceKlass::cast(k);                                                                   \
477   Array&lt;Method*&gt;* methods = iklass-&gt;methods();                                                                      \
478   for (int i = 0; i &lt; methods-&gt;length(); i++) {                                                                     \
479     Method* m = methods-&gt;at(i);                                                                                     \
480     if (m-&gt;is_native()) {                                                                                           \
481       st-&gt;print_cr(&quot;method %s %s %s&quot;, current_class_name, m-&gt;name()-&gt;as_C_string(), m-&gt;signature()-&gt;as_C_string()); \
482     }                                                                                                               \
483   }                                                                                                                 \
484 } while(0)
485 
486   if (JVMCILibDumpJNIConfig != NULL) {
487     Thread* THREAD = Thread::current();
488     fileStream* st = JVMCIGlobals::get_jni_config_file();
489 
490     DUMP_ALL_NATIVE_METHODS(vmSymbols::jdk_vm_ci_hotspot_CompilerToVM());
491     ThrowableInitDumper dumper(st);
492     vmSymbols::symbols_do(&amp;dumper);
493 
494     st-&gt;flush();
495     tty-&gt;print_cr(&quot;Dumped JVMCI shared library JNI configuration to %s&quot;, JVMCILibDumpJNIConfig);
496     vm_exit(0);
497   }
498 
499 #undef DUMP_ALL_NATIVE_METHODS
500 #undef DO_BOX_CLASS
501 #undef BOX_CLASSES
502 #undef IN_CLASS
503 
504 #define CC (char*)  /*cast a literal from (const char*)*/
505 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(f))
<a name="7" id="anc7"></a><span class="line-added">506 }</span>
507 
<a name="8" id="anc8"></a><span class="line-modified">508 static void register_natives_for_class(JNIEnv* env, jclass clazz, const char* name, const JNINativeMethod *methods, jint nMethods) {</span>
<span class="line-modified">509   if (clazz == NULL) {</span>
<span class="line-added">510     clazz = env-&gt;FindClass(name);</span>
511     if (env-&gt;ExceptionCheck()) {
512       env-&gt;ExceptionDescribe();
<a name="9" id="anc9"></a><span class="line-modified">513       fatal(&quot;Could not find class %s&quot;, name);</span>








514     }
<a name="10" id="anc10"></a><span class="line-added">515   }</span>
<span class="line-added">516   env-&gt;RegisterNatives(clazz, methods, nMethods);</span>
<span class="line-added">517   if (env-&gt;ExceptionCheck()) {</span>
<span class="line-added">518     env-&gt;ExceptionDescribe();</span>
<span class="line-added">519     fatal(&quot;Failure registering natives for %s&quot;, name);</span>
<span class="line-added">520   }</span>
<span class="line-added">521 }</span>
522 
<a name="11" id="anc11"></a><span class="line-modified">523 void JNIJVMCI::register_natives(JNIEnv* env) {</span>
<span class="line-modified">524   if (env != JavaThread::current()-&gt;jni_environment()) {</span>
<span class="line-modified">525     JNINativeMethod CompilerToVM_nmethods[] = {{ CC&quot;registerNatives&quot;, CC&quot;()V&quot;, FN_PTR(JVM_RegisterJVMCINatives) }};</span>
<span class="line-modified">526     JNINativeMethod JVMCI_nmethods[] = {{ CC&quot;initializeRuntime&quot;,   CC&quot;()Ljdk/vm/ci/runtime/JVMCIRuntime;&quot;, FN_PTR(JVM_GetJVMCIRuntime) }};</span>
<span class="line-modified">527 </span>
<span class="line-modified">528     register_natives_for_class(env, NULL, &quot;jdk/vm/ci/hotspot/CompilerToVM&quot;, CompilerToVM_nmethods, 1);</span>
<span class="line-modified">529     register_natives_for_class(env, JVMCI::clazz(), &quot;jdk/vm/ci/runtime/JVMCI&quot;, JVMCI_nmethods, 1);</span>

530   }
531 }
532 
533 #undef METHOD
534 #undef CONSTRUCTOR
535 #undef FIELD2
536 
537 #define EMPTY0
538 #define EMPTY1(x)
539 #define EMPTY2(x,y)
540 #define FIELD3(className, name, sig) FIELD2(className, name)
541 #define FIELD2(className, name) \
542   jfieldID JNIJVMCI::className::_##name##_field_id = 0; \
543   int HotSpotJVMCI::className::_##name##_offset = 0;
544 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
545 #define CONSTRUCTOR(className, signature)
546 
547 // Generates the definitions of static fields used by the accessors. For example:
548 //  jfieldID JNIJVMCI::Architecture::_wordKind_field_id = 0;
549 //  jfieldID HotSpotJVMCI::Architecture::_wordKind_offset = 0;
550 JVMCI_CLASSES_DO(EMPTY2, EMPTY0, FIELD2, FIELD2, FIELD2, FIELD2, FIELD2, FIELD3, FIELD3, FIELD3, FIELD3, FIELD3, FIELD2, FIELD2, METHOD, CONSTRUCTOR)
551 
552 #undef START_CLASS
553 #undef END_CLASS
554 #undef METHOD
555 #undef CONSTRUCTOR
556 #undef FIELD
557 #undef CHAR_FIELD
558 #undef INT_FIELD
559 #undef BOOLEAN_FIELD
560 #undef LONG_FIELD
561 #undef FLOAT_FIELD
562 #undef OBJECT_FIELD
563 #undef PRIMARRAY_FIELD
564 #undef OBJECTARRAY_FIELD
565 #undef STATIC_FIELD
566 #undef STATIC_OBJECT_FIELD
567 #undef STATIC_OBJECTARRAY_FIELD
568 #undef STATIC_INT_FIELD
569 #undef STATIC_BOOLEAN_FIELD
570 #undef EMPTY_CAST
571 
572 
573 #define START_CLASS(className, fullClassName)                                                                                     \
574   void JNIJVMCI::className::initialize(JVMCI_TRAPS) {                                                                             \
575     /* should already be initialized */                                                                                           \
576   }                                                                                                                               \
577   bool JNIJVMCI::className::is_instance(JVMCIEnv* jvmciEnv, JVMCIObject object) {                                                 \
578     JNIAccessMark jni(jvmciEnv);                                                                                                  \
579     return jni()-&gt;IsInstanceOf(object.as_jobject(), className::clazz()) != 0;                                                     \
580   }                                                                                                                               \
581   void JNIJVMCI::className::check(JVMCIEnv* jvmciEnv, JVMCIObject obj, const char* field_name, jfieldID offset) {                 \
582     assert(obj.is_non_null(), &quot;NULL field access of %s.%s&quot;, #className, field_name);                                     \
583     assert(jvmciEnv-&gt;isa_##className(obj), &quot;wrong class, &quot; #className &quot; expected, found %s&quot;, jvmciEnv-&gt;klass_name(obj)); \
584     assert(offset != 0, &quot;must be valid offset&quot;);                                                                                  \
585   }                                                                                                                               \
586   jclass JNIJVMCI::className::_class = NULL;
587 
588 #define END_CLASS
589 
590 #define FIELD(className, name, type, accessor, cast)                                                                \
591   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                                       \
592    className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                           \
593    JNIAccessMark jni(jvmciEnv);                               \
594    return cast jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id); \
595   }                                                                                                                 \
596   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                               \
597     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                                          \
598     JNIAccessMark jni(jvmciEnv); \
599     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, x);         \
600   } \
601 
602 #define EMPTY_CAST
603 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
604 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
605 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
606 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
607 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
608 
609 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
610 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
611 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
612 
613 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
614 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
615 
616 #define OOPISH_FIELD(className, name, type, accessor, cast)                                             \
617   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj) {                           \
618     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \
619     JNIAccessMark jni(jvmciEnv);                                                                        \
620     return cast wrap(jni()-&gt;Get##accessor##Field(resolve_handle(obj), className::_##name##_field_id));  \
621   }                                                                                                     \
622   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, JVMCIObject obj, type x) {                   \
623     className::check(jvmciEnv, obj, #name, className::_##name##_field_id);                              \
624     JNIAccessMark jni(jvmciEnv);                                                                        \
625     jni()-&gt;Set##accessor##Field(resolve_handle(obj), className::_##name##_field_id, resolve_handle(x)); \
626   }
627 
628 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)                                      \
629   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \
630     JNIAccessMark jni(jvmciEnv);                                                                        \
631     return cast wrap(jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id));  \
632   }                                                                                                     \
633   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \
634     JNIAccessMark jni(jvmciEnv);                                                                        \
635     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, resolve_handle(x)); \
636   }
637 
638 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast)                                   \
639   type JNIJVMCI::className::get_##name(JVMCIEnv* jvmciEnv) {                                            \
640     JNIAccessMark jni(jvmciEnv);                                                                        \
641     return cast jni()-&gt;GetStatic##accessor##Field(className::clazz(), className::_##name##_field_id);   \
642   }                                                                                                     \
643   void JNIJVMCI::className::set_##name(JVMCIEnv* jvmciEnv, type x) {                                    \
644     JNIAccessMark jni(jvmciEnv);                                                                        \
645     jni()-&gt;SetStatic##accessor##Field(className::clazz(), className::_##name##_field_id, x);            \
646   }
647 
648 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
649 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
650 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
651   jmethodID JNIJVMCI::className::_##methodName##_method;
652 
653 #define CONSTRUCTOR(className, signature) \
654   jmethodID JNIJVMCI::className::_constructor;
655 
656 /**
657  * Generates the method definitions for the classes in HotSpotJVMCI.
658  */
659 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
660 
661 #undef METHOD
662 #undef CONSTRUCTOR
663 #undef START_CLASS
664 #undef END_CLASS
665 #undef FIELD
666 #undef CHAR_FIELD
667 #undef INT_FIELD
668 #undef BOOLEAN_FIELD
669 #undef LONG_FIELD
670 #undef FLOAT_FIELD
671 #undef OBJECT_FIELD
672 #undef PRIMARRAY_FIELD
673 #undef OBJECTARRAY_FIELD
674 #undef STATIC_OOPISH_FIELD
675 #undef STATIC_OBJECT_FIELD
676 #undef STATIC_OBJECTARRAY_FIELD
677 #undef STATIC_INT_FIELD
678 #undef STATIC_BOOLEAN_FIELD
679 #undef STATIC_PRIMITIVE_FIELD
680 #undef OOPISH_FIELD
681 #undef EMPTY_CAST
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>