<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/stringTable.hpp&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;compiler/compileTask.hpp&quot;
  30 #include &quot;memory/oopFactory.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/objArrayKlass.hpp&quot;
  34 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  35 #include &quot;runtime/deoptimization.hpp&quot;
  36 #include &quot;runtime/jniHandles.inline.hpp&quot;
  37 #include &quot;runtime/javaCalls.hpp&quot;
  38 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  39 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  40 
  41 JVMCICompileState::JVMCICompileState(CompileTask* task):
  42   _task(task),
  43   _retryable(true),
  44   _failure_reason(NULL),
  45   _failure_reason_on_C_heap(false) {
  46   // Get Jvmti capabilities under lock to get consistent values.
  47   MutexLocker mu(JvmtiThreadState_lock);
  48   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
  49   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
  50   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
  51   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
  52   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  53   _target_method_is_old                 = _task != NULL &amp;&amp; _task-&gt;method()-&gt;is_old();
  54 }
  55 
  56 bool JVMCICompileState::jvmti_state_changed() const {
  57   // Some classes were redefined
  58   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
  59     return true;
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
  80 void JVMCIEnv::copy_saved_properties() {
  81   assert(!is_hotspot(), &quot;can only copy saved properties from HotSpot to native image&quot;);
  82 
  83   JavaThread* THREAD = JavaThread::current();
  84 
  85   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  86   if (HAS_PENDING_EXCEPTION) {
  87     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  88   }
  89   InstanceKlass* ik = InstanceKlass::cast(k);
  90   if (ik-&gt;should_be_initialized()) {
  91     ik-&gt;initialize(THREAD);
  92     if (HAS_PENDING_EXCEPTION) {
  93       JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  94     }
  95   }
  96 
  97   // Get the serialized saved properties from HotSpot
  98   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(&quot;serializeSavedProperties&quot;);
  99   JavaValue result(T_OBJECT);
 100   JavaCallArguments args;
 101   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);
 102   if (HAS_PENDING_EXCEPTION) {
 103     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error calling jdk.vm.ci.services.Services.serializeSavedProperties&quot;);
 104   }
 105   oop res = (oop) result.get_jobject();
 106   assert(res-&gt;is_typeArray(), &quot;must be&quot;);
 107   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;must be&quot;);
 108   typeArrayOop ba = typeArrayOop(res);
 109   int serialized_properties_len = ba-&gt;length();
 110 
 111   // Copy serialized saved properties from HotSpot object into native buffer
 112   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 113   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 114 
 115   // Copy native buffer into shared library object
 116   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 117   if (has_pending_exception()) {
 118     describe_pending_exception(true);
 119     fatal(&quot;Error in copy_saved_properties&quot;);
 120   }
 121   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 122   if (has_pending_exception()) {
 123     describe_pending_exception(true);
 124     fatal(&quot;Error in copy_saved_properties&quot;);
 125   }
 126 
 127   // Initialize saved properties in shared library
 128   jclass servicesClass = JNIJVMCI::Services::clazz();
 129   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
 130   JNIAccessMark jni(this, THREAD);
 131   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 132   if (jni()-&gt;ExceptionCheck()) {
 133     jni()-&gt;ExceptionDescribe();
 134     fatal(&quot;Error calling jdk.vm.ci.services.Services.initializeSavedProperties&quot;);
 135   }
 136 }
 137 
 138 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 139   assert(thread != NULL, &quot;npe&quot;);
 140   _env = NULL;
 141   _pop_frame_on_close = false;
 142   _detach_on_close = false;
 143   if (!UseJVMCINativeLibrary) {
 144     // In HotSpot mode, JNI isn&#39;t used at all.
 145     _runtime = JVMCI::java_runtime();
 146     _is_hotspot = true;
 147     return;
 148   }
 149 
 150   if (parent_env != NULL) {
 151     // If the parent JNI environment is non-null then figure out whether it
 152     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 153     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 154     if (_is_hotspot) {
 155       // Select the Java runtime
 156       _runtime = JVMCI::java_runtime();
 157       return;
 158     }
 159     _runtime = JVMCI::compiler_runtime();
 160     assert(_runtime != NULL, &quot;npe&quot;);
 161     _env = parent_env;
 162     return;
 163   }
 164 
 165   // Running in JVMCI shared library mode so ensure the shared library
 166   // is loaded and initialized and get a shared library JNIEnv
 167   _is_hotspot = false;
 168 
 169   _runtime = JVMCI::compiler_runtime();
 170   _env = _runtime-&gt;init_shared_library_javavm();
 171 
 172   if (_env != NULL) {
 173     // Creating the JVMCI shared library VM also attaches the current thread
 174     _detach_on_close = true;
 175   } else {
 176     _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);
 177     if (parent_env != NULL) {
 178       // Even though there&#39;s a parent JNI env, there&#39;s no guarantee
 179       // it was opened by a JVMCIEnv scope and thus may not have
 180       // pushed a local JNI frame. As such, we use a new JNI local
 181       // frame in this scope to ensure local JNI refs are collected
 182       // in a timely manner after leaving this scope.
 183       _env = parent_env;
 184     } else {
 185       ResourceMark rm; // Thread name is resource allocated
 186       JavaVMAttachArgs attach_args;
 187       attach_args.version = JNI_VERSION_1_2;
 188       attach_args.name = thread-&gt;name();
 189       attach_args.group = NULL;
 190       if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {
 191         fatal(&quot;Error attaching current thread (%s) to JVMCI shared library JNI interface&quot;, attach_args.name);
 192       }
 193       _detach_on_close = true;
 194     }
 195   }
 196 
 197   assert(_env != NULL, &quot;missing env&quot;);
 198   assert(_throw_to_caller == false, &quot;must be&quot;);
 199 
 200   JNIAccessMark jni(this, thread);
 201   jint result = _env-&gt;PushLocalFrame(32);
 202   if (result != JNI_OK) {
 203     char message[256];
 204     jio_snprintf(message, 256, &quot;Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 205     JVMCIRuntime::exit_on_pending_exception(this, message);
 206   }
 207   _pop_frame_on_close = true;
 208 }
 209 
 210 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 211     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 212   init_env_mode_runtime(thread, NULL);
 213 }
 214 
 215 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 216     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 217   init_env_mode_runtime(thread, NULL);
 218 }
 219 
 220 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):
 221     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {
 222   init_env_mode_runtime(thread, parent_env);
 223   assert(_env == NULL || parent_env == _env, &quot;mismatched JNIEnvironment&quot;);
 224 }
 225 
 226 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 227   _compile_state = NULL;
 228   _throw_to_caller = false;
 229   _file = file;
 230   _line = line;
 231   if (is_hotspot) {
 232     _env = NULL;
 233     _pop_frame_on_close = false;
 234     _detach_on_close = false;
 235     _is_hotspot = true;
 236     _runtime = JVMCI::java_runtime();
 237   } else {
 238     init_env_mode_runtime(thread, NULL);
 239   }
 240 }
 241 
 242 // Prints a pending exception (if any) and its stack trace.
 243 void JVMCIEnv::describe_pending_exception(bool clear) {
 244   Thread* THREAD = Thread::current();
 245   if (!is_hotspot()) {
 246     JNIAccessMark jni(this);
 247     if (jni()-&gt;ExceptionCheck()) {
 248       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 249       jni()-&gt;ExceptionDescribe();
 250       if (ex != NULL) {
 251         jni()-&gt;Throw(ex);
 252       }
 253     }
 254   } else {
 255     if (HAS_PENDING_EXCEPTION) {
 256       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 257     }
 258   }
 259 }
 260 
 261 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 262   assert(!is_hotspot(), &quot;must_be&quot;);
 263   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 264   // may not have been called.
 265   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 266   JavaCallArguments jargs;
 267   jargs.push_oop(throwable);
 268   JavaValue result(T_OBJECT);
 269   JavaCalls::call_static(&amp;result,
 270                           runtimeKlass,
 271                           vmSymbols::encodeThrowable_name(),
 272                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 273   if (HAS_PENDING_EXCEPTION) {
 274     JVMCIRuntime::exit_on_pending_exception(this, &quot;HotSpotJVMCIRuntime.encodeThrowable should not throw an exception&quot;);
 275   }
 276 
 277   oop encoded_throwable_string = (oop) result.get_jobject();
 278 
 279   ResourceMark rm;
 280   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 281 
 282   JNIAccessMark jni(this, THREAD);
 283   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 284   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 285                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 286                                 jni_encoded_throwable_string);
 287   jni()-&gt;Throw(jni_throwable);
 288 }
 289 
 290 JVMCIEnv::~JVMCIEnv() {
 291   if (_throw_to_caller) {
 292     if (is_hotspot()) {
 293       // Nothing to do
 294     } else {
 295       if (Thread::current()-&gt;is_Java_thread()) {
 296         JavaThread* THREAD = JavaThread::current();
 297         if (HAS_PENDING_EXCEPTION) {
 298           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 299           CLEAR_PENDING_EXCEPTION;
 300           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 301         }
 302       }
 303     }
 304   } else {
 305     if (_pop_frame_on_close) {
 306       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 307       JNIAccessMark jni(this);
 308       jni()-&gt;PopLocalFrame(NULL);
 309     }
 310 
 311     if (has_pending_exception()) {
 312       char message[256];
 313       jio_snprintf(message, 256, &quot;Uncaught exception exiting JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 314       JVMCIRuntime::exit_on_pending_exception(this, message);
 315     }
 316 
 317     if (_detach_on_close) {
 318       _runtime-&gt;DetachCurrentThread(JavaThread::current());
 319     }
 320   }
 321 }
 322 
 323 jboolean JVMCIEnv::has_pending_exception() {
 324   if (is_hotspot()) {
 325     Thread* THREAD = Thread::current();
 326     return HAS_PENDING_EXCEPTION;
 327   } else {
 328     JNIAccessMark jni(this);
 329     return jni()-&gt;ExceptionCheck();
 330   }
 331 }
 332 
 333 void JVMCIEnv::clear_pending_exception() {
 334   if (is_hotspot()) {
 335     Thread* THREAD = Thread::current();
 336     CLEAR_PENDING_EXCEPTION;
 337   } else {
 338     JNIAccessMark jni(this);
 339     jni()-&gt;ExceptionClear();
 340   }
 341 }
 342 
 343 int JVMCIEnv::get_length(JVMCIArray array) {
 344   if (is_hotspot()) {
 345     return HotSpotJVMCI::resolve(array)-&gt;length();
 346   } else {
 347     JNIAccessMark jni(this);
 348     return jni()-&gt;GetArrayLength(get_jarray(array));
 349   }
 350 }
 351 
 352 JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {
 353   if (is_hotspot()) {
 354     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);
 355     return wrap(result);
 356   } else {
 357     JNIAccessMark jni(this);
 358     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);
 359     return wrap(result);
 360   }
 361 }
 362 
 363 void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {
 364   if (is_hotspot()) {
 365     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));
 366   } else {
 367     JNIAccessMark jni(this);
 368     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));
 369   }
 370 }
 371 
 372 jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {
 373   if (is_hotspot()) {
 374     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);
 375   } else {
 376     JNIAccessMark jni(this);
 377     jboolean result;
 378     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);
 379     return result;
 380   }
 381 }
 382 void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {
 383   if (is_hotspot()) {
 384     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);
 385   } else {
 386     JNIAccessMark jni(this);
 387     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);
 388   }
 389 }
 390 
 391 jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {
 392   if (is_hotspot()) {
 393     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);
 394   } else {
 395     JNIAccessMark jni(this);
 396     jbyte result;
 397     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);
 398     return result;
 399   }
 400 }
 401 void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {
 402   if (is_hotspot()) {
 403     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);
 404   } else {
 405     JNIAccessMark jni(this);
 406     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);
 407   }
 408 }
 409 
 410 jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {
 411   if (is_hotspot()) {
 412     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);
 413   } else {
 414     JNIAccessMark jni(this);
 415     jint result;
 416     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);
 417     return result;
 418   }
 419 }
 420 void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {
 421   if (is_hotspot()) {
 422     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);
 423   } else {
 424     JNIAccessMark jni(this);
 425     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);
 426   }
 427 }
 428 
 429 long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {
 430   if (is_hotspot()) {
 431     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);
 432   } else {
 433     JNIAccessMark jni(this);
 434     jlong result;
 435     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);
 436     return result;
 437   }
 438 }
 439 void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {
 440   if (is_hotspot()) {
 441     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);
 442   } else {
 443     JNIAccessMark jni(this);
 444     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);
 445   }
 446 }
 447 
 448 void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {
 449   if (length == 0) {
 450     return;
 451   }
 452   if (is_hotspot()) {
 453     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);
 454   } else {
 455     JNIAccessMark jni(this);
 456     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);
 457   }
 458 }
 459 void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 460   if (length == 0) {
 461     return;
 462   }
 463   if (is_hotspot()) {
 464     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);
 465   } else {
 466     JNIAccessMark jni(this);
 467     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);
 468   }
 469 }
 470 
 471 void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 472   if (length == 0) {
 473     return;
 474   }
 475   if (is_hotspot()) {
 476     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));
 477   } else {
 478     JNIAccessMark jni(this);
 479     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);
 480   }
 481 }
 482 
 483 jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {
 484   if (is_hotspot()) {
 485     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);
 486   } else {
 487     JNIAccessMark jni(this);
 488     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));
 489   }
 490 }
 491 
 492 // Get the primitive value from a Java boxing object.  It&#39;s hard error to
 493 // pass a non-primitive BasicType.
 494 jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {
 495   jvalue result;
 496   if (is_hotspot()) {
 497     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {
 498       ShouldNotReachHere();
 499     }
 500   } else {
 501     JNIAccessMark jni(this);
 502     jfieldID field = JNIJVMCI::box_field(type);
 503     switch (type) {
 504       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;
 505       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;
 506       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;
 507       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;
 508       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;
 509       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;
 510       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;
 511       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;
 512       default:
 513         ShouldNotReachHere();
 514     }
 515   }
 516   return result;
 517 }
 518 
 519 // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.
 520 BasicType JVMCIEnv::get_box_type(JVMCIObject object) {
 521   if (is_hotspot()) {
 522     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));
 523   } else {
 524     JNIAccessMark jni(this);
 525     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));
 526     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;
 527     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;
 528     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;
 529     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;
 530     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;
 531     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;
 532     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;
 533     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 534     return T_ILLEGAL;
 535   }
 536 }
 537 
 538 // Create a boxing object of the appropriate primitive type.
 539 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 540   switch (type) {
 541     case T_BOOLEAN:
 542     case T_BYTE:
 543     case T_CHAR:
 544     case T_SHORT:
 545     case T_INT:
 546     case T_LONG:
 547     case T_FLOAT:
 548     case T_DOUBLE:
 549       break;
 550     default:
 551       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;Only boxes for primitive values can be created&quot;, JVMCIObject());
 552   }
 553   JavaThread* THREAD = JavaThread::current();
 554   if (is_hotspot()) {
 555     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 556     return HotSpotJVMCI::wrap(box);
 557   } else {
 558     JNIAccessMark jni(this, THREAD);
 559     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 560     assert(box != NULL, &quot;&quot;);
 561     return wrap(box);
 562   }
 563 }
 564 
 565 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 566   if (is_hotspot()) {
 567     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 568   } else {
 569     JNIAccessMark jni(this);
 570     int length = jni()-&gt;GetStringLength(str.as_jstring());
 571     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 572     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 573     return result;
 574   }
 575 }
 576 
 577 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 578   if (is_hotspot()) {
 579     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str), buf, buflen);
 580   } else {
 581     JNIAccessMark jni(this);
 582     int length = jni()-&gt;GetStringLength(str.as_jstring());
 583     if (length &gt;= buflen) {
 584       length = buflen;
 585     }
 586     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, buf);
 587     return buf;
 588   }
 589 }
 590 
 591 #define DO_THROW(name)                             \
 592 void JVMCIEnv::throw_##name(const char* msg) {     \
 593   if (is_hotspot()) {                              \
 594     JavaThread* THREAD = JavaThread::current();    \
 595     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \
 596   } else {                                         \
 597     JNIAccessMark jni(this);                       \
 598     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \
 599   }                                                \
 600 }
 601 
 602 DO_THROW(InternalError)
 603 DO_THROW(ArrayIndexOutOfBoundsException)
 604 DO_THROW(IllegalStateException)
 605 DO_THROW(NullPointerException)
 606 DO_THROW(IllegalArgumentException)
 607 DO_THROW(InvalidInstalledCodeException)
 608 DO_THROW(UnsatisfiedLinkError)
 609 DO_THROW(UnsupportedOperationException)
 610 DO_THROW(ClassNotFoundException)
 611 
 612 #undef DO_THROW
 613 
 614 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 615   const int max_msg_size = 1024;
 616   va_list ap;
 617   va_start(ap, format);
 618   char msg[max_msg_size];
 619   vsnprintf(msg, max_msg_size, format, ap);
 620   msg[max_msg_size-1] = &#39;\0&#39;;
 621   va_end(ap);
 622   JavaThread* THREAD = JavaThread::current();
 623   if (is_hotspot()) {
 624     Handle h_loader = Handle();
 625     Handle h_protection_domain = Handle();
 626     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 627   } else {
 628     JNIAccessMark jni(this, THREAD);
 629     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 630   }
 631 }
 632 
 633 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 634                                                               jlong compile_state, int id) {
 635   if (is_hotspot()) {
 636     Thread* THREAD = Thread::current();
 637     JavaCallArguments jargs;
 638     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 639     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 640     jargs.push_int(entry_bci);
 641     jargs.push_long(compile_state);
 642     jargs.push_int(id);
 643     JavaValue result(T_OBJECT);
 644     JavaCalls::call_special(&amp;result,
 645                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 646                             vmSymbols::compileMethod_name(),
 647                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 648     return wrap((oop) result.get_jobject());
 649   } else {
 650     JNIAccessMark jni(this);
 651     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),
 652                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 653                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),
 654                                                      method.as_jobject(), entry_bci, compile_state, id);
 655     if (jni()-&gt;ExceptionCheck()) {
 656       return JVMCIObject();
 657     }
 658     return wrap(result);
 659   }
 660 }
 661 
 662 void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 663   if (is_hotspot()) {
 664     Thread* THREAD = Thread::current();
 665     JavaCallArguments jargs;
 666     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 667     JavaValue result(T_VOID);
 668     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 669   } else {
 670     JNIAccessMark jni(this);
 671     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 672 
 673   }
 674 }
 675 
 676 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 677   HandleMark hm;
 678   JavaThread* THREAD = JavaThread::current();
 679   if (is_hotspot()) {
 680     JavaCallArguments jargs;
 681     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 682     JavaValue result(T_VOID);
 683     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 684   } else {
 685     JNIAccessMark jni(this, THREAD);
 686     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 687   }
 688   if (has_pending_exception()) {
 689     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 690     // handle all exceptions.
 691     describe_pending_exception(true);
 692   }
 693 }
 694 
 695 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 696   JavaThread* THREAD = JavaThread::current();
 697   if (is_hotspot()) {
 698     JavaCallArguments jargs;
 699     JavaValue result(T_OBJECT);
 700     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());
 702   } else {
 703     JNIAccessMark jni(this, THREAD);
 704     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 705     if (jni()-&gt;ExceptionCheck()) {
 706       return JVMCIObject();
 707     }
 708     return wrap(result);
 709   }
 710 }
 711 
 712 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 713   JavaThread* THREAD = JavaThread::current();
 714   if (is_hotspot()) {
 715     JavaCallArguments jargs;
 716     JavaValue result(T_OBJECT);
 717     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 718     return wrap((oop) result.get_jobject());
 719   } else {
 720     JNIAccessMark jni(this, THREAD);
 721     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 722     if (jni()-&gt;ExceptionCheck()) {
 723       return JVMCIObject();
 724     }
 725     return wrap(result);
 726   }
 727 }
 728 
 729 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 730   JavaThread* THREAD = JavaThread::current();
 731   if (is_hotspot()) {
 732     JavaCallArguments jargs;
 733     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 734     JavaValue result(T_OBJECT);
 735     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 736     return wrap((oop) result.get_jobject());
 737   } else {
 738     JNIAccessMark jni(this, THREAD);
 739     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 740     if (jni()-&gt;ExceptionCheck()) {
 741       return JVMCIObject();
 742     }
 743     return wrap(result);
 744   }
 745 }
 746 
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 753     JavaValue result(T_OBJECT);
 754     JavaCalls::call_static(&amp;result,
 755                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 756                            vmSymbols::callToString_name(),
 757                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 758     return wrap((oop) result.get_jobject());
 759   } else {
 760     JNIAccessMark jni(this, THREAD);
 761     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 762                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 763                                                      object.as_jobject());
 764     if (jni()-&gt;ExceptionCheck()) {
 765       return JVMCIObject();
 766     }
 767     return wrap(result);
 768   }
 769 }
 770 
 771 
 772 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 773   JavaThread* THREAD = JavaThread::current();
 774   if (is_hotspot()) {
 775     JavaCallArguments jargs;
 776     jargs.push_int(kind);
 777     jargs.push_long(value);
 778     JavaValue result(T_OBJECT);
 779     JavaCalls::call_static(&amp;result,
 780                            HotSpotJVMCI::PrimitiveConstant::klass(),
 781                            vmSymbols::forTypeChar_name(),
 782                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 783     return wrap((oop) result.get_jobject());
 784   } else {
 785     JNIAccessMark jni(this, THREAD);
 786     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 787                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 788                                                      kind, value);
 789     if (jni()-&gt;ExceptionCheck()) {
 790       return JVMCIObject();
 791     }
 792     return wrap(result);
 793   }
 794 }
 795 
 796 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 797   JavaThread* THREAD = JavaThread::current();
 798   if (is_hotspot()) {
 799     JavaCallArguments jargs;
 800     jargs.push_float(value);
 801     JavaValue result(T_OBJECT);
 802     JavaCalls::call_static(&amp;result,
 803                            HotSpotJVMCI::JavaConstant::klass(),
 804                            vmSymbols::forFloat_name(),
 805                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 806     return wrap((oop) result.get_jobject());
 807   } else {
 808     JNIAccessMark jni(this, THREAD);
 809     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 810                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 811                                                      value);
 812     if (jni()-&gt;ExceptionCheck()) {
 813       return JVMCIObject();
 814     }
 815     return wrap(result);
 816   }
 817 }
 818 
 819 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 820   JavaThread* THREAD = JavaThread::current();
 821   if (is_hotspot()) {
 822     JavaCallArguments jargs;
 823     jargs.push_double(value);
 824     JavaValue result(T_OBJECT);
 825     JavaCalls::call_static(&amp;result,
 826                            HotSpotJVMCI::JavaConstant::klass(),
 827                            vmSymbols::forDouble_name(),
 828                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 829     return wrap((oop) result.get_jobject());
 830   } else {
 831     JNIAccessMark jni(this, THREAD);
 832     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 833                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 834                                                      value);
 835     if (jni()-&gt;ExceptionCheck()) {
 836       return JVMCIObject();
 837     }
 838     return wrap(result);
 839   }
 840 }
 841 
 842 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 843   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 844   JVMCIObject result = get_object_at(primitives, type);
 845   return result;
 846 }
 847 
 848 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 849   JavaThread* THREAD = JavaThread::current();
 850   Symbol* file_name_sym;
 851   int line_number;
 852   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));
 853 
 854   Symbol* method_name_sym = method-&gt;name();
 855   InstanceKlass* holder = method-&gt;method_holder();
 856   const char* declaring_class_str = holder-&gt;external_name();
 857 
 858   if (is_hotspot()) {
 859     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 860     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 861     Handle obj = Handle(THREAD, objOop);
 862 
 863     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 864     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 865 
 866     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 867     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 868 
 869     if (file_name_sym != NULL) {
 870       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 871       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 872     }
 873     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 874     return wrap(obj());
 875   } else {
 876     JNIAccessMark jni(this, THREAD);
 877     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 878     if (jni()-&gt;ExceptionCheck()) {
 879       return JVMCIObject();
 880     }
 881     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 882     if (jni()-&gt;ExceptionCheck()) {
 883       return JVMCIObject();
 884     }
 885     jobject file_name = NULL;
 886     if (file_name_sym != NULL) {
 887       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 888       if (jni()-&gt;ExceptionCheck()) {
 889         return JVMCIObject();
 890       }
 891     }
 892 
 893     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 894                                       JNIJVMCI::StackTraceElement::constructor(),
 895                                       declaring_class, method_name, file_name, line_number);
 896     return wrap(result);
 897   }
 898 }
 899 
 900 JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {
 901   JavaThread* THREAD = JavaThread::current();
 902 
 903   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));
 904 
 905   if (is_hotspot()) {
 906     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());
 907     if (ik-&gt;should_be_initialized()) {
 908       ik-&gt;initialize(CHECK_(JVMCIObject()));
 909     }
 910     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 911     Handle obj_h(THREAD, obj);
 912     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 913 
 914     // Call constructor
 915     JavaCallArguments jargs;
 916     jargs.push_oop(obj_h);
 917     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 918     jargs.push_oop(nameStr);
 919     jargs.push_int(isDefault);
 920     jargs.push_long(compileId);
 921     JavaValue result(T_VOID);
 922     JavaCalls::call_special(&amp;result, ik,
 923                             vmSymbols::object_initializer_name(),
 924                             vmSymbols::method_string_bool_long_signature(),
 925                             &amp;jargs, CHECK_(JVMCIObject()));
 926     return wrap(obj_h());
 927   } else {
 928     JNIAccessMark jni(this, THREAD);
 929     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 930     if (jni()-&gt;ExceptionCheck()) {
 931       return JVMCIObject();
 932     }
 933 
 934     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 935                                       JNIJVMCI::HotSpotNmethod::constructor(),
 936                                       methodObject.as_jobject(), nameStr, isDefault);
 937     return wrap(result);
 938   }
 939 }
 940 
 941 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 942   if (object.is_null()) {
 943     return JVMCIObject();
 944   }
 945   if (is_hotspot()) {
 946     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
 947   } else {
 948     JNIAccessMark jni(this);
 949     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
 950   }
 951 }
 952 
 953 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
 954   if (object.is_null()) {
 955     return JVMCIObject();
 956   }
 957   if (is_hotspot()) {
 958     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
 959   } else {
 960     JNIAccessMark jni(this);
 961     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
 962   }
 963 }
 964 
 965 void JVMCIEnv::destroy_local(JVMCIObject object) {
 966   if (is_hotspot()) {
 967     JNIHandles::destroy_local(object.as_jobject());
 968   } else {
 969     JNIAccessMark jni(this);
 970     jni()-&gt;DeleteLocalRef(object.as_jobject());
 971   }
 972 }
 973 
 974 void JVMCIEnv::destroy_global(JVMCIObject object) {
 975   if (is_hotspot()) {
 976     JNIHandles::destroy_global(object.as_jobject());
 977   } else {
 978     JNIAccessMark jni(this);
 979     jni()-&gt;DeleteGlobalRef(object.as_jobject());
 980   }
 981 }
 982 
 983 const char* JVMCIEnv::klass_name(JVMCIObject object) {
 984   if (is_hotspot()) {
 985     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
 986   } else {
 987     JVMCIObject name;
 988     {
 989       JNIAccessMark jni(this);
 990       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
 991       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
 992       name = JVMCIObject::create(result, is_hotspot());
 993     }
 994     return as_utf8_string(name);
 995   }
 996 }
 997 
 998 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
 999   JVMCIObject method_object;
1000   if (method() == NULL) {
1001     return method_object;
1002   }
1003 
1004   Thread* THREAD = Thread::current();
1005   jmetadata handle = _runtime-&gt;allocate_handle(method);
1006   jboolean exception = false;
1007   if (is_hotspot()) {
1008     JavaValue result(T_OBJECT);
1009     JavaCallArguments args;
1010     args.push_long((jlong) handle);
1011     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1012                            vmSymbols::fromMetaspace_name(),
1013                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1014     if (HAS_PENDING_EXCEPTION) {
1015       exception = true;
1016     } else {
1017       method_object = wrap((oop)result.get_jobject());
1018     }
1019   } else {
1020     JNIAccessMark jni(this);
1021     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1022                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1023                                                                   (jlong) handle));
1024     exception = jni()-&gt;ExceptionCheck();
1025   }
1026 
1027   if (exception) {
1028     _runtime-&gt;release_handle(handle);
1029     return JVMCIObject();
1030   }
1031 
1032   assert(asMethod(method_object) == method(), &quot;must be&quot;);
1033   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
1034     _runtime-&gt;release_handle(handle);
1035   }
1036   assert(!method_object.is_null(), &quot;must be&quot;);
1037   return method_object;
1038 }
1039 
1040 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1041   JVMCIObject type;
1042   if (klass.is_null()) {
1043     return type;
1044   }
1045 
1046   jlong pointer = (jlong) klass();
1047   JavaThread* THREAD = JavaThread::current();
1048   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1049   jboolean exception = false;
1050   if (is_hotspot()) {
1051     JavaValue result(T_OBJECT);
1052     JavaCallArguments args;
1053     args.push_long(pointer);
1054     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1055     JavaCalls::call_static(&amp;result,
1056                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1057                            vmSymbols::fromMetaspace_name(),
1058                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1059 
1060     if (HAS_PENDING_EXCEPTION) {
1061       exception = true;
1062     } else {
1063       type = wrap((oop)result.get_jobject());
1064     }
1065   } else {
1066     JNIAccessMark jni(this, THREAD);
1067 
1068     HandleMark hm(THREAD);
1069     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1070                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1071                                                         pointer, signature.as_jstring()));
1072     exception = jni()-&gt;ExceptionCheck();
1073   }
1074   if (exception) {
1075     return JVMCIObject();
1076   }
1077 
1078   assert(type.is_non_null(), &quot;must have result&quot;);
1079   return type;
1080 }
1081 
1082 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1083   JVMCIObject cp_object;
1084   jmetadata handle = _runtime-&gt;allocate_handle(cp);
1085   jboolean exception = false;
1086   JavaThread* THREAD = JavaThread::current();
1087   if (is_hotspot()) {
1088     JavaValue result(T_OBJECT);
1089     JavaCallArguments args;
1090     args.push_long((jlong) handle);
1091     JavaCalls::call_static(&amp;result,
1092                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1093                            vmSymbols::fromMetaspace_name(),
1094                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1095     if (HAS_PENDING_EXCEPTION) {
1096       exception = true;
1097     } else {
1098       cp_object = wrap((oop)result.get_jobject());
1099     }
1100   } else {
1101     JNIAccessMark jni(this, THREAD);
1102     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1103                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1104                                                              (jlong) handle));
1105     exception = jni()-&gt;ExceptionCheck();
1106   }
1107 
1108   if (exception) {
1109     _runtime-&gt;release_handle(handle);
1110     return JVMCIObject();
1111   }
1112 
1113   assert(!cp_object.is_null(), &quot;must be&quot;);
1114   // Constant pools aren&#39;t cached so this is always a newly created object using the handle
1115   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, &quot;must use same handle&quot;);
1116   return cp_object;
1117 }
1118 
1119 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
1120   JavaThread* THREAD = JavaThread::current();
1121   if (is_hotspot()) {
1122     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1123     return wrap(result);
1124   } else {
1125     JNIAccessMark jni(this, THREAD);
1126     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1127     return wrap(result);
1128   }
1129 }
1130 
1131 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
1132   JavaThread* THREAD = JavaThread::current();
1133   if (is_hotspot()) {
1134     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1135     return wrap(result);
1136   } else {
1137     JNIAccessMark jni(this, THREAD);
1138     jbyteArray result = jni()-&gt;NewByteArray(length);
1139     return wrap(result);
1140   }
1141 }
1142 
1143 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
1144   JavaThread* THREAD = JavaThread::current();
1145   if (is_hotspot()) {
1146     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1147     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1148     return wrap(result);
1149   } else {
1150     JNIAccessMark jni(this, THREAD);
1151     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1152     return wrap(result);
1153   }
1154 }
1155 
1156 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
1157   JavaThread* THREAD = JavaThread::current();
1158   if (is_hotspot()) {
1159     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1160     return wrap(result);
1161   } else {
1162     JNIAccessMark jni(this, THREAD);
1163     jintArray result = jni()-&gt;NewIntArray(length);
1164     return wrap(result);
1165   }
1166 }
1167 
1168 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
1169   JavaThread* THREAD = JavaThread::current();
1170   if (is_hotspot()) {
1171     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1172     return wrap(result);
1173   } else {
1174     JNIAccessMark jni(this, THREAD);
1175     jlongArray result = jni()-&gt;NewLongArray(length);
1176     return wrap(result);
1177   }
1178 }
1179 
1180 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
1181   JavaThread* THREAD = JavaThread::current();
1182   if (is_hotspot()) {
1183     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1184     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1185     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1186     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1187     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1188     HotSpotJVMCI::VMField::set_address(this, obj, address);
1189     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1190     return wrap(obj);
1191   } else {
1192     JNIAccessMark jni(this, THREAD);
1193     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1194                                     JNIJVMCI::VMField::constructor(),
1195                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1196     return wrap(result);
1197   }
1198 }
1199 
1200 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
1201   JavaThread* THREAD = JavaThread::current();
1202   if (is_hotspot()) {
1203     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1204     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1205     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1206     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1207     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1208     return wrap(obj);
1209   } else {
1210     JNIAccessMark jni(this, THREAD);
1211     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1212                                     JNIJVMCI::VMFlag::constructor(),
1213                                     get_jobject(name), get_jobject(type), get_jobject(value));
1214     return wrap(result);
1215   }
1216 }
1217 
1218 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
1219   JavaThread* THREAD = JavaThread::current();
1220   if (is_hotspot()) {
1221     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1222     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1223     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1224     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1225     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1226     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1227     return wrap(obj);
1228   } else {
1229     JNIAccessMark jni(this, THREAD);
1230     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1231                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1232                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1233     return wrap(result);
1234   }
1235 }
1236 
1237 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1238   if (is_hotspot()) {
1239     JavaThread* THREAD = JavaThread::current();
1240     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1241     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1242     return wrap(obj);
1243   } else {
1244     ShouldNotReachHere();
1245     return JVMCIObject();
1246   }
1247 }
1248 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1249   if (is_hotspot()) {
1250     JavaThread* THREAD = JavaThread::current();
1251     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1252     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1253     return wrap(obj);
1254   } else {
1255     ShouldNotReachHere();
1256     return JVMCIObject();
1257   }
1258 }
1259 
1260 
1261 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1262   JavaThread* THREAD = JavaThread::current();
1263   Handle obj = Handle(THREAD, objOop);
1264   if (obj.is_null()) {
1265     return JVMCIObject();
1266   }
1267   if (is_hotspot()) {
1268     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1269     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1270     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1271     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1272     return wrap(constant);
1273   } else {
1274     jlong handle = make_handle(obj);
1275     JNIAccessMark jni(this, THREAD);
1276     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1277                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1278                                       handle, compressed, dont_register);
1279     return wrap(result);
1280   }
1281 }
1282 
1283 
1284 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1285   if (constant.is_null()) {
1286     return Handle();
1287   }
1288   JavaThread* THREAD = JavaThread::current();
1289   if (is_hotspot()) {
1290     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), &quot;wrong type&quot;);
1291     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1292     return Handle(THREAD, obj);
1293   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1294     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1295     if (object_handle == 0L) {
1296       JVMCI_THROW_MSG_(NullPointerException, &quot;Foreign object reference has been cleared&quot;, Handle());
1297     }
1298     oop result = resolve_handle(object_handle);
1299     if (result == NULL) {
1300       JVMCI_THROW_MSG_(InternalError, &quot;Constant was unexpectedly NULL&quot;, Handle());
1301     }
1302     return Handle(THREAD, result);
1303   } else {
1304     JVMCI_THROW_MSG_(IllegalArgumentException, &quot;DirectHotSpotObjectConstantImpl shouldn&#39;t reach JVMCI in SVM mode&quot;, Handle());
1305   }
1306 }
1307 
1308 JVMCIObject JVMCIEnv::wrap(jobject object) {
1309   return JVMCIObject::create(object, is_hotspot());
1310 }
1311 
1312 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1313   assert(!obj.is_null(), &quot;should only create handle for non-NULL oops&quot;);
1314   jobject handle = _runtime-&gt;make_global(obj);
1315   return (jlong) handle;
1316 }
1317 
1318 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1319   assert(objectHandle != 0, &quot;should be a valid handle&quot;);
1320   oop obj = *((oopDesc**)objectHandle);
1321   if (obj != NULL) {
1322     oopDesc::verify(obj);
1323   }
1324   return obj;
1325 }
1326 
1327 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
1328   JavaThread* THREAD = JavaThread::current();
1329   if (is_hotspot()) {
1330     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1331     return HotSpotJVMCI::wrap(result());
1332   } else {
1333     jobject result;
1334     jboolean exception = false;
1335     {
1336       JNIAccessMark jni(this, THREAD);
1337       result = jni()-&gt;NewStringUTF(str);
1338       exception = jni()-&gt;ExceptionCheck();
1339     }
1340     return wrap(result);
1341   }
1342 }
1343 
1344 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1345   if (is_hotspot()) {
1346     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1347   } else {
1348     JNIAccessMark jni(this);
1349     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1350   }
1351 }
1352 
1353 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1354   if (kind.is_null()) {
1355     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1356   }
1357   jchar ch = get_JavaKind_typeChar(kind);
1358   switch(ch) {
1359     case &#39;Z&#39;: return T_BOOLEAN;
1360     case &#39;B&#39;: return T_BYTE;
1361     case &#39;S&#39;: return T_SHORT;
1362     case &#39;C&#39;: return T_CHAR;
1363     case &#39;I&#39;: return T_INT;
1364     case &#39;F&#39;: return T_FLOAT;
1365     case &#39;J&#39;: return T_LONG;
1366     case &#39;D&#39;: return T_DOUBLE;
1367     case &#39;A&#39;: return T_OBJECT;
1368     case &#39;-&#39;: return T_ILLEGAL;
1369     default:
1370       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);
1371   }
1372 }
1373 
1374 void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {
1375   // Ensure that all updates to the InstalledCode fields are consistent.
1376   if (get_InstalledCode_address(installed_code) != 0) {
1377     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance already in use&quot;);
1378   }
1379   if (!isa_HotSpotInstalledCode(installed_code)) {
1380     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance must be a subclass of HotSpotInstalledCode&quot;);
1381   }
1382 
1383   // Ignore the version which can stay at 0
1384   if (cb-&gt;is_nmethod()) {
1385     nmethod* nm = cb-&gt;as_nmethod_or_null();
1386     if (!nm-&gt;is_alive()) {
1387       JVMCI_THROW_MSG(InternalError, &quot;nmethod has been reclaimed&quot;);
1388     }
1389     if (nm-&gt;is_in_use()) {
1390       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());
1391     }
1392   } else {
1393     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());
1394   }
1395   set_InstalledCode_address(installed_code, (jlong) cb);
1396   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());
1397   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());
1398   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());
1399 }
1400 
1401 
1402 void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {
1403   if (mirror.is_null()) {
1404     JVMCI_THROW(NullPointerException);
1405   }
1406 
1407   nmethodLocker locker;
1408   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);
1409   if (nm == NULL) {
1410     // Nothing to do
1411     return;
1412   }
1413 
1414   Thread* THREAD = Thread::current();
1415   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {
1416     // Calling back into native might cause the execution to block, so only allow this when calling
1417     // from a JavaThread, which is the normal case anyway.
1418     JVMCI_THROW_MSG(IllegalArgumentException,
1419                     &quot;Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread&quot;);
1420   }
1421 
1422   nmethodLocker nml(nm);
1423   if (nm-&gt;is_alive()) {
1424     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.
1425     Deoptimization::deoptimize_all_marked(nm);
1426   }
1427 
1428   // A HotSpotNmethod instance can only reference a single nmethod
1429   // during its lifetime so simply clear it here.
1430   set_InstalledCode_address(mirror, 0);
1431 }
1432 
1433 Klass* JVMCIEnv::asKlass(JVMCIObject obj) {
1434   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);
1435 }
1436 
1437 Method* JVMCIEnv::asMethod(JVMCIObject obj) {
1438   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);
1439   return *metadataHandle;
1440 }
1441 
1442 ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {
1443   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);
1444   return *metadataHandle;
1445 }
1446 
1447 CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {
1448   address code = (address) get_InstalledCode_address(obj);
1449   if (code == NULL) {
1450     return NULL;
1451   }
1452   if (isa_HotSpotNmethod(obj)) {
1453     nmethod* nm = NULL;
1454     {
1455       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can&#39;t be freed
1456       // by nmethod::flush while we&#39;re interrogating it.
1457       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1458       CodeBlob* cb = CodeCache::find_blob_unsafe(code);
1459       if (cb == (CodeBlob*) code) {
1460         nmethod* the_nm = cb-&gt;as_nmethod_or_null();
1461         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {
1462           // Lock the nmethod to stop any further transitions by the sweeper.  It&#39;s still possible
1463           // for this code to execute in the middle of the sweeping of the nmethod but that will be
1464           // handled below.
1465           locker.set_code(nm, true);
1466           nm = the_nm;
1467         }
1468       }
1469     }
1470 
1471     if (nm != NULL) {
1472       // We found the nmethod but it could be in the process of being freed.  Check the state of the
1473       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other
1474       // threads have seen the is_locked_by_vm() update above.
1475       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1476       if (!nm-&gt;is_alive()) {
1477         //  It was alive when we looked it up but it&#39;s no longer alive so release it.
1478         locker.set_code(NULL);
1479         nm = NULL;
1480       }
1481     }
1482 
1483     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);
1484     if (compile_id_snapshot != 0L) {
1485       // Found a live nmethod with the same address, make sure it&#39;s the same nmethod
1486       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {
1487         if (nm-&gt;is_not_entrant()) {
1488           // Zero the entry point so that the nmethod
1489           // cannot be invoked by the mirror but can
1490           // still be deoptimized.
1491           set_InstalledCode_entryPoint(obj, 0);
1492         }
1493         return nm;
1494       }
1495       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state
1496       locker.set_code(NULL);
1497       nm = NULL;
1498     }
1499 
1500     if (nm == NULL) {
1501       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so
1502       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a
1503       // nmethod in the code cache.
1504       set_InstalledCode_address(obj, 0);
1505       set_InstalledCode_entryPoint(obj, 0);
1506     }
1507     return nm;
1508   }
1509 
1510   CodeBlob* cb = (CodeBlob*) code;
1511   assert(!cb-&gt;is_nmethod(), &quot;unexpected nmethod&quot;);
1512   return cb;
1513 }
1514 
1515 nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {
1516   CodeBlob* cb = get_code_blob(obj, locker);
1517   if (cb != NULL) {
1518     return cb-&gt;as_nmethod_or_null();
1519   }
1520   return NULL;
1521 }
1522 
1523 // Generate implementations for the initialize, new, isa, get and set methods for all the types and
1524 // fields declared in the JVMCI_CLASSES_DO macro.
1525 
1526 #define START_CLASS(className, fullClassName)                                                                        \
1527   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \
1528     if (is_hotspot()) {                                                                                              \
1529       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \
1530     } else {                                                                                                         \
1531       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \
1532     }                                                                                                                \
1533   }                                                                                                                  \
1534   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \
1535     if (is_hotspot()) {                                                                                              \
1536       Thread* THREAD = Thread::current();                                                                            \
1537       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \
1538       return (JVMCIObjectArray) wrap(array);                                                                         \
1539     } else {                                                                                                         \
1540       JNIAccessMark jni(this);                                                                                       \
1541       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \
1542       return wrap(result);                                                                                           \
1543     }                                                                                                                \
1544   }                                                                                                                  \
1545   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \
1546     if (is_hotspot()) {                                                                                              \
1547       return HotSpotJVMCI::className::is_instance(this, object);                                                     \
1548     } else {                                                                                                         \
1549       return JNIJVMCI::className::is_instance(this, object);                                                         \
1550     }                                                                                                                \
1551   }
1552 
1553 #define END_CLASS
1554 
1555 #define FIELD(className, name, type, accessor, cast)                 \
1556   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \
1557     if (is_hotspot()) {                                              \
1558       return HotSpotJVMCI::className::get_##name(this, obj);         \
1559     } else {                                                         \
1560       return JNIJVMCI::className::get_##name(this, obj);             \
1561     }                                                                \
1562   }                                                                  \
1563   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \
1564     if (is_hotspot()) {                                              \
1565       HotSpotJVMCI::className::set_##name(this, obj, x);             \
1566     } else {                                                         \
1567       JNIJVMCI::className::set_##name(this, obj, x);                 \
1568     }                                                                \
1569   }
1570 
1571 #define EMPTY_CAST
1572 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
1573 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
1574 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1575 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
1576 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
1577 
1578 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
1579 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1580 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
1581 
1582 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
1583 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1584 
1585 #define OOPISH_FIELD(className, name, type, accessor, cast)           \
1586   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \
1587     if (is_hotspot()) {                                               \
1588       return HotSpotJVMCI::className::get_##name(this, obj);          \
1589     } else {                                                          \
1590       return JNIJVMCI::className::get_##name(this, obj);              \
1591     }                                                                 \
1592   }                                                                   \
1593   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \
1594     if (is_hotspot()) {                                               \
1595       HotSpotJVMCI::className::set_##name(this, obj, x);              \
1596     } else {                                                          \
1597       JNIJVMCI::className::set_##name(this, obj, x);                  \
1598     }                                                                 \
1599   }
1600 
1601 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \
1602   type JVMCIEnv::get_##className##_##name() {                         \
1603     if (is_hotspot()) {                                               \
1604       return HotSpotJVMCI::className::get_##name(this);               \
1605     } else {                                                          \
1606       return JNIJVMCI::className::get_##name(this);                   \
1607     }                                                                 \
1608   }                                                                   \
1609   void JVMCIEnv::set_##className##_##name(type x) {                   \
1610     if (is_hotspot()) {                                               \
1611       HotSpotJVMCI::className::set_##name(this, x);                   \
1612     } else {                                                          \
1613       JNIJVMCI::className::set_##name(this, x);                       \
1614     }                                                                 \
1615   }
1616 
1617 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \
1618   type JVMCIEnv::get_##className##_##name() {                         \
1619     if (is_hotspot()) {                                               \
1620       return HotSpotJVMCI::className::get_##name(this);               \
1621     } else {                                                          \
1622       return JNIJVMCI::className::get_##name(this);                   \
1623     }                                                                 \
1624   }                                                                   \
1625   void JVMCIEnv::set_##className##_##name(type x) {                   \
1626     if (is_hotspot()) {                                               \
1627       HotSpotJVMCI::className::set_##name(this, x);                   \
1628     } else {                                                          \
1629       JNIJVMCI::className::set_##name(this, x);                       \
1630     }                                                                 \
1631   }
1632 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
1633 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1634 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
1635 #define CONSTRUCTOR(className, signature)
1636 
1637 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
1638 
1639 #undef START_CLASS
1640 #undef END_CLASS
1641 #undef METHOD
1642 #undef CONSTRUCTOR
1643 #undef FIELD
1644 #undef CHAR_FIELD
1645 #undef INT_FIELD
1646 #undef BOOLEAN_FIELD
1647 #undef LONG_FIELD
1648 #undef FLOAT_FIELD
1649 #undef OBJECT_FIELD
1650 #undef PRIMARRAY_FIELD
1651 #undef OBJECTARRAY_FIELD
1652 #undef STATIC_OOPISH_FIELD
1653 #undef STATIC_OBJECT_FIELD
1654 #undef STATIC_OBJECTARRAY_FIELD
1655 #undef STATIC_INT_FIELD
1656 #undef STATIC_BOOLEAN_FIELD
1657 #undef EMPTY_CAST
    </pre>
  </body>
</html>