<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/stringTable.hpp&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;compiler/compileTask.hpp&quot;
  30 #include &quot;memory/oopFactory.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/objArrayKlass.hpp&quot;
  34 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  35 #include &quot;runtime/deoptimization.hpp&quot;
  36 #include &quot;runtime/jniHandles.inline.hpp&quot;
  37 #include &quot;runtime/javaCalls.hpp&quot;
  38 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  39 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  40 
  41 JVMCICompileState::JVMCICompileState(CompileTask* task):
  42   _task(task),
  43   _retryable(true),
  44   _failure_reason(NULL),
  45   _failure_reason_on_C_heap(false) {
  46   // Get Jvmti capabilities under lock to get consistent values.
  47   MutexLocker mu(JvmtiThreadState_lock);
  48   _jvmti_redefinition_count             = JvmtiExport::redefinition_count();
  49   _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint() ? 1 : 0;
  50   _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables() ? 1 : 0;
  51   _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions() ? 1 : 0;
  52   _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame() ? 1 : 0;
  53   _target_method_is_old                 = _task != NULL &amp;&amp; _task-&gt;method()-&gt;is_old();
  54 }
  55 
  56 bool JVMCICompileState::jvmti_state_changed() const {
  57   // Some classes were redefined
  58   if (jvmti_redefinition_count() != JvmtiExport::redefinition_count()) {
  59     return true;
  60   }
  61   if (!jvmti_can_access_local_variables() &amp;&amp;
  62       JvmtiExport::can_access_local_variables()) {
  63     return true;
  64   }
  65   if (!jvmti_can_hotswap_or_post_breakpoint() &amp;&amp;
  66       JvmtiExport::can_hotswap_or_post_breakpoint()) {
  67     return true;
  68   }
  69   if (!jvmti_can_post_on_exceptions() &amp;&amp;
  70       JvmtiExport::can_post_on_exceptions()) {
  71     return true;
  72   }
  73   if (!jvmti_can_pop_frame() &amp;&amp;
  74       JvmtiExport::can_pop_frame()) {
  75     return true;
  76   }
  77   return false;
  78 }
  79 
  80 JavaVM* JVMCIEnv::_shared_library_javavm = NULL;
  81 void* JVMCIEnv::_shared_library_handle = NULL;
  82 char* JVMCIEnv::_shared_library_path = NULL;
  83 
  84 void JVMCIEnv::copy_saved_properties() {
  85   assert(!is_hotspot(), &quot;can only copy saved properties from HotSpot to native image&quot;);
  86 
  87   JavaThread* THREAD = JavaThread::current();
  88 
  89   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_services_Services(), Handle(), Handle(), true, THREAD);
  90   if (HAS_PENDING_EXCEPTION) {
  91     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  92   }
  93   InstanceKlass* ik = InstanceKlass::cast(k);
  94   if (ik-&gt;should_be_initialized()) {
  95     ik-&gt;initialize(THREAD);
  96     if (HAS_PENDING_EXCEPTION) {
  97       JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error initializing jdk.vm.ci.services.Services&quot;);
  98     }
  99   }
 100 
 101   // Get the serialized saved properties from HotSpot
 102   TempNewSymbol serializeSavedProperties = SymbolTable::new_symbol(&quot;serializeSavedProperties&quot;);
 103   JavaValue result(T_OBJECT);
 104   JavaCallArguments args;
 105   JavaCalls::call_static(&amp;result, ik, serializeSavedProperties, vmSymbols::serializePropertiesToByteArray_signature(), &amp;args, THREAD);
 106   if (HAS_PENDING_EXCEPTION) {
 107     JVMCIRuntime::exit_on_pending_exception(NULL, &quot;Error calling jdk.vm.ci.services.Services.serializeSavedProperties&quot;);
 108   }
 109   oop res = (oop) result.get_jobject();
 110   assert(res-&gt;is_typeArray(), &quot;must be&quot;);
 111   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;must be&quot;);
 112   typeArrayOop ba = typeArrayOop(res);
 113   int serialized_properties_len = ba-&gt;length();
 114 
 115   // Copy serialized saved properties from HotSpot object into native buffer
 116   jbyte* serialized_properties = NEW_RESOURCE_ARRAY(jbyte, serialized_properties_len);
 117   memcpy(serialized_properties, ba-&gt;byte_at_addr(0), serialized_properties_len);
 118 
 119   // Copy native buffer into shared library object
 120   JVMCIPrimitiveArray buf = new_byteArray(serialized_properties_len, this);
 121   if (has_pending_exception()) {
 122     describe_pending_exception(true);
 123     fatal(&quot;Error in copy_saved_properties&quot;);
 124   }
 125   copy_bytes_from(serialized_properties, buf, 0, serialized_properties_len);
 126   if (has_pending_exception()) {
 127     describe_pending_exception(true);
 128     fatal(&quot;Error in copy_saved_properties&quot;);
 129   }
 130 
 131   // Initialize saved properties in shared library
 132   jclass servicesClass = JNIJVMCI::Services::clazz();
 133   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
 134   JNIAccessMark jni(this);
 135   jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
 136   if (jni()-&gt;ExceptionCheck()) {
 137     jni()-&gt;ExceptionDescribe();
 138     fatal(&quot;Error calling jdk.vm.ci.services.Services.initializeSavedProperties&quot;);
 139   }
 140 }
 141 
 142 JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {
 143   if (_shared_library_javavm == NULL) {
 144     MutexLocker locker(JVMCI_lock);
 145     if (_shared_library_javavm == NULL) {
 146       char path[JVM_MAXPATHLEN];
 147       char ebuf[1024];
 148       if (JVMCILibPath != NULL) {
 149         if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {
 150           vm_exit_during_initialization(&quot;Unable to create JVMCI shared library path from -XX:JVMCILibPath value&quot;, JVMCILibPath);
 151         }
 152       } else {
 153         if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {
 154           vm_exit_during_initialization(&quot;Unable to create path to JVMCI shared library&quot;);
 155         }
 156       }
 157 
 158       void* handle = os::dll_load(path, ebuf, sizeof ebuf);
 159       if (handle == NULL) {
 160         vm_exit_during_initialization(&quot;Unable to load JVMCI shared library&quot;, ebuf);
 161       }
 162       _shared_library_handle = handle;
 163       _shared_library_path = strdup(path);
 164       jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);
 165       typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);
 166 
 167       JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, &quot;JNI_CreateJavaVM&quot;));
 168       JNIEnv* env;
 169       if (JNI_CreateJavaVM == NULL) {
 170         vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, path);
 171       }
 172 
 173       ResourceMark rm;
 174       JavaVMInitArgs vm_args;
 175       vm_args.version = JNI_VERSION_1_2;
 176       vm_args.ignoreUnrecognized = JNI_TRUE;
 177       vm_args.options = NULL;
 178       vm_args.nOptions = 0;
 179 
 180       JavaVM* the_javavm = NULL;
 181       int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);
 182       if (result == JNI_OK) {
 183         guarantee(env != NULL, &quot;missing env&quot;);
 184         _shared_library_javavm = the_javavm;
 185         return env;
 186       } else {
 187         vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), path);
 188       }
 189     }
 190   }
 191   return NULL;
 192 }
 193 
 194 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
 195   assert(thread != NULL, &quot;npe&quot;);
 196   // By default there is only one runtime which is the compiler runtime.
 197   _runtime = JVMCI::compiler_runtime();
 198   _env = NULL;
 199   _pop_frame_on_close = false;
 200   _detach_on_close = false;
 201   if (!UseJVMCINativeLibrary) {
 202     // In HotSpot mode, JNI isn&#39;t used at all.
 203     _is_hotspot = true;
 204     return;
 205   }
 206 
 207   if (parent_env != NULL) {
 208     // If the parent JNI environment is non-null then figure out whether it
 209     // is a HotSpot or shared library JNIEnv and set the state appropriately.
 210     _is_hotspot = thread-&gt;jni_environment() == parent_env;
 211     if (_is_hotspot) {
 212       // Select the Java runtime
 213       _runtime = JVMCI::java_runtime();
 214       return;
 215     }
 216     _env = parent_env;
 217     return;
 218   }
 219 
 220   // Running in JVMCI shared library mode so ensure the shared library
 221   // is loaded and initialized and get a shared library JNIEnv
 222   _is_hotspot = false;
 223   _env = init_shared_library(thread);
 224 
 225   if (_env != NULL) {
 226     // Creating the JVMCI shared library VM also attaches the current thread
 227     _detach_on_close = true;
 228   } else {
 229     _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);
 230     if (parent_env != NULL) {
 231       // Even though there&#39;s a parent JNI env, there&#39;s no guarantee
 232       // it was opened by a JVMCIEnv scope and thus may not have
 233       // pushed a local JNI frame. As such, we use a new JNI local
 234       // frame in this scope to ensure local JNI refs are collected
 235       // in a timely manner after leaving this scope.
 236       _env = parent_env;
 237     } else {
 238       ResourceMark rm; // Thread name is resource allocated
 239       JavaVMAttachArgs attach_args;
 240       attach_args.version = JNI_VERSION_1_2;
 241       attach_args.name = thread-&gt;name();
 242       attach_args.group = NULL;
 243       if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {
 244         fatal(&quot;Error attaching current thread (%s) to JVMCI shared library JNI interface&quot;, attach_args.name);
 245       }
 246       _detach_on_close = true;
 247     }
 248   }
 249 
 250   assert(_env != NULL, &quot;missing env&quot;);
 251   assert(_throw_to_caller == false, &quot;must be&quot;);
 252 
 253   JNIAccessMark jni(this);
 254   jint result = _env-&gt;PushLocalFrame(32);
 255   if (result != JNI_OK) {
 256     char message[256];
 257     jio_snprintf(message, 256, &quot;Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 258     JVMCIRuntime::exit_on_pending_exception(this, message);
 259   }
 260   _pop_frame_on_close = true;
 261 }
 262 
 263 JVMCIEnv::JVMCIEnv(JavaThread* thread, JVMCICompileState* compile_state, const char* file, int line):
 264     _throw_to_caller(false), _file(file), _line(line), _compile_state(compile_state) {
 265   init_env_mode_runtime(thread, NULL);
 266 }
 267 
 268 JVMCIEnv::JVMCIEnv(JavaThread* thread, const char* file, int line):
 269     _throw_to_caller(false), _file(file), _line(line), _compile_state(NULL) {
 270   init_env_mode_runtime(thread, NULL);
 271 }
 272 
 273 JVMCIEnv::JVMCIEnv(JavaThread* thread, JNIEnv* parent_env, const char* file, int line):
 274     _throw_to_caller(true), _file(file), _line(line), _compile_state(NULL) {
 275   init_env_mode_runtime(thread, parent_env);
 276   assert(_env == NULL || parent_env == _env, &quot;mismatched JNIEnvironment&quot;);
 277 }
 278 
 279 void JVMCIEnv::init(JavaThread* thread, bool is_hotspot, const char* file, int line) {
 280   _compile_state = NULL;
 281   _throw_to_caller = false;
 282   _file = file;
 283   _line = line;
 284   if (is_hotspot) {
 285     _env = NULL;
 286     _pop_frame_on_close = false;
 287     _detach_on_close = false;
 288     _is_hotspot = true;
 289     _runtime = JVMCI::java_runtime();
 290   } else {
 291     init_env_mode_runtime(thread, NULL);
 292   }
 293 }
 294 
 295 // Prints a pending exception (if any) and its stack trace.
 296 void JVMCIEnv::describe_pending_exception(bool clear) {
 297   if (!is_hotspot()) {
 298     JNIAccessMark jni(this);
 299     if (jni()-&gt;ExceptionCheck()) {
 300       jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
 301       jni()-&gt;ExceptionDescribe();
 302       if (ex != NULL) {
 303         jni()-&gt;Throw(ex);
 304       }
 305     }
 306   } else {
 307     Thread* THREAD = Thread::current();
 308     if (HAS_PENDING_EXCEPTION) {
 309       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
 310     }
 311   }
 312 }
 313 
 314 void JVMCIEnv::translate_hotspot_exception_to_jni_exception(JavaThread* THREAD, const Handle&amp; throwable) {
 315   assert(!is_hotspot(), &quot;must_be&quot;);
 316   // Resolve HotSpotJVMCIRuntime class explicitly as HotSpotJVMCI::compute_offsets
 317   // may not have been called.
 318   Klass* runtimeKlass = SystemDictionary::resolve_or_fail(vmSymbols::jdk_vm_ci_hotspot_HotSpotJVMCIRuntime(), true, CHECK);
 319   JavaCallArguments jargs;
 320   jargs.push_oop(throwable);
 321   JavaValue result(T_OBJECT);
 322   JavaCalls::call_static(&amp;result,
 323                           runtimeKlass,
 324                           vmSymbols::encodeThrowable_name(),
 325                           vmSymbols::encodeThrowable_signature(), &amp;jargs, THREAD);
 326   if (HAS_PENDING_EXCEPTION) {
 327     JVMCIRuntime::exit_on_pending_exception(this, &quot;HotSpotJVMCIRuntime.encodeThrowable should not throw an exception&quot;);
 328   }
 329 
 330   oop encoded_throwable_string = (oop) result.get_jobject();
 331 
 332   ResourceMark rm;
 333   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 334 
 335   JNIAccessMark jni(this);
 336   jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
 337   jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 338                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
 339                                 jni_encoded_throwable_string);
 340   jni()-&gt;Throw(jni_throwable);
 341 }
 342 
 343 JVMCIEnv::~JVMCIEnv() {
 344   if (_throw_to_caller) {
 345     if (is_hotspot()) {
 346       // Nothing to do
 347     } else {
 348       if (Thread::current()-&gt;is_Java_thread()) {
 349         JavaThread* THREAD = JavaThread::current();
 350         if (HAS_PENDING_EXCEPTION) {
 351           Handle throwable = Handle(THREAD, PENDING_EXCEPTION);
 352           CLEAR_PENDING_EXCEPTION;
 353           translate_hotspot_exception_to_jni_exception(THREAD, throwable);
 354         }
 355       }
 356     }
 357   } else {
 358     if (_pop_frame_on_close) {
 359       // Pop the JNI local frame that was pushed when entering this JVMCIEnv scope.
 360       JNIAccessMark jni(this);
 361       jni()-&gt;PopLocalFrame(NULL);
 362     }
 363 
 364     if (has_pending_exception()) {
 365       char message[256];
 366       jio_snprintf(message, 256, &quot;Uncaught exception exiting JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
 367       JVMCIRuntime::exit_on_pending_exception(this, message);
 368     }
 369 
 370     if (_detach_on_close) {
 371       get_shared_library_javavm()-&gt;DetachCurrentThread();
 372     }
 373   }
 374 }
 375 
 376 jboolean JVMCIEnv::has_pending_exception() {
 377   if (is_hotspot()) {
 378     Thread* THREAD = Thread::current();
 379     return HAS_PENDING_EXCEPTION;
 380   } else {
 381     JNIAccessMark jni(this);
 382     return jni()-&gt;ExceptionCheck();
 383   }
 384 }
 385 
 386 void JVMCIEnv::clear_pending_exception() {
 387   if (is_hotspot()) {
 388     Thread* THREAD = Thread::current();
 389     CLEAR_PENDING_EXCEPTION;
 390   } else {
 391     JNIAccessMark jni(this);
 392     jni()-&gt;ExceptionClear();
 393   }
 394 }
 395 
 396 int JVMCIEnv::get_length(JVMCIArray array) {
 397   if (is_hotspot()) {
 398     return HotSpotJVMCI::resolve(array)-&gt;length();
 399   } else {
 400     JNIAccessMark jni(this);
 401     return jni()-&gt;GetArrayLength(get_jarray(array));
 402   }
 403 }
 404 
 405 JVMCIObject JVMCIEnv::get_object_at(JVMCIObjectArray array, int index) {
 406   if (is_hotspot()) {
 407     oop result = HotSpotJVMCI::resolve(array)-&gt;obj_at(index);
 408     return wrap(result);
 409   } else {
 410     JNIAccessMark jni(this);
 411     jobject result = jni()-&gt;GetObjectArrayElement(get_jobjectArray(array), index);
 412     return wrap(result);
 413   }
 414 }
 415 
 416 void JVMCIEnv::put_object_at(JVMCIObjectArray array, int index, JVMCIObject value) {
 417   if (is_hotspot()) {
 418     HotSpotJVMCI::resolve(array)-&gt;obj_at_put(index, HotSpotJVMCI::resolve(value));
 419   } else {
 420     JNIAccessMark jni(this);
 421     jni()-&gt;SetObjectArrayElement(get_jobjectArray(array), index, get_jobject(value));
 422   }
 423 }
 424 
 425 jboolean JVMCIEnv::get_bool_at(JVMCIPrimitiveArray array, int index) {
 426   if (is_hotspot()) {
 427     return HotSpotJVMCI::resolve(array)-&gt;bool_at(index);
 428   } else {
 429     JNIAccessMark jni(this);
 430     jboolean result;
 431     jni()-&gt;GetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;result);
 432     return result;
 433   }
 434 }
 435 void JVMCIEnv::put_bool_at(JVMCIPrimitiveArray array, int index, jboolean value) {
 436   if (is_hotspot()) {
 437     HotSpotJVMCI::resolve(array)-&gt;bool_at_put(index, value);
 438   } else {
 439     JNIAccessMark jni(this);
 440     jni()-&gt;SetBooleanArrayRegion(array.as_jbooleanArray(), index, 1, &amp;value);
 441   }
 442 }
 443 
 444 jbyte JVMCIEnv::get_byte_at(JVMCIPrimitiveArray array, int index) {
 445   if (is_hotspot()) {
 446     return HotSpotJVMCI::resolve(array)-&gt;byte_at(index);
 447   } else {
 448     JNIAccessMark jni(this);
 449     jbyte result;
 450     jni()-&gt;GetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;result);
 451     return result;
 452   }
 453 }
 454 void JVMCIEnv::put_byte_at(JVMCIPrimitiveArray array, int index, jbyte value) {
 455   if (is_hotspot()) {
 456     HotSpotJVMCI::resolve(array)-&gt;byte_at_put(index, value);
 457   } else {
 458     JNIAccessMark jni(this);
 459     jni()-&gt;SetByteArrayRegion(array.as_jbyteArray(), index, 1, &amp;value);
 460   }
 461 }
 462 
 463 jint JVMCIEnv::get_int_at(JVMCIPrimitiveArray array, int index) {
 464   if (is_hotspot()) {
 465     return HotSpotJVMCI::resolve(array)-&gt;int_at(index);
 466   } else {
 467     JNIAccessMark jni(this);
 468     jint result;
 469     jni()-&gt;GetIntArrayRegion(array.as_jintArray(), index, 1, &amp;result);
 470     return result;
 471   }
 472 }
 473 void JVMCIEnv::put_int_at(JVMCIPrimitiveArray array, int index, jint value) {
 474   if (is_hotspot()) {
 475     HotSpotJVMCI::resolve(array)-&gt;int_at_put(index, value);
 476   } else {
 477     JNIAccessMark jni(this);
 478     jni()-&gt;SetIntArrayRegion(array.as_jintArray(), index, 1, &amp;value);
 479   }
 480 }
 481 
 482 long JVMCIEnv::get_long_at(JVMCIPrimitiveArray array, int index) {
 483   if (is_hotspot()) {
 484     return HotSpotJVMCI::resolve(array)-&gt;long_at(index);
 485   } else {
 486     JNIAccessMark jni(this);
 487     jlong result;
 488     jni()-&gt;GetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;result);
 489     return result;
 490   }
 491 }
 492 void JVMCIEnv::put_long_at(JVMCIPrimitiveArray array, int index, jlong value) {
 493   if (is_hotspot()) {
 494     HotSpotJVMCI::resolve(array)-&gt;long_at_put(index, value);
 495   } else {
 496     JNIAccessMark jni(this);
 497     jni()-&gt;SetLongArrayRegion(array.as_jlongArray(), index, 1, &amp;value);
 498   }
 499 }
 500 
 501 void JVMCIEnv::copy_bytes_to(JVMCIPrimitiveArray src, jbyte* dest, int offset, jsize length) {
 502   if (length == 0) {
 503     return;
 504   }
 505   if (is_hotspot()) {
 506     memcpy(dest, HotSpotJVMCI::resolve(src)-&gt;byte_at_addr(offset), length);
 507   } else {
 508     JNIAccessMark jni(this);
 509     jni()-&gt;GetByteArrayRegion(src.as_jbyteArray(), offset, length, dest);
 510   }
 511 }
 512 void JVMCIEnv::copy_bytes_from(jbyte* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 513   if (length == 0) {
 514     return;
 515   }
 516   if (is_hotspot()) {
 517     memcpy(HotSpotJVMCI::resolve(dest)-&gt;byte_at_addr(offset), src, length);
 518   } else {
 519     JNIAccessMark jni(this);
 520     jni()-&gt;SetByteArrayRegion(dest.as_jbyteArray(), offset, length, src);
 521   }
 522 }
 523 
 524 void JVMCIEnv::copy_longs_from(jlong* src, JVMCIPrimitiveArray dest, int offset, jsize length) {
 525   if (length == 0) {
 526     return;
 527   }
 528   if (is_hotspot()) {
 529     memcpy(HotSpotJVMCI::resolve(dest)-&gt;long_at_addr(offset), src, length * sizeof(jlong));
 530   } else {
 531     JNIAccessMark jni(this);
 532     jni()-&gt;SetLongArrayRegion(dest.as_jlongArray(), offset, length, src);
 533   }
 534 }
 535 
 536 jboolean JVMCIEnv::is_boxing_object(BasicType type, JVMCIObject object) {
 537   if (is_hotspot()) {
 538     return java_lang_boxing_object::is_instance(HotSpotJVMCI::resolve(object), type);
 539   } else {
 540     JNIAccessMark jni(this);
 541     return jni()-&gt;IsInstanceOf(get_jobject(object), JNIJVMCI::box_class(type));
 542   }
 543 }
 544 
 545 // Get the primitive value from a Java boxing object.  It&#39;s hard error to
 546 // pass a non-primitive BasicType.
 547 jvalue JVMCIEnv::get_boxed_value(BasicType type, JVMCIObject object) {
 548   jvalue result;
 549   if (is_hotspot()) {
 550     if (java_lang_boxing_object::get_value(HotSpotJVMCI::resolve(object), &amp;result) == T_ILLEGAL) {
 551       ShouldNotReachHere();
 552     }
 553   } else {
 554     JNIAccessMark jni(this);
 555     jfieldID field = JNIJVMCI::box_field(type);
 556     switch (type) {
 557       case T_BOOLEAN: result.z = jni()-&gt;GetBooleanField(get_jobject(object), field); break;
 558       case T_BYTE:    result.b = jni()-&gt;GetByteField(get_jobject(object), field); break;
 559       case T_SHORT:   result.s = jni()-&gt;GetShortField(get_jobject(object), field); break;
 560       case T_CHAR:    result.c = jni()-&gt;GetCharField(get_jobject(object), field); break;
 561       case T_INT:     result.i = jni()-&gt;GetIntField(get_jobject(object), field); break;
 562       case T_LONG:    result.j = jni()-&gt;GetLongField(get_jobject(object), field); break;
 563       case T_FLOAT:   result.f = jni()-&gt;GetFloatField(get_jobject(object), field); break;
 564       case T_DOUBLE:  result.d = jni()-&gt;GetDoubleField(get_jobject(object), field); break;
 565       default:
 566         ShouldNotReachHere();
 567     }
 568   }
 569   return result;
 570 }
 571 
 572 // Return the BasicType of the object if it&#39;s a boxing object, otherwise return T_ILLEGAL.
 573 BasicType JVMCIEnv::get_box_type(JVMCIObject object) {
 574   if (is_hotspot()) {
 575     return java_lang_boxing_object::basic_type(HotSpotJVMCI::resolve(object));
 576   } else {
 577     JNIAccessMark jni(this);
 578     jclass clazz = jni()-&gt;GetObjectClass(get_jobject(object));
 579     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BOOLEAN))) return T_BOOLEAN;
 580     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_BYTE))) return T_BYTE;
 581     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_SHORT))) return T_SHORT;
 582     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_CHAR))) return T_CHAR;
 583     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_INT))) return T_INT;
 584     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_LONG))) return T_LONG;
 585     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_FLOAT))) return T_FLOAT;
 586     if (jni()-&gt;IsSameObject(clazz, JNIJVMCI::box_class(T_DOUBLE))) return T_DOUBLE;
 587     return T_ILLEGAL;
 588   }
 589 }
 590 
 591 // Create a boxing object of the appropriate primitive type.
 592 JVMCIObject JVMCIEnv::create_box(BasicType type, jvalue* value, JVMCI_TRAPS) {
 593   switch (type) {
 594     case T_BOOLEAN:
 595     case T_BYTE:
 596     case T_CHAR:
 597     case T_SHORT:
 598     case T_INT:
 599     case T_LONG:
 600     case T_FLOAT:
 601     case T_DOUBLE:
 602       break;
 603     default:
 604       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;Only boxes for primitive values can be created&quot;, JVMCIObject());
 605   }
 606   if (is_hotspot()) {
 607     JavaThread* THREAD = JavaThread::current();
 608     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
 609     return HotSpotJVMCI::wrap(box);
 610   } else {
 611     JNIAccessMark jni(this);
 612     jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
 613     assert(box != NULL, &quot;&quot;);
 614     return wrap(box);
 615   }
 616 }
 617 
 618 const char* JVMCIEnv::as_utf8_string(JVMCIObject str) {
 619   if (is_hotspot()) {
 620     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str));
 621   } else {
 622     JNIAccessMark jni(this);
 623     int length = jni()-&gt;GetStringLength(str.as_jstring());
 624     char* result = NEW_RESOURCE_ARRAY(char, length + 1);
 625     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, result);
 626     return result;
 627   }
 628 }
 629 
 630 char* JVMCIEnv::as_utf8_string(JVMCIObject str, char* buf, int buflen) {
 631   if (is_hotspot()) {
 632     return java_lang_String::as_utf8_string(HotSpotJVMCI::resolve(str), buf, buflen);
 633   } else {
 634     JNIAccessMark jni(this);
 635     int length = jni()-&gt;GetStringLength(str.as_jstring());
 636     if (length &gt;= buflen) {
 637       length = buflen;
 638     }
 639     jni()-&gt;GetStringUTFRegion(str.as_jstring(), 0, length, buf);
 640     return buf;
 641   }
 642 }
 643 
 644 #define DO_THROW(name)                             \
 645 void JVMCIEnv::throw_##name(const char* msg) {     \
 646   if (is_hotspot()) {                              \
 647     JavaThread* THREAD = JavaThread::current();    \
 648     THROW_MSG(HotSpotJVMCI::name::symbol(), msg);  \
 649   } else {                                         \
 650     JNIAccessMark jni(this);                       \
 651     jni()-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg); \
 652   }                                                \
 653 }
 654 
 655 DO_THROW(InternalError)
 656 DO_THROW(ArrayIndexOutOfBoundsException)
 657 DO_THROW(IllegalStateException)
 658 DO_THROW(NullPointerException)
 659 DO_THROW(IllegalArgumentException)
 660 DO_THROW(InvalidInstalledCodeException)
 661 DO_THROW(UnsatisfiedLinkError)
 662 DO_THROW(UnsupportedOperationException)
 663 DO_THROW(ClassNotFoundException)
 664 
 665 #undef DO_THROW
 666 
 667 void JVMCIEnv::fthrow_error(const char* file, int line, const char* format, ...) {
 668   const int max_msg_size = 1024;
 669   va_list ap;
 670   va_start(ap, format);
 671   char msg[max_msg_size];
 672   vsnprintf(msg, max_msg_size, format, ap);
 673   msg[max_msg_size-1] = &#39;\0&#39;;
 674   va_end(ap);
 675   if (is_hotspot()) {
 676     JavaThread* THREAD = JavaThread::current();
 677     Handle h_loader = Handle();
 678     Handle h_protection_domain = Handle();
 679     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
 680   } else {
 681     JNIAccessMark jni(this);
 682     jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
 683   }
 684 }
 685 
 686 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
 687                                                               jlong compile_state, int id) {
 688   if (is_hotspot()) {
 689     Thread* THREAD = Thread::current();
 690     JavaCallArguments jargs;
 691     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 692     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(method)));
 693     jargs.push_int(entry_bci);
 694     jargs.push_long(compile_state);
 695     jargs.push_int(id);
 696     JavaValue result(T_OBJECT);
 697     JavaCalls::call_special(&amp;result,
 698                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 699                             vmSymbols::compileMethod_name(),
 700                             vmSymbols::compileMethod_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 701     return wrap((oop) result.get_jobject());
 702   } else {
 703     JNIAccessMark jni(this);
 704     jobject result = jni()-&gt;CallNonvirtualObjectMethod(runtime.as_jobject(),
 705                                                      JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 706                                                      JNIJVMCI::HotSpotJVMCIRuntime::compileMethod_method(),
 707                                                      method.as_jobject(), entry_bci, compile_state, id);
 708     if (jni()-&gt;ExceptionCheck()) {
 709       return JVMCIObject();
 710     }
 711     return wrap(result);
 712   }
 713 }
 714 
 715 void JVMCIEnv::call_HotSpotJVMCIRuntime_bootstrapFinished (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 716   if (is_hotspot()) {
 717     Thread* THREAD = Thread::current();
 718     JavaCallArguments jargs;
 719     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 720     JavaValue result(T_VOID);
 721     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::bootstrapFinished_name(), vmSymbols::void_method_signature(), &amp;jargs, CHECK);
 722   } else {
 723     JNIAccessMark jni(this);
 724     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::bootstrapFinished_method());
 725 
 726   }
 727 }
 728 
 729 void JVMCIEnv::call_HotSpotJVMCIRuntime_shutdown (JVMCIObject runtime) {
 730   HandleMark hm;
 731   JavaThread* THREAD = JavaThread::current();
 732   if (is_hotspot()) {
 733     JavaCallArguments jargs;
 734     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 735     JavaValue result(T_VOID);
 736     JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
 737   } else {
 738     JNIAccessMark jni(this);
 739     jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
 740   }
 741   if (has_pending_exception()) {
 742     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
 743     // handle all exceptions.
 744     describe_pending_exception(true);
 745   }
 746 }
 747 
 748 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_runtime (JVMCIEnv* JVMCIENV) {
 749   JavaThread* THREAD = JavaThread::current();
 750   if (is_hotspot()) {
 751     JavaCallArguments jargs;
 752     JavaValue result(T_OBJECT);
 753     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 754     return wrap((oop) result.get_jobject());
 755   } else {
 756     JNIAccessMark jni(this);
 757     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
 758     if (jni()-&gt;ExceptionCheck()) {
 759       return JVMCIObject();
 760     }
 761     return wrap(result);
 762   }
 763 }
 764 
 765 JVMCIObject JVMCIEnv::call_JVMCI_getRuntime (JVMCIEnv* JVMCIENV) {
 766   JavaThread* THREAD = JavaThread::current();
 767   if (is_hotspot()) {
 768     JavaCallArguments jargs;
 769     JavaValue result(T_OBJECT);
 770     JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 771     return wrap((oop) result.get_jobject());
 772   } else {
 773     JNIAccessMark jni(this);
 774     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
 775     if (jni()-&gt;ExceptionCheck()) {
 776       return JVMCIObject();
 777     }
 778     return wrap(result);
 779   }
 780 }
 781 
 782 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_getCompiler (JVMCIObject runtime, JVMCIEnv* JVMCIENV) {
 783   JavaThread* THREAD = JavaThread::current();
 784   if (is_hotspot()) {
 785     JavaCallArguments jargs;
 786     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
 787     JavaValue result(T_OBJECT);
 788     JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 789     return wrap((oop) result.get_jobject());
 790   } else {
 791     JNIAccessMark jni(this);
 792     jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
 793     if (jni()-&gt;ExceptionCheck()) {
 794       return JVMCIObject();
 795     }
 796     return wrap(result);
 797   }
 798 }
 799 
 800 
 801 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_callToString(JVMCIObject object, JVMCIEnv* JVMCIENV) {
 802   JavaThread* THREAD = JavaThread::current();
 803   if (is_hotspot()) {
 804     JavaCallArguments jargs;
 805     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(object)));
 806     JavaValue result(T_OBJECT);
 807     JavaCalls::call_static(&amp;result,
 808                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
 809                            vmSymbols::callToString_name(),
 810                            vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 811     return wrap((oop) result.get_jobject());
 812   } else {
 813     JNIAccessMark jni(this);
 814     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
 815                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
 816                                                      object.as_jobject());
 817     if (jni()-&gt;ExceptionCheck()) {
 818       return JVMCIObject();
 819     }
 820     return wrap(result);
 821   }
 822 }
 823 
 824 
 825 JVMCIObject JVMCIEnv::call_PrimitiveConstant_forTypeChar(jchar kind, jlong value, JVMCI_TRAPS) {
 826   JavaThread* THREAD = JavaThread::current();
 827   if (is_hotspot()) {
 828     JavaCallArguments jargs;
 829     jargs.push_int(kind);
 830     jargs.push_long(value);
 831     JavaValue result(T_OBJECT);
 832     JavaCalls::call_static(&amp;result,
 833                            HotSpotJVMCI::PrimitiveConstant::klass(),
 834                            vmSymbols::forTypeChar_name(),
 835                            vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 836     return wrap((oop) result.get_jobject());
 837   } else {
 838     JNIAccessMark jni(this);
 839     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
 840                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
 841                                                      kind, value);
 842     if (jni()-&gt;ExceptionCheck()) {
 843       return JVMCIObject();
 844     }
 845     return wrap(result);
 846   }
 847 }
 848 
 849 JVMCIObject JVMCIEnv::call_JavaConstant_forFloat(float value, JVMCI_TRAPS) {
 850   JavaThread* THREAD = JavaThread::current();
 851   if (is_hotspot()) {
 852     JavaCallArguments jargs;
 853     jargs.push_float(value);
 854     JavaValue result(T_OBJECT);
 855     JavaCalls::call_static(&amp;result,
 856                            HotSpotJVMCI::JavaConstant::klass(),
 857                            vmSymbols::forFloat_name(),
 858                            vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 859     return wrap((oop) result.get_jobject());
 860   } else {
 861     JNIAccessMark jni(this);
 862     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 863                                                      JNIJVMCI::JavaConstant::forFloat_method(),
 864                                                      value);
 865     if (jni()-&gt;ExceptionCheck()) {
 866       return JVMCIObject();
 867     }
 868     return wrap(result);
 869   }
 870 }
 871 
 872 JVMCIObject JVMCIEnv::call_JavaConstant_forDouble(double value, JVMCI_TRAPS) {
 873   JavaThread* THREAD = JavaThread::current();
 874   if (is_hotspot()) {
 875     JavaCallArguments jargs;
 876     jargs.push_double(value);
 877     JavaValue result(T_OBJECT);
 878     JavaCalls::call_static(&amp;result,
 879                            HotSpotJVMCI::JavaConstant::klass(),
 880                            vmSymbols::forDouble_name(),
 881                            vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
 882     return wrap((oop) result.get_jobject());
 883   } else {
 884     JNIAccessMark jni(this);
 885     jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
 886                                                      JNIJVMCI::JavaConstant::forDouble_method(),
 887                                                      value);
 888     if (jni()-&gt;ExceptionCheck()) {
 889       return JVMCIObject();
 890     }
 891     return wrap(result);
 892   }
 893 }
 894 
 895 JVMCIObject JVMCIEnv::get_jvmci_primitive_type(BasicType type) {
 896   JVMCIObjectArray primitives = get_HotSpotResolvedPrimitiveType_primitives();
 897   JVMCIObject result = get_object_at(primitives, type);
 898   return result;
 899 }
 900 
 901 JVMCIObject JVMCIEnv::new_StackTraceElement(const methodHandle&amp; method, int bci, JVMCI_TRAPS) {
 902   JavaThread* THREAD = JavaThread::current();
 903   Symbol* file_name_sym;
 904   int line_number;
 905   java_lang_StackTraceElement::decode(method, bci, file_name_sym, line_number, CHECK_(JVMCIObject()));
 906 
 907   Symbol* method_name_sym = method-&gt;name();
 908   InstanceKlass* holder = method-&gt;method_holder();
 909   const char* declaring_class_str = holder-&gt;external_name();
 910 
 911   if (is_hotspot()) {
 912     HotSpotJVMCI::StackTraceElement::klass()-&gt;initialize(CHECK_(JVMCIObject()));
 913     oop objOop = HotSpotJVMCI::StackTraceElement::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
 914     Handle obj = Handle(THREAD, objOop);
 915 
 916     oop declaring_class = StringTable::intern((char*) declaring_class_str, CHECK_(JVMCIObject()));
 917     HotSpotJVMCI::StackTraceElement::set_declaringClass(this, obj(), declaring_class);
 918 
 919     oop method_name = StringTable::intern(method_name_sym, CHECK_(JVMCIObject()));
 920     HotSpotJVMCI::StackTraceElement::set_methodName(this, obj(), method_name);
 921 
 922     if (file_name_sym != NULL) {
 923       oop file_name = StringTable::intern(file_name_sym, CHECK_(JVMCIObject()));
 924       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
 925     }
 926     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
 927     return wrap(obj());
 928   } else {
 929     JNIAccessMark jni(this);
 930     jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
 931     if (jni()-&gt;ExceptionCheck()) {
 932       return JVMCIObject();
 933     }
 934     jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
 935     if (jni()-&gt;ExceptionCheck()) {
 936       return JVMCIObject();
 937     }
 938     jobject file_name = NULL;
 939     if (file_name_sym != NULL) {
 940       file_name = jni()-&gt;NewStringUTF(file_name_sym-&gt;as_C_string());
 941       if (jni()-&gt;ExceptionCheck()) {
 942         return JVMCIObject();
 943       }
 944     }
 945 
 946     jobject result = jni()-&gt;NewObject(JNIJVMCI::StackTraceElement::clazz(),
 947                                       JNIJVMCI::StackTraceElement::constructor(),
 948                                       declaring_class, method_name, file_name, line_number);
 949     return wrap(result);
 950   }
 951 }
 952 
 953 JVMCIObject JVMCIEnv::new_HotSpotNmethod(const methodHandle&amp; method, const char* name, jboolean isDefault, jlong compileId, JVMCI_TRAPS) {
 954   JavaThread* THREAD = JavaThread::current();
 955 
 956   JVMCIObject methodObject = get_jvmci_method(method, JVMCI_CHECK_(JVMCIObject()));
 957 
 958   if (is_hotspot()) {
 959     InstanceKlass* ik = InstanceKlass::cast(HotSpotJVMCI::HotSpotNmethod::klass());
 960     if (ik-&gt;should_be_initialized()) {
 961       ik-&gt;initialize(CHECK_(JVMCIObject()));
 962     }
 963     oop obj = ik-&gt;allocate_instance(CHECK_(JVMCIObject()));
 964     Handle obj_h(THREAD, obj);
 965     Handle nameStr = java_lang_String::create_from_str(name, CHECK_(JVMCIObject()));
 966 
 967     // Call constructor
 968     JavaCallArguments jargs;
 969     jargs.push_oop(obj_h);
 970     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(methodObject)));
 971     jargs.push_oop(nameStr);
 972     jargs.push_int(isDefault);
 973     jargs.push_long(compileId);
 974     JavaValue result(T_VOID);
 975     JavaCalls::call_special(&amp;result, ik,
 976                             vmSymbols::object_initializer_name(),
 977                             vmSymbols::method_string_bool_long_signature(),
 978                             &amp;jargs, CHECK_(JVMCIObject()));
 979     return wrap(obj_h());
 980   } else {
 981     JNIAccessMark jni(this);
 982     jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
 983     if (jni()-&gt;ExceptionCheck()) {
 984       return JVMCIObject();
 985     }
 986 
 987     jobject result = jni()-&gt;NewObject(JNIJVMCI::HotSpotNmethod::clazz(),
 988                                       JNIJVMCI::HotSpotNmethod::constructor(),
 989                                       methodObject.as_jobject(), nameStr, isDefault);
 990     return wrap(result);
 991   }
 992 }
 993 
 994 JVMCIObject JVMCIEnv::make_local(JVMCIObject object) {
 995   if (object.is_null()) {
 996     return JVMCIObject();
 997   }
 998   if (is_hotspot()) {
 999     return wrap(JNIHandles::make_local(HotSpotJVMCI::resolve(object)));
1000   } else {
1001     JNIAccessMark jni(this);
1002     return wrap(jni()-&gt;NewLocalRef(object.as_jobject()));
1003   }
1004 }
1005 
1006 JVMCIObject JVMCIEnv::make_global(JVMCIObject object) {
1007   if (object.is_null()) {
1008     return JVMCIObject();
1009   }
1010   if (is_hotspot()) {
1011     return wrap(JNIHandles::make_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
1012   } else {
1013     JNIAccessMark jni(this);
1014     return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
1015   }
1016 }
1017 
1018 JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {
1019   if (object.is_null()) {
1020     return JVMCIObject();
1021   }
1022   if (is_hotspot()) {
1023     return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
1024   } else {
1025     JNIAccessMark jni(this);
1026     return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));
1027   }
1028 }
1029 
1030 void JVMCIEnv::destroy_local(JVMCIObject object) {
1031   if (is_hotspot()) {
1032     JNIHandles::destroy_local(object.as_jobject());
1033   } else {
1034     JNIAccessMark jni(this);
1035     jni()-&gt;DeleteLocalRef(object.as_jobject());
1036   }
1037 }
1038 
1039 void JVMCIEnv::destroy_global(JVMCIObject object) {
1040   if (is_hotspot()) {
1041     JNIHandles::destroy_global(object.as_jobject());
1042   } else {
1043     JNIAccessMark jni(this);
1044     jni()-&gt;DeleteGlobalRef(object.as_jobject());
1045   }
1046 }
1047 
1048 void JVMCIEnv::destroy_weak(JVMCIObject object) {
1049   if (is_hotspot()) {
1050     JNIHandles::destroy_weak_global(object.as_jweak());
1051   } else {
1052     JNIAccessMark jni(this);
1053     jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());
1054   }
1055 }
1056 
1057 const char* JVMCIEnv::klass_name(JVMCIObject object) {
1058   if (is_hotspot()) {
1059     return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
1060   } else {
1061     JVMCIObject name;
1062     {
1063       JNIAccessMark jni(this);
1064       jclass jcl = jni()-&gt;GetObjectClass(object.as_jobject());
1065       jobject result = jni()-&gt;CallObjectMethod(jcl, JNIJVMCI::Class_getName_method());
1066       name = JVMCIObject::create(result, is_hotspot());
1067     }
1068     return as_utf8_string(name);
1069   }
1070 }
1071 
1072 JVMCIObject JVMCIEnv::get_jvmci_method(const methodHandle&amp; method, JVMCI_TRAPS) {
1073   JVMCIObject method_object;
1074   if (method() == NULL) {
1075     return method_object;
1076   }
1077 
1078   Thread* THREAD = Thread::current();
1079   jmetadata handle = JVMCI::allocate_handle(method);
1080   jboolean exception = false;
1081   if (is_hotspot()) {
1082     JavaValue result(T_OBJECT);
1083     JavaCallArguments args;
1084     args.push_long((jlong) handle);
1085     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass(),
1086                            vmSymbols::fromMetaspace_name(),
1087                            vmSymbols::method_fromMetaspace_signature(), &amp;args, THREAD);
1088     if (HAS_PENDING_EXCEPTION) {
1089       exception = true;
1090     } else {
1091       method_object = wrap((oop)result.get_jobject());
1092     }
1093   } else {
1094     JNIAccessMark jni(this);
1095     method_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedJavaMethodImpl::clazz(),
1096                                                                   JNIJVMCI::HotSpotResolvedJavaMethodImpl_fromMetaspace_method(),
1097                                                                   (jlong) handle));
1098     exception = jni()-&gt;ExceptionCheck();
1099   }
1100 
1101   if (exception) {
1102     JVMCI::release_handle(handle);
1103     return JVMCIObject();
1104   }
1105 
1106   assert(asMethod(method_object) == method(), &quot;must be&quot;);
1107   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
1108     JVMCI::release_handle(handle);
1109   }
1110   assert(!method_object.is_null(), &quot;must be&quot;);
1111   return method_object;
1112 }
1113 
1114 JVMCIObject JVMCIEnv::get_jvmci_type(const JVMCIKlassHandle&amp; klass, JVMCI_TRAPS) {
1115   JVMCIObject type;
1116   if (klass.is_null()) {
1117     return type;
1118   }
1119 
1120   jlong pointer = (jlong) klass();
1121   JavaThread* THREAD = JavaThread::current();
1122   JVMCIObject signature = create_string(klass-&gt;signature_name(), JVMCI_CHECK_(JVMCIObject()));
1123   jboolean exception = false;
1124   if (is_hotspot()) {
1125     JavaValue result(T_OBJECT);
1126     JavaCallArguments args;
1127     args.push_long(pointer);
1128     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(signature)));
1129     JavaCalls::call_static(&amp;result,
1130                            HotSpotJVMCI::HotSpotResolvedObjectTypeImpl::klass(),
1131                            vmSymbols::fromMetaspace_name(),
1132                            vmSymbols::klass_fromMetaspace_signature(), &amp;args, THREAD);
1133 
1134     if (HAS_PENDING_EXCEPTION) {
1135       exception = true;
1136     } else {
1137       type = wrap((oop)result.get_jobject());
1138     }
1139   } else {
1140     JNIAccessMark jni(this);
1141 
1142     HandleMark hm(THREAD);
1143     type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
1144                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
1145                                                         pointer, signature.as_jstring()));
1146     exception = jni()-&gt;ExceptionCheck();
1147   }
1148   if (exception) {
1149     return JVMCIObject();
1150   }
1151 
1152   assert(type.is_non_null(), &quot;must have result&quot;);
1153   return type;
1154 }
1155 
1156 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
1157   JVMCIObject cp_object;
1158   jmetadata handle = JVMCI::allocate_handle(cp);
1159   jboolean exception = false;
1160   if (is_hotspot()) {
1161     JavaThread* THREAD = JavaThread::current();
1162     JavaValue result(T_OBJECT);
1163     JavaCallArguments args;
1164     args.push_long((jlong) handle);
1165     JavaCalls::call_static(&amp;result,
1166                            HotSpotJVMCI::HotSpotConstantPool::klass(),
1167                            vmSymbols::fromMetaspace_name(),
1168                            vmSymbols::constantPool_fromMetaspace_signature(), &amp;args, THREAD);
1169     if (HAS_PENDING_EXCEPTION) {
1170       exception = true;
1171     } else {
1172       cp_object = wrap((oop)result.get_jobject());
1173     }
1174   } else {
1175     JNIAccessMark jni(this);
1176     cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
1177                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
1178                                                              (jlong) handle));
1179     exception = jni()-&gt;ExceptionCheck();
1180   }
1181 
1182   if (exception) {
1183     JVMCI::release_handle(handle);
1184     return JVMCIObject();
1185   }
1186 
1187   assert(!cp_object.is_null(), &quot;must be&quot;);
1188   // Constant pools aren&#39;t cached so this is always a newly created object using the handle
1189   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, &quot;must use same handle&quot;);
1190   return cp_object;
1191 }
1192 
1193 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
1194   if (is_hotspot()) {
1195     JavaThread* THREAD = JavaThread::current();
1196     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
1197     return wrap(result);
1198   } else {
1199     JNIAccessMark jni(this);
1200     jbooleanArray result = jni()-&gt;NewBooleanArray(length);
1201     return wrap(result);
1202   }
1203 }
1204 
1205 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
1206   if (is_hotspot()) {
1207     JavaThread* THREAD = JavaThread::current();
1208     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
1209     return wrap(result);
1210   } else {
1211     JNIAccessMark jni(this);
1212     jbyteArray result = jni()-&gt;NewByteArray(length);
1213     return wrap(result);
1214   }
1215 }
1216 
1217 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
1218   if (is_hotspot()) {
1219     JavaThread* THREAD = JavaThread::current();
1220     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
1221     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
1222     return wrap(result);
1223   } else {
1224     JNIAccessMark jni(this);
1225     jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
1226     return wrap(result);
1227   }
1228 }
1229 
1230 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
1231   if (is_hotspot()) {
1232     JavaThread* THREAD = JavaThread::current();
1233     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
1234     return wrap(result);
1235   } else {
1236     JNIAccessMark jni(this);
1237     jintArray result = jni()-&gt;NewIntArray(length);
1238     return wrap(result);
1239   }
1240 }
1241 
1242 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
1243   if (is_hotspot()) {
1244     JavaThread* THREAD = JavaThread::current();
1245     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
1246     return wrap(result);
1247   } else {
1248     JNIAccessMark jni(this);
1249     jlongArray result = jni()-&gt;NewLongArray(length);
1250     return wrap(result);
1251   }
1252 }
1253 
1254 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
1255   if (is_hotspot()) {
1256     JavaThread* THREAD = JavaThread::current();
1257     HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1258     oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1259     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
1260     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
1261     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
1262     HotSpotJVMCI::VMField::set_address(this, obj, address);
1263     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
1264     return wrap(obj);
1265   } else {
1266     JNIAccessMark jni(this);
1267     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
1268                                     JNIJVMCI::VMField::constructor(),
1269                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
1270     return wrap(result);
1271   }
1272 }
1273 
1274 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
1275   if (is_hotspot()) {
1276     JavaThread* THREAD = JavaThread::current();
1277     HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1278     oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1279     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
1280     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
1281     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
1282     return wrap(obj);
1283   } else {
1284     JNIAccessMark jni(this);
1285     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
1286                                     JNIJVMCI::VMFlag::constructor(),
1287                                     get_jobject(name), get_jobject(type), get_jobject(value));
1288     return wrap(result);
1289   }
1290 }
1291 
1292 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
1293   if (is_hotspot()) {
1294     JavaThread* THREAD = JavaThread::current();
1295     HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1296     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1297     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
1298     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
1299     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
1300     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
1301     return wrap(obj);
1302   } else {
1303     JNIAccessMark jni(this);
1304     jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
1305                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
1306                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
1307     return wrap(result);
1308   }
1309 }
1310 
1311 JVMCIObject JVMCIEnv::new_HotSpotStackFrameReference(JVMCI_TRAPS) {
1312   if (is_hotspot()) {
1313     JavaThread* THREAD = JavaThread::current();
1314     HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1315     oop obj = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1316     return wrap(obj);
1317   } else {
1318     ShouldNotReachHere();
1319     return JVMCIObject();
1320   }
1321 }
1322 JVMCIObject JVMCIEnv::new_JVMCIError(JVMCI_TRAPS) {
1323   if (is_hotspot()) {
1324     JavaThread* THREAD = JavaThread::current();
1325     HotSpotJVMCI::JVMCIError::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1326     oop obj = HotSpotJVMCI::JVMCIError::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1327     return wrap(obj);
1328   } else {
1329     ShouldNotReachHere();
1330     return JVMCIObject();
1331   }
1332 }
1333 
1334 
1335 JVMCIObject JVMCIEnv::get_object_constant(oop objOop, bool compressed, bool dont_register) {
1336   JavaThread* THREAD = JavaThread::current();
1337   Handle obj = Handle(THREAD, objOop);
1338   if (obj.is_null()) {
1339     return JVMCIObject();
1340   }
1341   if (is_hotspot()) {
1342     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;initialize(CHECK_(JVMCIObject()));
1343     oop constant = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
1344     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
1345     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
1346     return wrap(constant);
1347   } else {
1348     jlong handle = make_handle(obj);
1349     JNIAccessMark jni(this);
1350     jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
1351                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
1352                                       handle, compressed, dont_register);
1353     return wrap(result);
1354   }
1355 }
1356 
1357 
1358 Handle JVMCIEnv::asConstant(JVMCIObject constant, JVMCI_TRAPS) {
1359   if (constant.is_null()) {
1360     return Handle();
1361   }
1362   JavaThread* THREAD = JavaThread::current();
1363   if (is_hotspot()) {
1364     assert(HotSpotJVMCI::DirectHotSpotObjectConstantImpl::is_instance(this, constant), &quot;wrong type&quot;);
1365     oop obj = HotSpotJVMCI::DirectHotSpotObjectConstantImpl::object(this, HotSpotJVMCI::resolve(constant));
1366     return Handle(THREAD, obj);
1367   } else if (isa_IndirectHotSpotObjectConstantImpl(constant)) {
1368     jlong object_handle = get_IndirectHotSpotObjectConstantImpl_objectHandle(constant);
1369     if (object_handle == 0L) {
1370       JVMCI_THROW_MSG_(NullPointerException, &quot;Foreign object reference has been cleared&quot;, Handle());
1371     }
1372     oop result = resolve_handle(object_handle);
1373     if (result == NULL) {
1374       JVMCI_THROW_MSG_(InternalError, &quot;Constant was unexpectedly NULL&quot;, Handle());
1375     }
1376     return Handle(THREAD, result);
1377   } else {
1378     JVMCI_THROW_MSG_(IllegalArgumentException, &quot;DirectHotSpotObjectConstantImpl shouldn&#39;t reach JVMCI in SVM mode&quot;, Handle());
1379   }
1380 }
1381 
1382 JVMCIObject JVMCIEnv::wrap(jobject object) {
1383   return JVMCIObject::create(object, is_hotspot());
1384 }
1385 
1386 jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
1387   assert(!obj.is_null(), &quot;should only create handle for non-NULL oops&quot;);
1388   jobject handle = JVMCI::make_global(obj);
1389   return (jlong) handle;
1390 }
1391 
1392 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
1393   assert(objectHandle != 0, &quot;should be a valid handle&quot;);
1394   oop obj = *((oopDesc**)objectHandle);
1395   if (obj != NULL) {
1396     oopDesc::verify(obj);
1397   }
1398   return obj;
1399 }
1400 
1401 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
1402   if (is_hotspot()) {
1403     JavaThread* THREAD = JavaThread::current();
1404     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
1405     return HotSpotJVMCI::wrap(result());
1406   } else {
1407     jobject result;
1408     jboolean exception = false;
1409     {
1410       JNIAccessMark jni(this);
1411       result = jni()-&gt;NewStringUTF(str);
1412       exception = jni()-&gt;ExceptionCheck();
1413     }
1414     return wrap(result);
1415   }
1416 }
1417 
1418 bool JVMCIEnv::equals(JVMCIObject a, JVMCIObject b) {
1419   if (is_hotspot()) {
1420     return HotSpotJVMCI::resolve(a) == HotSpotJVMCI::resolve(b);
1421   } else {
1422     JNIAccessMark jni(this);
1423     return jni()-&gt;IsSameObject(a.as_jobject(), b.as_jobject()) != 0;
1424   }
1425 }
1426 
1427 BasicType JVMCIEnv::kindToBasicType(JVMCIObject kind, JVMCI_TRAPS) {
1428   if (kind.is_null()) {
1429     JVMCI_THROW_(NullPointerException, T_ILLEGAL);
1430   }
1431   jchar ch = get_JavaKind_typeChar(kind);
1432   switch(ch) {
1433     case &#39;Z&#39;: return T_BOOLEAN;
1434     case &#39;B&#39;: return T_BYTE;
1435     case &#39;S&#39;: return T_SHORT;
1436     case &#39;C&#39;: return T_CHAR;
1437     case &#39;I&#39;: return T_INT;
1438     case &#39;F&#39;: return T_FLOAT;
1439     case &#39;J&#39;: return T_LONG;
1440     case &#39;D&#39;: return T_DOUBLE;
1441     case &#39;A&#39;: return T_OBJECT;
1442     case &#39;-&#39;: return T_ILLEGAL;
1443     default:
1444       JVMCI_ERROR_(T_ILLEGAL, &quot;unexpected Kind: %c&quot;, ch);
1445   }
1446 }
1447 
1448 void JVMCIEnv::initialize_installed_code(JVMCIObject installed_code, CodeBlob* cb, JVMCI_TRAPS) {
1449   // Ensure that all updates to the InstalledCode fields are consistent.
1450   if (get_InstalledCode_address(installed_code) != 0) {
1451     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance already in use&quot;);
1452   }
1453   if (!isa_HotSpotInstalledCode(installed_code)) {
1454     JVMCI_THROW_MSG(InternalError, &quot;InstalledCode instance must be a subclass of HotSpotInstalledCode&quot;);
1455   }
1456 
1457   // Ignore the version which can stay at 0
1458   if (cb-&gt;is_nmethod()) {
1459     nmethod* nm = cb-&gt;as_nmethod_or_null();
1460     if (!nm-&gt;is_alive()) {
1461       JVMCI_THROW_MSG(InternalError, &quot;nmethod has been reclaimed&quot;);
1462     }
1463     if (nm-&gt;is_in_use()) {
1464       set_InstalledCode_entryPoint(installed_code, (jlong) nm-&gt;verified_entry_point());
1465     }
1466   } else {
1467     set_InstalledCode_entryPoint(installed_code, (jlong) cb-&gt;code_begin());
1468   }
1469   set_InstalledCode_address(installed_code, (jlong) cb);
1470   set_HotSpotInstalledCode_size(installed_code, cb-&gt;size());
1471   set_HotSpotInstalledCode_codeStart(installed_code, (jlong) cb-&gt;code_begin());
1472   set_HotSpotInstalledCode_codeSize(installed_code, cb-&gt;code_size());
1473 }
1474 
1475 
1476 void JVMCIEnv::invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS) {
1477   if (mirror.is_null()) {
1478     JVMCI_THROW(NullPointerException);
1479   }
1480 
1481   nmethodLocker locker;
1482   nmethod* nm = JVMCIENV-&gt;get_nmethod(mirror, locker);
1483   if (nm == NULL) {
1484     // Nothing to do
1485     return;
1486   }
1487 
1488   Thread* THREAD = Thread::current();
1489   if (!mirror.is_hotspot() &amp;&amp; !THREAD-&gt;is_Java_thread()) {
1490     // Calling back into native might cause the execution to block, so only allow this when calling
1491     // from a JavaThread, which is the normal case anyway.
1492     JVMCI_THROW_MSG(IllegalArgumentException,
1493                     &quot;Cannot invalidate HotSpotNmethod object in shared library VM heap from non-JavaThread&quot;);
1494   }
1495 
1496   nmethodLocker nml(nm);
1497   if (nm-&gt;is_alive()) {
1498     // Invalidating the HotSpotNmethod means we want the nmethod to be deoptimized.
1499     Deoptimization::deoptimize_all_marked(nm);
1500   }
1501 
1502   // A HotSpotNmethod instance can only reference a single nmethod
1503   // during its lifetime so simply clear it here.
1504   set_InstalledCode_address(mirror, 0);
1505 }
1506 
1507 Klass* JVMCIEnv::asKlass(JVMCIObject obj) {
1508   return (Klass*) get_HotSpotResolvedObjectTypeImpl_metadataPointer(obj);
1509 }
1510 
1511 Method* JVMCIEnv::asMethod(JVMCIObject obj) {
1512   Method** metadataHandle = (Method**) get_HotSpotResolvedJavaMethodImpl_metadataHandle(obj);
1513   return *metadataHandle;
1514 }
1515 
1516 ConstantPool* JVMCIEnv::asConstantPool(JVMCIObject obj) {
1517   ConstantPool** metadataHandle = (ConstantPool**) get_HotSpotConstantPool_metadataHandle(obj);
1518   return *metadataHandle;
1519 }
1520 
1521 CodeBlob* JVMCIEnv::get_code_blob(JVMCIObject obj, nmethodLocker&amp; locker) {
1522   address code = (address) get_InstalledCode_address(obj);
1523   if (code == NULL) {
1524     return NULL;
1525   }
1526   if (isa_HotSpotNmethod(obj)) {
1527     nmethod* nm = NULL;
1528     {
1529       // Lookup the CodeBlob while holding the CodeCache_lock to ensure the nmethod can&#39;t be freed
1530       // by nmethod::flush while we&#39;re interrogating it.
1531       MutexLocker cm_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1532       CodeBlob* cb = CodeCache::find_blob_unsafe(code);
1533       if (cb == (CodeBlob*) code) {
1534         nmethod* the_nm = cb-&gt;as_nmethod_or_null();
1535         if (the_nm != NULL &amp;&amp; the_nm-&gt;is_alive()) {
1536           // Lock the nmethod to stop any further transitions by the sweeper.  It&#39;s still possible
1537           // for this code to execute in the middle of the sweeping of the nmethod but that will be
1538           // handled below.
1539           locker.set_code(nm, true);
1540           nm = the_nm;
1541         }
1542       }
1543     }
1544 
1545     if (nm != NULL) {
1546       // We found the nmethod but it could be in the process of being freed.  Check the state of the
1547       // nmethod while holding the CompiledMethod_lock.  This ensures that any transitions by other
1548       // threads have seen the is_locked_by_vm() update above.
1549       MutexLocker cm_lock(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
1550       if (!nm-&gt;is_alive()) {
1551         //  It was alive when we looked it up but it&#39;s no longer alive so release it.
1552         locker.set_code(NULL);
1553         nm = NULL;
1554       }
1555     }
1556 
1557     jlong compile_id_snapshot = get_HotSpotNmethod_compileIdSnapshot(obj);
1558     if (compile_id_snapshot != 0L) {
1559       // Found a live nmethod with the same address, make sure it&#39;s the same nmethod
1560       if (nm == (nmethod*) code &amp;&amp; nm-&gt;compile_id() == compile_id_snapshot &amp;&amp; nm-&gt;is_alive()) {
1561         if (nm-&gt;is_not_entrant()) {
1562           // Zero the entry point so that the nmethod
1563           // cannot be invoked by the mirror but can
1564           // still be deoptimized.
1565           set_InstalledCode_entryPoint(obj, 0);
1566         }
1567         return nm;
1568       }
1569       // The HotSpotNmethod no longer refers to a valid nmethod so clear the state
1570       locker.set_code(NULL);
1571       nm = NULL;
1572     }
1573 
1574     if (nm == NULL) {
1575       // The HotSpotNmethod was pointing at some nmethod but the nmethod is no longer valid, so
1576       // clear the InstalledCode fields of this HotSpotNmethod so that it no longer refers to a
1577       // nmethod in the code cache.
1578       set_InstalledCode_address(obj, 0);
1579       set_InstalledCode_entryPoint(obj, 0);
1580     }
1581     return nm;
1582   }
1583 
1584   CodeBlob* cb = (CodeBlob*) code;
1585   assert(!cb-&gt;is_nmethod(), &quot;unexpected nmethod&quot;);
1586   return cb;
1587 }
1588 
1589 nmethod* JVMCIEnv::get_nmethod(JVMCIObject obj, nmethodLocker&amp; locker) {
1590   CodeBlob* cb = get_code_blob(obj, locker);
1591   if (cb != NULL) {
1592     return cb-&gt;as_nmethod_or_null();
1593   }
1594   return NULL;
1595 }
1596 
1597 // Generate implementations for the initialize, new, isa, get and set methods for all the types and
1598 // fields declared in the JVMCI_CLASSES_DO macro.
1599 
1600 #define START_CLASS(className, fullClassName)                                                                        \
1601   void JVMCIEnv::className##_initialize(JVMCI_TRAPS) {                                                               \
1602     if (is_hotspot()) {                                                                                              \
1603       HotSpotJVMCI::className::initialize(JVMCI_CHECK);                                                              \
1604     } else {                                                                                                         \
1605       JNIJVMCI::className::initialize(JVMCI_CHECK);                                                                  \
1606     }                                                                                                                \
1607   }                                                                                                                  \
1608   JVMCIObjectArray JVMCIEnv::new_##className##_array(int length, JVMCI_TRAPS) {                                      \
1609     if (is_hotspot()) {                                                                                              \
1610       Thread* THREAD = Thread::current();                                                                            \
1611       objArrayOop array = oopFactory::new_objArray(HotSpotJVMCI::className::klass(), length, CHECK_(JVMCIObject())); \
1612       return (JVMCIObjectArray) wrap(array);                                                                         \
1613     } else {                                                                                                         \
1614       JNIAccessMark jni(this);                                                                                       \
1615       jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::className::clazz(), NULL);                       \
1616       return wrap(result);                                                                                           \
1617     }                                                                                                                \
1618   }                                                                                                                  \
1619   bool JVMCIEnv::isa_##className(JVMCIObject object) {                                                               \
1620     if (is_hotspot()) {                                                                                              \
1621       return HotSpotJVMCI::className::is_instance(this, object);                                                     \
1622     } else {                                                                                                         \
1623       return JNIJVMCI::className::is_instance(this, object);                                                         \
1624     }                                                                                                                \
1625   }
1626 
1627 #define END_CLASS
1628 
1629 #define FIELD(className, name, type, accessor, cast)                 \
1630   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {         \
1631     if (is_hotspot()) {                                              \
1632       return HotSpotJVMCI::className::get_##name(this, obj);         \
1633     } else {                                                         \
1634       return JNIJVMCI::className::get_##name(this, obj);             \
1635     }                                                                \
1636   }                                                                  \
1637   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) { \
1638     if (is_hotspot()) {                                              \
1639       HotSpotJVMCI::className::set_##name(this, obj, x);             \
1640     } else {                                                         \
1641       JNIJVMCI::className::set_##name(this, obj, x);                 \
1642     }                                                                \
1643   }
1644 
1645 #define EMPTY_CAST
1646 #define CHAR_FIELD(className, name)                    FIELD(className, name, jchar, Char, EMPTY_CAST)
1647 #define INT_FIELD(className, name)                     FIELD(className, name, jint, Int, EMPTY_CAST)
1648 #define BOOLEAN_FIELD(className, name)                 FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1649 #define LONG_FIELD(className, name)                    FIELD(className, name, jlong, Long, EMPTY_CAST)
1650 #define FLOAT_FIELD(className, name)                   FIELD(className, name, jfloat, Float, EMPTY_CAST)
1651 
1652 #define OBJECT_FIELD(className, name, signature)              OOPISH_FIELD(className, name, JVMCIObject, Object, EMPTY_CAST)
1653 #define OBJECTARRAY_FIELD(className, name, signature)         OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1654 #define PRIMARRAY_FIELD(className, name, signature)           OOPISH_FIELD(className, name, JVMCIPrimitiveArray, Object, (JVMCIPrimitiveArray))
1655 
1656 #define STATIC_OBJECT_FIELD(className, name, signature)       STATIC_OOPISH_FIELD(className, name, JVMCIObject, Object, (JVMCIObject))
1657 #define STATIC_OBJECTARRAY_FIELD(className, name, signature)  STATIC_OOPISH_FIELD(className, name, JVMCIObjectArray, Object, (JVMCIObjectArray))
1658 
1659 #define OOPISH_FIELD(className, name, type, accessor, cast)           \
1660   type JVMCIEnv::get_##className##_##name(JVMCIObject obj) {          \
1661     if (is_hotspot()) {                                               \
1662       return HotSpotJVMCI::className::get_##name(this, obj);          \
1663     } else {                                                          \
1664       return JNIJVMCI::className::get_##name(this, obj);              \
1665     }                                                                 \
1666   }                                                                   \
1667   void JVMCIEnv::set_##className##_##name(JVMCIObject obj, type x) {  \
1668     if (is_hotspot()) {                                               \
1669       HotSpotJVMCI::className::set_##name(this, obj, x);              \
1670     } else {                                                          \
1671       JNIJVMCI::className::set_##name(this, obj, x);                  \
1672     }                                                                 \
1673   }
1674 
1675 #define STATIC_OOPISH_FIELD(className, name, type, accessor, cast)    \
1676   type JVMCIEnv::get_##className##_##name() {                         \
1677     if (is_hotspot()) {                                               \
1678       return HotSpotJVMCI::className::get_##name(this);               \
1679     } else {                                                          \
1680       return JNIJVMCI::className::get_##name(this);                   \
1681     }                                                                 \
1682   }                                                                   \
1683   void JVMCIEnv::set_##className##_##name(type x) {                   \
1684     if (is_hotspot()) {                                               \
1685       HotSpotJVMCI::className::set_##name(this, x);                   \
1686     } else {                                                          \
1687       JNIJVMCI::className::set_##name(this, x);                       \
1688     }                                                                 \
1689   }
1690 
1691 #define STATIC_PRIMITIVE_FIELD(className, name, type, accessor, cast) \
1692   type JVMCIEnv::get_##className##_##name() {                         \
1693     if (is_hotspot()) {                                               \
1694       return HotSpotJVMCI::className::get_##name(this);               \
1695     } else {                                                          \
1696       return JNIJVMCI::className::get_##name(this);                   \
1697     }                                                                 \
1698   }                                                                   \
1699   void JVMCIEnv::set_##className##_##name(type x) {                   \
1700     if (is_hotspot()) {                                               \
1701       HotSpotJVMCI::className::set_##name(this, x);                   \
1702     } else {                                                          \
1703       JNIJVMCI::className::set_##name(this, x);                       \
1704     }                                                                 \
1705   }
1706 #define STATIC_INT_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jint, Int, EMPTY_CAST)
1707 #define STATIC_BOOLEAN_FIELD(className, name) STATIC_PRIMITIVE_FIELD(className, name, jboolean, Boolean, EMPTY_CAST)
1708 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args)
1709 #define CONSTRUCTOR(className, signature)
1710 
1711 JVMCI_CLASSES_DO(START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
1712 
1713 #undef START_CLASS
1714 #undef END_CLASS
1715 #undef METHOD
1716 #undef CONSTRUCTOR
1717 #undef FIELD
1718 #undef CHAR_FIELD
1719 #undef INT_FIELD
1720 #undef BOOLEAN_FIELD
1721 #undef LONG_FIELD
1722 #undef FLOAT_FIELD
1723 #undef OBJECT_FIELD
1724 #undef PRIMARRAY_FIELD
1725 #undef OBJECTARRAY_FIELD
1726 #undef STATIC_OOPISH_FIELD
1727 #undef STATIC_OBJECT_FIELD
1728 #undef STATIC_OBJECTARRAY_FIELD
1729 #undef STATIC_INT_FIELD
1730 #undef STATIC_BOOLEAN_FIELD
1731 #undef EMPTY_CAST
    </pre>
  </body>
</html>