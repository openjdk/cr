<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
<a name="1" id="anc1"></a><span class="line-added">  53 import jdk.internal.access.JavaUtilZipFileAccess;</span>
<span class="line-added">  54 import jdk.internal.access.SharedSecrets;</span>
  55 import jdk.security.jarsigner.JarSigner;
  56 import jdk.security.jarsigner.JarSignerException;
  57 import sun.security.pkcs.PKCS7;
  58 import sun.security.pkcs.SignerInfo;
  59 import sun.security.timestamp.TimestampToken;
  60 import sun.security.tools.KeyStoreUtil;
  61 import sun.security.validator.Validator;
  62 import sun.security.validator.ValidatorException;
  63 import sun.security.x509.*;
  64 import sun.security.util.*;
  65 
  66 
  67 /**
  68  * &lt;p&gt;The jarsigner utility.
  69  *
  70  * The exit codes for the main method are:
  71  *
  72  * 0: success
  73  * 1: any error that the jar cannot be signed or verified, including:
  74  *      keystore loading error
  75  *      TSP communication error
  76  *      jarsigner command line error...
  77  * otherwise: error codes from -strict
  78  *
  79  * @author Roland Schemers
  80  * @author Jan Luehe
  81  */
  82 public class Main {
  83 
  84     // for i18n
  85     private static final java.util.ResourceBundle rb =
  86         java.util.ResourceBundle.getBundle
  87         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  88     private static final Collator collator = Collator.getInstance();
  89     static {
  90         // this is for case insensitive string comparisions
  91         collator.setStrength(Collator.PRIMARY);
  92     }
  93 
  94     private static final String NONE = &quot;NONE&quot;;
  95     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  96 
  97     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  98     private static final long ONE_YEAR = 366*24*60*60*1000L;
  99 
 100     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 101             new DisabledAlgorithmConstraints(
 102                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 103 
 104     private static final DisabledAlgorithmConstraints LEGACY_CHECK =
 105             new DisabledAlgorithmConstraints(
 106                     DisabledAlgorithmConstraints.PROPERTY_SECURITY_LEGACY_ALGS);
 107 
 108     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 109             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 110     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 111             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 112 
<a name="2" id="anc2"></a><span class="line-added"> 113     private static boolean permsDetected;</span>
<span class="line-added"> 114 </span>
 115     static final String VERSION = &quot;1.0&quot;;
 116 
 117     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 118     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 119     // signer is not in alias list
 120     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 121 
<a name="3" id="anc3"></a><span class="line-added"> 122     static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();</span>
<span class="line-added"> 123 </span>
 124     // Attention:
 125     // This is the entry that get launched by the security tool jarsigner.
 126     public static void main(String args[]) throws Exception {
 127         Main js = new Main();
 128         js.run(args);
 129     }
 130 
 131     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 132     PrivateKey privateKey;          // private key
 133     KeyStore store;                 // the keystore specified by -keystore
 134                                     // or the default keystore, never null
 135 
 136     String keystore; // key store file
 137     boolean nullStream = false; // null keystore input stream (NONE)
 138     boolean token = false; // token-based keystore
 139     String jarfile;  // jar files to sign or verify
 140     String alias;    // alias to sign jar with
 141     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 142     char[] storepass; // keystore password
 143     boolean protectedPath; // protected authentication path
 144     String storetype; // keystore type
 145     String providerName; // provider name
 146     List&lt;String&gt; providers = null; // list of provider names
 147     List&lt;String&gt; providerClasses = null; // list of provider classes
 148     // arguments for provider constructors
 149     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 150     char[] keypass; // private key password
 151     String sigfile; // name of .SF file
 152     String sigalg; // name of signature algorithm
 153     String digestalg; // name of digest algorithm
 154     String signedjar; // output filename
 155     String tsaUrl; // location of the Timestamping Authority
 156     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 157     String altCertChain; // file to read alternative cert chain from
 158     String tSAPolicyID;
 159     String tSADigestAlg;
 160     boolean verify = false; // verify the jar
 161     String verbose = null; // verbose output when signing/verifying
 162     boolean showcerts = false; // show certs when verifying
 163     boolean debug = false; // debug
 164     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 165     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 166     boolean strict = false;  // treat warnings as error
 167     boolean revocationCheck = false; // Revocation check flag
 168 
 169     // read zip entry raw bytes
 170     private String altSignerClass = null;
 171     private String altSignerClasspath = null;
 172     private ZipFile zipFile = null;
 173 
 174     // Informational warnings
 175     private boolean hasExpiringCert = false;
 176     private boolean hasExpiringTsaCert = false;
 177     private boolean noTimestamp = true;
 178 
 179     // Expiration date. The value could be null if signed by a trusted cert.
 180     private Date expireDate = null;
 181     private Date tsaExpireDate = null;
 182 
 183     // If there is a time stamp block inside the PKCS7 block file
 184     boolean hasTimestampBlock = false;
 185 
 186     private PublicKey weakPublicKey = null;
 187     private boolean disabledAlgFound = false;
 188     private String legacyDigestAlg = null;
 189     private String legacyTsaDigestAlg = null;
 190     private String legacySigAlg = null;
 191 
 192     // Severe warnings.
 193 
 194     // jarsigner used to check signer cert chain validity and key usages
 195     // itself and set various warnings. Later CertPath validation is
 196     // added but chainNotValidated is only flagged when no other existing
 197     // warnings are set. TSA cert chain check is added separately and
 198     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 199     // notYetValidCert, or any badXyzUsage.
 200 
 201     private int legacyAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 202     private int disabledAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg, 8. key
 203     private boolean hasExpiredCert = false;
 204     private boolean hasExpiredTsaCert = false;
 205     private boolean notYetValidCert = false;
 206     private boolean chainNotValidated = false;
 207     private boolean tsaChainNotValidated = false;
 208     private boolean notSignedByAlias = false;
 209     private boolean aliasNotInStore = false;
 210     private boolean hasUnsignedEntry = false;
 211     private boolean badKeyUsage = false;
 212     private boolean badExtendedKeyUsage = false;
 213     private boolean badNetscapeCertType = false;
 214     private boolean signerSelfSigned = false;
 215 
 216     private Throwable chainNotValidatedReason = null;
 217     private Throwable tsaChainNotValidatedReason = null;
 218 
 219     PKIXBuilderParameters pkixParameters;
 220     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 221 
 222     public void run(String args[]) {
 223         try {
 224             args = parseArgs(args);
 225 
 226             // Try to load and install the specified providers
 227             if (providers != null) {
 228                 for (String provName: providers) {
 229                     try {
 230                         KeyStoreUtil.loadProviderByName(provName,
 231                                 providerArgs.get(provName));
 232                         if (debug) {
 233                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 234                         }
 235                     } catch (IllegalArgumentException e) {
 236                         throw new Exception(String.format(rb.getString(
 237                                 &quot;provider.name.not.found&quot;), provName));
 238                     }
 239                 }
 240             }
 241 
 242             if (providerClasses != null) {
 243                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 244                 for (String provClass: providerClasses) {
 245                     try {
 246                         KeyStoreUtil.loadProviderByClass(provClass,
 247                                 providerArgs.get(provClass), cl);
 248                         if (debug) {
 249                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 250                         }
 251                     } catch (ClassCastException cce) {
 252                         throw new Exception(String.format(rb.getString(
 253                                 &quot;provclass.not.a.provider&quot;), provClass));
 254                     } catch (IllegalArgumentException e) {
 255                         throw new Exception(String.format(rb.getString(
 256                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 257                     }
 258                 }
 259             }
 260 
 261             if (verify) {
 262                 try {
 263                     loadKeyStore(keystore, false);
 264                 } catch (Exception e) {
 265                     if ((keystore != null) || (storepass != null)) {
 266                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 267                                         e.getMessage());
 268                         if (debug) {
 269                             e.printStackTrace();
 270                         }
 271                         System.exit(1);
 272                     }
 273                 }
 274                 /*              if (debug) {
 275                     SignatureFileVerifier.setDebug(true);
 276                     ManifestEntryVerifier.setDebug(true);
 277                 }
 278                 */
 279                 verifyJar(jarfile);
 280             } else {
 281                 loadKeyStore(keystore, true);
 282                 getAliasInfo(alias);
 283 
 284                 signJar(jarfile, alias);
 285             }
 286         } catch (Exception e) {
 287             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 288             if (debug) {
 289                 e.printStackTrace();
 290             }
 291             System.exit(1);
 292         } finally {
 293             // zero-out private key password
 294             if (keypass != null) {
 295                 Arrays.fill(keypass, &#39; &#39;);
 296                 keypass = null;
 297             }
 298             // zero-out keystore password
 299             if (storepass != null) {
 300                 Arrays.fill(storepass, &#39; &#39;);
 301                 storepass = null;
 302             }
<a name="4" id="anc4"></a><span class="line-modified"> 303             Event.clearReportListener(Event.ReporterCategory.CRLCHECK);</span>
 304         }
 305 
 306         if (strict) {
 307             int exitCode = 0;
 308             if (disabledAlg != 0 || chainNotValidated || hasExpiredCert
 309                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 310                 exitCode |= 4;
 311             }
 312             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 313                 exitCode |= 8;
 314             }
 315             if (hasUnsignedEntry) {
 316                 exitCode |= 16;
 317             }
 318             if (notSignedByAlias || aliasNotInStore) {
 319                 exitCode |= 32;
 320             }
 321             if (tsaChainNotValidated) {
 322                 exitCode |= 64;
 323             }
 324             if (exitCode != 0) {
 325                 System.exit(exitCode);
 326             }
 327         }
 328     }
 329 
 330     /*
 331      * Parse command line arguments.
 332      */
 333     String[] parseArgs(String args[]) throws Exception {
 334         /* parse flags */
 335         int n = 0;
 336 
 337         if (args.length == 0) fullusage();
 338 
 339         String confFile = null;
 340         String command = &quot;-sign&quot;;
 341         for (n=0; n &lt; args.length; n++) {
 342             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 343                 command = &quot;-verify&quot;;
 344             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 345                 if (n == args.length - 1) {
 346                     usageNoArg();
 347                 }
 348                 confFile = args[++n];
 349             }
 350         }
 351 
 352         if (confFile != null) {
 353             args = KeyStoreUtil.expandArgs(
 354                     &quot;jarsigner&quot;, confFile, command, null, args);
 355         }
 356 
 357         debug = Arrays.stream(args).anyMatch(
 358                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 359 
 360         if (debug) {
 361             // No need to localize debug output
 362             System.out.println(&quot;Command line args: &quot; +
 363                     Arrays.toString(args));
 364         }
 365 
 366         for (n=0; n &lt; args.length; n++) {
 367 
 368             String flags = args[n];
 369             String modifier = null;
 370 
 371             if (flags.startsWith(&quot;-&quot;)) {
 372                 int pos = flags.indexOf(&#39;:&#39;);
 373                 if (pos &gt; 0) {
 374                     modifier = flags.substring(pos+1);
 375                     flags = flags.substring(0, pos);
 376                 }
 377             }
 378 
 379             if (!flags.startsWith(&quot;-&quot;)) {
 380                 if (jarfile == null) {
 381                     jarfile = flags;
 382                 } else {
 383                     alias = flags;
 384                     ckaliases.add(alias);
 385                 }
 386             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 387                 if (++n == args.length) usageNoArg();
 388             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 389                 if (++n == args.length) usageNoArg();
 390                 keystore = args[n];
 391             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 392                 if (++n == args.length) usageNoArg();
 393                 storepass = getPass(modifier, args[n]);
 394             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 395                 if (++n == args.length) usageNoArg();
 396                 storetype = args[n];
 397             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 398                 if (++n == args.length) usageNoArg();
 399                 providerName = args[n];
 400             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 401                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 402                 if (++n == args.length) usageNoArg();
 403                 if (providerClasses == null) {
 404                     providerClasses = new ArrayList&lt;&gt;(3);
 405                 }
 406                 providerClasses.add(args[n]);
 407 
 408                 if (args.length &gt; (n+1)) {
 409                     flags = args[n+1];
 410                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 411                         if (args.length == (n+2)) usageNoArg();
 412                         providerArgs.put(args[n], args[n+2]);
 413                         n += 2;
 414                     }
 415                 }
 416             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 417                 if (++n == args.length) usageNoArg();
 418                 if (providers == null) {
 419                     providers = new ArrayList&lt;&gt;(3);
 420                 }
 421                 providers.add(args[n]);
 422 
 423                 if (args.length &gt; (n+1)) {
 424                     flags = args[n+1];
 425                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 426                         if (args.length == (n+2)) usageNoArg();
 427                         providerArgs.put(args[n], args[n+2]);
 428                         n += 2;
 429                     }
 430                 }
 431             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 432                 protectedPath = true;
 433             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 434                 if (++n == args.length) usageNoArg();
 435                 altCertChain = args[n];
 436             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 437                 if (++n == args.length) usageNoArg();
 438                 tSAPolicyID = args[n];
 439             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 440                 if (++n == args.length) usageNoArg();
 441                 tSADigestAlg = args[n];
 442             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 443                 // Already processed
 444             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 445                 if (++n == args.length) usageNoArg();
 446                 keypass = getPass(modifier, args[n]);
 447             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 448                 if (++n == args.length) usageNoArg();
 449                 sigfile = args[n];
 450             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 451                 if (++n == args.length) usageNoArg();
 452                 signedjar = args[n];
 453             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 454                 if (++n == args.length) usageNoArg();
 455                 tsaUrl = args[n];
 456             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 457                 if (++n == args.length) usageNoArg();
 458                 tsaAlias = args[n];
 459             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 460                 if (++n == args.length) usageNoArg();
 461                 altSignerClass = args[n];
 462                 System.err.println(
 463                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 464                                 &quot;-altsigner&quot;);
 465             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 466                 if (++n == args.length) usageNoArg();
 467                 altSignerClasspath = args[n];
 468                 System.err.println(
 469                         rb.getString(&quot;This.option.is.forremoval&quot;) +
 470                                 &quot;-altsignerpath&quot;);
 471             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 472                 signManifest = false;
 473             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 474                 externalSF = false;
 475             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 476                 verify = true;
 477             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 478                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 479             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 480                 if (++n == args.length) usageNoArg();
 481                 sigalg = args[n];
 482             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 483                 if (++n == args.length) usageNoArg();
 484                 digestalg = args[n];
 485             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 486                 showcerts = true;
 487             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 488                 strict = true;
 489             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 490                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 491                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 492                        // -help: legacy.
 493                        collator.compare(flags, &quot;-help&quot;) == 0) {
 494                 fullusage();
 495             } else if (collator.compare(flags, &quot;-revCheck&quot;) == 0) {
 496                 revocationCheck = true;
 497             } else {
 498                 System.err.println(
 499                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 500                 usage();
 501             }
 502         }
 503 
 504         // -certs must always be specified with -verbose
 505         if (verbose == null) showcerts = false;
 506 
 507         if (jarfile == null) {
 508             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 509             usage();
 510         }
 511         if (!verify &amp;&amp; alias == null) {
 512             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 513             usage();
 514         }
 515         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 516             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 517             usage();
 518         }
 519 
 520         if (storetype == null) {
 521             storetype = KeyStore.getDefaultType();
 522         }
 523         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 524 
 525         try {
 526             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 527                     new File(jarfile).getCanonicalPath())) {
 528                 signedjar = null;
 529             }
 530         } catch (IOException ioe) {
 531             // File system error?
 532             // Just ignore it.
 533         }
 534 
 535         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 536                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 537             token = true;
 538             if (keystore == null) {
 539                 keystore = NONE;
 540             }
 541         }
 542 
 543         if (NONE.equals(keystore)) {
 544             nullStream = true;
 545         }
 546 
 547         if (token &amp;&amp; !nullStream) {
 548             System.err.println(MessageFormat.format(rb.getString
 549                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 550             usage();
 551         }
 552 
 553         if (token &amp;&amp; keypass != null) {
 554             System.err.println(MessageFormat.format(rb.getString
 555                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 556             usage();
 557         }
 558 
 559         if (protectedPath) {
 560             if (storepass != null || keypass != null) {
 561                 System.err.println(rb.getString
 562                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 563                 usage();
 564             }
 565         }
 566         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 567             if (storepass != null || keypass != null) {
 568                 System.err.println(rb.getString
 569                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 570                 usage();
 571             }
 572         }
 573         return args;
 574     }
 575 
 576     static char[] getPass(String modifier, String arg) {
 577         char[] output =
 578             KeyStoreUtil.getPassWithModifier(modifier, arg, rb, collator);
 579         if (output != null) return output;
 580         usage();
 581         return null;    // Useless, usage() already exit
 582     }
 583 
 584     static void usageNoArg() {
 585         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 586         usage();
 587     }
 588 
 589     static void usage() {
 590         System.out.println();
 591         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 592         System.exit(1);
 593     }
 594 
 595     static void fullusage() {
 596         System.out.println(rb.getString
 597                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 598         System.out.println(rb.getString
 599                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 600         System.out.println();
 601         System.out.println(rb.getString
 602                 (&quot;.keystore.url.keystore.location&quot;));
 603         System.out.println();
 604         System.out.println(rb.getString
 605                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 606         System.out.println();
 607         System.out.println(rb.getString
 608                 (&quot;.storetype.type.keystore.type&quot;));
 609         System.out.println();
 610         System.out.println(rb.getString
 611                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 612         System.out.println();
 613         System.out.println(rb.getString
 614                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 615         System.out.println();
 616         System.out.println(rb.getString
 617                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 618         System.out.println();
 619         System.out.println(rb.getString
 620                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 621         System.out.println();
 622         System.out.println(rb.getString
 623                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 624         System.out.println();
 625         System.out.println(rb.getString
 626                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 627         System.out.println();
 628         System.out.println(rb.getString
 629                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 630         System.out.println();
 631         System.out.println(rb.getString
 632                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 633         System.out.println(rb.getString
 634                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 635         System.out.println();
 636         System.out.println(rb.getString
 637                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 638         System.out.println();
 639         System.out.println(rb.getString
 640                 (&quot;.certs.revocation.check&quot;));
 641         System.out.println();
 642         System.out.println(rb.getString
 643                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 644         System.out.println();
 645         System.out.println(rb.getString
 646                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 647         System.out.println();
 648         System.out.println(rb.getString
 649                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 650         System.out.println();
 651         System.out.println(rb.getString
 652                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 653         System.out.println();
 654         System.out.println(rb.getString
 655                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 656         System.out.println();
 657         System.out.println(rb.getString
 658                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 659         System.out.println();
 660         System.out.println(rb.getString
 661                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 662         System.out.println();
 663         System.out.println(rb.getString
 664                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 665         System.out.println();
 666         System.out.println(rb.getString
 667                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 668         System.out.println();
 669         System.out.println(rb.getString
 670                 (&quot;.providerName.name.provider.name&quot;));
 671         System.out.println();
 672         System.out.println(rb.getString
 673                 (&quot;.add.provider.option&quot;));
 674         System.out.println(rb.getString
 675                 (&quot;.providerArg.option.1&quot;));
 676         System.out.println();
 677         System.out.println(rb.getString
 678                 (&quot;.providerClass.option&quot;));
 679         System.out.println(rb.getString
 680                 (&quot;.providerArg.option.2&quot;));
 681         System.out.println();
 682         System.out.println(rb.getString
 683                 (&quot;.strict.treat.warnings.as.errors&quot;));
 684         System.out.println();
 685         System.out.println(rb.getString
 686                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 687         System.out.println();
 688         System.out.println(rb.getString
 689                 (&quot;.print.this.help.message&quot;));
 690         System.out.println();
 691 
 692         System.exit(0);
 693     }
 694 
 695     void verifyJar(String jarName)
 696         throws Exception
 697     {
 698         boolean anySigned = false;  // if there exists entry inside jar signed
 699         JarFile jf = null;
 700         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 701         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 702         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 703         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 704 
 705         try {
 706             jf = new JarFile(jarName, true);
 707             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 708             byte[] buffer = new byte[8192];
 709 
 710             String suffix1 = &quot;-Digest-Manifest&quot;;
 711             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;
 712 
 713             int suffixLength1 = suffix1.length();
 714             int suffixLength2 = suffix2.length();
 715 
 716             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 717             while (entries.hasMoreElements()) {
 718                 JarEntry je = entries.nextElement();
 719                 entriesVec.addElement(je);
 720                 try (InputStream is = jf.getInputStream(je)) {
 721                     String name = je.getName();
 722                     if (signatureRelated(name)
 723                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 724                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 725                                 name.lastIndexOf(&#39;.&#39;));
 726                         try {
 727                             if (name.endsWith(&quot;.SF&quot;)) {
 728                                 Manifest sf = new Manifest(is);
 729                                 boolean found = false;
 730                                 for (Object obj : sf.getMainAttributes().keySet()) {
 731                                     String key = obj.toString();
 732                                     if (key.endsWith(suffix1)) {
 733                                         digestMap.put(alias, key.substring(
 734                                                 0, key.length() - suffixLength1));
 735                                         found = true;
 736                                         break;
 737                                     } else if (key.endsWith(suffix2)) {
 738                                         digestMap.put(alias, key.substring(
 739                                                 0, key.length() - suffixLength2));
 740                                         found = true;
 741                                         break;
 742                                     }
 743                                 }
 744                                 if (!found) {
 745                                     unparsableSignatures.putIfAbsent(alias,
 746                                         String.format(
 747                                             rb.getString(&quot;history.unparsable&quot;),
 748                                             name));
 749                                 }
 750                             } else {
 751                                 sigNameMap.put(alias, name);
 752                                 sigMap.put(alias, new PKCS7(is));
 753                             }
 754                         } catch (IOException ioe) {
 755                             unparsableSignatures.putIfAbsent(alias, String.format(
 756                                     rb.getString(&quot;history.unparsable&quot;), name));
 757                         }
 758                     } else {
 759                         while (is.read(buffer, 0, buffer.length) != -1) {
 760                             // we just read. this will throw a SecurityException
 761                             // if  a signature/digest check fails.
 762                         }
 763                     }
 764                 }
 765             }
 766 
 767             Manifest man = jf.getManifest();
 768             boolean hasSignature = false;
 769 
 770             // The map to record display info, only used when -verbose provided
 771             //      key: signer info string
 772             //      value: the list of files with common key
 773             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 774 
 775             if (man != null) {
 776                 if (verbose != null) System.out.println();
 777                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 778 
 779                 String tab = rb.getString(&quot;6SPACE&quot;);
 780 
 781                 while (e.hasMoreElements()) {
 782                     JarEntry je = e.nextElement();
 783                     String name = je.getName();
 784 
<a name="5" id="anc5"></a><span class="line-added"> 785                     if (!permsDetected &amp;&amp; JUZFA.getPosixPerms(je) != -1) {</span>
<span class="line-added"> 786                         permsDetected = true;</span>
<span class="line-added"> 787                     }</span>
 788                     hasSignature = hasSignature
 789                             || SignatureFileVerifier.isBlockOrSF(name);
 790 
 791                     CodeSigner[] signers = je.getCodeSigners();
 792                     boolean isSigned = (signers != null);
 793                     anySigned |= isSigned;
 794                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 795                                         &amp;&amp; !signatureRelated(name);
 796 
 797                     int inStoreWithAlias = inKeyStore(signers);
 798 
 799                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 800 
 801                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 802                     if (keystore != null) {
 803                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 804                     }
 805 
 806                     // Only used when -verbose provided
 807                     StringBuffer sb = null;
 808                     if (verbose != null) {
 809                         sb = new StringBuffer();
 810                         boolean inManifest =
 811                             ((man.getAttributes(name) != null) ||
 812                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 813                              (man.getAttributes(&quot;/&quot;+name) != null));
 814                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 815                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 816                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 817                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 818                                 .append(rb.getString(&quot;SPACE&quot;));
 819                         sb.append(&#39;|&#39;);
 820                     }
 821 
 822                     // When -certs provided, display info has extra empty
 823                     // lines at the beginning and end.
 824                     if (isSigned) {
 825                         if (showcerts) sb.append(&#39;\n&#39;);
 826                         for (CodeSigner signer: signers) {
 827                             // signerInfo() must be called even if -verbose
 828                             // not provided. The method updates various
 829                             // warning flags.
 830                             String si = signerInfo(signer, tab);
 831                             if (showcerts) {
 832                                 sb.append(si);
 833                                 sb.append(&#39;\n&#39;);
 834                             }
 835                         }
 836                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 837                         // Print no info for unsigned entries when -verbose:all,
 838                         // to be consistent with old behavior.
 839                         if (signatureRelated(name)) {
 840                             sb.append(&#39;\n&#39;)
 841                                     .append(tab)
 842                                     .append(rb
 843                                             .getString(&quot;.Signature.related.entries.&quot;))
 844                                     .append(&quot;\n\n&quot;);
 845                         } else {
 846                             sb.append(&#39;\n&#39;).append(tab)
 847                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 848                                     .append(&quot;\n\n&quot;);
 849                         }
 850                     }
 851 
 852                     if (verbose != null) {
 853                         String label = sb.toString();
 854                         if (signatureRelated(name)) {
 855                             // Entries inside META-INF and other unsigned
 856                             // entries are grouped separately.
 857                             label = &quot;-&quot; + label;
 858                         }
 859 
 860                         // The label finally contains 2 parts separated by &#39;|&#39;:
 861                         // The legend displayed before the entry names, and
 862                         // the cert info (if -certs specified).
 863 
 864                         if (!output.containsKey(label)) {
 865                             output.put(label, new ArrayList&lt;String&gt;());
 866                         }
 867 
 868                         StringBuilder fb = new StringBuilder();
 869                         String s = Long.toString(je.getSize());
 870                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 871                             fb.append(&#39; &#39;);
 872                         }
 873                         fb.append(s).append(&#39; &#39;).
 874                                 append(new Date(je.getTime()).toString());
 875                         fb.append(&#39; &#39;).append(name);
 876 
 877                         output.get(label).add(fb.toString());
 878                     }
 879                 }
 880             }
 881             if (verbose != null) {
 882                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 883                     List&lt;String&gt; files = s.getValue();
 884                     String key = s.getKey();
 885                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 886                         key = key.substring(1);
 887                     }
 888                     int pipe = key.indexOf(&#39;|&#39;);
 889                     if (verbose.equals(&quot;all&quot;)) {
 890                         for (String f: files) {
 891                             System.out.println(key.substring(0, pipe) + f);
 892                             System.out.printf(key.substring(pipe+1));
 893                         }
 894                     } else {
 895                         if (verbose.equals(&quot;grouped&quot;)) {
 896                             for (String f: files) {
 897                                 System.out.println(key.substring(0, pipe) + f);
 898                             }
 899                         } else if (verbose.equals(&quot;summary&quot;)) {
 900                             System.out.print(key.substring(0, pipe));
 901                             if (files.size() &gt; 1) {
 902                                 System.out.println(files.get(0) + &quot; &quot; +
 903                                         String.format(rb.getString(
 904                                         &quot;.and.d.more.&quot;), files.size()-1));
 905                             } else {
 906                                 System.out.println(files.get(0));
 907                             }
 908                         }
 909                         System.out.printf(key.substring(pipe+1));
 910                     }
 911                 }
 912                 System.out.println();
 913                 System.out.println(rb.getString(
 914                     &quot;.s.signature.was.verified.&quot;));
 915                 System.out.println(rb.getString(
 916                     &quot;.m.entry.is.listed.in.manifest&quot;));
 917                 System.out.println(rb.getString(
 918                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 919                 if (ckaliases.size() &gt; 0) {
 920                     System.out.println(rb.getString(
 921                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 922                 }
 923             }
 924             if (man == null) {
 925                 System.out.println();
 926                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 927             }
 928 
 929             // If signer is a trusted cert or private entry in user&#39;s own
 930             // keystore, it can be self-signed. Please note aliasNotInStore
 931             // is always false when ~/.keystore is used.
 932             if (!aliasNotInStore &amp;&amp; keystore != null) {
 933                 signerSelfSigned = false;
 934             }
 935 
 936             // Even if the verbose option is not specified, all out strings
 937             // must be generated so disabledAlgFound can be updated.
 938             if (!digestMap.isEmpty()
 939                     || !sigMap.isEmpty()
 940                     || !unparsableSignatures.isEmpty()) {
 941                 if (verbose != null) {
 942                     System.out.println();
 943                 }
 944                 for (String s : sigMap.keySet()) {
 945                     if (!digestMap.containsKey(s)) {
 946                         unparsableSignatures.putIfAbsent(s, String.format(
 947                                 rb.getString(&quot;history.nosf&quot;), s));
 948                     }
 949                 }
 950                 for (String s : digestMap.keySet()) {
 951                     PKCS7 p7 = sigMap.get(s);
 952                     if (p7 != null) {
 953                         String history;
 954                         try {
 955                             SignerInfo si = p7.getSignerInfos()[0];
 956                             X509Certificate signer = si.getCertificate(p7);
 957                             String digestAlg = digestMap.get(s);
 958                             String sigAlg = AlgorithmId.makeSigAlg(
 959                                     si.getDigestAlgorithmId().getName(),
 960                                     si.getDigestEncryptionAlgorithmId().getName());
 961                             PublicKey key = signer.getPublicKey();
 962                             PKCS7 tsToken = si.getTsToken();
 963                             if (tsToken != null) {
 964                                 hasTimestampBlock = true;
 965                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 966                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 967                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 968                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 969                                 PublicKey tsKey = tsSigner.getPublicKey();
 970                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 971                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 972                                         tsSi.getDigestAlgorithmId().getName(),
 973                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 974                                 Calendar c = Calendar.getInstance(
 975                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 976                                         Locale.getDefault(Locale.Category.FORMAT));
 977                                 c.setTime(tsTokenInfo.getDate());
 978                                 history = String.format(
 979                                         rb.getString(&quot;history.with.ts&quot;),
 980                                         signer.getSubjectX500Principal(),
 981                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 982                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 983                                         verifyWithWeak(key),
 984                                         c,
 985                                         tsSigner.getSubjectX500Principal(),
 986                                         verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true),
 987                                         verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true),
 988                                         verifyWithWeak(tsKey));
 989                             } else {
 990                                 history = String.format(
 991                                         rb.getString(&quot;history.without.ts&quot;),
 992                                         signer.getSubjectX500Principal(),
 993                                         verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false),
 994                                         verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false),
 995                                         verifyWithWeak(key));
 996                             }
 997                         } catch (Exception e) {
 998                             // The only usage of sigNameMap, remember the name
 999                             // of the block file if it&#39;s invalid.
1000                             history = String.format(
1001                                     rb.getString(&quot;history.unparsable&quot;),
1002                                     sigNameMap.get(s));
1003                         }
1004                         if (verbose != null) {
1005                             System.out.println(history);
1006                         }
1007                     } else {
1008                         unparsableSignatures.putIfAbsent(s, String.format(
1009                                 rb.getString(&quot;history.nobk&quot;), s));
1010                     }
1011                 }
1012                 if (verbose != null) {
1013                     for (String s : unparsableSignatures.keySet()) {
1014                         System.out.println(unparsableSignatures.get(s));
1015                     }
1016                 }
1017             }
1018             System.out.println();
1019 
1020             if (!anySigned) {
1021                 if (disabledAlgFound) {
1022                     if (verbose != null) {
1023                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
1024                         System.out.println(&quot;\n  &quot; +
1025                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
1026                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
1027                     } else {
1028                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
1029                     }
1030                 } else if (hasSignature) {
1031                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
1032                 } else {
1033                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
1034                 }
1035             } else {
1036                 displayMessagesAndResult(false);
1037             }
1038             return;
1039         } catch (Exception e) {
1040             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1041             if (debug) {
1042                 e.printStackTrace();
1043             }
1044         } finally { // close the resource
1045             if (jf != null) {
1046                 jf.close();
1047             }
1048         }
1049 
1050         System.exit(1);
1051     }
1052 
1053     private void displayMessagesAndResult(boolean isSigning) {
1054         String result;
1055         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1056         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1057         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1058 
1059         boolean signerNotExpired = expireDate == null
1060                 || expireDate.after(new Date());
1061 
1062         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
1063                 notYetValidCert || chainNotValidated || hasExpiredCert ||
1064                 hasUnsignedEntry || signerSelfSigned || (legacyAlg != 0) ||
1065                 (disabledAlg != 0) || aliasNotInStore || notSignedByAlias ||
1066                 tsaChainNotValidated ||
1067                 (hasExpiredTsaCert &amp;&amp; !signerNotExpired)) {
1068 
1069             if (strict) {
1070                 result = isSigning
1071                         ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)
1072                         : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);
1073             } else {
1074                 result = isSigning
1075                         ? rb.getString(&quot;jar.signed.&quot;)
1076                         : rb.getString(&quot;jar.verified.&quot;);
1077             }
1078 
1079             if (badKeyUsage) {
1080                 errors.add(isSigning
1081                         ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1082                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1083             }
1084 
1085             if (badExtendedKeyUsage) {
1086                 errors.add(isSigning
1087                         ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1088                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1089             }
1090 
1091             if (badNetscapeCertType) {
1092                 errors.add(isSigning
1093                         ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)
1094                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
1095             }
1096 
1097             // only in verifying
1098             if (hasUnsignedEntry) {
1099                 errors.add(rb.getString(
1100                         &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
1101             }
1102             if (hasExpiredCert) {
1103                 errors.add(isSigning
1104                         ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)
1105                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
1106             }
1107             if (notYetValidCert) {
1108                 errors.add(isSigning
1109                         ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)
1110                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
1111             }
1112 
1113             if (chainNotValidated) {
1114                 errors.add(String.format(isSigning
1115                                 ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)
1116                                 : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),
1117                         chainNotValidatedReason.getLocalizedMessage()));
1118             }
1119 
1120             if (hasExpiredTsaCert) {
1121                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));
1122             }
1123             if (tsaChainNotValidated) {
1124                 errors.add(String.format(isSigning
1125                                 ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)
1126                                 : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),
1127                         tsaChainNotValidatedReason.getLocalizedMessage()));
1128             }
1129 
1130             // only in verifying
1131             if (notSignedByAlias) {
1132                 errors.add(
1133                         rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
1134             }
1135 
1136             // only in verifying
1137             if (aliasNotInStore) {
1138                 errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
1139             }
1140 
1141             if (signerSelfSigned) {
1142                 errors.add(isSigning
1143                         ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)
1144                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));
1145             }
1146 
1147             if (isSigning) {
1148                 if ((legacyAlg &amp; 1) == 1) {
1149                     warnings.add(String.format(
1150                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1151                             digestalg, &quot;-digestalg&quot;));
1152                 }
1153 
1154                 if ((disabledAlg &amp; 1) == 1) {
1155                     errors.add(String.format(
1156                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1157                             digestalg, &quot;-digestalg&quot;));
1158                 }
1159 
1160                 if ((legacyAlg &amp; 2) == 2) {
1161                     warnings.add(String.format(
1162                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1163                             sigalg, &quot;-sigalg&quot;));
1164                 }
1165                 if ((disabledAlg &amp; 2) == 2) {
1166                     errors.add(String.format(
1167                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1168                             sigalg, &quot;-sigalg&quot;));
1169                 }
1170 
1171                 if ((legacyAlg &amp; 4) == 4) {
1172                     warnings.add(String.format(
1173                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1174                             tSADigestAlg, &quot;-tsadigestalg&quot;));
1175                 }
1176                 if ((disabledAlg &amp; 4) == 4) {
1177                     errors.add(String.format(
1178                             rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.and.is.disabled.&quot;),
1179                             tSADigestAlg, &quot;-tsadigestalg&quot;));
1180                 }
1181 
1182                 if ((legacyAlg &amp; 8) == 8) {
1183                     warnings.add(String.format(
1184                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),
1185                             privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1186                 }
1187                 if ((disabledAlg &amp; 8) == 8) {
1188                     errors.add(String.format(
1189                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.and.is.disabled.&quot;),
1190                             privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1191                 }
1192             } else {
1193                 if ((legacyAlg &amp; 1) != 0) {
1194                     warnings.add(String.format(
1195                             rb.getString(&quot;The.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1196                             legacyDigestAlg));
1197                 }
1198 
1199                 if ((legacyAlg &amp; 2) == 2) {
1200                      warnings.add(String.format(
1201                              rb.getString(&quot;The.signature.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1202                              legacySigAlg));
1203                 }
1204 
1205                 if ((legacyAlg &amp; 4) != 0) {
1206                     warnings.add(String.format(
1207                             rb.getString(&quot;The.timestamp.digest.algorithm.1.is.considered.a.security.risk..This.algorithm.will.be.disabled.in.a.future.update.&quot;),
1208                             legacyTsaDigestAlg));
1209                 }
1210 
1211                 if ((legacyAlg &amp; 8) == 8) {
1212                     warnings.add(String.format(
1213                             rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk..This.key.size.will.be.disabled.in.a.future.update.&quot;),
1214                             weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));
1215                 }
1216             }
1217         } else {
1218             result = isSigning ? rb.getString(&quot;jar.signed.&quot;) : rb.getString(&quot;jar.verified.&quot;);
1219         }
1220 
1221         if (hasExpiredTsaCert) {
1222             // No need to warn about expiring if already expired
1223             hasExpiringTsaCert = false;
1224         }
1225 
1226         if (hasExpiringCert ||
1227                 (hasExpiringTsaCert  &amp;&amp; expireDate != null) ||
1228                 (noTimestamp &amp;&amp; expireDate != null) ||
<a name="6" id="anc6"></a><span class="line-modified">1229                 (hasExpiredTsaCert &amp;&amp; signerNotExpired) ||</span>
<span class="line-added">1230                 permsDetected) {</span>
1231 
1232             if (hasExpiredTsaCert &amp;&amp; signerNotExpired) {
1233                 if (expireDate != null) {
1234                     warnings.add(String.format(
1235                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1236                             tsaExpireDate,
1237                             expireDate));
1238                 }
1239                 // Reset the flag so exit code is 0
1240                 hasExpiredTsaCert = false;
1241             }
1242             if (hasExpiringCert) {
1243                 warnings.add(isSigning
1244                         ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)
1245                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
1246             }
1247             if (hasExpiringTsaCert &amp;&amp; expireDate != null) {
1248                 if (expireDate.after(tsaExpireDate)) {
1249                     warnings.add(String.format(rb.getString(
1250                             &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));
1251                 } else {
1252                     warnings.add(String.format(rb.getString(
1253                             &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));
1254                 }
1255             }
1256             if (noTimestamp &amp;&amp; expireDate != null) {
1257                 if (hasTimestampBlock) {
1258                     warnings.add(String.format(isSigning
1259                             ? rb.getString(&quot;invalid.timestamp.signing&quot;)
1260                             : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));
1261                 } else {
1262                     warnings.add(String.format(isSigning
1263                             ? rb.getString(&quot;no.timestamp.signing&quot;)
1264                             : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
1265                 }
1266             }
<a name="7" id="anc7"></a><span class="line-added">1267             if (permsDetected) {</span>
<span class="line-added">1268                 warnings.add(rb.getString(&quot;posix.attributes.detected&quot;));</span>
<span class="line-added">1269             }</span>
1270         }
1271 
1272         System.out.println(result);
1273         if (strict) {
1274             if (!errors.isEmpty()) {
1275                 System.out.println();
1276                 System.out.println(rb.getString(&quot;Error.&quot;));
1277                 errors.forEach(System.out::println);
1278             }
1279             if (!warnings.isEmpty()) {
1280                 System.out.println();
1281                 System.out.println(rb.getString(&quot;Warning.&quot;));
1282                 warnings.forEach(System.out::println);
1283             }
1284         } else {
1285             if (!errors.isEmpty() || !warnings.isEmpty()) {
1286                 System.out.println();
1287                 System.out.println(rb.getString(&quot;Warning.&quot;));
1288                 errors.forEach(System.out::println);
1289                 warnings.forEach(System.out::println);
1290             }
1291         }
1292         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1293             if (! (verbose != null &amp;&amp; showcerts)) {
1294                 System.out.println();
1295                 System.out.println(rb.getString(
1296                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1297             }
1298         }
1299 
1300         if (isSigning || verbose != null) {
1301             // Always print out expireDate, unless expired or expiring.
1302             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1303                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1304                 info.add(String.format(rb.getString(
1305                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1306             }
1307             if (!noTimestamp) {
1308                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1309                     if (signerNotExpired) {
1310                         info.add(String.format(rb.getString(
1311                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1312                     } else {
1313                         info.add(String.format(rb.getString(
1314                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1315                                 expireDate,
1316                                 tsaExpireDate));
1317                     }
1318                 }
1319             }
1320         }
1321 
1322         if (!info.isEmpty()) {
1323             System.out.println();
1324             info.forEach(System.out::println);
1325         }
1326     }
1327 
1328     private String verifyWithWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1329         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1330             if (LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1331                 return alg;
1332             } else {
1333                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1334                    legacyAlg |= 2;
1335                    legacySigAlg = alg;
1336                 } else {
1337                     if (tsa) {
1338                         legacyAlg |= 4;
1339                         legacyTsaDigestAlg = alg;
1340                     } else {
1341                         legacyAlg |= 1;
1342                         legacyDigestAlg = alg;
1343                     }
1344                 }
1345                 return String.format(rb.getString(&quot;with.weak&quot;), alg);
1346             }
1347         } else {
1348             disabledAlgFound = true;
1349             return String.format(rb.getString(&quot;with.disabled&quot;), alg);
1350         }
1351     }
1352 
1353     private String verifyWithWeak(PublicKey key) {
1354         int kLen = KeyUtil.getKeySize(key);
1355         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1356             if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1357                 if (kLen &gt;= 0) {
1358                     return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1359                 } else {
1360                     return rb.getString(&quot;unknown.size&quot;);
1361                 }
1362             } else {
1363                 weakPublicKey = key;
1364                 legacyAlg |= 8;
1365                 return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen);
1366             }
1367         } else {
1368            disabledAlgFound = true;
1369            return String.format(rb.getString(&quot;key.bit.disabled&quot;), kLen);
1370         }
1371     }
1372 
1373     private void checkWeakSign(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet, boolean tsa) {
1374         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1375             if (!LEGACY_CHECK.permits(primitiveSet, alg, null)) {
1376                 if (primitiveSet == SIG_PRIMITIVE_SET) {
1377                    legacyAlg |= 2;
1378                 } else {
1379                     if (tsa) {
1380                         legacyAlg |= 4;
1381                     } else {
1382                         legacyAlg |= 1;
1383                     }
1384                 }
1385             }
1386         } else {
1387            if (primitiveSet == SIG_PRIMITIVE_SET) {
1388                disabledAlg |= 2;
1389            } else {
1390                if (tsa) {
1391                    disabledAlg |= 4;
1392                } else {
1393                    disabledAlg |= 1;
1394                }
1395            }
1396         }
1397     }
1398 
1399     private void checkWeakSign(PrivateKey key) {
1400         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1401             if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1402                 legacyAlg |= 8;
1403             }
1404         } else {
1405             disabledAlg |= 8;
1406         }
1407     }
1408 
1409     private static MessageFormat validityTimeForm = null;
1410     private static MessageFormat notYetTimeForm = null;
1411     private static MessageFormat expiredTimeForm = null;
1412     private static MessageFormat expiringTimeForm = null;
1413 
1414     /**
1415      * Returns a string about a certificate:
1416      *
1417      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1418      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1419      * [&lt;key-usage-warning&gt;]
1420      *
1421      * Note: no newline character at the end.
1422      *
1423      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1424      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1425      * hasExpiringTsaCert, hasExpiredTsaCert.
1426      *
1427      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1428      * @param checkUsage true to check code signer keyUsage
1429      */
1430     String printCert(boolean isTsCert, String tab, Certificate c,
1431         Date timestamp, boolean checkUsage) throws Exception {
1432 
1433         StringBuilder certStr = new StringBuilder();
1434         String space = rb.getString(&quot;SPACE&quot;);
1435         X509Certificate x509Cert = null;
1436 
1437         if (c instanceof X509Certificate) {
1438             x509Cert = (X509Certificate) c;
1439             certStr.append(tab).append(x509Cert.getType())
1440                 .append(rb.getString(&quot;COMMA&quot;))
1441                 .append(x509Cert.getSubjectDN().getName());
1442         } else {
1443             certStr.append(tab).append(c.getType());
1444         }
1445 
1446         String alias = storeHash.get(c);
1447         if (alias != null) {
1448             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);
1449         }
1450 
1451         if (x509Cert != null) {
1452 
1453             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1454 
1455             if (trustedCerts.contains(x509Cert)) {
1456                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1457             } else {
1458                 Date notAfter = x509Cert.getNotAfter();
1459                 try {
1460                     boolean printValidity = true;
1461                     if (isTsCert) {
1462                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1463                             tsaExpireDate = notAfter;
1464                         }
1465                     } else {
1466                         if (expireDate == null || expireDate.after(notAfter)) {
1467                             expireDate = notAfter;
1468                         }
1469                     }
1470                     if (timestamp == null) {
1471                         x509Cert.checkValidity();
1472                         // test if cert will expire within six months (or one year for tsa)
1473                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1474                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1475                             if (isTsCert) {
1476                                 hasExpiringTsaCert = true;
1477                             } else {
1478                                 hasExpiringCert = true;
1479                             }
1480                             if (expiringTimeForm == null) {
1481                                 expiringTimeForm = new MessageFormat(
1482                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1483                             }
1484                             Object[] source = {notAfter};
1485                             certStr.append(expiringTimeForm.format(source));
1486                             printValidity = false;
1487                         }
1488                     } else {
1489                         x509Cert.checkValidity(timestamp);
1490                     }
1491                     if (printValidity) {
1492                         if (validityTimeForm == null) {
1493                             validityTimeForm = new MessageFormat(
1494                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1495                         }
1496                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1497                         certStr.append(validityTimeForm.format(source));
1498                     }
1499                 } catch (CertificateExpiredException cee) {
1500                     if (isTsCert) {
1501                         hasExpiredTsaCert = true;
1502                     } else {
1503                         hasExpiredCert = true;
1504                     }
1505 
1506                     if (expiredTimeForm == null) {
1507                         expiredTimeForm = new MessageFormat(
1508                                 rb.getString(&quot;certificate.expired.on&quot;));
1509                     }
1510                     Object[] source = {notAfter};
1511                     certStr.append(expiredTimeForm.format(source));
1512 
1513                 } catch (CertificateNotYetValidException cnyve) {
1514                     if (!isTsCert) notYetValidCert = true;
1515 
1516                     if (notYetTimeForm == null) {
1517                         notYetTimeForm = new MessageFormat(
1518                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1519                     }
1520                     Object[] source = {x509Cert.getNotBefore()};
1521                     certStr.append(notYetTimeForm.format(source));
1522                 }
1523             }
1524             certStr.append(&quot;]&quot;);
1525 
1526             if (checkUsage) {
1527                 boolean[] bad = new boolean[3];
1528                 checkCertUsage(x509Cert, bad);
1529                 if (bad[0] || bad[1] || bad[2]) {
1530                     String x = &quot;&quot;;
1531                     if (bad[0]) {
1532                         x =&quot;KeyUsage&quot;;
1533                     }
1534                     if (bad[1]) {
1535                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1536                         x = x + &quot;ExtendedKeyUsage&quot;;
1537                     }
1538                     if (bad[2]) {
1539                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1540                         x = x + &quot;NetscapeCertType&quot;;
1541                     }
1542                     certStr.append(&quot;\n&quot;).append(tab)
1543                         .append(MessageFormat.format(rb.getString(
1544                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1545                 }
1546             }
1547         }
1548         return certStr.toString();
1549     }
1550 
1551     private static MessageFormat signTimeForm = null;
1552 
1553     private String printTimestamp(String tab, Timestamp timestamp) {
1554 
1555         if (signTimeForm == null) {
1556             signTimeForm =
1557                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1558         }
1559         Object[] source = { timestamp.getTimestamp() };
1560 
1561         return new StringBuilder().append(tab).append(&quot;[&quot;)
1562             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1563     }
1564 
1565     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1566 
1567     private int inKeyStoreForOneSigner(CodeSigner signer) {
1568         if (cacheForInKS.containsKey(signer)) {
1569             return cacheForInKS.get(signer);
1570         }
1571 
1572         int result = 0;
1573         if (store != null) {
1574             try {
1575                 List&lt;? extends Certificate&gt; certs =
1576                         signer.getSignerCertPath().getCertificates();
1577                 for (Certificate c : certs) {
1578                     String alias = storeHash.get(c);
1579                     if (alias == null) {
1580                         alias = store.getCertificateAlias(c);
1581                         if (alias != null) {
1582                             storeHash.put(c, alias);
1583                         }
1584                     }
1585                     if (alias != null) {
1586                         result |= IN_KEYSTORE;
1587                     }
1588                     for (String ckalias : ckaliases) {
1589                         if (c.equals(store.getCertificate(ckalias))) {
1590                             result |= SIGNED_BY_ALIAS;
1591                             // must continue with next certificate c and cannot
1592                             // return or break outer loop because has to fill
1593                             // storeHash for printCert
1594                             break;
1595                         }
1596                     }
1597                 }
1598             } catch (KeyStoreException kse) {
1599                 // never happens, because keystore has been loaded
1600             }
1601         }
1602         cacheForInKS.put(signer, result);
1603         return result;
1604     }
1605 
1606     /**
1607      * Maps certificates (as keys) to alias names associated in the keystore
1608      * {@link #store} (as values).
1609      */
1610     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1611 
1612     int inKeyStore(CodeSigner[] signers) {
1613 
1614         if (signers == null)
1615             return 0;
1616 
1617         int output = 0;
1618 
1619         for (CodeSigner signer: signers) {
1620             int result = inKeyStoreForOneSigner(signer);
1621             output |= result;
1622         }
1623         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1624             output |= NOT_ALIAS;
1625         }
1626         return output;
1627     }
1628 
1629     void signJar(String jarName, String alias)
1630             throws Exception {
1631 
1632         if (digestalg == null) {
1633             digestalg = JarSigner.Builder.getDefaultDigestAlgorithm();
1634         }
1635         checkWeakSign(digestalg, DIGEST_PRIMITIVE_SET, false);
1636 
1637         if (tSADigestAlg == null) {
1638             tSADigestAlg = JarSigner.Builder.getDefaultDigestAlgorithm();
1639         }
1640         checkWeakSign(tSADigestAlg, DIGEST_PRIMITIVE_SET, true);
1641 
1642         if (sigalg == null) {
1643             sigalg = JarSigner.Builder.getDefaultSignatureAlgorithm(privateKey);
1644         }
1645         checkWeakSign(sigalg, SIG_PRIMITIVE_SET, false);
1646 
1647         checkWeakSign(privateKey);
1648 
1649         boolean aliasUsed = false;
1650         X509Certificate tsaCert = null;
1651 
1652         if (sigfile == null) {
1653             sigfile = alias;
1654             aliasUsed = true;
1655         }
1656 
1657         if (sigfile.length() &gt; 8) {
1658             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1659         } else {
1660             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1661         }
1662 
1663         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1664         for (int j = 0; j &lt; sigfile.length(); j++) {
1665             char c = sigfile.charAt(j);
1666             if (!
1667                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1668                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1669                             (c == &#39;-&#39;) ||
1670                             (c == &#39;_&#39;))) {
1671                 if (aliasUsed) {
1672                     // convert illegal characters from the alias to be _&#39;s
1673                     c = &#39;_&#39;;
1674                 } else {
1675                     throw new
1676                             RuntimeException(rb.getString
1677                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1678                 }
1679             }
1680             tmpSigFile.append(c);
1681         }
1682 
1683         sigfile = tmpSigFile.toString();
1684 
1685         String tmpJarName;
1686         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1687         else tmpJarName = signedjar;
1688 
1689         File jarFile = new File(jarName);
1690         File signedJarFile = new File(tmpJarName);
1691 
1692         // Open the jar (zip) file
1693         try {
1694             zipFile = new ZipFile(jarName);
1695         } catch (IOException ioe) {
1696             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1697         }
1698 
1699         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1700                 .generateCertPath(Arrays.asList(certChain));
1701         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1702 
1703         if (verbose != null) {
1704             builder.eventHandler((action, file) -&gt; {
1705                 switch (action) {
1706                     case &quot;signing&quot;:
1707                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1708                         break;
1709                     case &quot;adding&quot;:
1710                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1711                         break;
1712                     case &quot;updating&quot;:
1713                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1714                         break;
1715                     default:
1716                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1717                                 + action);
1718                 }
1719             });
1720         }
1721 
1722         if (digestalg != null) {
1723             builder.digestAlgorithm(digestalg);
1724         }
1725         if (sigalg != null) {
1726             builder.signatureAlgorithm(sigalg);
1727         }
1728 
1729         URI tsaURI = null;
1730 
1731         if (tsaUrl != null) {
1732             tsaURI = new URI(tsaUrl);
1733         } else if (tsaAlias != null) {
1734             tsaCert = getTsaCert(tsaAlias);
1735             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1736         }
1737 
1738         if (tsaURI != null) {
1739             if (verbose != null) {
1740                 System.out.println(
1741                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1742                 if (tsaUrl != null) {
1743                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1744                 } else if (tsaCert != null) {
1745                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1746                             printCert(true, &quot;&quot;, tsaCert, null, false));
1747                 }
1748             }
1749             builder.tsa(tsaURI);
1750             if (tSADigestAlg != null) {
1751                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1752             }
1753 
1754             if (tSAPolicyID != null) {
1755                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1756             }
1757         }
1758 
1759         if (altSignerClass != null) {
1760             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1761             if (verbose != null) {
1762                 System.out.println(
1763                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1764             }
1765         }
1766 
1767         if (altSignerClasspath != null) {
1768             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1769         }
1770 
1771         builder.signerName(sigfile);
1772 
1773         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1774         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1775 
1776         FileOutputStream fos = null;
1777         try {
1778             fos = new FileOutputStream(signedJarFile);
1779         } catch (IOException ioe) {
1780             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1781         }
1782 
1783         Throwable failedCause = null;
1784         String failedMessage = null;
1785 
1786         try {
<a name="8" id="anc8"></a><span class="line-added">1787             Event.setReportListener(Event.ReporterCategory.POSIXPERMS,</span>
<span class="line-added">1788                     (t, o) -&gt; permsDetected = true);</span>
1789             builder.build().sign(zipFile, fos);
1790         } catch (JarSignerException e) {
1791             failedCause = e.getCause();
1792             if (failedCause instanceof SocketTimeoutException
1793                     || failedCause instanceof UnknownHostException) {
1794                 // Provide a helpful message when TSA is beyond a firewall
1795                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1796                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1797                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1798                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1799                         rb.getString(&quot;or&quot;) +
1800                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1801                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1802             } else {
1803                 // JarSignerException might have a null cause
1804                 if (failedCause == null) {
1805                     failedCause = e;
1806                 }
1807                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1808             }
1809         } catch (Exception e) {
1810             failedCause = e;
1811             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1812         } finally {
1813             // close the resources
1814             if (zipFile != null) {
1815                 zipFile.close();
1816                 zipFile = null;
1817             }
1818 
1819             if (fos != null) {
1820                 fos.close();
1821             }
1822 
<a name="9" id="anc9"></a><span class="line-added">1823             Event.clearReportListener(Event.ReporterCategory.POSIXPERMS);</span>
1824         }
1825 
1826         if (failedCause != null) {
1827             signedJarFile.delete();
1828             error(failedMessage, failedCause);
1829         }
1830 
1831         if (verbose != null) {
1832             System.out.println();
1833         }
1834 
1835         // The JarSigner API always accepts the timestamp received.
1836         // We need to extract the certs from the signed jar to
1837         // validate it.
1838         try (JarFile check = new JarFile(signedJarFile)) {
1839             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1840                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1841             Timestamp ts = null;
1842             try {
1843                 SignerInfo si = p7.getSignerInfos()[0];
1844                 if (si.getTsToken() != null) {
1845                     hasTimestampBlock = true;
1846                 }
1847                 ts = si.getTimestamp();
1848             } catch (Exception e) {
1849                 tsaChainNotValidated = true;
1850                 tsaChainNotValidatedReason = e;
1851             }
1852             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1853             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1854             if (verbose != null) {
1855                 System.out.println(result);
1856             }
1857         } catch (Exception e) {
1858             if (debug) {
1859                 e.printStackTrace();
1860             }
1861         }
1862 
1863         if (signedjar == null) {
1864             // attempt an atomic rename. If that fails,
1865             // rename the original jar file, then the signed
1866             // one, then delete the original.
1867             if (!signedJarFile.renameTo(jarFile)) {
1868                 File origJar = new File(jarName+&quot;.orig&quot;);
1869 
1870                 if (jarFile.renameTo(origJar)) {
1871                     if (signedJarFile.renameTo(jarFile)) {
1872                         origJar.delete();
1873                     } else {
1874                         MessageFormat form = new MessageFormat(rb.getString
1875                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1876                         Object[] source = {signedJarFile, jarFile};
1877                         error(form.format(source));
1878                     }
1879                 } else {
1880                     MessageFormat form = new MessageFormat(rb.getString
1881                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1882                     Object[] source = {jarFile, origJar};
1883                     error(form.format(source));
1884                 }
1885             }
1886         }
1887         displayMessagesAndResult(true);
1888     }
1889 
1890     /**
1891      * signature-related files include:
1892      * . META-INF/MANIFEST.MF
1893      * . META-INF/SIG-*
1894      * . META-INF/*.SF
1895      * . META-INF/*.DSA
1896      * . META-INF/*.RSA
1897      * . META-INF/*.EC
1898      */
1899     private boolean signatureRelated(String name) {
1900         return SignatureFileVerifier.isSigningRelated(name);
1901     }
1902 
1903     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1904 
1905     /**
1906      * Returns a string of signer info, with a newline at the end.
1907      * Called by verifyJar().
1908      */
1909     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1910         if (cacheForSignerInfo.containsKey(signer)) {
1911             return cacheForSignerInfo.get(signer);
1912         }
1913         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1914         // signing time is only displayed on verification
1915         Timestamp ts = signer.getTimestamp();
1916         String tsLine = &quot;&quot;;
1917         if (ts != null) {
1918             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1919         }
1920         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1921 
1922         String result = certsAndTSInfo(tab, tab, certs, ts);
1923         cacheForSignerInfo.put(signer, tsLine + result);
1924         return result;
1925     }
1926 
1927     /**
1928      * Fills info on certs and timestamp into a StringBuilder, sets
1929      * warning flags (through printCert) and validates cert chains.
1930      *
1931      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1932      * @param tab2 spaces before the other lines
1933      * @param certs the signer cert
1934      * @param ts the timestamp, can be null
1935      * @return the info as a string
1936      */
1937     private String certsAndTSInfo(
1938             String tab1,
1939             String tab2,
1940             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1941             throws Exception {
1942 
1943         Date timestamp;
1944         if (ts != null) {
1945             timestamp = ts.getTimestamp();
1946             noTimestamp = false;
1947         } else {
1948             timestamp = null;
1949         }
1950         // display the certificate(sb). The first one is end-entity cert and
1951         // its KeyUsage should be checked.
1952         boolean first = true;
1953         StringBuilder sb = new StringBuilder();
1954         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1955         for (Certificate c : certs) {
1956             sb.append(printCert(false, tab2, c, timestamp, first));
1957             sb.append(&#39;\n&#39;);
1958             first = false;
1959         }
1960         try {
1961             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1962         } catch (Exception e) {
1963             chainNotValidated = true;
1964             chainNotValidatedReason = e;
1965             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1966                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1967         }
1968         if (ts != null) {
1969             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1970             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1971                 sb.append(printCert(true, tab2, c, null, false));
1972                 sb.append(&#39;\n&#39;);
1973             }
1974             try {
1975                 validateCertChain(Validator.VAR_TSA_SERVER,
1976                         ts.getSignerCertPath().getCertificates(), null);
1977             } catch (Exception e) {
1978                 tsaChainNotValidated = true;
1979                 tsaChainNotValidatedReason = e;
1980                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1981                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1982             }
1983         }
1984         if (certs.size() == 1
1985                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1986             signerSelfSigned = true;
1987         }
1988 
1989         return sb.toString();
1990     }
1991 
1992     void loadKeyStore(String keyStoreName, boolean prompt) {
1993 
1994         if (!nullStream &amp;&amp; keyStoreName == null) {
1995             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1996                 + &quot;.keystore&quot;;
1997         }
1998 
1999         try {
2000             try {
2001                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
2002                 if (caks != null) {
2003                     Enumeration&lt;String&gt; aliases = caks.aliases();
2004                     while (aliases.hasMoreElements()) {
2005                         String a = aliases.nextElement();
2006                         try {
2007                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
2008                         } catch (Exception e2) {
2009                             // ignore, when a SecretkeyEntry does not include a cert
2010                         }
2011                     }
2012                 }
2013             } catch (Exception e) {
2014                 // Ignore, if cacerts cannot be loaded
2015             }
2016 
2017             if (providerName == null) {
2018                 store = KeyStore.getInstance(storetype);
2019             } else {
2020                 store = KeyStore.getInstance(storetype, providerName);
2021             }
2022 
2023             // Get pass phrase
2024             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
2025             // and on NT call ??
2026             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
2027                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
2028                 storepass = getPass
2029                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2030             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
2031                 storepass = getPass
2032                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
2033             }
2034 
2035             try {
2036                 if (nullStream) {
2037                     store.load(null, storepass);
2038                 } else {
2039                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
2040                     URL url = null;
2041                     try {
2042                         url = new URL(keyStoreName);
2043                     } catch (java.net.MalformedURLException e) {
2044                         // try as file
2045                         url = new File(keyStoreName).toURI().toURL();
2046                     }
2047                     InputStream is = null;
2048                     try {
2049                         is = url.openStream();
2050                         store.load(is, storepass);
2051                     } finally {
2052                         if (is != null) {
2053                             is.close();
2054                         }
2055                     }
2056                 }
2057                 Enumeration&lt;String&gt; aliases = store.aliases();
2058                 while (aliases.hasMoreElements()) {
2059                     String a = aliases.nextElement();
2060                     try {
2061                         X509Certificate c = (X509Certificate)store.getCertificate(a);
2062                         // Only add TrustedCertificateEntry and self-signed
2063                         // PrivateKeyEntry
2064                         if (store.isCertificateEntry(a) ||
2065                                 c.getSubjectDN().equals(c.getIssuerDN())) {
2066                             trustedCerts.add(c);
2067                         }
2068                     } catch (Exception e2) {
2069                         // ignore, when a SecretkeyEntry does not include a cert
2070                     }
2071                 }
2072             } finally {
2073                 try {
2074                     pkixParameters = new PKIXBuilderParameters(
2075                             trustedCerts.stream()
2076                                     .map(c -&gt; new TrustAnchor(c, null))
2077                                     .collect(Collectors.toSet()),
2078                             null);
2079 
2080                     if (revocationCheck) {
2081                         Security.setProperty(&quot;ocsp.enable&quot;, &quot;true&quot;);
2082                         System.setProperty(&quot;com.sun.security.enableCRLDP&quot;, &quot;true&quot;);
<a name="10" id="anc10"></a><span class="line-modified">2083                         Event.setReportListener(Event.ReporterCategory.CRLCHECK,</span>
<span class="line-added">2084                                 (t, o) -&gt; System.out.println(String.format(rb.getString(t), o)));</span>
2085                     }
2086                     pkixParameters.setRevocationEnabled(revocationCheck);
2087                 } catch (InvalidAlgorithmParameterException ex) {
2088                     // Only if tas is empty
2089                 }
2090             }
2091         } catch (IOException ioe) {
2092             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2093                                         ioe.getMessage());
2094         } catch (java.security.cert.CertificateException ce) {
2095             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
2096                                         ce.getMessage());
2097         } catch (NoSuchProviderException pe) {
2098             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2099                                         pe.getMessage());
2100         } catch (NoSuchAlgorithmException nsae) {
2101             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
2102                                         nsae.getMessage());
2103         } catch (KeyStoreException kse) {
2104             throw new RuntimeException
2105                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
2106                 kse.getMessage());
2107         }
2108     }
2109 
2110     X509Certificate getTsaCert(String alias) {
2111 
2112         java.security.cert.Certificate cs = null;
2113 
2114         try {
2115             cs = store.getCertificate(alias);
2116         } catch (KeyStoreException kse) {
2117             // this never happens, because keystore has been loaded
2118         }
2119         if (cs == null || (!(cs instanceof X509Certificate))) {
2120             MessageFormat form = new MessageFormat(rb.getString
2121                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
2122             Object[] source = {alias, alias};
2123             error(form.format(source));
2124         }
2125         return (X509Certificate) cs;
2126     }
2127 
2128     /**
2129      * Check if userCert is designed to be a code signer
2130      * @param userCert the certificate to be examined
2131      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
2132      *            NetscapeCertType has codeSigning flag turned on.
2133      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
2134      *            badNetscapeCertType will be set.
2135      */
2136     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
2137 
2138         // Can act as a signer?
2139         // 1. if KeyUsage, then [0:digitalSignature] or
2140         //    [1:nonRepudiation] should be true
2141         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
2142         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
2143         // 1,2,3 must be true
2144 
2145         if (bad != null) {
2146             bad[0] = bad[1] = bad[2] = false;
2147         }
2148 
2149         boolean[] keyUsage = userCert.getKeyUsage();
2150         if (keyUsage != null) {
2151             keyUsage = Arrays.copyOf(keyUsage, 9);
2152             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
2153                 if (bad != null) {
2154                     bad[0] = true;
2155                     badKeyUsage = true;
2156                 }
2157             }
2158         }
2159 
2160         try {
2161             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2162             if (xKeyUsage != null) {
2163                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2164                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2165                     if (bad != null) {
2166                         bad[1] = true;
2167                         badExtendedKeyUsage = true;
2168                     }
2169                 }
2170             }
2171         } catch (java.security.cert.CertificateParsingException e) {
2172             // shouldn&#39;t happen
2173         }
2174 
2175         try {
2176             // OID_NETSCAPE_CERT_TYPE
2177             byte[] netscapeEx = userCert.getExtensionValue
2178                     (&quot;2.16.840.1.113730.1.1&quot;);
2179             if (netscapeEx != null) {
2180                 DerInputStream in = new DerInputStream(netscapeEx);
2181                 byte[] encoded = in.getOctetString();
2182                 encoded = new DerValue(encoded).getUnalignedBitString()
2183                         .toByteArray();
2184 
2185                 NetscapeCertTypeExtension extn =
2186                         new NetscapeCertTypeExtension(encoded);
2187 
2188                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2189                 if (!val) {
2190                     if (bad != null) {
2191                         bad[2] = true;
2192                         badNetscapeCertType = true;
2193                     }
2194                 }
2195             }
2196         } catch (IOException e) {
2197             //
2198         }
2199     }
2200 
2201     // Called by signJar().
2202     void getAliasInfo(String alias) throws Exception {
2203 
2204         Key key = null;
2205 
2206         try {
2207             java.security.cert.Certificate[] cs = null;
2208             if (altCertChain != null) {
2209                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2210                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2211                             generateCertificates(fis).
2212                             toArray(new Certificate[0]);
2213                 } catch (FileNotFoundException ex) {
2214                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2215                 } catch (CertificateException | IOException ex) {
2216                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2217                 }
2218             } else {
2219                 try {
2220                     cs = store.getCertificateChain(alias);
2221                 } catch (KeyStoreException kse) {
2222                     // this never happens, because keystore has been loaded
2223                 }
2224             }
2225             if (cs == null || cs.length == 0) {
2226                 if (altCertChain != null) {
2227                     error(rb.getString
2228                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2229                 } else {
2230                     MessageFormat form = new MessageFormat(rb.getString
2231                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2232                     Object[] source = {alias, alias};
2233                     error(form.format(source));
2234                 }
2235             }
2236 
2237             certChain = new X509Certificate[cs.length];
2238             for (int i=0; i&lt;cs.length; i++) {
2239                 if (!(cs[i] instanceof X509Certificate)) {
2240                     error(rb.getString
2241                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2242                 }
2243                 certChain[i] = (X509Certificate)cs[i];
2244             }
2245 
2246             try {
2247                 if (!token &amp;&amp; keypass == null)
2248                     key = store.getKey(alias, storepass);
2249                 else
2250                     key = store.getKey(alias, keypass);
2251             } catch (UnrecoverableKeyException e) {
2252                 if (token) {
2253                     throw e;
2254                 } else if (keypass == null) {
2255                     // Did not work out, so prompt user for key password
2256                     MessageFormat form = new MessageFormat(rb.getString
2257                         (&quot;Enter.key.password.for.alias.&quot;));
2258                     Object[] source = {alias};
2259                     keypass = getPass(form.format(source));
2260                     key = store.getKey(alias, keypass);
2261                 }
2262             }
2263         } catch (NoSuchAlgorithmException e) {
2264             error(e.getMessage());
2265         } catch (UnrecoverableKeyException e) {
2266             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2267         } catch (KeyStoreException kse) {
2268             // this never happens, because keystore has been loaded
2269         }
2270 
2271         if (!(key instanceof PrivateKey)) {
2272             MessageFormat form = new MessageFormat(rb.getString
2273                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2274             Object[] source = {alias};
2275             error(form.format(source));
2276         } else {
2277             privateKey = (PrivateKey)key;
2278         }
2279     }
2280 
2281     void error(String message) {
2282         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2283         System.exit(1);
2284     }
2285 
2286 
2287     void error(String message, Throwable e) {
2288         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2289         if (debug) {
2290             e.printStackTrace();
2291         }
2292         System.exit(1);
2293     }
2294 
2295     /**
2296      * Validates a cert chain.
2297      *
2298      * @param parameter this might be a timestamp
2299      */
2300     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2301                            Timestamp parameter)
2302             throws Exception {
2303         try {
2304             Validator.getInstance(Validator.TYPE_PKIX,
2305                     variant,
2306                     pkixParameters)
2307                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2308                             null, parameter);
2309         } catch (Exception e) {
2310             if (debug) {
2311                 e.printStackTrace();
2312             }
2313 
2314             // Exception might be dismissed if another warning flag
2315             // is already set by printCert.
2316 
2317             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2318                     e instanceof ValidatorException) {
2319                 // Throw cause if it&#39;s CertPathValidatorException,
2320                 if (e.getCause() != null &amp;&amp;
2321                         e.getCause() instanceof CertPathValidatorException) {
2322                     e = (Exception) e.getCause();
2323                     Throwable t = e.getCause();
2324                     if ((t instanceof CertificateExpiredException &amp;&amp;
2325                             hasExpiredTsaCert)) {
2326                         // we already have hasExpiredTsaCert
2327                         return;
2328                     }
2329                 }
2330             }
2331 
2332             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2333                     e instanceof ValidatorException) {
2334                 // Throw cause if it&#39;s CertPathValidatorException,
2335                 if (e.getCause() != null &amp;&amp;
2336                         e.getCause() instanceof CertPathValidatorException) {
2337                     e = (Exception) e.getCause();
2338                     Throwable t = e.getCause();
2339                     if ((t instanceof CertificateExpiredException &amp;&amp;
2340                                 hasExpiredCert) ||
2341                             (t instanceof CertificateNotYetValidException &amp;&amp;
2342                                     notYetValidCert)) {
2343                         // we already have hasExpiredCert and notYetValidCert
2344                         return;
2345                     }
2346                 }
2347                 if (e instanceof ValidatorException) {
2348                     ValidatorException ve = (ValidatorException)e;
2349                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2350                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2351                         // We already have badKeyUsage, badExtendedKeyUsage
2352                         // and badNetscapeCertType
2353                         return;
2354                     }
2355                 }
2356             }
2357             throw e;
2358         }
2359     }
2360 
2361     char[] getPass(String prompt) {
2362         System.err.print(prompt);
2363         System.err.flush();
2364         try {
2365             char[] pass = Password.readPassword(System.in);
2366 
2367             if (pass == null) {
2368                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2369             } else {
2370                 return pass;
2371             }
2372         } catch (IOException ioe) {
2373             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2374         }
2375         // this shouldn&#39;t happen
2376         return null;
2377     }
2378 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>