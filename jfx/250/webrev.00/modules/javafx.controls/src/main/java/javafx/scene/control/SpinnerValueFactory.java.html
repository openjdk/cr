<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/SpinnerValueFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene.control;
  26 
  27 import javafx.beans.NamedArg;
  28 import javafx.beans.property.BooleanProperty;
  29 import javafx.beans.property.DoubleProperty;
  30 import javafx.beans.property.IntegerProperty;
  31 import javafx.beans.property.LongProperty;
  32 import javafx.beans.property.ObjectProperty;
  33 import javafx.beans.property.SimpleBooleanProperty;
  34 import javafx.beans.property.SimpleDoubleProperty;
  35 import javafx.beans.property.SimpleIntegerProperty;
  36 import javafx.beans.property.SimpleLongProperty;
  37 import javafx.beans.property.SimpleObjectProperty;
  38 import javafx.collections.ListChangeListener;
  39 import javafx.collections.ObservableList;
  40 import javafx.collections.WeakListChangeListener;
  41 import javafx.util.StringConverter;
  42 import javafx.util.converter.IntegerStringConverter;
  43 
  44 import java.lang.ref.WeakReference;
  45 import java.math.BigDecimal;
  46 import java.text.DecimalFormat;
  47 import java.text.ParseException;
  48 import java.time.Duration;
  49 import java.time.LocalDate;
  50 import java.time.LocalTime;
  51 import java.time.format.DateTimeFormatter;
  52 import java.time.format.FormatStyle;
  53 import java.time.temporal.ChronoUnit;
  54 import java.time.temporal.TemporalUnit;
  55 import java.util.List;
  56 
  57 /**
  58  * The SpinnerValueFactory is the model behind the JavaFX
  59  * {@link Spinner Spinner control} - without a value factory installed a
  60  * Spinner is unusable. It is the role of the value factory to handle almost all
  61  * aspects of the Spinner, including:
  62  *
  63  * &lt;ul&gt;
  64  *     &lt;li&gt;Representing the current state of the {@link javafx.scene.control.SpinnerValueFactory#valueProperty() value},&lt;/li&gt;
  65  *     &lt;li&gt;{@link SpinnerValueFactory#increment(int) Incrementing}
  66  *         and {@link SpinnerValueFactory#decrement(int) decrementing} the
  67  *         value, with one or more steps per call,&lt;/li&gt;
  68  *     &lt;li&gt;{@link javafx.scene.control.SpinnerValueFactory#converterProperty() Converting} text input
  69  *         from the user (via the Spinner {@link Spinner#editorProperty() editor},&lt;/li&gt;
  70  *     &lt;li&gt;Converting {@link javafx.scene.control.SpinnerValueFactory#converterProperty() objects to user-readable strings}
  71  *         for display on screen&lt;/li&gt;
  72  * &lt;/ul&gt;
  73  *
  74  * &lt;p&gt;SpinnerValueFactory classes for some common types are provided with JavaFX, including:
  75  *
  76  * &lt;ul&gt;
  77  *     &lt;li&gt;{@link SpinnerValueFactory.IntegerSpinnerValueFactory}&lt;/li&gt;
  78  *     &lt;li&gt;{@link SpinnerValueFactory.DoubleSpinnerValueFactory}&lt;/li&gt;
  79  *     &lt;li&gt;{@link SpinnerValueFactory.ListSpinnerValueFactory}&lt;/li&gt;
  80  * &lt;/ul&gt;
  81  *
  82  * @param &lt;T&gt; The type of the data this value factory deals with, which must
  83  *            coincide with the type of the Spinner that the value factory is set on.
  84  * @see Spinner
  85  * @see SpinnerValueFactory.IntegerSpinnerValueFactory
  86  * @see SpinnerValueFactory.DoubleSpinnerValueFactory
  87  * @see SpinnerValueFactory.ListSpinnerValueFactory
  88  * @since JavaFX 8u40
  89  */
  90 public abstract class SpinnerValueFactory&lt;T&gt; {
  91 
  92     /**
  93      * Creates a default SpinnerValueFactory.
  94      */
  95     public SpinnerValueFactory() {}
  96 
  97     /***************************************************************************
  98      *                                                                         *
  99      * Private fields                                                          *
 100      *                                                                         *
 101      **************************************************************************/
 102 
 103 
 104 
 105     /***************************************************************************
 106      *                                                                         *
 107      * Abstract methods                                                        *
 108      *                                                                         *
 109      **************************************************************************/
 110 
 111     /**
 112      * Attempts to decrement the {@link #valueProperty() value} by the given
 113      * number of steps.
 114      *
 115      * @param steps The number of decrements that should be performed on the value.
 116      */
 117     public abstract void decrement(int steps);
 118 
 119 
 120     /**
 121      * Attempts to omcrement the {@link #valueProperty() value} by the given
 122      * number of steps.
 123      *
 124      * @param steps The number of increments that should be performed on the value.
 125      */
 126     public abstract void increment(int steps);
 127 
 128 
 129 
 130     /***************************************************************************
 131      *                                                                         *
 132      * Properties                                                              *
 133      *                                                                         *
 134      **************************************************************************/
 135 
 136     // --- value
 137     /**
 138      * Represents the current value of the SpinnerValueFactory, or null if no
 139      * value has been set.
 140      */
 141     private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;&gt;(this, &quot;value&quot;);
 142     public final T getValue() {
 143         return value.get();
 144     }
 145     public final void setValue(T newValue) {
 146         value.set(newValue);
 147     }
 148     public final ObjectProperty&lt;T&gt; valueProperty() {
 149         return value;
 150     }
 151 
 152 
 153     // --- converter
 154     /**
 155      * Converts the user-typed input (when the Spinner is
 156      * {@link Spinner#editableProperty() editable}) to an object of type T,
 157      * such that the input may be retrieved via the  {@link #valueProperty() value}
 158      * property.
 159      */
 160     private ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converter = new SimpleObjectProperty&lt;&gt;(this, &quot;converter&quot;);
 161     public final StringConverter&lt;T&gt; getConverter() {
 162         return converter.get();
 163     }
 164     public final void setConverter(StringConverter&lt;T&gt; newValue) {
 165         converter.set(newValue);
 166     }
 167     public final ObjectProperty&lt;StringConverter&lt;T&gt;&gt; converterProperty() {
 168         return converter;
 169     }
 170 
 171 
 172     // --- wrapAround
 173     /**
 174      * The wrapAround property is used to specify whether the value factory should
 175      * be circular. For example, should an integer-based value model increment
 176      * from the maximum value back to the minimum value (and vice versa).
 177      */
 178     private BooleanProperty wrapAround;
 179     public final void setWrapAround(boolean value) {
 180         wrapAroundProperty().set(value);
 181     }
 182     public final boolean isWrapAround() {
 183         return wrapAround == null ? false : wrapAround.get();
 184     }
 185     public final BooleanProperty wrapAroundProperty() {
 186         if (wrapAround == null) {
 187             wrapAround = new SimpleBooleanProperty(this, &quot;wrapAround&quot;, false);
 188         }
 189         return wrapAround;
 190     }
 191 
 192 
 193 
 194     /***************************************************************************
 195      *                                                                         *
 196      * Subclasses of SpinnerValueFactory                                       *
 197      *                                                                         *
 198      **************************************************************************/
 199 
 200     /**
 201      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 202      * a list of values.
 203      *
 204      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 205      * simply as shown below, which may be adequate in many cases, but it is important
 206      * for users to ensure that this suits their needs (and adjust when necessary):
 207      *
 208      * &lt;pre&gt;
 209      * setConverter(new StringConverter&amp;lt;T&amp;gt;() {
 210      *     &amp;#064;Override public String toString(T value) {
 211      *         if (value == null) {
 212      *             return &quot;&quot;;
 213      *         }
 214      *         return value.toString();
 215      *     }
 216      *
 217      *     &amp;#064;Override public T fromString(String string) {
 218      *         return (T) string;
 219      *     }
 220      * });&lt;/pre&gt;
 221      *
 222      * @param &lt;T&gt; The type of the elements in the {@link java.util.List}.
 223      * @since JavaFX 8u40
 224      */
 225     public static class ListSpinnerValueFactory&lt;T&gt; extends SpinnerValueFactory&lt;T&gt; {
 226 
 227         /***********************************************************************
 228          *                                                                     *
 229          * Private fields                                                      *
 230          *                                                                     *
 231          **********************************************************************/
 232 
 233         private int currentIndex = 0;
 234 
 235         private final ListChangeListener&lt;T&gt; itemsContentObserver = c -&gt; {
 236             // the items content has changed. We do not try to find the current
 237             // item, instead we remain at the currentIndex, if possible, or else
 238             // we go back to index 0, and if that fails, we go to null
 239             updateCurrentIndex();
 240         };
 241 
 242         private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
 243                 new WeakListChangeListener&lt;T&gt;(itemsContentObserver);
 244 
 245 
 246 
 247         /***********************************************************************
 248          *                                                                     *
 249          * Constructors                                                        *
 250          *                                                                     *
 251          **********************************************************************/
 252 
 253         /**
 254          * Creates a new instance of the ListSpinnerValueFactory with the given
 255          * list used as the list to step through.
 256          *
 257          * @param items The list of items to step through with the Spinner.
 258          */
 259         public ListSpinnerValueFactory(@NamedArg(&quot;items&quot;) ObservableList&lt;T&gt; items) {
 260             setItems(items);
 261             setConverter(new StringConverter&lt;T&gt;() {
 262                 @Override public String toString(T value) {
 263                     if (value == null) {
 264                         return &quot;&quot;;
 265                     }
 266                     return value.toString();
 267                 }
 268 
 269                 @Override public T fromString(String string) {
 270                     return (T) string;
 271                 }
 272             });
 273 
 274             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 275                 // when the value is set, we need to react to ensure it is a
 276                 // valid value (and if not, blow up appropriately)
 277                 int newIndex = -1;
 278                 if (items.contains(newValue)) {
 279                     newIndex = items.indexOf(newValue);
 280                 } else {
 281                     // add newValue to list
 282                     items.add(newValue);
 283                     newIndex = items.indexOf(newValue);
 284                 }
 285                 currentIndex = newIndex;
 286             });
 287             setValue(_getValue(currentIndex));
 288         }
 289 
 290 
 291 
 292         /***********************************************************************
 293          *                                                                     *
 294          * Properties                                                          *
 295          *                                                                     *
 296          **********************************************************************/
 297         // --- Items
 298         private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;
 299 
 300         /**
 301          * Sets the underlying data model for the ListSpinnerValueFactory. Note that it has a generic
 302          * type that must match the type of the Spinner itself.
 303          * @param value the list of items
 304          */
 305         public final void setItems(ObservableList&lt;T&gt; value) {
 306             itemsProperty().set(value);
 307         }
 308 
 309         /**
 310          * Returns an {@link javafx.collections.ObservableList} that contains the items currently able
 311          * to be iterated through by the user. This may be null if
 312          * {@link #setItems(javafx.collections.ObservableList)} has previously been
 313          * called, however, by default it is an empty ObservableList.
 314          *
 315          * @return An ObservableList containing the items to be shown to the user, or
 316          *      null if the items have previously been set to null.
 317          */
 318         public final ObservableList&lt;T&gt; getItems() {
 319             return items == null ? null : items.get();
 320         }
 321 
 322         /**
 323          * The underlying data model for the ListView. Note that it has a generic
 324          * type that must match the type of the ListView itself.
 325          * @return the list of items
 326          */
 327         public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
 328             if (items == null) {
 329                 items = new SimpleObjectProperty&lt;ObservableList&lt;T&gt;&gt;(this, &quot;items&quot;) {
 330                     WeakReference&lt;ObservableList&lt;T&gt;&gt; oldItemsRef;
 331 
 332                     @Override protected void invalidated() {
 333                         ObservableList&lt;T&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
 334                         ObservableList&lt;T&gt; newItems = getItems();
 335 
 336                         // update listeners
 337                         if (oldItems != null) {
 338                             oldItems.removeListener(weakItemsContentObserver);
 339                         }
 340                         if (newItems != null) {
 341                             newItems.addListener(weakItemsContentObserver);
 342                         }
 343 
 344                         // update the current value based on the index
 345                         updateCurrentIndex();
 346 
 347                         oldItemsRef = new WeakReference&lt;&gt;(getItems());
 348                     }
 349                 };
 350             }
 351             return items;
 352         }
 353 
 354 
 355 
 356         /***********************************************************************
 357          *                                                                     *
 358          * Overridden methods                                                  *
 359          *                                                                     *
 360          **********************************************************************/
 361 
 362         /** {@inheritDoc} */
 363         @Override public void decrement(int steps) {
 364             final int max = getItemsSize() - 1;
 365             int newIndex = currentIndex - steps;
 366             currentIndex = newIndex &gt;= 0 ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : 0);
 367             setValue(_getValue(currentIndex));
 368         }
 369 
 370         /** {@inheritDoc} */
 371         @Override public void increment(int steps) {
 372             final int max = getItemsSize() - 1;
 373             int newIndex = currentIndex + steps;
 374             currentIndex = newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, 0, max + 1) : max);
 375             setValue(_getValue(currentIndex));
 376         }
 377 
 378 
 379 
 380         /***********************************************************************
 381          *                                                                     *
 382          * Private implementation                                              *
 383          *                                                                     *
 384          **********************************************************************/
 385         private int getItemsSize() {
 386             List&lt;T&gt; items = getItems();
 387             return items == null ? 0 : items.size();
 388         }
 389 
 390         private void updateCurrentIndex() {
 391             int itemsSize = getItemsSize();
 392             if (currentIndex &lt; 0 || currentIndex &gt;= itemsSize) {
 393                 currentIndex = 0;
 394             }
 395             setValue(_getValue(currentIndex));
 396         }
 397 
 398         private T _getValue(int index) {
 399             List&lt;T&gt; items = getItems();
 400             return items == null ? null : (index &gt;= 0 &amp;&amp; index &lt; items.size()) ? items.get(index) : null;
 401         }
 402     }
 403 
 404 
 405 
 406     /**
 407      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 408      * integer values.
 409      *
 410      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 411      * as an {@link javafx.util.converter.IntegerStringConverter} instance.
 412      *
 413      * @since JavaFX 8u40
 414      */
 415     public static class IntegerSpinnerValueFactory extends SpinnerValueFactory&lt;Integer&gt; {
 416 
 417         /***********************************************************************
 418          *                                                                     *
 419          * Constructors                                                        *
 420          *                                                                     *
 421          **********************************************************************/
 422 
 423         /**
 424          * Constructs a new IntegerSpinnerValueFactory that sets the initial value
 425          * to be equal to the min value, and a default {@code amountToStepBy} of one.
 426          *
 427          * @param min The minimum allowed integer value for the Spinner.
 428          * @param max The maximum allowed integer value for the Spinner.
 429          */
 430         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 431                                           @NamedArg(&quot;max&quot;) int max) {
 432             this(min, max, min);
 433         }
 434 
 435         /**
 436          * Constructs a new IntegerSpinnerValueFactory with a default
 437          * {@code amountToStepBy} of one.
 438          *
 439          * @param min The minimum allowed integer value for the Spinner.
 440          * @param max The maximum allowed integer value for the Spinner.
 441          * @param initialValue The value of the Spinner when first instantiated, must
 442          *                     be within the bounds of the min and max arguments, or
 443          *                     else the min value will be used.
 444          */
 445         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 446                                           @NamedArg(&quot;max&quot;) int max,
 447                                           @NamedArg(&quot;initialValue&quot;) int initialValue) {
 448             this(min, max, initialValue, 1);
 449         }
 450 
 451         /**
 452          * Constructs a new IntegerSpinnerValueFactory.
 453          *
 454          * @param min The minimum allowed integer value for the Spinner.
 455          * @param max The maximum allowed integer value for the Spinner.
 456          * @param initialValue The value of the Spinner when first instantiated, must
 457          *                     be within the bounds of the min and max arguments, or
 458          *                     else the min value will be used.
 459          * @param amountToStepBy The amount to increment or decrement by, per step.
 460          */
 461         public IntegerSpinnerValueFactory(@NamedArg(&quot;min&quot;) int min,
 462                                           @NamedArg(&quot;max&quot;) int max,
 463                                           @NamedArg(&quot;initialValue&quot;) int initialValue,
 464                                           @NamedArg(&quot;amountToStepBy&quot;) int amountToStepBy) {
 465             setMin(min);
 466             setMax(max);
 467             setAmountToStepBy(amountToStepBy);
 468             setConverter(new IntegerStringConverter());
 469 
 470             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 471                 // when the value is set, we need to react to ensure it is a
 472                 // valid value (and if not, blow up appropriately)
 473                 if (newValue &lt; getMin()) {
 474                     setValue(getMin());
 475                 } else if (newValue &gt; getMax()) {
 476                     setValue(getMax());
 477                 }
 478             });
 479             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 480         }
 481 
 482 
 483         /***********************************************************************
 484          *                                                                     *
 485          * Properties                                                          *
 486          *                                                                     *
 487          **********************************************************************/
 488 
 489         // --- min
 490         private IntegerProperty min = new SimpleIntegerProperty(this, &quot;min&quot;) {
 491             @Override protected void invalidated() {
 492                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 493                 if (currentValue == null) {
 494                     return;
 495                 }
 496 
 497                 int newMin = get();
 498                 if (newMin &gt; getMax()) {
 499                     setMin(getMax());
 500                     return;
 501                 }
 502 
 503                 if (currentValue &lt; newMin) {
 504                     IntegerSpinnerValueFactory.this.setValue(newMin);
 505                 }
 506             }
 507         };
 508 
 509         public final void setMin(int value) {
 510             min.set(value);
 511         }
 512         public final int getMin() {
 513             return min.get();
 514         }
 515         /**
 516          * Sets the minimum allowable value for this value factory
 517          * @return the minimum allowable value for this value factory
 518          */
 519         public final IntegerProperty minProperty() {
 520             return min;
 521         }
 522 
 523         // --- max
 524         private IntegerProperty max = new SimpleIntegerProperty(this, &quot;max&quot;) {
 525             @Override protected void invalidated() {
 526                 Integer currentValue = IntegerSpinnerValueFactory.this.getValue();
 527                 if (currentValue == null) {
 528                     return;
 529                 }
 530 
 531                 int newMax = get();
 532                 if (newMax &lt; getMin()) {
 533                     setMax(getMin());
 534                     return;
 535                 }
 536 
 537                 if (currentValue &gt; newMax) {
 538                     IntegerSpinnerValueFactory.this.setValue(newMax);
 539                 }
 540             }
 541         };
 542 
 543         public final void setMax(int value) {
 544             max.set(value);
 545         }
 546         public final int getMax() {
 547             return max.get();
 548         }
 549         /**
 550          * Sets the maximum allowable value for this value factory
 551          * @return the maximum allowable value for this value factory
 552          */
 553         public final IntegerProperty maxProperty() {
 554             return max;
 555         }
 556 
 557         // --- amountToStepBy
 558         private IntegerProperty amountToStepBy = new SimpleIntegerProperty(this, &quot;amountToStepBy&quot;);
 559         public final void setAmountToStepBy(int value) {
 560             amountToStepBy.set(value);
 561         }
 562         public final int getAmountToStepBy() {
 563             return amountToStepBy.get();
 564         }
 565         /**
 566          * Sets the amount to increment or decrement by, per step.
 567          * @return the amount to increment or decrement by, per step
 568          */
 569         public final IntegerProperty amountToStepByProperty() {
 570             return amountToStepBy;
 571         }
 572 
 573 
 574 
 575         /***********************************************************************
 576          *                                                                     *
 577          * Overridden methods                                                  *
 578          *                                                                     *
 579          **********************************************************************/
 580 
 581         /** {@inheritDoc} */
 582         @Override public void decrement(int steps) {
 583             final int min = getMin();
 584             final int max = getMax();
 585             final int newIndex = getValue() - steps * getAmountToStepBy();
 586             setValue(newIndex &gt;= min ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max) + 1 : min));
 587         }
 588 
 589         /** {@inheritDoc} */
 590         @Override public void increment(int steps) {
 591             final int min = getMin();
 592             final int max = getMax();
 593             final int currentValue = getValue();
 594             final int newIndex = currentValue + steps * getAmountToStepBy();
 595             setValue(newIndex &lt;= max ? newIndex : (isWrapAround() ? Spinner.wrapValue(newIndex, min, max) - 1 : max));
 596         }
 597     }
 598 
 599 
 600 
 601     /**
 602      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 603      * double values.
 604      *
 605      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 606      * simply as shown below, which may be adequate in many cases, but it is important
 607      * for users to ensure that this suits their needs (and adjust when necessary). The
 608      * main point to note is that this {@link javafx.util.StringConverter} embeds
 609      * within it a {@link java.text.DecimalFormat} instance that shows the Double
 610      * to two decimal places. This is used for both the toString and fromString
 611      * methods:
 612      *
 613      * &lt;pre&gt;
 614      * setConverter(new StringConverter&amp;lt;Double&amp;gt;() {
 615      *     private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 616      *
 617      *     &amp;#064;Override public String toString(Double value) {
 618      *         // If the specified value is null, return a zero-length String
 619      *         if (value == null) {
 620      *             return &quot;&quot;;
 621      *         }
 622      *
 623      *         return df.format(value);
 624      *     }
 625      *
 626      *     &amp;#064;Override public Double fromString(String value) {
 627      *         try {
 628      *             // If the specified value is null or zero-length, return null
 629      *             if (value == null) {
 630      *                 return null;
 631      *             }
 632      *
 633      *             value = value.trim();
 634      *
 635      *             if (value.length() &amp;lt; 1) {
 636      *                 return null;
 637      *             }
 638      *
 639      *             // Perform the requested parsing
 640      *             return df.parse(value).doubleValue();
 641      *         } catch (ParseException ex) {
 642      *             throw new RuntimeException(ex);
 643      *         }
 644      *     }
 645      * });&lt;/pre&gt;
 646      *
 647      * @since JavaFX 8u40
 648      */
 649     public static class DoubleSpinnerValueFactory extends SpinnerValueFactory&lt;Double&gt; {
 650 
 651         /**
 652          * Constructs a new DoubleSpinnerValueFactory that sets the initial value
 653          * to be equal to the min value, and a default {@code amountToStepBy} of
 654          * one.
 655          *
 656          * @param min The minimum allowed double value for the Spinner.
 657          * @param max The maximum allowed double value for the Spinner.
 658          */
 659         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 660                                          @NamedArg(&quot;max&quot;) double max) {
 661             this(min, max, min);
 662         }
 663 
 664         /**
 665          * Constructs a new DoubleSpinnerValueFactory with a default
 666          * {@code amountToStepBy} of one.
 667          *
 668          * @param min The minimum allowed double value for the Spinner.
 669          * @param max The maximum allowed double value for the Spinner.
 670          * @param initialValue The value of the Spinner when first instantiated, must
 671          *                     be within the bounds of the min and max arguments, or
 672          *                     else the min value will be used.
 673          */
 674         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 675                                          @NamedArg(&quot;max&quot;) double max,
 676                                          @NamedArg(&quot;initialValue&quot;) double initialValue) {
 677             this(min, max, initialValue, 1);
 678         }
 679 
 680         /**
 681          * Constructs a new DoubleSpinnerValueFactory.
 682          *
 683          * @param min The minimum allowed double value for the Spinner.
 684          * @param max The maximum allowed double value for the Spinner.
 685          * @param initialValue The value of the Spinner when first instantiated, must
 686          *                     be within the bounds of the min and max arguments, or
 687          *                     else the min value will be used.
 688          * @param amountToStepBy The amount to increment or decrement by, per step.
 689          */
 690         public DoubleSpinnerValueFactory(@NamedArg(&quot;min&quot;) double min,
 691                                          @NamedArg(&quot;max&quot;) double max,
 692                                          @NamedArg(&quot;initialValue&quot;) double initialValue,
 693                                          @NamedArg(&quot;amountToStepBy&quot;) double amountToStepBy) {
 694             setMin(min);
 695             setMax(max);
 696             setAmountToStepBy(amountToStepBy);
 697             setConverter(new StringConverter&lt;Double&gt;() {
 698                 private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);
 699 
 700                 @Override public String toString(Double value) {
 701                     // If the specified value is null, return a zero-length String
 702                     if (value == null) {
 703                         return &quot;&quot;;
 704                     }
 705 
 706                     return df.format(value);
 707                 }
 708 
 709                 @Override public Double fromString(String value) {
 710                     try {
 711                         // If the specified value is null or zero-length, return null
 712                         if (value == null) {
 713                             return null;
 714                         }
 715 
 716                         value = value.trim();
 717 
 718                         if (value.length() &lt; 1) {
 719                             return null;
 720                         }
 721 
 722                         // Perform the requested parsing
 723                         return df.parse(value).doubleValue();
 724                     } catch (ParseException ex) {
 725                         throw new RuntimeException(ex);
 726                     }
 727                 }
 728             });
 729 
 730             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 731                 if (newValue == null) return;
 732 
 733                 // when the value is set, we need to react to ensure it is a
 734                 // valid value (and if not, blow up appropriately)
 735                 if (newValue &lt; getMin()) {
 736                     setValue(getMin());
 737                 } else if (newValue &gt; getMax()) {
 738                     setValue(getMax());
 739                 }
 740             });
 741             setValue(initialValue &gt;= min &amp;&amp; initialValue &lt;= max ? initialValue : min);
 742         }
 743 
 744 
 745 
 746         /***********************************************************************
 747          *                                                                     *
 748          * Properties                                                          *
 749          *                                                                     *
 750          **********************************************************************/
 751 
 752         // --- min
 753         private DoubleProperty min = new SimpleDoubleProperty(this, &quot;min&quot;) {
 754             @Override protected void invalidated() {
 755                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 756                 if (currentValue == null) {
 757                     return;
 758                 }
 759 
 760                 final double newMin = get();
 761                 if (newMin &gt; getMax()) {
 762                     setMin(getMax());
 763                     return;
 764                 }
 765 
 766                 if (currentValue &lt; newMin) {
 767                     DoubleSpinnerValueFactory.this.setValue(newMin);
 768                 }
 769             }
 770         };
 771 
 772         public final void setMin(double value) {
 773             min.set(value);
 774         }
 775         public final double getMin() {
 776             return min.get();
 777         }
 778         /**
 779          * Sets the minimum allowable value for this value factory
 780          * @return the minimum allowable value for this value factory
 781          */
 782         public final DoubleProperty minProperty() {
 783             return min;
 784         }
 785 
 786         // --- max
 787         private DoubleProperty max = new SimpleDoubleProperty(this, &quot;max&quot;) {
 788             @Override protected void invalidated() {
 789                 Double currentValue = DoubleSpinnerValueFactory.this.getValue();
 790                 if (currentValue == null) {
 791                     return;
 792                 }
 793 
 794                 final double newMax = get();
 795                 if (newMax &lt; getMin()) {
 796                     setMax(getMin());
 797                     return;
 798                 }
 799 
 800                 if (currentValue &gt; newMax) {
 801                     DoubleSpinnerValueFactory.this.setValue(newMax);
 802                 }
 803             }
 804         };
 805 
 806         public final void setMax(double value) {
 807             max.set(value);
 808         }
 809         public final double getMax() {
 810             return max.get();
 811         }
 812         /**
 813          * Sets the maximum allowable value for this value factory
 814          * @return the maximum allowable value for this value factory
 815          */
 816         public final DoubleProperty maxProperty() {
 817             return max;
 818         }
 819 
 820         // --- amountToStepBy
 821         private DoubleProperty amountToStepBy = new SimpleDoubleProperty(this, &quot;amountToStepBy&quot;);
 822         public final void setAmountToStepBy(double value) {
 823             amountToStepBy.set(value);
 824         }
 825         public final double getAmountToStepBy() {
 826             return amountToStepBy.get();
 827         }
 828         /**
 829          * Sets the amount to increment or decrement by, per step.
 830          * @return the amount to increment or decrement by, per step
 831          */
 832         public final DoubleProperty amountToStepByProperty() {
 833             return amountToStepBy;
 834         }
 835 
 836 
 837 
 838         /** {@inheritDoc} */
 839         @Override public void decrement(int steps) {
 840             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 841             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 842             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 843             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 844             BigDecimal newValue = currentValue.subtract(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 845             setValue(newValue.compareTo(minBigDecimal) &gt;= 0 ? newValue.doubleValue() :
 846                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMin()));
 847         }
 848 
 849         /** {@inheritDoc} */
 850         @Override public void increment(int steps) {
 851             final BigDecimal currentValue = BigDecimal.valueOf(getValue());
 852             final BigDecimal minBigDecimal = BigDecimal.valueOf(getMin());
 853             final BigDecimal maxBigDecimal = BigDecimal.valueOf(getMax());
 854             final BigDecimal amountToStepByBigDecimal = BigDecimal.valueOf(getAmountToStepBy());
 855             BigDecimal newValue = currentValue.add(amountToStepByBigDecimal.multiply(BigDecimal.valueOf(steps)));
 856             setValue(newValue.compareTo(maxBigDecimal) &lt;= 0 ? newValue.doubleValue() :
 857                     (isWrapAround() ? Spinner.wrapValue(newValue, minBigDecimal, maxBigDecimal).doubleValue() : getMax()));
 858         }
 859     }
 860 
 861     /**
 862      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
 863      * {@link java.time.LocalDate} values.
 864      *
 865      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
 866      * simply as shown below, which may be adequate in many cases, but it is important
 867      * for users to ensure that this suits their needs (and adjust when necessary):
 868      *
 869      * &lt;pre&gt;
 870      * setConverter(new StringConverter&amp;lt;LocalDate&amp;gt;() {
 871      *     &amp;#064;Override public String toString(LocalDate object) {
 872      *         if (object == null) {
 873      *             return &quot;&quot;;
 874      *         }
 875      *         return object.toString();
 876      *     }
 877      *
 878      *     &amp;#064;Override public LocalDate fromString(String string) {
 879      *         return LocalDate.parse(string);
 880      *     }
 881      * });&lt;/pre&gt;
 882      */
 883     static class LocalDateSpinnerValueFactory extends SpinnerValueFactory&lt;LocalDate&gt; {
 884 
 885         /**
 886          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 887          * value returned by calling {@code LocalDate#now()} as the initial value,
 888          * and using a stepping amount of one day.
 889          */
 890         public LocalDateSpinnerValueFactory() {
 891             this(LocalDate.now());
 892         }
 893 
 894         /**
 895          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 896          * provided initial value, and a stepping amount of one day.
 897          *
 898          * @param initialValue The value of the Spinner when first instantiated.
 899          */
 900         public LocalDateSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 901             this(LocalDate.MIN, LocalDate.MAX, initialValue);
 902         }
 903 
 904         /**
 905          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 906          * provided initial value, and a stepping amount of one day.
 907          *
 908          * @param min The minimum allowed double value for the Spinner.
 909          * @param max The maximum allowed double value for the Spinner.
 910          * @param initialValue The value of the Spinner when first instantiated.
 911          */
 912         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 913                                             @NamedArg(&quot;min&quot;) LocalDate max,
 914                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue) {
 915             this(min, max, initialValue, 1, ChronoUnit.DAYS);
 916         }
 917 
 918         /**
 919          * Creates a new instance of the LocalDateSpinnerValueFactory, using the
 920          * provided min, max, and initial values, as well as the amount to step
 921          * by and {@link java.time.temporal.TemporalUnit}.
 922          *
 923          * &lt;p&gt;To better understand, here are a few examples:
 924          *
 925          * &lt;ul&gt;
 926          *     &lt;li&gt;&lt;strong&gt;To step by one day from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.DAYS)}&lt;/li&gt;
 927          *     &lt;li&gt;&lt;strong&gt;To step by one month from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.MONTHS)}&lt;/li&gt;
 928          *     &lt;li&gt;&lt;strong&gt;To step by one year from today: &lt;/strong&gt; {@code new LocalDateSpinnerValueFactory(LocalDate.MIN, LocalDate.MAX, LocalDate.now(), 1, ChronoUnit.YEARS)}&lt;/li&gt;
 929          * &lt;/ul&gt;
 930          *
 931          * @param min The minimum allowed double value for the Spinner.
 932          * @param max The maximum allowed double value for the Spinner.
 933          * @param initialValue The value of the Spinner when first instantiated.
 934          * @param amountToStepBy The amount to increment or decrement by, per step.
 935          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
 936          */
 937         public LocalDateSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalDate min,
 938                                             @NamedArg(&quot;min&quot;) LocalDate max,
 939                                             @NamedArg(&quot;initialValue&quot;) LocalDate initialValue,
 940                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
 941                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
 942             setMin(min);
 943             setMax(max);
 944             setAmountToStepBy(amountToStepBy);
 945             setTemporalUnit(temporalUnit);
 946             setConverter(new StringConverter&lt;LocalDate&gt;() {
 947                 @Override public String toString(LocalDate object) {
 948                     if (object == null) {
 949                         return &quot;&quot;;
 950                     }
 951                     return object.toString();
 952                 }
 953 
 954                 @Override public LocalDate fromString(String string) {
 955                     return LocalDate.parse(string);
 956                 }
 957             });
 958 
 959             valueProperty().addListener((o, oldValue, newValue) -&gt; {
 960                 // when the value is set, we need to react to ensure it is a
 961                 // valid value (and if not, blow up appropriately)
 962                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
 963                     setValue(getMin());
 964                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
 965                     setValue(getMax());
 966                 }
 967             });
 968             setValue(initialValue != null ? initialValue : LocalDate.now());
 969         }
 970 
 971 
 972 
 973         /***********************************************************************
 974          *                                                                     *
 975          * Properties                                                          *
 976          *                                                                     *
 977          **********************************************************************/
 978 
 979         // --- min
 980         private ObjectProperty&lt;LocalDate&gt; min = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;min&quot;) {
 981             @Override protected void invalidated() {
 982                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
 983                 if (currentValue == null) {
 984                     return;
 985                 }
 986 
 987                 final LocalDate newMin = get();
 988                 if (newMin.isAfter(getMax())) {
 989                     setMin(getMax());
 990                     return;
 991                 }
 992 
 993                 if (currentValue.isBefore(newMin)) {
 994                     LocalDateSpinnerValueFactory.this.setValue(newMin);
 995                 }
 996             }
 997         };
 998 
 999         public final void setMin(LocalDate value) {
1000             min.set(value);
1001         }
1002         public final LocalDate getMin() {
1003             return min.get();
1004         }
1005         /**
1006          * Sets the minimum allowable value for this value factory
1007          */
1008         public final ObjectProperty&lt;LocalDate&gt; minProperty() {
1009             return min;
1010         }
1011 
1012         // --- max
1013         private ObjectProperty&lt;LocalDate&gt; max = new SimpleObjectProperty&lt;LocalDate&gt;(this, &quot;max&quot;) {
1014             @Override protected void invalidated() {
1015                 LocalDate currentValue = LocalDateSpinnerValueFactory.this.getValue();
1016                 if (currentValue == null) {
1017                     return;
1018                 }
1019 
1020                 final LocalDate newMax = get();
1021                 if (newMax.isBefore(getMin())) {
1022                     setMax(getMin());
1023                     return;
1024                 }
1025 
1026                 if (currentValue.isAfter(newMax)) {
1027                     LocalDateSpinnerValueFactory.this.setValue(newMax);
1028                 }
1029             }
1030         };
1031 
1032         public final void setMax(LocalDate value) {
1033             max.set(value);
1034         }
1035         public final LocalDate getMax() {
1036             return max.get();
1037         }
1038         /**
1039          * Sets the maximum allowable value for this value factory
1040          */
1041         public final ObjectProperty&lt;LocalDate&gt; maxProperty() {
1042             return max;
1043         }
1044 
1045         // --- temporalUnit
1046         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1047         public final void setTemporalUnit(TemporalUnit value) {
1048             temporalUnit.set(value);
1049         }
1050         public final TemporalUnit getTemporalUnit() {
1051             return temporalUnit.get();
1052         }
1053         /**
1054          * The size of each step (e.g. day, week, month, year, etc).
1055          */
1056         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1057             return temporalUnit;
1058         }
1059 
1060         // --- amountToStepBy
1061         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1062         public final void setAmountToStepBy(long value) {
1063             amountToStepBy.set(value);
1064         }
1065         public final long getAmountToStepBy() {
1066             return amountToStepBy.get();
1067         }
1068         /**
1069          * Sets the amount to increment or decrement by, per step.
1070          */
1071         public final LongProperty amountToStepByProperty() {
1072             return amountToStepBy;
1073         }
1074 
1075 
1076 
1077         /***********************************************************************
1078          *                                                                     *
1079          * Overridden methods                                                  *
1080          *                                                                     *
1081          **********************************************************************/
1082 
1083         /** {@inheritDoc} */
1084         @Override public void decrement(int steps) {
1085             final LocalDate currentValue = getValue();
1086             final LocalDate min = getMin();
1087             LocalDate newValue = currentValue.minus(getAmountToStepBy() * steps, getTemporalUnit());
1088 
1089             if (min != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isBefore(min)) {
1090                 // we need to wrap around
1091                 newValue = getMax();
1092             }
1093 
1094             setValue(newValue);
1095         }
1096 
1097         /** {@inheritDoc} */
1098         @Override public void increment(int steps) {
1099             final LocalDate currentValue = getValue();
1100             final LocalDate max = getMax();
1101             LocalDate newValue = currentValue.plus(getAmountToStepBy() * steps, getTemporalUnit());
1102 
1103             if (max != null &amp;&amp; isWrapAround() &amp;&amp; newValue.isAfter(max)) {
1104                 // we need to wrap around
1105                 newValue = getMin();
1106             }
1107 
1108             setValue(newValue);
1109         }
1110     }
1111 
1112 
1113 
1114 
1115 
1116     /**
1117      * A {@link javafx.scene.control.SpinnerValueFactory} implementation designed to iterate through
1118      * {@link java.time.LocalTime} values.
1119      *
1120      * &lt;p&gt;Note that the default {@link #converterProperty() converter} is implemented
1121      * simply as shown below, which may be adequate in many cases, but it is important
1122      * for users to ensure that this suits their needs (and adjust when necessary):
1123      *
1124      * &lt;pre&gt;
1125      * setConverter(new StringConverter&amp;lt;LocalTime&amp;gt;() {
1126      *     &amp;#064;Override public String toString(LocalTime object) {
1127      *         if (object == null) {
1128      *             return &quot;&quot;;
1129      *         }
1130      *         return object.toString();
1131      *     }
1132      *
1133      *     &amp;#064;Override public LocalTime fromString(String string) {
1134      *         return LocalTime.parse(string);
1135      *     }
1136      * });&lt;/pre&gt;
1137      */
1138     static class LocalTimeSpinnerValueFactory extends SpinnerValueFactory&lt;LocalTime&gt; {
1139 
1140         /**
1141          * Creates a new instance of the LocalTimepinnerValueFactory, using the
1142          * value returned by calling {@code LocalTime#now()} as the initial value,
1143          * and using a stepping amount of one day.
1144          */
1145         public LocalTimeSpinnerValueFactory() {
1146             this(LocalTime.now());
1147         }
1148 
1149         /**
1150          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1151          * provided initial value, and a stepping amount of one hour.
1152          *
1153          * @param initialValue The value of the Spinner when first instantiated.
1154          */
1155         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1156             this(LocalTime.MIN, LocalTime.MAX, initialValue);
1157         }
1158 
1159         /**
1160          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1161          * provided initial value, and a stepping amount of one hour.
1162          *
1163          * @param min The minimum allowed double value for the Spinner.
1164          * @param max The maximum allowed double value for the Spinner.
1165          * @param initialValue The value of the Spinner when first instantiated.
1166          */
1167         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1168                                             @NamedArg(&quot;min&quot;) LocalTime max,
1169                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue) {
1170             this(min, max, initialValue, 1, ChronoUnit.HOURS);
1171         }
1172 
1173         /**
1174          * Creates a new instance of the LocalTimeSpinnerValueFactory, using the
1175          * provided min, max, and initial values, as well as the amount to step
1176          * by and {@link java.time.temporal.TemporalUnit}.
1177          *
1178          * &lt;p&gt;To better understand, here are a few examples:
1179          *
1180          * &lt;ul&gt;
1181          *     &lt;li&gt;&lt;strong&gt;To step by one hour from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.HOURS)}&lt;/li&gt;
1182          *     &lt;li&gt;&lt;strong&gt;To step by one minute from the current time: &lt;/strong&gt; {@code new LocalTimeSpinnerValueFactory(LocalTime.MIN, LocalTime.MAX, LocalTime.now(), 1, ChronoUnit.MINUTES)}&lt;/li&gt;
1183          * &lt;/ul&gt;
1184          *
1185          * @param min The minimum allowed double value for the Spinner.
1186          * @param max The maximum allowed double value for the Spinner.
1187          * @param initialValue The value of the Spinner when first instantiated.
1188          * @param amountToStepBy The amount to increment or decrement by, per step.
1189          * @param temporalUnit The size of each step (e.g. day, week, month, year, etc)
1190          */
1191         public LocalTimeSpinnerValueFactory(@NamedArg(&quot;min&quot;) LocalTime min,
1192                                             @NamedArg(&quot;min&quot;) LocalTime max,
1193                                             @NamedArg(&quot;initialValue&quot;) LocalTime initialValue,
1194                                             @NamedArg(&quot;amountToStepBy&quot;) long amountToStepBy,
1195                                             @NamedArg(&quot;temporalUnit&quot;) TemporalUnit temporalUnit) {
1196             setMin(min);
1197             setMax(max);
1198             setAmountToStepBy(amountToStepBy);
1199             setTemporalUnit(temporalUnit);
1200             setConverter(new StringConverter&lt;LocalTime&gt;() {
1201                 private DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
1202 
1203                 @Override public String toString(LocalTime localTime) {
1204                     if (localTime == null) {
1205                         return &quot;&quot;;
1206                     }
1207                     return localTime.format(dtf);
1208                 }
1209 
1210                 @Override public LocalTime fromString(String string) {
1211                     return LocalTime.parse(string);
1212                 }
1213             });
1214 
1215             valueProperty().addListener((o, oldValue, newValue) -&gt; {
1216                 // when the value is set, we need to react to ensure it is a
1217                 // valid value (and if not, blow up appropriately)
1218                 if (getMin() != null &amp;&amp; newValue.isBefore(getMin())) {
1219                     setValue(getMin());
1220                 } else if (getMax() != null &amp;&amp; newValue.isAfter(getMax())) {
1221                     setValue(getMax());
1222                 }
1223             });
1224             setValue(initialValue != null ? initialValue : LocalTime.now());
1225         }
1226 
1227 
1228 
1229         /***********************************************************************
1230          *                                                                     *
1231          * Properties                                                          *
1232          *                                                                     *
1233          **********************************************************************/
1234 
1235         // --- min
1236         private ObjectProperty&lt;LocalTime&gt; min = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;min&quot;) {
1237             @Override protected void invalidated() {
1238                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1239                 if (currentValue == null) {
1240                     return;
1241                 }
1242 
1243                 final LocalTime newMin = get();
1244                 if (newMin.isAfter(getMax())) {
1245                     setMin(getMax());
1246                     return;
1247                 }
1248 
1249                 if (currentValue.isBefore(newMin)) {
1250                     LocalTimeSpinnerValueFactory.this.setValue(newMin);
1251                 }
1252             }
1253         };
1254 
1255         public final void setMin(LocalTime value) {
1256             min.set(value);
1257         }
1258         public final LocalTime getMin() {
1259             return min.get();
1260         }
1261         /**
1262          * Sets the minimum allowable value for this value factory
1263          */
1264         public final ObjectProperty&lt;LocalTime&gt; minProperty() {
1265             return min;
1266         }
1267 
1268         // --- max
1269         private ObjectProperty&lt;LocalTime&gt; max = new SimpleObjectProperty&lt;LocalTime&gt;(this, &quot;max&quot;) {
1270             @Override protected void invalidated() {
1271                 LocalTime currentValue = LocalTimeSpinnerValueFactory.this.getValue();
1272                 if (currentValue == null) {
1273                     return;
1274                 }
1275 
1276                 final LocalTime newMax = get();
1277                 if (newMax.isBefore(getMin())) {
1278                     setMax(getMin());
1279                     return;
1280                 }
1281 
1282                 if (currentValue.isAfter(newMax)) {
1283                     LocalTimeSpinnerValueFactory.this.setValue(newMax);
1284                 }
1285             }
1286         };
1287 
1288         public final void setMax(LocalTime value) {
1289             max.set(value);
1290         }
1291         public final LocalTime getMax() {
1292             return max.get();
1293         }
1294         /**
1295          * Sets the maximum allowable value for this value factory
1296          */
1297         public final ObjectProperty&lt;LocalTime&gt; maxProperty() {
1298             return max;
1299         }
1300 
1301         // --- temporalUnit
1302         private ObjectProperty&lt;TemporalUnit&gt; temporalUnit = new SimpleObjectProperty&lt;&gt;(this, &quot;temporalUnit&quot;);
1303         public final void setTemporalUnit(TemporalUnit value) {
1304             temporalUnit.set(value);
1305         }
1306         public final TemporalUnit getTemporalUnit() {
1307             return temporalUnit.get();
1308         }
1309         /**
1310          * The size of each step (e.g. day, week, month, year, etc).
1311          */
1312         public final ObjectProperty&lt;TemporalUnit&gt; temporalUnitProperty() {
1313             return temporalUnit;
1314         }
1315 
1316         // --- amountToStepBy
1317         private LongProperty amountToStepBy = new SimpleLongProperty(this, &quot;amountToStepBy&quot;);
1318         public final void setAmountToStepBy(long value) {
1319             amountToStepBy.set(value);
1320         }
1321         public final long getAmountToStepBy() {
1322             return amountToStepBy.get();
1323         }
1324         /**
1325          * Sets the amount to increment or decrement by, per step.
1326          */
1327         public final LongProperty amountToStepByProperty() {
1328             return amountToStepBy;
1329         }
1330 
1331 
1332 
1333         /***********************************************************************
1334          *                                                                     *
1335          * Overridden methods                                                  *
1336          *                                                                     *
1337          **********************************************************************/
1338 
1339         /** {@inheritDoc} */
1340         @Override public void decrement(int steps) {
1341             final LocalTime currentValue = getValue();
1342             final LocalTime min = getMin();
1343 
1344             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1345 
1346             final long durationInSeconds = duration.toMinutes() * 60;
1347             final long currentValueInSeconds = currentValue.toSecondOfDay();
1348 
1349             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; currentValueInSeconds) {
1350                 setValue(min == null ? LocalTime.MIN : min);
1351             } else {
1352                 setValue(currentValue.minus(duration));
1353             }
1354         }
1355 
1356         /** {@inheritDoc} */
1357         @Override public void increment(int steps) {
1358             final LocalTime currentValue = getValue();
1359             final LocalTime max = getMax();
1360 
1361             final Duration duration = Duration.of(getAmountToStepBy() * steps, getTemporalUnit());
1362 
1363             final long durationInSeconds = duration.toMinutes() * 60;
1364             final long currentValueInSeconds = currentValue.toSecondOfDay();
1365 
1366             if (! isWrapAround() &amp;&amp; durationInSeconds &gt; (LocalTime.MAX.toSecondOfDay() - currentValueInSeconds)) {
1367                 setValue(max == null ? LocalTime.MAX : max);
1368             } else {
1369                 setValue(currentValue.plus(duration));
1370             }
1371         }
1372     }
1373 }
    </pre>
  </body>
</html>