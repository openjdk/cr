<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-glass/ios/GlassApplication.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &lt;UIKit/UIKit.h&gt;
  27 
  28 #import &quot;GlassMacros.h&quot;
  29 #import &quot;GlassApplication.h&quot;
  30 #import &quot;GlassHelper.h&quot;
  31 #import &quot;GlassStatics.h&quot;
  32 #import &quot;GlassTimer.h&quot;
  33 #import &quot;GlassWindow.h&quot;
  34 #import &quot;GlassScreen.h&quot;
  35 
  36 pthread_key_t GlassThreadDataKey = 0;
  37 
  38 // Java JNI IDs
  39 JNIEnv *jEnv = NULL;
  40 
  41 jclass mat_jIntegerClass = NULL;
  42 jclass mat_jMapClass = NULL;
  43 jclass mat_jBooleanClass = NULL;
  44 jclass mat_jLongClass = NULL;
  45 
  46 #if PROTECT_INVOKE_AND_WAIT
  47 static jobject mat_eventThread = 0;
  48 static jclass mat_jThreadClass = 0;
  49 static jmethodID mat_ThreadCurrentThread = 0;
  50 #endif
  51 
  52 jmethodID mat_jVectorAddElement = 0;
  53 
  54 jclass mat_jScreenClass = NULL;
  55 
  56 jclass mat_jViewClass = NULL;
  57 
  58 jclass jApplicationClass = NULL;
  59 jmethodID jApplicationReportException = 0;
  60 
  61 jmethodID mat_jViewNotifyResize = 0;
  62 jmethodID mat_jViewNotifyRepaint = 0;
  63 jmethodID mat_jViewNotifyKey = 0;
  64 jmethodID mat_jViewNotifyMouse = 0;
  65 jmethodID mat_jViewNotifyMenu = 0;
  66 jmethodID mat_jViewNotifyInputMethod = 0;
  67 jmethodID mat_jViewNotifyView = 0;
  68 
  69 jmethodID mat_jMapGetMethod = 0;
  70 jmethodID mat_jBooleanValueMethod = 0;
  71 jmethodID mat_jIntegerValueMethod = 0;
  72 jmethodID mat_jLongValueMethod = 0;
  73 
  74 jfieldID mat_jViewWindow = 0;
  75 jfieldID mat_jViewWidth = 0;
  76 jfieldID mat_jViewHeight = 0;
  77 jfieldID mat_jViewPtr = 0;
  78 
  79 jclass mat_jWindowClass = NULL;
  80 
  81 jfieldID mat_jWindowX = 0;
  82 jfieldID mat_jWindowY = 0;
  83 jfieldID mat_jWindowWidth = 0;
  84 jfieldID mat_jWindowHeight = 0;
  85 jfieldID mat_jWindowView = 0;
  86 jfieldID mat_jWindowPtr = 0;
  87 
  88 jmethodID mat_jWindowNotifyClose = 0;
  89 jmethodID mat_jWindowNotifyDestroy = 0;
  90 jmethodID mat_jWindowNotifyFocus = 0;
  91 jmethodID mat_jWindowNotifyFocusDisabled = 0;
  92 jmethodID jWindowNotifyFocusUngrab = 0;
  93 jmethodID mat_jWindowNotifyMove = 0;
  94 jmethodID mat_jWindowNotifyMoveToAnotherScreen = 0;
  95 jmethodID mat_jWindowNotifyResize = 0;
  96 
  97 jclass mat_jPixelsClass = NULL;
  98 
  99 jfieldID mat_jPixelsWidth = 0;
 100 jfieldID mat_jPixelsHeight = 0;
 101 jfieldID mat_jPixelsBytes = 0;
 102 jfieldID mat_jPixelsInts = 0;
 103 
 104 jmethodID mat_jPixelsAttachData = 0;
 105 
 106 jclass mat_jCursorClass = NULL;
 107 
 108 
 109 // a unix pipe which we will use as a runnable queue for posted events.
 110 static int postEventPipe[2];
 111 static int haveIDs = 0;
 112 
 113 static BOOL shouldKeepRunningNestedLoop = YES;
 114 static jobject nestedLoopReturnValue = NULL;
 115 
 116 //Library entrypoint
 117 JNIEXPORT jint JNICALL
 118 JNI_OnLoad_glass(JavaVM *vm, void *reserved)
 119 {
 120 #ifdef JNI_VERSION_1_8
 121     //min. returned JNI_VERSION required by JDK8 for builtin libraries
 122     JNIEnv *env;
 123     if ((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_8) != JNI_OK) {
 124         return JNI_VERSION_1_4;
 125     }
 126     return JNI_VERSION_1_8;
 127 #else
 128     return JNI_VERSION_1_4;
 129 #endif
 130 }
 131 
 132 /*
 133  * Function to set the context class loader for the main glass event thread.
 134  * This is necessary because we co-opt the UIKit thread as the glass event
 135  * thread.
 136  */
 137 jboolean setContextClassLoader(JNIEnv *env, jobject contextClassLoader)
 138 {
 139     jclass threadCls = (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;);
 140     if ((*env)-&gt;ExceptionCheck(env) || threadCls == NULL) {
 141         return JNI_FALSE;
 142     }
 143     jmethodID currentThreadMID = (*env)-&gt;GetStaticMethodID(env, threadCls,
 144                                                            &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 145     if ((*env)-&gt;ExceptionCheck(env) || currentThreadMID == NULL) {
 146         return JNI_FALSE;
 147     }
 148     jobject jCurrentThread = (*env)-&gt;CallStaticObjectMethod(env, threadCls, currentThreadMID);
 149     if ((*env)-&gt;ExceptionCheck(env) || jCurrentThread == NULL) {
 150         return JNI_FALSE;
 151     }
 152 
 153     jmethodID setContextClassLoaderMID = (*env)-&gt;GetMethodID(env, threadCls,
 154                                                              &quot;setContextClassLoader&quot;, &quot;(Ljava/lang/ClassLoader;)V&quot;);
 155     if ((*env)-&gt;ExceptionCheck(env) || setContextClassLoaderMID == NULL) {
 156         return JNI_FALSE;
 157     }
 158     (*env)-&gt;CallVoidMethod(env, jCurrentThread, setContextClassLoaderMID, contextClassLoader);
 159     if ((*env)-&gt;ExceptionCheck(env)) {
 160         return JNI_FALSE;
 161     }
 162 
 163     return JNI_TRUE;
 164 }
 165 
 166 
 167 /*
 168  * Function to find a glass class using the context class loader. All glass
 169  * classes must be looked up using this function rather than FindClass so that
 170  * the correct ClassLoader is used.
 171  *
 172  * Note that the className passed to this function must use &quot;.&quot; rather than &quot;/&quot;
 173  * as a package separator.
 174  */
 175 jclass classForName(JNIEnv *env, char *className)
 176 {
 177     jclass threadCls = (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;);
 178     if ((*env)-&gt;ExceptionCheck(env) || threadCls == NULL) {
 179         return NULL;
 180     }
 181     jmethodID currentThreadMID = (*env)-&gt;GetStaticMethodID(env, threadCls,
 182                                                            &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 183     if ((*env)-&gt;ExceptionCheck(env) || currentThreadMID == NULL) {
 184         return NULL;
 185     }
 186     jobject jCurrentThread = (*env)-&gt;CallStaticObjectMethod(env, threadCls, currentThreadMID);
 187     if ((*env)-&gt;ExceptionCheck(env) || jCurrentThread == NULL) {
 188         return NULL;
 189     }
 190 
 191     jmethodID getContextClassLoaderMID = (*env)-&gt;GetMethodID(env, threadCls,
 192                                                              &quot;getContextClassLoader&quot;, &quot;()Ljava/lang/ClassLoader;&quot;);
 193     if ((*env)-&gt;ExceptionCheck(env) || getContextClassLoaderMID == NULL) {
 194         return NULL;
 195     }
 196     jobject contextClassLoader = (*env)-&gt;CallObjectMethod(env, jCurrentThread, getContextClassLoaderMID);
 197     if ((*env)-&gt;ExceptionCheck(env)) {
 198         return NULL;
 199     }
 200 
 201     jclass classCls = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
 202     if ((*env)-&gt;ExceptionCheck(env) || classCls == NULL) {
 203         return NULL;
 204     }
 205     jmethodID forNameMID = (*env)-&gt;GetStaticMethodID(env, classCls,
 206                                                      &quot;forName&quot;, &quot;(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;&quot;);
 207     if ((*env)-&gt;ExceptionCheck(env) || forNameMID == NULL) {
 208         return NULL;
 209     }
 210     jstring classNameStr = (*env)-&gt;NewStringUTF(env, className);
 211     if ((*env)-&gt;ExceptionCheck(env) || classNameStr == NULL) {
 212         return NULL;
 213     }
 214     jclass theCls = (*env)-&gt;CallStaticObjectMethod(env, classCls, forNameMID,
 215                                                    classNameStr, JNI_TRUE, contextClassLoader);
 216     if ((*env)-&gt;ExceptionCheck(env)) {
 217         return NULL;
 218     }
 219     return theCls;
 220 }
 221 
 222 
 223 
 224 @interface GlassRunnable : NSObject
 225 {
 226 
 227 }
 228 
 229 @property (nonatomic) jobject jRunnable;
 230 
 231 - (id)initWithRunnable:(jobject)runnable;
 232 - (void)run;
 233 
 234 @end
 235 
 236 
 237 
 238 @implementation GlassRunnable
 239 
 240 @synthesize jRunnable;
 241 
 242 - (id)initWithRunnable:(jobject)runnable
 243 {
 244     self.jRunnable = runnable;
 245     return self;
 246 }
 247 
 248 
 249 - (void)run
 250 {
 251     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 252     {
 253         NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 254         if (jEnv != NULL)
 255         {
 256             (*jEnv)-&gt;CallVoidMethod(jEnv, self.jRunnable, jRunnableRun);
 257             GLASS_CHECK_EXCEPTION(jEnv);
 258         }
 259 
 260         [self release];
 261     }
 262     [pool drain];
 263 }
 264 
 265 
 266 - (void)dealloc
 267 {
 268     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 269     if (jEnv != NULL)
 270     {
 271         (*jEnv)-&gt;DeleteGlobalRef(jEnv, self.jRunnable);
 272     }
 273     self.jRunnable = NULL;
 274 
 275     [super dealloc];
 276 }
 277 
 278 @end
 279 
 280 
 281 
 282 @implementation GlassApplication
 283 
 284 @synthesize started;
 285 @synthesize condition;
 286 @synthesize jApplication;
 287 @synthesize jLaunchable;
 288 @synthesize jContextClassLoader;
 289 
 290 - (id)initWithEnv:(JNIEnv*)env application:(jobject)application contextClassLoader:(jobject)contextClassLoader launchable:(jobject)launchable
 291 {
 292     GLASS_LOG(&quot;GlassApplication_initWithEnv called.&quot;);
 293     self = [super init];
 294     if (self != nil)
 295     {
 296         self.condition = [[NSCondition alloc] init];
 297         [self.condition release]; //condition property retains; alloc as well
 298         self.started = NO;
 299         (*env)-&gt;GetJavaVM(env, &amp;jVM);
 300         self.jApplication = (*env)-&gt;NewGlobalRef(env, application);
 301         if (launchable != NULL)
 302         {
 303             self.jLaunchable = (*env)-&gt;NewGlobalRef(env, launchable);
 304         }
 305         if (contextClassLoader != NULL)
 306         {
 307             self.jContextClassLoader = (*env)-&gt;NewGlobalRef(env, contextClassLoader);
 308         }
 309     }
 310     return self;
 311 }
 312 
 313 // Called e.g. by GlassViewController when app. user interface changes orientation.
 314 // FX can resize Stage, adjust UI, etc. in response.
 315 - (void)GlassApplicationDidChangeScreenParameters
 316 {
 317     GLASS_LOG(&quot;GlassApplication_GlassApplicationDidChangeScreenParameters&quot;);
 318     GlassScreenDidChangeScreenParameters(jEnv);
 319 }
 320 
 321 
 322 // Application state changes callbacks to java
 323 
 324 - (void)callWillResignActive
 325 {
 326     GET_MAIN_JENV;
 327     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 328     {
 329         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillResignActiveMethod]);
 330     }
 331     [pool drain];
 332     GLASS_CHECK_EXCEPTION(env);
 333 }
 334 
 335 - (void)callDidResignActive
 336 {
 337     GET_MAIN_JENV;
 338     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 339     {
 340         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidResignActiveMethod]);
 341     }
 342     [pool drain];
 343     GLASS_CHECK_EXCEPTION(env);
 344 }
 345 
 346 - (void)callDidReceiveMemoryWarning
 347 {
 348     GET_MAIN_JENV;
 349     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 350     {
 351         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidReceiveMemoryWarningMethod]);
 352     }
 353     [pool drain];
 354     GLASS_CHECK_EXCEPTION(env);
 355 }
 356 
 357 
 358 - (void)callWillBecomeActive
 359 {
 360     GET_MAIN_JENV;
 361     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 362     {
 363         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillBecomeActiveMethod]);
 364     }
 365     [pool drain];
 366     GLASS_CHECK_EXCEPTION(env);
 367 }
 368 
 369 - (void)callDidBecomeActive
 370 {
 371     GET_MAIN_JENV;
 372     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 373     {
 374         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidBecomeActiveMethod]);
 375     }
 376     [pool drain];
 377     GLASS_CHECK_EXCEPTION(env);
 378 }
 379 
 380 - (void)callQuit
 381 {
 382     GET_MAIN_JENV;
 383     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 384     {
 385         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillQuitMethod]);
 386     }
 387     [pool drain];
 388     GLASS_CHECK_EXCEPTION(env);
 389 }
 390 
 391 
 392 - (void)applicationCallback:(SEL)method
 393 {
 394     if ([[NSThread currentThread] isMainThread] == YES)
 395     {
 396         [self performSelector:method];
 397     }
 398     else
 399     {
 400         [self performSelectorOnMainThread:method withObject:nil waitUntilDone:YES];
 401     }
 402 }
 403 
 404 
 405 - (void)applicationWillResignActive:(UIApplication *)application
 406 {
 407     /*
 408      Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
 409      Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
 410      */
 411     GLASS_LOG(&quot;GlassApplication:applicationWillResignActive&quot;);
 412     [self applicationCallback:@selector(callWillResignActive)];
 413 }
 414 
 415 
 416 - (void)applicationDidEnterBackground:(UIApplication *)application {
 417     GLASS_LOG(&quot;GlassApplication:applicationDidEnterBackground&quot;);
 418     [self applicationCallback:@selector(callDidResignActive)];
 419 }
 420 
 421 - (void)applicationDidReceiveMemoryWarning:(UIApplication *)application {
 422     GLASS_LOG(&quot;GlassApplication:applicationDidReceiveMemoryWarning&quot;);
 423     [self applicationCallback:@selector(callDidReceiveMemoryWarning)];
 424 }
 425 
 426 - (void)applicationWillEnterForeground:(UIApplication *)application {
 427     /*
 428      Called as part of  transition from the background to the inactive state: here you can undo many of the changes made on entering the background.
 429      */
 430     GLASS_LOG(&quot;GlassApplication:applicationWillEnterForeground&quot;);
 431     [self applicationCallback:@selector(callWillBecomeActive)];
 432 }
 433 
 434 
 435 - (void)applicationDidBecomeActive:(UIApplication *)application {
 436     /*
 437      Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
 438      */
 439     GLASS_LOG(&quot;GlassApplication:applicationDidBecomeActive&quot;);
 440     [self applicationCallback:@selector(callDidBecomeActive)];
 441 }
 442 
 443 
 444 - (void)applicationWillTerminate:(UIApplication *)application {
 445     GLASS_LOG(&quot;GlassApplication:applicationWillTerminate&quot;);
 446     [self applicationCallback:@selector(callQuit)];
 447 }
 448 
 449 
 450 - (void)applicationWillFinishLaunching:(NSNotification *)aNotification
 451 {
 452     GLASS_LOG(&quot;GlassApplication_applicationWillFinishLaunching&quot;);
 453     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 454     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 455     {
 456         if (self.jLaunchable != NULL)
 457         {
 458             jclass runnableClass = classForName(jEnv, &quot;java.lang.Runnable&quot;);
 459             if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 460             {
 461                 (*jEnv)-&gt;ExceptionDescribe(jEnv);
 462             }
 463 
 464             jmethodID runMethod = (*jEnv)-&gt;GetMethodID(jEnv, runnableClass, &quot;run&quot;, &quot;()V&quot;);
 465             if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 466             {
 467                 (*jEnv)-&gt;ExceptionDescribe(jEnv);
 468             }
 469 
 470             if ((runnableClass != 0) &amp;&amp; (runMethod != 0))
 471             {
 472                 (*jEnv)-&gt;CallVoidMethod(jEnv, self.jLaunchable, runMethod);
 473                 if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 474                 {
 475                     (*jEnv)-&gt;ExceptionDescribe(jEnv);
 476                 }
 477             }
 478             else if (runnableClass == 0)
 479             {
 480                 NSLog(@&quot;ERROR: Glass could not find Runnable class&quot;);
 481             }
 482             else if (runMethod == 0)
 483             {
 484                 NSLog(@&quot;ERROR: Glass could not find run() method&quot;);
 485             }
 486         }
 487 
 488         [self notify];
 489     }
 490     [pool drain];
 491 
 492     GLASS_CHECK_EXCEPTION(jEnv);
 493 }
 494 
 495 
 496 - (void)runLoop:(id)selector
 497 {
 498     GLASS_LOG(&quot;GlassApplication:runLoop&quot;);
 499     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 500     jint error = (*jVM)-&gt;AttachCurrentThread(jVM, (void **)&amp;jEnv, NULL);
 501     GLASS_LOG(&quot;AttachCurrentThread returned %ld&quot;,error);
 502 
 503 
 504     if (error == 0)
 505     {
 506         NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 507         {
 508             if ([[NSThread currentThread] name] == nil) {
 509                 [[NSThread currentThread] setName:@&quot;Main UIKit Thread&quot;];
 510             }
 511 
 512             GlassApplication *glassApp = (GlassApplication *) selector;
 513 
 514             // Set the context class loader for this thread
 515             if (!setContextClassLoader(jEnv, glassApp.jContextClassLoader)) {
 516                 NSLog(@&quot;ERROR: can&#39;t set the context classloader&quot;);
 517             }
 518             GLASS_CHECK_EXCEPTION(jEnv);
 519 
 520             // Load IosApplication class using the glass classloader
 521             jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.ios.IosApplication&quot; withEnv:jEnv];
 522             if (!cls)
 523             {
 524                 NSLog(@&quot;ERROR: can&#39;t find the IosApplication class&quot;);
 525             }
 526             else
 527             {
 528                 jmethodID setEventThreadMID = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setEventThread&quot;, &quot;()V&quot;);
 529                 if (!setEventThreadMID)
 530                 {
 531                     NSLog(@&quot;ERROR: can&#39;t get IosApplication.setEventThread() method ID&quot;);
 532                 }
 533                 else
 534                 {
 535                     (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setEventThreadMID);
 536                 }
 537             }
 538             GLASS_CHECK_EXCEPTION(jEnv);
 539 
 540             //Set self as UIApplicationDelegate so we can pass life cycle notifications from iOS
 541             //to JavaFX
 542             [[UIApplication sharedApplication] setDelegate:glassApp];
 543 
 544             [glassApp performSelectorOnMainThread:@selector(applicationWillFinishLaunching:) withObject:NULL waitUntilDone:NO];
 545             GLASS_CHECK_EXCEPTION(jEnv);
 546         }
 547         [pool drain];
 548     }
 549     else // attaching to JVM failed
 550     {
 551         NSLog(@&quot;ERROR: Glass could not attach to VM, result:%ld&quot;, error);
 552     }
 553 }
 554 
 555 
 556 + (jobject)enterNestedEventLoopWithEnv:(JNIEnv*)env
 557 {
 558     jobject ret = NULL;
 559     GLASS_LOG(&quot;entering nestedEventLoop&quot;);
 560 
 561     NSRunLoop *theRL = [NSRunLoop currentRunLoop];
 562     UIApplication * app = [UIApplication sharedApplication];
 563     shouldKeepRunningNestedLoop = YES;
 564     while (shouldKeepRunningNestedLoop &amp;&amp; [theRL runMode:NSDefaultRunLoopMode
 565                                               beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.010]])
 566     {
 567         // don&#39;t do anything, as long as we should stay here events are forwarded.
 568     }
 569     GLASS_LOG(&quot;leaving enterNestedEventLoop&quot;);
 570 
 571     if (nestedLoopReturnValue != NULL) {
 572         ret = (*env)-&gt;NewLocalRef(env, nestedLoopReturnValue);
 573         (*env)-&gt;DeleteGlobalRef(env, nestedLoopReturnValue);
 574         nestedLoopReturnValue = NULL;
 575     }
 576 
 577     shouldKeepRunningNestedLoop = YES;
 578 
 579     return ret;
 580 }
 581 
 582 + (void)leaveNestedEventLoopWithEnv:(JNIEnv*)env retValue:(jobject)retValue
 583 {
 584     if (retValue != NULL) {
 585         nestedLoopReturnValue = (*env)-&gt;NewGlobalRef(env, retValue);
 586     }
 587     shouldKeepRunningNestedLoop = NO;
 588 }
 589 
 590 
 591 
 592 - (void)notify
 593 {
 594     [self.condition lock];
 595     [self setStarted: YES];
 596     [self.condition signal];
 597     [self.condition unlock];
 598 }
 599 
 600 
 601 -(void)await
 602 {
 603     [self.condition lock];
 604     while(self.started == NO)
 605     {
 606         GLASS_LOG(&quot;&lt;--&gt;waiting for [glass started]&quot;);
 607         [self.condition wait];
 608     }
 609     [self.condition unlock];
 610 }
 611 
 612 
 613 - (void)dealloc {
 614     [[NSNotificationCenter defaultCenter] removeObserver: self];
 615     self.condition = nil;
 616     [super dealloc];
 617 }
 618 
 619 @end
 620 
 621 
 622 
 623 /*
 624  * Class:     com_sun_glass_ui_ios_IosApplication
 625  * Method:    _initIDs
 626  * Signature: ()V
 627  */
 628 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1initIDs
 629 (JNIEnv *env, jclass jClass)
 630 {
 631 
 632     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1initIDs&quot;);
 633 
 634     if (haveIDs)
 635         return;
 636     haveIDs = 1;
 637 
 638     assert(pthread_key_create(&amp;GlassThreadDataKey, NULL) == 0);
 639 
 640     jApplicationClass = (*env)-&gt;NewGlobalRef(env, jClass);
 641     jApplicationReportException = (*env)-&gt;GetStaticMethodID(env, jClass, &quot;reportException&quot;, &quot;(Ljava/lang/Throwable;)V&quot;);
 642 
 643     mat_jIntegerClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;));
 644     mat_jMapClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/util/Map&quot;));
 645     mat_jBooleanClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;));
 646     mat_jLongClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;));
 647 
 648 #if PROTECT_INVOKE_AND_WAIT
 649     mat_jThreadClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;));
 650     mat_ThreadCurrentThread = (*env)-&gt;GetStaticMethodID(env, mat_jThreadClass, &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 651 #endif
 652 
 653     mat_jVectorAddElement = (*env)-&gt;GetMethodID(env, (*env)-&gt;FindClass(env, &quot;java/util/Vector&quot;), &quot;addElement&quot;, &quot;(Ljava/lang/Object;)V&quot;);
 654 
 655     mat_jMapGetMethod = (*env)-&gt;GetMethodID(env, mat_jMapClass, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
 656     mat_jBooleanValueMethod = (*env)-&gt;GetMethodID(env, mat_jBooleanClass, &quot;booleanValue&quot;, &quot;()Z&quot;);
 657     mat_jIntegerValueMethod = (*env)-&gt;GetMethodID(env, mat_jIntegerClass, &quot;intValue&quot;, &quot;()I&quot;);
 658     mat_jLongValueMethod = (*env)-&gt;GetMethodID(env, mat_jLongClass, &quot;longValue&quot;, &quot;()J&quot;);
 659 
 660     jRunnableRun = (*env)-&gt;GetMethodID(env, (*env)-&gt;FindClass(env, &quot;java/lang/Runnable&quot;), &quot;run&quot;, &quot;()V&quot;);
 661 
 662     // screen specific
 663     mat_jScreenClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Screen&quot;));
 664     GLASS_CHECK_EXCEPTION(env);
 665 
 666     // view specific
 667     mat_jViewClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosView&quot;));
 668     mat_jViewNotifyKey = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyUnicode&quot;, &quot;(IIII)V&quot;);
 669     jclass mat_jViewBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/View&quot;);
 670     GLASS_CHECK_EXCEPTION(env);
 671 
 672     mat_jViewNotifyResize = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyResize&quot;, &quot;(II)V&quot;);
 673     mat_jViewNotifyRepaint = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyRepaint&quot;, &quot;(IIII)V&quot;);
 674     mat_jViewNotifyMouse = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyMouse&quot;, &quot;(IIIIIIIZZ)V&quot;);
 675     mat_jViewNotifyMenu = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyMenu&quot;, &quot;(IIIIZ)V&quot;);
 676     mat_jViewNotifyInputMethod = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyInputMethod&quot;, &quot;(Ljava/lang/String;[I[I[BIII)V&quot;);
 677     mat_jViewNotifyView = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyView&quot;, &quot;(I)V&quot;);
 678     GLASS_CHECK_EXCEPTION(env);
 679 
 680 
 681     if (jViewNotifyDragEnter == NULL)
 682     {
 683         jViewNotifyDragEnter = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragEnter&quot;, &quot;(IIIII)I&quot;);
 684     }
 685 
 686     if (jViewNotifyDragOver == NULL)
 687     {
 688         jViewNotifyDragOver = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragOver&quot;, &quot;(IIIII)I&quot;);
 689     }
 690 
 691     if (jViewNotifyDragLeave == NULL)
 692     {
 693         jViewNotifyDragLeave = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragLeave&quot;, &quot;()V&quot;);
 694     }
 695 
 696     if (jViewNotifyDragDrop == NULL)
 697     {
 698         jViewNotifyDragDrop = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragDrop&quot;, &quot;(IIIII)I&quot;);
 699     }
 700 
 701     if (jViewNotifyDragEnd == NULL)
 702     {
 703         jViewNotifyDragEnd = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragEnd&quot;, &quot;(I)V&quot;);
 704     }
 705 
 706     GLASS_CHECK_EXCEPTION(env);
 707 
 708     mat_jViewWidth = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;width&quot;,&quot;I&quot;);
 709     mat_jViewHeight = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;height&quot;,&quot;I&quot;);
 710     mat_jViewWindow = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;window&quot;,&quot;Lcom/sun/glass/ui/Window;&quot;);
 711     GLASS_CHECK_EXCEPTION(env);
 712 
 713     mat_jViewPtr = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;ptr&quot;, &quot;J&quot;);
 714     GLASS_CHECK_EXCEPTION(env);
 715 
 716     //window specific
 717     mat_jWindowClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosWindow&quot;));
 718     jclass mat_jWindowBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Window&quot;);
 719     GLASS_CHECK_EXCEPTION(env);
 720 
 721     mat_jWindowX = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;x&quot;, &quot;I&quot;);
 722     mat_jWindowY = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;y&quot;, &quot;I&quot;);
 723     mat_jWindowWidth = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;width&quot;, &quot;I&quot;);
 724     mat_jWindowHeight = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;height&quot;, &quot;I&quot;);
 725     mat_jWindowPtr = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;ptr&quot;, &quot;J&quot;);
 726 
 727     mat_jWindowView = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;view&quot;, &quot;Lcom/sun/glass/ui/View;&quot;);
 728     GLASS_CHECK_EXCEPTION(env);
 729 
 730     mat_jWindowNotifyMove = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyMove&quot;, &quot;(II)V&quot;);
 731     mat_jWindowNotifyResize = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyResize&quot;, &quot;(III)V&quot;);
 732     mat_jWindowNotifyMoveToAnotherScreen = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyMoveToAnotherScreen&quot;, &quot;(Lcom/sun/glass/ui/Screen;)V&quot;);
 733     mat_jWindowNotifyClose = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyClose&quot;, &quot;()V&quot;);
 734     mat_jWindowNotifyFocus = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocus&quot;, &quot;(I)V&quot;);
 735     mat_jWindowNotifyDestroy = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyDestroy&quot;, &quot;()V&quot;);
 736     mat_jWindowNotifyFocusDisabled = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocusDisabled&quot;, &quot;()V&quot;);
 737     jWindowNotifyFocusUngrab = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocusUngrab&quot;, &quot;()V&quot;);
 738     GLASS_CHECK_EXCEPTION(env);
 739 
 740     //pixels specific
 741     mat_jPixelsClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosPixels&quot;));
 742     jclass mat_jPixelsBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Pixels&quot;);
 743     GLASS_CHECK_EXCEPTION(env);
 744 
 745     mat_jPixelsWidth = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;width&quot;, &quot;I&quot;);
 746     mat_jPixelsHeight = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;height&quot;, &quot;I&quot;);
 747     mat_jPixelsBytes = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;bytes&quot;, &quot;Ljava/nio/ByteBuffer;&quot;);
 748     mat_jPixelsInts = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;ints&quot;, &quot;Ljava/nio/IntBuffer;&quot;);
 749     GLASS_CHECK_EXCEPTION(env);
 750 
 751     mat_jPixelsAttachData = (*env)-&gt;GetMethodID(env, mat_jPixelsBaseClass, &quot;attachData&quot;, &quot;(J)V&quot;);
 752     GLASS_CHECK_EXCEPTION(env);
 753 
 754     //cursor specific
 755     mat_jCursorClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosCursor&quot;));
 756     GLASS_CHECK_EXCEPTION(env);
 757 
 758     if (pipe(postEventPipe) != 0) {
 759         mat_JNU_ThrowByName(env, mat_RuntimeException, &quot;Pipe allocation failed&quot;);
 760     }
 761 
 762     // display link timer
 763     NSObject&lt;GlassTimerDelegate&gt;  *delegate = [[GlassTimer alloc] init];
 764     [GlassTimer setDelegate: delegate];
 765 
 766     GLASS_LOG(&quot;leaving Java_com_sun_glass_ui_ios_IosApplication__1initIDs&quot;);
 767 }
 768 
 769 
 770 #if PROTECT_INVOKE_AND_WAIT
 771 static jobject getCurrentThread(JNIEnv *env) {
 772     jobject jobj = (*env)-&gt;CallStaticObjectMethod(env, mat_jThreadClass, mat_ThreadCurrentThread);
 773     if ((*env)-&gt;ExceptionCheck(env)) {
 774         return NULL;
 775     }
 776     return jobj;
 777 }
 778 #endif
 779 
 780 
 781 /*
 782  * Class:     com_sun_glass_ui_ios_IosApplication
 783  * Method:    _runLoop
 784  * Signature: (Ljava/lang/Runnable;)V
 785  */
 786 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1runLoop
 787 (JNIEnv *env, jobject japplication, jobject jLaunchable, jobject jContextClassLoader)
 788 {
 789     GLASS_LOG(&quot;Entering Java_com_sun_glass_ui_ios_IosApplication__1runLoop !!!&quot;);
 790     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 791     {
 792         if ([[NSThread currentThread] isMainThread] == YES)
 793         {
 794             NSLog(@&quot;\nWARNING: Glass was started on 1st thread and will block this thread.\nYou most likely do not want to do this - please remove \&quot;-XstartOnFirstThread\&quot; from VM arguments.&quot;);
 795         }
 796         else
 797         {
 798             GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop - not on main thread 2&quot;);
 799 
 800             if ([[NSThread currentThread] name] == nil)
 801             {
 802                 GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop - setting name &#39;Main Java Thread&#39; to current thread &quot;);
 803 
 804                 [[NSThread currentThread] setName:@&quot;Main Java Thread&quot;];
 805             }
 806         }
 807 
 808         GLASS_LOG(&quot;iOSApplication_runloop before glass init ... &quot;);
 809 
 810         const GlassApplication * const glass = [[GlassApplication alloc]
 811             initWithEnv:env
 812             application:japplication
 813             contextClassLoader:jContextClassLoader
 814             launchable:jLaunchable];
 815         [glass performSelectorOnMainThread:@selector(runLoop:) withObject:glass waitUntilDone:[[NSThread currentThread] isMainThread]];
 816 
 817 
 818         // wait for UIKit to enter its UI runloop
 819         [glass await];
 820 
 821         // at this point Java main thread is allowed to proceed, but UIKit thread entered its run loop, so the VM will not quit
 822     }
 823     [glasspool drain];
 824     glasspool=nil;
 825     GLASS_CHECK_EXCEPTION(env);
 826     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop ... returns&quot;);
 827 }
 828 
 829 
 830 /*
 831  *  * Class:     com_sun_glass_ui_ios_IosApplication
 832  *   * Method:    _enterNestedEventLoopImpl
 833  *    * Signature: ()Ljava/lang/Object;
 834  *     */
 835 JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_ios_IosApplication__1enterNestedEventLoopImpl
 836 (JNIEnv *env, jobject japplication)
 837 {
 838     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1enterNestedEventLoopImpl&quot;);
 839 
 840     jobject ret;
 841 
 842     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 843     {
 844         ret = [GlassApplication enterNestedEventLoopWithEnv:env];
 845     }
 846     [glasspool drain]; glasspool=nil;
 847      GLASS_CHECK_EXCEPTION(env);
 848 
 849     return ret;
 850 }
 851 
 852 /*
 853  *  * Class:     com_sun_glass_ui_ios_IosApplication
 854  *   * Method:    _leaveNestedEventLoopImpl
 855  *    * Signature: (Ljava/lang/Object;)V
 856  *     */
 857 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1leaveNestedEventLoopImpl
 858 (JNIEnv *env, jobject japplication, jobject retValue)
 859 {
 860     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1leaveNestedEventLoopImpl&quot;);
 861 
 862     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 863     {
 864         [GlassApplication leaveNestedEventLoopWithEnv:env retValue:retValue];
 865     }
 866     [glasspool drain]; glasspool=nil;
 867      GLASS_CHECK_EXCEPTION(env);
 868 
 869 }
 870 
 871 
 872 
 873 /*
 874  * Class:     com_sun_glass_ui_Application
 875  * Method:    _invokeAndWait
 876  * Signature: (Ljava/lang/Runnable;)V
 877  */
 878 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1invokeAndWait
 879 (JNIEnv *env, jobject jApplication, jobject jRunnable)
 880 {
 881     if (jEnv != NULL)
 882     {
 883         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 884         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];
 885         // released in the run method
 886     }
 887 }
 888 
 889 
 890 /*
 891  * Class:     com_sun_glass_ui_Application
 892  * Method:    _invokeLater
 893  * Signature: (Ljava/lang/Runnable;)V
 894  */
 895 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1invokeLater
 896 (JNIEnv *env, jobject jApplication, jobject jRunnable)
 897 {
 898     if (jEnv != NULL)
 899     {
 900         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 901         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
 902         // released in the run method
 903     }
 904 }
 905 
 906 
 907 char * mat_RuntimeException = &quot;java/lang/RuntimeException&quot;;
 908 
 909 void
 910 mat_JNU_ThrowByName(JNIEnv *env, const char *name, const char *msg)
 911 {
 912     GLASS_LOG(&quot;Throwing Exception ... %s&quot;,name);
 913     jclass cls = (*env)-&gt;FindClass(env, name);
 914     // if cls is NULL, an exception has already been thrown
 915     if (cls != NULL) {
 916         GLASS_LOG(&quot;Throwing Exception ....... %s(%s)&quot;,name,msg);
 917         (*env)-&gt;ThrowNew(env, cls, msg);
 918     } else {
 919         GLASS_LOG(&quot;EXCEPTION: not found %s(%s)&quot;, name, msg);
 920     }
 921     // free the local ref
 922     (*env)-&gt;DeleteLocalRef(env, cls);
 923 }
 924 
 925 
 926 /*
 927  * Class:     com_sun_glass_ui_ios_IosApplication
 928  * Method:    _setStatusBarHidden
 929  */
 930 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarHidden
 931 (JNIEnv *env, jclass clazz, jboolean hidden) {
 932     [UIApplication sharedApplication].statusBarHidden = (hidden == JNI_TRUE);
 933 }
 934 
 935 /*
 936  * Class:     com_sun_glass_ui_ios_IosApplication
 937  * Method:    _setStatusBarHiddenWithAnimation
 938  */
 939 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarHiddenWithAnimation
 940 (JNIEnv *env, jclass clazz, jboolean hidden, jint animation) {
 941     [[UIApplication sharedApplication]
 942         setStatusBarHidden:hidden == JNI_TRUE
 943         withAnimation:(UIStatusBarAnimation)animation];
 944 }
 945 
 946 /*
 947  * Class:     com_sun_glass_ui_ios_IosApplication
 948  * Method:    _setStatusBarOrientationAnimated
 949  */
 950 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarOrientationAnimated
 951 (JNIEnv *env, jclass clazz, jint interfaceOrientation, jboolean animated) {
 952     [[UIApplication sharedApplication]
 953         setStatusBarOrientation:(UIInterfaceOrientation)interfaceOrientation
 954         animated:animated == JNI_TRUE
 955     ];
 956 }
 957 
 958 /*
 959  * Class:     com_sun_glass_ui_ios_IosApplication
 960  * Method:    _setStatusBarStyleAnimated
 961  */
 962 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarStyleAnimated
 963 (JNIEnv *env, jclass clazz, jint statusBarStyle, jboolean animated) {
 964     [[UIApplication sharedApplication]
 965         setStatusBarStyle:(UIStatusBarStyle)statusBarStyle
 966         animated:animated == JNI_TRUE
 967     ];
 968 }
 969 
 970 /*
 971  * Class:     com_sun_glass_ui_ios_IosApplication
 972  * Method:    _getStatusBarHidden
 973  */
 974 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarHidden
 975 (JNIEnv *env, jclass clazz) {
 976     return [UIApplication sharedApplication].statusBarHidden == YES ? JNI_TRUE : JNI_FALSE;
 977 }
 978 
 979 /*
 980  * Class:     com_sun_glass_ui_ios_IosApplication
 981  * Method:    _getStatusBarStyle
 982  */
 983 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarStyle
 984 (JNIEnv *env, jclass clazz) {
 985     return [UIApplication sharedApplication].statusBarStyle;
 986 }
 987 
 988 /*
 989  * Class:     com_sun_glass_ui_ios_IosApplication
 990  * Method:    _getStatusBarStyle
 991  */
 992 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarOrientation
 993 (JNIEnv *env, jclass clazz) {
 994     return [UIApplication sharedApplication].statusBarOrientation;
 995 }
 996 
 997 /*
 998  * Class:     com_sun_glass_ui_ios_IosApplication
 999  * Method:    staticScreen_getVideoRefreshPeriod
1000  * Signature: ()D
1001  */
1002 JNIEXPORT jdouble JNICALL
1003 Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getVideoRefreshPeriod
1004 (JNIEnv *env, jobject jApplication)
1005 {
1006     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getVideoRefreshPeriod&quot;);
1007 
1008     double outRefresh = 1.0 / 30.0;     // ability to set frame divider
1009     return (outRefresh * 1000.0);       // to millis
1010 }
1011 
1012 /*
1013  * Class:     com_sun_glass_ui_ios_IosApplication
1014  * Method:    staticScreen_getScreens
1015  * Signature: ([Lcom/sun/glass/ui/Screen;)D
1016  */
1017 JNIEXPORT jobjectArray JNICALL
1018 Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getScreens
1019 (JNIEnv *env, jobject jApplication)
1020 {
1021     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getScreens&quot;);
1022 
1023     return createJavaScreens(env);
1024 }
1025 
    </pre>
  </body>
</html>