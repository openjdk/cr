<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/skin/VirtualFlow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.ParentHelper;
  29 import com.sun.javafx.scene.control.Logging;
  30 import com.sun.javafx.scene.control.Properties;
  31 import com.sun.javafx.scene.control.VirtualScrollBar;
  32 import com.sun.javafx.scene.control.skin.Utils;
  33 import com.sun.javafx.scene.traversal.Algorithm;
  34 import com.sun.javafx.scene.traversal.Direction;
  35 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  36 import com.sun.javafx.scene.traversal.TraversalContext;
  37 import javafx.animation.KeyFrame;
  38 import javafx.animation.Timeline;
  39 import javafx.beans.InvalidationListener;
  40 import javafx.beans.Observable;
  41 import javafx.beans.property.BooleanProperty;
  42 import javafx.beans.property.BooleanPropertyBase;
  43 import javafx.beans.property.DoubleProperty;
  44 import javafx.beans.property.IntegerProperty;
  45 import javafx.beans.property.ObjectProperty;
  46 import javafx.beans.property.SimpleBooleanProperty;
  47 import javafx.beans.property.SimpleDoubleProperty;
  48 import javafx.beans.property.SimpleIntegerProperty;
  49 import javafx.beans.property.SimpleObjectProperty;
  50 import javafx.beans.value.ChangeListener;
  51 import javafx.collections.ObservableList;
  52 import javafx.event.EventDispatcher;
  53 import javafx.event.EventHandler;
  54 import javafx.geometry.Orientation;
  55 import javafx.scene.AccessibleRole;
  56 import javafx.scene.Group;
  57 import javafx.scene.Node;
  58 import javafx.scene.Parent;
  59 import javafx.scene.Scene;
  60 import javafx.scene.control.Cell;
  61 import javafx.scene.control.IndexedCell;
  62 import javafx.scene.control.ScrollBar;
  63 import javafx.scene.input.MouseEvent;
  64 import javafx.scene.input.ScrollEvent;
  65 import javafx.scene.layout.Region;
  66 import javafx.scene.layout.StackPane;
  67 import javafx.scene.shape.Rectangle;
  68 import javafx.util.Callback;
  69 import javafx.util.Duration;
  70 import com.sun.javafx.logging.PlatformLogger;
  71 
  72 import java.util.AbstractList;
  73 import java.util.ArrayList;
  74 import java.util.BitSet;
  75 import java.util.List;
  76 
  77 /**
  78  * Implementation of a virtualized container using a cell based mechanism. This
  79  * is used by the skin implementations for UI controls such as
  80  * {@link javafx.scene.control.ListView}, {@link javafx.scene.control.TreeView},
  81  * {@link javafx.scene.control.TableView}, and {@link javafx.scene.control.TreeTableView}.
  82  *
  83  * @since 9
  84  */
  85 public class VirtualFlow&lt;T extends IndexedCell&gt; extends Region {
  86 
  87     /***************************************************************************
  88      *                                                                         *
  89      * Static fields                                                           *
  90      *                                                                         *
  91      **************************************************************************/
  92 
  93     /**
  94      * Scroll events may request to scroll about a number of &quot;lines&quot;. We first
  95      * decide how big one &quot;line&quot; is - for fixed cell size it&#39;s clear,
  96      * for variable cell size we settle on a single number so that the scrolling
  97      * speed is consistent. Now if the line is so big that
  98      * MIN_SCROLLING_LINES_PER_PAGE of them don&#39;t fit into one page, we make
  99      * them smaller to prevent the scrolling step to be too big (perhaps
 100      * even more than one page).
 101      */
 102     private static final int MIN_SCROLLING_LINES_PER_PAGE = 8;
 103 
 104     /**
 105      * Indicates that this is a newly created cell and we need call processCSS for it.
 106      *
 107      * See RT-23616 for more details.
 108      */
 109     private static final String NEW_CELL = &quot;newcell&quot;;
 110 
 111     private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;
 112 
 113 
 114 
 115     /***************************************************************************
 116      *                                                                         *
 117      * Private fields                                                          *
 118      *                                                                         *
 119      **************************************************************************/
 120 
 121     private boolean touchDetected = false;
 122     private boolean mouseDown = false;
 123 
 124     /**
 125      * The width of the VirtualFlow the last time it was laid out. We
 126      * use this information for several fast paths during the layout pass.
 127      */
 128     double lastWidth = -1;
 129 
 130     /**
 131      * The height of the VirtualFlow the last time it was laid out. We
 132      * use this information for several fast paths during the layout pass.
 133      */
 134     double lastHeight = -1;
 135 
 136     /**
 137      * The number of &quot;virtual&quot; cells in the flow the last time it was laid out.
 138      * For example, there may have been 1000 virtual cells, but only 20 actual
 139      * cells created and in use. In that case, lastCellCount would be 1000.
 140      */
 141     int lastCellCount = 0;
 142 
 143     /**
 144      * We remember the last value for vertical the last time we laid out the
 145      * flow. If vertical has changed, we will want to change the max &amp; value
 146      * for the different scroll bars. Since we do all the scroll bar update
 147      * work in the layoutChildren function, we need to know what the old value for
 148      * vertical was.
 149      */
 150     boolean lastVertical;
 151 
 152     /**
 153      * The position last time we laid out. If none of the lastXXX vars have
 154      * changed respective to their values in layoutChildren, then we can just punt
 155      * out of the method (I hope...)
 156      */
 157     double lastPosition;
 158 
 159     /**
 160      * The breadth of the first visible cell last time we laid out.
 161      */
 162     double lastCellBreadth = -1;
 163 
 164     /**
 165      * The length of the first visible cell last time we laid out.
 166      */
 167     double lastCellLength = -1;
 168 
 169     /**
 170      * The list of cells representing those cells which actually make up the
 171      * current view. The cells are ordered such that the first cell in this
 172      * list is the first in the view, and the last cell is the last in the
 173      * view. When pixel scrolling, the list is simply shifted and items drop
 174      * off the beginning or the end, depending on the order of scrolling.
 175      * &lt;p&gt;
 176      * This is package private ONLY FOR TESTING
 177      */
 178     final ArrayLinkedList&lt;T&gt; cells = new ArrayLinkedList&lt;T&gt;();
 179 
 180     /**
 181      * A structure containing cells that can be reused later. These are cells
 182      * that at one time were needed to populate the view, but now are no longer
 183      * needed. We keep them here until they are needed again.
 184      * &lt;p&gt;
 185      * This is package private ONLY FOR TESTING
 186      */
 187     final ArrayLinkedList&lt;T&gt; pile = new ArrayLinkedList&lt;T&gt;();
 188 
 189     /**
 190      * A special cell used to accumulate bounds, such that we reduce object
 191      * churn. This cell must be recreated whenever the cell factory function
 192      * changes. This has package access ONLY for testing.
 193      */
 194     T accumCell;
 195 
 196     /**
 197      * This group is used for holding the &#39;accumCell&#39;. &#39;accumCell&#39; must
 198      * be added to the skin for it to be styled. Otherwise, it doesn&#39;t
 199      * report the correct width/height leading to issues when scrolling
 200      * the flow
 201      */
 202     Group accumCellParent;
 203 
 204     /**
 205      * The group which holds the cells.
 206      */
 207     final Group sheet;
 208 
 209     final ObservableList&lt;Node&gt; sheetChildren;
 210 
 211     /**
 212      * The scroll bar used for scrolling horizontally. This has package access
 213      * ONLY for testing.
 214      */
 215     private VirtualScrollBar hbar = new VirtualScrollBar(this);
 216 
 217     /**
 218      * The scroll bar used to scrolling vertically. This has package access
 219      * ONLY for testing.
 220      */
 221     private VirtualScrollBar vbar = new VirtualScrollBar(this);
 222 
 223     /**
 224      * Control in which the cell&#39;s sheet is placed and forms the viewport. The
 225      * viewportBreadth and viewportLength are simply the dimensions of the
 226      * clipView. This has package access ONLY for testing.
 227      */
 228     ClippedContainer clipView;
 229 
 230     /**
 231      * When both the horizontal and vertical scroll bars are visible,
 232      * we have to &#39;fill in&#39; the bottom right corner where the two scroll bars
 233      * meet. This is handled by this corner region. This has package access
 234      * ONLY for testing.
 235      */
 236     StackPane corner;
 237 
 238     // used for panning the virtual flow
 239     private double lastX;
 240     private double lastY;
 241     private boolean isPanning = false;
 242 
 243     private boolean fixedCellSizeEnabled = false;
 244 
 245     private boolean needsReconfigureCells = false; // when cell contents are the same
 246     private boolean needsRecreateCells = false; // when cell factory changed
 247     private boolean needsRebuildCells = false; // when cell contents have changed
 248     private boolean needsCellsLayout = false;
 249     private boolean sizeChanged = false;
 250     private final BitSet dirtyCells = new BitSet();
 251 
 252     Timeline sbTouchTimeline;
 253     KeyFrame sbTouchKF1;
 254     KeyFrame sbTouchKF2;
 255 
 256     private boolean needBreadthBar;
 257     private boolean needLengthBar;
 258     private boolean tempVisibility = false;
 259 
 260 
 261 
 262     /***************************************************************************
 263      *                                                                         *
 264      * Constructors                                                            *
 265      *                                                                         *
 266      **************************************************************************/
 267 
 268     /**
 269      * Creates a new VirtualFlow instance.
 270      */
 271     public VirtualFlow() {
 272         getStyleClass().add(&quot;virtual-flow&quot;);
 273         setId(&quot;virtual-flow&quot;);
 274 
 275         // initContent
 276         // --- sheet
 277         sheet = new Group();
 278         sheet.getStyleClass().add(&quot;sheet&quot;);
 279         sheet.setAutoSizeChildren(false);
 280 
 281         sheetChildren = sheet.getChildren();
 282 
 283         // --- clipView
 284         clipView = new ClippedContainer(this);
 285         clipView.setNode(sheet);
 286         getChildren().add(clipView);
 287 
 288         // --- accumCellParent
 289         accumCellParent = new Group();
 290         accumCellParent.setVisible(false);
 291         getChildren().add(accumCellParent);
 292 
 293 
 294         /*
 295         ** don&#39;t allow the ScrollBar to handle the ScrollEvent,
 296         ** In a VirtualFlow a vertical scroll should scroll on the vertical only,
 297         ** whereas in a horizontal ScrollBar it can scroll horizontally.
 298         */
 299         // block the event from being passed down to children
 300         final EventDispatcher blockEventDispatcher = (event, tail) -&gt; event;
 301         // block ScrollEvent from being passed down to scrollbar&#39;s skin
 302         final EventDispatcher oldHsbEventDispatcher = hbar.getEventDispatcher();
 303         hbar.setEventDispatcher((event, tail) -&gt; {
 304             if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
 305                     !((ScrollEvent)event).isDirect()) {
 306                 tail = tail.prepend(blockEventDispatcher);
 307                 tail = tail.prepend(oldHsbEventDispatcher);
 308                 return tail.dispatchEvent(event);
 309             }
 310             return oldHsbEventDispatcher.dispatchEvent(event, tail);
 311         });
 312         // block ScrollEvent from being passed down to scrollbar&#39;s skin
 313         final EventDispatcher oldVsbEventDispatcher = vbar.getEventDispatcher();
 314         vbar.setEventDispatcher((event, tail) -&gt; {
 315             if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
 316                     !((ScrollEvent)event).isDirect()) {
 317                 tail = tail.prepend(blockEventDispatcher);
 318                 tail = tail.prepend(oldVsbEventDispatcher);
 319                 return tail.dispatchEvent(event);
 320             }
 321             return oldVsbEventDispatcher.dispatchEvent(event, tail);
 322         });
 323         /*
 324         ** listen for ScrollEvents over the whole of the VirtualFlow
 325         ** area, the above dispatcher having removed the ScrollBars
 326         ** scroll event handling.
 327         */
 328         setOnScroll(new EventHandler&lt;ScrollEvent&gt;() {
 329             @Override public void handle(ScrollEvent event) {
 330                 if (Properties.IS_TOUCH_SUPPORTED) {
 331                     if (touchDetected == false &amp;&amp;  mouseDown == false ) {
 332                         startSBReleasedAnimation();
 333                     }
 334                 }
 335                 /*
 336                 ** calculate the delta in the direction of the flow.
 337                 */
 338                 double virtualDelta = 0.0;
 339                 if (isVertical()) {
 340                     switch(event.getTextDeltaYUnits()) {
 341                         case PAGES:
 342                             virtualDelta = event.getTextDeltaY() * lastHeight;
 343                             break;
 344                         case LINES:
 345                             double lineSize;
 346                             if (fixedCellSizeEnabled) {
 347                                 lineSize = getFixedCellSize();
 348                             } else {
 349                                 // For the scrolling to be reasonably consistent
 350                                 // we set the lineSize to the average size
 351                                 // of all currently loaded lines.
 352                                 T lastCell = cells.getLast();
 353                                 lineSize =
 354                                         (getCellPosition(lastCell)
 355                                             + getCellLength(lastCell)
 356                                             - getCellPosition(cells.getFirst()))
 357                                         / cells.size();
 358                             }
 359 
 360                             if (lastHeight / lineSize &lt; MIN_SCROLLING_LINES_PER_PAGE) {
 361                                 lineSize = lastHeight / MIN_SCROLLING_LINES_PER_PAGE;
 362                             }
 363 
 364                             virtualDelta = event.getTextDeltaY() * lineSize;
 365                             break;
 366                         case NONE:
 367                             virtualDelta = event.getDeltaY();
 368                     }
 369                 } else { // horizontal
 370                     switch(event.getTextDeltaXUnits()) {
 371                         case CHARACTERS:
 372                             // can we get character size here?
 373                             // for now, fall through to pixel values
 374                         case NONE:
 375                             double dx = event.getDeltaX();
 376                             double dy = event.getDeltaY();
 377 
 378                             virtualDelta = (Math.abs(dx) &gt; Math.abs(dy) ? dx : dy);
 379                     }
 380                 }
 381 
 382                 if (virtualDelta != 0.0) {
 383                     /*
 384                     ** only consume it if we use it
 385                     */
 386                     double result = scrollPixels(-virtualDelta);
 387                     if (result != 0.0) {
 388                         event.consume();
 389                     }
 390                 }
 391 
 392                 ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
 393                 if (needBreadthBar) {
 394                     double nonVirtualDelta = isVertical() ? event.getDeltaX() : event.getDeltaY();
 395                     if (nonVirtualDelta != 0.0) {
 396                         double newValue = nonVirtualBar.getValue() - nonVirtualDelta;
 397                         if (newValue &lt; nonVirtualBar.getMin()) {
 398                             nonVirtualBar.setValue(nonVirtualBar.getMin());
 399                         } else if (newValue &gt; nonVirtualBar.getMax()) {
 400                             nonVirtualBar.setValue(nonVirtualBar.getMax());
 401                         } else {
 402                             nonVirtualBar.setValue(newValue);
 403                         }
 404                         event.consume();
 405                     }
 406                 }
 407             }
 408         });
 409 
 410 
 411         addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler&lt;MouseEvent&gt;() {
 412             @Override
 413             public void handle(MouseEvent e) {
 414                 mouseDown = true;
 415                 if (Properties.IS_TOUCH_SUPPORTED) {
 416                     scrollBarOn();
 417                 }
 418                 if (isFocusTraversable()) {
 419                     // We check here to see if the current focus owner is within
 420                     // this VirtualFlow, and if so we back-off from requesting
 421                     // focus back to the VirtualFlow itself. This is particularly
 422                     // relevant given the bug identified in RT-32869. In this
 423                     // particular case TextInputControl was clearing selection
 424                     // when the focus on the TextField changed, meaning that the
 425                     // right-click context menu was not showing the correct
 426                     // options as there was no selection in the TextField.
 427                     boolean doFocusRequest = true;
 428                     Node focusOwner = getScene().getFocusOwner();
 429                     if (focusOwner != null) {
 430                         Parent parent = focusOwner.getParent();
 431                         while (parent != null) {
 432                             if (parent.equals(VirtualFlow.this)) {
 433                                 doFocusRequest = false;
 434                                 break;
 435                             }
 436                             parent = parent.getParent();
 437                         }
 438                     }
 439 
 440                     if (doFocusRequest) {
 441                         requestFocus();
 442                     }
 443                 }
 444 
 445                 lastX = e.getX();
 446                 lastY = e.getY();
 447 
 448                 // determine whether the user has push down on the virtual flow,
 449                 // or whether it is the scrollbar. This is done to prevent
 450                 // mouse events being &#39;doubled up&#39; when dragging the scrollbar
 451                 // thumb - it has the side-effect of also starting the panning
 452                 // code, leading to flicker
 453                 isPanning = ! (vbar.getBoundsInParent().contains(e.getX(), e.getY())
 454                         || hbar.getBoundsInParent().contains(e.getX(), e.getY()));
 455             }
 456         });
 457         addEventFilter(MouseEvent.MOUSE_RELEASED, e -&gt; {
 458             mouseDown = false;
 459             if (Properties.IS_TOUCH_SUPPORTED) {
 460                 startSBReleasedAnimation();
 461             }
 462         });
 463         addEventFilter(MouseEvent.MOUSE_DRAGGED, e -&gt; {
 464             if (Properties.IS_TOUCH_SUPPORTED) {
 465                 scrollBarOn();
 466             }
 467             if (! isPanning || ! isPannable()) return;
 468 
 469             // With panning enabled, we support panning in both vertical
 470             // and horizontal directions, regardless of the fact that
 471             // VirtualFlow is virtual in only one direction.
 472             double xDelta = lastX - e.getX();
 473             double yDelta = lastY - e.getY();
 474 
 475             // figure out the distance that the mouse moved in the virtual
 476             // direction, and then perform the movement along that axis
 477             // virtualDelta will contain the amount we actually did move
 478             double virtualDelta = isVertical() ? yDelta : xDelta;
 479             double actual = scrollPixels(virtualDelta);
 480             if (actual != 0) {
 481                 // update last* here, as we know we&#39;ve just adjusted the
 482                 // scrollbar. This means we don&#39;t get the situation where a
 483                 // user presses-and-drags a long way past the min or max
 484                 // values, only to change directions and see the scrollbar
 485                 // start moving immediately.
 486                 if (isVertical()) lastY = e.getY();
 487                 else lastX = e.getX();
 488             }
 489 
 490             // similarly, we do the same in the non-virtual direction
 491             double nonVirtualDelta = isVertical() ? xDelta : yDelta;
 492             ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
 493             if (nonVirtualBar.isVisible()) {
 494                 double newValue = nonVirtualBar.getValue() + nonVirtualDelta;
 495                 if (newValue &lt; nonVirtualBar.getMin()) {
 496                     nonVirtualBar.setValue(nonVirtualBar.getMin());
 497                 } else if (newValue &gt; nonVirtualBar.getMax()) {
 498                     nonVirtualBar.setValue(nonVirtualBar.getMax());
 499                 } else {
 500                     nonVirtualBar.setValue(newValue);
 501 
 502                     // same as the last* comment above
 503                     if (isVertical()) lastX = e.getX();
 504                     else lastY = e.getY();
 505                 }
 506             }
 507         });
 508 
 509         /*
 510          * We place the scrollbars _above_ the rectangle, such that the drag
 511          * operations often used in conjunction with scrollbars aren&#39;t
 512          * misinterpreted as drag operations on the rectangle as well (which
 513          * would be the case if the scrollbars were underneath it as the
 514          * rectangle itself doesn&#39;t block the mouse.
 515          */
 516         // --- vbar
 517         vbar.setOrientation(Orientation.VERTICAL);
 518         vbar.addEventHandler(MouseEvent.ANY, event -&gt; {
 519             event.consume();
 520         });
 521         getChildren().add(vbar);
 522 
 523         // --- hbar
 524         hbar.setOrientation(Orientation.HORIZONTAL);
 525         hbar.addEventHandler(MouseEvent.ANY, event -&gt; {
 526             event.consume();
 527         });
 528         getChildren().add(hbar);
 529 
 530         // --- corner
 531         corner = new StackPane();
 532         corner.getStyleClass().setAll(&quot;corner&quot;);
 533         getChildren().add(corner);
 534 
 535 
 536 
 537         // initBinds
 538         // clipView binds
 539         InvalidationListener listenerX = valueModel -&gt; {
 540             updateHbar();
 541         };
 542         verticalProperty().addListener(listenerX);
 543         hbar.valueProperty().addListener(listenerX);
 544         hbar.visibleProperty().addListener(listenerX);
 545 
 546 //        ChangeListener listenerY = new ChangeListener() {
 547 //            @Override public void handle(Bean bean, PropertyReference property) {
 548 //                clipView.setClipY(isVertical() ? 0 : vbar.getValue());
 549 //            }
 550 //        };
 551 //        addChangedListener(VERTICAL, listenerY);
 552 //        vbar.addChangedListener(ScrollBar.VALUE, listenerY);
 553 
 554         ChangeListener&lt;Number&gt; listenerY = (ov, t, t1) -&gt; {
 555             clipView.setClipY(isVertical() ? 0 : vbar.getValue());
 556         };
 557         vbar.valueProperty().addListener(listenerY);
 558 
 559         super.heightProperty().addListener((observable, oldHeight, newHeight) -&gt; {
 560             // Fix for RT-8480, where the VirtualFlow does not show its content
 561             // after changing size to 0 and back.
 562             if (oldHeight.doubleValue() == 0 &amp;&amp; newHeight.doubleValue() &gt; 0) {
 563                 recreateCells();
 564             }
 565         });
 566 
 567 
 568         /*
 569         ** there are certain animations that need to know if the touch is
 570         ** happening.....
 571         */
 572         setOnTouchPressed(e -&gt; {
 573             touchDetected = true;
 574             scrollBarOn();
 575         });
 576 
 577         setOnTouchReleased(e -&gt; {
 578             touchDetected = false;
 579             startSBReleasedAnimation();
 580         });
 581 
 582         ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {
 583 
 584             Node selectNextAfterIndex(int index, TraversalContext context) {
 585                 T nextCell;
 586                 while ((nextCell = getVisibleCell(++index)) != null) {
 587                     if (nextCell.isFocusTraversable()) {
 588                         return nextCell;
 589                     }
 590                     Node n = context.selectFirstInParent(nextCell);
 591                     if (n != null) {
 592                         return n;
 593                     }
 594                 }
 595                 return null;
 596             }
 597 
 598             Node selectPreviousBeforeIndex(int index, TraversalContext context) {
 599                 T prevCell;
 600                 while ((prevCell = getVisibleCell(--index)) != null) {
 601                     Node prev = context.selectLastInParent(prevCell);
 602                     if (prev != null) {
 603                         return prev;
 604                     }
 605                     if (prevCell.isFocusTraversable()) {
 606                         return prevCell;
 607                     }
 608                 }
 609                 return null;
 610             }
 611 
 612             @Override
 613             public Node select(Node owner, Direction dir, TraversalContext context) {
 614                 T cell;
 615                 if (cells.isEmpty()) return null;
 616                 if (cells.contains(owner)) {
 617                     cell = (T) owner;
 618                 } else {
 619                     cell = findOwnerCell(owner);
 620                     Node next = context.selectInSubtree(cell, owner, dir);
 621                     if (next != null) {
 622                         return next;
 623                     }
 624                     if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
 625                 }
 626                 int cellIndex = cell.getIndex();
 627                 switch(dir) {
 628                     case PREVIOUS:
 629                         return selectPreviousBeforeIndex(cellIndex, context);
 630                     case NEXT:
 631                         Node n = context.selectFirstInParent(cell);
 632                         if (n != null) {
 633                             return n;
 634                         }
 635                         // Intentional fall-through
 636                     case NEXT_IN_LINE:
 637                         return selectNextAfterIndex(cellIndex, context);
 638                 }
 639                 return null;
 640             }
 641 
 642             private T findOwnerCell(Node owner) {
 643                 Parent p = owner.getParent();
 644                 while (!cells.contains(p)) {
 645                     p = p.getParent();
 646                 }
 647                 return (T)p;
 648             }
 649 
 650             @Override
 651             public Node selectFirst(TraversalContext context) {
 652                 T firstCell = cells.getFirst();
 653                 if (firstCell == null) return null;
 654                 if (firstCell.isFocusTraversable()) return firstCell;
 655                 Node n = context.selectFirstInParent(firstCell);
 656                 if (n != null) {
 657                     return n;
 658                 }
 659                 return selectNextAfterIndex(firstCell.getIndex(), context);
 660             }
 661 
 662             @Override
 663             public Node selectLast(TraversalContext context) {
 664                 T lastCell = cells.getLast();
 665                 if (lastCell == null) return null;
 666                 Node p = context.selectLastInParent(lastCell);
 667                 if (p != null) {
 668                     return p;
 669                 }
 670                 if (lastCell.isFocusTraversable()) return lastCell;
 671                 return selectPreviousBeforeIndex(lastCell.getIndex(), context);
 672             }
 673         }));
 674     }
 675 
 676 
 677 
 678     /***************************************************************************
 679      *                                                                         *
 680      * Properties                                                              *
 681      *                                                                         *
 682      **************************************************************************/
 683 
 684     /**
 685      * There are two main complicating factors in the implementation of the
 686      * VirtualFlow, which are made even more complicated due to the performance
 687      * sensitive nature of this code. The first factor is the actual
 688      * virtualization mechanism, wired together with the PositionMapper.
 689      * The second complicating factor is the desire to do minimal layout
 690      * and minimal updates to CSS.
 691      *
 692      * Since the layout mechanism runs at most once per pulse, we want to hook
 693      * into this mechanism for minimal recomputation. Whenever a layout pass
 694      * is run we record the width/height that the virtual flow was last laid
 695      * out to. In subsequent passes, if the width/height has not changed then
 696      * we know we only have to rebuild the cells. If the width or height has
 697      * changed, then we can make appropriate decisions based on whether the
 698      * width / height has been reduced or expanded.
 699      *
 700      * In various places, if requestLayout is called it is generally just
 701      * used to indicate that some form of layout needs to happen (either the
 702      * entire thing has to be reconstructed, or just the cells need to be
 703      * reconstructed, generally).
 704      *
 705      * The accumCell is a special cell which is used in some computations
 706      * when an actual cell for that item isn&#39;t currently available. However,
 707      * the accumCell must be cleared whenever the cellFactory function is
 708      * changed because we need to use the cells that come from the new factory.
 709      *
 710      * In addition to storing the lastWidth and lastHeight, we also store the
 711      * number of cells that existed last time we performed a layout. In this
 712      * way if the number of cells change, we can request a layout and when it
 713      * occurs we can tell that the number of cells has changed and react
 714      * accordingly.
 715      *
 716      * Because the VirtualFlow can be laid out horizontally or vertically a
 717      * naming problem is present when trying to conceptualize and implement
 718      * the flow. In particular, the words &quot;width&quot; and &quot;height&quot; are not
 719      * precise when describing the unit of measure along the &quot;virtualized&quot;
 720      * axis and the &quot;orthogonal&quot; axis. For example, the height of a cell when
 721      * the flow is vertical is the magnitude along the &quot;virtualized axis&quot;,
 722      * and the width is along the axis orthogonal to it.
 723      *
 724      * Since &quot;height&quot; and &quot;width&quot; are not reliable terms, we use the words
 725      * &quot;length&quot; and &quot;breadth&quot; to describe the magnitude of a cell along
 726      * the virtualized axis and orthogonal axis. For example, in a vertical
 727      * flow, the height=length and the width=breadth. In a horizontal axis,
 728      * the height=breadth and the width=length.
 729      *
 730      * These terms are somewhat arbitrary, but chosen so that when reading
 731      * most of the below code you can think in just one dimension, with
 732      * helper functions converting width/height in to length/breadth, while
 733      * also being different from width/height so as not to get confused with
 734      * the actual width/height of a cell.
 735      */
 736 
 737     // --- vertical
 738     /**
 739      * Indicates the primary direction of virtualization. If true, then the
 740      * primary direction of virtualization is vertical, meaning that cells will
 741      * stack vertically on top of each other. If false, then they will stack
 742      * horizontally next to each other.
 743      */
 744     private BooleanProperty vertical;
 745     public final void setVertical(boolean value) {
 746         verticalProperty().set(value);
 747     }
 748 
 749     public final boolean isVertical() {
 750         return vertical == null ? true : vertical.get();
 751     }
 752 
 753     public final BooleanProperty verticalProperty() {
 754         if (vertical == null) {
 755             vertical = new BooleanPropertyBase(true) {
 756                 @Override protected void invalidated() {
 757                     pile.clear();
 758                     sheetChildren.clear();
 759                     cells.clear();
 760                     lastWidth = lastHeight = -1;
 761                     setMaxPrefBreadth(-1);
 762                     setViewportBreadth(0);
 763                     setViewportLength(0);
 764                     lastPosition = 0;
 765                     hbar.setValue(0);
 766                     vbar.setValue(0);
 767                     setPosition(0.0f);
 768                     setNeedsLayout(true);
 769                     requestLayout();
 770                 }
 771 
 772                 @Override
 773                 public Object getBean() {
 774                     return VirtualFlow.this;
 775                 }
 776 
 777                 @Override
 778                 public String getName() {
 779                     return &quot;vertical&quot;;
 780                 }
 781             };
 782         }
 783         return vertical;
 784     }
 785 
 786     // --- pannable
 787     /**
 788      * Indicates whether the VirtualFlow viewport is capable of being panned
 789      * by the user (either via the mouse or touch events).
 790      */
 791     private BooleanProperty pannable = new SimpleBooleanProperty(this, &quot;pannable&quot;, true);
 792     public final boolean isPannable() { return pannable.get(); }
 793     public final void setPannable(boolean value) { pannable.set(value); }
 794     public final BooleanProperty pannableProperty() { return pannable; }
 795 
 796     // --- cell count
 797     /**
 798      * Indicates the number of cells that should be in the flow. The user of
 799      * the VirtualFlow must set this appropriately. When the cell count changes
 800      * the VirtualFlow responds by updating the visuals. If the items backing
 801      * the cells change, but the count has not changed, you must call the
 802      * reconfigureCells() function to update the visuals.
 803      */
 804     private IntegerProperty cellCount = new SimpleIntegerProperty(this, &quot;cellCount&quot;, 0) {
 805         private int oldCount = 0;
 806 
 807         @Override protected void invalidated() {
 808             int cellCount = get();
 809 
 810             boolean countChanged = oldCount != cellCount;
 811             oldCount = cellCount;
 812 
 813             // ensure that the virtual scrollbar adjusts in size based on the current
 814             // cell count.
 815             if (countChanged) {
 816                 VirtualScrollBar lengthBar = isVertical() ? vbar : hbar;
 817                 lengthBar.setMax(cellCount);
 818             }
 819 
 820             // I decided *not* to reset maxPrefBreadth here for the following
 821             // situation. Suppose I have 30 cells and then I add 10 more. Just
 822             // because I added 10 more doesn&#39;t mean the max pref should be
 823             // reset. Suppose the first 3 cells were extra long, and I was
 824             // scrolled down such that they weren&#39;t visible. If I were to reset
 825             // maxPrefBreadth when subsequent cells were added or removed, then the
 826             // scroll bars would erroneously reset as well. So I do not reset
 827             // the maxPrefBreadth here.
 828 
 829             // Fix for RT-12512, RT-14301 and RT-14864.
 830             // Without this, the VirtualFlow length-wise scrollbar would not change
 831             // as expected. This would leave items unable to be shown, as they
 832             // would exist outside of the visible area, even when the scrollbar
 833             // was at its maximum position.
 834             // FIXME this should be only executed on the pulse, so this will likely
 835             // lead to performance degradation until it is handled properly.
 836             if (countChanged) {
 837                 layoutChildren();
 838 
 839                 // Fix for RT-13965: Without this line of code, the number of items in
 840                 // the sheet would constantly grow, leaking memory for the life of the
 841                 // application. This was especially apparent when the total number of
 842                 // cells changes - regardless of whether it became bigger or smaller.
 843                 sheetChildren.clear();
 844 
 845                 Parent parent = getParent();
 846                 if (parent != null) parent.requestLayout();
 847             }
 848             // TODO suppose I had 100 cells and I added 100 more. Further
 849             // suppose I was scrolled to the bottom when that happened. I
 850             // actually want to update the position of the mapper such that
 851             // the view remains &quot;stable&quot;.
 852         }
 853     };
 854     public final int getCellCount() { return cellCount.get(); }
 855     public final void setCellCount(int value) { cellCount.set(value);  }
 856     public final IntegerProperty cellCountProperty() { return cellCount; }
 857 
 858 
 859     // --- position
 860     /**
 861      * The position of the VirtualFlow within its list of cells. This is a value
 862      * between 0 and 1.
 863      */
 864     private DoubleProperty position = new SimpleDoubleProperty(this, &quot;position&quot;) {
 865         @Override public void setValue(Number v) {
 866             super.setValue(com.sun.javafx.util.Utils.clamp(0, get(), 1));
 867         }
 868 
 869         @Override protected void invalidated() {
 870             super.invalidated();
 871             requestLayout();
 872         }
 873     };
 874     public final double getPosition() { return position.get(); }
 875     public final void setPosition(double value) { position.set(value); }
 876     public final DoubleProperty positionProperty() { return position; }
 877 
 878     // --- fixed cell size
 879     /**
 880      * For optimisation purposes, some use cases can trade dynamic cell length
 881      * for speed - if fixedCellSize is greater than zero we&#39;ll use that rather
 882      * than determine it by querying the cell itself.
 883      */
 884     private DoubleProperty fixedCellSize = new SimpleDoubleProperty(this, &quot;fixedCellSize&quot;) {
 885         @Override protected void invalidated() {
 886             fixedCellSizeEnabled = get() &gt; 0;
 887             needsCellsLayout = true;
 888             layoutChildren();
 889         }
 890     };
 891     public final void setFixedCellSize(final double value) { fixedCellSize.set(value); }
 892     public final double getFixedCellSize() { return fixedCellSize.get(); }
 893     public final DoubleProperty fixedCellSizeProperty() { return fixedCellSize; }
 894 
 895 
 896     // --- Cell Factory
 897     private ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactory;
 898 
 899     /**
 900      * Sets a new cell factory to use in the VirtualFlow. This forces all old
 901      * cells to be thrown away, and new cells to be created with
 902      * the new cell factory.
 903      * @param value the new cell factory
 904      */
 905     public final void setCellFactory(Callback&lt;VirtualFlow&lt;T&gt;, T&gt; value) {
 906         cellFactoryProperty().set(value);
 907     }
 908 
 909     /**
 910      * Returns the current cell factory.
 911      * @return the current cell factory
 912      */
 913     public final Callback&lt;VirtualFlow&lt;T&gt;, T&gt; getCellFactory() {
 914         return cellFactory == null ? null : cellFactory.get();
 915     }
 916 
 917     /**
 918      * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
 919      * creation, allowing for total customization of the cell. Internally, the
 920      * VirtualFlow is responsible for reusing cells - all that is necessary
 921      * is for the custom cell factory to return from this function a cell
 922      * which might be usable for representing any item in the VirtualFlow.
 923      *
 924      * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
 925      * @return  the cell factory property
 926      */
 927     public final ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactoryProperty() {
 928         if (cellFactory == null) {
 929             cellFactory = new SimpleObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt;(this, &quot;cellFactory&quot;) {
 930                 @Override protected void invalidated() {
 931                     if (get() != null) {
 932                         accumCell = null;
 933                         setNeedsLayout(true);
 934                         recreateCells();
 935                         if (getParent() != null) getParent().requestLayout();
 936                     }
 937                 }
 938             };
 939         }
 940         return cellFactory;
 941     }
 942 
 943 
 944 
 945     /***************************************************************************
 946      *                                                                         *
 947      * Public API                                                              *
 948      *                                                                         *
 949      **************************************************************************/
 950 
 951     /**
 952      * Overridden to implement somewhat more efficient support for layout. The
 953      * VirtualFlow can generally be considered as being unmanaged, in that
 954      * whenever the position changes, or other such things change, we need
 955      * to perform a layout but there is no reason to notify the parent. However
 956      * when things change which may impact the preferred size (such as
 957      * vertical, createCell, and configCell) then we need to notify the
 958      * parent.
 959      */
 960     @Override public void requestLayout() {
 961 // Note: This block is commented as it was relaying on a bad assumption on how
 962 //       layout request was handled in parent class that is now fixed.
 963 //
 964 //        // isNeedsLayout() is commented out due to RT-21417. This does not
 965 //        // appear to impact performance (indeed, it may help), and resolves the
 966 //        // issue identified in RT-21417.
 967 //        setNeedsLayout(true);
 968 
 969         // The fix is to prograte this layout request to its parent class.
 970         // A better fix will be required if performance is negatively affected
 971         // by this fix.
 972         super.requestLayout();
 973     }
 974 
 975     /** {@inheritDoc} */
 976     @Override protected void layoutChildren() {
 977         if (needsRecreateCells) {
 978             lastWidth = -1;
 979             lastHeight = -1;
 980             releaseCell(accumCell);
 981 //            accumCell = null;
 982 //            accumCellParent.getChildren().clear();
 983             sheet.getChildren().clear();
 984             for (int i = 0, max = cells.size(); i &lt; max; i++) {
 985                 cells.get(i).updateIndex(-1);
 986             }
 987             cells.clear();
 988             pile.clear();
 989             releaseAllPrivateCells();
 990         } else if (needsRebuildCells) {
 991             lastWidth = -1;
 992             lastHeight = -1;
 993             releaseCell(accumCell);
 994             for (int i = 0, max = cells.size(); i &lt; max; i++) {
 995                 cells.get(i).updateIndex(-1);
 996             }
 997             addAllToPile();
 998             releaseAllPrivateCells();
 999         } else if (needsReconfigureCells) {
1000             setMaxPrefBreadth(-1);
1001             lastWidth = -1;
1002             lastHeight = -1;
1003         }
1004 
1005         if (! dirtyCells.isEmpty()) {
1006             int index;
1007             final int cellsSize = cells.size();
1008             while ((index = dirtyCells.nextSetBit(0)) != -1 &amp;&amp; index &lt; cellsSize) {
1009                 T cell = cells.get(index);
1010                 // updateIndex(-1) works for TableView, but breaks ListView.
1011                 // For now, the TableView just does not use the dirtyCells API
1012 //                cell.updateIndex(-1);
1013                 if (cell != null) {
1014                     cell.requestLayout();
1015                 }
1016                 dirtyCells.clear(index);
1017             }
1018 
1019             setMaxPrefBreadth(-1);
1020             lastWidth = -1;
1021             lastHeight = -1;
1022         }
1023 
1024         final boolean hasSizeChange = sizeChanged;
1025         boolean recreatedOrRebuilt = needsRebuildCells || needsRecreateCells || sizeChanged;
1026 
1027         needsRecreateCells = false;
1028         needsReconfigureCells = false;
1029         needsRebuildCells = false;
1030         sizeChanged = false;
1031 
1032         if (needsCellsLayout) {
1033             for (int i = 0, max = cells.size(); i &lt; max; i++) {
1034                 Cell&lt;?&gt; cell = cells.get(i);
1035                 if (cell != null) {
1036                     cell.requestLayout();
1037                 }
1038             }
1039             needsCellsLayout = false;
1040 
1041             // yes, we return here - if needsCellsLayout was set to true, we
1042             // only did it to do the above - not rerun the entire layout.
1043             return;
1044         }
1045 
1046         final double width = getWidth();
1047         final double height = getHeight();
1048         final boolean isVertical = isVertical();
1049         final double position = getPosition();
1050 
1051         // if the width and/or height is 0, then there is no point doing
1052         // any of this work. In particular, this can happen during startup
1053         if (width &lt;= 0 || height &lt;= 0) {
1054             addAllToPile();
1055             lastWidth = width;
1056             lastHeight = height;
1057             hbar.setVisible(false);
1058             vbar.setVisible(false);
1059             corner.setVisible(false);
1060             return;
1061         }
1062 
1063         // we check if any of the cells in the cells list need layout. This is a
1064         // sign that they are perhaps animating their sizes. Without this check,
1065         // we may not perform a layout here, meaning that the cell will likely
1066         // &#39;jump&#39; (in height normally) when the user drags the virtual thumb as
1067         // that is the first time the layout would occur otherwise.
1068         boolean cellNeedsLayout = false;
1069         boolean thumbNeedsLayout = false;
1070 
1071         if (Properties.IS_TOUCH_SUPPORTED) {
1072             if ((tempVisibility == true &amp;&amp; (hbar.isVisible() == false || vbar.isVisible() == false)) ||
1073                 (tempVisibility == false &amp;&amp; (hbar.isVisible() == true || vbar.isVisible() == true))) {
1074                 thumbNeedsLayout = true;
1075             }
1076         }
1077 
1078         if (!cellNeedsLayout) {
1079             for (int i = 0; i &lt; cells.size(); i++) {
1080                 Cell&lt;?&gt; cell = cells.get(i);
1081                 cellNeedsLayout = cell.isNeedsLayout();
1082                 if (cellNeedsLayout) break;
1083             }
1084         }
1085 
1086         final int cellCount = getCellCount();
1087         final T firstCell = getFirstVisibleCell();
1088 
1089         // If no cells need layout, we check other criteria to see if this
1090         // layout call is even necessary. If it is found that no layout is
1091         // needed, we just punt.
1092         if (! cellNeedsLayout &amp;&amp; !thumbNeedsLayout) {
1093             boolean cellSizeChanged = false;
1094             if (firstCell != null) {
1095                 double breadth = getCellBreadth(firstCell);
1096                 double length = getCellLength(firstCell);
1097                 cellSizeChanged = (breadth != lastCellBreadth) || (length != lastCellLength);
1098                 lastCellBreadth = breadth;
1099                 lastCellLength = length;
1100             }
1101 
1102             if (width == lastWidth &amp;&amp;
1103                 height == lastHeight &amp;&amp;
1104                 cellCount == lastCellCount &amp;&amp;
1105                 isVertical == lastVertical &amp;&amp;
1106                 position == lastPosition &amp;&amp;
1107                 ! cellSizeChanged)
1108             {
1109                 // TODO this happens to work around the problem tested by
1110                 // testCellLayout_LayoutWithoutChangingThingsUsesCellsInSameOrderAsBefore
1111                 // but isn&#39;t a proper solution. Really what we need to do is, when
1112                 // laying out cells, we need to make sure that if a cell is pressed
1113                 // AND we are doing a full rebuild then we need to make sure we
1114                 // use that cell in the same physical location as before so that
1115                 // it gets the mouse release event.
1116                 return;
1117             }
1118         }
1119 
1120         /*
1121          * This function may get called under a variety of circumstances.
1122          * It will determine what has changed from the last time it was laid
1123          * out, and will then take one of several execution paths based on
1124          * what has changed so as to perform minimal layout work and also to
1125          * give the expected behavior. One or more of the following may have
1126          * happened:
1127          *
1128          *  1) width/height has changed
1129          *      - If the width and/or height has been reduced (but neither of
1130          *        them has been expanded), then we simply have to reposition and
1131          *        resize the scroll bars
1132          *      - If the width (in the vertical case) has expanded, then we
1133          *        need to resize the existing cells and reposition and resize
1134          *        the scroll bars
1135          *      - If the height (in the vertical case) has expanded, then we
1136          *        need to resize and reposition the scroll bars and add
1137          *        any trailing cells
1138          *
1139          *  2) cell count has changed
1140          *      - If the number of cells is bigger, or it is smaller but not
1141          *        so small as to move the position then we can just update the
1142          *        cells in place without performing layout and update the
1143          *        scroll bars.
1144          *      - If the number of cells has been reduced and it affects the
1145          *        position, then move the position and rebuild all the cells
1146          *        and update the scroll bars
1147          *
1148          *  3) size of the cell has changed
1149          *      - If the size changed in the virtual direction (ie: height
1150          *        in the case of vertical) then layout the cells, adding
1151          *        trailing cells as necessary and updating the scroll bars
1152          *      - If the size changed in the non virtual direction (ie: width
1153          *        in the case of vertical) then simply adjust the widths of
1154          *        the cells as appropriate and adjust the scroll bars
1155          *
1156          *  4) vertical changed, cells is empty, maxPrefBreadth == -1, etc
1157          *      - Full rebuild.
1158          *
1159          * Each of the conditions really resolves to several of a handful of
1160          * possible outcomes:
1161          *  a) reposition &amp; rebuild scroll bars
1162          *  b) resize cells in non-virtual direction
1163          *  c) add trailing cells
1164          *  d) update cells
1165          *  e) resize cells in the virtual direction
1166          *  f) all of the above
1167          *
1168          * So this function first determines what outcomes need to occur, and
1169          * then will execute all the ones that really need to happen. Every code
1170          * path ends up touching the &quot;reposition &amp; rebuild scroll bars&quot; outcome,
1171          * so that one will be executed every time.
1172          */
1173         boolean needTrailingCells = false;
1174         boolean rebuild = cellNeedsLayout  ||
1175                 isVertical != lastVertical ||
1176                 cells.isEmpty()            ||
1177                 getMaxPrefBreadth() == -1  ||
1178                 position != lastPosition   ||
1179                 cellCount != lastCellCount ||
1180                 hasSizeChange ||
1181                 (isVertical &amp;&amp; height &lt; lastHeight) || (! isVertical &amp;&amp; width &lt; lastWidth);
1182 
1183         if (!rebuild) {
1184             // Check if maxPrefBreadth didn&#39;t change
1185             double maxPrefBreadth = getMaxPrefBreadth();
1186             boolean foundMax = false;
1187             for (int i = 0; i &lt; cells.size(); ++i) {
1188                 double breadth = getCellBreadth(cells.get(i));
1189                 if (maxPrefBreadth == breadth) {
1190                     foundMax = true;
1191                 } else if (breadth &gt; maxPrefBreadth) {
1192                     rebuild = true;
1193                     break;
1194                 }
1195             }
1196             if (!foundMax) { // All values were lower
1197                 rebuild = true;
1198             }
1199         }
1200 
1201         if (! rebuild) {
1202             if ((isVertical &amp;&amp; height &gt; lastHeight) || (! isVertical &amp;&amp; width &gt; lastWidth)) {
1203                 // resized in the virtual direction
1204                 needTrailingCells = true;
1205             }
1206         }
1207 
1208         initViewport();
1209 
1210         // Get the index of the &quot;current&quot; cell
1211         int currentIndex = computeCurrentIndex();
1212         if (lastCellCount != cellCount) {
1213             // The cell count has changed. We want to keep the viewport
1214             // stable if possible. If position was 0 or 1, we want to keep
1215             // the position in the same place. If the new cell count is &gt;=
1216             // the currentIndex, then we will adjust the position to be 1.
1217             // Otherwise, our goal is to leave the index of the cell at the
1218             // top consistent, with the same translation etc.
1219             if (position == 0 || position == 1) {
1220                 // Update the item count
1221 //                setItemCount(cellCount);
1222             } else if (currentIndex &gt;= cellCount) {
1223                 setPosition(1.0f);
1224 //                setItemCount(cellCount);
1225             } else if (firstCell != null) {
1226                 double firstCellOffset = getCellPosition(firstCell);
1227                 int firstCellIndex = getCellIndex(firstCell);
1228 //                setItemCount(cellCount);
1229                 adjustPositionToIndex(firstCellIndex);
1230                 double viewportTopToCellTop = -computeOffsetForCell(firstCellIndex);
1231                 adjustByPixelAmount(viewportTopToCellTop - firstCellOffset);
1232             }
1233 
1234             // Update the current index
1235             currentIndex = computeCurrentIndex();
1236         }
1237 
1238         if (rebuild) {
1239             setMaxPrefBreadth(-1);
1240             // Start by dumping all the cells into the pile
1241             addAllToPile();
1242 
1243             // The distance from the top of the viewport to the top of the
1244             // cell for the current index.
1245             double offset = -computeViewportOffset(getPosition());
1246 
1247             // Add all the leading and trailing cells (the call to add leading
1248             // cells will add the current cell as well -- that is, the one that
1249             // represents the current position on the mapper).
1250             addLeadingCells(currentIndex, offset);
1251 
1252             // Force filling of space with empty cells if necessary
1253             addTrailingCells(true);
1254         } else if (needTrailingCells) {
1255             addTrailingCells(true);
1256         }
1257 
1258         computeBarVisiblity();
1259 
1260         recreatedOrRebuilt = recreatedOrRebuilt || rebuild;
1261         updateScrollBarsAndCells(recreatedOrRebuilt);
1262 
1263         lastWidth = getWidth();
1264         lastHeight = getHeight();
1265         lastCellCount = getCellCount();
1266         lastVertical = isVertical();
1267         lastPosition = getPosition();
1268 
1269         cleanPile();
1270     }
1271 
1272     /** {@inheritDoc} */
1273     @Override protected void setWidth(double value) {
1274         if (value != lastWidth) {
1275             super.setWidth(value);
1276             sizeChanged = true;
1277             setNeedsLayout(true);
1278             requestLayout();
1279         }
1280     }
1281 
1282     /** {@inheritDoc} */
1283     @Override protected void setHeight(double value) {
1284         if (value != lastHeight) {
1285             super.setHeight(value);
1286             sizeChanged = true;
1287             setNeedsLayout(true);
1288             requestLayout();
1289         }
1290     }
1291 
1292     /**
1293      * Get a cell which can be used in the layout. This function will reuse
1294      * cells from the pile where possible, and will create new cells when
1295      * necessary.
1296      * @param prefIndex the preferred index
1297      * @return the available cell
1298      */
1299     protected T getAvailableCell(int prefIndex) {
1300         T cell = null;
1301 
1302         // Fix for RT-12822. We try to retrieve the cell from the pile rather
1303         // than just grab a random cell from the pile (or create another cell).
1304         for (int i = 0, max = pile.size(); i &lt; max; i++) {
1305             T _cell = pile.get(i);
1306             assert _cell != null;
1307 
1308             if (getCellIndex(_cell) == prefIndex) {
1309                 cell = _cell;
1310                 pile.remove(i);
1311                 break;
1312             }
1313         }
1314 
1315         if (cell == null &amp;&amp; !pile.isEmpty()) {
1316             cell = pile.removeLast();
1317         }
1318 
1319         if (cell == null) {
1320             cell = getCellFactory().call(this);
1321             cell.getProperties().put(NEW_CELL, null);
1322         }
1323 
1324         if (cell.getParent() == null) {
1325             sheetChildren.add(cell);
1326         }
1327 
1328         return cell;
1329     }
1330 
1331     /**
1332      * This method will remove all cells from the VirtualFlow and remove them,
1333      * adding them to the &#39;pile&#39; (that is, a place from where cells can be used
1334      * at a later date). This method is protected to allow subclasses to clean up
1335      * appropriately.
1336      */
1337     protected void addAllToPile() {
1338         for (int i = 0, max = cells.size(); i &lt; max; i++) {
1339             addToPile(cells.removeFirst());
1340         }
1341     }
1342 
1343     /**
1344      * Gets a cell for the given index if the cell has been created and laid out.
1345      * &quot;Visible&quot; is a bit of a misnomer, the cell might not be visible in the
1346      * viewport (it may be clipped), but does distinguish between cells that
1347      * have been created and are in use vs. those that are in the pile or
1348      * not created.
1349      * @param index the index
1350      * @return the visible cell
1351      */
1352     public T getVisibleCell(int index) {
1353         if (cells.isEmpty()) return null;
1354 
1355         // check the last index
1356         T lastCell = cells.getLast();
1357         int lastIndex = getCellIndex(lastCell);
1358         if (index == lastIndex) return lastCell;
1359 
1360         // check the first index
1361         T firstCell = cells.getFirst();
1362         int firstIndex = getCellIndex(firstCell);
1363         if (index == firstIndex) return firstCell;
1364 
1365         // if index is &gt; firstIndex and &lt; lastIndex then we can get the index
1366         if (index &gt; firstIndex &amp;&amp; index &lt; lastIndex) {
1367             T cell = cells.get(index - firstIndex);
1368             if (getCellIndex(cell) == index) return cell;
1369         }
1370 
1371         // there is no visible cell for the specified index
1372         return null;
1373     }
1374 
1375     /**
1376      * Locates and returns the last non-empty IndexedCell that is currently
1377      * partially or completely visible. This function may return null if there
1378      * are no cells, or if the viewport length is 0.
1379      * @return the last visible cell
1380      */
1381     public T getLastVisibleCell() {
1382         if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
1383 
1384         T cell;
1385         for (int i = cells.size() - 1; i &gt;= 0; i--) {
1386             cell = cells.get(i);
1387             if (! cell.isEmpty()) {
1388                 return cell;
1389             }
1390         }
1391 
1392         return null;
1393     }
1394 
1395     /**
1396      * Locates and returns the first non-empty IndexedCell that is partially or
1397      * completely visible. This really only ever returns null if there are no
1398      * cells or the viewport length is 0.
1399      * @return the first visible cell
1400      */
1401     public T getFirstVisibleCell() {
1402         if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
1403         T cell = cells.getFirst();
1404         return cell.isEmpty() ? null : cell;
1405     }
1406 
1407     /**
1408      * Adjust the position of cells so that the specified cell
1409      * will be positioned at the start of the viewport. The given cell must
1410      * already be &quot;live&quot;.
1411      * @param firstCell the first cell
1412      */
1413     public void scrollToTop(T firstCell) {
1414         if (firstCell != null) {
1415             scrollPixels(getCellPosition(firstCell));
1416         }
1417     }
1418 
1419     /**
1420      * Adjust the position of cells so that the specified cell
1421      * will be positioned at the end of the viewport. The given cell must
1422      * already be &quot;live&quot;.
1423      * @param lastCell the last cell
1424      */
1425     public void scrollToBottom(T lastCell) {
1426         if (lastCell != null) {
1427             scrollPixels(getCellPosition(lastCell) + getCellLength(lastCell) - getViewportLength());
1428         }
1429     }
1430 
1431     /**
1432      * Adjusts the cells such that the selected cell will be fully visible in
1433      * the viewport (but only just).
1434      * @param cell the cell
1435      */
1436     public void scrollTo(T cell) {
1437         if (cell != null) {
1438             final double start = getCellPosition(cell);
1439             final double length = getCellLength(cell);
1440             final double end = start + length;
1441             final double viewportLength = getViewportLength();
1442 
1443             if (start &lt; 0) {
1444                 scrollPixels(start);
1445             } else if (end &gt; viewportLength) {
1446                 scrollPixels(end - viewportLength);
1447             }
1448         }
1449     }
1450 
1451     /**
1452      * Adjusts the cells such that the cell in the given index will be fully visible in
1453      * the viewport.
1454      * @param index the index
1455      */
1456     public void scrollTo(int index) {
1457         T cell = getVisibleCell(index);
1458         if (cell != null) {
1459             scrollTo(cell);
1460         } else {
1461             // see JDK-8197536
1462             if (tryScrollOneCell(index, true)) {
1463                 return;
1464             } else if (tryScrollOneCell(index, false)) {
1465                 return;
1466             }
1467 
1468             adjustPositionToIndex(index);
1469             addAllToPile();
1470             requestLayout();
1471         }
1472     }
1473 
1474     // will return true if scroll is successful
1475     private boolean tryScrollOneCell(int targetIndex, boolean downOrRight) {
1476         // if going down, cell diff is -1, because it will get the target cell index and check if previous
1477         // cell is visible to base the position
1478         int indexDiff = downOrRight ? -1 : 1;
1479 
1480         T targetCell = getVisibleCell(targetIndex + indexDiff);
1481         if (targetCell != null) {
1482             T cell = getAvailableCell(targetIndex);
1483             setCellIndex(cell, targetIndex);
1484             resizeCell(cell);
1485             setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
1486             cell.setVisible(true);
1487             if (downOrRight) {
1488                 cells.addLast(cell);
1489                 scrollPixels(getCellLength(cell));
1490             } else {
1491                 // up or left
1492                 cells.addFirst(cell);
1493                 scrollPixels(-getCellLength(cell));
1494             }
1495             return true;
1496         }
1497 
1498         return false;
1499     }
1500 
1501     /**
1502      * Adjusts the cells such that the cell in the given index will be fully visible in
1503      * the viewport, and positioned at the very top of the viewport.
1504      * @param index the index
1505      */
1506     public void scrollToTop(int index) {
1507         boolean posSet = false;
1508 
1509         if (index &gt;= getCellCount() - 1) {
1510             setPosition(1);
1511             posSet = true;
1512         } else if (index &lt; 0) {
1513             setPosition(0);
1514             posSet = true;
1515         }
1516 
1517         if (! posSet) {
1518             adjustPositionToIndex(index);
1519             double offset = - computeOffsetForCell(index);
1520             adjustByPixelAmount(offset);
1521         }
1522 
1523         requestLayout();
1524     }
1525 
1526 //    //TODO We assume all the cell have the same length.  We will need to support
1527 //    // cells of different lengths.
1528 //    public void scrollToOffset(int offset) {
1529 //        scrollPixels(offset * getCellLength(0));
1530 //    }
1531 
1532     /**
1533      * Given a delta value representing a number of pixels, this method attempts
1534      * to move the VirtualFlow in the given direction (positive is down/right,
1535      * negative is up/left) the given number of pixels. It returns the number of
1536      * pixels actually moved.
1537      * @param delta the delta value
1538      * @return the number of pixels actually moved
1539      */
1540     public double scrollPixels(final double delta) {
1541         // Short cut this method for cases where nothing should be done
1542         if (delta == 0) return 0;
1543 
1544         final boolean isVertical = isVertical();
1545         if (((isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !vbar.isVisible())) ||
1546                 (! isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !hbar.isVisible())))) return 0;
1547 
1548         double pos = getPosition();
1549         if (pos == 0.0f &amp;&amp; delta &lt; 0) return 0;
1550         if (pos == 1.0f &amp;&amp; delta &gt; 0) return 0;
1551 
1552         adjustByPixelAmount(delta);
1553         if (pos == getPosition()) {
1554             // The pos hasn&#39;t changed, there&#39;s nothing to do. This is likely
1555             // to occur when we hit either extremity
1556             return 0;
1557         }
1558 
1559         // Now move stuff around. Translating by pixels fundamentally means
1560         // moving the cells by the delta. However, after having
1561         // done that, we need to go through the cells and see which cells,
1562         // after adding in the translation factor, now fall off the viewport.
1563         // Also, we need to add cells as appropriate to the end (or beginning,
1564         // depending on the direction of travel).
1565         //
1566         // One simplifying assumption (that had better be true!) is that we
1567         // will only make it this far in the function if the virtual scroll
1568         // bar is visible. Otherwise, we never will pixel scroll. So as we go,
1569         // if we find that the maxPrefBreadth exceeds the viewportBreadth,
1570         // then we will be sure to show the breadthBar and update it
1571         // accordingly.
1572         if (cells.size() &gt; 0) {
1573             for (int i = 0; i &lt; cells.size(); i++) {
1574                 T cell = cells.get(i);
1575                 assert cell != null;
1576                 positionCell(cell, getCellPosition(cell) - delta);
1577             }
1578 
1579             // Fix for RT-32908
1580             T firstCell = cells.getFirst();
1581             double layoutY = firstCell == null ? 0 : getCellPosition(firstCell);
1582             for (int i = 0; i &lt; cells.size(); i++) {
1583                 T cell = cells.get(i);
1584                 assert cell != null;
1585                 double actualLayoutY = getCellPosition(cell);
1586                 if (Math.abs(actualLayoutY - layoutY) &gt; 0.001) {
1587                     // we need to shift the cell to layoutY
1588                     positionCell(cell, layoutY);
1589                 }
1590 
1591                 layoutY += getCellLength(cell);
1592             }
1593             // end of fix for RT-32908
1594             cull();
1595             firstCell = cells.getFirst();
1596 
1597             // Add any necessary leading cells
1598             if (firstCell != null) {
1599                 int firstIndex = getCellIndex(firstCell);
1600                 double prevIndexSize = getCellLength(firstIndex - 1);
1601                 addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
1602             } else {
1603                 int currentIndex = computeCurrentIndex();
1604 
1605                 // The distance from the top of the viewport to the top of the
1606                 // cell for the current index.
1607                 double offset = -computeViewportOffset(getPosition());
1608 
1609                 // Add all the leading and trailing cells (the call to add leading
1610                 // cells will add the current cell as well -- that is, the one that
1611                 // represents the current position on the mapper).
1612                 addLeadingCells(currentIndex, offset);
1613             }
1614 
1615             // Starting at the tail of the list, loop adding cells until
1616             // all the space on the table is filled up. We want to make
1617             // sure that we DO NOT add empty trailing cells (since we are
1618             // in the full virtual case and so there are no trailing empty
1619             // cells).
1620             if (! addTrailingCells(false)) {
1621                 // Reached the end, but not enough cells to fill up to
1622                 // the end. So, remove the trailing empty space, and translate
1623                 // the cells down
1624                 final T lastCell = getLastVisibleCell();
1625                 final double lastCellSize = getCellLength(lastCell);
1626                 final double cellEnd = getCellPosition(lastCell) + lastCellSize;
1627                 final double viewportLength = getViewportLength();
1628 
1629                 if (cellEnd &lt; viewportLength) {
1630                     // Reposition the nodes
1631                     double emptySize = viewportLength - cellEnd;
1632                     for (int i = 0; i &lt; cells.size(); i++) {
1633                         T cell = cells.get(i);
1634                         positionCell(cell, getCellPosition(cell) + emptySize);
1635                     }
1636                     setPosition(1.0f);
1637                     // fill the leading empty space
1638                     firstCell = cells.getFirst();
1639                     int firstIndex = getCellIndex(firstCell);
1640                     double prevIndexSize = getCellLength(firstIndex - 1);
1641                     addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
1642                 }
1643             }
1644         }
1645 
1646         // Now throw away any cells that don&#39;t fit
1647         cull();
1648 
1649         // Finally, update the scroll bars
1650         updateScrollBarsAndCells(false);
1651         lastPosition = getPosition();
1652 
1653         // notify
1654         return delta; // TODO fake
1655     }
1656 
1657     /** {@inheritDoc} */
1658     @Override protected double computePrefWidth(double height) {
1659         double w = isVertical() ? getPrefBreadth(height) : getPrefLength();
1660         return w + vbar.prefWidth(-1);
1661     }
1662 
1663     /** {@inheritDoc} */
1664     @Override protected double computePrefHeight(double width) {
1665         double h = isVertical() ? getPrefLength() : getPrefBreadth(width);
1666         return h + hbar.prefHeight(-1);
1667     }
1668 
1669     /**
1670      * Return a cell for the given index. This may be called for any cell,
1671      * including beyond the range defined by cellCount, in which case an
1672      * empty cell will be returned. The returned value should not be stored for
1673      * any reason.
1674      * @param index the index
1675      * @return the cell
1676      */
1677     public T getCell(int index) {
1678         // If there are cells, then we will attempt to get an existing cell
1679         if (! cells.isEmpty()) {
1680             // First check the cells that have already been created and are
1681             // in use. If this call returns a value, then we can use it
1682             T cell = getVisibleCell(index);
1683             if (cell != null) return cell;
1684         }
1685 
1686         // check the pile
1687         for (int i = 0; i &lt; pile.size(); i++) {
1688             T cell = pile.get(i);
1689             if (getCellIndex(cell) == index) {
1690                 // Note that we don&#39;t remove from the pile: if we do it leads
1691                 // to a severe performance decrease. This seems to be OK, as
1692                 // getCell() is only used for cell measurement purposes.
1693                 // pile.remove(i);
1694                 return cell;
1695             }
1696         }
1697 
1698         if (pile.size() &gt; 0) {
1699             return pile.get(0);
1700         }
1701 
1702         // We need to use the accumCell and return that
1703         if (accumCell == null) {
1704             Callback&lt;VirtualFlow&lt;T&gt;,T&gt; cellFactory = getCellFactory();
1705             if (cellFactory != null) {
1706                 accumCell = cellFactory.call(this);
1707                 accumCell.getProperties().put(NEW_CELL, null);
1708                 accumCellParent.getChildren().setAll(accumCell);
1709 
1710                 // Note the screen reader will attempt to find all
1711                 // the items inside the view to calculate the item count.
1712                 // Having items under different parents (sheet and accumCellParent)
1713                 // leads the screen reader to compute wrong values.
1714                 // The regular scheme to provide items to the screen reader
1715                 // uses getPrivateCell(), which places the item in the sheet.
1716                 // The accumCell, and its children, should be ignored by the
1717                 // screen reader.
1718                 accumCell.setAccessibleRole(AccessibleRole.NODE);
1719                 accumCell.getChildrenUnmodifiable().addListener((Observable c) -&gt; {
1720                     for (Node n : accumCell.getChildrenUnmodifiable()) {
1721                         n.setAccessibleRole(AccessibleRole.NODE);
1722                     }
1723                 });
1724             }
1725         }
1726         setCellIndex(accumCell, index);
1727         resizeCell(accumCell);
1728         return accumCell;
1729     }
1730 
1731     /**
1732      * The VirtualFlow uses this method to set a cells index (rather than calling
1733      * {@link IndexedCell#updateIndex(int)} directly), so it is a perfect place
1734      * for subclasses to override if this if of interest.
1735      *
1736      * @param cell The cell whose index will be updated.
1737      * @param index The new index for the cell.
1738      */
1739     protected void setCellIndex(T cell, int index) {
1740         assert cell != null;
1741 
1742         cell.updateIndex(index);
1743 
1744         // make sure the cell is sized correctly. This is important for both
1745         // general layout of cells in a VirtualFlow, but also in cases such as
1746         // RT-34333, where the sizes were being reported incorrectly to the
1747         // ComboBox popup.
1748         if ((cell.isNeedsLayout() &amp;&amp; cell.getScene() != null) || cell.getProperties().containsKey(NEW_CELL)) {
1749             cell.applyCss();
1750             cell.getProperties().remove(NEW_CELL);
1751         }
1752     }
1753 
1754     /**
1755      * Return the index for a given cell. This allows subclasses to customise
1756      * how cell indices are retrieved.
1757      * @param cell the cell
1758      * @return the index
1759      */
1760     protected int getCellIndex(T cell){
1761         return cell.getIndex();
1762     }
1763 
1764 
1765 
1766     /***************************************************************************
1767      *                                                                         *
1768      * Private implementation                                                  *
1769      *                                                                         *
1770      **************************************************************************/
1771 
1772     /**
1773      * Returns the scroll bar used for scrolling horizontally. A developer who needs to be notified when a scroll is
1774      * happening could attach a listener to the {@link ScrollBar#valueProperty()}.
1775      *
1776      * @return the scroll bar used for scrolling horizontally
1777      * @since 12
1778      */
1779     protected final ScrollBar getHbar() {
1780         return hbar;
1781     }
1782 
1783     /**
1784      * Returns the scroll bar used for scrolling vertically. A developer who needs to be notified when a scroll is
1785      * happening could attach a listener to the {@link ScrollBar#valueProperty()}. The {@link ScrollBar#getWidth()} is
1786      * also useful when adding a component over the {@code TableView} in order to clip it so that it doesn&#39;t overlap the
1787      * {@code ScrollBar}.
1788      *
1789      * @return the scroll bar used for scrolling vertically
1790      * @since 12
1791      */
1792     protected final ScrollBar getVbar() {
1793         return vbar;
1794     }
1795 
1796     /**
1797      * The maximum preferred size in the non-virtual direction. For example,
1798      * if vertical, then this is the max pref width of all cells encountered.
1799      * &lt;p&gt;
1800      * In general, this is the largest preferred size in the non-virtual
1801      * direction that we have ever encountered. We don&#39;t reduce this size
1802      * unless instructed to do so, so as to reduce the amount of scroll bar
1803      * jitter. The access on this variable is package ONLY FOR TESTING.
1804      */
1805     private double maxPrefBreadth;
1806     private final void setMaxPrefBreadth(double value) {
1807         this.maxPrefBreadth = value;
1808     }
1809     final double getMaxPrefBreadth() {
1810         return maxPrefBreadth;
1811     }
1812 
1813     /**
1814      * The breadth of the viewport portion of the VirtualFlow as computed during
1815      * the layout pass. In a vertical flow this would be the same as the clip
1816      * view width. In a horizontal flow this is the clip view height.
1817      * The access on this variable is package ONLY FOR TESTING.
1818      */
1819     private double viewportBreadth;
1820     private final void setViewportBreadth(double value) {
1821         this.viewportBreadth = value;
1822     }
1823     private final double getViewportBreadth() {
1824         return viewportBreadth;
1825     }
1826 
1827     /**
1828      * The length of the viewport portion of the VirtualFlow as computed
1829      * during the layout pass. In a vertical flow this would be the same as the
1830      * clip view height. In a horizontal flow this is the clip view width.
1831      * The access on this variable is package ONLY FOR TESTING.
1832      */
1833     private double viewportLength;
1834     void setViewportLength(double value) {
1835         this.viewportLength = value;
1836     }
1837     double getViewportLength() {
1838         return viewportLength;
1839     }
1840 
1841     /**
1842      * Compute and return the length of the cell for the given index. This is
1843      * called both internally when adjusting by pixels, and also at times
1844      * by PositionMapper (see the getItemSize callback). When called by
1845      * PositionMapper, it is possible that it will be called for some index
1846      * which is not associated with any cell, so we have to do a bit of work
1847      * to use a cell as a helper for computing cell size in some cases.
1848      */
1849     double getCellLength(int index) {
1850         if (fixedCellSizeEnabled) return getFixedCellSize();
1851 
1852         T cell = getCell(index);
1853         double length = getCellLength(cell);
1854         releaseCell(cell);
1855         return length;
1856     }
1857 
1858     /**
1859      */
1860     double getCellBreadth(int index) {
1861         T cell = getCell(index);
1862         double b = getCellBreadth(cell);
1863         releaseCell(cell);
1864         return b;
1865     }
1866 
1867     /**
1868      * Gets the length of a specific cell
1869      */
1870     double getCellLength(T cell) {
1871         if (cell == null) return 0;
1872         if (fixedCellSizeEnabled) return getFixedCellSize();
1873 
1874         return isVertical() ?
1875                 cell.getLayoutBounds().getHeight()
1876                 : cell.getLayoutBounds().getWidth();
1877     }
1878 
1879     /**
1880      * Gets the breadth of a specific cell
1881      */
1882     double getCellBreadth(Cell cell) {
1883         return isVertical() ?
1884                 cell.prefWidth(-1)
1885                 : cell.prefHeight(-1);
1886     }
1887 
1888     /**
1889      * Gets the layout position of the cell along the length axis
1890      */
1891     double getCellPosition(T cell) {
1892         if (cell == null) return 0;
1893 
1894         return isVertical() ?
1895                 cell.getLayoutY()
1896                 : cell.getLayoutX();
1897     }
1898 
1899     private void positionCell(T cell, double position) {
1900         if (isVertical()) {
1901             cell.setLayoutX(0);
1902             cell.setLayoutY(snapSizeY(position));
1903         } else {
1904             cell.setLayoutX(snapSizeX(position));
1905             cell.setLayoutY(0);
1906         }
1907     }
1908 
1909     /**
1910      * Resizes the given cell. If {@link #isVertical()} is set to {@code true}, the cell width will be the maximum
1911      * between the viewport width and the sum of all the cells&#39; {@code prefWidth}. The cell height will be computed by
1912      * the cell itself unless {@code fixedCellSizeEnabled} is set to {@code true}, then {@link #getFixedCellSize()} is
1913      * used. If {@link #isVertical()} is set to {@code false}, the width and height calculations are reversed.
1914      *
1915      * @param cell the cell to resize
1916      * @since 12
1917      */
1918     protected void resizeCell(T cell) {
1919         if (cell == null) return;
1920 
1921         if (isVertical()) {
1922             double width = Math.max(getMaxPrefBreadth(), getViewportBreadth());
1923             cell.resize(width, fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefHeight(width), cell.minHeight(width), cell.maxHeight(width)));
1924         } else {
1925             double height = Math.max(getMaxPrefBreadth(), getViewportBreadth());
1926             cell.resize(fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefWidth(height), cell.minWidth(height), cell.maxWidth(height)), height);
1927         }
1928     }
1929 
1930     /**
1931      * Returns the list of cells displayed in the current viewport.
1932      * &lt;p&gt;
1933      * The cells are ordered such that the first cell in this list is the first in the view, and the last cell is the
1934      * last in the view. When pixel scrolling, the list is simply shifted and items drop off the beginning or the end,
1935      * depending on the order of scrolling.
1936      *
1937      * @return the cells displayed in the current viewport
1938      * @since 12
1939      */
1940     protected List&lt;T&gt; getCells() {
1941         return cells;
1942     }
1943 
1944     /**
1945      * Returns the last visible cell whose bounds are entirely within the viewport. When manually inserting rows, one
1946      * may need to know which cell indices are visible in the viewport.
1947      *
1948      * @return last visible cell whose bounds are entirely within the viewport
1949      * @since 12
1950      */
1951     protected T getLastVisibleCellWithinViewport() {
1952         if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
1953 
1954         T cell;
1955         final double max = getViewportLength();
1956         for (int i = cells.size() - 1; i &gt;= 0; i--) {
1957             cell = cells.get(i);
1958             if (cell.isEmpty()) continue;
1959 
1960             final double cellStart = getCellPosition(cell);
1961             final double cellEnd = cellStart + getCellLength(cell);
1962 
1963             // we use the magic +2 to allow for a little bit of fuzziness,
1964             // this is to help in situations such as RT-34407
1965             if (cellEnd &lt;= (max + 2)) {
1966                 return cell;
1967             }
1968         }
1969 
1970         return null;
1971     }
1972 
1973     /**
1974      * Returns the first visible cell whose bounds are entirely within the viewport. When manually inserting rows, one
1975      * may need to know which cell indices are visible in the viewport.
1976      *
1977      * @return first visible cell whose bounds are entirely within the viewport
1978      * @since 12
1979      */
1980     protected T getFirstVisibleCellWithinViewport() {
1981         if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
1982 
1983         T cell;
1984         for (int i = 0; i &lt; cells.size(); i++) {
1985             cell = cells.get(i);
1986             if (cell.isEmpty()) continue;
1987 
1988             final double cellStart = getCellPosition(cell);
1989             if (cellStart &gt;= 0) {
1990                 return cell;
1991             }
1992         }
1993 
1994         return null;
1995     }
1996 
1997     /**
1998      * Adds all the cells prior to and including the given currentIndex, until
1999      * no more can be added without falling off the flow. The startOffset
2000      * indicates the distance from the leading edge (top) of the viewport to
2001      * the leading edge (top) of the currentIndex.
2002      */
2003     void addLeadingCells(int currentIndex, double startOffset) {
2004         // The offset will keep track of the distance from the top of the
2005         // viewport to the top of the current index. We will increment it
2006         // as we lay out leading cells.
2007         double offset = startOffset;
2008         // The index is the absolute index of the cell being laid out
2009         int index = currentIndex;
2010 
2011         // Offset should really be the bottom of the current index
2012         boolean first = true; // first time in, we just fudge the offset and let
2013         // it be the top of the current index then redefine
2014         // it as the bottom of the current index thereafter
2015         // while we have not yet laid out so many cells that they would fall
2016         // off the flow, we will continue to create and add cells. The
2017         // offset is our indication of whether we can lay out additional
2018         // cells. If the offset is ever &lt; 0, except in the case of the very
2019         // first cell, then we must quit.
2020         T cell = null;
2021 
2022         // special case for the position == 1.0, skip adding last invisible cell
2023         if (index == getCellCount() &amp;&amp; offset == getViewportLength()) {
2024             index--;
2025             first = false;
2026         }
2027         while (index &gt;= 0 &amp;&amp; (offset &gt; 0 || first)) {
2028             cell = getAvailableCell(index);
2029             setCellIndex(cell, index);
2030             resizeCell(cell); // resize must be after config
2031             cells.addFirst(cell);
2032 
2033             // A little gross but better than alternatives because it reduces
2034             // the number of times we have to update a cell or compute its
2035             // size. The first time into this loop &quot;offset&quot; is actually the
2036             // top of the current index. On all subsequent visits, it is the
2037             // bottom of the current index.
2038             if (first) {
2039                 first = false;
2040             } else {
2041                 offset -= getCellLength(cell);
2042             }
2043 
2044             // Position the cell, and update the maxPrefBreadth variable as we go.
2045             positionCell(cell, offset);
2046             setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
2047             cell.setVisible(true);
2048             --index;
2049         }
2050 
2051         // There are times when after laying out the cells we discover that
2052         // the top of the first cell which represents index 0 is below the top
2053         // of the viewport. In these cases, we have to adjust the cells up
2054         // and reset the mapper position. This might happen when items got
2055         // removed at the top or when the viewport size increased.
2056         if (cells.size() &gt; 0) {
2057             cell = cells.getFirst();
2058             int firstIndex = getCellIndex(cell);
2059             double firstCellPos = getCellPosition(cell);
2060             if (firstIndex == 0 &amp;&amp; firstCellPos &gt; 0) {
2061                 setPosition(0.0f);
2062                 offset = 0;
2063                 for (int i = 0; i &lt; cells.size(); i++) {
2064                     cell = cells.get(i);
2065                     positionCell(cell, offset);
2066                     offset += getCellLength(cell);
2067                 }
2068             }
2069         } else {
2070             // reset scrollbar to top, so if the flow sees cells again it starts at the top
2071             vbar.setValue(0);
2072             hbar.setValue(0);
2073         }
2074     }
2075 
2076     /**
2077      * Adds all the trailing cells that come &lt;em&gt;after&lt;/em&gt; the last index in
2078      * the cells ObservableList.
2079      */
2080     boolean addTrailingCells(boolean fillEmptyCells) {
2081         // If cells is empty then addLeadingCells bailed for some reason and
2082         // we&#39;re hosed, so just punt
2083         if (cells.isEmpty()) return false;
2084 
2085         // While we have not yet laid out so many cells that they would fall
2086         // off the flow, so we will continue to create and add cells. When the
2087         // offset becomes greater than the width/height of the flow, then we
2088         // know we cannot add any more cells.
2089         T startCell = cells.getLast();
2090         double offset = getCellPosition(startCell) + getCellLength(startCell);
2091         int index = getCellIndex(startCell) + 1;
2092         final int cellCount = getCellCount();
2093         boolean filledWithNonEmpty = index &lt;= cellCount;
2094 
2095         final double viewportLength = getViewportLength();
2096 
2097         // Fix for RT-37421, which was a regression caused by RT-36556
2098         if (offset &lt; 0 &amp;&amp; !fillEmptyCells) {
2099             return false;
2100         }
2101 
2102         //
2103         // RT-36507: viewportLength gives the maximum number of
2104         // additional cells that should ever be able to fit in the viewport if
2105         // every cell had a height of 1. If index ever exceeds this count,
2106         // then offset is not incrementing fast enough, or at all, which means
2107         // there is something wrong with the cell size calculation.
2108         //
2109         final double maxCellCount = viewportLength;
2110         while (offset &lt; viewportLength) {
2111             if (index &gt;= cellCount) {
2112                 if (offset &lt; viewportLength) filledWithNonEmpty = false;
2113                 if (! fillEmptyCells) return filledWithNonEmpty;
2114                 // RT-36507 - return if we&#39;ve exceeded the maximum
2115                 if (index &gt; maxCellCount) {
2116                     final PlatformLogger logger = Logging.getControlsLogger();
2117                     if (logger.isLoggable(PlatformLogger.Level.INFO)) {
2118                         logger.info(&quot;index exceeds maxCellCount. Check size calculations for &quot; + startCell.getClass());
2119                     }
2120                     return filledWithNonEmpty;
2121                 }
2122             }
2123             T cell = getAvailableCell(index);
2124             setCellIndex(cell, index);
2125             resizeCell(cell); // resize happens after config!
2126             cells.addLast(cell);
2127 
2128             // Position the cell and update the max pref
2129             positionCell(cell, offset);
2130             setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
2131 
2132             offset += getCellLength(cell);
2133             cell.setVisible(true);
2134             ++index;
2135         }
2136 
2137         // Discover whether the first cell coincides with index #0. If after
2138         // adding all the trailing cells we find that a) the first cell was
2139         // not index #0 and b) there are trailing cells, then we have a
2140         // problem. We need to shift all the cells down and add leading cells,
2141         // one at a time, until either the very last non-empty cells is aligned
2142         // with the bottom OR we have laid out cell index #0 at the first
2143         // position.
2144         T firstCell = cells.getFirst();
2145         index = getCellIndex(firstCell);
2146         T lastNonEmptyCell = getLastVisibleCell();
2147         double start = getCellPosition(firstCell);
2148         double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);
2149         if ((index != 0 || (index == 0 &amp;&amp; start &lt; 0)) &amp;&amp; fillEmptyCells &amp;&amp;
2150                 lastNonEmptyCell != null &amp;&amp; getCellIndex(lastNonEmptyCell) == cellCount - 1 &amp;&amp; end &lt; viewportLength) {
2151 
2152             double prospectiveEnd = end;
2153             double distance = viewportLength - end;
2154             while (prospectiveEnd &lt; viewportLength &amp;&amp; index != 0 &amp;&amp; (-start) &lt; distance) {
2155                 index--;
2156                 T cell = getAvailableCell(index);
2157                 setCellIndex(cell, index);
2158                 resizeCell(cell); // resize must be after config
2159                 cells.addFirst(cell);
2160                 double cellLength = getCellLength(cell);
2161                 start -= cellLength;
2162                 prospectiveEnd += cellLength;
2163                 positionCell(cell, start);
2164                 setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
2165                 cell.setVisible(true);
2166             }
2167 
2168             // The amount by which to translate the cells down
2169             firstCell = cells.getFirst();
2170             start = getCellPosition(firstCell);
2171             double delta = viewportLength - end;
2172             if (getCellIndex(firstCell) == 0 &amp;&amp; delta &gt; (-start)) {
2173                 delta = (-start);
2174             }
2175             // Move things
2176             for (int i = 0; i &lt; cells.size(); i++) {
2177                 T cell = cells.get(i);
2178                 positionCell(cell, getCellPosition(cell) + delta);
2179             }
2180 
2181             // Check whether the first cell, subsequent to our adjustments, is
2182             // now index #0 and aligned with the top. If so, change the position
2183             // to be at 0 instead of 1.
2184             start = getCellPosition(firstCell);
2185             if (getCellIndex(firstCell) == 0 &amp;&amp; start == 0) {
2186                 setPosition(0);
2187             } else if (getPosition() != 1) {
2188                 setPosition(1);
2189             }
2190         }
2191 
2192         return filledWithNonEmpty;
2193     }
2194 
2195     /**
2196      * Informs the {@code VirtualFlow} that a layout pass should be done, and the cell contents have not changed. For
2197      * example, this might be called from a {@code TableView} or {@code ListView} when a layout is needed and no cells
2198      * have been added or removed.
2199      *
2200      * @since 12
2201      */
2202     protected void reconfigureCells() {
2203         needsReconfigureCells = true;
2204         requestLayout();
2205     }
2206 
2207     /**
2208      * Informs the {@code VirtualFlow} that a layout pass should be done, and that the cell factory has changed. All
2209      * cells in the viewport are recreated with the new cell factory.
2210      *
2211      * @since 12
2212      */
2213     protected void recreateCells() {
2214         needsRecreateCells = true;
2215         requestLayout();
2216     }
2217 
2218     /**
2219      * Informs the {@code VirtualFlow} that a layout pass should be done, and cell contents have changed. All cells are
2220      * removed and then added properly in the viewport.
2221      *
2222      * @since 12
2223      */
2224     protected void rebuildCells() {
2225         needsRebuildCells = true;
2226         requestLayout();
2227     }
2228 
2229     /**
2230      * Informs the {@code VirtualFlow} that a layout pass should be done and only the cell layout will be requested.
2231      *
2232      * @since 12
2233      */
2234     protected void requestCellLayout() {
2235         needsCellsLayout = true;
2236         requestLayout();
2237     }
2238 
2239     void setCellDirty(int index) {
2240         dirtyCells.set(index);
2241         requestLayout();
2242     }
2243 
2244     private void startSBReleasedAnimation() {
2245         if (sbTouchTimeline == null) {
2246             /*
2247             ** timeline to leave the scrollbars visible for a short
2248             ** while after a scroll/drag
2249             */
2250             sbTouchTimeline = new Timeline();
2251             sbTouchKF1 = new KeyFrame(Duration.millis(0), event -&gt; {
2252                 tempVisibility = true;
2253                 requestLayout();
2254             });
2255 
2256             sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -&gt; {
2257                 if (touchDetected == false &amp;&amp; mouseDown == false) {
2258                     tempVisibility = false;
2259                     requestLayout();
2260                 }
2261             });
2262             sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);
2263         }
2264         sbTouchTimeline.playFromStart();
2265     }
2266 
2267     private void scrollBarOn() {
2268         tempVisibility = true;
2269         requestLayout();
2270     }
2271 
2272     void updateHbar() {
2273         if (! isVisible() || getScene() == null) return;
2274         // Bring the clipView.clipX back to 0 if control is vertical or
2275         // the hbar isn&#39;t visible (fix for RT-11666)
2276         if (isVertical()) {
2277             if (hbar.isVisible()) {
2278                 clipView.setClipX(hbar.getValue());
2279             } else {
2280                 // all cells are now less than the width of the flow,
2281                 // so we should shift the hbar/clip such that
2282                 // everything is visible in the viewport.
2283                 clipView.setClipX(0);
2284                 hbar.setValue(0);
2285             }
2286         }
2287     }
2288 
2289     /**
2290      * @return true if bar visibility changed
2291      */
2292     private boolean computeBarVisiblity() {
2293         if (cells.isEmpty()) {
2294             // In case no cells are set yet, we assume no bars are needed
2295             needLengthBar = false;
2296             needBreadthBar = false;
2297             return true;
2298         }
2299 
2300         final boolean isVertical = isVertical();
2301         boolean barVisibilityChanged = false;
2302 
2303         VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
2304         VirtualScrollBar lengthBar = isVertical ? vbar : hbar;
2305 
2306         final double viewportBreadth = getViewportBreadth();
2307 
2308         final int cellsSize = cells.size();
2309         final int cellCount = getCellCount();
2310         for (int i = 0; i &lt; 2; i++) {
2311             final boolean lengthBarVisible = getPosition() &gt; 0
2312                     || cellCount &gt; cellsSize
2313                     || (cellCount == cellsSize &amp;&amp; (getCellPosition(cells.getLast()) + getCellLength(cells.getLast())) &gt; getViewportLength())
2314                     || (cellCount == cellsSize - 1 &amp;&amp; barVisibilityChanged &amp;&amp; needBreadthBar);
2315 
2316             if (lengthBarVisible ^ needLengthBar) {
2317                 needLengthBar = lengthBarVisible;
2318                 barVisibilityChanged = true;
2319             }
2320 
2321             // second conditional removed for RT-36669.
2322             final boolean breadthBarVisible = (maxPrefBreadth &gt; viewportBreadth);// || (needLengthBar &amp;&amp; maxPrefBreadth &gt; (viewportBreadth - lengthBarBreadth));
2323             if (breadthBarVisible ^ needBreadthBar) {
2324                 needBreadthBar = breadthBarVisible;
2325                 barVisibilityChanged = true;
2326             }
2327         }
2328 
2329         // Start by optimistically deciding whether the length bar and
2330         // breadth bar are needed and adjust the viewport dimensions
2331         // accordingly. If during layout we find that one or the other of the
2332         // bars actually is needed, then we will perform a cleanup pass
2333 
2334         if (!Properties.IS_TOUCH_SUPPORTED) {
2335             updateViewportDimensions();
2336             breadthBar.setVisible(needBreadthBar);
2337             lengthBar.setVisible(needLengthBar);
2338         } else {
2339             breadthBar.setVisible(needBreadthBar &amp;&amp; tempVisibility);
2340             lengthBar.setVisible(needLengthBar &amp;&amp; tempVisibility);
2341         }
2342 
2343         return barVisibilityChanged;
2344     }
2345 
2346     private void updateViewportDimensions() {
2347         final boolean isVertical = isVertical();
2348         final double breadthBarLength = isVertical ? snapSizeY(hbar.prefHeight(-1)) : snapSizeX(vbar.prefWidth(-1));
2349         final double lengthBarBreadth = isVertical ? snapSizeX(vbar.prefWidth(-1)) : snapSizeY(hbar.prefHeight(-1));
2350 
2351         setViewportBreadth((isVertical ? getWidth() : getHeight()) - (needLengthBar ? lengthBarBreadth : 0));
2352         setViewportLength((isVertical ? getHeight() : getWidth()) - (needBreadthBar ? breadthBarLength : 0));
2353     }
2354 
2355     private void initViewport() {
2356         // Initialize the viewportLength and viewportBreadth to match the
2357         // width/height of the flow
2358         final boolean isVertical = isVertical();
2359 
2360         updateViewportDimensions();
2361 
2362         VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
2363         VirtualScrollBar lengthBar = isVertical ? vbar : hbar;
2364 
2365         // If there has been a switch between the virtualized bar, then we
2366         // will want to do some stuff TODO.
2367         breadthBar.setVirtual(false);
2368         lengthBar.setVirtual(true);
2369     }
2370 
2371     private void updateScrollBarsAndCells(boolean recreate) {
2372         // Assign the hbar and vbar to the breadthBar and lengthBar so as
2373         // to make some subsequent calculations easier.
2374         final boolean isVertical = isVertical();
2375         VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
2376         VirtualScrollBar lengthBar = isVertical ? vbar : hbar;
2377 
2378         // We may have adjusted the viewport length and breadth after the
2379         // layout due to scroll bars becoming visible. So we need to perform
2380         // a follow up pass and resize and shift all the cells to fit the
2381         // viewport. Note that the prospective viewport size is always &gt;= the
2382         // final viewport size, so we don&#39;t have to worry about adding
2383         // cells during this cleanup phase.
2384         fitCells();
2385 
2386         // Update cell positions.
2387         // When rebuilding the cells, we add the cells and along the way compute
2388         // the maxPrefBreadth. Based on the computed value, we may add
2389         // the breadth scrollbar which changes viewport length, so we need
2390         // to re-position the cells.
2391         if (!cells.isEmpty()) {
2392             final double currOffset = -computeViewportOffset(getPosition());
2393             final int currIndex = computeCurrentIndex() - cells.getFirst().getIndex();
2394             final int size = cells.size();
2395 
2396             // position leading cells
2397             double offset = currOffset;
2398 
2399             for (int i = currIndex - 1; i &gt;= 0 &amp;&amp; i &lt; size; i--) {
2400                 final T cell = cells.get(i);
2401 
2402                 offset -= getCellLength(cell);
2403 
2404                 positionCell(cell, offset);
2405             }
2406 
2407             // position trailing cells
2408             offset = currOffset;
2409             for (int i = currIndex; i &gt;= 0 &amp;&amp; i &lt; size; i++) {
2410                 final T cell = cells.get(i);
2411                 positionCell(cell, offset);
2412 
2413                 offset += getCellLength(cell);
2414             }
2415         }
2416 
2417         // Toggle visibility on the corner
2418         corner.setVisible(breadthBar.isVisible() &amp;&amp; lengthBar.isVisible());
2419 
2420         double sumCellLength = 0;
2421         double flowLength = (isVertical ? getHeight() : getWidth()) -
2422                 (breadthBar.isVisible() ? breadthBar.prefHeight(-1) : 0);
2423 
2424         final double viewportBreadth = getViewportBreadth();
2425         final double viewportLength = getViewportLength();
2426 
2427         // Now position and update the scroll bars
2428         if (breadthBar.isVisible()) {
2429             /*
2430             ** Positioning the ScrollBar
2431             */
2432             if (!Properties.IS_TOUCH_SUPPORTED) {
2433                 if (isVertical) {
2434                     hbar.resizeRelocate(0, viewportLength,
2435                             viewportBreadth, hbar.prefHeight(viewportBreadth));
2436                 } else {
2437                     vbar.resizeRelocate(viewportLength, 0,
2438                             vbar.prefWidth(viewportBreadth), viewportBreadth);
2439                 }
2440             }
2441             else {
2442                 if (isVertical) {
2443                     hbar.resizeRelocate(0, (viewportLength-hbar.getHeight()),
2444                             viewportBreadth, hbar.prefHeight(viewportBreadth));
2445                 } else {
2446                     vbar.resizeRelocate((viewportLength-vbar.getWidth()), 0,
2447                             vbar.prefWidth(viewportBreadth), viewportBreadth);
2448                 }
2449             }
2450 
2451             if (getMaxPrefBreadth() != -1) {
2452                 double newMax = Math.max(1, getMaxPrefBreadth() - viewportBreadth);
2453                 if (newMax != breadthBar.getMax()) {
2454                     breadthBar.setMax(newMax);
2455 
2456                     double breadthBarValue = breadthBar.getValue();
2457                     boolean maxed = breadthBarValue != 0 &amp;&amp; newMax == breadthBarValue;
2458                     if (maxed || breadthBarValue &gt; newMax) {
2459                         breadthBar.setValue(newMax);
2460                     }
2461 
2462                     breadthBar.setVisibleAmount((viewportBreadth / getMaxPrefBreadth()) * newMax);
2463                 }
2464             }
2465         }
2466 
2467         // determine how many cells there are on screen so that the scrollbar
2468         // thumb can be appropriately sized
2469         if (recreate &amp;&amp; (lengthBar.isVisible() || Properties.IS_TOUCH_SUPPORTED)) {
2470             final int cellCount = getCellCount();
2471             int numCellsVisibleOnScreen = 0;
2472             for (int i = 0, max = cells.size(); i &lt; max; i++) {
2473                 T cell = cells.get(i);
2474                 if (cell != null &amp;&amp; !cell.isEmpty()) {
2475                     sumCellLength += (isVertical ? cell.getHeight() : cell.getWidth());
2476                     if (sumCellLength &gt; flowLength) {
2477                         break;
2478                     }
2479 
2480                     numCellsVisibleOnScreen++;
2481                 }
2482             }
2483 
2484             lengthBar.setMax(1);
2485             if (numCellsVisibleOnScreen == 0 &amp;&amp; cellCount == 1) {
2486                 // special case to help resolve RT-17701 and the case where we have
2487                 // only a single row and it is bigger than the viewport
2488                 lengthBar.setVisibleAmount(flowLength / sumCellLength);
2489             } else {
2490                 lengthBar.setVisibleAmount(numCellsVisibleOnScreen / (float) cellCount);
2491             }
2492         }
2493 
2494         if (lengthBar.isVisible()) {
2495             // Fix for RT-11873. If this isn&#39;t here, we can have a situation where
2496             // the scrollbar scrolls endlessly. This is possible when the cell
2497             // count grows as the user hits the maximal position on the scrollbar
2498             // (i.e. the list size dynamically grows as the user needs more).
2499             //
2500             // This code was commented out to resolve RT-14477 after testing
2501             // whether RT-11873 can be recreated. It could not, and therefore
2502             // for now this code will remained uncommented until it is deleted
2503             // following further testing.
2504 //            if (lengthBar.getValue() == 1.0 &amp;&amp; lastCellCount != cellCount) {
2505 //                lengthBar.setValue(0.99);
2506 //            }
2507 
2508             /*
2509             ** Positioning the ScrollBar
2510             */
2511             if (!Properties.IS_TOUCH_SUPPORTED) {
2512                 if (isVertical) {
2513                     vbar.resizeRelocate(viewportBreadth, 0, vbar.prefWidth(viewportLength), viewportLength);
2514                 } else {
2515                     hbar.resizeRelocate(0, viewportBreadth, viewportLength, hbar.prefHeight(-1));
2516                 }
2517             }
2518             else {
2519                 if (isVertical) {
2520                     vbar.resizeRelocate((viewportBreadth-vbar.getWidth()), 0, vbar.prefWidth(viewportLength), viewportLength);
2521                 } else {
2522                     hbar.resizeRelocate(0, (viewportBreadth-hbar.getHeight()), viewportLength, hbar.prefHeight(-1));
2523                 }
2524             }
2525         }
2526 
2527         if (corner.isVisible()) {
2528             if (!Properties.IS_TOUCH_SUPPORTED) {
2529                 corner.resize(vbar.getWidth(), hbar.getHeight());
2530                 corner.relocate(hbar.getLayoutX() + hbar.getWidth(), vbar.getLayoutY() + vbar.getHeight());
2531             }
2532             else {
2533                 corner.resize(vbar.getWidth(), hbar.getHeight());
2534                 corner.relocate(hbar.getLayoutX() + (hbar.getWidth()-vbar.getWidth()), vbar.getLayoutY() + (vbar.getHeight()-hbar.getHeight()));
2535                 hbar.resize(hbar.getWidth()-vbar.getWidth(), hbar.getHeight());
2536                 vbar.resize(vbar.getWidth(), vbar.getHeight()-hbar.getHeight());
2537             }
2538         }
2539 
2540         clipView.resize(snapSizeX(isVertical ? viewportBreadth : viewportLength),
2541                         snapSizeY(isVertical ? viewportLength : viewportBreadth));
2542 
2543         // If the viewportLength becomes large enough that all cells fit
2544         // within the viewport, then we want to update the value to match.
2545         if (getPosition() != lengthBar.getValue()) {
2546             lengthBar.setValue(getPosition());
2547         }
2548     }
2549 
2550     /**
2551      * Adjusts the cells location and size if necessary. The breadths of all
2552      * cells will be adjusted to fit the viewportWidth or maxPrefBreadth, and
2553      * the layout position will be updated if necessary based on index and
2554      * offset.
2555      */
2556     private void fitCells() {
2557         double size = Math.max(getMaxPrefBreadth(), getViewportBreadth());
2558         boolean isVertical = isVertical();
2559 
2560         // Note: Do not optimise this loop by pre-calculating the cells size and
2561         // storing that into a int value - this can lead to RT-32828
2562         for (int i = 0; i &lt; cells.size(); i++) {
2563             Cell&lt;?&gt; cell = cells.get(i);
2564             if (isVertical) {
2565                 cell.resize(size, cell.prefHeight(size));
2566             } else {
2567                 cell.resize(cell.prefWidth(size), size);
2568             }
2569         }
2570     }
2571 
2572     private void cull() {
2573         final double viewportLength = getViewportLength();
2574         for (int i = cells.size() - 1; i &gt;= 0; i--) {
2575             T cell = cells.get(i);
2576             double cellSize = getCellLength(cell);
2577             double cellStart = getCellPosition(cell);
2578             double cellEnd = cellStart + cellSize;
2579             if (cellStart &gt;= viewportLength || cellEnd &lt; 0) {
2580                 addToPile(cells.remove(i));
2581             }
2582         }
2583     }
2584 
2585     /**
2586      * After using the accum cell, it needs to be released!
2587      */
2588     private void releaseCell(T cell) {
2589         if (accumCell != null &amp;&amp; cell == accumCell) {
2590             accumCell.updateIndex(-1);
2591         }
2592     }
2593 
2594 
2595     /**
2596      * Creates and returns a new cell for the given index.
2597      * &lt;p&gt;
2598      * If the requested index is not already an existing visible cell, it will create a cell for the given index and
2599      * insert it into the {@code VirtualFlow} container. If the index exists, simply returns the visible cell. From that
2600      * point on, it will be unmanaged, and is up to the caller of this method to manage it.
2601      * &lt;p&gt;
2602      * This is useful if a row that should not be visible must be accessed (a row that always stick to the top for
2603      * example). It can then be easily created, correctly initialized and inserted in the {@code VirtualFlow}
2604      * container.
2605      *
2606      * @param index the cell index
2607      * @return a cell for the given index inserted in the VirtualFlow container
2608      * @since 12
2609      */
2610     protected T getPrivateCell(int index)  {
2611         T cell = null;
2612 
2613         // If there are cells, then we will attempt to get an existing cell
2614         if (! cells.isEmpty()) {
2615             // First check the cells that have already been created and are
2616             // in use. If this call returns a value, then we can use it
2617             cell = getVisibleCell(index);
2618             if (cell != null) {
2619                 // Force the underlying text inside the cell to be updated
2620                 // so that when the screen reader runs, it will match the
2621                 // text in the cell (force updateDisplayedText())
2622                 cell.layout();
2623                 return cell;
2624             }
2625         }
2626 
2627         // check the existing sheet children
2628         if (cell == null) {
2629             for (int i = 0; i &lt; sheetChildren.size(); i++) {
2630                 T _cell = (T) sheetChildren.get(i);
2631                 if (getCellIndex(_cell) == index) {
2632                     return _cell;
2633                 }
2634             }
2635         }
2636 
2637         Callback&lt;VirtualFlow&lt;T&gt;, T&gt; cellFactory = getCellFactory();
2638         if (cellFactory != null) {
2639             cell = cellFactory.call(this);
2640         }
2641 
2642         if (cell != null) {
2643             setCellIndex(cell, index);
2644             resizeCell(cell);
2645             cell.setVisible(false);
2646             sheetChildren.add(cell);
2647             privateCells.add(cell);
2648         }
2649 
2650         return cell;
2651     }
2652 
2653     private final List&lt;T&gt; privateCells = new ArrayList&lt;&gt;();
2654 
2655     private void releaseAllPrivateCells() {
2656         sheetChildren.removeAll(privateCells);
2657         privateCells.clear();
2658     }
2659 
2660     /**
2661      * Puts the given cell onto the pile. This is called whenever a cell has
2662      * fallen off the flow&#39;s start.
2663      */
2664     private void addToPile(T cell) {
2665         assert cell != null;
2666         pile.addLast(cell);
2667     }
2668 
2669     private void cleanPile() {
2670         boolean wasFocusOwner = false;
2671 
2672         for (int i = 0, max = pile.size(); i &lt; max; i++) {
2673             T cell = pile.get(i);
2674             wasFocusOwner = wasFocusOwner || doesCellContainFocus(cell);
2675             cell.setVisible(false);
2676         }
2677 
2678         // Fix for RT-35876: Rather than have the cells do weird things with
2679         // focus (in particular, have focus jump between cells), we return focus
2680         // to the VirtualFlow itself.
2681         if (wasFocusOwner) {
2682             requestFocus();
2683         }
2684     }
2685 
2686     private boolean doesCellContainFocus(Cell&lt;?&gt; c) {
2687         Scene scene = c.getScene();
2688         final Node focusOwner = scene == null ? null : scene.getFocusOwner();
2689 
2690         if (focusOwner != null) {
2691             if (c.equals(focusOwner)) {
2692                 return true;
2693             }
2694 
2695             Parent p = focusOwner.getParent();
2696             while (p != null &amp;&amp; ! (p instanceof VirtualFlow)) {
2697                 if (c.equals(p)) {
2698                     return true;
2699                 }
2700                 p = p.getParent();
2701             }
2702         }
2703 
2704         return false;
2705     }
2706 
2707     private double getPrefBreadth(double oppDimension) {
2708         double max = getMaxCellWidth(10);
2709 
2710         // This primarily exists for the case where we do not want the breadth
2711         // to grow to ensure a golden ratio between width and height (for example,
2712         // when a ListView is used in a ComboBox - the width should not grow
2713         // just because items are being added to the ListView)
2714         if (oppDimension &gt; -1) {
2715             double prefLength = getPrefLength();
2716             max = Math.max(max, prefLength * GOLDEN_RATIO_MULTIPLIER);
2717         }
2718 
2719         return max;
2720     }
2721 
2722     private double getPrefLength() {
2723         double sum = 0.0;
2724         int rows = Math.min(10, getCellCount());
2725         for (int i = 0; i &lt; rows; i++) {
2726             sum += getCellLength(i);
2727         }
2728         return sum;
2729     }
2730 
2731     double getMaxCellWidth(int rowsToCount) {
2732         double max = 0.0;
2733 
2734         // we always measure at least one row
2735         int rows = Math.max(1, rowsToCount == -1 ? getCellCount() : rowsToCount);
2736         for (int i = 0; i &lt; rows; i++) {
2737             max = Math.max(max, getCellBreadth(i));
2738         }
2739         return max;
2740     }
2741 
2742     // Old PositionMapper
2743     /**
2744      * Given a position value between 0 and 1, compute and return the viewport
2745      * offset from the &quot;current&quot; cell associated with that position value.
2746      * That is, if the return value of this function where used as a translation
2747      * factor for a sheet that contained all the items, then the current
2748      * item would end up positioned correctly.
2749      */
2750     private double computeViewportOffset(double position) {
2751         double p = com.sun.javafx.util.Utils.clamp(0, position, 1);
2752         double fractionalPosition = p * getCellCount();
2753         int cellIndex = (int) fractionalPosition;
2754         double fraction = fractionalPosition - cellIndex;
2755         double cellSize = getCellLength(cellIndex);
2756         double pixelOffset = cellSize * fraction;
2757         double viewportOffset = getViewportLength() * p;
2758         return pixelOffset - viewportOffset;
2759     }
2760 
2761     private void adjustPositionToIndex(int index) {
2762         int cellCount = getCellCount();
2763         if (cellCount &lt;= 0) {
2764             setPosition(0.0f);
2765         } else {
2766             setPosition(((double)index) / cellCount);
2767         }
2768     }
2769 
2770     /**
2771      * Adjust the position based on a delta of pixels. If negative, then the
2772      * position will be adjusted negatively. If positive, then the position will
2773      * be adjusted positively. If the pixel amount is too great for the range of
2774      * the position, then it will be clamped such that position is always
2775      * strictly between 0 and 1
2776      */
2777     private void adjustByPixelAmount(double numPixels) {
2778         if (numPixels == 0) return;
2779         // Starting from the current cell, we move in the direction indicated
2780         // by numPixels one cell at a team. For each cell, we discover how many
2781         // pixels the &quot;position&quot; line would move within that cell, and adjust
2782         // our count of numPixels accordingly. When we come to the &quot;final&quot; cell,
2783         // then we can take the remaining number of pixels and multiply it by
2784         // the &quot;travel rate&quot; of &quot;p&quot; within that cell to get the delta. Add
2785         // the delta to &quot;p&quot; to get position.
2786 
2787         // get some basic info about the list and the current cell
2788         boolean forward = numPixels &gt; 0;
2789         int cellCount = getCellCount();
2790         double fractionalPosition = getPosition() * cellCount;
2791         int cellIndex = (int) fractionalPosition;
2792         if (forward &amp;&amp; cellIndex == cellCount) return;
2793         double cellSize = getCellLength(cellIndex);
2794         double fraction = fractionalPosition - cellIndex;
2795         double pixelOffset = cellSize * fraction;
2796 
2797         // compute the percentage of &quot;position&quot; that represents each cell
2798         double cellPercent = 1.0 / cellCount;
2799 
2800         // To help simplify the algorithm, we pretend as though the current
2801         // position is at the beginning of the current cell. This reduces some
2802         // of the corner cases and provides a simpler algorithm without adding
2803         // any overhead to performance.
2804         double start = computeOffsetForCell(cellIndex);
2805         double end = cellSize + computeOffsetForCell(cellIndex + 1);
2806 
2807         // We need to discover the distance that the fictional &quot;position line&quot;
2808         // would travel within this cell, from its current position to the end.
2809         double remaining = end - start;
2810 
2811         // Keep track of the number of pixels left to travel
2812         double n = forward ?
2813               numPixels + pixelOffset - (getViewportLength() * getPosition()) - start
2814             : -numPixels + end - (pixelOffset - (getViewportLength() * getPosition()));
2815 
2816         // &quot;p&quot; represents the most recent value for position. This is always
2817         // based on the edge between two cells, except at the very end of the
2818         // algorithm where it is added to the computed &quot;p&quot; offset for the final
2819         // value of Position.
2820         double p = cellPercent * cellIndex;
2821 
2822         // Loop over the cells one at a time until either we reach the end of
2823         // the cells, or we find that the &quot;n&quot; will fall within the cell we&#39;re on
2824         while (n &gt; remaining &amp;&amp; ((forward &amp;&amp; cellIndex &lt; cellCount - 1) || (! forward &amp;&amp; cellIndex &gt; 0))) {
2825             if (forward) cellIndex++; else cellIndex--;
2826             n -= remaining;
2827             cellSize = getCellLength(cellIndex);
2828             start = computeOffsetForCell(cellIndex);
2829             end = cellSize + computeOffsetForCell(cellIndex + 1);
2830             remaining = end - start;
2831             p = cellPercent * cellIndex;
2832         }
2833 
2834         // if remaining is &lt; n, then we must have hit an end, so as a
2835         // fast path, we can just set position to 1.0 or 0.0 and return
2836         // because we know we hit the end
2837         if (n &gt; remaining) {
2838             setPosition(forward ? 1.0f : 0.0f);
2839         } else if (forward) {
2840             double rate = cellPercent / Math.abs(end - start);
2841             setPosition(p + (rate * n));
2842         } else {
2843             double rate = cellPercent / Math.abs(end - start);
2844             setPosition((p + cellPercent) - (rate * n));
2845         }
2846     }
2847 
2848     private int computeCurrentIndex() {
2849         return (int) (getPosition() * getCellCount());
2850     }
2851 
2852     /**
2853      * Given an item index, this function will compute and return the viewport
2854      * offset from the beginning of the specified item. Notice that because each
2855      * item has the same percentage of the position dedicated to it, and since
2856      * we are measuring from the start of each item, this is a very simple
2857      * calculation.
2858      */
2859     private double computeOffsetForCell(int itemIndex) {
2860         double cellCount = getCellCount();
2861         double p = com.sun.javafx.util.Utils.clamp(0, itemIndex, cellCount) / cellCount;
2862         return -(getViewportLength() * p);
2863     }
2864 
2865 //    /**
2866 //     * Adjust the position based on a chunk of pixels. The position is based
2867 //     * on the start of the scrollbar position.
2868 //     */
2869 //    private void adjustByPixelChunk(double numPixels) {
2870 //        setPosition(0);
2871 //        adjustByPixelAmount(numPixels);
2872 //    }
2873     // end of old PositionMapper code
2874 
2875 
2876 
2877 
2878     /***************************************************************************
2879      *                                                                         *
2880      * Support classes                                                         *
2881      *                                                                         *
2882      **************************************************************************/
2883 
2884     /**
2885      * A simple extension to Region that ensures that anything wanting to flow
2886      * outside of the bounds of the Region is clipped.
2887      */
2888     static class ClippedContainer extends Region {
2889 
2890         /**
2891          * The Node which is embedded within this {@code ClipView}.
2892          */
2893         private Node node;
2894         public Node getNode() { return this.node; }
2895         public void setNode(Node n) {
2896             this.node = n;
2897 
2898             getChildren().clear();
2899             getChildren().add(node);
2900         }
2901 
2902         public void setClipX(double clipX) {
2903             setLayoutX(-clipX);
2904             clipRect.setLayoutX(clipX);
2905         }
2906 
2907         public void setClipY(double clipY) {
2908             setLayoutY(-clipY);
2909             clipRect.setLayoutY(clipY);
2910         }
2911 
2912         private final Rectangle clipRect;
2913 
2914         public ClippedContainer(final VirtualFlow&lt;?&gt; flow) {
2915             if (flow == null) {
2916                 throw new IllegalArgumentException(&quot;VirtualFlow can not be null&quot;);
2917             }
2918 
2919             getStyleClass().add(&quot;clipped-container&quot;);
2920 
2921             // clipping
2922             clipRect = new Rectangle();
2923             clipRect.setSmooth(false);
2924             setClip(clipRect);
2925             // --- clipping
2926 
2927             super.widthProperty().addListener(valueModel -&gt; {
2928                 clipRect.setWidth(getWidth());
2929             });
2930             super.heightProperty().addListener(valueModel -&gt; {
2931                 clipRect.setHeight(getHeight());
2932             });
2933         }
2934     }
2935 
2936     /**
2937      * A List-like implementation that is exceedingly efficient for the purposes
2938      * of the VirtualFlow. Typically there is not much variance in the number of
2939      * cells -- it is always some reasonably consistent number. Yet for efficiency
2940      * in code, we like to use a linked list implementation so as to append to
2941      * start or append to end. However, at times when we need to iterate, LinkedList
2942      * is expensive computationally as well as requiring the construction of
2943      * temporary iterators.
2944      * &lt;p&gt;
2945      * This linked list like implementation is done using an array. It begins by
2946      * putting the first item in the center of the allocated array, and then grows
2947      * outward (either towards the first or last of the array depending on whether
2948      * we are inserting at the head or tail). It maintains an index to the start
2949      * and end of the array, so that it can efficiently expose iteration.
2950      * &lt;p&gt;
2951      * This class is package private solely for the sake of testing.
2952      */
2953     static class ArrayLinkedList&lt;T&gt; extends AbstractList&lt;T&gt; {
2954         /**
2955          * The array list backing this class. We default the size of the array
2956          * list to be fairly large so as not to require resizing during normal
2957          * use, and since that many ArrayLinkedLists won&#39;t be created it isn&#39;t
2958          * very painful to do so.
2959          */
2960         private final ArrayList&lt;T&gt; array;
2961 
2962         private int firstIndex = -1;
2963         private int lastIndex = -1;
2964 
2965         public ArrayLinkedList() {
2966             array = new ArrayList&lt;T&gt;(50);
2967 
2968             for (int i = 0; i &lt; 50; i++) {
2969                 array.add(null);
2970             }
2971         }
2972 
2973         public T getFirst() {
2974             return firstIndex == -1 ? null : array.get(firstIndex);
2975         }
2976 
2977         public T getLast() {
2978             return lastIndex == -1 ? null : array.get(lastIndex);
2979         }
2980 
2981         public void addFirst(T cell) {
2982             // if firstIndex == -1 then that means this is the first item in the
2983             // list and we need to initialize firstIndex and lastIndex
2984             if (firstIndex == -1) {
2985                 firstIndex = lastIndex = array.size() / 2;
2986                 array.set(firstIndex, cell);
2987             } else if (firstIndex == 0) {
2988                 // we&#39;re already at the head of the array, so insert at position
2989                 // 0 and then increment the lastIndex to compensate
2990                 array.add(0, cell);
2991                 lastIndex++;
2992             } else {
2993                 // we&#39;re not yet at the head of the array, so insert at the
2994                 // firstIndex - 1 position and decrement first position
2995                 array.set(--firstIndex, cell);
2996             }
2997         }
2998 
2999         public void addLast(T cell) {
3000             // if lastIndex == -1 then that means this is the first item in the
3001             // list and we need to initialize the firstIndex and lastIndex
3002             if (firstIndex == -1) {
3003                 firstIndex = lastIndex = array.size() / 2;
3004                 array.set(lastIndex, cell);
3005             } else if (lastIndex == array.size() - 1) {
3006                 // we&#39;re at the end of the array so need to &quot;add&quot; so as to force
3007                 // the array to be expanded in size
3008                 array.add(++lastIndex, cell);
3009             } else {
3010                 array.set(++lastIndex, cell);
3011             }
3012         }
3013 
3014         public int size() {
3015             return firstIndex == -1 ? 0 : lastIndex - firstIndex + 1;
3016         }
3017 
3018         public boolean isEmpty() {
3019             return firstIndex == -1;
3020         }
3021 
3022         public T get(int index) {
3023             if (index &gt; (lastIndex - firstIndex) || index &lt; 0) {
3024                 // Commented out exception due to RT-29111
3025                 // throw new java.lang.ArrayIndexOutOfBoundsException();
3026                 return null;
3027             }
3028 
3029             return array.get(firstIndex + index);
3030         }
3031 
3032         public void clear() {
3033             for (int i = 0; i &lt; array.size(); i++) {
3034                 array.set(i, null);
3035             }
3036 
3037             firstIndex = lastIndex = -1;
3038         }
3039 
3040         public T removeFirst() {
3041             if (isEmpty()) return null;
3042             return remove(0);
3043         }
3044 
3045         public T removeLast() {
3046             if (isEmpty()) return null;
3047             return remove(lastIndex - firstIndex);
3048         }
3049 
3050         public T remove(int index) {
3051             if (index &gt; lastIndex - firstIndex || index &lt; 0) {
3052                 throw new ArrayIndexOutOfBoundsException();
3053             }
3054 
3055             // if the index == 0, then we&#39;re removing the first
3056             // item and can simply set it to null in the array and increment
3057             // the firstIndex unless there is only one item, in which case
3058             // we have to also set first &amp; last index to -1.
3059             if (index == 0) {
3060                 T cell = array.get(firstIndex);
3061                 array.set(firstIndex, null);
3062                 if (firstIndex == lastIndex) {
3063                     firstIndex = lastIndex = -1;
3064                 } else {
3065                     firstIndex++;
3066                 }
3067                 return cell;
3068             } else if (index == lastIndex - firstIndex) {
3069                 // if the index == lastIndex - firstIndex, then we&#39;re removing the
3070                 // last item and can simply set it to null in the array and
3071                 // decrement the lastIndex
3072                 T cell = array.get(lastIndex);
3073                 array.set(lastIndex--, null);
3074                 return cell;
3075             } else {
3076                 // if the index is somewhere in between, then we have to remove the
3077                 // item and decrement the lastIndex
3078                 T cell = array.get(firstIndex + index);
3079                 array.set(firstIndex + index, null);
3080                 for (int i = (firstIndex + index + 1); i &lt;= lastIndex; i++) {
3081                     array.set(i - 1, array.get(i));
3082                 }
3083                 array.set(lastIndex--, null);
3084                 return cell;
3085             }
3086         }
3087     }
3088 }
    </pre>
  </body>
</html>