diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/scene/PointLightHelper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -54,19 +54,24 @@
     @Override
     protected NGNode createPeerImpl(Node node) {
         return pointLightAccessor.doCreatePeer(node);
     }
 
+    @Override
+    protected void updatePeerImpl(Node node) {
+        super.updatePeerImpl(node);
+        pointLightAccessor.doUpdatePeer(node);
+    }
+
     public static void setPointLightAccessor(final PointLightAccessor newAccessor) {
         if (pointLightAccessor != null) {
             throw new IllegalStateException();
         }
 
         pointLightAccessor = newAccessor;
     }
 
     public interface PointLightAccessor {
         NGNode doCreatePeer(Node node);
+        void doUpdatePeer(Node node);
     }
-
 }
-
diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGPointLight.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,13 +24,95 @@
  */
 
 package com.sun.javafx.sg.prism;
 
 /**
- * TODO: 3D - Need documentation
+ * The peer of the {@code PointLight} class. Holds the default values of {@code PointLight}'s
+ * properties and updates the visuals via {@link NGNode#visualsChanged} when one of the current
+ * values changes. The peer receives its changes by {@code PointLight.doUpdatePeer} calls.
  */
 public class NGPointLight extends NGLightBase {
 
+    /** Constant attenuation factor default value */
+    private static final float DEFAULT_CA = 1;
+    /** Linear attenuation factor default value */
+    private static final float DEFAULT_LA = 0;
+    /** Quadratic attenuation factor default value */
+    private static final float DEFAULT_QA = 0;
+    /** Max range default value */
+    private static final float DEFAULT_MAX_RANGE = Float.POSITIVE_INFINITY;
+
     public NGPointLight() {
     }
 
-}
+    public static float getDefaultCa() {
+        return DEFAULT_CA;
+    }
+
+    public static float getDefaultLa() {
+        return DEFAULT_LA;
+    }
+
+    public static float getDefaultQa() {
+        return DEFAULT_QA;
+    }
+
+    public static float getDefaultMaxRange() {
+        return DEFAULT_MAX_RANGE;
+    }
+
+
+    private float ca = DEFAULT_CA;
+
+    public float getCa() {
+        return ca;
+    }
+
+    public void setCa(float ca) {
+        if (this.ca != ca) {
+            this.ca = ca;
+            visualsChanged();
+        }
+    }
+
+
+    private float la = DEFAULT_LA;
+
+    public float getLa() {
+        return la;
+    }
+
+    public void setLa(float la) {
+        if (this.la != la) {
+            this.la = la;
+            visualsChanged();
+        }
+    }
+
+
+    private float qa = DEFAULT_QA;
+
+    public float getQa() {
+        return qa;
+    }
+
+    public void setQa(float qa) {
+        if (this.qa != qa) {
+            this.qa = qa;
+            visualsChanged();
+        }
+    }
+
+
+    private float maxRange = DEFAULT_MAX_RANGE;
+
+    public float getMaxRange() {
+        return maxRange;
+    }
+
+    public void setMaxRange(float maxRange) {
+        if (this.maxRange != maxRange) {
+            this.maxRange = maxRange < 0 ? 0 : maxRange;
+            visualsChanged();
+        }
+    }
+}
diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/sg/prism/NGShape3D.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -107,18 +107,22 @@
 
         // Setup lights
         int pointLightIdx = 0;
         if (g.getLights() == null || g.getLights()[0] == null) {
             // If no lights are in scene apply default light. Default light
-            // is a single point white point light at camera eye position.
+            // is a single white point light at camera eye position.
             meshView.setAmbientLight(0.0f, 0.0f, 0.0f);
             Vec3d cameraPos = g.getCameraNoClone().getPositionInWorld(null);
             meshView.setPointLight(pointLightIdx++,
                                    (float)cameraPos.x,
                                    (float)cameraPos.y,
                                    (float)cameraPos.z,
-                                   1.0f, 1.0f, 1.0f, 1.0f);
+                                   1.0f, 1.0f, 1.0f, 1.0f,
+                                   NGPointLight.getDefaultCa(),
+                                   NGPointLight.getDefaultLa(),
+                                   NGPointLight.getDefaultQa(),
+                                   NGPointLight.getDefaultMaxRange());
         } else {
             float ambientRed = 0.0f;
             float ambientBlue = 0.0f;
             float ambientGreen = 0.0f;
 
@@ -130,11 +134,11 @@
                 } else if (lightBase.affects(this)) {
                     float rL = lightBase.getColor().getRed();
                     float gL = lightBase.getColor().getGreen();
                     float bL = lightBase.getColor().getBlue();
                     /* TODO: 3D
-                     * There is a limit on the number of lights that can affect
+                     * There is a limit on the number of point lights that can affect
                      * a 3D shape. (Currently we simply select the first 3)
                      * Thus it is important to select the most relevant lights.
                      *
                      * One such way would be to sort lights according to
                      * intensity, which becomes especially relevant when lights
@@ -153,11 +157,15 @@
                             Affine3D lightWT = light.getWorldTransform();
                             meshView.setPointLight(pointLightIdx++,
                                     (float)lightWT.getMxt(),
                                     (float)lightWT.getMyt(),
                                     (float)lightWT.getMzt(),
-                                    rL, gL, bL, 1.0f);
+                                    rL, gL, bL, 1.0f,
+                                    light.getCa(),
+                                    light.getLa(),
+                                    light.getQa(),
+                                    light.getMaxRange());
                         }
                     } else if (lightBase instanceof NGAmbientLight) {
                         // Accumulate ambient lights
                         ambientRed   += rL;
                         ambientGreen += gL;
@@ -171,11 +179,15 @@
             meshView.setAmbientLight(ambientRed, ambientGreen, ambientBlue);
         }
         // TODO: 3D Required for D3D implementation of lights, which is limited to 3
         while (pointLightIdx < 3) {
                 // Reset any previously set lights
-                meshView.setPointLight(pointLightIdx++, 0, 0, 0, 0, 0, 0, 0);
+                meshView.setPointLight(pointLightIdx++,
+                        0, 0, 0, // x y z
+                        0, 0, 0, 0, // r g b w
+                        NGPointLight.getDefaultCa(), NGPointLight.getDefaultLa(), NGPointLight.getDefaultQa(),
+                        NGPointLight.getDefaultMaxRange());
         }
 
         meshView.render(g);
     }
 
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/MeshView.java b/modules/javafx.graphics/src/main/java/com/sun/prism/MeshView.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/MeshView.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/MeshView.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -46,9 +46,10 @@
 
     public void setAmbientLight(float r, float g, float b);
 
     public void setPointLight(int index,
             float x, float y, float z,
-            float r, float g, float b, float w);
+            float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange);
 
     public void render(Graphics g);
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DContext.java
@@ -424,11 +424,12 @@
     private static native void nSetWireframe(long pContext, long nativeMeshView,
             boolean wireframe);
     private static native void nSetAmbientLight(long pContext, long nativeMeshView,
             float r, float g, float b);
     private static native void nSetPointLight(long pContext, long nativeMeshView,
-            int index, float x, float y, float z, float r, float g, float b, float w);
+            int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange);
     private static native void nRenderMeshView(long pContext, long nativeMeshView);
     private static native int nDrawIndexedQuads(long pContext,
             float coords[], byte colors[], int numVertices);
 
 
@@ -549,12 +550,13 @@
 
     void setAmbientLight(long nativeMeshView, float r, float g, float b) {
         nSetAmbientLight(pContext, nativeMeshView, r, g, b);
     }
 
-    void setPointLight(long nativeMeshView, int index, float x, float y, float z, float r, float g, float b, float w) {
-        nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w);
+    void setPointLight(long nativeMeshView, int index, float x, float y, float z,
+            float r, float g, float b, float w, float ca, float la, float qa, float maxRange) {
+        nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
     }
 
     @Override
     protected void renderQuads(float coordArray[], byte colorArray[], int numVertices) {
         int res = nDrawIndexedQuads(pContext, coordArray, colorArray, numVertices);
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DMeshView.java b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DMeshView.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DMeshView.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/d3d/D3DMeshView.java
@@ -79,14 +79,15 @@
     public void setAmbientLight(float r, float g, float b) {
         context.setAmbientLight(nativeHandle, r, g, b);
     }
 
     @Override
-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w) {
+    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange) {
         // NOTE: We only support up to 3 point lights at the present
         if (index >= 0 && index <= 2) {
-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
+            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
         }
     }
 
     @Override
     public void render(Graphics g) {
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Context.java b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Context.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Context.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Context.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -447,12 +447,13 @@
 
     void setAmbientLight(long nativeHandle, float r, float g, float b) {
         glContext.setAmbientLight(nativeHandle, r, g, b);
     }
 
-    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w) {
-        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
+    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange) {
+        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
     }
 
     @Override
     public void blit(RTTexture srcRTT, RTTexture dstRTT,
                      int srcX0, int srcY0, int srcX1, int srcY1,
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Light.java b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Light.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Light.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2Light.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,16 +30,21 @@
  */
 class ES2Light {
 
     float x, y, z = 0;
     float r, g, b, w = 1;
+    float ca, la, qa, maxRange;
 
-    ES2Light(float ix, float iy, float iz, float ir, float ig, float ib, float iw) {
+    ES2Light(float ix, float iy, float iz, float ir, float ig, float ib, float iw, float ca, float la, float qa, float maxRange) {
         x = ix;
         y = iy;
         z = iz;
         r = ir;
         g = ig;
         b = ib;
         w = iw;
+        this.ca = ca;
+        this.la = la;
+        this.qa = qa;
+        this.maxRange = maxRange;
     }
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2MeshView.java b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2MeshView.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2MeshView.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2MeshView.java
@@ -99,15 +99,16 @@
     float getAmbientLightBlue() {
         return ambientLightBlue;
     }
 
     @Override
-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w) {
+    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange) {
         // NOTE: We only support up to 3 point lights at the present
         if (index >= 0 && index <= 2) {
-            lights[index] = new ES2Light(x, y, z, r, g, b, w);
-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
+            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, maxRange);
+            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
         }
     }
 
     ES2Light[] getPointLights() {
         return lights;
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2PhongShader.java b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2PhongShader.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2PhongShader.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/ES2PhongShader.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -202,14 +202,16 @@
 
         shader.setConstant("ambientColor", meshView.getAmbientLightRed(),
                 meshView.getAmbientLightGreen(), meshView.getAmbientLightBlue());
 
         int i = 0;
-        for(ES2Light light : meshView.getPointLights()) {
+        for (ES2Light light : meshView.getPointLights()) {
             if (light != null && light.w > 0) {
                 shader.setConstant("lights[" + i + "].pos", light.x, light.y, light.z, light.w);
                 shader.setConstant("lights[" + i + "].color", light.r, light.g, light.b);
+                shader.setConstant("lights[" + i + "].attn", light.ca, light.la, light.qa);
+                shader.setConstant("lights[" + i + "].range", light.maxRange);
                 i++;
             }
         }
     }
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/GLContext.java b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/GLContext.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/es2/GLContext.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/es2/GLContext.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -250,11 +250,12 @@
     private static native void nSetWireframe(long nativeCtxInfo, long nativeMeshViewInfo,
             boolean wireframe);
     private static native void nSetAmbientLight(long nativeCtxInfo, long nativeMeshViewInfo,
             float r, float g, float b);
     private static native void nSetPointLight(long nativeCtxInfo, long nativeMeshViewInfo,
-            int index, float x, float y, float z, float r, float g, float b, float w);
+            int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange);
     private static native void nRenderMeshView(long nativeCtxInfo, long nativeMeshViewInfo);
     private static native void nBlit(long nativeCtxInfo, int srcFBO, int dstFBO,
             int srcX0, int srcY0, int srcX1, int srcY1,
             int dstX0, int dstY0, int dstX1, int dstY1);
 
@@ -806,12 +807,13 @@
 
     void setAmbientLight(long nativeMeshViewInfo, float r, float g, float b) {
         nSetAmbientLight(nativeCtxInfo, nativeMeshViewInfo, r, g, b);
     }
 
-    void setPointLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w) {
-        nSetPointLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w);
+    void setPointLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w,
+            float ca, float la, float qa, float maxRange) {
+        nSetPointLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);
     }
 
     void renderMeshView(long nativeMeshViewInfo) {
         nRenderMeshView(nativeCtxInfo, nativeMeshViewInfo);
     }
diff a/modules/javafx.graphics/src/main/java/javafx/scene/LightBase.java b/modules/javafx.graphics/src/main/java/javafx/scene/LightBase.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/LightBase.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/LightBase.java
@@ -42,12 +42,14 @@
 import java.util.stream.Collectors;
 
 import javafx.application.ConditionalFeature;
 import javafx.application.Platform;
 import javafx.beans.property.BooleanProperty;
+import javafx.beans.property.DoubleProperty;
 import javafx.beans.property.ObjectProperty;
 import javafx.beans.property.SimpleBooleanProperty;
+import javafx.beans.property.SimpleDoubleProperty;
 import javafx.beans.property.SimpleObjectProperty;
 import javafx.collections.ListChangeListener.Change;
 import javafx.collections.ObservableList;
 import javafx.scene.paint.Color;
 import javafx.scene.shape.Shape3D;
@@ -275,10 +277,24 @@
         } else if (newScene != null) {
             newScene.addLight(this);
         }
     }
 
+    /**
+     * For use by implementing subclasses. Treat as protected.
+     *
+     * Creates and returns a SimpleDoubleProperty with an invalidation scheme.
+     */
+    DoubleProperty getLightDoubleProperty(String name, double initialValue) {
+        return new SimpleDoubleProperty(this, name, initialValue) {
+            @Override
+            protected void invalidated() {
+                NodeHelper.markDirty(LightBase.this, DirtyBits.NODE_LIGHT);
+            }
+        };
+    }
+
     private void markOwnerDirty() {
         // if the light is part of the scene/subScene, we will need to notify
         // the owner to mark the entire scene/subScene dirty.
         SubScene subScene = getSubScene();
         if (subScene != null) {
diff a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/PointLight.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,40 +24,62 @@
  */
 
 package javafx.scene;
 
 import com.sun.javafx.scene.DirtyBits;
-import com.sun.javafx.scene.NodeHelper;
 import com.sun.javafx.scene.PointLightHelper;
 import com.sun.javafx.sg.prism.NGNode;
 import com.sun.javafx.sg.prism.NGPointLight;
+
+import javafx.beans.property.DoubleProperty;
 import javafx.scene.paint.Color;
+import javafx.scene.paint.PhongMaterial;
 
 /**
- * Defines a point light source object. A light source that has a
- * fixed point in space and radiates light equally in all directions
- * away from itself.
+ * A light source that radiates light equally in all directions away from itself. The location of the light
+ * source is a single point in space. Any pixel within the range of the light will be illuminated by it,
+ * unless it belongs to a {@code Shape3D} outside of its {@code scope}.
+ * <p>
+ * The light's intensity can be set to decrease over distance by attenuating it. The attenuation formula
+ * <p>
+ * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
+ * <p>
+ * defines 3 coefficients: {@code ca}, {@code la}, and {@code qa}, which control the constant, linear, and
+ * quadratic behaviors of intensity falloff over distance, respectively. The effective color of the light
+ * at a given point in space is {@code color * attn}. It is possible, albeit unrealistic, to specify negative
+ * values to attenuation coefficients. This allows the resulting attenuation factor to be negative, which
+ * results in the light's color being subtracted from the material instead of added to it, thus creating a
+ * "shadow caster".
+ * <p>
+ * For a realistic effect, {@code maxRange} should be set to a distance at which the attenuation is close to 0
+ * as this will give a soft cutoff.
  *
  * @since JavaFX 8.0
+ * @see PhongMaterial
  */
 public class PointLight extends LightBase {
     static {
         PointLightHelper.setPointLightAccessor(new PointLightHelper.PointLightAccessor() {
             @Override
             public NGNode doCreatePeer(Node node) {
                 return ((PointLight) node).doCreatePeer();
             }
+
+            @Override
+            public void doUpdatePeer(Node node) {
+                ((PointLight) node).doUpdatePeer();
+            }
         });
     }
 
     {
-        // To initialize the class helper at the begining each constructor of this class
+        // To initialize the class helper at the beginning each constructor of this class
         PointLightHelper.initHelper(this);
     }
 
     /**
-     * Creates a new instance of {@code PointLight} class with a default Color.WHITE light source.
+     * Creates a new instance of {@code PointLight} class with a default {@code Color.WHITE} light source.
      */
     public PointLight() {
         super();
     }
 
@@ -68,12 +90,143 @@
      */
     public PointLight(Color color) {
         super(color);
     }
 
+    /**
+     * The maximum range of this {@code PointLight}. For a pixel to be affected by this light, its distance to the
+     * light source must be less than or equal to the light's maximum range. Any negative value will be treated as 0.
+     * <p>
+     * Lower {@code maxRange} values can give better performance as pixels outside the range of the light
+     * will not require complex calculation. The attenuation formula can be used to calculate a realistic
+     * {@code maxRange} value by finding the distance where the attenuation is close enough to 0.
+     * <p>
+     * Nodes that are inside the light's range can still be excluded from the light's effect by removing them from
+     * its {@link #getScope() scope} (or including them in its {@link #getExclusionScope() exclusion scope}). If a
+     * node is known to always be outside of the light's range, it is more performant to exclude it from its scope.
+     *
+     * @defaultValue {@code Double.POSITIVE_INFINITY}
+     * @since 16
+     */
+    private DoubleProperty maxRange;
+
+    public final void setMaxRange(double value) {
+        maxRangeProperty().set(value);
+    }
+
+    private static final double DEFAULT_MAX_RANGE = NGPointLight.getDefaultMaxRange();
+
+    public final double getMaxRange() {
+        return maxRange == null ? DEFAULT_MAX_RANGE : maxRange.get();
+    }
+
+    public final DoubleProperty maxRangeProperty() {
+        if (maxRange == null) {
+            maxRange = getLightDoubleProperty("maxRange", DEFAULT_MAX_RANGE);
+        }
+        return maxRange;
+    }
+
+    /**
+     * The constant attenuation coefficient. This is the term {@code ca} in the attenuation formula:
+     * <p>
+     * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
+     * <p>
+     * where {@code dist} is the distance between the light source and the pixel.
+     *
+     * @defaultValue 1
+     * @since 16
+     */
+    private DoubleProperty constantAttenuation;
+
+    public final void setConstantAttenuation(double value) {
+        constantAttenuationProperty().set(value);
+    }
+
+    private static final double DEFAULT_CONSTANT_ATTENUATION = NGPointLight.getDefaultCa();
+
+    public final double getConstantAttenuation() {
+        return constantAttenuation == null ? DEFAULT_CONSTANT_ATTENUATION : constantAttenuation.get();
+    }
+
+    public final DoubleProperty constantAttenuationProperty() {
+        if (constantAttenuation == null) {
+            constantAttenuation = getLightDoubleProperty("constantAttenuation", DEFAULT_CONSTANT_ATTENUATION);
+        }
+        return constantAttenuation;
+    }
+
+    /**
+     * The linear attenuation coefficient. This is the term {@code la} in the attenuation formula:
+     * <p>
+     * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
+     * <p>
+     * where {@code dist} is the distance between the light source and the pixel.
+     *
+     * @defaultValue 0
+     * @since 16
+     */
+    private DoubleProperty linearAttenuation;
+
+    public final void setLinearAttenuation(double value) {
+        linearAttenuationProperty().set(value);
+    }
+
+    private static final double DEFAULT_LINEAR_ATTENUATION = NGPointLight.getDefaultLa();
+
+    public final double getLinearAttenuation() {
+        return linearAttenuation == null ? DEFAULT_LINEAR_ATTENUATION : linearAttenuation.get();
+    }
+
+    public final DoubleProperty linearAttenuationProperty() {
+        if (linearAttenuation == null) {
+            linearAttenuation = getLightDoubleProperty("linearAttenuation", DEFAULT_LINEAR_ATTENUATION);
+        }
+        return linearAttenuation;
+    }
+
+    /**
+     * The quadratic attenuation coefficient. This is the term {@code qa} in the attenuation formula:
+     * <p>
+     * {@code attn = 1 / (ca + la * dist + qa * dist^2)}
+     * <p>
+     * where {@code dist} is the distance between the light source and the pixel.
+     *
+     * @defaultValue 0
+     * @since 16
+     */
+    private DoubleProperty quadraticAttenuation;
+
+    public final void setQuadraticAttenuation(double value) {
+        quadraticAttenuationProperty().set(value);
+    }
+
+    private static final double DEFAULT_QUADRATIC_ATTENUATION = NGPointLight.getDefaultQa();
+
+    public final double getQuadraticAttenuation() {
+        return quadraticAttenuation == null ? DEFAULT_QUADRATIC_ATTENUATION : quadraticAttenuation.get();
+    }
+
+    public final DoubleProperty quadraticAttenuationProperty() {
+        if (quadraticAttenuation == null) {
+            quadraticAttenuation = getLightDoubleProperty("quadraticAttenuation", DEFAULT_QUADRATIC_ATTENUATION);
+        }
+        return quadraticAttenuation;
+    }
+
     /*
      * Note: This method MUST only be called via its accessor method.
      */
     private NGNode doCreatePeer() {
         return new NGPointLight();
     }
+
+    private void doUpdatePeer() {
+        if (isDirty(DirtyBits.NODE_LIGHT)) {
+            NGPointLight peer = getPeer();
+            peer.setCa((float) getConstantAttenuation());
+            peer.setLa((float) getLinearAttenuation());
+            peer.setQa((float) getQuadraticAttenuation());
+            peer.setMaxRange((float) getMaxRange());
+        }
+    }
 }
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DContext.cc b/modules/javafx.graphics/src/main/native-prism-d3d/D3DContext.cc
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DContext.cc
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DContext.cc
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -514,17 +514,17 @@
  * Method:    nSetPointLight
  * Signature: (JJIFFFFFFF)V
  */
 JNIEXPORT void JNICALL Java_com_sun_prism_d3d_D3DContext_nSetPointLight
   (JNIEnv *env, jclass, jlong ctx, jlong nativeMeshView, jint index,
-        jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)
+        jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w,
+        jfloat ca, jfloat la, jfloat qa, jfloat range)
 {
     TraceLn(NWT_TRACE_INFO, "D3DContext_nSetPointLight");
     D3DMeshView *meshView = (D3DMeshView *) jlong_to_ptr(nativeMeshView);
     RETURN_IF_NULL(meshView);
-
-    meshView->setPointLight(index, x, y, z, r, g, b, w);
+    meshView->setPointLight(index, x, y, z, r, g, b, w, ca, la, qa, range);
 }
 
 /*
  * Class:     com_sun_prism_d3d_D3DContext
  * Method:    nRenderMeshView
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.cc b/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.cc
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.cc
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.cc
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,14 @@
     position[0] = 0;
     position[1] = 0;
     position[2] = 0;
     position[3] = 0; // padding since SetPixelShaderConstantF only takes vec4f; position[3] is unused
     w = 0;
+    attenuation[0] = 1;
+    attenuation[1] = 0;
+    attenuation[2] = 0;
+    maxRange = 0;
 }
 
 void D3DLight::setColor(float r, float g, float b) {
     color[0] = r;
     color[1] = g;
@@ -54,5 +58,9 @@
 void D3DLight::setPosition(float x, float y, float z) {
     position[0] = x;
     position[1] = y;
     position[2] = z;
 }
+
+/*void D3DLight::setRange(float r) {
+    maxRange = r;
+}*/
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.h b/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DLight.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -34,13 +34,16 @@
 public:
     D3DLight();
     virtual ~D3DLight();
     void setColor(float r, float g, float b);
     void setPosition(float x, float y, float z);
+//  void setRange(float r);
     float position[4]; // Only need x, y, z. The last float is needed for padding when upload to shader.
     float color[3];
     float w;
+    float attenuation[3]; // ca, la, qa
+    float maxRange;
 
 private:
 
 };
 
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.cc b/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.cc
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.cc
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.cc
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -71,20 +71,25 @@
     ambientLightColor[1] = g;
     ambientLightColor[2] = b;
 }
 
 void D3DMeshView::setPointLight(int index, float x, float y, float z,
-    float r, float g, float b, float w) {
+        float r, float g, float b, float w,
+        float ca, float la, float qa, float maxRange) {
     // NOTE: We only support up to 3 point lights at the present
     if (index >= 0 && index <= 2) {
         lights[index].position[0] = x;
         lights[index].position[1] = y;
         lights[index].position[2] = z;
         lights[index].color[0] = r;
         lights[index].color[1] = g;
         lights[index].color[2] = b;
         lights[index].w = w;
+        lights[index].attenuation[0] = ca;
+        lights[index].attenuation[1] = la;
+        lights[index].attenuation[2] = qa;
+        lights[index].maxRange = maxRange;
         lightsDirty = TRUE;
     }
 }
 
 void D3DMeshView::computeNumLights() {
@@ -152,23 +157,45 @@
     if (!status) {
         cout << "D3DMeshView.render() - SetPixelShaderConstantF (PSR_SPECULARCOLOR) failed !!!" << endl;
         return;
     }
 
-    float lightsColor[12];
-    for (int i = 0, j = 0; i < 3; i++) {
+    float lightsColor[12];       // 3 lights x (3 color + 1 padding)
+    float lightsAttenuation[12]; // 3 lights x (3 attenuation factors + 1 padding)
+    float lightsRange[12];		 // 3 lights x (1 maxRange + 3 padding)
+    for (int i = 0, c = 0, a = 0, r = 0; i < 3; i++) {
         float w = lights[i].w;
-        lightsColor[j++] = lights[i].color[0] * w;
-        lightsColor[j++] = lights[i].color[1] * w;
-        lightsColor[j++] = lights[i].color[2] * w;
-        lightsColor[j++] = 1;
+        lightsColor[c++] = lights[i].color[0] * w;
+        lightsColor[c++] = lights[i].color[1] * w;
+        lightsColor[c++] = lights[i].color[2] * w;
+        lightsColor[c++] = 1;
+
+        lightsAttenuation[a++] = lights[i].attenuation[0];
+        lightsAttenuation[a++] = lights[i].attenuation[1];
+        lightsAttenuation[a++] = lights[i].attenuation[2];
+        lightsAttenuation[a++] = 0;
+
+        lightsRange[r++] = lights[i].maxRange;
+        lightsRange[r++] = 0;
+        lightsRange[r++] = 0;
+        lightsRange[r++] = 0;
     }
     status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHTCOLOR, lightsColor, 3));
     if (!status) {
         cout << "D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHTCOLOR) failed !!!" << endl;
         return;
     }
+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_ATTENUATION, lightsAttenuation, 3));
+    if (!status) {
+        cout << "D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_ATTENUATION) failed !!!" << endl;
+        return;
+    }
+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_RANGE, lightsRange, 3));
+    if (!status) {
+        cout << "D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_RANGE) failed !!!" << endl;
+        return;
+    }
 
     int bm = pShader->getBumpMode(material->isBumpMap());
     int sm = pShader->getSpecularMode(material->isSpecularMap(), material->isSpecularColor());
     int im = material->isSelfIllumMap() ? 1 : 0;
 
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.h b/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DMeshView.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -38,21 +38,22 @@
     void setCullingMode(int cMode);
     void setMaterial(D3DPhongMaterial *pMaterial);
     void setWireframe(bool wf);
     void setAmbientLight(float r, float g, float b);
     void setPointLight(int index, float x, float y, float z,
-    float r, float g, float b, float w);
+        float r, float g, float b, float w,
+        float ca, float la, float qa, float maxRange);
     void computeNumLights();
     void render();
 
 private:
     D3DContext *context;
     D3DMesh *mesh;
     D3DPhongMaterial *material;
     D3DLight lights[3];
     float ambientLightColor[3];
-    int  numLights;
+    int numLights;
     bool lightsDirty;
     int cullMode;
     bool wireframe;
 };
 
diff a/modules/javafx.graphics/src/main/native-prism-d3d/D3DPhongShader.h b/modules/javafx.graphics/src/main/native-prism-d3d/D3DPhongShader.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/D3DPhongShader.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/D3DPhongShader.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,14 +37,16 @@
 #define VSR_AMBIENTCOLOR 20
 // world
 #define VSR_WORLDMATRIX 30
 
 // PSR implies Pixel Shader Registers
-// we have 32 constants for ps 2.0
+// we have 224 float constants for ps 3.0
 #define PSR_DIFFUSECOLOR 0
 #define PSR_SPECULARCOLOR 1
-#define PSR_LIGHTCOLOR 4
+#define PSR_LIGHTCOLOR 4        // 3 lights + 2 reserve
+#define PSR_LIGHT_ATTENUATION 9 // 3 lights + 2 reserve
+#define PSR_LIGHT_RANGE 14      // 3 lights + 2 reserve
 
 // SR implies Sampler Registers
 #define SR_DIFFUSEMAP 0
 #define SR_SPECULARMAP 1
 #define SR_BUMPHEIGHTMAP 2
diff a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psConstants.h b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psConstants.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psConstants.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psConstants.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,8 +27,10 @@
 
 static const int numMaxLights = 5;
 
 float4 gDiffuseColor : register(c0);
 float4 gSpecularColor : register(c1); // specular power is in the alpha
-float4 gLightColor[numMaxLights] : register(c4);  // [c4 .. c8]
+float4 gLightColor[numMaxLights] : register(c4); // [c4 .. c8]
+float4 gLightAttenuation[numMaxLights] : register(c9); // [c9 .. c13]
+float4 gLightRange[numMaxLights] : register(c14); // [c14 .. c18]
 
-float4 gSomethingElse : register(c9);
+float4 gSomethingElse : register(c19);
diff a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
--- a/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
+++ b/modules/javafx.graphics/src/main/native-prism-d3d/hlsl/psMath.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -61,11 +61,19 @@
 void phong(
     float3 n, float3 e, float power, in float4 L[LocalBump::nLights],
     in out float3 d, in out float3 s, int _s, int _e)
 {
     float3 refl = reflect(e, n);
-    for (int i=_s; i<_e; i++) {
-        float3 l = normalize(L[i].xyz);
-        d += saturate(dot(n,l))*gLightColor[i].xyz;
-        s += pow(saturate(dot(-refl, l)), power)*gLightColor[i].xyz;
+    for (int i = _s; i < _e; i++) {
+        float dist = length(L[i].xyz);
+        if (dist <= gLightRange[i].x) {
+            float ca = gLightAttenuation[i].x;
+            float la = gLightAttenuation[i].y;
+            float qa = gLightAttenuation[i].z;
+            float attenuatedColor = gLightColor[i].xyz / (ca + la * dist + qa * dist * dist);
+
+            float3 l = normalize(L[i].xyz);
+            d += saturate(dot(n, l)) * attenuatedColor;
+            s += pow(saturate(dot(-refl, l)), power) * attenuatedColor;
+        }
     }
 }
diff a/modules/javafx.graphics/src/main/native-prism-es2/GLContext.c b/modules/javafx.graphics/src/main/native-prism-es2/GLContext.c
--- a/modules/javafx.graphics/src/main/native-prism-es2/GLContext.c
+++ b/modules/javafx.graphics/src/main/native-prism-es2/GLContext.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -2120,10 +2120,14 @@
     meshViewInfo->pointLightColor[2] = 0;
     meshViewInfo->pointLightPosition[0] = 0;
     meshViewInfo->pointLightPosition[1] = 0;
     meshViewInfo->pointLightPosition[2] = 0;
     meshViewInfo->pointLightWeight = 0;
+    meshViewInfo->pointLightAttenuation[0] = 1;
+    meshViewInfo->pointLightAttenuation[1] = 0;
+    meshViewInfo->pointLightAttenuation[2] = 0;
+    meshViewInfo->pointLightMaxRange = 0;
 
     return ptr_to_jlong(meshViewInfo);
 }
 
 /*
@@ -2263,11 +2267,12 @@
  * Method:    nSetPointLight
  * Signature: (JJIFFFFFFF)V
  */
 JNIEXPORT void JNICALL Java_com_sun_prism_es2_GLContext_nSetPointLight
   (JNIEnv *env, jclass class, jlong nativeCtxInfo, jlong nativeMeshViewInfo,
-        jint index, jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)
+        jint index, jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w,
+        jfloat ca, jfloat la, jfloat qa, jfloat maxRange)
 {
     ContextInfo *ctxInfo = (ContextInfo *) jlong_to_ptr(nativeCtxInfo);
     MeshViewInfo *meshViewInfo = (MeshViewInfo *) jlong_to_ptr(nativeMeshViewInfo);
     // NOTE: We only support up to 3 point lights at the present
     if ((ctxInfo == NULL) || (meshViewInfo == NULL) || (index < 0) || (index > 2)) {
@@ -2279,10 +2284,14 @@
     meshViewInfo->pointLightPosition[2] = z;
     meshViewInfo->pointLightColor[0] = r;
     meshViewInfo->pointLightColor[1] = g;
     meshViewInfo->pointLightColor[2] = b;
     meshViewInfo->pointLightWeight = w;
+    meshViewInfo->pointLightAttenuation[0] = ca;
+    meshViewInfo->pointLightAttenuation[1] = la;
+    meshViewInfo->pointLightAttenuation[2] = qa;
+    meshViewInfo->pointLightMaxRange = maxRange;
 }
 
 /*
  * Class:     com_sun_prism_es2_GLContext
  * Method:    nRenderMeshView
diff a/modules/javafx.graphics/src/main/native-prism-es2/PrismES2Defs.h b/modules/javafx.graphics/src/main/native-prism-es2/PrismES2Defs.h
--- a/modules/javafx.graphics/src/main/native-prism-es2/PrismES2Defs.h
+++ b/modules/javafx.graphics/src/main/native-prism-es2/PrismES2Defs.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -378,10 +378,12 @@
     GLfloat ambientLightColor[3];
     GLuint pointLightIndex;
     GLfloat pointLightWeight;
     GLfloat pointLightPosition[3];
     GLfloat pointLightColor[3];
+    GLfloat pointLightAttenuation[3];
+    GLfloat pointLightMaxRange;
     GLboolean cullEnable;
     GLenum cullMode;
     GLenum fillMode;
 };
 
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main.vert b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main.vert
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main.vert
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main.vert
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,10 +33,12 @@
 attribute vec4 tangent;
 
 struct Light {
     vec4 pos;
     vec3 color;
+    vec3 attn;
+    float range;
 };
 
 //3 lights used
 uniform Light lights[3];
 
@@ -93,11 +95,11 @@
     lightTangentSpacePositions[1] = vec4( getLocalVector(L,tangentFrame)*lights[1].pos.w, 1.0);
 
     L = lights[2].pos.xyz - worldPos.xyz;
     lightTangentSpacePositions[2] = vec4( getLocalVector(L,tangentFrame)*lights[2].pos.w, 1.0);
 
-     mat4 mvpMatrix = viewProjectionMatrix * worldMatrix;
+    mat4 mvpMatrix = viewProjectionMatrix * worldMatrix;
 
     //Send texcoords to Pixel Shader and calculate vertex position.
     oTexCoords = texCoords;
     gl_Position = mvpMatrix * vec4(pos,1.0);
 }
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main1Light.frag
@@ -56,38 +56,44 @@
 vec4 apply_selfIllum();
 
 struct Light {
     vec4 pos;
     vec3 color;
+    vec3 attn;
+    float range;
 };
 
 uniform vec3 ambientColor;
 uniform Light lights[3];
 
 varying vec3 eyePos;
 varying vec4 lightTangentSpacePositions[3];
 
 void main()
 {
-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);
     vec4 diffuse = apply_diffuse();
 
     if (diffuse.a == 0.0) discard;
 
-    vec3 n = apply_normal();
-
     vec3 d = vec3(0.0);
     vec3 s = vec3(0.0);
 
-    vec3 refl = reflect(normalize(eyePos), n);
     vec4 specular = apply_specular();
-    float power = specular.a;
 
-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);
-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;
-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power)*lights[0].color.rgb;
+    float maxRange = lights[0].range;
+    float dist = length(lightTangentSpacePositions[0].xyz);
+    if (dist <= maxRange) {
+        vec3 n = apply_normal();
+        vec3 refl = reflect(normalize(eyePos), n);
+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);
+
+        float power = specular.a;
 
-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d = clamp(dot(n, l), 0.0, 1.0) * attenuatedColor;
+        s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 
-    gl_FragColor = vec4(clamp(rez, 0.0, 1.0) , diffuse.a);
+    gl_FragColor = vec4(clamp(rez, 0.0, 1.0), diffuse.a);
 }
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main2Lights.frag
@@ -56,42 +56,52 @@
 vec4 apply_selfIllum();
 
 struct Light {
     vec4 pos;
     vec3 color;
+    vec3 attn;
+    float range;
 };
 
 uniform vec3 ambientColor;
 uniform Light lights[3];
 
 varying vec3 eyePos;
 varying vec4 lightTangentSpacePositions[3];
 
 void main()
 {
-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);
     vec4 diffuse = apply_diffuse();
 
     if (diffuse.a == 0.0) discard;
 
     vec3 n = apply_normal();
+    vec3 refl = reflect(normalize(eyePos), n);
 
     vec3 d = vec3(0.0);
     vec3 s = vec3(0.0);
 
-    vec3 refl = reflect(normalize(eyePos), n);
     vec4 specular = apply_specular();
     float power = specular.a;
 
-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);
-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;
-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power)*lights[0].color.rgb;
-
-    l = normalize(lightTangentSpacePositions[1].xyz);
-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[1].color).rgb;
-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb;
-
-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;
+    float maxRange = lights[0].range;
+    float dist = length(lightTangentSpacePositions[0].xyz);
+    if (dist <= maxRange) {
+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+
+    maxRange = lights[1].range;
+    dist = length(lightTangentSpacePositions[1].xyz);
+    if (dist <= maxRange) {
+        vec3 l = normalize(lightTangentSpacePositions[1].xyz);
+        float attenuatedColor = (lights[1].color).rgb / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 
     gl_FragColor = vec4(clamp(rez, 0.0, 1.0) , diffuse.a);
 }
diff a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
--- a/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
+++ b/modules/javafx.graphics/src/main/resources/com/sun/prism/es2/glsl/main3Lights.frag
@@ -56,46 +56,62 @@
 vec4 apply_selfIllum();
 
 struct Light {
     vec4 pos;
     vec3 color;
+    vec3 attn;
+    float range;
 };
 
 uniform vec3 ambientColor;
 uniform Light lights[3];
 
 varying vec3 eyePos;
 varying vec4 lightTangentSpacePositions[3];
 
 void main()
 {
-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);
     vec4 diffuse = apply_diffuse();
 
     if (diffuse.a == 0.0) discard;
 
     vec3 n = apply_normal();
+    vec3 refl = reflect(normalize(eyePos), n);
 
     vec3 d = vec3(0.0);
     vec3 s = vec3(0.0);
 
-    vec3 refl = reflect(normalize(eyePos), n);
     vec4 specular = apply_specular();
     float power = specular.a;
 
-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);
-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;
-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[0].color.rgb;
-
-    l = normalize(lightTangentSpacePositions[1].xyz);
-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[1].color).rgb;
-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb;
-
-    l = normalize(lightTangentSpacePositions[2].xyz);
-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[2].color).rgb;
-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[2].color.rgb;
-
-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;
+    float maxRange = lights[0].range;
+    float dist = length(lightTangentSpacePositions[0].xyz);
+    if (dist <= maxRange) {
+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);
+        float attenuatedColor = (lights[0].color).rgb / (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+
+    maxRange = lights[1].range;
+    dist = length(lightTangentSpacePositions[1].xyz);
+    if (dist <= maxRange) {
+        vec3 l = normalize(lightTangentSpacePositions[1].xyz);
+        float attenuatedColor = (lights[1].color).rgb / (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+
+    maxRange = lights[2].range;
+    dist = length(lightTangentSpacePositions[2].xyz);
+    if (dist <= maxRange) {
+        vec3 l = normalize(lightTangentSpacePositions[2].xyz);
+        float attenuatedColor = (lights[2].color).rgb / (lights[2].attn.x + lights[2].attn.y * dist + lights[2].attn.z * dist * dist);
+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;
+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;
+    }
+
+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;
     rez += apply_selfIllum().xyz;
 
     gl_FragColor = vec4(clamp(rez, 0.0, 1.0) , diffuse.a);
 }
diff a/tests/3DLighting/attenuation/AttenLightingSample.java b/tests/3DLighting/attenuation/AttenLightingSample.java
--- /dev/null
+++ b/tests/3DLighting/attenuation/AttenLightingSample.java
@@ -0,0 +1,42 @@
+package attenuation;
+
+import javafx.beans.property.DoubleProperty;
+import javafx.scene.PointLight;
+import javafx.scene.control.Label;
+import javafx.scene.control.Slider;
+import javafx.scene.control.TextField;
+import javafx.scene.layout.HBox;
+import javafx.scene.layout.VBox;
+import javafx.util.converter.NumberStringConverter;
+
+/**
+ * A {@code LightingSample} with additional controls for light attenuation.
+ */
+public class AttenLightingSample extends LightingSample {
+
+    @Override
+    protected VBox addLightControls(PointLight light) {
+        var vbox = super.addLightControls(light);
+        var range = createSliderControl("range", light.maxRangeProperty(), 0, 100, light.getMaxRange());
+        var c = createSliderControl("constant", light.constantAttenuationProperty(), -1, 1, light.getConstantAttenuation());
+        var lc = createSliderControl("linear", light.linearAttenuationProperty(), -1, 1, light.getLinearAttenuation());
+        var qc = createSliderControl("quadratic", light.quadraticAttenuationProperty(), -1, 1, light.getQuadraticAttenuation());
+        vbox.getChildren().addAll(range, c, lc, qc);
+        return vbox;
+    }
+
+    private HBox createSliderControl(String name, DoubleProperty property, double min, double max, double start) {
+        var slider = new Slider(min, max, start);
+        slider.setShowTickMarks(true);
+        slider.setShowTickLabels(true);
+        property.bindBidirectional(slider.valueProperty());
+        var tf = new TextField();
+        tf.textProperty().bindBidirectional(slider.valueProperty(), new NumberStringConverter());
+        tf.setMaxWidth(50);
+        return new HBox(5, new Label(name), slider, tf);
+    }
+
+    public static void main(String[] args) {
+        launch(args);
+    }
+}
diff a/tests/3DLighting/attenuation/CameraScene3D.java b/tests/3DLighting/attenuation/CameraScene3D.java
--- /dev/null
+++ b/tests/3DLighting/attenuation/CameraScene3D.java
@@ -0,0 +1,148 @@
+package attenuation;
+
+import javafx.beans.property.BooleanProperty;
+import javafx.beans.property.DoubleProperty;
+import javafx.beans.property.SimpleBooleanProperty;
+import javafx.beans.property.SimpleDoubleProperty;
+import javafx.scene.Group;
+import javafx.scene.PerspectiveCamera;
+import javafx.scene.PointLight;
+import javafx.scene.SceneAntialiasing;
+import javafx.scene.SubScene;
+import javafx.scene.input.MouseButton;
+import javafx.scene.input.ScrollEvent;
+import javafx.scene.layout.Pane;
+import javafx.scene.transform.Rotate;
+import javafx.scene.transform.Translate;
+
+class CameraScene3D extends Pane {
+
+    public DoubleProperty xPan = new SimpleDoubleProperty();
+    public DoubleProperty yPan = new SimpleDoubleProperty(-10);
+    public DoubleProperty zoom = new SimpleDoubleProperty();
+    public DoubleProperty zAngle = new SimpleDoubleProperty();
+    public DoubleProperty isometricAngle = new SimpleDoubleProperty();
+
+    public DoubleProperty panSensitivity = new SimpleDoubleProperty(1);
+    public DoubleProperty zoomSensitivity = new SimpleDoubleProperty(1);
+    public DoubleProperty zRotationSensitivity = new SimpleDoubleProperty(1);
+    public BooleanProperty isZoomTotal = new SimpleBooleanProperty();
+
+    protected PerspectiveCamera camera = new PerspectiveCamera(true);
+
+    public DoubleProperty farClip = new SimpleDoubleProperty(camera.getFarClip());
+    public DoubleProperty nearClip = new SimpleDoubleProperty(camera.getNearClip());
+    public DoubleProperty fieldOfView = new SimpleDoubleProperty(camera.getFieldOfView());
+    public BooleanProperty verticalFOV = new SimpleBooleanProperty(camera.isVerticalFieldOfView());
+
+    protected PointLight camLight = new PointLight();
+    public BooleanProperty camLightOn = new SimpleBooleanProperty(camLight.isLightOn());
+
+    public Group rootGroup = new Group();
+
+    public CameraScene3D() {
+        setupCamera();
+        createScenes();
+        setUIBindings();
+    }
+
+    private void setupCamera() {
+        Translate panTranslation = new Translate();
+        panTranslation.xProperty().bind(xPan);
+        panTranslation.yProperty().bind(yPan);
+
+        Translate zoomTranslation = new Translate();
+        zoomTranslation.zProperty().bind(zoom);
+
+        Rotate zRotation = new Rotate(0, Rotate.Y_AXIS);
+        zRotation.angleProperty().bind(zAngle);
+
+        Rotate isometricRotation = new Rotate(0, Rotate.X_AXIS);
+        isometricRotation.angleProperty().bind(isometricAngle);
+
+        camera.farClipProperty().bind(farClip);
+        camera.nearClipProperty().bind(nearClip);
+        camera.fieldOfViewProperty().bind(fieldOfView);
+        camera.verticalFieldOfViewProperty().bind(verticalFOV);
+
+        camera.getTransforms().addAll(panTranslation, zRotation, isometricRotation, zoomTranslation);
+
+        camLight.lightOnProperty().bind(camLightOn);
+        camLight.getTransforms().addAll(camera.getTransforms());
+        camLightOn.set(false);
+
+        rootGroup.getTransforms().addAll();
+        rootGroup.getChildren().add(camLight);
+        rootGroup.setId("root group");
+    }
+
+    private void createScenes() {
+        var aaScene = new SubScene(rootGroup, 0, 0, true, SceneAntialiasing.BALANCED);
+        aaScene.setCamera(camera);
+        aaScene.widthProperty().bind(widthProperty());
+        aaScene.heightProperty().bind(heightProperty());
+        aaScene.setOnMouseEntered(e -> aaScene.requestFocus());
+        getChildren().setAll(aaScene);
+    }
+
+    private double startX, startY, curX, curY;
+
+    private final void setUIBindings() {
+        setOnRotate(e -> rotate(e.getAngle()));
+        setOnZoom(e -> zoom(isZoomTotal.get() ? e.getTotalZoomFactor() : e.getZoomFactor()));
+        setOnScroll(e -> {
+            // touch scroll for moving the board
+            if (e.getEventType() == ScrollEvent.SCROLL_STARTED)
+                pan(e.getDeltaX(), e.getDeltaY());
+            // mouse scroll for zoom
+            else
+                zoom(e.getDeltaY());
+        });
+
+        setOnMousePressed(e -> {
+            startX = curX = e.getX();
+            startY = curY = e.getY();
+        });
+
+        setOnMouseDragged(e -> {
+            startX = curX;
+            startY = curY;
+            curX = e.getX();
+            curY = e.getY();
+            double deltaX = curX - startX;
+            double deltaY = curY - startY;
+            if (e.getButton() == MouseButton.PRIMARY) {
+            	pan(deltaX, deltaY);
+            } else if (e.getButton() == MouseButton.SECONDARY) {
+                boolean positiveX = curX > getWidth() / 2;
+                boolean positiveY = curY > getHeight() / 2;
+                deltaX = positiveY ? -deltaX : deltaX;
+                deltaY = positiveX ? deltaY : -deltaY;
+                rotate((deltaX + deltaY)/2);
+            }
+        });
+    }
+
+    private final double scaleFactor = 500;
+
+    private void pan(double deltaX, double deltaY) {
+        double angle = Math.toRadians(zAngle.get());
+        double cosA = Math.cos(angle);
+        double sinA = Math.sin(angle);
+        double rotatedDeltaX = deltaX *  cosA + deltaY * sinA;
+        double rotatedDeltaY = deltaX * -sinA + deltaY * cosA;
+        double panFactor = panSensitivity.get() * zoom.get() / scaleFactor;
+        double newX = xPan.get() + rotatedDeltaX * panFactor;
+        double newY = yPan.get() + rotatedDeltaY * panFactor;
+        xPan.set(newX);
+        yPan.set(newY);
+    }
+
+    private void zoom(double amount) {
+        zoom.set(zoom.get() - amount * zoomSensitivity.get() * zoom.get() / scaleFactor);
+    }
+
+    private void rotate(double amount) {
+        zAngle.set(zAngle.get() - amount * zRotationSensitivity.get());
+    }
+}
diff a/tests/3DLighting/attenuation/Environment.java b/tests/3DLighting/attenuation/Environment.java
--- /dev/null
+++ b/tests/3DLighting/attenuation/Environment.java
@@ -0,0 +1,97 @@
+package attenuation;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javafx.scene.AmbientLight;
+import javafx.scene.PointLight;
+import javafx.scene.paint.Color;
+import javafx.scene.paint.PhongMaterial;
+import javafx.scene.shape.MeshView;
+import javafx.scene.shape.Shape3D;
+import javafx.scene.shape.Sphere;
+import javafx.scene.shape.TriangleMesh;
+
+class Environment extends CameraScene3D {
+
+    private final PointLight light1 = new PointLight(Color.RED);
+    private final PointLight light2 = new PointLight(Color.BLUE);
+    private final PointLight light3 = new PointLight(Color.MAGENTA);
+    final PointLight[] lights = {light1, light2, light3};
+
+    private Shape3D currentShape;
+
+    private final AmbientLight worldLight = new AmbientLight();
+
+    Environment() {
+        farClip.set(1000);
+        zoom.set(-350);
+
+        for (var light : lights) {
+        	light.setTranslateZ(-50);
+        	var lightRep = new Sphere(2);
+        	lightRep.setMaterial(new PhongMaterial(light.getColor()));
+        	lightRep.translateXProperty().bind(light.translateXProperty());
+        	lightRep.translateYProperty().bind(light.translateYProperty());
+        	lightRep.translateZProperty().bind(light.translateZProperty());
+        	rootGroup.getChildren().addAll(light, lightRep);
+        }
+        light1.setTranslateX(40);
+        light2.setTranslateX(-40);
+        light1.setUserData("RED");
+        light2.setUserData("BLUE");
+        light3.setUserData("MAGENTA");
+
+        rootGroup.getChildren().add(worldLight);
+        rootGroup.setMouseTransparent(true);
+    }
+
+    Sphere createSphere(int subdivisions) {
+        return new Sphere(50, subdivisions);
+    }
+
+    MeshView createMeshView(int quadNum) {
+        // Points and texCoords array defining a single quad that will
+        // be referenced by all pairs of triangles in the faces array
+        final float[] points = {
+            -75.0f,  75.0f, 0.0f,
+             75.0f,  75.0f, 0.0f,
+             75.0f, -75.0f, 0.0f,
+            -75.0f, -75.0f, 0.0f
+        };
+        final float[] texCoords = {
+            0.0f, 0.0f,
+            1.0f, 0.0f,
+            1.0f, 1.0f,
+            0.0f, 1.0f
+        };
+        // List of faces defining a single quad (pair of triangles).
+        // This is replicated for the desired number of quads
+        var face = List.of(
+            0, 0, 1, 1, 2, 2,
+            0, 0, 2, 2, 3, 3
+        );
+
+        var faces = new ArrayList<Integer>(quadNum * face.size());
+        for (int i = 0; i < quadNum; i++) {
+            faces.addAll(face);
+        }
+
+        var mesh = new TriangleMesh();
+        mesh.getPoints().setAll(points);
+        mesh.getTexCoords().setAll(texCoords);
+        int[] array = faces.stream().mapToInt(i -> i).toArray();
+        mesh.getFaces().setAll(array);
+
+        var mv = new MeshView(mesh);
+        return mv;
+    }
+
+    void switchTo(Shape3D node) {
+        worldLight.getExclusionScope().remove(currentShape);
+        worldLight.getExclusionScope().add(node);
+        rootGroup.getChildren().remove(currentShape);
+        rootGroup.getChildren().add(node);
+        currentShape = node;
+    }
+}
diff a/tests/3DLighting/attenuation/FPSCounter.java b/tests/3DLighting/attenuation/FPSCounter.java
--- /dev/null
+++ b/tests/3DLighting/attenuation/FPSCounter.java
@@ -0,0 +1,62 @@
+package attenuation;
+
+import javafx.animation.AnimationTimer;
+
+final class FPSCounter extends AnimationTimer {
+
+    private int skipFrames = 100;
+    private long lastTime = -1;
+    private long elapsedTime;
+    private int elapsedFrames;
+    private long totalElapsedTime;
+    private int totalElapsedFrames;
+
+    @Override
+    public void handle(long now) {
+        if (skipFrames > 0) {
+            --skipFrames;
+            return;
+        }
+
+        if (lastTime < 0) {
+            lastTime = System.nanoTime();
+            elapsedTime = 0;
+            elapsedFrames = 0;
+            totalElapsedTime = 0;
+            totalElapsedFrames = 0;
+            return;
+        }
+
+        long currTime = System.nanoTime();
+        elapsedTime += currTime - lastTime;
+        elapsedFrames += 1;
+        totalElapsedTime += currTime - lastTime;
+        totalElapsedFrames += 1;
+
+        double elapsedSeconds = (double) elapsedTime / 1e9;
+        double totalElapsedSeconds = (double) totalElapsedTime / 1e9;
+        if (elapsedSeconds >= 5.0) {
+            double fps = elapsedFrames / elapsedSeconds;
+            System.out.println();
+            System.out.println("instant fps: " + fps);
+            double avgFps = totalElapsedFrames / totalElapsedSeconds;
+            System.out.println("average fps: " + avgFps);
+            System.out.flush();
+            elapsedTime = 0;
+            elapsedFrames = 0;
+        }
+
+        lastTime = currTime;
+    }
+
+    void reset() {
+        skipFrames = 100;
+        lastTime = -1;
+        elapsedTime = 0;
+        elapsedFrames = 0;
+        totalElapsedTime = 0;
+        totalElapsedFrames = 0;
+        System.out.println();
+        System.out.println(" --------------------- ");
+    }
+}
diff a/tests/3DLighting/attenuation/LightingSample.java b/tests/3DLighting/attenuation/LightingSample.java
--- /dev/null
+++ b/tests/3DLighting/attenuation/LightingSample.java
@@ -0,0 +1,108 @@
+package attenuation;
+
+import javafx.animation.Animation;
+import javafx.animation.TranslateTransition;
+import javafx.application.Application;
+import javafx.scene.PointLight;
+import javafx.scene.Scene;
+import javafx.scene.control.Button;
+import javafx.scene.control.CheckBox;
+import javafx.scene.control.Label;
+import javafx.scene.control.Separator;
+import javafx.scene.control.Slider;
+import javafx.scene.layout.HBox;
+import javafx.scene.layout.Priority;
+import javafx.scene.layout.VBox;
+import javafx.scene.shape.Shape3D;
+import javafx.stage.Stage;
+import javafx.util.Duration;
+import javafx.util.converter.NumberStringConverter;
+
+/**
+ * A sample application for measuring FPS for various 3D nodes with environmental lighting.
+ * <p>
+ * <b>Important</b>: make sure that no other application on your system is rendering heavy graphics, like videos, to a screen,
+ * as this will corrupt the measurement. 
+ */
+public class LightingSample extends Application {
+
+    private final Environment environment = new Environment();
+    private final TranslateTransition animation = createAnimation();
+    private final FPSCounter fpsCouner = new FPSCounter();
+
+    @Override
+    public void start(Stage stage) throws Exception {
+        environment.setStyle("-fx-background-color: teal");
+
+        var subdivisionSlider = new Slider(10, 200, 60);
+        subdivisionSlider.setMajorTickUnit(10);
+        setupSlier(subdivisionSlider);
+
+        var subdivisionLabel = new Label();
+        subdivisionLabel.textProperty().bindBidirectional(subdivisionSlider.valueProperty(), new NumberStringConverter("#"));
+
+        var sphere = new Button("Sphere");
+        sphere.setOnAction(e -> switchTo(environment.createSphere((int) subdivisionSlider.getValue())));
+
+        var quadSlider = new Slider(500, 10_000, 1000);
+        quadSlider.setMajorTickUnit(500);
+        setupSlier(quadSlider);
+
+        var quadLabel = new Label();
+        quadLabel.textProperty().bindBidirectional(quadSlider.valueProperty(), new NumberStringConverter("#"));
+
+        var mesh = new Button("Mesh");
+        mesh.setOnAction(e -> switchTo(environment.createMeshView((int) quadSlider.getValue())));
+
+        var sphereBox = new HBox(sphere, subdivisionSlider, subdivisionLabel);
+        var meshBox = new HBox(mesh, quadSlider, quadLabel);
+
+        var controls = new VBox(sphereBox, meshBox);
+        for (var light : environment.lights) {
+        	controls.getChildren().add(addLightControls(light));
+        }
+
+        var hBox = new HBox(controls, environment);
+        HBox.setHgrow(environment, Priority.ALWAYS);
+        stage.setScene(new Scene(hBox));
+        stage.setWidth(1100);
+        stage.setHeight(735);
+        stage.show();
+    }
+
+    private void setupSlier(Slider slider) {
+        slider.setMinorTickCount(0);
+        slider.setShowTickLabels(true);
+        slider.setShowTickMarks(true);
+        slider.setSnapToTicks(true);
+    }
+
+    protected VBox addLightControls(PointLight light) {
+    	var lightOn = new CheckBox("On/Off");
+    	lightOn.setSelected(true);
+    	light.lightOnProperty().bind(lightOn.selectedProperty());
+        return new VBox(new Separator(), new Label(light.getUserData() + " light"), lightOn);
+    }
+
+   private TranslateTransition createAnimation() {
+        var anim = new TranslateTransition(Duration.seconds(2));
+        anim.setAutoReverse(true);
+        anim.setCycleCount(Animation.INDEFINITE);
+        anim.setFromZ(150);
+        anim.setToZ(0);
+        return anim;
+    }
+
+    private void switchTo(Shape3D node) {
+        fpsCouner.stop();
+        fpsCouner.reset();
+        environment.switchTo(node);
+        animation.setNode(node);
+        animation.playFromStart();
+        fpsCouner.start();
+    }
+
+    public static void main(String[] args) {
+        launch(args);
+    }
+}
