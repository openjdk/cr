<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *               &lt;2006,2011&gt; Stefan Kost &lt;ensonic@users.sf.net&gt;
   4  *               &lt;2007-2009&gt; Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 /**
  22  * SECTION:element-spectrum
  23  *
  24  * The Spectrum element analyzes the frequency spectrum of an audio signal.
  25  * If the #GstSpectrum:post-messages property is %TRUE, it sends analysis results
  26  * as element messages named
  27  * &lt;classname&gt;&amp;quot;spectrum&amp;quot;&lt;/classname&gt; after each interval of time given
  28  * by the #GstSpectrum:interval property.
  29  *
  30  * The message&#39;s structure contains some combination of these fields:
  31  * &lt;itemizedlist&gt;
  32  * &lt;listitem&gt;
  33  *   &lt;para&gt;
  34  *   #GstClockTime
  35  *   &lt;classname&gt;&amp;quot;timestamp&amp;quot;&lt;/classname&gt;:
  36  *   the timestamp of the buffer that triggered the message.
  37  *   &lt;/para&gt;
  38  * &lt;/listitem&gt;
  39  * &lt;listitem&gt;
  40  *   &lt;para&gt;
  41  *   #GstClockTime
  42  *   &lt;classname&gt;&amp;quot;stream-time&amp;quot;&lt;/classname&gt;:
  43  *   the stream time of the buffer.
  44  *   &lt;/para&gt;
  45  * &lt;/listitem&gt;
  46  * &lt;listitem&gt;
  47  *   &lt;para&gt;
  48  *   #GstClockTime
  49  *   &lt;classname&gt;&amp;quot;running-time&amp;quot;&lt;/classname&gt;:
  50  *   the running_time of the buffer.
  51  *   &lt;/para&gt;
  52  * &lt;/listitem&gt;
  53  * &lt;listitem&gt;
  54  *   &lt;para&gt;
  55  *   #GstClockTime
  56  *   &lt;classname&gt;&amp;quot;duration&amp;quot;&lt;/classname&gt;:
  57  *   the duration of the buffer.
  58  *   &lt;/para&gt;
  59  * &lt;/listitem&gt;
  60  * &lt;listitem&gt;
  61  *   &lt;para&gt;
  62  *   #GstClockTime
  63  *   &lt;classname&gt;&amp;quot;endtime&amp;quot;&lt;/classname&gt;:
  64  *   the end time of the buffer that triggered the message as stream time (this
  65  *   is deprecated, as it can be calculated from stream-time + duration)
  66  *   &lt;/para&gt;
  67  * &lt;/listitem&gt;
  68  * &lt;listitem&gt;
  69  *   &lt;para&gt;
  70  *   #GstValueList of #gfloat
  71  *   &lt;classname&gt;&amp;quot;magnitude&amp;quot;&lt;/classname&gt;:
  72  *   the level for each frequency band in dB. All values below the value of the
  73  *   #GstSpectrum:threshold property will be set to the threshold. Only present
  74  *   if the #GstSpectrum:message-magnitude property is %TRUE.
  75  *   &lt;/para&gt;
  76  * &lt;/listitem&gt;
  77  * &lt;listitem&gt;
  78  *   &lt;para&gt;
  79  *   #GstValueList of #gfloat
  80  *   &lt;classname&gt;&amp;quot;phase&amp;quot;&lt;/classname&gt;:
  81  *   The phase for each frequency band. The value is between -pi and pi. Only
  82  *   present if the #GstSpectrum:message-phase property is %TRUE.
  83  *   &lt;/para&gt;
  84  * &lt;/listitem&gt;
  85  * &lt;/itemizedlist&gt;
  86  *
  87  * If #GstSpectrum:multi-channel property is set to true. magnitude and phase
  88  * fields will be each a nested #GstValueArray. The first dimension are the
  89  * channels and the second dimension are the values.
  90  *
  91  * &lt;refsect2&gt;
  92  * &lt;title&gt;Example application&lt;/title&gt;
  93  * &lt;informalexample&gt;&lt;programlisting language=&quot;C&quot;&gt;
  94  * &lt;xi:include xmlns:xi=&quot;http://www.w3.org/2003/XInclude&quot; parse=&quot;text&quot; href=&quot;../../../../tests/examples/spectrum/spectrum-example.c&quot; /&gt;
  95  * &lt;/programlisting&gt;&lt;/informalexample&gt;
  96  * &lt;/refsect2&gt;
  97  */
  98 
  99 #ifdef HAVE_CONFIG_H
 100 #include &quot;config.h&quot;
 101 #endif
 102 
 103 #include &lt;string.h&gt;
 104 #include &lt;math.h&gt;
 105 #include &quot;gstspectrum.h&quot;
 106 
 107 GST_DEBUG_CATEGORY_STATIC (gst_spectrum_debug);
 108 #define GST_CAT_DEFAULT gst_spectrum_debug
 109 
 110 /* elementfactory information */
 111 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 112 # define FORMATS &quot;{ S16LE, S24LE, S32LE, F32LE, F64LE }&quot;
 113 #else
 114 # define FORMATS &quot;{ S16BE, S24BE, S32BE, F32BE, F64BE }&quot;
 115 #endif
 116 
 117 #ifdef GSTREAMER_LITE
 118 #define MAX_BANDS    1024
 119 #endif // GSTREAMER_LITE
 120 
 121 #define ALLOWED_CAPS \
 122   GST_AUDIO_CAPS_MAKE (FORMATS) &quot;, &quot; \
 123   &quot;layout = (string) interleaved&quot;
 124 
 125 /* Spectrum properties */
 126 #define DEFAULT_POST_MESSAGES         TRUE
 127 #define DEFAULT_MESSAGE_MAGNITUDE TRUE
 128 #define DEFAULT_MESSAGE_PHASE   FALSE
 129 #define DEFAULT_INTERVAL    (GST_SECOND / 10)
 130 #define DEFAULT_BANDS     128
 131 #define DEFAULT_THRESHOLD   -60
 132 #define DEFAULT_MULTI_CHANNEL   FALSE
 133 
 134 enum
 135 {
 136   PROP_0,
 137   PROP_POST_MESSAGES,
 138   PROP_MESSAGE_MAGNITUDE,
 139   PROP_MESSAGE_PHASE,
 140   PROP_INTERVAL,
 141   PROP_BANDS,
 142   PROP_THRESHOLD,
 143   PROP_MULTI_CHANNEL
 144 };
 145 
 146 #define gst_spectrum_parent_class parent_class
 147 G_DEFINE_TYPE (GstSpectrum, gst_spectrum, GST_TYPE_AUDIO_FILTER);
 148 
 149 static void gst_spectrum_finalize (GObject * object);
 150 static void gst_spectrum_set_property (GObject * object, guint prop_id,
 151     const GValue * value, GParamSpec * pspec);
 152 static void gst_spectrum_get_property (GObject * object, guint prop_id,
 153     GValue * value, GParamSpec * pspec);
 154 static gboolean gst_spectrum_start (GstBaseTransform * trans);
 155 static gboolean gst_spectrum_stop (GstBaseTransform * trans);
 156 static GstFlowReturn gst_spectrum_transform_ip (GstBaseTransform * trans,
 157     GstBuffer * in);
 158 static gboolean gst_spectrum_setup (GstAudioFilter * base,
 159     const GstAudioInfo * info);
 160 
<a name="1" id="anc1"></a><span class="line-added"> 161 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)</span>
<span class="line-added"> 162 gboolean gst_spectrum_setup_api (GstAudioFilter * base, const GstAudioInfo * info,</span>
<span class="line-added"> 163                                  guint bps_user, guint bpf_user) {</span>
<span class="line-added"> 164     GstSpectrum *spectrum = GST_SPECTRUM (base);</span>
<span class="line-added"> 165     spectrum-&gt;bps_user = bps_user;</span>
<span class="line-added"> 166     spectrum-&gt;bpf_user = bpf_user;</span>
<span class="line-added"> 167     return gst_spectrum_setup(base, info);</span>
<span class="line-added"> 168 }</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170 GstFlowReturn</span>
<span class="line-added"> 171 gst_spectrum_transform_ip_api (GstBaseTransform * trans, GstBuffer * buffer) {</span>
<span class="line-added"> 172     return gst_spectrum_transform_ip(trans, buffer);</span>
<span class="line-added"> 173 }</span>
<span class="line-added"> 174 #endif // GSTREAMER_LITE and OSX</span>
<span class="line-added"> 175 </span>
 176 static void
 177 gst_spectrum_class_init (GstSpectrumClass * klass)
 178 {
 179   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 180   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 181   GstBaseTransformClass *trans_class = GST_BASE_TRANSFORM_CLASS (klass);
 182   GstAudioFilterClass *filter_class = GST_AUDIO_FILTER_CLASS (klass);
 183   GstCaps *caps;
 184 
 185   gobject_class-&gt;set_property = gst_spectrum_set_property;
 186   gobject_class-&gt;get_property = gst_spectrum_get_property;
 187   gobject_class-&gt;finalize = gst_spectrum_finalize;
 188 
 189   trans_class-&gt;start = GST_DEBUG_FUNCPTR (gst_spectrum_start);
 190   trans_class-&gt;stop = GST_DEBUG_FUNCPTR (gst_spectrum_stop);
 191   trans_class-&gt;transform_ip = GST_DEBUG_FUNCPTR (gst_spectrum_transform_ip);
 192   trans_class-&gt;passthrough_on_same_caps = TRUE;
 193 
 194   filter_class-&gt;setup = GST_DEBUG_FUNCPTR (gst_spectrum_setup);
 195 
 196   g_object_class_install_property (gobject_class, PROP_POST_MESSAGES,
 197       g_param_spec_boolean (&quot;post-messages&quot;, &quot;Post Messages&quot;,
 198           &quot;Whether to post a &#39;spectrum&#39; element message on the bus for each &quot;
 199           &quot;passed interval&quot;, DEFAULT_POST_MESSAGES,
 200           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 201 
 202   g_object_class_install_property (gobject_class, PROP_MESSAGE_MAGNITUDE,
 203       g_param_spec_boolean (&quot;message-magnitude&quot;, &quot;Magnitude&quot;,
 204           &quot;Whether to add a &#39;magnitude&#39; field to the structure of any &quot;
 205           &quot;&#39;spectrum&#39; element messages posted on the bus&quot;,
 206           DEFAULT_MESSAGE_MAGNITUDE,
 207           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 208 
 209   g_object_class_install_property (gobject_class, PROP_MESSAGE_PHASE,
 210       g_param_spec_boolean (&quot;message-phase&quot;, &quot;Phase&quot;,
 211           &quot;Whether to add a &#39;phase&#39; field to the structure of any &quot;
 212           &quot;&#39;spectrum&#39; element messages posted on the bus&quot;,
 213           DEFAULT_MESSAGE_PHASE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 214 
 215   g_object_class_install_property (gobject_class, PROP_INTERVAL,
 216       g_param_spec_uint64 (&quot;interval&quot;, &quot;Interval&quot;,
 217           &quot;Interval of time between message posts (in nanoseconds)&quot;,
 218           1, G_MAXUINT64, DEFAULT_INTERVAL,
 219           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 220 
 221 #ifdef GSTREAMER_LITE
 222   g_object_class_install_property (gobject_class, PROP_BANDS,
 223       g_param_spec_uint (&quot;bands&quot;, &quot;Bands&quot;, &quot;Number of frequency bands&quot;,
 224           0, MAX_BANDS, DEFAULT_BANDS,
 225           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 226 #else
 227   g_object_class_install_property (gobject_class, PROP_BANDS,
 228       g_param_spec_uint (&quot;bands&quot;, &quot;Bands&quot;, &quot;Number of frequency bands&quot;,
 229           2, ((guint) G_MAXINT + 2) / 2, DEFAULT_BANDS,
 230           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 231 #endif // GSTREAMER_LITE
 232 
 233   g_object_class_install_property (gobject_class, PROP_THRESHOLD,
 234       g_param_spec_int (&quot;threshold&quot;, &quot;Threshold&quot;,
 235           &quot;dB threshold for result. All lower values will be set to this&quot;,
 236           G_MININT, 0, DEFAULT_THRESHOLD,
 237           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 238 
 239   g_object_class_install_property (gobject_class, PROP_MULTI_CHANNEL,
 240       g_param_spec_boolean (&quot;multi-channel&quot;, &quot;Multichannel results&quot;,
 241           &quot;Send separate results for each channel&quot;,
 242           DEFAULT_MULTI_CHANNEL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 243 
 244   GST_DEBUG_CATEGORY_INIT (gst_spectrum_debug, &quot;spectrum&quot;, 0,
 245       &quot;audio spectrum analyser element&quot;);
 246 
 247   gst_element_class_set_static_metadata (element_class, &quot;Spectrum analyzer&quot;,
 248       &quot;Filter/Analyzer/Audio&quot;,
 249       &quot;Run an FFT on the audio signal, output spectrum data&quot;,
 250       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;, &quot;
 251       &quot;Stefan Kost &lt;ensonic@users.sf.net&gt;, &quot;
 252       &quot;Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;&quot;);
 253 
 254   caps = gst_caps_from_string (ALLOWED_CAPS);
 255   gst_audio_filter_class_add_pad_templates (filter_class, caps);
 256   gst_caps_unref (caps);
 257 }
 258 
 259 static void
 260 gst_spectrum_init (GstSpectrum * spectrum)
 261 {
 262   spectrum-&gt;post_messages = DEFAULT_POST_MESSAGES;
 263   spectrum-&gt;message_magnitude = DEFAULT_MESSAGE_MAGNITUDE;
 264   spectrum-&gt;message_phase = DEFAULT_MESSAGE_PHASE;
 265   spectrum-&gt;interval = DEFAULT_INTERVAL;
 266   spectrum-&gt;bands = DEFAULT_BANDS;
 267   spectrum-&gt;threshold = DEFAULT_THRESHOLD;
 268 
<a name="2" id="anc2"></a><span class="line-added"> 269 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)</span>
<span class="line-added"> 270   spectrum-&gt;bps_user = 0;</span>
<span class="line-added"> 271   spectrum-&gt;bpf_user = 0;</span>
<span class="line-added"> 272   spectrum-&gt;user_data = NULL;</span>
<span class="line-added"> 273 #endif // GSTREAMER_LITE and OSX</span>
<span class="line-added"> 274 </span>
 275   g_mutex_init (&amp;spectrum-&gt;lock);
 276 }
 277 
 278 static void
 279 gst_spectrum_alloc_channel_data (GstSpectrum * spectrum)
 280 {
 281   gint i;
 282   GstSpectrumChannel *cd;
 283   guint bands = spectrum-&gt;bands;
 284   guint nfft = 2 * bands - 2;
 285 
 286   g_assert (spectrum-&gt;channel_data == NULL);
 287 
 288   spectrum-&gt;num_channels = (spectrum-&gt;multi_channel) ?
 289       GST_AUDIO_FILTER_CHANNELS (spectrum) : 1;
 290 
 291   GST_DEBUG_OBJECT (spectrum, &quot;allocating data for %d channels&quot;,
 292       spectrum-&gt;num_channels);
 293 
 294   spectrum-&gt;channel_data = g_new (GstSpectrumChannel, spectrum-&gt;num_channels);
 295   for (i = 0; i &lt; spectrum-&gt;num_channels; i++) {
 296     cd = &amp;spectrum-&gt;channel_data[i];
 297     cd-&gt;fft_ctx = gst_fft_f32_new (nfft, FALSE);
 298     cd-&gt;input = g_new0 (gfloat, nfft);
 299     cd-&gt;input_tmp = g_new0 (gfloat, nfft);
 300     cd-&gt;freqdata = g_new0 (GstFFTF32Complex, bands);
 301     cd-&gt;spect_magnitude = g_new0 (gfloat, bands);
 302     cd-&gt;spect_phase = g_new0 (gfloat, bands);
 303   }
 304 }
 305 
 306 static void
 307 gst_spectrum_free_channel_data (GstSpectrum * spectrum)
 308 {
 309   if (spectrum-&gt;channel_data) {
 310     gint i;
 311     GstSpectrumChannel *cd;
 312 
 313     GST_DEBUG_OBJECT (spectrum, &quot;freeing data for %d channels&quot;,
 314         spectrum-&gt;num_channels);
 315 
 316     for (i = 0; i &lt; spectrum-&gt;num_channels; i++) {
 317       cd = &amp;spectrum-&gt;channel_data[i];
 318       if (cd-&gt;fft_ctx)
 319         gst_fft_f32_free (cd-&gt;fft_ctx);
 320       g_free (cd-&gt;input);
 321       g_free (cd-&gt;input_tmp);
 322       g_free (cd-&gt;freqdata);
 323       g_free (cd-&gt;spect_magnitude);
 324       g_free (cd-&gt;spect_phase);
 325     }
 326     g_free (spectrum-&gt;channel_data);
 327     spectrum-&gt;channel_data = NULL;
 328   }
 329 }
 330 
 331 static void
 332 gst_spectrum_flush (GstSpectrum * spectrum)
 333 {
 334   spectrum-&gt;num_frames = 0;
 335   spectrum-&gt;num_fft = 0;
 336 
 337   spectrum-&gt;accumulated_error = 0;
 338 #ifdef GSTREAMER_LITE
 339   spectrum-&gt;input_pos = 0;
 340 #endif // GSTREAMER_LITE
 341 }
 342 
 343 static void
 344 gst_spectrum_reset_state (GstSpectrum * spectrum)
 345 {
 346   GST_DEBUG_OBJECT (spectrum, &quot;resetting state&quot;);
 347 
 348   gst_spectrum_free_channel_data (spectrum);
 349   gst_spectrum_flush (spectrum);
 350 }
 351 
 352 static void
 353 gst_spectrum_finalize (GObject * object)
 354 {
 355   GstSpectrum *spectrum = GST_SPECTRUM (object);
 356 
 357   gst_spectrum_reset_state (spectrum);
 358   g_mutex_clear (&amp;spectrum-&gt;lock);
 359 
 360   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 361 }
 362 
 363 static void
 364 gst_spectrum_set_property (GObject * object, guint prop_id,
 365     const GValue * value, GParamSpec * pspec)
 366 {
 367   GstSpectrum *filter = GST_SPECTRUM (object);
 368 
 369   switch (prop_id) {
 370     case PROP_POST_MESSAGES:
 371       filter-&gt;post_messages = g_value_get_boolean (value);
 372       break;
 373     case PROP_MESSAGE_MAGNITUDE:
 374       filter-&gt;message_magnitude = g_value_get_boolean (value);
 375       break;
 376     case PROP_MESSAGE_PHASE:
 377       filter-&gt;message_phase = g_value_get_boolean (value);
 378       break;
 379     case PROP_INTERVAL:{
 380       guint64 interval = g_value_get_uint64 (value);
 381       g_mutex_lock (&amp;filter-&gt;lock);
 382       if (filter-&gt;interval != interval) {
 383         filter-&gt;interval = interval;
 384         gst_spectrum_reset_state (filter);
 385       }
 386       g_mutex_unlock (&amp;filter-&gt;lock);
 387       break;
 388     }
 389     case PROP_BANDS:{
 390       guint bands = g_value_get_uint (value);
 391       g_mutex_lock (&amp;filter-&gt;lock);
 392       if (filter-&gt;bands != bands) {
 393         filter-&gt;bands = bands;
 394         gst_spectrum_reset_state (filter);
 395       }
 396       g_mutex_unlock (&amp;filter-&gt;lock);
 397       break;
 398     }
 399     case PROP_THRESHOLD:
 400       filter-&gt;threshold = g_value_get_int (value);
 401       break;
 402     case PROP_MULTI_CHANNEL:{
 403       gboolean multi_channel = g_value_get_boolean (value);
 404       g_mutex_lock (&amp;filter-&gt;lock);
 405       if (filter-&gt;multi_channel != multi_channel) {
 406         filter-&gt;multi_channel = multi_channel;
 407         gst_spectrum_reset_state (filter);
 408       }
 409       g_mutex_unlock (&amp;filter-&gt;lock);
 410       break;
 411     }
 412     default:
 413       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 414       break;
 415   }
 416 }
 417 
 418 static void
 419 gst_spectrum_get_property (GObject * object, guint prop_id,
 420     GValue * value, GParamSpec * pspec)
 421 {
 422   GstSpectrum *filter = GST_SPECTRUM (object);
 423 
 424   switch (prop_id) {
 425     case PROP_POST_MESSAGES:
 426       g_value_set_boolean (value, filter-&gt;post_messages);
 427       break;
 428     case PROP_MESSAGE_MAGNITUDE:
 429       g_value_set_boolean (value, filter-&gt;message_magnitude);
 430       break;
 431     case PROP_MESSAGE_PHASE:
 432       g_value_set_boolean (value, filter-&gt;message_phase);
 433       break;
 434     case PROP_INTERVAL:
 435       g_value_set_uint64 (value, filter-&gt;interval);
 436       break;
 437     case PROP_BANDS:
 438       g_value_set_uint (value, filter-&gt;bands);
 439       break;
 440     case PROP_THRESHOLD:
 441       g_value_set_int (value, filter-&gt;threshold);
 442       break;
 443     case PROP_MULTI_CHANNEL:
 444       g_value_set_boolean (value, filter-&gt;multi_channel);
 445       break;
 446     default:
 447       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 448       break;
 449   }
 450 }
 451 
 452 static gboolean
 453 gst_spectrum_start (GstBaseTransform * trans)
 454 {
 455   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 456 
 457   gst_spectrum_reset_state (spectrum);
 458 
 459   return TRUE;
 460 }
 461 
 462 static gboolean
 463 gst_spectrum_stop (GstBaseTransform * trans)
 464 {
 465   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 466 
 467   gst_spectrum_reset_state (spectrum);
 468 
 469   return TRUE;
 470 }
 471 
 472 /* mixing data readers */
 473 
 474 static void
 475 input_data_mixed_float (const guint8 * _in, gfloat * out, guint len,
 476     guint channels, gfloat max_value, guint op, guint nfft)
 477 {
 478   guint i, j, ip = 0;
 479   gfloat v;
 480   gfloat *in = (gfloat *) _in;
 481 
 482   for (j = 0; j &lt; len; j++) {
 483     v = in[ip++];
 484     for (i = 1; i &lt; channels; i++)
 485       v += in[ip++];
 486     out[op] = v / channels;
 487     op = (op + 1) % nfft;
 488   }
 489 }
 490 
 491 static void
 492 input_data_mixed_double (const guint8 * _in, gfloat * out, guint len,
 493     guint channels, gfloat max_value, guint op, guint nfft)
 494 {
 495   guint i, j, ip = 0;
 496   gfloat v;
 497   gdouble *in = (gdouble *) _in;
 498 
 499   for (j = 0; j &lt; len; j++) {
 500     v = in[ip++];
 501     for (i = 1; i &lt; channels; i++)
 502       v += in[ip++];
 503     out[op] = v / channels;
 504     op = (op + 1) % nfft;
 505   }
 506 }
 507 
 508 static void
 509 input_data_mixed_int32_max (const guint8 * _in, gfloat * out, guint len,
 510     guint channels, gfloat max_value, guint op, guint nfft)
 511 {
 512   guint i, j, ip = 0;
 513   gint32 *in = (gint32 *) _in;
 514   gfloat v;
 515 
 516   for (j = 0; j &lt; len; j++) {
 517     v = in[ip++] / max_value;
 518     for (i = 1; i &lt; channels; i++)
 519       v += in[ip++] / max_value;
 520     out[op] = v / channels;
 521     op = (op + 1) % nfft;
 522   }
 523 }
 524 
 525 static void
 526 input_data_mixed_int24_max (const guint8 * _in, gfloat * out, guint len,
 527     guint channels, gfloat max_value, guint op, guint nfft)
 528 {
 529   guint i, j;
 530   gfloat v = 0.0;
 531 
 532   for (j = 0; j &lt; len; j++) {
 533     for (i = 0; i &lt; channels; i++) {
 534 #if G_BYTE_ORDER == G_BIG_ENDIAN
 535       gint32 value = GST_READ_UINT24_BE (_in);
 536 #else
 537       gint32 value = GST_READ_UINT24_LE (_in);
 538 #endif
 539       if (value &amp; 0x00800000)
 540         value |= 0xff000000;
 541       v += value / max_value;
 542       _in += 3;
 543     }
 544     out[op] = v / channels;
 545     op = (op + 1) % nfft;
 546   }
 547 }
 548 
 549 static void
 550 input_data_mixed_int16_max (const guint8 * _in, gfloat * out, guint len,
 551     guint channels, gfloat max_value, guint op, guint nfft)
 552 {
 553   guint i, j, ip = 0;
 554   gint16 *in = (gint16 *) _in;
 555   gfloat v;
 556 
 557   for (j = 0; j &lt; len; j++) {
 558     v = in[ip++] / max_value;
 559     for (i = 1; i &lt; channels; i++)
 560       v += in[ip++] / max_value;
 561     out[op] = v / channels;
 562     op = (op + 1) % nfft;
 563   }
 564 }
 565 
 566 /* non mixing data readers */
 567 
 568 static void
 569 input_data_float (const guint8 * _in, gfloat * out, guint len, guint channels,
 570     gfloat max_value, guint op, guint nfft)
 571 {
 572   guint j, ip;
 573   gfloat *in = (gfloat *) _in;
 574 
 575   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 576     out[op] = in[ip];
 577     op = (op + 1) % nfft;
 578   }
 579 }
 580 
 581 static void
 582 input_data_double (const guint8 * _in, gfloat * out, guint len, guint channels,
 583     gfloat max_value, guint op, guint nfft)
 584 {
 585   guint j, ip;
 586   gdouble *in = (gdouble *) _in;
 587 
 588   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 589     out[op] = in[ip];
 590     op = (op + 1) % nfft;
 591   }
 592 }
 593 
 594 static void
 595 input_data_int32_max (const guint8 * _in, gfloat * out, guint len,
 596     guint channels, gfloat max_value, guint op, guint nfft)
 597 {
 598   guint j, ip;
 599   gint32 *in = (gint32 *) _in;
 600 
 601   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 602     out[op] = in[ip] / max_value;
 603     op = (op + 1) % nfft;
 604   }
 605 }
 606 
 607 static void
 608 input_data_int24_max (const guint8 * _in, gfloat * out, guint len,
 609     guint channels, gfloat max_value, guint op, guint nfft)
 610 {
 611   guint j;
 612 
 613   for (j = 0; j &lt; len; j++) {
 614 #if G_BYTE_ORDER == G_BIG_ENDIAN
 615     gint32 v = GST_READ_UINT24_BE (_in);
 616 #else
 617     gint32 v = GST_READ_UINT24_LE (_in);
 618 #endif
 619     if (v &amp; 0x00800000)
 620       v |= 0xff000000;
 621     _in += 3 * channels;
 622     out[op] = v / max_value;
 623     op = (op + 1) % nfft;
 624   }
 625 }
 626 
 627 static void
 628 input_data_int16_max (const guint8 * _in, gfloat * out, guint len,
 629     guint channels, gfloat max_value, guint op, guint nfft)
 630 {
 631   guint j, ip;
 632   gint16 *in = (gint16 *) _in;
 633 
 634   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 635     out[op] = in[ip] / max_value;
 636     op = (op + 1) % nfft;
 637   }
 638 }
 639 
 640 static gboolean
 641 gst_spectrum_setup (GstAudioFilter * base, const GstAudioInfo * info)
 642 {
 643   GstSpectrum *spectrum = GST_SPECTRUM (base);
 644   gboolean multi_channel = spectrum-&gt;multi_channel;
 645   GstSpectrumInputData input_data = NULL;
 646 
 647   g_mutex_lock (&amp;spectrum-&gt;lock);
 648   switch (GST_AUDIO_INFO_FORMAT (info)) {
 649     case GST_AUDIO_FORMAT_S16:
 650       input_data =
 651           multi_channel ? input_data_int16_max : input_data_mixed_int16_max;
 652       break;
 653     case GST_AUDIO_FORMAT_S24:
 654       input_data =
 655           multi_channel ? input_data_int24_max : input_data_mixed_int24_max;
 656       break;
 657     case GST_AUDIO_FORMAT_S32:
 658       input_data =
 659           multi_channel ? input_data_int32_max : input_data_mixed_int32_max;
 660       break;
 661     case GST_AUDIO_FORMAT_F32:
 662       input_data = multi_channel ? input_data_float : input_data_mixed_float;
 663       break;
 664     case GST_AUDIO_FORMAT_F64:
 665       input_data = multi_channel ? input_data_double : input_data_mixed_double;
 666       break;
 667     default:
 668       g_assert_not_reached ();
 669       break;
 670   }
 671   spectrum-&gt;input_data = input_data;
 672 
 673   gst_spectrum_reset_state (spectrum);
 674   g_mutex_unlock (&amp;spectrum-&gt;lock);
 675 
 676   return TRUE;
 677 }
 678 
 679 static GValue *
 680 gst_spectrum_message_add_container (GstStructure * s, GType type,
 681     const gchar * name)
 682 {
 683   GValue v = { 0, };
 684 
 685   g_value_init (&amp;v, type);
 686   /* will copy-by-value */
 687   gst_structure_set_value (s, name, &amp;v);
 688   g_value_unset (&amp;v);
 689   return (GValue *) gst_structure_get_value (s, name);
 690 }
 691 
 692 static void
 693 gst_spectrum_message_add_list (GValue * cv, gfloat * data, guint num_values)
 694 {
 695   GValue v = { 0, };
 696   guint i;
 697 
 698   g_value_init (&amp;v, G_TYPE_FLOAT);
 699   for (i = 0; i &lt; num_values; i++) {
 700     g_value_set_float (&amp;v, data[i]);
 701     gst_value_list_append_value (cv, &amp;v);       /* copies by value */
 702   }
 703   g_value_unset (&amp;v);
 704 }
 705 
 706 static void
 707 gst_spectrum_message_add_array (GValue * cv, gfloat * data, guint num_values)
 708 {
 709   GValue v = { 0, };
 710   GValue a = { 0, };
 711   guint i;
 712 
 713   g_value_init (&amp;a, GST_TYPE_ARRAY);
 714 
 715   g_value_init (&amp;v, G_TYPE_FLOAT);
 716   for (i = 0; i &lt; num_values; i++) {
 717     g_value_set_float (&amp;v, data[i]);
 718     gst_value_array_append_value (&amp;a, &amp;v);      /* copies by value */
 719   }
 720   g_value_unset (&amp;v);
 721 
 722   gst_value_array_append_value (cv, &amp;a);        /* copies by value */
 723   g_value_unset (&amp;a);
 724 }
 725 
 726 static GstMessage *
 727 gst_spectrum_message_new (GstSpectrum * spectrum, GstClockTime timestamp,
 728     GstClockTime duration)
 729 {
 730   GstBaseTransform *trans = GST_BASE_TRANSFORM_CAST (spectrum);
 731   GstSpectrumChannel *cd;
 732   GstStructure *s;
 733   GValue *mcv = NULL, *pcv = NULL;
 734   GstClockTime endtime, running_time, stream_time;
 735 
 736   GST_DEBUG_OBJECT (spectrum, &quot;preparing message, bands =%d &quot;, spectrum-&gt;bands);
 737 
<a name="3" id="anc3"></a><span class="line-added"> 738 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)</span>
<span class="line-added"> 739   // When running spectrum directly we cannot figure out time stamps, since we do not</span>
<span class="line-added"> 740   // have full pipeline. Caller will be responsible to handle time stamps.</span>
<span class="line-added"> 741   if (spectrum-&gt;user_data != NULL) {</span>
<span class="line-added"> 742     running_time = 0;</span>
<span class="line-added"> 743     stream_time = 0;</span>
<span class="line-added"> 744   } else {</span>
<span class="line-added"> 745     running_time = gst_segment_to_running_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,</span>
<span class="line-added"> 746       timestamp);</span>
<span class="line-added"> 747     stream_time = gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,</span>
<span class="line-added"> 748       timestamp);</span>
<span class="line-added"> 749   }</span>
<span class="line-added"> 750 #else // GSTREAMER_LITE and OSX</span>
 751   running_time = gst_segment_to_running_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 752       timestamp);
 753   stream_time = gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 754       timestamp);
<a name="4" id="anc4"></a><span class="line-added"> 755 #endif // GSTREAMER_LITE and OSX</span>
 756   /* endtime is for backwards compatibility */
 757   endtime = stream_time + duration;
 758 
 759   s = gst_structure_new (&quot;spectrum&quot;,
 760       &quot;endtime&quot;, GST_TYPE_CLOCK_TIME, endtime,
 761       &quot;timestamp&quot;, G_TYPE_UINT64, timestamp,
 762       &quot;stream-time&quot;, G_TYPE_UINT64, stream_time,
 763       &quot;running-time&quot;, G_TYPE_UINT64, running_time,
 764       &quot;duration&quot;, G_TYPE_UINT64, duration, NULL);
 765 
 766   if (!spectrum-&gt;multi_channel) {
 767     cd = &amp;spectrum-&gt;channel_data[0];
 768 
 769     if (spectrum-&gt;message_magnitude) {
 770       /* FIXME 0.11: this should be an array, not a list */
 771       mcv = gst_spectrum_message_add_container (s, GST_TYPE_LIST, &quot;magnitude&quot;);
 772       gst_spectrum_message_add_list (mcv, cd-&gt;spect_magnitude, spectrum-&gt;bands);
 773     }
 774     if (spectrum-&gt;message_phase) {
 775       /* FIXME 0.11: this should be an array, not a list */
 776       pcv = gst_spectrum_message_add_container (s, GST_TYPE_LIST, &quot;phase&quot;);
 777       gst_spectrum_message_add_list (pcv, cd-&gt;spect_phase, spectrum-&gt;bands);
 778     }
 779   } else {
 780     guint c;
 781     guint channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 782 
 783     if (spectrum-&gt;message_magnitude) {
 784       mcv = gst_spectrum_message_add_container (s, GST_TYPE_ARRAY, &quot;magnitude&quot;);
 785     }
 786     if (spectrum-&gt;message_phase) {
 787       pcv = gst_spectrum_message_add_container (s, GST_TYPE_ARRAY, &quot;phase&quot;);
 788     }
 789 
 790     for (c = 0; c &lt; channels; c++) {
 791       cd = &amp;spectrum-&gt;channel_data[c];
 792 
 793       if (spectrum-&gt;message_magnitude) {
 794         gst_spectrum_message_add_array (mcv, cd-&gt;spect_magnitude,
 795             spectrum-&gt;bands);
 796       }
 797       if (spectrum-&gt;message_phase) {
 798         gst_spectrum_message_add_array (pcv, cd-&gt;spect_phase, spectrum-&gt;bands);
 799       }
 800     }
 801   }
 802   return gst_message_new_element (GST_OBJECT (spectrum), s);
 803 }
 804 
 805 static void
 806 gst_spectrum_run_fft (GstSpectrum * spectrum, GstSpectrumChannel * cd,
 807     guint input_pos)
 808 {
 809   guint i;
 810   guint bands = spectrum-&gt;bands;
 811   guint nfft = 2 * bands - 2;
 812   gint threshold = spectrum-&gt;threshold;
 813   gfloat *input = cd-&gt;input;
 814   gfloat *input_tmp = cd-&gt;input_tmp;
 815   gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 816   gfloat *spect_phase = cd-&gt;spect_phase;
 817   GstFFTF32Complex *freqdata = cd-&gt;freqdata;
 818   GstFFTF32 *fft_ctx = cd-&gt;fft_ctx;
 819 
 820   for (i = 0; i &lt; nfft; i++)
 821     input_tmp[i] = input[(input_pos + i) % nfft];
 822 
 823   gst_fft_f32_window (fft_ctx, input_tmp, GST_FFT_WINDOW_HAMMING);
 824 
 825   gst_fft_f32_fft (fft_ctx, input_tmp, freqdata);
 826 
 827   if (spectrum-&gt;message_magnitude) {
 828     gdouble val;
 829     /* Calculate magnitude in db */
 830     for (i = 0; i &lt; bands; i++) {
 831       val = freqdata[i].r * freqdata[i].r;
 832       val += freqdata[i].i * freqdata[i].i;
 833       val /= nfft * nfft;
 834       val = 10.0 * log10 (val);
 835       if (val &lt; threshold)
 836         val = threshold;
 837       spect_magnitude[i] += val;
 838     }
 839   }
 840 
 841   if (spectrum-&gt;message_phase) {
 842     /* Calculate phase */
 843     for (i = 0; i &lt; bands; i++)
 844       spect_phase[i] += atan2 (freqdata[i].i, freqdata[i].r);
 845   }
 846 }
 847 
 848 static void
 849 gst_spectrum_prepare_message_data (GstSpectrum * spectrum,
 850     GstSpectrumChannel * cd)
 851 {
 852   guint i;
 853   guint bands = spectrum-&gt;bands;
 854   guint num_fft = spectrum-&gt;num_fft;
 855 
 856   /* Calculate average */
 857   if (spectrum-&gt;message_magnitude) {
 858     gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 859     for (i = 0; i &lt; bands; i++)
 860       spect_magnitude[i] /= num_fft;
 861   }
 862   if (spectrum-&gt;message_phase) {
 863     gfloat *spect_phase = cd-&gt;spect_phase;
 864     for (i = 0; i &lt; bands; i++)
 865       spect_phase[i] /= num_fft;
 866   }
 867 }
 868 
 869 static void
 870 gst_spectrum_reset_message_data (GstSpectrum * spectrum,
 871     GstSpectrumChannel * cd)
 872 {
 873   guint bands = spectrum-&gt;bands;
 874   gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 875   gfloat *spect_phase = cd-&gt;spect_phase;
 876 
 877   /* reset spectrum accumulators */
 878   memset (spect_magnitude, 0, bands * sizeof (gfloat));
 879   memset (spect_phase, 0, bands * sizeof (gfloat));
 880 }
 881 
 882 static GstFlowReturn
 883 gst_spectrum_transform_ip (GstBaseTransform * trans, GstBuffer * buffer)
 884 {
 885 #ifdef GSTREAMER_LITE
 886   GstMessage *m;
 887 
 888   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 889   guint rate;
 890   guint channels;
 891   guint bps;
 892   guint bpf;
 893   guint output_channels;
 894   guint c;
 895   gfloat max_value;
 896   guint bands;
 897   guint nfft;
 898   guint input_pos;
 899   gfloat *input;
 900   GstMapInfo map;
 901   const guint8 *data;
 902   gsize size;
 903   guint fft_todo, msg_todo, block_size;
 904   gboolean have_full_interval;
 905   GstSpectrumChannel *cd;
 906   GstSpectrumInputData input_data;
 907 
 908   if (!spectrum-&gt;post_messages)
 909       return GST_FLOW_OK;
 910 
 911   rate = GST_AUDIO_FILTER_RATE (spectrum);
 912   channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 913   bps = GST_AUDIO_FILTER_BPS (spectrum);
 914   bpf = GST_AUDIO_FILTER_BPF (spectrum);
<a name="5" id="anc5"></a><span class="line-added"> 915 #ifdef OSX</span>
<span class="line-added"> 916   if (spectrum-&gt;bps_user != 0 &amp;&amp; spectrum-&gt;bpf_user != 0) {</span>
<span class="line-added"> 917     bps = spectrum-&gt;bps_user;</span>
<span class="line-added"> 918     bpf = spectrum-&gt;bpf_user;</span>
<span class="line-added"> 919   }</span>
<span class="line-added"> 920 #endif // OSX</span>
 921   output_channels = spectrum-&gt;multi_channel ? channels : 1;
 922   max_value = (1UL &lt;&lt; ((bps &lt;&lt; 3) - 1)) - 1;
 923   bands = spectrum-&gt;bands;
 924   nfft = 2 * bands - 2;
 925 #else // GSTREAMER_LITE
 926 
 927   guint rate = GST_AUDIO_FILTER_RATE (spectrum);
 928   guint channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 929   guint bps = GST_AUDIO_FILTER_BPS (spectrum);
 930   guint bpf = GST_AUDIO_FILTER_BPF (spectrum);
 931   guint output_channels = spectrum-&gt;multi_channel ? channels : 1;
 932   guint c;
 933   gfloat max_value = (1UL &lt;&lt; ((bps &lt;&lt; 3) - 1)) - 1;
 934   guint bands = spectrum-&gt;bands;
 935   guint nfft = 2 * bands - 2;
 936   guint input_pos;
 937   gfloat *input;
 938   GstMapInfo map;
 939   const guint8 *data;
 940   gsize size;
 941   guint fft_todo, msg_todo, block_size;
 942   gboolean have_full_interval;
 943   GstSpectrumChannel *cd;
 944   GstSpectrumInputData input_data;
 945 #endif // GSTREAMER_LITE
 946 
 947   g_mutex_lock (&amp;spectrum-&gt;lock);
 948   gst_buffer_map (buffer, &amp;map, GST_MAP_READ);
 949   data = map.data;
 950   size = map.size;
 951 
 952   GST_LOG_OBJECT (spectrum, &quot;input size: %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, size);
 953 
 954   if (GST_BUFFER_IS_DISCONT (buffer)) {
 955     GST_DEBUG_OBJECT (spectrum, &quot;Discontinuity detected -- flushing&quot;);
 956     gst_spectrum_flush (spectrum);
 957   }
 958 
 959   /* If we don&#39;t have a FFT context yet (or it was reset due to parameter
 960    * changes) get one and allocate memory for everything
 961    */
 962   if (spectrum-&gt;channel_data == NULL) {
 963     GST_DEBUG_OBJECT (spectrum, &quot;allocating for bands %u&quot;, bands);
 964 
 965     gst_spectrum_alloc_channel_data (spectrum);
 966 
 967     /* number of sample frames we process before posting a message
 968      * interval is in ns */
 969     spectrum-&gt;frames_per_interval =
 970         gst_util_uint64_scale (spectrum-&gt;interval, rate, GST_SECOND);
 971     spectrum-&gt;frames_todo = spectrum-&gt;frames_per_interval;
 972     /* rounding error for frames_per_interval in ns,
 973      * aggregated it in accumulated_error */
 974     spectrum-&gt;error_per_interval = (spectrum-&gt;interval * rate) % GST_SECOND;
 975     if (spectrum-&gt;frames_per_interval == 0)
 976       spectrum-&gt;frames_per_interval = 1;
 977 
 978     GST_INFO_OBJECT (spectrum, &quot;interval %&quot; GST_TIME_FORMAT &quot;, fpi %&quot;
 979         G_GUINT64_FORMAT &quot;, error %&quot; GST_TIME_FORMAT,
 980         GST_TIME_ARGS (spectrum-&gt;interval), spectrum-&gt;frames_per_interval,
 981         GST_TIME_ARGS (spectrum-&gt;error_per_interval));
 982 
 983     spectrum-&gt;input_pos = 0;
 984 
 985     gst_spectrum_flush (spectrum);
 986   }
 987 
 988   if (spectrum-&gt;num_frames == 0)
 989     spectrum-&gt;message_ts = GST_BUFFER_TIMESTAMP (buffer);
 990 
 991   input_pos = spectrum-&gt;input_pos;
 992   input_data = spectrum-&gt;input_data;
 993 
 994   while (size &gt;= bpf) {
 995     /* run input_data for a chunk of data */
 996     fft_todo = nfft - (spectrum-&gt;num_frames % nfft);
 997     msg_todo = spectrum-&gt;frames_todo - spectrum-&gt;num_frames;
 998     GST_LOG_OBJECT (spectrum,
 999         &quot;message frames todo: %u, fft frames todo: %u, input frames %&quot;
1000         G_GSIZE_FORMAT, msg_todo, fft_todo, (size / bpf));
1001     block_size = msg_todo;
1002     if (block_size &gt; (size / bpf))
1003       block_size = (size / bpf);
1004     if (block_size &gt; fft_todo)
1005       block_size = fft_todo;
1006 
1007     for (c = 0; c &lt; output_channels; c++) {
1008       cd = &amp;spectrum-&gt;channel_data[c];
1009       input = cd-&gt;input;
1010       /* Move the current frames into our ringbuffers */
1011       input_data (data + c * bps, input, block_size, channels, max_value,
1012           input_pos, nfft);
1013     }
1014     data += block_size * bpf;
1015     size -= block_size * bpf;
1016     input_pos = (input_pos + block_size) % nfft;
1017     spectrum-&gt;num_frames += block_size;
1018 
1019     have_full_interval = (spectrum-&gt;num_frames == spectrum-&gt;frames_todo);
1020 
1021     GST_LOG_OBJECT (spectrum,
1022         &quot;size: %&quot; G_GSIZE_FORMAT &quot;, do-fft = %d, do-message = %d&quot;, size,
1023         (spectrum-&gt;num_frames % nfft == 0), have_full_interval);
1024 
1025     /* If we have enough frames for an FFT or we have all frames required for
1026      * the interval and we haven&#39;t run a FFT, then run an FFT */
1027     if ((spectrum-&gt;num_frames % nfft == 0) ||
1028         (have_full_interval &amp;&amp; !spectrum-&gt;num_fft)) {
1029       for (c = 0; c &lt; output_channels; c++) {
1030         cd = &amp;spectrum-&gt;channel_data[c];
1031         gst_spectrum_run_fft (spectrum, cd, input_pos);
1032       }
1033       spectrum-&gt;num_fft++;
1034     }
1035 
1036     /* Do we have the FFTs for one interval? */
1037     if (have_full_interval) {
1038       GST_DEBUG_OBJECT (spectrum, &quot;nfft: %u frames: %&quot; G_GUINT64_FORMAT
1039           &quot; fpi: %&quot; G_GUINT64_FORMAT &quot; error: %&quot; GST_TIME_FORMAT, nfft,
1040           spectrum-&gt;num_frames, spectrum-&gt;frames_per_interval,
1041           GST_TIME_ARGS (spectrum-&gt;accumulated_error));
1042 
1043       spectrum-&gt;frames_todo = spectrum-&gt;frames_per_interval;
1044       if (spectrum-&gt;accumulated_error &gt;= GST_SECOND) {
1045         spectrum-&gt;accumulated_error -= GST_SECOND;
1046         spectrum-&gt;frames_todo++;
1047       }
1048       spectrum-&gt;accumulated_error += spectrum-&gt;error_per_interval;
1049 
1050 #ifndef GSTREAMER_LITE
1051       if (spectrum-&gt;post_messages) {
1052         GstMessage *m;
1053 #endif // GSTREAMER_LITE
1054 
1055         for (c = 0; c &lt; output_channels; c++) {
1056           cd = &amp;spectrum-&gt;channel_data[c];
1057           gst_spectrum_prepare_message_data (spectrum, cd);
1058         }
1059 
1060         m = gst_spectrum_message_new (spectrum, spectrum-&gt;message_ts,
1061             spectrum-&gt;interval);
1062 
1063         gst_element_post_message (GST_ELEMENT (spectrum), m);
1064 #ifndef GSTREAMER_LITE
1065       }
1066 #endif // GSTREAMER_LITE
1067 
1068       if (GST_CLOCK_TIME_IS_VALID (spectrum-&gt;message_ts))
1069         spectrum-&gt;message_ts +=
1070             gst_util_uint64_scale (spectrum-&gt;num_frames, GST_SECOND, rate);
1071 
1072 #ifdef GSTREAMER_LITE
1073       for (c = 0; c &lt; spectrum-&gt;num_channels; c++) {
1074 #else // GSTREAMER_LITE
1075       for (c = 0; c &lt; output_channels; c++) {
1076 #endif // GSTREAMER_LITE
1077         cd = &amp;spectrum-&gt;channel_data[c];
1078         gst_spectrum_reset_message_data (spectrum, cd);
1079       }
1080       spectrum-&gt;num_frames = 0;
1081       spectrum-&gt;num_fft = 0;
1082     }
1083   }
1084 
1085   spectrum-&gt;input_pos = input_pos;
1086 
1087   gst_buffer_unmap (buffer, &amp;map);
1088   g_mutex_unlock (&amp;spectrum-&gt;lock);
1089 
1090   g_assert (size == 0);
1091 
1092   return GST_FLOW_OK;
1093 }
1094 
1095 #ifdef GSTREAMER_LITE
1096 gboolean
1097 plugin_init_spectrum (GstPlugin * plugin)
1098 #else // GSTREAMER_LITE
1099 static gboolean
1100 plugin_init (GstPlugin * plugin)
1101 #endif // GSTREAMER_LITE
1102 {
1103   return gst_element_register (plugin, &quot;spectrum&quot;, GST_RANK_NONE,
1104       GST_TYPE_SPECTRUM);
1105 }
1106 
1107 #ifndef GSTREAMER_LITE
1108 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
1109     GST_VERSION_MINOR,
1110     spectrum,
1111     &quot;Run an FFT on the audio signal, output spectrum data&quot;,
1112     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
1113 #endif // GSTREAMER_LITE
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>