<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/css/StyleResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
   4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
   5  * Copyright (C) 2005-2014 Apple Inc. All rights reserved.
   6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
  12  * Copyright (C) 2014 Igalia S.L.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;StyleResolver.h&quot;
  32 
  33 #include &quot;CSSCalculationValue.h&quot;
  34 #include &quot;CSSCursorImageValue.h&quot;
  35 #include &quot;CSSCustomPropertyValue.h&quot;
  36 #include &quot;CSSDefaultStyleSheets.h&quot;
  37 #include &quot;CSSFilterImageValue.h&quot;
  38 #include &quot;CSSFontSelector.h&quot;
  39 #include &quot;CSSFunctionValue.h&quot;
  40 #include &quot;CSSGradientValue.h&quot;
  41 #include &quot;CSSImageSetValue.h&quot;
  42 #include &quot;CSSImageValue.h&quot;
  43 #include &quot;CSSKeyframeRule.h&quot;
  44 #include &quot;CSSKeyframesRule.h&quot;
  45 #include &quot;CSSPaintImageValue.h&quot;
  46 #include &quot;CSSParser.h&quot;
  47 #include &quot;CSSPrimitiveValueMappings.h&quot;
  48 #include &quot;CSSPropertyNames.h&quot;
  49 #include &quot;CSSReflectValue.h&quot;
  50 #include &quot;CSSSelector.h&quot;
  51 #include &quot;CSSShadowValue.h&quot;
  52 #include &quot;CSSStyleRule.h&quot;
  53 #include &quot;CSSStyleSheet.h&quot;
  54 #include &quot;CSSValueList.h&quot;
  55 #include &quot;CSSValuePool.h&quot;
  56 #include &quot;CachedResourceLoader.h&quot;
  57 #include &quot;ElementRuleCollector.h&quot;
  58 #include &quot;FilterOperation.h&quot;
  59 #include &quot;Frame.h&quot;
  60 #include &quot;FrameSelection.h&quot;
  61 #include &quot;FrameView.h&quot;
  62 #include &quot;HTMLInputElement.h&quot;
  63 #include &quot;HTMLMarqueeElement.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLSlotElement.h&quot;
  66 #include &quot;HTMLTableElement.h&quot;
  67 #include &quot;HTMLTextAreaElement.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;KeyframeList.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;MathMLElement.h&quot;
  72 #include &quot;MathMLNames.h&quot;
  73 #include &quot;MediaList.h&quot;
  74 #include &quot;MediaQueryEvaluator.h&quot;
  75 #include &quot;NodeRenderStyle.h&quot;
  76 #include &quot;PageRuleCollector.h&quot;
  77 #include &quot;PaintWorkletGlobalScope.h&quot;
  78 #include &quot;Pair.h&quot;
  79 #include &quot;RenderScrollbar.h&quot;
  80 #include &quot;RenderStyleConstants.h&quot;
  81 #include &quot;RenderTheme.h&quot;
  82 #include &quot;RenderView.h&quot;
  83 #include &quot;RuleSet.h&quot;
  84 #include &quot;RuntimeEnabledFeatures.h&quot;
  85 #include &quot;SVGDocument.h&quot;
  86 #include &quot;SVGDocumentExtensions.h&quot;
  87 #include &quot;SVGFontFaceElement.h&quot;
  88 #include &quot;SVGNames.h&quot;
  89 #include &quot;SVGSVGElement.h&quot;
  90 #include &quot;SVGURIReference.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;SharedStringHash.h&quot;
  94 #include &quot;StyleBuilder.h&quot;
  95 #include &quot;StyleColor.h&quot;
  96 #include &quot;StyleCachedImage.h&quot;
  97 #include &quot;StyleFontSizeFunctions.h&quot;
  98 #include &quot;StyleGeneratedImage.h&quot;
  99 #include &quot;StyleProperties.h&quot;
 100 #include &quot;StylePropertyShorthand.h&quot;
 101 #include &quot;StyleRule.h&quot;
 102 #include &quot;StyleSheetContents.h&quot;
 103 #include &quot;TransformFunctions.h&quot;
 104 #include &quot;TransformOperations.h&quot;
 105 #include &quot;UserAgentStyleSheets.h&quot;
 106 #include &quot;ViewportStyleResolver.h&quot;
 107 #include &quot;VisitedLinkState.h&quot;
 108 #include &quot;WebKitFontFamilyNames.h&quot;
 109 #include &lt;bitset&gt;
 110 #include &lt;wtf/Seconds.h&gt;
 111 #include &lt;wtf/StdLibExtras.h&gt;
 112 #include &lt;wtf/Vector.h&gt;
 113 #include &lt;wtf/text/AtomicStringHash.h&gt;
 114 
 115 
 116 #if ENABLE(DASHBOARD_SUPPORT)
 117 #endif
 118 
 119 #if ENABLE(VIDEO_TRACK)
 120 #endif
 121 
 122 namespace WebCore {
 123 
 124 using namespace HTMLNames;
 125 
 126 static const CSSPropertyID firstLowPriorityProperty = static_cast&lt;CSSPropertyID&gt;(lastHighPriorityProperty + 1);
 127 
 128 static void extractDirectionAndWritingMode(const RenderStyle&amp;, const StyleResolver::MatchResult&amp;, TextDirection&amp;, WritingMode&amp;);
 129 
 130 inline void StyleResolver::State::cacheBorderAndBackground()
 131 {
 132     m_hasUAAppearance = m_style-&gt;hasAppearance();
 133     if (m_hasUAAppearance) {
 134         m_borderData = m_style-&gt;border();
 135         m_backgroundData = m_style-&gt;backgroundLayers();
 136         m_backgroundColor = m_style-&gt;backgroundColor();
 137     }
 138 }
 139 
 140 inline void StyleResolver::State::clear()
 141 {
 142     m_element = nullptr;
 143     m_parentStyle = nullptr;
 144     m_ownedParentStyle = nullptr;
 145     m_cssToLengthConversionData = CSSToLengthConversionData();
 146 }
 147 
 148 void StyleResolver::MatchResult::addMatchedProperties(const StyleProperties&amp; properties, StyleRule* rule, unsigned linkMatchType, PropertyWhitelistType propertyWhitelistType, Style::ScopeOrdinal styleScopeOrdinal)
 149 {
 150     m_matchedProperties.grow(m_matchedProperties.size() + 1);
 151     StyleResolver::MatchedProperties&amp; newProperties = m_matchedProperties.last();
 152     newProperties.properties = const_cast&lt;StyleProperties*&gt;(&amp;properties);
 153     newProperties.linkMatchType = linkMatchType;
 154     newProperties.whitelistType = propertyWhitelistType;
 155     newProperties.styleScopeOrdinal = styleScopeOrdinal;
 156     matchedRules.append(rule);
 157 
 158     if (styleScopeOrdinal != Style::ScopeOrdinal::Element)
 159         isCacheable = false;
 160 
 161     if (isCacheable) {
 162         for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
 163             // Currently the property cache only copy the non-inherited values and resolve
 164             // the inherited ones.
 165             // Here we define some exception were we have to resolve some properties that are not inherited
 166             // by default. If those exceptions become too common on the web, it should be possible
 167             // to build a list of exception to resolve instead of completely disabling the cache.
 168 
 169             StyleProperties::PropertyReference current = properties.propertyAt(i);
 170             if (!current.isInherited()) {
 171                 // If the property value is explicitly inherited, we need to apply further non-inherited properties
 172                 // as they might override the value inherited here. For this reason we don&#39;t allow declarations with
 173                 // explicitly inherited properties to be cached.
 174                 const CSSValue&amp; value = *current.value();
 175                 if (value.isInheritedValue()) {
 176                     isCacheable = false;
 177                     break;
 178                 }
 179 
 180                 // The value currentColor has implicitely the same side effect. It depends on the value of color,
 181                 // which is an inherited value, making the non-inherited property implicitly inherited.
 182                 if (is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueCurrentcolor) {
 183                     isCacheable = false;
 184                     break;
 185                 }
 186 
 187                 if (value.hasVariableReferences()) {
 188                     isCacheable = false;
 189                     break;
 190                 }
 191             }
 192         }
 193     }
 194 }
 195 
 196 StyleResolver::StyleResolver(Document&amp; document)
 197     : m_ruleSets(*this)
 198     , m_matchedPropertiesCacheSweepTimer(*this, &amp;StyleResolver::sweepMatchedPropertiesCache)
 199     , m_document(document)
 200 #if ENABLE(CSS_DEVICE_ADAPTATION)
 201     , m_viewportStyleResolver(ViewportStyleResolver::create(&amp;document))
 202 #endif
 203     , m_styleMap(this)
 204     , m_matchAuthorAndUserStyles(m_document.settings().authorAndUserStylesEnabled())
 205 {
 206     Element* root = m_document.documentElement();
 207 
 208     CSSDefaultStyleSheets::initDefaultStyle(root);
 209 
 210     // construct document root element default style. this is needed
 211     // to evaluate media queries that contain relative constraints, like &quot;screen and (max-width: 10em)&quot;
 212     // This is here instead of constructor, because when constructor is run,
 213     // document doesn&#39;t have documentElement
 214     // NOTE: this assumes that element that gets passed to styleForElement -call
 215     // is always from the document that owns the style selector
 216     FrameView* view = m_document.view();
 217     if (view)
 218         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType() };
 219     else
 220         m_mediaQueryEvaluator = MediaQueryEvaluator { &quot;all&quot; };
 221 
 222     if (root) {
 223         m_rootDefaultStyle = styleForElement(*root, m_document.renderStyle(), nullptr, RuleMatchingBehavior::MatchOnlyUserAgentRules).renderStyle;
 224         // Turn off assertion against font lookups during style resolver initialization. We may need root style font for media queries.
 225         m_document.fontSelector().incrementIsComputingRootStyleFont();
 226         m_rootDefaultStyle-&gt;fontCascade().update(&amp;m_document.fontSelector());
 227         m_rootDefaultStyle-&gt;fontCascade().primaryFont();
 228         m_document.fontSelector().decrementIsComputingRootStyleFont();
 229     }
 230 
 231     if (m_rootDefaultStyle &amp;&amp; view)
 232         m_mediaQueryEvaluator = MediaQueryEvaluator { view-&gt;mediaType(), m_document, m_rootDefaultStyle.get() };
 233 
 234     m_ruleSets.resetAuthorStyle();
 235     m_ruleSets.resetUserAgentMediaQueryStyle();
 236 }
 237 
 238 void StyleResolver::addCurrentSVGFontFaceRules()
 239 {
 240 #if ENABLE(SVG_FONTS)
 241     if (m_document.svgExtensions()) {
 242         const HashSet&lt;SVGFontFaceElement*&gt;&amp; svgFontFaceElements = m_document.svgExtensions()-&gt;svgFontFaceElements();
 243         for (auto* svgFontFaceElement : svgFontFaceElements)
 244             m_document.fontSelector().addFontFaceRule(svgFontFaceElement-&gt;fontFaceRule(), svgFontFaceElement-&gt;isInUserAgentShadowTree());
 245     }
 246 #endif
 247 }
 248 
 249 void StyleResolver::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets)
 250 {
 251     m_ruleSets.appendAuthorStyleSheets(styleSheets, &amp;m_mediaQueryEvaluator, m_inspectorCSSOMWrappers, this);
 252 
 253     if (auto renderView = document().renderView())
 254         renderView-&gt;style().fontCascade().update(&amp;document().fontSelector());
 255 
 256 #if ENABLE(CSS_DEVICE_ADAPTATION)
 257     viewportStyleResolver()-&gt;resolve();
 258 #endif
 259 }
 260 
 261 // This is a simplified style setting function for keyframe styles
 262 void StyleResolver::addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp; rule)
 263 {
 264     AtomicString s(rule-&gt;name());
 265     m_keyframesRuleMap.set(s.impl(), WTFMove(rule));
 266 }
 267 
 268 StyleResolver::~StyleResolver()
 269 {
 270     RELEASE_ASSERT(!m_document.isResolvingTreeStyle());
 271     RELEASE_ASSERT(!m_isDeleted);
 272     m_isDeleted = true;
 273 
 274 #if ENABLE(CSS_DEVICE_ADAPTATION)
 275     m_viewportStyleResolver-&gt;clearDocument();
 276 #endif
 277 }
 278 
 279 void StyleResolver::sweepMatchedPropertiesCache()
 280 {
 281     // Look for cache entries containing a style declaration with a single ref and remove them.
 282     // This may happen when an element attribute mutation causes it to generate a new inlineStyle()
 283     // or presentationAttributeStyle(), potentially leaving this cache with the last ref on the old one.
 284     Vector&lt;unsigned, 16&gt; toRemove;
 285     MatchedPropertiesCache::iterator it = m_matchedPropertiesCache.begin();
 286     MatchedPropertiesCache::iterator end = m_matchedPropertiesCache.end();
 287     for (; it != end; ++it) {
 288         Vector&lt;MatchedProperties&gt;&amp; matchedProperties = it-&gt;value.matchedProperties;
 289         for (size_t i = 0; i &lt; matchedProperties.size(); ++i) {
 290             if (matchedProperties[i].properties-&gt;hasOneRef()) {
 291                 toRemove.append(it-&gt;key);
 292                 break;
 293             }
 294         }
 295     }
 296     for (size_t i = 0; i &lt; toRemove.size(); ++i)
 297         m_matchedPropertiesCache.remove(toRemove[i]);
 298 
 299     m_matchedPropertiesCacheAdditionsSinceLastSweep = 0;
 300 }
 301 
 302 StyleResolver::State::State(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* documentElementStyle, const SelectorFilter* selectorFilter)
 303     : m_element(&amp;element)
 304     , m_parentStyle(parentStyle)
 305     , m_selectorFilter(selectorFilter)
 306     , m_elementLinkState(element.document().visitedLinkState().determineLinkState(element))
 307 {
 308     bool resetStyleInheritance = hasShadowRootParent(element) &amp;&amp; downcast&lt;ShadowRoot&gt;(element.parentNode())-&gt;resetStyleInheritance();
 309     if (resetStyleInheritance)
 310         m_parentStyle = nullptr;
 311 
 312     auto&amp; document = element.document();
 313     auto* documentElement = document.documentElement();
 314     if (!documentElement || documentElement == &amp;element)
 315         m_rootElementStyle = document.renderStyle();
 316     else
 317         m_rootElementStyle = documentElementStyle ? documentElementStyle : documentElement-&gt;renderStyle();
 318 
 319     updateConversionData();
 320 }
 321 
 322 inline void StyleResolver::State::updateConversionData()
 323 {
 324     m_cssToLengthConversionData = CSSToLengthConversionData(m_style.get(), m_rootElementStyle, m_element ? m_element-&gt;document().renderView() : nullptr);
 325 }
 326 
 327 inline void StyleResolver::State::setStyle(std::unique_ptr&lt;RenderStyle&gt; style)
 328 {
 329     m_style = WTFMove(style);
 330     updateConversionData();
 331 }
 332 
 333 inline void StyleResolver::State::setParentStyle(std::unique_ptr&lt;RenderStyle&gt; parentStyle)
 334 {
 335     m_ownedParentStyle = WTFMove(parentStyle);
 336     m_parentStyle = m_ownedParentStyle.get();
 337 }
 338 
 339 static inline bool isAtShadowBoundary(const Element&amp; element)
 340 {
 341     auto* parentNode = element.parentNode();
 342     return parentNode &amp;&amp; parentNode-&gt;isShadowRoot();
 343 }
 344 
 345 void StyleResolver::setNewStateWithElement(const Element&amp; element)
 346 {
 347     // Apply the declaration to the style. This is a simplified version of the logic in styleForElement.
 348     m_state = State(element, nullptr);
 349 }
 350 
 351 ElementStyle StyleResolver::styleForElement(const Element&amp; element, const RenderStyle* parentStyle, const RenderStyle* parentBoxStyle, RuleMatchingBehavior matchingBehavior, const SelectorFilter* selectorFilter)
 352 {
 353     RELEASE_ASSERT(!m_isDeleted);
 354 
 355     m_state = State(element, parentStyle, m_overrideDocumentElementStyle, selectorFilter);
 356     State&amp; state = m_state;
 357 
 358     if (state.parentStyle()) {
 359         state.setStyle(RenderStyle::createPtr());
 360         state.style()-&gt;inheritFrom(*state.parentStyle());
 361     } else {
 362         state.setStyle(defaultStyleForElement());
 363         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
 364     }
 365 
 366     auto&amp; style = *state.style();
 367 
 368     if (element.isLink()) {
 369         style.setIsLink(true);
 370         InsideLink linkState = state.elementLinkState();
 371         if (linkState != InsideLink::NotInside) {
 372             bool forceVisited = InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassVisited);
 373             if (forceVisited)
 374                 linkState = InsideLink::InsideVisited;
 375         }
 376         style.setInsideLink(linkState);
 377     }
 378 
 379     CSSDefaultStyleSheets::ensureDefaultStyleSheetsForElement(element);
 380 
 381     ElementRuleCollector collector(element, m_ruleSets, m_state.selectorFilter());
 382     collector.setMedium(&amp;m_mediaQueryEvaluator);
 383 
 384     if (matchingBehavior == RuleMatchingBehavior::MatchOnlyUserAgentRules)
 385         collector.matchUARules();
 386     else
 387         collector.matchAllRules(m_matchAuthorAndUserStyles, matchingBehavior != RuleMatchingBehavior::MatchAllRulesExcludingSMIL);
 388 
 389     if (collector.matchedPseudoElementIds())
 390         style.setHasPseudoStyles(collector.matchedPseudoElementIds());
 391 
 392     // This is required for style sharing.
 393     if (collector.didMatchUncommonAttributeSelector())
 394         style.setUnique();
 395 
 396     auto elementStyleRelations = Style::commitRelationsToRenderStyle(style, element, collector.styleRelations());
 397 
 398     applyMatchedProperties(collector.matchedResult(), element);
 399 
 400     // Clean up our style object&#39;s display and text decorations (among other fixups).
 401     adjustRenderStyle(*state.style(), *state.parentStyle(), parentBoxStyle, &amp;element);
 402 
 403     if (state.style()-&gt;hasViewportUnits())
 404         document().setHasStyleWithViewportUnits();
 405 
 406     state.clear(); // Clear out for the next resolve.
 407 
 408     return { state.takeStyle(), WTFMove(elementStyleRelations) };
 409 }
 410 
 411 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::styleForKeyframe(const RenderStyle* elementStyle, const StyleRuleKeyframe* keyframe, KeyframeValue&amp; keyframeValue)
 412 {
 413     RELEASE_ASSERT(!m_isDeleted);
 414 
 415     MatchResult result;
 416     result.addMatchedProperties(keyframe-&gt;properties());
 417 
 418     ASSERT(!m_state.style());
 419 
 420     State&amp; state = m_state;
 421 
 422     // Create the style
 423     state.setStyle(RenderStyle::clonePtr(*elementStyle));
 424     state.setParentStyle(RenderStyle::clonePtr(*elementStyle));
 425 
 426     TextDirection direction;
 427     WritingMode writingMode;
 428     extractDirectionAndWritingMode(*state.style(), result, direction, writingMode);
 429 
 430     // We don&#39;t need to bother with !important. Since there is only ever one
 431     // decl, there&#39;s nothing to override. So just add the first properties.
 432     CascadedProperties cascade(direction, writingMode);
 433     cascade.addNormalMatches(result, 0, result.matchedProperties().size() - 1);
 434 
 435     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;result };
 436     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
 437 
 438     // If our font got dirtied, update it now.
 439     updateFont();
 440 
 441     // Now resolve remaining custom properties and the rest, in any order
 442     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
 443         applyCascadedCustomProperty(it-&gt;key, applyState);
 444     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
 445 
 446     // If our font got dirtied by one of the non-essential font props, update it a second time.
 447     updateFont();
 448 
 449     cascade.applyDeferredProperties(*this, applyState);
 450 
 451     adjustRenderStyle(*state.style(), *state.parentStyle(), nullptr, nullptr);
 452 
 453     // Add all the animating properties to the keyframe.
 454     unsigned propertyCount = keyframe-&gt;properties().propertyCount();
 455     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 456         CSSPropertyID property = keyframe-&gt;properties().propertyAt(i).id();
 457         // Timing-function within keyframes is special, because it is not animated; it just
 458         // describes the timing function between this keyframe and the next.
 459         if (property != CSSPropertyAnimationTimingFunction)
 460             keyframeValue.addProperty(property);
 461     }
 462 
 463     return state.takeStyle();
 464 }
 465 
 466 bool StyleResolver::isAnimationNameValid(const String&amp; name)
 467 {
 468     return m_keyframesRuleMap.find(AtomicString(name).impl()) != m_keyframesRuleMap.end();
 469 }
 470 
 471 void StyleResolver::keyframeStylesForAnimation(const Element&amp; element, const RenderStyle* elementStyle, KeyframeList&amp; list)
 472 {
 473     list.clear();
 474 
 475     // Get the keyframesRule for this name.
 476     if (list.animationName().isEmpty())
 477         return;
 478 
 479     m_keyframesRuleMap.checkConsistency();
 480 
 481     KeyframesRuleMap::iterator it = m_keyframesRuleMap.find(list.animationName().impl());
 482     if (it == m_keyframesRuleMap.end())
 483         return;
 484 
 485     const StyleRuleKeyframes* keyframesRule = it-&gt;value.get();
 486 
 487     auto* keyframes = &amp;keyframesRule-&gt;keyframes();
 488     Vector&lt;Ref&lt;StyleRuleKeyframe&gt;&gt; newKeyframesIfNecessary;
 489 
 490     bool hasDuplicateKeys = false;
 491     HashSet&lt;double&gt; keyframeKeys;
 492     for (auto&amp; keyframe : *keyframes) {
 493         for (auto key : keyframe-&gt;keys()) {
 494             if (!keyframeKeys.add(key)) {
 495                 hasDuplicateKeys = true;
 496                 break;
 497             }
 498         }
 499         if (hasDuplicateKeys)
 500             break;
 501     }
 502 
 503     // FIXME: If HashMaps could have Ref&lt;&gt; as value types, we wouldn&#39;t need
 504     // to copy the HashMap into a Vector.
 505     if (hasDuplicateKeys) {
 506         // Merge duplicate key times.
 507         HashMap&lt;double, RefPtr&lt;StyleRuleKeyframe&gt;&gt; keyframesMap;
 508 
 509         for (auto&amp; originalKeyframe : keyframesRule-&gt;keyframes()) {
 510             for (auto key : originalKeyframe-&gt;keys()) {
 511                 if (auto keyframe = keyframesMap.get(key))
 512                     keyframe-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
 513                 else {
 514                     auto StyleRuleKeyframe = StyleRuleKeyframe::create(MutableStyleProperties::create());
 515                     StyleRuleKeyframe.ptr()-&gt;setKey(key);
 516                     StyleRuleKeyframe.ptr()-&gt;mutableProperties().mergeAndOverrideOnConflict(originalKeyframe-&gt;properties());
 517                     keyframesMap.set(key, StyleRuleKeyframe.ptr());
 518                 }
 519             }
 520         }
 521 
 522         for (auto&amp; keyframe : keyframesMap.values())
 523             newKeyframesIfNecessary.append(*keyframe.get());
 524 
 525         keyframes = &amp;newKeyframesIfNecessary;
 526     }
 527 
 528     // Construct and populate the style for each keyframe.
 529     for (auto&amp; keyframe : *keyframes) {
 530         setNewStateWithElement(element);
 531 
 532         // Add this keyframe style to all the indicated key times
 533         for (auto key : keyframe-&gt;keys()) {
 534             KeyframeValue keyframeValue(0, nullptr);
 535             keyframeValue.setStyle(styleForKeyframe(elementStyle, keyframe.ptr(), keyframeValue));
 536             keyframeValue.setKey(key);
 537             if (auto timingFunctionCSSValue = keyframe-&gt;properties().getPropertyCSSValue(CSSPropertyAnimationTimingFunction))
 538                 keyframeValue.setTimingFunction(TimingFunction::createFromCSSValue(*timingFunctionCSSValue.get()));
 539             list.insert(WTFMove(keyframeValue));
 540         }
 541     }
 542 
 543     // If the 0% keyframe is missing, create it (but only if there is at least one other keyframe).
 544     int initialListSize = list.size();
 545     if (initialListSize &gt; 0 &amp;&amp; list[0].key()) {
 546         static StyleRuleKeyframe* zeroPercentKeyframe;
 547         if (!zeroPercentKeyframe) {
 548             zeroPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
 549             zeroPercentKeyframe-&gt;setKey(0);
 550         }
 551         KeyframeValue keyframeValue(0, nullptr);
 552         keyframeValue.setStyle(styleForKeyframe(elementStyle, zeroPercentKeyframe, keyframeValue));
 553         list.insert(WTFMove(keyframeValue));
 554     }
 555 
 556     // If the 100% keyframe is missing, create it (but only if there is at least one other keyframe).
 557     if (initialListSize &gt; 0 &amp;&amp; (list[list.size() - 1].key() != 1)) {
 558         static StyleRuleKeyframe* hundredPercentKeyframe;
 559         if (!hundredPercentKeyframe) {
 560             hundredPercentKeyframe = &amp;StyleRuleKeyframe::create(MutableStyleProperties::create()).leakRef();
 561             hundredPercentKeyframe-&gt;setKey(1);
 562         }
 563         KeyframeValue keyframeValue(1, nullptr);
 564         keyframeValue.setStyle(styleForKeyframe(elementStyle, hundredPercentKeyframe, keyframeValue));
 565         list.insert(WTFMove(keyframeValue));
 566     }
 567 }
 568 
 569 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::pseudoStyleForElement(const Element&amp; element, const PseudoStyleRequest&amp; pseudoStyleRequest, const RenderStyle&amp; parentStyle, const SelectorFilter* selectorFilter)
 570 {
 571     m_state = State(element, &amp;parentStyle, m_overrideDocumentElementStyle, selectorFilter);
 572 
 573     State&amp; state = m_state;
 574 
 575     if (m_state.parentStyle()) {
 576         state.setStyle(RenderStyle::createPtr());
 577         state.style()-&gt;inheritFrom(*m_state.parentStyle());
 578     } else {
 579         state.setStyle(defaultStyleForElement());
 580         state.setParentStyle(RenderStyle::clonePtr(*state.style()));
 581     }
 582 
 583     // Since we don&#39;t use pseudo-elements in any of our quirk/print user agent rules, don&#39;t waste time walking
 584     // those rules.
 585 
 586     // Check UA, user and author rules.
 587     ElementRuleCollector collector(element, m_ruleSets, m_state.selectorFilter());
 588     collector.setPseudoStyleRequest(pseudoStyleRequest);
 589     collector.setMedium(&amp;m_mediaQueryEvaluator);
 590     collector.matchUARules();
 591 
 592     if (m_matchAuthorAndUserStyles) {
 593         collector.matchUserRules(false);
 594         collector.matchAuthorRules(false);
 595     }
 596 
 597     ASSERT(!collector.matchedPseudoElementIds());
 598 
 599     if (collector.matchedResult().matchedProperties().isEmpty())
 600         return nullptr;
 601 
 602     state.style()-&gt;setStyleType(pseudoStyleRequest.pseudoId);
 603 
 604     applyMatchedProperties(collector.matchedResult(), element);
 605 
 606     // Clean up our style object&#39;s display and text decorations (among other fixups).
 607     adjustRenderStyle(*state.style(), *m_state.parentStyle(), nullptr, nullptr);
 608 
 609     if (state.style()-&gt;hasViewportUnits())
 610         document().setHasStyleWithViewportUnits();
 611 
 612     // Now return the style.
 613     return state.takeStyle();
 614 }
 615 
 616 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::styleForPage(int pageIndex)
 617 {
 618     RELEASE_ASSERT(!m_isDeleted);
 619 
 620     auto* documentElement = m_document.documentElement();
 621     if (!documentElement)
 622         return RenderStyle::createPtr();
 623 
 624     m_state = State(*documentElement, m_document.renderStyle());
 625 
 626     m_state.setStyle(RenderStyle::createPtr());
 627     m_state.style()-&gt;inheritFrom(*m_state.rootElementStyle());
 628 
 629     PageRuleCollector collector(m_state, m_ruleSets);
 630     collector.matchAllPageRules(pageIndex);
 631 
 632     MatchResult&amp; result = collector.matchedResult();
 633 
 634     TextDirection direction;
 635     WritingMode writingMode;
 636     extractDirectionAndWritingMode(*m_state.style(), result, direction, writingMode);
 637 
 638     CascadedProperties cascade(direction, writingMode);
 639     cascade.addNormalMatches(result, 0, result.matchedProperties().size() - 1);
 640 
 641     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;result };
 642     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
 643 
 644     // If our font got dirtied, update it now.
 645     updateFont();
 646 
 647     // Now resolve remaining custom properties and the rest, in any order
 648     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
 649         applyCascadedCustomProperty(it-&gt;key, applyState);
 650     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
 651 
 652     cascade.applyDeferredProperties(*this, applyState);
 653 
 654     // Now return the style.
 655     return m_state.takeStyle();
 656 }
 657 
 658 std::unique_ptr&lt;RenderStyle&gt; StyleResolver::defaultStyleForElement()
 659 {
 660     m_state.setStyle(RenderStyle::createPtr());
 661     // Make sure our fonts are initialized if we don&#39;t inherit them from our parent style.
 662     initializeFontStyle();
 663     m_state.style()-&gt;fontCascade().update(&amp;document().fontSelector());
 664     return m_state.takeStyle();
 665 }
 666 
 667 static void addIntrinsicMargins(RenderStyle&amp; style)
 668 {
 669     // Intrinsic margin value.
 670     const int intrinsicMargin = clampToInteger(2 * style.effectiveZoom());
 671 
 672     // FIXME: Using width/height alone and not also dealing with min-width/max-width is flawed.
 673     // FIXME: Using &quot;hasQuirk&quot; to decide the margin wasn&#39;t set is kind of lame.
 674     if (style.width().isIntrinsicOrAuto()) {
 675         if (style.marginLeft().hasQuirk())
 676             style.setMarginLeft(Length(intrinsicMargin, Fixed));
 677         if (style.marginRight().hasQuirk())
 678             style.setMarginRight(Length(intrinsicMargin, Fixed));
 679     }
 680 
 681     if (style.height().isAuto()) {
 682         if (style.marginTop().hasQuirk())
 683             style.setMarginTop(Length(intrinsicMargin, Fixed));
 684         if (style.marginBottom().hasQuirk())
 685             style.setMarginBottom(Length(intrinsicMargin, Fixed));
 686     }
 687 }
 688 
 689 static DisplayType equivalentBlockDisplay(const RenderStyle&amp; style, const Document&amp; document)
 690 {
 691     switch (auto display = style.display()) {
 692     case DisplayType::Block:
 693     case DisplayType::Table:
 694     case DisplayType::Box:
 695     case DisplayType::Flex:
 696     case DisplayType::WebKitFlex:
 697     case DisplayType::Grid:
 698         return display;
 699 
 700     case DisplayType::ListItem:
 701         // It is a WinIE bug that floated list items lose their bullets, so we&#39;ll emulate the quirk, but only in quirks mode.
 702         if (document.inQuirksMode() &amp;&amp; style.isFloating())
 703             return DisplayType::Block;
 704         return display;
 705     case DisplayType::InlineTable:
 706         return DisplayType::Table;
 707     case DisplayType::InlineBox:
 708         return DisplayType::Box;
 709     case DisplayType::InlineFlex:
 710     case DisplayType::WebKitInlineFlex:
 711         return DisplayType::Flex;
 712     case DisplayType::InlineGrid:
 713         return DisplayType::Grid;
 714 
 715     case DisplayType::Inline:
 716     case DisplayType::Compact:
 717     case DisplayType::InlineBlock:
 718     case DisplayType::TableRowGroup:
 719     case DisplayType::TableHeaderGroup:
 720     case DisplayType::TableFooterGroup:
 721     case DisplayType::TableRow:
 722     case DisplayType::TableColumnGroup:
 723     case DisplayType::TableColumn:
 724     case DisplayType::TableCell:
 725     case DisplayType::TableCaption:
 726         return DisplayType::Block;
 727     case DisplayType::Contents:
 728         ASSERT_NOT_REACHED();
 729         return DisplayType::Contents;
 730     case DisplayType::None:
 731         ASSERT_NOT_REACHED();
 732         return DisplayType::None;
 733     }
 734     ASSERT_NOT_REACHED();
 735     return DisplayType::Block;
 736 }
 737 
 738 // CSS requires text-decoration to be reset at each DOM element for tables,
 739 // inline blocks, inline tables, shadow DOM crossings, floating elements,
 740 // and absolute or relatively positioned elements.
 741 static bool doesNotInheritTextDecoration(const RenderStyle&amp; style, const Element* element)
 742 {
 743     return style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
 744         || style.display() == DisplayType::InlineBlock || style.display() == DisplayType::InlineBox || (element &amp;&amp; isAtShadowBoundary(*element))
 745         || style.isFloating() || style.hasOutOfFlowPosition();
 746 }
 747 
 748 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
 749 static bool isScrollableOverflow(Overflow overflow)
 750 {
 751     return overflow == Overflow::Scroll || overflow == Overflow::Auto;
 752 }
 753 #endif
 754 
 755 void StyleResolver::adjustStyleForInterCharacterRuby()
 756 {
 757     RenderStyle* style = m_state.style();
 758     if (style-&gt;rubyPosition() != RubyPosition::InterCharacter || !m_state.element() || !m_state.element()-&gt;hasTagName(rtTag))
 759         return;
 760     style-&gt;setTextAlign(TextAlignMode::Center);
 761     if (style-&gt;isHorizontalWritingMode())
 762         style-&gt;setWritingMode(LeftToRightWritingMode);
 763 }
 764 
 765 static bool hasEffectiveDisplayNoneForDisplayContents(const Element&amp; element)
 766 {
 767     // https://drafts.csswg.org/css-display-3/#unbox-html
 768     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; tagNames = [] {
 769         static const HTMLQualifiedName* const tagList[] = {
 770             &amp;brTag.get(),
 771             &amp;wbrTag.get(),
 772             &amp;meterTag.get(),
 773             &amp;appletTag.get(),
 774             &amp;progressTag.get(),
 775             &amp;canvasTag.get(),
 776             &amp;embedTag.get(),
 777             &amp;objectTag.get(),
 778             &amp;audioTag.get(),
 779             &amp;iframeTag.get(),
 780             &amp;imgTag.get(),
 781             &amp;videoTag.get(),
 782             &amp;frameTag.get(),
 783             &amp;framesetTag.get(),
 784             &amp;inputTag.get(),
 785             &amp;textareaTag.get(),
 786             &amp;selectTag.get(),
 787         };
 788         HashSet&lt;AtomicString&gt; set;
 789         for (auto&amp; name : tagList)
 790             set.add(name-&gt;localName());
 791         return set;
 792     }();
 793 
 794     // https://drafts.csswg.org/css-display-3/#unbox-svg
 795     // FIXME: &lt;g&gt;, &lt;use&gt; and &lt;tspan&gt; have special (?) behavior for display:contents in the current draft spec.
 796     if (is&lt;SVGElement&gt;(element))
 797         return true;
 798 #if ENABLE(MATHML)
 799     // Not sure MathML code can handle it.
 800     if (is&lt;MathMLElement&gt;(element))
 801         return true;
 802 #endif // ENABLE(MATHML)
 803     if (!is&lt;HTMLElement&gt;(element))
 804         return false;
 805     return tagNames.get().contains(element.localName());
 806 }
 807 
 808 static void adjustDisplayContentsStyle(RenderStyle&amp; style, const Element* element)
 809 {
 810     bool displayContentsEnabled = is&lt;HTMLSlotElement&gt;(element) || RuntimeEnabledFeatures::sharedFeatures().displayContentsEnabled();
 811     if (!displayContentsEnabled) {
 812         style.setDisplay(DisplayType::Inline);
 813         return;
 814     }
 815     if (!element) {
 816         if (style.styleType() != PseudoId::Before &amp;&amp; style.styleType() != PseudoId::After)
 817             style.setDisplay(DisplayType::None);
 818         return;
 819     }
 820     if (element-&gt;document().documentElement() == element) {
 821         style.setDisplay(DisplayType::Block);
 822         return;
 823     }
 824     if (hasEffectiveDisplayNoneForDisplayContents(*element))
 825         style.setDisplay(DisplayType::None);
 826 }
 827 
 828 void StyleResolver::adjustSVGElementStyle(const SVGElement&amp; svgElement, RenderStyle&amp; style)
 829 {
 830     // Only the root &lt;svg&gt; element in an SVG document fragment tree honors css position
 831     auto isPositioningAllowed = svgElement.hasTagName(SVGNames::svgTag) &amp;&amp; svgElement.parentNode() &amp;&amp; !svgElement.parentNode()-&gt;isSVGElement() &amp;&amp; !svgElement.correspondingElement();
 832     if (!isPositioningAllowed)
 833         style.setPosition(RenderStyle::initialPosition());
 834 
 835     // RenderSVGRoot handles zooming for the whole SVG subtree, so foreignObject content should
 836     // not be scaled again.
 837     if (svgElement.hasTagName(SVGNames::foreignObjectTag))
 838         style.setEffectiveZoom(RenderStyle::initialZoom());
 839 
 840     // SVG text layout code expects us to be a block-level style element.
 841     if ((svgElement.hasTagName(SVGNames::foreignObjectTag) || svgElement.hasTagName(SVGNames::textTag)) &amp;&amp; style.isDisplayInlineType())
 842         style.setDisplay(DisplayType::Block);
 843 }
 844 
 845 void StyleResolver::adjustRenderStyle(RenderStyle&amp; style, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const Element* element)
 846 {
 847     // If the composed tree parent has display:contents, the parent box style will be different from the parent style.
 848     // We don&#39;t have it when resolving computed style for display:none subtree. Use parent style for adjustments in that case.
 849     if (!parentBoxStyle)
 850         parentBoxStyle = &amp;parentStyle;
 851 
 852     // Cache our original display.
 853     style.setOriginalDisplay(style.display());
 854 
 855     if (style.display() == DisplayType::Contents)
 856         adjustDisplayContentsStyle(style, element);
 857 
 858     if (style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents) {
 859         if (element) {
 860             // If we have a &lt;td&gt; that specifies a float property, in quirks mode we just drop the float
 861             // property.
 862             // Sites also commonly use display:inline/block on &lt;td&gt;s and &lt;table&gt;s. In quirks mode we force
 863             // these tags to retain their display types.
 864             if (document().inQuirksMode()) {
 865                 if (element-&gt;hasTagName(tdTag)) {
 866                     style.setDisplay(DisplayType::TableCell);
 867                     style.setFloating(Float::No);
 868                 } else if (is&lt;HTMLTableElement&gt;(*element))
 869                     style.setDisplay(style.isDisplayInlineType() ? DisplayType::InlineTable : DisplayType::Table);
 870             }
 871 
 872             if (element-&gt;hasTagName(tdTag) || element-&gt;hasTagName(thTag)) {
 873                 if (style.whiteSpace() == WhiteSpace::KHTMLNoWrap) {
 874                     // Figure out if we are really nowrapping or if we should just
 875                     // use normal instead. If the width of the cell is fixed, then
 876                     // we don&#39;t actually use WhiteSpace::NoWrap.
 877                     if (style.width().isFixed())
 878                         style.setWhiteSpace(WhiteSpace::Normal);
 879                     else
 880                         style.setWhiteSpace(WhiteSpace::NoWrap);
 881                 }
 882             }
 883 
 884             // Tables never support the -webkit-* values for text-align and will reset back to the default.
 885             if (is&lt;HTMLTableElement&gt;(*element) &amp;&amp; (style.textAlign() == TextAlignMode::WebKitLeft || style.textAlign() == TextAlignMode::WebKitCenter || style.textAlign() == TextAlignMode::WebKitRight))
 886                 style.setTextAlign(TextAlignMode::Start);
 887 
 888             // Frames and framesets never honor position:relative or position:absolute. This is necessary to
 889             // fix a crash where a site tries to position these objects. They also never honor display.
 890             if (element-&gt;hasTagName(frameTag) || element-&gt;hasTagName(framesetTag)) {
 891                 style.setPosition(PositionType::Static);
 892                 style.setDisplay(DisplayType::Block);
 893             }
 894 
 895             // Ruby text does not support float or position. This might change with evolution of the specification.
 896             if (element-&gt;hasTagName(rtTag)) {
 897                 style.setPosition(PositionType::Static);
 898                 style.setFloating(Float::No);
 899             }
 900 
 901             // User agents are expected to have a rule in their user agent stylesheet that matches th elements that have a parent
 902             // node whose computed value for the &#39;text-align&#39; property is its initial value, whose declaration block consists of
 903             // just a single declaration that sets the &#39;text-align&#39; property to the value &#39;center&#39;.
 904             // https://html.spec.whatwg.org/multipage/rendering.html#rendering
 905             if (element-&gt;hasTagName(thTag) &amp;&amp; !style.hasExplicitlySetTextAlign() &amp;&amp; parentStyle.textAlign() == RenderStyle::initialTextAlign())
 906                 style.setTextAlign(TextAlignMode::Center);
 907 
 908             if (element-&gt;hasTagName(legendTag))
 909                 style.setDisplay(DisplayType::Block);
 910         }
 911 
 912         // Absolute/fixed positioned elements, floating elements and the document element need block-like outside display.
 913         if (style.hasOutOfFlowPosition() || style.isFloating() || (element &amp;&amp; element-&gt;document().documentElement() == element))
 914             style.setDisplay(equivalentBlockDisplay(style, document()));
 915 
 916         // FIXME: Don&#39;t support this mutation for pseudo styles like first-letter or first-line, since it&#39;s not completely
 917         // clear how that should work.
 918         if (style.display() == DisplayType::Inline &amp;&amp; style.styleType() == PseudoId::None &amp;&amp; style.writingMode() != parentStyle.writingMode())
 919             style.setDisplay(DisplayType::InlineBlock);
 920 
 921         // After performing the display mutation, check table rows. We do not honor position:relative or position:sticky on
 922         // table rows or cells. This has been established for position:relative in CSS2.1 (and caused a crash in containingBlock()
 923         // on some sites).
 924         if ((style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRowGroup
 925             || style.display() == DisplayType::TableFooterGroup || style.display() == DisplayType::TableRow)
 926             &amp;&amp; style.position() == PositionType::Relative)
 927             style.setPosition(PositionType::Static);
 928 
 929         // writing-mode does not apply to table row groups, table column groups, table rows, and table columns.
 930         // FIXME: Table cells should be allowed to be perpendicular or flipped with respect to the table, though.
 931         if (style.display() == DisplayType::TableColumn || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableFooterGroup
 932             || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableRowGroup
 933             || style.display() == DisplayType::TableCell)
 934             style.setWritingMode(parentStyle.writingMode());
 935 
 936         // FIXME: Since we don&#39;t support block-flow on flexible boxes yet, disallow setting
 937         // of block-flow to anything other than TopToBottomWritingMode.
 938         // https://bugs.webkit.org/show_bug.cgi?id=46418 - Flexible box support.
 939         if (style.writingMode() != TopToBottomWritingMode &amp;&amp; (style.display() == DisplayType::Box || style.display() == DisplayType::InlineBox))
 940             style.setWritingMode(TopToBottomWritingMode);
 941 
 942         // https://www.w3.org/TR/css-display/#transformations
 943         // &quot;A parent with a grid or flex display value blockifies the boxâ€™s display type.&quot;
 944         if (parentBoxStyle-&gt;isDisplayFlexibleOrGridBox()) {
 945             style.setFloating(Float::No);
 946             style.setDisplay(equivalentBlockDisplay(style, document()));
 947         }
 948     }
 949 
 950     // Make sure our z-index value is only applied if the object is positioned.
 951     if (style.position() == PositionType::Static &amp;&amp; !parentBoxStyle-&gt;isDisplayFlexibleOrGridBox())
 952         style.setHasAutoZIndex();
 953 
 954     // Auto z-index becomes 0 for the root element and transparent objects. This prevents
 955     // cases where objects that should be blended as a single unit end up with a non-transparent
 956     // object wedged in between them. Auto z-index also becomes 0 for objects that specify transforms/masks/reflections.
 957     if (style.hasAutoZIndex()) {
 958         if ((element &amp;&amp; element-&gt;document().documentElement() == element)
 959             || style.opacity() &lt; 1.0f
 960             || style.hasTransformRelatedProperty()
 961             || style.hasMask()
 962             || style.clipPath()
 963             || style.boxReflect()
 964             || style.hasFilter()
 965 #if ENABLE(FILTERS_LEVEL_2)
 966             || style.hasBackdropFilter()
 967 #endif
 968             || style.hasBlendMode()
 969             || style.hasIsolation()
 970             || style.position() == PositionType::Sticky
 971             || style.position() == PositionType::Fixed
 972             || style.willChangeCreatesStackingContext())
 973             style.setZIndex(0);
 974     }
 975 
 976     if (element) {
 977         // Textarea considers overflow visible as auto.
 978         if (is&lt;HTMLTextAreaElement&gt;(*element)) {
 979             style.setOverflowX(style.overflowX() == Overflow::Visible ? Overflow::Auto : style.overflowX());
 980             style.setOverflowY(style.overflowY() == Overflow::Visible ? Overflow::Auto : style.overflowY());
 981         }
 982 
 983         // Disallow -webkit-user-modify on :pseudo and ::pseudo elements.
 984         if (!element-&gt;shadowPseudoId().isNull())
 985             style.setUserModify(UserModify::ReadOnly);
 986 
 987         if (is&lt;HTMLMarqueeElement&gt;(*element)) {
 988             // For now, &lt;marquee&gt; requires an overflow clip to work properly.
 989             style.setOverflowX(Overflow::Hidden);
 990             style.setOverflowY(Overflow::Hidden);
 991 
 992             bool isVertical = style.marqueeDirection() == MarqueeDirection::Up || style.marqueeDirection() == MarqueeDirection::Down;
 993             // Make horizontal marquees not wrap.
 994             if (!isVertical) {
 995                 style.setWhiteSpace(WhiteSpace::NoWrap);
 996                 style.setTextAlign(TextAlignMode::Start);
 997             }
 998             // Apparently this is the expected legacy behavior.
 999             if (isVertical &amp;&amp; style.height().isAuto())
1000                 style.setHeight(Length(200, Fixed));
1001         }
1002     }
1003 
1004     if (doesNotInheritTextDecoration(style, element))
1005         style.setTextDecorationsInEffect(style.textDecoration());
1006     else
1007         style.addToTextDecorationsInEffect(style.textDecoration());
1008 
1009     // If either overflow value is not visible, change to auto.
1010     if (style.overflowX() == Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Visible) {
1011         // FIXME: Once we implement pagination controls, overflow-x should default to hidden
1012         // if overflow-y is set to -webkit-paged-x or -webkit-page-y. For now, we&#39;ll let it
1013         // default to auto so we can at least scroll through the pages.
1014         style.setOverflowX(Overflow::Auto);
1015     } else if (style.overflowY() == Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Visible)
1016         style.setOverflowY(Overflow::Auto);
1017 
1018     // Call setStylesForPaginationMode() if a pagination mode is set for any non-root elements. If these
1019     // styles are specified on a root element, then they will be incorporated in
1020     // Style::createForDocument().
1021     if ((style.overflowY() == Overflow::PagedX || style.overflowY() == Overflow::PagedY) &amp;&amp; !(element &amp;&amp; (element-&gt;hasTagName(htmlTag) || element-&gt;hasTagName(bodyTag))))
1022         style.setColumnStylesFromPaginationMode(WebCore::paginationModeForRenderStyle(style));
1023 
1024     // Table rows, sections and the table itself will support overflow:hidden and will ignore scroll/auto.
1025     // FIXME: Eventually table sections will support auto and scroll.
1026     if (style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
1027         || style.display() == DisplayType::TableRowGroup || style.display() == DisplayType::TableRow) {
1028         if (style.overflowX() != Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Hidden)
1029             style.setOverflowX(Overflow::Visible);
1030         if (style.overflowY() != Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Hidden)
1031             style.setOverflowY(Overflow::Visible);
1032     }
1033 
1034     // Menulists should have visible overflow
1035     if (style.appearance() == MenulistPart) {
1036         style.setOverflowX(Overflow::Visible);
1037         style.setOverflowY(Overflow::Visible);
1038     }
1039 
1040 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)
1041     // Touch overflow scrolling creates a stacking context.
1042     if (style.hasAutoZIndex() &amp;&amp; style.useTouchOverflowScrolling() &amp;&amp; (isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY())))
1043         style.setZIndex(0);
1044 #endif
1045 
1046     // Cull out any useless layers and also repeat patterns into additional layers.
1047     style.adjustBackgroundLayers();
1048     style.adjustMaskLayers();
1049 
1050     // Do the same for animations and transitions.
1051     style.adjustAnimations();
1052     style.adjustTransitions();
1053 
1054     // Important: Intrinsic margins get added to controls before the theme has adjusted the style, since the theme will
1055     // alter fonts and heights/widths.
1056     if (is&lt;HTMLFormControlElement&gt;(element) &amp;&amp; style.computedFontPixelSize() &gt;= 11) {
1057         // Don&#39;t apply intrinsic margins to image buttons. The designer knows how big the images are,
1058         // so we have to treat all image buttons as though they were explicitly sized.
1059         if (!is&lt;HTMLInputElement&gt;(*element) || !downcast&lt;HTMLInputElement&gt;(*element).isImageButton())
1060             addIntrinsicMargins(style);
1061     }
1062 
1063     // Let the theme also have a crack at adjusting the style.
1064     if (style.hasAppearance())
1065         RenderTheme::singleton().adjustStyle(*this, style, element, m_state.hasUAAppearance(), m_state.borderData(), m_state.backgroundData(), m_state.backgroundColor());
1066 
1067     // If we have first-letter pseudo style, do not share this style.
1068     if (style.hasPseudoStyle(PseudoId::FirstLetter))
1069         style.setUnique();
1070 
1071     // FIXME: when dropping the -webkit prefix on transform-style, we should also have opacity &lt; 1 cause flattening.
1072     if (style.preserves3D() &amp;&amp; (style.overflowX() != Overflow::Visible
1073         || style.overflowY() != Overflow::Visible
1074         || style.hasClip()
1075         || style.clipPath()
1076         || style.hasFilter()
1077 #if ENABLE(FILTERS_LEVEL_2)
1078         || style.hasBackdropFilter()
1079 #endif
1080         || style.hasBlendMode()))
1081         style.setTransformStyle3D(TransformStyle3D::Flat);
1082 
1083     if (is&lt;SVGElement&gt;(element))
1084         adjustSVGElementStyle(downcast&lt;SVGElement&gt;(*element), style);
1085 
1086     // If the inherited value of justify-items includes the &#39;legacy&#39; keyword (plus &#39;left&#39;, &#39;right&#39; or
1087     // &#39;center&#39;), &#39;legacy&#39; computes to the the inherited value. Otherwise, &#39;auto&#39; computes to &#39;normal&#39;.
1088     if (parentBoxStyle-&gt;justifyItems().positionType() == ItemPositionType::Legacy &amp;&amp; style.justifyItems().position() == ItemPosition::Legacy)
1089         style.setJustifyItems(parentBoxStyle-&gt;justifyItems());
1090 }
1091 
1092 static void checkForOrientationChange(RenderStyle* style)
1093 {
1094     FontOrientation fontOrientation;
1095     NonCJKGlyphOrientation glyphOrientation;
1096     std::tie(fontOrientation, glyphOrientation) = style-&gt;fontAndGlyphOrientation();
1097 
1098     const auto&amp; fontDescription = style-&gt;fontDescription();
1099     if (fontDescription.orientation() == fontOrientation &amp;&amp; fontDescription.nonCJKGlyphOrientation() == glyphOrientation)
1100         return;
1101 
1102     auto newFontDescription = fontDescription;
1103     newFontDescription.setNonCJKGlyphOrientation(glyphOrientation);
1104     newFontDescription.setOrientation(fontOrientation);
1105     style-&gt;setFontDescription(WTFMove(newFontDescription));
1106 }
1107 
1108 void StyleResolver::updateFont()
1109 {
1110     if (!m_state.fontDirty())
1111         return;
1112 
1113     RenderStyle* style = m_state.style();
1114 #if ENABLE(TEXT_AUTOSIZING)
1115     checkForTextSizeAdjust(style);
1116 #endif
1117     checkForGenericFamilyChange(style, m_state.parentStyle());
1118     checkForZoomChange(style, m_state.parentStyle());
1119     checkForOrientationChange(style);
1120     style-&gt;fontCascade().update(&amp;document().fontSelector());
1121     if (m_state.fontSizeHasViewportUnits())
1122         style-&gt;setHasViewportUnits(true);
1123     m_state.setFontDirty(false);
1124 }
1125 
1126 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::styleRulesForElement(const Element* element, unsigned rulesToInclude)
1127 {
1128     return pseudoStyleRulesForElement(element, PseudoId::None, rulesToInclude);
1129 }
1130 
1131 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleResolver::pseudoStyleRulesForElement(const Element* element, PseudoId pseudoId, unsigned rulesToInclude)
1132 {
1133     if (!element)
1134         return { };
1135 
1136     m_state = State(*element, nullptr);
1137 
1138     ElementRuleCollector collector(*element, m_ruleSets, m_state.selectorFilter());
1139     collector.setMode(SelectorChecker::Mode::CollectingRules);
1140     collector.setPseudoStyleRequest(PseudoStyleRequest(pseudoId));
1141     collector.setMedium(&amp;m_mediaQueryEvaluator);
1142 
1143     if (rulesToInclude &amp; UAAndUserCSSRules) {
1144         // First we match rules from the user agent sheet.
1145         collector.matchUARules();
1146 
1147         // Now we check user sheet rules.
1148         if (m_matchAuthorAndUserStyles)
1149             collector.matchUserRules(rulesToInclude &amp; EmptyCSSRules);
1150     }
1151 
1152     if (m_matchAuthorAndUserStyles &amp;&amp; (rulesToInclude &amp; AuthorCSSRules))
1153         collector.matchAuthorRules(rulesToInclude &amp; EmptyCSSRules);
1154 
1155     return collector.matchedRuleList();
1156 }
1157 
1158 static bool shouldApplyPropertyInParseOrder(CSSPropertyID propertyID)
1159 {
1160     switch (propertyID) {
1161     case CSSPropertyWebkitBackgroundClip:
1162     case CSSPropertyBackgroundClip:
1163     case CSSPropertyWebkitBackgroundOrigin:
1164     case CSSPropertyBackgroundOrigin:
1165     case CSSPropertyWebkitBackgroundSize:
1166     case CSSPropertyBackgroundSize:
1167     case CSSPropertyWebkitBorderImage:
1168     case CSSPropertyBorderImage:
1169     case CSSPropertyBorderImageSlice:
1170     case CSSPropertyBorderImageSource:
1171     case CSSPropertyBorderImageOutset:
1172     case CSSPropertyBorderImageRepeat:
1173     case CSSPropertyBorderImageWidth:
1174     case CSSPropertyWebkitBoxShadow:
1175     case CSSPropertyBoxShadow:
1176     case CSSPropertyWebkitTextDecoration:
1177     case CSSPropertyTextDecorationLine:
1178     case CSSPropertyTextDecorationStyle:
1179     case CSSPropertyTextDecorationColor:
1180     case CSSPropertyTextDecorationSkip:
1181     case CSSPropertyTextUnderlinePosition:
1182     case CSSPropertyTextUnderlineOffset:
1183     case CSSPropertyTextDecorationThickness:
1184     case CSSPropertyTextDecoration:
1185         return true;
1186     default:
1187         return false;
1188     }
1189 }
1190 
1191 static bool elementTypeHasAppearanceFromUAStyle(const Element&amp; element)
1192 {
1193     // NOTE: This is just a hard-coded list of elements that have some -webkit-appearance value in html.css
1194     const auto&amp; localName = element.localName();
1195     return localName == HTMLNames::inputTag
1196         || localName == HTMLNames::textareaTag
1197         || localName == HTMLNames::buttonTag
1198         || localName == HTMLNames::progressTag
1199         || localName == HTMLNames::selectTag
1200         || localName == HTMLNames::meterTag;
1201 }
1202 
1203 unsigned StyleResolver::computeMatchedPropertiesHash(const MatchedProperties* properties, unsigned size)
1204 {
1205     return StringHasher::hashMemory(properties, sizeof(MatchedProperties) * size);
1206 }
1207 
1208 bool operator==(const StyleResolver::MatchRanges&amp; a, const StyleResolver::MatchRanges&amp; b)
1209 {
1210     return a.firstUARule == b.firstUARule
1211         &amp;&amp; a.lastUARule == b.lastUARule
1212         &amp;&amp; a.firstAuthorRule == b.firstAuthorRule
1213         &amp;&amp; a.lastAuthorRule == b.lastAuthorRule
1214         &amp;&amp; a.firstUserRule == b.firstUserRule
1215         &amp;&amp; a.lastUserRule == b.lastUserRule;
1216 }
1217 
1218 bool operator!=(const StyleResolver::MatchRanges&amp; a, const StyleResolver::MatchRanges&amp; b)
1219 {
1220     return !(a == b);
1221 }
1222 
1223 bool operator==(const StyleResolver::MatchedProperties&amp; a, const StyleResolver::MatchedProperties&amp; b)
1224 {
1225     return a.properties == b.properties &amp;&amp; a.linkMatchType == b.linkMatchType;
1226 }
1227 
1228 bool operator!=(const StyleResolver::MatchedProperties&amp; a, const StyleResolver::MatchedProperties&amp; b)
1229 {
1230     return !(a == b);
1231 }
1232 
1233 const StyleResolver::MatchedPropertiesCacheItem* StyleResolver::findFromMatchedPropertiesCache(unsigned hash, const MatchResult&amp; matchResult)
1234 {
1235     ASSERT(hash);
1236 
1237     MatchedPropertiesCache::iterator it = m_matchedPropertiesCache.find(hash);
1238     if (it == m_matchedPropertiesCache.end())
1239         return nullptr;
1240     MatchedPropertiesCacheItem&amp; cacheItem = it-&gt;value;
1241 
1242     size_t size = matchResult.matchedProperties().size();
1243     if (size != cacheItem.matchedProperties.size())
1244         return nullptr;
1245     for (size_t i = 0; i &lt; size; ++i) {
1246         if (matchResult.matchedProperties()[i] != cacheItem.matchedProperties[i])
1247             return nullptr;
1248     }
1249     if (cacheItem.ranges != matchResult.ranges)
1250         return nullptr;
1251     return &amp;cacheItem;
1252 }
1253 
1254 void StyleResolver::addToMatchedPropertiesCache(const RenderStyle* style, const RenderStyle* parentStyle, unsigned hash, const MatchResult&amp; matchResult)
1255 {
1256     static const unsigned matchedDeclarationCacheAdditionsBetweenSweeps = 100;
1257     if (++m_matchedPropertiesCacheAdditionsSinceLastSweep &gt;= matchedDeclarationCacheAdditionsBetweenSweeps
1258         &amp;&amp; !m_matchedPropertiesCacheSweepTimer.isActive()) {
1259         static const Seconds matchedDeclarationCacheSweepTime { 1_min };
1260         m_matchedPropertiesCacheSweepTimer.startOneShot(matchedDeclarationCacheSweepTime);
1261     }
1262 
1263     ASSERT(hash);
1264     // Note that we don&#39;t cache the original RenderStyle instance. It may be further modified.
1265     // The RenderStyle in the cache is really just a holder for the substructures and never used as-is.
1266     MatchedPropertiesCacheItem cacheItem(matchResult, style, parentStyle);
1267     m_matchedPropertiesCache.add(hash, WTFMove(cacheItem));
1268 }
1269 
1270 void StyleResolver::invalidateMatchedPropertiesCache()
1271 {
1272     m_matchedPropertiesCache.clear();
1273 }
1274 
1275 void StyleResolver::clearCachedPropertiesAffectedByViewportUnits()
1276 {
1277     Vector&lt;unsigned, 16&gt; toRemove;
1278     for (auto&amp; cacheKeyValue : m_matchedPropertiesCache) {
1279         if (cacheKeyValue.value.renderStyle-&gt;hasViewportUnits())
1280             toRemove.append(cacheKeyValue.key);
1281     }
1282     for (auto key : toRemove)
1283         m_matchedPropertiesCache.remove(key);
1284 }
1285 
1286 static bool isCacheableInMatchedPropertiesCache(const Element&amp; element, const RenderStyle* style, const RenderStyle* parentStyle)
1287 {
1288     // FIXME: Writing mode and direction properties modify state when applying to document element by calling
1289     // Document::setWritingMode/DirectionSetOnDocumentElement. We can&#39;t skip the applying by caching.
1290     if (&amp;element == element.document().documentElement())
1291         return false;
1292     // content:attr() value depends on the element it is being applied to.
1293     if (style-&gt;hasAttrContent() || (style-&gt;styleType() != PseudoId::None &amp;&amp; parentStyle-&gt;hasAttrContent()))
1294         return false;
1295     if (style-&gt;hasAppearance())
1296         return false;
1297     if (style-&gt;zoom() != RenderStyle::initialZoom())
1298         return false;
1299     if (style-&gt;writingMode() != RenderStyle::initialWritingMode() || style-&gt;direction() != RenderStyle::initialDirection())
1300         return false;
1301     // The cache assumes static knowledge about which properties are inherited.
1302     if (style-&gt;hasExplicitlyInheritedProperties())
1303         return false;
1304     return true;
1305 }
1306 
1307 void extractDirectionAndWritingMode(const RenderStyle&amp; style, const StyleResolver::MatchResult&amp; matchResult, TextDirection&amp; direction, WritingMode&amp; writingMode)
1308 {
1309     direction = style.direction();
1310     writingMode = style.writingMode();
1311 
1312     bool hadImportantWritingMode = false;
1313     bool hadImportantDirection = false;
1314 
1315     for (const auto&amp; matchedProperties : matchResult.matchedProperties()) {
1316         for (unsigned i = 0, count = matchedProperties.properties-&gt;propertyCount(); i &lt; count; ++i) {
1317             auto property = matchedProperties.properties-&gt;propertyAt(i);
1318             if (!property.value()-&gt;isPrimitiveValue())
1319                 continue;
1320             switch (property.id()) {
1321             case CSSPropertyWritingMode:
1322                 if (!hadImportantWritingMode || property.isImportant()) {
1323                     writingMode = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
1324                     hadImportantWritingMode = property.isImportant();
1325                 }
1326                 break;
1327             case CSSPropertyDirection:
1328                 if (!hadImportantDirection || property.isImportant()) {
1329                     direction = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
1330                     hadImportantDirection = property.isImportant();
1331                 }
1332                 break;
1333             default:
1334                 break;
1335             }
1336         }
1337     }
1338 }
1339 
1340 void StyleResolver::applyMatchedProperties(const MatchResult&amp; matchResult, const Element&amp; element, ShouldUseMatchedPropertiesCache shouldUseMatchedPropertiesCache)
1341 {
1342     State&amp; state = m_state;
1343     unsigned cacheHash = shouldUseMatchedPropertiesCache &amp;&amp; matchResult.isCacheable ? computeMatchedPropertiesHash(matchResult.matchedProperties().data(), matchResult.matchedProperties().size()) : 0;
1344     bool applyInheritedOnly = false;
1345     const MatchedPropertiesCacheItem* cacheItem = nullptr;
1346     if (cacheHash &amp;&amp; (cacheItem = findFromMatchedPropertiesCache(cacheHash, matchResult))
1347         &amp;&amp; isCacheableInMatchedPropertiesCache(element, state.style(), state.parentStyle())) {
1348         // We can build up the style by copying non-inherited properties from an earlier style object built using the same exact
1349         // style declarations. We then only need to apply the inherited properties, if any, as their values can depend on the
1350         // element context. This is fast and saves memory by reusing the style data structures.
1351         state.style()-&gt;copyNonInheritedFrom(*cacheItem-&gt;renderStyle);
1352         if (state.parentStyle()-&gt;inheritedDataShared(cacheItem-&gt;parentRenderStyle.get()) &amp;&amp; !isAtShadowBoundary(element)) {
1353             InsideLink linkStatus = state.style()-&gt;insideLink();
1354             // If the cache item parent style has identical inherited properties to the current parent style then the
1355             // resulting style will be identical too. We copy the inherited properties over from the cache and are done.
1356             state.style()-&gt;inheritFrom(*cacheItem-&gt;renderStyle);
1357 
1358             // Unfortunately the link status is treated like an inherited property. We need to explicitly restore it.
1359             state.style()-&gt;setInsideLink(linkStatus);
1360             return;
1361         }
1362         applyInheritedOnly = true;
1363     }
1364 
1365     // Directional properties (*-before/after) are aliases that depend on the TextDirection and WritingMode.
1366     // These must be resolved before we can begin the property cascade.
1367     TextDirection direction;
1368     WritingMode writingMode;
1369     extractDirectionAndWritingMode(*state.style(), matchResult, direction, writingMode);
1370 
1371     if (elementTypeHasAppearanceFromUAStyle(*state.element())) {
1372         // FIXME: This is such a hack.
1373         // Find out if there&#39;s a -webkit-appearance property in effect from the UA sheet.
1374         // If so, we cache the border and background styles so that RenderTheme::adjustStyle()
1375         // can look at them later to figure out if this is a styled form control or not.
1376         CascadedProperties cascade(direction, writingMode);
1377         cascade.addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1378         cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1379 
1380         ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1381 
1382         applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1383         adjustStyleForInterCharacterRuby();
1384 
1385 #if ENABLE(DARK_MODE_CSS)
1386         // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
1387         applyCascadedProperties(CSSPropertySupportedColorSchemes, CSSPropertySupportedColorSchemes, applyState);
1388 #endif
1389 
1390         applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1391 
1392         // If our font got dirtied, update it now.
1393         updateFont();
1394 
1395         // Now resolve remaining custom properties and the rest, in any order
1396         for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1397             applyCascadedCustomProperty(it-&gt;key, applyState);
1398         applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1399 
1400         state.cacheBorderAndBackground();
1401     }
1402 
1403     CascadedProperties cascade(direction, writingMode);
1404     cascade.addNormalMatches(matchResult, 0, matchResult.matchedProperties().size() - 1, applyInheritedOnly);
1405     cascade.addImportantMatches(matchResult, matchResult.ranges.firstAuthorRule, matchResult.ranges.lastAuthorRule, applyInheritedOnly);
1406     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, applyInheritedOnly);
1407     cascade.addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, applyInheritedOnly);
1408 
1409     ApplyCascadedPropertyState applyState { this, &amp;cascade, &amp;matchResult };
1410 
1411     applyCascadedProperties(CSSPropertyWebkitRubyPosition, CSSPropertyWebkitRubyPosition, applyState);
1412     adjustStyleForInterCharacterRuby();
1413 
1414 #if ENABLE(DARK_MODE_CSS)
1415     // Supported color schemes can affect resolved colors, so we need to apply that property before any color properties.
1416     applyCascadedProperties(CSSPropertySupportedColorSchemes, CSSPropertySupportedColorSchemes, applyState);
1417 #endif
1418 
1419     applyCascadedProperties(firstCSSProperty, lastHighPriorityProperty, applyState);
1420 
1421     // If the effective zoom value changes, we can&#39;t use the matched properties cache. Start over.
1422     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;effectiveZoom() != state.style()-&gt;effectiveZoom())
1423         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1424 
1425     // If our font got dirtied, update it now.
1426     updateFont();
1427 
1428     // If the font changed, we can&#39;t use the matched properties cache. Start over.
1429     if (cacheItem &amp;&amp; cacheItem-&gt;renderStyle-&gt;fontDescription() != state.style()-&gt;fontDescription())
1430         return applyMatchedProperties(matchResult, element, DoNotUseMatchedPropertiesCache);
1431 
1432     // Now resolve remaining custom properties and the rest, in any order
1433     for (auto it = cascade.customProperties().begin(); it != cascade.customProperties().end(); ++it)
1434         applyCascadedCustomProperty(it-&gt;key, applyState);
1435     applyCascadedProperties(firstLowPriorityProperty, lastCSSProperty, applyState);
1436 
1437     // Finally, some properties must be applied in the order they were parsed.
1438     // There are some CSS properties that affect the same RenderStyle values,
1439     // so to preserve behavior, we queue them up during cascade and flush here.
1440     cascade.applyDeferredProperties(*this, applyState);
1441 
1442     ASSERT(!state.fontDirty());
1443 
1444     if (cacheItem || !cacheHash)
1445         return;
1446     if (!isCacheableInMatchedPropertiesCache(*state.element(), state.style(), state.parentStyle()))
1447         return;
1448     addToMatchedPropertiesCache(state.style(), state.parentStyle(), cacheHash, matchResult);
1449 }
1450 
1451 void StyleResolver::applyPropertyToStyle(CSSPropertyID id, CSSValue* value, std::unique_ptr&lt;RenderStyle&gt; style)
1452 {
1453     m_state = State();
1454     m_state.setParentStyle(RenderStyle::clonePtr(*style));
1455     m_state.setStyle(WTFMove(style));
1456     applyPropertyToCurrentStyle(id, value);
1457 }
1458 
1459 void StyleResolver::applyPropertyToCurrentStyle(CSSPropertyID id, CSSValue* value)
1460 {
1461     ApplyCascadedPropertyState applyState { this, nullptr, nullptr };
1462     if (value)
1463         applyProperty(id, value, applyState);
1464 }
1465 
1466 inline bool isValidVisitedLinkProperty(CSSPropertyID id)
1467 {
1468     switch (id) {
1469     case CSSPropertyBackgroundColor:
1470     case CSSPropertyBorderLeftColor:
1471     case CSSPropertyBorderRightColor:
1472     case CSSPropertyBorderTopColor:
1473     case CSSPropertyBorderBottomColor:
1474     case CSSPropertyCaretColor:
1475     case CSSPropertyColor:
1476     case CSSPropertyOutlineColor:
1477     case CSSPropertyColumnRuleColor:
1478     case CSSPropertyTextDecorationColor:
1479     case CSSPropertyWebkitTextEmphasisColor:
1480     case CSSPropertyWebkitTextFillColor:
1481     case CSSPropertyWebkitTextStrokeColor:
1482     case CSSPropertyFill:
1483     case CSSPropertyStroke:
1484     case CSSPropertyStrokeColor:
1485         return true;
1486     default:
1487         break;
1488     }
1489 
1490     return false;
1491 }
1492 
1493 // https://www.w3.org/TR/css-pseudo-4/#marker-pseudo (Editor&#39;s Draft, 25 July 2017)
1494 static inline bool isValidMarkerStyleProperty(CSSPropertyID id)
1495 {
1496     switch (id) {
1497     case CSSPropertyColor:
1498     case CSSPropertyFontFamily:
1499     case CSSPropertyFontFeatureSettings:
1500     case CSSPropertyFontSize:
1501     case CSSPropertyFontStretch:
1502     case CSSPropertyFontStyle:
1503     case CSSPropertyFontSynthesis:
1504     case CSSPropertyFontVariantAlternates:
1505     case CSSPropertyFontVariantCaps:
1506     case CSSPropertyFontVariantEastAsian:
1507     case CSSPropertyFontVariantLigatures:
1508     case CSSPropertyFontVariantNumeric:
1509     case CSSPropertyFontVariantPosition:
1510     case CSSPropertyFontWeight:
1511 #if ENABLE(VARIATION_FONTS)
1512     case CSSPropertyFontOpticalSizing:
1513     case CSSPropertyFontVariationSettings:
1514 #endif
1515         return true;
1516     default:
1517         break;
1518     }
1519     return false;
1520 }
1521 
1522 #if ENABLE(VIDEO_TRACK)
1523 static inline bool isValidCueStyleProperty(CSSPropertyID id)
1524 {
1525     switch (id) {
1526     case CSSPropertyBackground:
1527     case CSSPropertyBackgroundAttachment:
1528     case CSSPropertyBackgroundClip:
1529     case CSSPropertyBackgroundColor:
1530     case CSSPropertyBackgroundImage:
1531     case CSSPropertyBackgroundOrigin:
1532     case CSSPropertyBackgroundPosition:
1533     case CSSPropertyBackgroundPositionX:
1534     case CSSPropertyBackgroundPositionY:
1535     case CSSPropertyBackgroundRepeat:
1536     case CSSPropertyBackgroundSize:
1537     case CSSPropertyColor:
1538     case CSSPropertyFont:
1539     case CSSPropertyFontFamily:
1540     case CSSPropertyFontSize:
1541     case CSSPropertyFontStyle:
1542     case CSSPropertyFontVariantCaps:
1543     case CSSPropertyFontWeight:
1544     case CSSPropertyLineHeight:
1545     case CSSPropertyOpacity:
1546     case CSSPropertyOutline:
1547     case CSSPropertyOutlineColor:
1548     case CSSPropertyOutlineOffset:
1549     case CSSPropertyOutlineStyle:
1550     case CSSPropertyOutlineWidth:
1551     case CSSPropertyVisibility:
1552     case CSSPropertyWhiteSpace:
1553     case CSSPropertyTextDecoration:
1554     case CSSPropertyTextShadow:
1555     case CSSPropertyBorderStyle:
1556     case CSSPropertyPaintOrder:
1557     case CSSPropertyStrokeLinejoin:
1558     case CSSPropertyStrokeLinecap:
1559     case CSSPropertyStrokeColor:
1560     case CSSPropertyStrokeWidth:
1561         return true;
1562     default:
1563         break;
1564     }
1565     return false;
1566 }
1567 #endif
1568 // SVG handles zooming in a different way compared to CSS. The whole document is scaled instead
1569 // of each individual length value in the render style / tree. CSSPrimitiveValue::computeLength*()
1570 // multiplies each resolved length with the zoom multiplier - so for SVG we need to disable that.
1571 // Though all CSS values that can be applied to outermost &lt;svg&gt; elements (width/height/border/padding...)
1572 // need to respect the scaling. RenderBox (the parent class of RenderSVGRoot) grabs values like
1573 // width/height/border/padding/... from the RenderStyle -&gt; for SVG these values would never scale,
1574 // if we&#39;d pass a 1.0 zoom factor everyhwere. So we only pass a zoom factor of 1.0 for specific
1575 // properties that are NOT allowed to scale within a zoomed SVG document (letter/word-spacing/font-size).
1576 bool StyleResolver::useSVGZoomRules() const
1577 {
1578     return m_state.element() &amp;&amp; m_state.element()-&gt;isSVGElement();
1579 }
1580 
1581 // Scale with/height properties on inline SVG root.
1582 bool StyleResolver::useSVGZoomRulesForLength() const
1583 {
1584     return is&lt;SVGElement&gt;(m_state.element()) &amp;&amp; !(is&lt;SVGSVGElement&gt;(*m_state.element()) &amp;&amp; m_state.element()-&gt;parentNode());
1585 }
1586 
1587 StyleResolver::CascadedProperties* StyleResolver::cascadedPropertiesForRollback(const MatchResult&amp; matchResult)
1588 {
1589     ASSERT(cascadeLevel() != CascadeLevel::UserAgentLevel);
1590 
1591     TextDirection direction;
1592     WritingMode writingMode;
1593     extractDirectionAndWritingMode(*state().style(), matchResult, direction, writingMode);
1594 
1595     if (cascadeLevel() == CascadeLevel::AuthorLevel) {
1596         CascadedProperties* authorRollback = state().authorRollback();
1597         if (authorRollback)
1598             return authorRollback;
1599 
1600         auto newAuthorRollback(std::make_unique&lt;CascadedProperties&gt;(direction, writingMode));
1601 
1602         // This special rollback cascade contains UA rules and user rules but no author rules.
1603         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1604         newAuthorRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1605         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUserRule, matchResult.ranges.lastUserRule, false);
1606         newAuthorRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1607 
1608         state().setAuthorRollback(newAuthorRollback);
1609         return state().authorRollback();
1610     }
1611 
1612     if (cascadeLevel() == CascadeLevel::UserLevel) {
1613         CascadedProperties* userRollback = state().userRollback();
1614         if (userRollback)
1615             return userRollback;
1616 
1617         auto newUserRollback(std::make_unique&lt;CascadedProperties&gt;(direction, writingMode));
1618 
1619         // This special rollback cascade contains only UA rules.
1620         newUserRollback-&gt;addNormalMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1621         newUserRollback-&gt;addImportantMatches(matchResult, matchResult.ranges.firstUARule, matchResult.ranges.lastUARule, false);
1622 
1623         state().setUserRollback(newUserRollback);
1624         return state().userRollback();
1625     }
1626 
1627     return nullptr;
1628 }
1629 
1630 void StyleResolver::applyProperty(CSSPropertyID id, CSSValue* value, ApplyCascadedPropertyState&amp; applyState, SelectorChecker::LinkMatchMask linkMatchMask)
1631 {
1632     auto* matchResult = applyState.matchResult;
1633     ASSERT_WITH_MESSAGE(!isShorthandCSSProperty(id), &quot;Shorthand property id = %d wasn&#39;t expanded at parsing time&quot;, id);
1634 
1635     State&amp; state = m_state;
1636 
1637     RefPtr&lt;CSSValue&gt; valueToApply = value;
1638     if (value-&gt;hasVariableReferences()) {
1639         valueToApply = resolvedVariableValue(id, *value, applyState);
1640         // If appliedProperties already has this id, then we detected a cycle, and this value should be unset.
1641         if (!valueToApply || applyState.appliedProperties.get(id)) {
1642             if (CSSProperty::isInheritedProperty(id))
1643                 valueToApply = CSSValuePool::singleton().createInheritedValue();
1644             else
1645                 valueToApply = CSSValuePool::singleton().createExplicitInitialValue();
1646         }
1647     }
1648 
1649     if (CSSProperty::isDirectionAwareProperty(id)) {
1650         CSSPropertyID newId = CSSProperty::resolveDirectionAwareProperty(id, state.style()-&gt;direction(), state.style()-&gt;writingMode());
1651         ASSERT(newId != id);
1652         return applyProperty(newId, valueToApply.get(), applyState, linkMatchMask);
1653     }
1654 
1655     CSSValue* valueToCheckForInheritInitial = valueToApply.get();
1656     CSSCustomPropertyValue* customPropertyValue = nullptr;
1657     CSSValueID customPropertyValueID = CSSValueInvalid;
1658 
1659     CSSRegisteredCustomProperty* customPropertyRegistered = nullptr;
1660 
1661     if (id == CSSPropertyCustom) {
1662         customPropertyValue = &amp;downcast&lt;CSSCustomPropertyValue&gt;(*valueToApply);
1663         ASSERT(customPropertyValue-&gt;isResolved());
1664         if (WTF::holds_alternative&lt;CSSValueID&gt;(customPropertyValue-&gt;value()))
1665             customPropertyValueID = WTF::get&lt;CSSValueID&gt;(customPropertyValue-&gt;value());
1666         auto&amp; name = customPropertyValue-&gt;name();
1667         customPropertyRegistered = document().getCSSRegisteredCustomPropertySet().get(name);
1668     }
1669 
1670     bool isInherit = state.parentStyle() ? valueToCheckForInheritInitial-&gt;isInheritedValue() || customPropertyValueID == CSSValueInherit : false;
1671     bool isInitial = valueToCheckForInheritInitial-&gt;isInitialValue() || customPropertyValueID == CSSValueInitial || (!state.parentStyle() &amp;&amp; (valueToCheckForInheritInitial-&gt;isInheritedValue() || customPropertyValueID == CSSValueInherit));
1672 
1673     bool isUnset = valueToCheckForInheritInitial-&gt;isUnsetValue() || customPropertyValueID == CSSValueUnset;
1674     bool isRevert = valueToCheckForInheritInitial-&gt;isRevertValue() || customPropertyValueID == CSSValueRevert;
1675 
1676     if (isRevert) {
1677         if (cascadeLevel() == CascadeLevel::UserAgentLevel || !matchResult)
1678             isUnset = true;
1679         else {
1680             // Fetch the correct rollback object from the state, building it if necessary.
1681             // This requires having the original MatchResult available.
1682             auto* rollback = cascadedPropertiesForRollback(*matchResult);
1683             ASSERT(rollback);
1684 
1685             // With the cascade built, we need to obtain the property and apply it. If the property is
1686             // not present, then we behave like &quot;unset.&quot; Otherwise we apply the property instead of
1687             // our own.
1688             if (customPropertyValue) {
1689                 if (customPropertyRegistered &amp;&amp; customPropertyRegistered-&gt;inherits &amp;&amp; rollback-&gt;hasCustomProperty(customPropertyValue-&gt;name())) {
1690                     auto property = rollback-&gt;customProperty(customPropertyValue-&gt;name());
1691                     if (property.cssValue[linkMatchMask])
1692                         applyProperty(property.id, property.cssValue[linkMatchMask], applyState, linkMatchMask);
1693                     return;
1694                 }
1695             } else if (rollback-&gt;hasProperty(id)) {
1696                 auto&amp; property = rollback-&gt;property(id);
1697                 if (property.cssValue[linkMatchMask])
1698                     applyProperty(property.id, property.cssValue[linkMatchMask], applyState, linkMatchMask);
1699                 return;
1700             }
1701 
1702             isUnset = true;
1703         }
1704     }
1705 
1706     if (isUnset) {
1707         if (CSSProperty::isInheritedProperty(id))
1708             isInherit = true;
1709         else
1710             isInitial = true;
1711     }
1712 
1713     ASSERT(!isInherit || !isInitial); // isInherit -&gt; !isInitial &amp;&amp; isInitial -&gt; !isInherit
1714 
1715     if (!state.applyPropertyToRegularStyle() &amp;&amp; (!state.applyPropertyToVisitedLinkStyle() || !isValidVisitedLinkProperty(id))) {
1716         // Limit the properties that can be applied to only the ones honored by :visited.
1717         return;
1718     }
1719 
1720     if (isInherit &amp;&amp; !CSSProperty::isInheritedProperty(id))
1721         state.style()-&gt;setHasExplicitlyInheritedProperties();
1722 
1723 #if ENABLE(CSS_PAINTING_API)
1724     if (is&lt;CSSPaintImageValue&gt;(*valueToApply)) {
1725         auto&amp; name = downcast&lt;CSSPaintImageValue&gt;(*valueToApply).name();
1726         if (auto* paintWorklet = document().paintWorkletGlobalScopeForName(name)) {
1727             auto locker = holdLock(paintWorklet-&gt;paintDefinitionLock());
1728             if (auto* registration = paintWorklet-&gt;paintDefinitionMap().get(name)) {
1729                 for (auto&amp; property : registration-&gt;inputProperties)
1730                     state.style()-&gt;addCustomPaintWatchProperty(property);
1731             }
1732         }
1733     }
1734 #endif
1735 
1736     // Use the generated StyleBuilder.
1737     StyleBuilder::applyProperty(id, *this, *valueToApply, isInitial, isInherit, customPropertyRegistered);
1738 }
1739 
1740 RefPtr&lt;CSSValue&gt; StyleResolver::resolvedVariableValue(CSSPropertyID propID, const CSSValue&amp; value, ApplyCascadedPropertyState&amp; state) const
1741 {
1742     CSSParser parser(document());
1743     return parser.parseValueWithVariableReferences(propID, value, state);
1744 }
1745 
1746 RefPtr&lt;StyleImage&gt; StyleResolver::styleImage(CSSValue&amp; value)
1747 {
1748     if (is&lt;CSSImageGeneratorValue&gt;(value)) {
1749         if (is&lt;CSSGradientValue&gt;(value))
1750             return StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(value).gradientWithStylesResolved(*this));
1751 
1752         if (is&lt;CSSFilterImageValue&gt;(value)) {
1753             // FilterImage needs to calculate FilterOperations.
1754             downcast&lt;CSSFilterImageValue&gt;(value).createFilterOperations(this);
1755         }
1756         return StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(value));
1757     }
1758 
1759     if (is&lt;CSSImageValue&gt;(value) || is&lt;CSSImageSetValue&gt;(value) || is&lt;CSSCursorImageValue&gt;(value))
1760         return StyleCachedImage::create(value);
1761 
1762     return nullptr;
1763 }
1764 
1765 #if ENABLE(TEXT_AUTOSIZING)
1766 void StyleResolver::checkForTextSizeAdjust(RenderStyle* style)
1767 {
1768     if (style-&gt;textSizeAdjust().isAuto())
1769         return;
1770 
1771     auto newFontDescription = style-&gt;fontDescription();
1772     if (!style-&gt;textSizeAdjust().isNone())
1773         newFontDescription.setComputedSize(newFontDescription.specifiedSize() * style-&gt;textSizeAdjust().multiplier());
1774     else
1775         newFontDescription.setComputedSize(newFontDescription.specifiedSize());
1776     style-&gt;setFontDescription(WTFMove(newFontDescription));
1777 }
1778 #endif
1779 
1780 void StyleResolver::checkForZoomChange(RenderStyle* style, const RenderStyle* parentStyle)
1781 {
1782     if (!parentStyle)
1783         return;
1784 
1785     if (style-&gt;effectiveZoom() == parentStyle-&gt;effectiveZoom() &amp;&amp; style-&gt;textZoom() == parentStyle-&gt;textZoom())
1786         return;
1787 
1788     const auto&amp; childFont = style-&gt;fontDescription();
1789     auto newFontDescription = childFont;
1790     setFontSize(newFontDescription, childFont.specifiedSize());
1791     style-&gt;setFontDescription(WTFMove(newFontDescription));
1792 }
1793 
1794 void StyleResolver::checkForGenericFamilyChange(RenderStyle* style, const RenderStyle* parentStyle)
1795 {
1796     const auto&amp; childFont = style-&gt;fontDescription();
1797 
1798     if (childFont.isAbsoluteSize() || !parentStyle)
1799         return;
1800 
1801     const auto&amp; parentFont = parentStyle-&gt;fontDescription();
1802     if (childFont.useFixedDefaultSize() == parentFont.useFixedDefaultSize())
1803         return;
1804     // We know the parent is monospace or the child is monospace, and that font
1805     // size was unspecified. We want to scale our font size as appropriate.
1806     // If the font uses a keyword size, then we refetch from the table rather than
1807     // multiplying by our scale factor.
1808     float size;
1809     if (CSSValueID sizeIdentifier = childFont.keywordSizeAsIdentifier())
1810         size = Style::fontSizeForKeyword(sizeIdentifier, childFont.useFixedDefaultSize(), document());
1811     else {
1812         float fixedScaleFactor = (settings().defaultFixedFontSize() &amp;&amp; settings().defaultFontSize())
1813             ? static_cast&lt;float&gt;(settings().defaultFixedFontSize()) / settings().defaultFontSize()
1814             : 1;
1815         size = parentFont.useFixedDefaultSize() ?
1816                 childFont.specifiedSize() / fixedScaleFactor :
1817                 childFont.specifiedSize() * fixedScaleFactor;
1818     }
1819 
1820     auto newFontDescription = childFont;
1821     setFontSize(newFontDescription, size);
1822     style-&gt;setFontDescription(WTFMove(newFontDescription));
1823 }
1824 
1825 void StyleResolver::initializeFontStyle()
1826 {
1827     FontCascadeDescription fontDescription;
1828     fontDescription.setRenderingMode(settings().fontRenderingMode());
1829     fontDescription.setOneFamily(standardFamily);
1830     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1831     setFontSize(fontDescription, Style::fontSizeForKeyword(CSSValueMedium, false, document()));
1832     fontDescription.setShouldAllowUserInstalledFonts(settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No);
1833     setFontDescription(WTFMove(fontDescription));
1834 }
1835 
1836 void StyleResolver::setFontSize(FontCascadeDescription&amp; fontDescription, float size)
1837 {
1838     fontDescription.setSpecifiedSize(size);
1839     fontDescription.setComputedSize(Style::computedFontSizeFromSpecifiedSize(size, fontDescription.isAbsoluteSize(), useSVGZoomRules(), m_state.style(), document()));
1840 }
1841 
1842 bool StyleResolver::colorFromPrimitiveValueIsDerivedFromElement(const CSSPrimitiveValue&amp; value)
1843 {
1844     switch (value.valueID()) {
1845     case CSSValueWebkitText:
1846     case CSSValueWebkitLink:
1847     case CSSValueWebkitActivelink:
1848     case CSSValueCurrentcolor:
1849         return true;
1850     default:
1851         return false;
1852     }
1853 }
1854 
1855 Color StyleResolver::colorFromPrimitiveValue(const CSSPrimitiveValue&amp; value, bool forVisitedLink) const
1856 {
1857     if (value.isRGBColor())
1858         return value.color();
1859 
1860     auto identifier = value.valueID();
1861     switch (identifier) {
1862     case CSSValueWebkitText:
1863         return document().textColor();
1864     case CSSValueWebkitLink:
1865         return (m_state.element()-&gt;isLink() &amp;&amp; forVisitedLink) ? document().visitedLinkColor() : document().linkColor();
1866     case CSSValueWebkitActivelink:
1867         return document().activeLinkColor();
1868     case CSSValueWebkitFocusRingColor:
1869         return RenderTheme::singleton().focusRingColor(document().styleColorOptions(m_state.style()));
1870     case CSSValueCurrentcolor:
1871         // Color is an inherited property so depending on it effectively makes the property inherited.
1872         // FIXME: Setting the flag as a side effect of calling this function is a bit oblique. Can we do better?
1873         m_state.style()-&gt;setHasExplicitlyInheritedProperties();
1874         return m_state.style()-&gt;color();
1875     default:
1876         return StyleColor::colorFromKeyword(identifier, document().styleColorOptions(m_state.style()));
1877     }
1878 }
1879 
1880 void StyleResolver::addViewportDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
1881 {
1882     m_viewportDependentMediaQueryResults.append(MediaQueryResult { expression, result });
1883 }
1884 
1885 bool StyleResolver::hasMediaQueriesAffectedByViewportChange() const
1886 {
1887     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByViewportChange evaluating queries&quot;);
1888     for (auto&amp; result : m_viewportDependentMediaQueryResults) {
1889         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
1890             return true;
1891     }
1892     return false;
1893 }
1894 
1895 void StyleResolver::addAccessibilitySettingsDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
1896 {
1897     m_accessibilitySettingsDependentMediaQueryResults.append(MediaQueryResult { expression, result });
1898 }
1899 
1900 bool StyleResolver::hasMediaQueriesAffectedByAccessibilitySettingsChange() const
1901 {
1902     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByAccessibilitySettingsChange evaluating queries&quot;);
1903     for (auto&amp; result : m_accessibilitySettingsDependentMediaQueryResults) {
1904         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
1905             return true;
1906     }
1907     return false;
1908 }
1909 
1910 void StyleResolver::addAppearanceDependentMediaQueryResult(const MediaQueryExpression&amp; expression, bool result)
1911 {
1912     m_appearanceDependentMediaQueryResults.append(MediaQueryResult { expression, result });
1913 }
1914 
1915 bool StyleResolver::hasMediaQueriesAffectedByAppearanceChange() const
1916 {
1917     LOG(MediaQueries, &quot;StyleResolver::hasMediaQueriesAffectedByAppearanceChange evaluating queries&quot;);
1918     for (auto&amp; result : m_appearanceDependentMediaQueryResults) {
1919         if (m_mediaQueryEvaluator.evaluate(result.expression) != result.result)
1920             return true;
1921     }
1922     return false;
1923 }
1924 
1925 static FilterOperation::OperationType filterOperationForType(CSSValueID type)
1926 {
1927     switch (type) {
1928     case CSSValueUrl:
1929         return FilterOperation::REFERENCE;
1930     case CSSValueGrayscale:
1931         return FilterOperation::GRAYSCALE;
1932     case CSSValueSepia:
1933         return FilterOperation::SEPIA;
1934     case CSSValueSaturate:
1935         return FilterOperation::SATURATE;
1936     case CSSValueHueRotate:
1937         return FilterOperation::HUE_ROTATE;
1938     case CSSValueInvert:
1939         return FilterOperation::INVERT;
1940     case CSSValueAppleInvertLightness:
1941         return FilterOperation::APPLE_INVERT_LIGHTNESS;
1942     case CSSValueOpacity:
1943         return FilterOperation::OPACITY;
1944     case CSSValueBrightness:
1945         return FilterOperation::BRIGHTNESS;
1946     case CSSValueContrast:
1947         return FilterOperation::CONTRAST;
1948     case CSSValueBlur:
1949         return FilterOperation::BLUR;
1950     case CSSValueDropShadow:
1951         return FilterOperation::DROP_SHADOW;
1952     default:
1953         break;
1954     }
1955     ASSERT_NOT_REACHED();
1956     return FilterOperation::NONE;
1957 }
1958 
1959 bool StyleResolver::createFilterOperations(const CSSValue&amp; inValue, FilterOperations&amp; outOperations)
1960 {
1961     State&amp; state = m_state;
1962     ASSERT(outOperations.isEmpty());
1963 
1964     if (is&lt;CSSPrimitiveValue&gt;(inValue)) {
1965         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(inValue);
1966         if (primitiveValue.valueID() == CSSValueNone)
1967             return true;
1968     }
1969 
1970     if (!is&lt;CSSValueList&gt;(inValue))
1971         return false;
1972 
1973     FilterOperations operations;
1974     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(inValue)) {
1975 
1976         if (is&lt;CSSPrimitiveValue&gt;(currentValue)) {
1977             auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(currentValue.get());
1978             if (!primitiveValue.isURI())
1979                 continue;
1980 
1981             String cssUrl = primitiveValue.stringValue();
1982             URL url = document().completeURL(cssUrl);
1983 
1984             auto operation = ReferenceFilterOperation::create(cssUrl, url.fragmentIdentifier());
1985             operations.operations().append(WTFMove(operation));
1986             continue;
1987         }
1988 
1989         if (!is&lt;CSSFunctionValue&gt;(currentValue))
1990             continue;
1991 
1992         auto&amp; filterValue = downcast&lt;CSSFunctionValue&gt;(currentValue.get());
1993         FilterOperation::OperationType operationType = filterOperationForType(filterValue.name());
1994 
1995         // Check that all parameters are primitive values, with the
1996         // exception of drop shadow which has a CSSShadowValue parameter.
1997         const CSSPrimitiveValue* firstValue = nullptr;
1998         if (operationType != FilterOperation::DROP_SHADOW) {
1999             bool haveNonPrimitiveValue = false;
2000             for (unsigned j = 0; j &lt; filterValue.length(); ++j) {
2001                 if (!is&lt;CSSPrimitiveValue&gt;(*filterValue.itemWithoutBoundsCheck(j))) {
2002                     haveNonPrimitiveValue = true;
2003                     break;
2004                 }
2005             }
2006             if (haveNonPrimitiveValue)
2007                 continue;
2008             if (filterValue.length())
2009                 firstValue = downcast&lt;CSSPrimitiveValue&gt;(filterValue.itemWithoutBoundsCheck(0));
2010         }
2011 
2012         switch (operationType) {
2013         case FilterOperation::GRAYSCALE:
2014         case FilterOperation::SEPIA:
2015         case FilterOperation::SATURATE: {
2016             double amount = 1;
2017             if (filterValue.length() == 1) {
2018                 amount = firstValue-&gt;doubleValue();
2019                 if (firstValue-&gt;isPercentage())
2020                     amount /= 100;
2021             }
2022 
2023             operations.operations().append(BasicColorMatrixFilterOperation::create(amount, operationType));
2024             break;
2025         }
2026         case FilterOperation::HUE_ROTATE: {
2027             double angle = 0;
2028             if (filterValue.length() == 1)
2029                 angle = firstValue-&gt;computeDegrees();
2030 
2031             operations.operations().append(BasicColorMatrixFilterOperation::create(angle, operationType));
2032             break;
2033         }
2034         case FilterOperation::INVERT:
2035         case FilterOperation::BRIGHTNESS:
2036         case FilterOperation::CONTRAST:
2037         case FilterOperation::OPACITY: {
2038             double amount = 1;
2039             if (filterValue.length() == 1) {
2040                 amount = firstValue-&gt;doubleValue();
2041                 if (firstValue-&gt;isPercentage())
2042                     amount /= 100;
2043             }
2044 
2045             operations.operations().append(BasicComponentTransferFilterOperation::create(amount, operationType));
2046             break;
2047         }
2048         case FilterOperation::APPLE_INVERT_LIGHTNESS: {
2049             operations.operations().append(InvertLightnessFilterOperation::create());
2050             break;
2051         }
2052         case FilterOperation::BLUR: {
2053             Length stdDeviation = Length(0, Fixed);
2054             if (filterValue.length() &gt;= 1)
2055                 stdDeviation = convertToFloatLength(firstValue, state.cssToLengthConversionData());
2056             if (stdDeviation.isUndefined())
2057                 return false;
2058 
2059             operations.operations().append(BlurFilterOperation::create(stdDeviation));
2060             break;
2061         }
2062         case FilterOperation::DROP_SHADOW: {
2063             if (filterValue.length() != 1)
2064                 return false;
2065 
2066             const auto* cssValue = filterValue.itemWithoutBoundsCheck(0);
2067             if (!is&lt;CSSShadowValue&gt;(cssValue))
2068                 continue;
2069 
2070             const auto&amp; item = downcast&lt;CSSShadowValue&gt;(*cssValue);
2071             int x = item.x-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData());
2072             int y = item.y-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData());
2073             IntPoint location(x, y);
2074             int blur = item.blur ? item.blur-&gt;computeLength&lt;int&gt;(state.cssToLengthConversionData()) : 0;
2075             Color color;
2076             if (item.color)
2077                 color = colorFromPrimitiveValue(*item.color);
2078 
2079             operations.operations().append(DropShadowFilterOperation::create(location, blur, color.isValid() ? color : Color::transparent));
2080             break;
2081         }
2082         default:
2083             ASSERT_NOT_REACHED();
2084             break;
2085         }
2086     }
2087 
2088     outOperations = operations;
2089     return true;
2090 }
2091 
2092 inline StyleResolver::MatchedProperties::MatchedProperties() = default;
2093 
2094 StyleResolver::MatchedProperties::~MatchedProperties() = default;
2095 
2096 StyleResolver::CascadedProperties::CascadedProperties(TextDirection direction, WritingMode writingMode)
2097     : m_direction(direction)
2098     , m_writingMode(writingMode)
2099 {
2100 }
2101 
2102 inline bool StyleResolver::CascadedProperties::hasProperty(CSSPropertyID id) const
2103 {
2104     ASSERT(id &lt; m_propertyIsPresent.size());
2105     return m_propertyIsPresent[id];
2106 }
2107 
2108 inline StyleResolver::CascadedProperties::Property&amp; StyleResolver::CascadedProperties::property(CSSPropertyID id)
2109 {
2110     return m_properties[id];
2111 }
2112 
2113 inline bool StyleResolver::CascadedProperties::hasCustomProperty(const String&amp; name) const
2114 {
2115     return m_customProperties.contains(name);
2116 }
2117 
2118 inline StyleResolver::CascadedProperties::Property StyleResolver::CascadedProperties::customProperty(const String&amp; name) const
2119 {
2120     return m_customProperties.get(name);
2121 }
2122 
2123 void StyleResolver::CascadedProperties::setPropertyInternal(Property&amp; property, CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2124 {
2125     ASSERT(linkMatchType &lt;= SelectorChecker::MatchAll);
2126     property.id = id;
2127     property.level = cascadeLevel;
2128     property.styleScopeOrdinal = styleScopeOrdinal;
2129     if (linkMatchType == SelectorChecker::MatchAll) {
2130         property.cssValue[0] = &amp;cssValue;
2131         property.cssValue[SelectorChecker::MatchLink] = &amp;cssValue;
2132         property.cssValue[SelectorChecker::MatchVisited] = &amp;cssValue;
2133     } else
2134         property.cssValue[linkMatchType] = &amp;cssValue;
2135 }
2136 
2137 void StyleResolver::CascadedProperties::set(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2138 {
2139     if (CSSProperty::isDirectionAwareProperty(id))
2140         id = CSSProperty::resolveDirectionAwareProperty(id, m_direction, m_writingMode);
2141 
2142     ASSERT(!shouldApplyPropertyInParseOrder(id));
2143 
2144     auto&amp; property = m_properties[id];
2145     ASSERT(id &lt; m_propertyIsPresent.size());
2146     if (id == CSSPropertyCustom) {
2147         m_propertyIsPresent.set(id);
2148         const auto&amp; customValue = downcast&lt;CSSCustomPropertyValue&gt;(cssValue);
2149         bool hasValue = customProperties().contains(customValue.name());
2150         if (!hasValue) {
2151             Property property;
2152             property.id = id;
2153             memset(property.cssValue, 0, sizeof(property.cssValue));
2154             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2155             customProperties().set(customValue.name(), property);
2156         } else {
2157             Property property = customProperties().get(customValue.name());
2158             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2159             customProperties().set(customValue.name(), property);
2160         }
2161         return;
2162     }
2163 
2164     if (!m_propertyIsPresent[id])
2165         memset(property.cssValue, 0, sizeof(property.cssValue));
2166     m_propertyIsPresent.set(id);
2167     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2168 }
2169 
2170 void StyleResolver::CascadedProperties::setDeferred(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, Style::ScopeOrdinal styleScopeOrdinal)
2171 {
2172     ASSERT(!CSSProperty::isDirectionAwareProperty(id));
2173     ASSERT(shouldApplyPropertyInParseOrder(id));
2174 
2175     Property property;
2176     memset(property.cssValue, 0, sizeof(property.cssValue));
2177     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
2178     m_deferredProperties.append(property);
2179 }
2180 
2181 static CascadeLevel cascadeLevelForIndex(const StyleResolver::MatchResult&amp; matchResult, int index)
2182 {
2183     if (index &gt;= matchResult.ranges.firstUARule &amp;&amp; index &lt;= matchResult.ranges.lastUARule)
2184         return CascadeLevel::UserAgentLevel;
2185     if (index &gt;= matchResult.ranges.firstUserRule &amp;&amp; index &lt;= matchResult.ranges.lastUserRule)
2186         return CascadeLevel::UserLevel;
2187     return CascadeLevel::AuthorLevel;
2188 }
2189 
2190 void StyleResolver::CascadedProperties::addMatch(const MatchResult&amp; matchResult, unsigned index, bool isImportant, bool inheritedOnly)
2191 {
2192     auto&amp; matchedProperties = matchResult.matchedProperties()[index];
2193     auto&amp; styleProperties = *matchedProperties.properties;
2194 
2195     auto propertyWhitelistType = static_cast&lt;PropertyWhitelistType&gt;(matchedProperties.whitelistType);
2196     auto cascadeLevel = cascadeLevelForIndex(matchResult, index);
2197 
2198     for (unsigned i = 0, count = styleProperties.propertyCount(); i &lt; count; ++i) {
2199         auto current = styleProperties.propertyAt(i);
2200         if (isImportant != current.isImportant())
2201             continue;
2202         if (inheritedOnly &amp;&amp; !current.isInherited()) {
2203             // We apply the inherited properties only when using the property cache.
2204             // A match with a value that is explicitely inherited should never have been cached.
2205             ASSERT(!current.value()-&gt;isInheritedValue());
2206             continue;
2207         }
2208         CSSPropertyID propertyID = current.id();
2209 
2210 #if ENABLE(VIDEO_TRACK)
2211         if (propertyWhitelistType == PropertyWhitelistCue &amp;&amp; !isValidCueStyleProperty(propertyID))
2212             continue;
2213 #endif
2214         if (propertyWhitelistType == PropertyWhitelistMarker &amp;&amp; !isValidMarkerStyleProperty(propertyID))
2215             continue;
2216 
2217         if (shouldApplyPropertyInParseOrder(propertyID))
2218             setDeferred(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
2219         else
2220             set(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
2221     }
2222 }
2223 
2224 void StyleResolver::CascadedProperties::addNormalMatches(const MatchResult&amp; matchResult, int startIndex, int endIndex, bool inheritedOnly)
2225 {
2226     if (startIndex == -1)
2227         return;
2228 
2229     for (int i = startIndex; i &lt;= endIndex; ++i)
2230         addMatch(matchResult, i, false, inheritedOnly);
2231 }
2232 
2233 static bool hasImportantProperties(const StyleProperties&amp; properties)
2234 {
2235     for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
2236         if (properties.propertyAt(i).isImportant())
2237             return true;
2238     }
2239     return false;
2240 }
2241 
2242 void StyleResolver::CascadedProperties::addImportantMatches(const MatchResult&amp; matchResult, int startIndex, int endIndex, bool inheritedOnly)
2243 {
2244     if (startIndex == -1)
2245         return;
2246 
2247     struct IndexAndOrdinal {
2248         int index;
2249         Style::ScopeOrdinal ordinal;
2250     };
2251     Vector&lt;IndexAndOrdinal&gt; shadowTreeMatches;
2252 
2253     for (int i = startIndex; i &lt;= endIndex; ++i) {
2254         const MatchedProperties&amp; matchedProperties = matchResult.matchedProperties()[i];
2255 
2256         if (!hasImportantProperties(*matchedProperties.properties))
2257             continue;
2258 
2259         if (matchedProperties.styleScopeOrdinal != Style::ScopeOrdinal::Element) {
2260             shadowTreeMatches.append({ i, matchedProperties.styleScopeOrdinal });
2261             continue;
2262         }
2263 
2264         addMatch(matchResult, i, true, inheritedOnly);
2265     }
2266 
2267     if (shadowTreeMatches.isEmpty())
2268         return;
2269 
2270     // For !important properties a later shadow tree wins.
2271     // Match results are sorted in reverse tree context order so this is not needed for normal properties.
2272     std::stable_sort(shadowTreeMatches.begin(), shadowTreeMatches.end(), [] (const IndexAndOrdinal&amp; a, const IndexAndOrdinal&amp; b) {
2273         return a.ordinal &lt; b.ordinal;
2274     });
2275 
2276     for (auto&amp; match : shadowTreeMatches)
2277         addMatch(matchResult, match.index, true, inheritedOnly);
2278 }
2279 
2280 void StyleResolver::CascadedProperties::applyDeferredProperties(StyleResolver&amp; resolver, ApplyCascadedPropertyState&amp; applyState)
2281 {
2282     for (auto&amp; property : m_deferredProperties)
2283         property.apply(resolver, applyState);
2284 }
2285 
2286 void StyleResolver::CascadedProperties::Property::apply(StyleResolver&amp; resolver, ApplyCascadedPropertyState&amp; applyState)
2287 {
2288     State&amp; state = resolver.state();
2289     state.setCascadeLevel(level);
2290     state.setStyleScopeOrdinal(styleScopeOrdinal);
2291 
2292     if (cssValue[SelectorChecker::MatchDefault]) {
2293         state.setApplyPropertyToRegularStyle(true);
2294         state.setApplyPropertyToVisitedLinkStyle(false);
2295         resolver.applyProperty(id, cssValue[SelectorChecker::MatchDefault], applyState, SelectorChecker::MatchDefault);
2296     }
2297 
2298     if (state.style()-&gt;insideLink() == InsideLink::NotInside)
2299         return;
2300 
2301     if (cssValue[SelectorChecker::MatchLink]) {
2302         state.setApplyPropertyToRegularStyle(true);
2303         state.setApplyPropertyToVisitedLinkStyle(false);
2304         resolver.applyProperty(id, cssValue[SelectorChecker::MatchLink], applyState, SelectorChecker::MatchLink);
2305     }
2306 
2307     if (cssValue[SelectorChecker::MatchVisited]) {
2308         state.setApplyPropertyToRegularStyle(false);
2309         state.setApplyPropertyToVisitedLinkStyle(true);
2310         resolver.applyProperty(id, cssValue[SelectorChecker::MatchVisited], applyState, SelectorChecker::MatchVisited);
2311     }
2312 
2313     state.setApplyPropertyToRegularStyle(true);
2314     state.setApplyPropertyToVisitedLinkStyle(false);
2315 }
2316 
2317 void StyleResolver::applyCascadedCustomProperty(const String&amp; name, ApplyCascadedPropertyState&amp; state)
2318 {
2319     if (state.appliedCustomProperties.contains(name) || !state.cascade-&gt;customProperties().contains(name))
2320         return;
2321 
2322     auto property = state.cascade-&gt;customProperties().get(name);
2323     bool inCycle = state.inProgressPropertiesCustom.contains(name);
2324 
2325     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
2326         if (!property.cssValue[index])
2327             continue;
2328         if (index != SelectorChecker::MatchDefault &amp;&amp; this-&gt;state().style()-&gt;insideLink() == InsideLink::NotInside)
2329             continue;
2330 
2331         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
2332 
2333         if (inCycle) {
2334             state.appliedCustomProperties.add(name); // Make sure we do not try to apply this property again while resolving it.
2335             valueToApply = CSSCustomPropertyValue::createWithID(name, CSSValueInvalid);
2336         }
2337 
2338         state.inProgressPropertiesCustom.add(name);
2339 
2340         if (WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
2341             RefPtr&lt;CSSValue&gt; parsedValue = resolvedVariableValue(CSSPropertyCustom, valueToApply.get(), state);
2342 
2343             if (state.appliedCustomProperties.contains(name))
2344                 return; // There was a cycle and the value was reset, so bail.
2345 
2346             if (!parsedValue)
2347                 parsedValue = CSSCustomPropertyValue::createWithID(name, CSSValueUnset);
2348 
2349             valueToApply = downcast&lt;CSSCustomPropertyValue&gt;(*parsedValue);
2350         }
2351 
2352         if (state.inProgressPropertiesCustom.contains(name)) {
2353             if (index == SelectorChecker::MatchDefault) {
2354                 this-&gt;state().setApplyPropertyToRegularStyle(true);
2355                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(false);
2356             }
2357 
2358             if (index == SelectorChecker::MatchLink) {
2359                 this-&gt;state().setApplyPropertyToRegularStyle(true);
2360                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(false);
2361             }
2362 
2363             if (index == SelectorChecker::MatchVisited) {
2364                 this-&gt;state().setApplyPropertyToRegularStyle(false);
2365                 this-&gt;state().setApplyPropertyToVisitedLinkStyle(true);
2366             }
2367             applyProperty(CSSPropertyCustom, valueToApply.ptr(), state, index);
2368         }
2369     }
2370 
2371     state.inProgressPropertiesCustom.remove(name);
2372     state.appliedCustomProperties.add(name);
2373 
2374     for (auto index : { SelectorChecker::MatchDefault, SelectorChecker::MatchLink, SelectorChecker::MatchVisited }) {
2375         if (!property.cssValue[index])
2376             continue;
2377         if (index != SelectorChecker::MatchDefault &amp;&amp; this-&gt;state().style()-&gt;insideLink() == InsideLink::NotInside)
2378             continue;
2379 
2380         Ref&lt;CSSCustomPropertyValue&gt; valueToApply = CSSCustomPropertyValue::create(downcast&lt;CSSCustomPropertyValue&gt;(*property.cssValue[index]));
2381 
2382         if (inCycle &amp;&amp; WTF::holds_alternative&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(valueToApply-&gt;value())) {
2383             // Resolve this value so that we reset its dependencies.
2384             resolvedVariableValue(CSSPropertyCustom, valueToApply.get(), state);
2385         }
2386     }
2387 }
2388 
2389 void StyleResolver::applyCascadedProperties(int firstProperty, int lastProperty, ApplyCascadedPropertyState&amp; state)
2390 {
2391     if (LIKELY(state.cascade-&gt;customProperties().isEmpty()))
2392         return applyCascadedPropertiesImpl&lt;CustomPropertyCycleTracking::Disabled&gt;(firstProperty, lastProperty, state);
2393     return applyCascadedPropertiesImpl&lt;CustomPropertyCycleTracking::Enabled&gt;(firstProperty, lastProperty, state);
2394 }
2395 
2396 template&lt;StyleResolver::CustomPropertyCycleTracking TrackCycles&gt;
2397 inline void StyleResolver::applyCascadedPropertiesImpl(int firstProperty, int lastProperty, ApplyCascadedPropertyState&amp; state)
2398 {
2399     for (int id = firstProperty; id &lt;= lastProperty; ++id) {
2400         CSSPropertyID propertyID = static_cast&lt;CSSPropertyID&gt;(id);
2401         if (!state.cascade-&gt;hasProperty(propertyID))
2402             continue;
2403         ASSERT(propertyID != CSSPropertyCustom);
2404         auto&amp; property = state.cascade-&gt;property(propertyID);
2405         ASSERT(!shouldApplyPropertyInParseOrder(propertyID));
2406 
2407         if (TrackCycles == CustomPropertyCycleTracking::Disabled) {
2408             // If we don&#39;t have any custom properties, then there can&#39;t be any cycles.
2409             property.apply(*this, state);
2410         } else {
2411             if (UNLIKELY(state.inProgressProperties.get(propertyID))) {
2412                 // We are in a cycle (eg. setting font size using registered custom property value containing em).
2413                 // So this value should be unset.
2414                 state.appliedProperties.set(propertyID);
2415                 // This property is in a cycle, and only the root of the call stack will have firstProperty != lastProperty.
2416                 ASSERT(firstProperty == lastProperty);
2417                 continue;
2418             }
2419 
2420             state.inProgressProperties.set(propertyID);
2421             property.apply(*this, state);
2422             state.appliedProperties.set(propertyID);
2423             state.inProgressProperties.set(propertyID, false);
2424         }
2425     }
2426 }
2427 
2428 } // namespace WebCore
    </pre>
  </body>
</html>