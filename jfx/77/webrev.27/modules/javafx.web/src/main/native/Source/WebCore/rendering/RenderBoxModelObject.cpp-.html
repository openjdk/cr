<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
   5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
   6  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc. All rights reserved.
   7  * Copyright (C) 2010 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;RenderBoxModelObject.h&quot;
  28 
  29 #include &quot;BitmapImage.h&quot;
  30 #include &quot;BorderEdge.h&quot;
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;DocumentTimeline.h&quot;
  34 #include &quot;FloatRoundedRect.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;GeometryUtilities.h&quot;
  38 #include &quot;GraphicsContext.h&quot;
  39 #include &quot;HTMLFrameOwnerElement.h&quot;
  40 #include &quot;HTMLFrameSetElement.h&quot;
  41 #include &quot;HTMLImageElement.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;ImageBuffer.h&quot;
  44 #include &quot;ImageQualityController.h&quot;
  45 #include &quot;Path.h&quot;
  46 #include &quot;RenderBlock.h&quot;
  47 #include &quot;RenderFlexibleBox.h&quot;
  48 #include &quot;RenderFragmentContainer.h&quot;
  49 #include &quot;RenderInline.h&quot;
  50 #include &quot;RenderLayer.h&quot;
  51 #include &quot;RenderLayerBacking.h&quot;
  52 #include &quot;RenderLayerCompositor.h&quot;
  53 #include &quot;RenderMultiColumnFlow.h&quot;
  54 #include &quot;RenderTable.h&quot;
  55 #include &quot;RenderTableRow.h&quot;
  56 #include &quot;RenderText.h&quot;
  57 #include &quot;RenderTextFragment.h&quot;
  58 #include &quot;RenderTreeBuilder.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;ScrollingConstraints.h&quot;
  61 #include &quot;Settings.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/NeverDestroyed.h&gt;
  65 #if !ASSERT_DISABLED
  66 #include &lt;wtf/SetForScope.h&gt;
  67 #endif
  68 
  69 #if PLATFORM(IOS_FAMILY)
  70 #include &quot;RuntimeApplicationChecks.h&quot;
  71 #endif
  72 
  73 namespace WebCore {
  74 
  75 using namespace HTMLNames;
  76 
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBoxModelObject);
  78 
  79 // The HashMap for storing continuation pointers.
  80 // An inline can be split with blocks occuring in between the inline content.
  81 // When this occurs we need a pointer to the next object. We can basically be
  82 // split into a sequence of inlines and blocks. The continuation will either be
  83 // an anonymous block (that houses other blocks) or it will be an inline flow.
  84 // &lt;b&gt;&lt;i&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/i&gt;&lt;/b&gt;. In this example the &lt;i&gt; will have a block as
  85 // its continuation but the &lt;b&gt; will just have an inline as its continuation.
  86 RenderBoxModelObject::ContinuationChainNode::ContinuationChainNode(RenderBoxModelObject&amp; renderer)
  87     : renderer(makeWeakPtr(renderer))
  88 {
  89 }
  90 
  91 RenderBoxModelObject::ContinuationChainNode::~ContinuationChainNode()
  92 {
  93     if (next) {
  94         ASSERT(previous);
  95         ASSERT(next-&gt;previous == this);
  96         next-&gt;previous = previous;
  97     }
  98     if (previous) {
  99         ASSERT(previous-&gt;next == this);
 100         previous-&gt;next = next;
 101     }
 102 }
 103 
 104 void RenderBoxModelObject::ContinuationChainNode::insertAfter(ContinuationChainNode&amp; after)
 105 {
 106     ASSERT(!previous);
 107     ASSERT(!next);
 108     if ((next = after.next)) {
 109         ASSERT(next-&gt;previous == &amp;after);
 110         next-&gt;previous = this;
 111     }
 112     previous = &amp;after;
 113     after.next = this;
 114 }
 115 
 116 using ContinuationChainNodeMap = HashMap&lt;const RenderBoxModelObject*, std::unique_ptr&lt;RenderBoxModelObject::ContinuationChainNode&gt;&gt;;
 117 
 118 static ContinuationChainNodeMap&amp; continuationChainNodeMap()
 119 {
 120     static NeverDestroyed&lt;ContinuationChainNodeMap&gt; map;
 121     return map;
 122 }
 123 
 124 using FirstLetterRemainingTextMap = HashMap&lt;const RenderBoxModelObject*, WeakPtr&lt;RenderTextFragment&gt;&gt;;
 125 
 126 static FirstLetterRemainingTextMap&amp; firstLetterRemainingTextMap()
 127 {
 128     static NeverDestroyed&lt;FirstLetterRemainingTextMap&gt; map;
 129     return map;
 130 }
 131 
 132 void RenderBoxModelObject::setSelectionState(SelectionState state)
 133 {
 134     if (state == SelectionInside &amp;&amp; selectionState() != SelectionNone)
 135         return;
 136 
 137     if ((state == SelectionStart &amp;&amp; selectionState() == SelectionEnd)
 138         || (state == SelectionEnd &amp;&amp; selectionState() == SelectionStart))
 139         RenderLayerModelObject::setSelectionState(SelectionBoth);
 140     else
 141         RenderLayerModelObject::setSelectionState(state);
 142 
 143     // FIXME: We should consider whether it is OK propagating to ancestor RenderInlines.
 144     // This is a workaround for http://webkit.org/b/32123
 145     // The containing block can be null in case of an orphaned tree.
 146     RenderBlock* containingBlock = this-&gt;containingBlock();
 147     if (containingBlock &amp;&amp; !containingBlock-&gt;isRenderView())
 148         containingBlock-&gt;setSelectionState(state);
 149 }
 150 
 151 void RenderBoxModelObject::contentChanged(ContentChangeType changeType)
 152 {
 153     if (!hasLayer())
 154         return;
 155 
 156     layer()-&gt;contentChanged(changeType);
 157 }
 158 
 159 bool RenderBoxModelObject::hasAcceleratedCompositing() const
 160 {
 161     return view().compositor().hasAcceleratedCompositing();
 162 }
 163 
 164 bool RenderBoxModelObject::startTransition(double timeOffset, CSSPropertyID propertyId, const RenderStyle* fromStyle, const RenderStyle* toStyle)
 165 {
 166     ASSERT(hasLayer());
 167     ASSERT(isComposited());
 168     return layer()-&gt;backing()-&gt;startTransition(timeOffset, propertyId, fromStyle, toStyle);
 169 }
 170 
 171 void RenderBoxModelObject::transitionPaused(double timeOffset, CSSPropertyID propertyId)
 172 {
 173     ASSERT(hasLayer());
 174     ASSERT(isComposited());
 175     layer()-&gt;backing()-&gt;transitionPaused(timeOffset, propertyId);
 176 }
 177 
 178 void RenderBoxModelObject::transitionFinished(CSSPropertyID propertyId)
 179 {
 180     ASSERT(hasLayer());
 181     ASSERT(isComposited());
 182     layer()-&gt;backing()-&gt;transitionFinished(propertyId);
 183 }
 184 
 185 bool RenderBoxModelObject::startAnimation(double timeOffset, const Animation* animation, const KeyframeList&amp; keyframes)
 186 {
 187     ASSERT(hasLayer());
 188     ASSERT(isComposited());
 189     return layer()-&gt;backing()-&gt;startAnimation(timeOffset, animation, keyframes);
 190 }
 191 
 192 void RenderBoxModelObject::animationPaused(double timeOffset, const String&amp; name)
 193 {
 194     ASSERT(hasLayer());
 195     ASSERT(isComposited());
 196     layer()-&gt;backing()-&gt;animationPaused(timeOffset, name);
 197 }
 198 
 199 void RenderBoxModelObject::animationSeeked(double timeOffset, const String&amp; name)
 200 {
 201     ASSERT(hasLayer());
 202     ASSERT(isComposited());
 203     layer()-&gt;backing()-&gt;animationSeeked(timeOffset, name);
 204 }
 205 
 206 void RenderBoxModelObject::animationFinished(const String&amp; name)
 207 {
 208     ASSERT(hasLayer());
 209     ASSERT(isComposited());
 210     layer()-&gt;backing()-&gt;animationFinished(name);
 211 }
 212 
 213 void RenderBoxModelObject::suspendAnimations(MonotonicTime time)
 214 {
 215     ASSERT(hasLayer());
 216     ASSERT(isComposited());
 217     layer()-&gt;backing()-&gt;suspendAnimations(time);
 218 }
 219 
 220 RenderBoxModelObject::RenderBoxModelObject(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 221     : RenderLayerModelObject(element, WTFMove(style), baseTypeFlags | RenderBoxModelObjectFlag)
 222 {
 223 }
 224 
 225 RenderBoxModelObject::RenderBoxModelObject(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 226     : RenderLayerModelObject(document, WTFMove(style), baseTypeFlags | RenderBoxModelObjectFlag)
 227 {
 228 }
 229 
 230 RenderBoxModelObject::~RenderBoxModelObject()
 231 {
 232     // Do not add any code here. Add it to willBeDestroyed() instead.
 233     ASSERT(!continuation());
 234 }
 235 
 236 void RenderBoxModelObject::willBeDestroyed()
 237 {
 238     if (hasContinuationChainNode())
 239         removeFromContinuationChain();
 240 
 241     if (isFirstLetter())
 242         clearFirstLetterRemainingText();
 243 
 244     if (!renderTreeBeingDestroyed())
 245         view().imageQualityController().rendererWillBeDestroyed(*this);
 246 
 247     RenderLayerModelObject::willBeDestroyed();
 248 }
 249 
 250 bool RenderBoxModelObject::hasVisibleBoxDecorationStyle() const
 251 {
 252     return hasBackground() || style().hasVisibleBorderDecoration() || style().hasAppearance() || style().boxShadow();
 253 }
 254 
 255 void RenderBoxModelObject::updateFromStyle()
 256 {
 257     RenderLayerModelObject::updateFromStyle();
 258 
 259     // Set the appropriate bits for a box model object.  Since all bits are cleared in styleWillChange,
 260     // we only check for bits that could possibly be set to true.
 261     const RenderStyle&amp; styleToUse = style();
 262     setHasVisibleBoxDecorations(hasVisibleBoxDecorationStyle());
 263     setInline(styleToUse.isDisplayInlineType());
 264     setPositionState(styleToUse.position());
 265     setHorizontalWritingMode(styleToUse.isHorizontalWritingMode());
 266     if (styleToUse.isFlippedBlocksWritingMode())
 267         view().frameView().setHasFlippedBlockRenderers(true);
 268 }
 269 
 270 static LayoutSize accumulateInFlowPositionOffsets(const RenderObject* child)
 271 {
 272     if (!child-&gt;isAnonymousBlock() || !child-&gt;isInFlowPositioned())
 273         return LayoutSize();
 274     LayoutSize offset;
 275     for (RenderElement* parent = downcast&lt;RenderBlock&gt;(*child).inlineContinuation(); is&lt;RenderInline&gt;(parent); parent = parent-&gt;parent()) {
 276         if (parent-&gt;isInFlowPositioned())
 277             offset += downcast&lt;RenderInline&gt;(*parent).offsetForInFlowPosition();
 278     }
 279     return offset;
 280 }
 281 
 282 static inline bool isOutOfFlowPositionedWithImplicitHeight(const RenderBoxModelObject&amp; child)
 283 {
 284     return child.isOutOfFlowPositioned() &amp;&amp; !child.style().logicalTop().isAuto() &amp;&amp; !child.style().logicalBottom().isAuto();
 285 }
 286 
 287 RenderBlock* RenderBoxModelObject::containingBlockForAutoHeightDetection(Length logicalHeight) const
 288 {
 289     // For percentage heights: The percentage is calculated with respect to the
 290     // height of the generated box&#39;s containing block. If the height of the
 291     // containing block is not specified explicitly (i.e., it depends on content
 292     // height), and this element is not absolutely positioned, the used height is
 293     // calculated as if &#39;auto&#39; was specified.
 294     if (!logicalHeight.isPercentOrCalculated() || isOutOfFlowPositioned())
 295         return nullptr;
 296 
 297     // Anonymous block boxes are ignored when resolving percentage values that
 298     // would refer to it: the closest non-anonymous ancestor box is used instead.
 299     auto* cb = containingBlock();
 300     while (cb &amp;&amp; cb-&gt;isAnonymous() &amp;&amp; !is&lt;RenderView&gt;(cb))
 301         cb = cb-&gt;containingBlock();
 302     if (!cb)
 303         return nullptr;
 304 
 305     // Matching RenderBox::percentageLogicalHeightIsResolvable() by
 306     // ignoring table cell&#39;s attribute value, where it says that table cells
 307     // violate what the CSS spec says to do with heights. Basically we don&#39;t care
 308     // if the cell specified a height or not.
 309     if (cb-&gt;isTableCell())
 310         return nullptr;
 311 
 312     // Match RenderBox::availableLogicalHeightUsing by special casing the layout
 313     // view. The available height is taken from the frame.
 314     if (cb-&gt;isRenderView())
 315         return nullptr;
 316 
 317     if (isOutOfFlowPositionedWithImplicitHeight(*cb))
 318         return nullptr;
 319 
 320     return cb;
 321 }
 322 
 323 bool RenderBoxModelObject::hasAutoHeightOrContainingBlockWithAutoHeight() const
 324 {
 325     const auto* thisBox = isBox() ? downcast&lt;RenderBox&gt;(this) : nullptr;
 326     Length logicalHeightLength = style().logicalHeight();
 327     auto* cb = containingBlockForAutoHeightDetection(logicalHeightLength);
 328 
 329     if (logicalHeightLength.isPercentOrCalculated() &amp;&amp; cb &amp;&amp; isBox())
 330         cb-&gt;addPercentHeightDescendant(*const_cast&lt;RenderBox*&gt;(downcast&lt;RenderBox&gt;(this)));
 331 
 332     if (thisBox &amp;&amp; thisBox-&gt;isFlexItem()) {
 333         auto&amp; flexBox = downcast&lt;RenderFlexibleBox&gt;(*parent());
 334         if (flexBox.childLogicalHeightForPercentageResolution(*thisBox))
 335             return false;
 336     }
 337 
 338     if (thisBox &amp;&amp; thisBox-&gt;isGridItem() &amp;&amp; thisBox-&gt;hasOverrideContainingBlockContentLogicalHeight())
 339         return false;
 340 
 341     if (logicalHeightLength.isAuto() &amp;&amp; !isOutOfFlowPositionedWithImplicitHeight(*this))
 342         return true;
 343 
 344     if (document().inQuirksMode())
 345         return false;
 346 
 347     if (cb)
 348         return !cb-&gt;hasDefiniteLogicalHeight();
 349 
 350     return false;
 351 }
 352 
 353 DecodingMode RenderBoxModelObject::decodingModeForImageDraw(const Image&amp; image, const PaintInfo&amp; paintInfo) const
 354 {
 355     if (!is&lt;BitmapImage&gt;(image))
 356         return DecodingMode::Synchronous;
 357 
 358     const BitmapImage&amp; bitmapImage = downcast&lt;BitmapImage&gt;(image);
 359     if (bitmapImage.canAnimate()) {
 360         // The DecodingMode for the current frame has to be Synchronous. The DecodingMode
 361         // for the next frame will be calculated in BitmapImage::internalStartAnimation().
 362         return DecodingMode::Synchronous;
 363     }
 364 
 365     // Large image case.
 366 #if PLATFORM(IOS_FAMILY)
 367     if (IOSApplication::isIBooksStorytime())
 368         return DecodingMode::Synchronous;
 369 #endif
 370     if (is&lt;HTMLImageElement&gt;(element())) {
 371         auto decodingMode = downcast&lt;HTMLImageElement&gt;(*element()).decodingMode();
 372         if (decodingMode != DecodingMode::Auto)
 373             return decodingMode;
 374     }
 375     if (bitmapImage.isLargeImageAsyncDecodingEnabledForTesting())
 376         return DecodingMode::Asynchronous;
 377     if (document().isImageDocument())
 378         return DecodingMode::Synchronous;
 379     if (paintInfo.paintBehavior.contains(PaintBehavior::Snapshotting))
 380         return DecodingMode::Synchronous;
 381     if (!settings().largeImageAsyncDecodingEnabled())
 382         return DecodingMode::Synchronous;
 383     if (!bitmapImage.canUseAsyncDecodingForLargeImages())
 384         return DecodingMode::Synchronous;
 385     if (paintInfo.paintBehavior.contains(PaintBehavior::TileFirstPaint))
 386         return DecodingMode::Asynchronous;
 387     // FIXME: isVisibleInViewport() is not cheap. Find a way to make this condition faster.
 388     if (!isVisibleInViewport())
 389         return DecodingMode::Asynchronous;
 390     return DecodingMode::Synchronous;
 391 }
 392 
 393 LayoutSize RenderBoxModelObject::relativePositionOffset() const
 394 {
 395     // This function has been optimized to avoid calls to containingBlock() in the common case
 396     // where all values are either auto or fixed.
 397 
 398     LayoutSize offset = accumulateInFlowPositionOffsets(this);
 399 
 400     // Objects that shrink to avoid floats normally use available line width when computing containing block width.  However
 401     // in the case of relative positioning using percentages, we can&#39;t do this.  The offset should always be resolved using the
 402     // available width of the containing block.  Therefore we don&#39;t use containingBlockLogicalWidthForContent() here, but instead explicitly
 403     // call availableWidth on our containing block.
 404     // However for grid items the containing block is the grid area, so offsets should be resolved against that:
 405     // https://drafts.csswg.org/css-grid/#grid-item-sizing
 406     if (!style().left().isAuto() || !style().right().isAuto()) {
 407         LayoutUnit availableWidth = hasOverrideContainingBlockContentWidth()
 408             ? overrideContainingBlockContentWidth().valueOr(LayoutUnit()) : containingBlock()-&gt;availableWidth();
 409         if (!style().left().isAuto()) {
 410             if (!style().right().isAuto() &amp;&amp; !containingBlock()-&gt;style().isLeftToRightDirection())
 411                 offset.setWidth(-valueForLength(style().right(), !style().right().isFixed() ? availableWidth : 0_lu));
 412             else
 413                 offset.expand(valueForLength(style().left(), !style().left().isFixed() ? availableWidth : 0_lu), 0_lu);
 414         } else if (!style().right().isAuto())
 415             offset.expand(-valueForLength(style().right(), !style().right().isFixed() ? availableWidth : 0_lu), 0_lu);
 416     }
 417 
 418     // If the containing block of a relatively positioned element does not
 419     // specify a height, a percentage top or bottom offset should be resolved as
 420     // auto. An exception to this is if the containing block has the WinIE quirk
 421     // where &lt;html&gt; and &lt;body&gt; assume the size of the viewport. In this case,
 422     // calculate the percent offset based on this height.
 423     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=26396&gt;.
 424     // Another exception is a grid item, as the containing block is the grid area:
 425     // https://drafts.csswg.org/css-grid/#grid-item-sizing
 426     if (!style().top().isAuto()
 427         &amp;&amp; (!style().top().isPercentOrCalculated()
 428             || !containingBlock()-&gt;hasAutoHeightOrContainingBlockWithAutoHeight()
 429             || containingBlock()-&gt;stretchesToViewport()
 430             || hasOverrideContainingBlockContentHeight())) {
 431         // FIXME: The computation of the available height is repeated later for &quot;bottom&quot;.
 432         // We could refactor this and move it to some common code for both ifs, however moving it outside of the ifs
 433         // is not possible as it&#39;d cause performance regressions.
 434         offset.expand(0_lu, valueForLength(style().top(), !style().top().isFixed()
 435             ? (hasOverrideContainingBlockContentHeight() ? overrideContainingBlockContentHeight().valueOr(0_lu) : containingBlock()-&gt;availableHeight())
 436             : LayoutUnit()));
 437     } else if (!style().bottom().isAuto()
 438         &amp;&amp; (!style().bottom().isPercentOrCalculated()
 439             || !containingBlock()-&gt;hasAutoHeightOrContainingBlockWithAutoHeight()
 440             || containingBlock()-&gt;stretchesToViewport()
 441             || hasOverrideContainingBlockContentHeight())) {
 442         // FIXME: Check comment above for &quot;top&quot;, it applies here too.
 443         offset.expand(0_lu, -valueForLength(style().bottom(), !style().bottom().isFixed()
 444             ? (hasOverrideContainingBlockContentHeight() ? overrideContainingBlockContentHeight().valueOr(0_lu) : containingBlock()-&gt;availableHeight())
 445             : LayoutUnit()));
 446     }
 447 
 448     return offset;
 449 }
 450 
 451 LayoutPoint RenderBoxModelObject::adjustedPositionRelativeToOffsetParent(const LayoutPoint&amp; startPoint) const
 452 {
 453     // If the element is the HTML body element or doesn&#39;t have a parent
 454     // return 0 and stop this algorithm.
 455     if (isBody() || !parent())
 456         return LayoutPoint();
 457 
 458     LayoutPoint referencePoint = startPoint;
 459 
 460     // If the offsetParent of the element is null, or is the HTML body element,
 461     // return the distance between the canvas origin and the left border edge
 462     // of the element and stop this algorithm.
 463     if (const RenderBoxModelObject* offsetParent = this-&gt;offsetParent()) {
 464         if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; !offsetParent-&gt;isBody() &amp;&amp; !is&lt;RenderTable&gt;(*offsetParent))
 465             referencePoint.move(-downcast&lt;RenderBox&gt;(*offsetParent).borderLeft(), -downcast&lt;RenderBox&gt;(*offsetParent).borderTop());
 466         if (!isOutOfFlowPositioned() || enclosingFragmentedFlow()) {
 467             if (isRelativelyPositioned())
 468                 referencePoint.move(relativePositionOffset());
 469             else if (isStickilyPositioned())
 470                 referencePoint.move(stickyPositionOffset());
 471 
 472             // CSS regions specification says that region flows should return the body element as their offsetParent.
 473             // Since we will bypass the bodyâ€™s renderer anyway, just end the loop if we encounter a region flow (named flow thread).
 474             // See http://dev.w3.org/csswg/css-regions/#cssomview-offset-attributes
 475             auto* ancestor = parent();
 476             while (ancestor != offsetParent) {
 477                 // FIXME: What are we supposed to do inside SVG content?
 478 
 479                 if (is&lt;RenderMultiColumnFlow&gt;(*ancestor)) {
 480                     // We need to apply a translation based off what region we are inside.
 481                     RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(*ancestor).physicalTranslationFromFlowToFragment(referencePoint);
 482                     if (fragment)
 483                         referencePoint.moveBy(fragment-&gt;topLeftLocation());
 484                 } else if (!isOutOfFlowPositioned()) {
 485                     if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor))
 486                         referencePoint.moveBy(downcast&lt;RenderBox&gt;(*ancestor).topLeftLocation());
 487                 }
 488 
 489                 ancestor = ancestor-&gt;parent();
 490             }
 491 
 492             if (is&lt;RenderBox&gt;(*offsetParent) &amp;&amp; offsetParent-&gt;isBody() &amp;&amp; !offsetParent-&gt;isPositioned())
 493                 referencePoint.moveBy(downcast&lt;RenderBox&gt;(*offsetParent).topLeftLocation());
 494         }
 495     }
 496 
 497     return referencePoint;
 498 }
 499 
 500 void RenderBoxModelObject::computeStickyPositionConstraints(StickyPositionViewportConstraints&amp; constraints, const FloatRect&amp; constrainingRect) const
 501 {
 502     constraints.setConstrainingRectAtLastLayout(constrainingRect);
 503 
 504     RenderBlock* containingBlock = this-&gt;containingBlock();
 505     RenderLayer* enclosingClippingLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);
 506     RenderBox&amp; enclosingClippingBox = enclosingClippingLayer ? downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer()) : view();
 507 
 508     LayoutRect containerContentRect;
 509     if (!enclosingClippingLayer || (containingBlock != &amp;enclosingClippingBox))
 510         containerContentRect = containingBlock-&gt;contentBoxRect();
 511     else {
 512         containerContentRect = containingBlock-&gt;layoutOverflowRect();
 513         LayoutPoint containerLocation = containerContentRect.location() + LayoutPoint(containingBlock-&gt;borderLeft() + containingBlock-&gt;paddingLeft(),
 514             containingBlock-&gt;borderTop() + containingBlock-&gt;paddingTop());
 515         containerContentRect.setLocation(containerLocation);
 516     }
 517 
 518     LayoutUnit maxWidth = containingBlock-&gt;availableLogicalWidth();
 519 
 520     // Sticky positioned element ignore any override logical width on the containing block (as they don&#39;t call
 521     // containingBlockLogicalWidthForContent). It&#39;s unclear whether this is totally fine.
 522     LayoutBoxExtent minMargin(minimumValueForLength(style().marginTop(), maxWidth),
 523         minimumValueForLength(style().marginRight(), maxWidth),
 524         minimumValueForLength(style().marginBottom(), maxWidth),
 525         minimumValueForLength(style().marginLeft(), maxWidth));
 526 
 527     // Compute the container-relative area within which the sticky element is allowed to move.
 528     containerContentRect.contract(minMargin);
 529 
 530     // Finally compute container rect relative to the scrolling ancestor.
 531     FloatRect containerRectRelativeToScrollingAncestor = containingBlock-&gt;localToContainerQuad(FloatRect(containerContentRect), &amp;enclosingClippingBox).boundingBox();
 532     if (enclosingClippingLayer) {
 533         FloatPoint containerLocationRelativeToScrollingAncestor = containerRectRelativeToScrollingAncestor.location() -
 534             FloatSize(enclosingClippingBox.borderLeft() + enclosingClippingBox.paddingLeft(),
 535             enclosingClippingBox.borderTop() + enclosingClippingBox.paddingTop());
 536         if (&amp;enclosingClippingBox != containingBlock)
 537             containerLocationRelativeToScrollingAncestor += enclosingClippingLayer-&gt;scrollOffset();
 538         containerRectRelativeToScrollingAncestor.setLocation(containerLocationRelativeToScrollingAncestor);
 539     }
 540     constraints.setContainingBlockRect(containerRectRelativeToScrollingAncestor);
 541 
 542     // Now compute the sticky box rect, also relative to the scrolling ancestor.
 543     LayoutRect stickyBoxRect = frameRectForStickyPositioning();
 544     LayoutRect flippedStickyBoxRect = stickyBoxRect;
 545     containingBlock-&gt;flipForWritingMode(flippedStickyBoxRect);
 546     FloatRect stickyBoxRelativeToScrollingAnecstor = flippedStickyBoxRect;
 547 
 548     // FIXME: sucks to call localToContainerQuad again, but we can&#39;t just offset from the previously computed rect if there are transforms.
 549     // Map to the view to avoid including page scale factor.
 550     FloatPoint stickyLocationRelativeToScrollingAncestor = flippedStickyBoxRect.location() + containingBlock-&gt;localToContainerQuad(FloatRect(FloatPoint(), containingBlock-&gt;size()), &amp;enclosingClippingBox).boundingBox().location();
 551     if (enclosingClippingLayer) {
 552         stickyLocationRelativeToScrollingAncestor -= FloatSize(enclosingClippingBox.borderLeft() + enclosingClippingBox.paddingLeft(),
 553             enclosingClippingBox.borderTop() + enclosingClippingBox.paddingTop());
 554         if (&amp;enclosingClippingBox != containingBlock)
 555             stickyLocationRelativeToScrollingAncestor += enclosingClippingLayer-&gt;scrollOffset();
 556     }
 557     // FIXME: For now, assume that |this| is not transformed.
 558     stickyBoxRelativeToScrollingAnecstor.setLocation(stickyLocationRelativeToScrollingAncestor);
 559     constraints.setStickyBoxRect(stickyBoxRelativeToScrollingAnecstor);
 560 
 561     if (!style().left().isAuto()) {
 562         constraints.setLeftOffset(valueForLength(style().left(), constrainingRect.width()));
 563         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
 564     }
 565 
 566     if (!style().right().isAuto()) {
 567         constraints.setRightOffset(valueForLength(style().right(), constrainingRect.width()));
 568         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
 569     }
 570 
 571     if (!style().top().isAuto()) {
 572         constraints.setTopOffset(valueForLength(style().top(), constrainingRect.height()));
 573         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
 574     }
 575 
 576     if (!style().bottom().isAuto()) {
 577         constraints.setBottomOffset(valueForLength(style().bottom(), constrainingRect.height()));
 578         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
 579     }
 580 }
 581 
 582 FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
 583 {
 584     RenderLayer* enclosingClippingLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);
 585     if (enclosingClippingLayer) {
 586         RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
 587         LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
 588         clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
 589             enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
 590 
 591         FloatRect constrainingRect = enclosingClippingBox.localToContainerQuad(FloatRect(clipRect), &amp;view()).boundingBox();
 592 
 593         FloatPoint scrollOffset = FloatPoint() + enclosingClippingLayer-&gt;scrollOffset();
 594 
 595         float scrollbarOffset = 0;
 596         if (enclosingClippingBox.hasLayer() &amp;&amp; enclosingClippingBox.shouldPlaceBlockDirectionScrollbarOnLeft())
 597             scrollbarOffset = enclosingClippingBox.layer()-&gt;verticalScrollbarWidth(IgnoreOverlayScrollbarSize);
 598 
 599         constrainingRect.setLocation(FloatPoint(scrollOffset.x() + scrollbarOffset, scrollOffset.y()));
 600         return constrainingRect;
 601     }
 602 
 603     return view().frameView().rectForFixedPositionLayout();
 604 }
 605 
 606 LayoutSize RenderBoxModelObject::stickyPositionOffset() const
 607 {
 608     ASSERT(hasLayer());
 609 
 610     FloatRect constrainingRect = constrainingRectForStickyPosition();
 611     StickyPositionViewportConstraints constraints;
 612     computeStickyPositionConstraints(constraints, constrainingRect);
 613 
 614     // The sticky offset is physical, so we can just return the delta computed in absolute coords (though it may be wrong with transforms).
 615     return LayoutSize(constraints.computeStickyOffset(constrainingRect));
 616 }
 617 
 618 LayoutSize RenderBoxModelObject::offsetForInFlowPosition() const
 619 {
 620     if (isRelativelyPositioned())
 621         return relativePositionOffset();
 622 
 623     if (isStickilyPositioned())
 624         return stickyPositionOffset();
 625 
 626     return LayoutSize();
 627 }
 628 
 629 LayoutUnit RenderBoxModelObject::offsetLeft() const
 630 {
 631     // Note that RenderInline and RenderBox override this to pass a different
 632     // startPoint to adjustedPositionRelativeToOffsetParent.
 633     return adjustedPositionRelativeToOffsetParent(LayoutPoint()).x();
 634 }
 635 
 636 LayoutUnit RenderBoxModelObject::offsetTop() const
 637 {
 638     // Note that RenderInline and RenderBox override this to pass a different
 639     // startPoint to adjustedPositionRelativeToOffsetParent.
 640     return adjustedPositionRelativeToOffsetParent(LayoutPoint()).y();
 641 }
 642 
 643 LayoutUnit RenderBoxModelObject::computedCSSPadding(const Length&amp; padding) const
 644 {
 645     LayoutUnit w;
 646     if (padding.isPercentOrCalculated())
 647         w = containingBlockLogicalWidthForContent();
 648     return minimumValueForLength(padding, w);
 649 }
 650 
 651 RoundedRect RenderBoxModelObject::getBackgroundRoundedRect(const LayoutRect&amp; borderRect, InlineFlowBox* box, LayoutUnit inlineBoxWidth, LayoutUnit inlineBoxHeight,
 652     bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 653 {
 654     RoundedRect border = style().getRoundedBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 655     if (box &amp;&amp; (box-&gt;nextLineBox() || box-&gt;prevLineBox())) {
 656         RoundedRect segmentBorder = style().getRoundedBorderFor(LayoutRect(0_lu, 0_lu, inlineBoxWidth, inlineBoxHeight), includeLogicalLeftEdge, includeLogicalRightEdge);
 657         border.setRadii(segmentBorder.radii());
 658     }
 659     return border;
 660 }
 661 
 662 void RenderBoxModelObject::clipRoundedInnerRect(GraphicsContext&amp; context, const FloatRect&amp; rect, const FloatRoundedRect&amp; clipRect)
 663 {
 664     if (clipRect.isRenderable())
 665         context.clipRoundedRect(clipRect);
 666     else {
 667         // We create a rounded rect for each of the corners and clip it, while making sure we clip opposing corners together.
 668         if (!clipRect.radii().topLeft().isEmpty() || !clipRect.radii().bottomRight().isEmpty()) {
 669             FloatRect topCorner(clipRect.rect().x(), clipRect.rect().y(), rect.maxX() - clipRect.rect().x(), rect.maxY() - clipRect.rect().y());
 670             FloatRoundedRect::Radii topCornerRadii;
 671             topCornerRadii.setTopLeft(clipRect.radii().topLeft());
 672             context.clipRoundedRect(FloatRoundedRect(topCorner, topCornerRadii));
 673 
 674             FloatRect bottomCorner(rect.x(), rect.y(), clipRect.rect().maxX() - rect.x(), clipRect.rect().maxY() - rect.y());
 675             FloatRoundedRect::Radii bottomCornerRadii;
 676             bottomCornerRadii.setBottomRight(clipRect.radii().bottomRight());
 677             context.clipRoundedRect(FloatRoundedRect(bottomCorner, bottomCornerRadii));
 678         }
 679 
 680         if (!clipRect.radii().topRight().isEmpty() || !clipRect.radii().bottomLeft().isEmpty()) {
 681             FloatRect topCorner(rect.x(), clipRect.rect().y(), clipRect.rect().maxX() - rect.x(), rect.maxY() - clipRect.rect().y());
 682             FloatRoundedRect::Radii topCornerRadii;
 683             topCornerRadii.setTopRight(clipRect.radii().topRight());
 684             context.clipRoundedRect(FloatRoundedRect(topCorner, topCornerRadii));
 685 
 686             FloatRect bottomCorner(clipRect.rect().x(), rect.y(), rect.maxX() - clipRect.rect().x(), clipRect.rect().maxY() - rect.y());
 687             FloatRoundedRect::Radii bottomCornerRadii;
 688             bottomCornerRadii.setBottomLeft(clipRect.radii().bottomLeft());
 689             context.clipRoundedRect(FloatRoundedRect(bottomCorner, bottomCornerRadii));
 690         }
 691     }
 692 }
 693 
 694 static LayoutRect shrinkRectByOneDevicePixel(const GraphicsContext&amp; context, const LayoutRect&amp; rect, float devicePixelRatio)
 695 {
 696     LayoutRect shrunkRect = rect;
 697     AffineTransform transform = context.getCTM();
 698     shrunkRect.inflateX(-ceilToDevicePixel(1_lu / transform.xScale(), devicePixelRatio));
 699     shrunkRect.inflateY(-ceilToDevicePixel(1_lu / transform.yScale(), devicePixelRatio));
 700     return shrunkRect;
 701 }
 702 
 703 LayoutRect RenderBoxModelObject::borderInnerRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; rect, BackgroundBleedAvoidance bleedAvoidance) const
 704 {
 705     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder)
 706         return rect;
 707 
 708     // We shrink the rectangle by one device pixel on each side to make it fully overlap the anti-aliased background border
 709     return shrinkRectByOneDevicePixel(context, rect, document().deviceScaleFactor());
 710 }
 711 
 712 RoundedRect RenderBoxModelObject::backgroundRoundedRectAdjustedForBleedAvoidance(const GraphicsContext&amp; context, const LayoutRect&amp; borderRect, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
 713 {
 714     if (bleedAvoidance == BackgroundBleedShrinkBackground) {
 715         // We shrink the rectangle by one device pixel on each side because the bleed is one pixel maximum.
 716         return getBackgroundRoundedRect(shrinkRectByOneDevicePixel(context, borderRect, document().deviceScaleFactor()), box, boxSize.width(), boxSize.height(),
 717             includeLogicalLeftEdge, includeLogicalRightEdge);
 718     }
 719     if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
 720         return style().getRoundedInnerBorderFor(borderRect, includeLogicalLeftEdge, includeLogicalRightEdge);
 721 
 722     return getBackgroundRoundedRect(borderRect, box, boxSize.width(), boxSize.height(), includeLogicalLeftEdge, includeLogicalRightEdge);
 723 }
 724 
 725 static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
 726 {
 727     const ShadowData* boxShadow = style.boxShadow();
 728     while (boxShadow-&gt;style() != Normal)
 729         boxShadow = boxShadow-&gt;next();
 730 
 731     FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
 732     if (!boxShadow-&gt;isWebkitBoxShadow())
 733         context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 734     else
 735         context.setLegacyShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
 736 }
 737 
 738 InterpolationQuality RenderBoxModelObject::chooseInterpolationQuality(GraphicsContext&amp; context, Image&amp; image, const void* layer, const LayoutSize&amp; size)
 739 {
 740     return view().imageQualityController().chooseInterpolationQuality(context, this, image, layer, size);
 741 }
 742 
 743 void RenderBoxModelObject::paintMaskForTextFillBox(ImageBuffer* maskImage, const IntRect&amp; maskRect, InlineFlowBox* box, const LayoutRect&amp; scrolledPaintRect)
 744 {
 745     GraphicsContext&amp; maskImageContext = maskImage-&gt;context();
 746     maskImageContext.translate(-maskRect.location());
 747 
 748     // Now add the text to the clip. We do this by painting using a special paint phase that signals to
 749     // InlineTextBoxes that they should just add their contents to the clip.
 750     PaintInfo info(maskImageContext, maskRect, PaintPhase::TextClip, PaintBehavior::ForceBlackText);
 751     if (box) {
 752         const RootInlineBox&amp; rootBox = box-&gt;root();
 753         box-&gt;paint(info, LayoutPoint(scrolledPaintRect.x() - box-&gt;x(), scrolledPaintRect.y() - box-&gt;y()), rootBox.lineTop(), rootBox.lineBottom());
 754     } else {
 755         LayoutSize localOffset = is&lt;RenderBox&gt;(*this) ? downcast&lt;RenderBox&gt;(*this).locationOffset() : LayoutSize();
 756         paint(info, scrolledPaintRect.location() - localOffset);
 757     }
 758 }
 759 
 760 void RenderBoxModelObject::paintFillLayerExtended(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; bgLayer, const LayoutRect&amp; rect,
 761     BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* box, const LayoutSize&amp; boxSize, CompositeOperator op, RenderElement* backgroundObject, BaseBackgroundColorUsage baseBgColorUsage)
 762 {
 763     GraphicsContext&amp; context = paintInfo.context();
 764     if (context.paintingDisabled() || rect.isEmpty())
 765         return;
 766 
 767     bool includeLeftEdge = box ? box-&gt;includeLogicalLeftEdge() : true;
 768     bool includeRightEdge = box ? box-&gt;includeLogicalRightEdge() : true;
 769 
 770     bool hasRoundedBorder = style().hasBorderRadius() &amp;&amp; (includeLeftEdge || includeRightEdge);
 771     bool clippedWithLocalScrolling = hasOverflowClip() &amp;&amp; bgLayer.attachment() == FillAttachment::LocalBackground;
 772     bool isBorderFill = bgLayer.clip() == FillBox::Border;
 773     bool isRoot = this-&gt;isDocumentElementRenderer();
 774 
 775     Color bgColor = color;
 776     StyleImage* bgImage = bgLayer.image();
 777     bool shouldPaintBackgroundImage = bgImage &amp;&amp; bgImage-&gt;canRender(this, style().effectiveZoom());
 778 
 779     if (context.invalidatingImagesWithAsyncDecodes()) {
 780         if (shouldPaintBackgroundImage &amp;&amp; bgImage-&gt;cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
 781             bgImage-&gt;cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
 782         return;
 783     }
 784 
 785     bool forceBackgroundToWhite = false;
 786     if (document().printing()) {
 787         if (style().printColorAdjust() == PrintColorAdjust::Economy)
 788             forceBackgroundToWhite = true;
 789         if (settings().shouldPrintBackgrounds())
 790             forceBackgroundToWhite = false;
 791     }
 792 
 793     // When printing backgrounds is disabled or using economy mode,
 794     // change existing background colors and images to a solid white background.
 795     // If there&#39;s no bg color or image, leave it untouched to avoid affecting transparency.
 796     // We don&#39;t try to avoid loading the background images, because this style flag is only set
 797     // when printing, and at that point we&#39;ve already loaded the background images anyway. (To avoid
 798     // loading the background images we&#39;d have to do this check when applying styles rather than
 799     // while rendering.)
 800     if (forceBackgroundToWhite) {
 801         // Note that we can&#39;t reuse this variable below because the bgColor might be changed
 802         bool shouldPaintBackgroundColor = !bgLayer.next() &amp;&amp; bgColor.isVisible();
 803         if (shouldPaintBackgroundImage || shouldPaintBackgroundColor) {
 804             bgColor = Color::white;
 805             shouldPaintBackgroundImage = false;
 806         }
 807     }
 808 
 809     bool baseBgColorOnly = (baseBgColorUsage == BaseBackgroundColorOnly);
 810     if (baseBgColorOnly &amp;&amp; (!isRoot || bgLayer.next() || bgColor.isOpaque()))
 811         return;
 812 
 813     bool colorVisible = bgColor.isVisible();
 814     float deviceScaleFactor = document().deviceScaleFactor();
 815     FloatRect pixelSnappedRect = snapRectToDevicePixels(rect, deviceScaleFactor);
 816 
 817     // Fast path for drawing simple color backgrounds.
 818     if (!isRoot &amp;&amp; !clippedWithLocalScrolling &amp;&amp; !shouldPaintBackgroundImage &amp;&amp; isBorderFill &amp;&amp; !bgLayer.next()) {
 819         if (!colorVisible)
 820             return;
 821 
 822         bool boxShadowShouldBeAppliedToBackground = this-&gt;boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance, box);
 823         GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 824         if (boxShadowShouldBeAppliedToBackground)
 825             applyBoxShadowForBackground(context, style());
 826 
 827         if (hasRoundedBorder &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer) {
 828             FloatRoundedRect pixelSnappedBorder = backgroundRoundedRectAdjustedForBleedAvoidance(context, rect, bleedAvoidance, box, boxSize,
 829                 includeLeftEdge, includeRightEdge).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
 830             if (pixelSnappedBorder.isRenderable()) {
 831                 CompositeOperator previousOperator = context.compositeOperation();
 832                 bool saveRestoreCompositeOp = op != previousOperator;
 833                 if (saveRestoreCompositeOp)
 834                     context.setCompositeOperation(op);
 835 
 836                 context.fillRoundedRect(pixelSnappedBorder, bgColor);
 837 
 838                 if (saveRestoreCompositeOp)
 839                     context.setCompositeOperation(previousOperator);
 840             } else {
 841                 context.save();
 842                 clipRoundedInnerRect(context, pixelSnappedRect, pixelSnappedBorder);
 843                 context.fillRect(pixelSnappedBorder.rect(), bgColor, op);
 844                 context.restore();
 845             }
 846         } else
 847             context.fillRect(pixelSnappedRect, bgColor, op);
 848 
 849         return;
 850     }
 851 
 852     // FillBox::Border radius clipping is taken care of by BackgroundBleedUseTransparencyLayer
 853     bool clipToBorderRadius = hasRoundedBorder &amp;&amp; !(isBorderFill &amp;&amp; bleedAvoidance == BackgroundBleedUseTransparencyLayer);
 854     GraphicsContextStateSaver clipToBorderStateSaver(context, clipToBorderRadius);
 855     if (clipToBorderRadius) {
 856         RoundedRect border = isBorderFill ? backgroundRoundedRectAdjustedForBleedAvoidance(context, rect, bleedAvoidance, box, boxSize, includeLeftEdge, includeRightEdge) : getBackgroundRoundedRect(rect, box, boxSize.width(), boxSize.height(), includeLeftEdge, includeRightEdge);
 857 
 858         // Clip to the padding or content boxes as necessary.
 859         if (bgLayer.clip() == FillBox::Content) {
 860             border = style().getRoundedInnerBorderFor(border.rect(),
 861                 paddingTop() + borderTop(), paddingBottom() + borderBottom(), paddingLeft() + borderLeft(), paddingRight() + borderRight(), includeLeftEdge, includeRightEdge);
 862         } else if (bgLayer.clip() == FillBox::Padding)
 863             border = style().getRoundedInnerBorderFor(border.rect(), includeLeftEdge, includeRightEdge);
 864 
 865         clipRoundedInnerRect(context, pixelSnappedRect, border.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
 866     }
 867 
 868     LayoutUnit bLeft = includeLeftEdge ? borderLeft() : 0_lu;
 869     LayoutUnit bRight = includeRightEdge ? borderRight() : 0_lu;
 870     LayoutUnit pLeft = includeLeftEdge ? paddingLeft() : 0_lu;
 871     LayoutUnit pRight = includeRightEdge ? paddingRight() : 0_lu;
 872 
 873     GraphicsContextStateSaver clipWithScrollingStateSaver(context, clippedWithLocalScrolling);
 874     LayoutRect scrolledPaintRect = rect;
 875     if (clippedWithLocalScrolling) {
 876         // Clip to the overflow area.
 877         auto&amp; thisBox = downcast&lt;RenderBox&gt;(*this);
 878         context.clip(thisBox.overflowClipRect(rect.location()));
 879 
 880         // Adjust the paint rect to reflect a scrolled content box with borders at the ends.
 881         scrolledPaintRect.moveBy(-thisBox.scrollPosition());
 882         scrolledPaintRect.setWidth(bLeft + layer()-&gt;scrollWidth() + bRight);
 883         scrolledPaintRect.setHeight(borderTop() + layer()-&gt;scrollHeight() + borderBottom());
 884     }
 885 
 886     GraphicsContextStateSaver backgroundClipStateSaver(context, false);
 887     std::unique_ptr&lt;ImageBuffer&gt; maskImage;
 888     IntRect maskRect;
 889 
 890     if (bgLayer.clip() == FillBox::Padding || bgLayer.clip() == FillBox::Content) {
 891         // Clip to the padding or content boxes as necessary.
 892         if (!clipToBorderRadius) {
 893             bool includePadding = bgLayer.clip() == FillBox::Content;
 894             LayoutRect clipRect = LayoutRect(scrolledPaintRect.x() + bLeft + (includePadding ? pLeft : 0_lu),
 895                 scrolledPaintRect.y() + borderTop() + (includePadding ? paddingTop() : 0_lu),
 896                 scrolledPaintRect.width() - bLeft - bRight - (includePadding ? pLeft + pRight : 0_lu),
 897                 scrolledPaintRect.height() - borderTop() - borderBottom() - (includePadding ? paddingTop() + paddingBottom() : 0_lu));
 898             backgroundClipStateSaver.save();
 899             context.clip(clipRect);
 900         }
 901     } else if (bgLayer.clip() == FillBox::Text) {
 902         // We have to draw our text into a mask that can then be used to clip background drawing.
 903         // First figure out how big the mask has to be.  It should be no bigger than what we need
 904         // to actually render, so we should intersect the dirty rect with the border box of the background.
 905         maskRect = snappedIntRect(rect);
 906         maskRect.intersect(snappedIntRect(paintInfo.rect));
 907 
 908         // Now create the mask.
 909         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, context);
 910         if (!maskImage)
 911             return;
 912         paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
 913 
 914         // The mask has been created.  Now we just need to clip to it.
 915         backgroundClipStateSaver.save();
 916         context.clip(maskRect);
 917         context.beginTransparencyLayer(1);
 918     }
 919 
 920     // Only fill with a base color (e.g., white) if we&#39;re the root document, since iframes/frames with
 921     // no background in the child document should show the parent&#39;s background.
 922     bool isOpaqueRoot = false;
 923     if (isRoot) {
 924         isOpaqueRoot = true;
 925         if (!bgLayer.next() &amp;&amp; !bgColor.isOpaque()) {
 926             HTMLFrameOwnerElement* ownerElement = document().ownerElement();
 927             if (ownerElement) {
 928                 if (!ownerElement-&gt;hasTagName(frameTag)) {
 929                     // Locate the &lt;body&gt; element using the DOM.  This is easier than trying
 930                     // to crawl around a render tree with potential :before/:after content and
 931                     // anonymous blocks created by inline &lt;body&gt; tags etc.  We can locate the &lt;body&gt;
 932                     // render object very easily via the DOM.
 933                     if (HTMLElement* body = document().bodyOrFrameset()) {
 934                         // Can&#39;t scroll a frameset document anyway.
 935                         isOpaqueRoot = is&lt;HTMLFrameSetElement&gt;(*body);
 936                     } else {
 937                         // SVG documents and XML documents with SVG root nodes are transparent.
 938                         isOpaqueRoot = !document().hasSVGRootNode();
 939                     }
 940                 }
 941             } else
 942                 isOpaqueRoot = !view().frameView().isTransparent();
 943         }
 944         view().frameView().setContentIsOpaque(isOpaqueRoot);
 945     }
 946 
 947     // Paint the color first underneath all images, culled if background image occludes it.
 948     // FIXME: In the bgLayer.hasFiniteBounds() case, we could improve the culling test
 949     // by verifying whether the background image covers the entire layout rect.
 950     if (!bgLayer.next()) {
 951         LayoutRect backgroundRect(scrolledPaintRect);
 952         bool boxShadowShouldBeAppliedToBackground = this-&gt;boxShadowShouldBeAppliedToBackground(rect.location(), bleedAvoidance, box);
 953         if (boxShadowShouldBeAppliedToBackground || !shouldPaintBackgroundImage || !bgLayer.hasOpaqueImage(*this) || !bgLayer.hasRepeatXY() || bgLayer.isEmpty()) {
 954             if (!boxShadowShouldBeAppliedToBackground)
 955                 backgroundRect.intersect(paintInfo.rect);
 956 
 957             // If we have an alpha and we are painting the root element, blend with the base background color.
 958             Color baseColor;
 959             bool shouldClearBackground = false;
 960             if ((baseBgColorUsage != BaseBackgroundColorSkip) &amp;&amp; isOpaqueRoot) {
 961                 baseColor = view().frameView().baseBackgroundColor();
 962                 if (!baseColor.isVisible())
 963                     shouldClearBackground = true;
 964             }
 965 
 966             GraphicsContextStateSaver shadowStateSaver(context, boxShadowShouldBeAppliedToBackground);
 967             if (boxShadowShouldBeAppliedToBackground)
 968                 applyBoxShadowForBackground(context, style());
 969 
 970             FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
 971             if (baseColor.isVisible()) {
 972                 if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
 973                     baseColor = baseColor.blend(bgColor);
 974                 context.fillRect(backgroundRectForPainting, baseColor, CompositeCopy);
 975             } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
 976                 auto operation = context.compositeOperation();
 977                 if (shouldClearBackground) {
 978                     if (op == CompositeDestinationOut) // We&#39;re punching out the background.
 979                         operation = op;
 980                     else
 981                         operation = CompositeCopy;
 982                 }
 983                 context.fillRect(backgroundRectForPainting, bgColor, operation);
 984             } else if (shouldClearBackground)
 985                 context.clearRect(backgroundRectForPainting);
 986         }
 987     }
 988 
 989     // no progressive loading of the background image
 990     if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
 991         auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
 992         geometry.clip(LayoutRect(pixelSnappedRect));
 993         RefPtr&lt;Image&gt; image;
 994         if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {
 995             auto compositeOp = op == CompositeSourceOver ? bgLayer.composite() : op;
 996             context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
 997 
 998             if (is&lt;BitmapImage&gt;(image))
 999                 downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
1000 
1001             auto interpolation = chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize());
1002             auto decodingMode = decodingModeForImageDraw(*image, paintInfo);
1003             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), ImagePaintingOptions(compositeOp, bgLayer.blendMode(), decodingMode, ImageOrientationDescription(), interpolation));
1004             if (drawResult == ImageDrawResult::DidRequestDecoding) {
1005                 ASSERT(bgImage-&gt;isCachedImage());
1006                 bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
1007             }
1008         }
1009     }
1010 
1011     if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
1012         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeDestinationIn);
1013         context.endTransparencyLayer();
1014     }
1015 }
1016 
1017 static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
1018 {
1019     return height * intrinsicRatio.width() / intrinsicRatio.height();
1020 }
1021 
1022 static inline LayoutUnit resolveHeightForRatio(LayoutUnit width, const LayoutSize&amp; intrinsicRatio)
1023 {
1024     return width * intrinsicRatio.height() / intrinsicRatio.width();
1025 }
1026 
1027 static inline LayoutSize resolveAgainstIntrinsicWidthOrHeightAndRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio, LayoutUnit useWidth, LayoutUnit useHeight)
1028 {
1029     if (intrinsicRatio.isEmpty()) {
1030         if (useWidth)
1031             return LayoutSize(useWidth, size.height());
1032         return LayoutSize(size.width(), useHeight);
1033     }
1034 
1035     if (useWidth)
1036         return LayoutSize(useWidth, resolveHeightForRatio(useWidth, intrinsicRatio));
1037     return LayoutSize(resolveWidthForRatio(useHeight, intrinsicRatio), useHeight);
1038 }
1039 
1040 static inline LayoutSize resolveAgainstIntrinsicRatio(const LayoutSize&amp; size, const LayoutSize&amp; intrinsicRatio)
1041 {
1042     // Two possible solutions: (size.width(), solutionHeight) or (solutionWidth, size.height())
1043     // &quot;... must be assumed to be the largest dimensions...&quot; = easiest answer: the rect with the largest surface area.
1044 
1045     LayoutUnit solutionWidth = resolveWidthForRatio(size.height(), intrinsicRatio);
1046     LayoutUnit solutionHeight = resolveHeightForRatio(size.width(), intrinsicRatio);
1047     if (solutionWidth &lt;= size.width()) {
1048         if (solutionHeight &lt;= size.height()) {
1049             // If both solutions fit, choose the one covering the larger area.
1050             LayoutUnit areaOne = solutionWidth * size.height();
1051             LayoutUnit areaTwo = size.width() * solutionHeight;
1052             if (areaOne &lt; areaTwo)
1053                 return LayoutSize(size.width(), solutionHeight);
1054             return LayoutSize(solutionWidth, size.height());
1055         }
1056 
1057         // Only the first solution fits.
1058         return LayoutSize(solutionWidth, size.height());
1059     }
1060 
1061     // Only the second solution fits, assert that.
1062     ASSERT(solutionHeight &lt;= size.height());
1063     return LayoutSize(size.width(), solutionHeight);
1064 }
1065 
1066 LayoutSize RenderBoxModelObject::calculateImageIntrinsicDimensions(StyleImage* image, const LayoutSize&amp; positioningAreaSize, ScaleByEffectiveZoomOrNot shouldScaleOrNot) const
1067 {
1068     // A generated image without a fixed size, will always return the container size as intrinsic size.
1069     if (image-&gt;isGeneratedImage() &amp;&amp; image-&gt;usesImageContainerSize())
1070         return LayoutSize(positioningAreaSize.width(), positioningAreaSize.height());
1071 
1072     Length intrinsicWidth;
1073     Length intrinsicHeight;
1074     FloatSize intrinsicRatio;
1075     image-&gt;computeIntrinsicDimensions(this, intrinsicWidth, intrinsicHeight, intrinsicRatio);
1076 
1077     ASSERT(!intrinsicWidth.isPercentOrCalculated());
1078     ASSERT(!intrinsicHeight.isPercentOrCalculated());
1079 
1080     LayoutSize resolvedSize(intrinsicWidth.value(), intrinsicHeight.value());
1081     LayoutSize minimumSize(resolvedSize.width() &gt; 0 ? 1 : 0, resolvedSize.height() &gt; 0 ? 1 : 0);
1082 
1083     if (shouldScaleOrNot == ScaleByEffectiveZoom)
1084         resolvedSize.scale(style().effectiveZoom());
1085     resolvedSize.clampToMinimumSize(minimumSize);
1086 
1087     if (!resolvedSize.isEmpty())
1088         return resolvedSize;
1089 
1090     // If the image has one of either an intrinsic width or an intrinsic height:
1091     // * and an intrinsic aspect ratio, then the missing dimension is calculated from the given dimension and the ratio.
1092     // * and no intrinsic aspect ratio, then the missing dimension is assumed to be the size of the rectangle that
1093     //   establishes the coordinate system for the &#39;background-position&#39; property.
1094     if (resolvedSize.width() &gt; 0 || resolvedSize.height() &gt; 0)
1095         return resolveAgainstIntrinsicWidthOrHeightAndRatio(positioningAreaSize, LayoutSize(intrinsicRatio), resolvedSize.width(), resolvedSize.height());
1096 
1097     // If the image has no intrinsic dimensions and has an intrinsic ratio the dimensions must be assumed to be the
1098     // largest dimensions at that ratio such that neither dimension exceeds the dimensions of the rectangle that
1099     // establishes the coordinate system for the &#39;background-position&#39; property.
1100     if (!intrinsicRatio.isEmpty())
1101         return resolveAgainstIntrinsicRatio(positioningAreaSize, LayoutSize(intrinsicRatio));
1102 
1103     // If the image has no intrinsic ratio either, then the dimensions must be assumed to be the rectangle that
1104     // establishes the coordinate system for the &#39;background-position&#39; property.
1105     return positioningAreaSize;
1106 }
1107 
1108 LayoutSize RenderBoxModelObject::calculateFillTileSize(const FillLayer&amp; fillLayer, const LayoutSize&amp; positioningAreaSize) const
1109 {
1110     StyleImage* image = fillLayer.image();
1111     FillSizeType type = fillLayer.size().type;
1112 
1113     LayoutSize imageIntrinsicSize;
1114     if (image) {
1115         imageIntrinsicSize = calculateImageIntrinsicDimensions(image, positioningAreaSize, ScaleByEffectiveZoom);
1116         imageIntrinsicSize.scale(1 / image-&gt;imageScaleFactor(), 1 / image-&gt;imageScaleFactor());
1117     } else
1118         imageIntrinsicSize = positioningAreaSize;
1119 
1120     switch (type) {
1121     case FillSizeType::Size: {
1122         LayoutSize tileSize = positioningAreaSize;
1123 
1124         Length layerWidth = fillLayer.size().size.width;
1125         Length layerHeight = fillLayer.size().size.height;
1126 
1127         if (layerWidth.isFixed())
1128             tileSize.setWidth(layerWidth.value());
1129         else if (layerWidth.isPercentOrCalculated())
1130             tileSize.setWidth(valueForLength(layerWidth, positioningAreaSize.width()));
1131 
1132         if (layerHeight.isFixed())
1133             tileSize.setHeight(layerHeight.value());
1134         else if (layerHeight.isPercentOrCalculated())
1135             tileSize.setHeight(valueForLength(layerHeight, positioningAreaSize.height()));
1136 
1137         // If one of the values is auto we have to use the appropriate
1138         // scale to maintain our aspect ratio.
1139         if (layerWidth.isAuto() &amp;&amp; !layerHeight.isAuto()) {
1140             if (imageIntrinsicSize.height())
1141                 tileSize.setWidth(imageIntrinsicSize.width() * tileSize.height() / imageIntrinsicSize.height());
1142         } else if (!layerWidth.isAuto() &amp;&amp; layerHeight.isAuto()) {
1143             if (imageIntrinsicSize.width())
1144                 tileSize.setHeight(imageIntrinsicSize.height() * tileSize.width() / imageIntrinsicSize.width());
1145         } else if (layerWidth.isAuto() &amp;&amp; layerHeight.isAuto()) {
1146             // If both width and height are auto, use the image&#39;s intrinsic size.
1147             tileSize = imageIntrinsicSize;
1148         }
1149 
1150         tileSize.clampNegativeToZero();
1151         return tileSize;
1152     }
1153     case FillSizeType::None: {
1154         // If both values are â€˜autoâ€™ then the intrinsic width and/or height of the image should be used, if any.
1155         if (!imageIntrinsicSize.isEmpty())
1156             return imageIntrinsicSize;
1157 
1158         // If the image has neither an intrinsic width nor an intrinsic height, its size is determined as for â€˜containâ€™.
1159         type = FillSizeType::Contain;
1160     }
1161     FALLTHROUGH;
1162     case FillSizeType::Contain:
1163     case FillSizeType::Cover: {
1164         // Scale computation needs higher precision than what LayoutUnit can offer.
1165         FloatSize localImageIntrinsicSize = imageIntrinsicSize;
1166         FloatSize localPositioningAreaSize = positioningAreaSize;
1167 
1168         float horizontalScaleFactor = localImageIntrinsicSize.width() ? (localPositioningAreaSize.width() / localImageIntrinsicSize.width()) : 1;
1169         float verticalScaleFactor = localImageIntrinsicSize.height() ? (localPositioningAreaSize.height() / localImageIntrinsicSize.height()) : 1;
1170         float scaleFactor = type == FillSizeType::Contain ? std::min(horizontalScaleFactor, verticalScaleFactor) : std::max(horizontalScaleFactor, verticalScaleFactor);
1171         float singleScaledPixel = 1.0 / document().deviceScaleFactor();
1172 
1173         if (localImageIntrinsicSize.isEmpty())
1174             return { };
1175 
1176         return LayoutSize(localImageIntrinsicSize.scaled(scaleFactor).expandedTo({ singleScaledPixel, singleScaledPixel }));
1177     }
1178     }
1179 
1180     ASSERT_NOT_REACHED();
1181     return { };
1182 }
1183 
1184 static void pixelSnapBackgroundImageGeometryForPainting(LayoutRect&amp; destinationRect, LayoutSize&amp; tileSize, LayoutSize&amp; phase, LayoutSize&amp; space, float scaleFactor)
1185 {
1186     tileSize = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), tileSize), scaleFactor).size());
1187     phase = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), phase), scaleFactor).size());
1188     space = LayoutSize(snapRectToDevicePixels(LayoutRect(LayoutPoint(), space), scaleFactor).size());
1189     destinationRect = LayoutRect(snapRectToDevicePixels(destinationRect, scaleFactor));
1190 }
1191 
1192 bool RenderBoxModelObject::fixedBackgroundPaintsInLocalCoordinates() const
1193 {
1194     if (!isDocumentElementRenderer())
1195         return false;
1196 
1197     if (view().frameView().paintBehavior().contains(PaintBehavior::FlattenCompositingLayers))
1198         return false;
1199 
1200     RenderLayer* rootLayer = view().layer();
1201     if (!rootLayer || !rootLayer-&gt;isComposited())
1202         return false;
1203 
1204     return rootLayer-&gt;backing()-&gt;backgroundLayerPaintsFixedRootBackground();
1205 }
1206 
1207 static inline LayoutUnit getSpace(LayoutUnit areaSize, LayoutUnit tileSize)
1208 {
1209     int numberOfTiles = areaSize / tileSize;
1210     LayoutUnit space = -1;
1211 
1212     if (numberOfTiles &gt; 1)
1213         space = (areaSize - numberOfTiles * tileSize) / (numberOfTiles - 1);
1214 
1215     return space;
1216 }
1217 
1218 static LayoutUnit resolveEdgeRelativeLength(const Length&amp; length, Edge edge, LayoutUnit availableSpace, const LayoutSize&amp; areaSize, const LayoutSize&amp; tileSize)
1219 {
1220     LayoutUnit result = minimumValueForLength(length, availableSpace);
1221 
1222     if (edge == Edge::Right)
1223         return areaSize.width() - tileSize.width() - result;
1224 
1225     if (edge == Edge::Bottom)
1226         return areaSize.height() - tileSize.height() - result;
1227 
1228     return result;
1229 }
1230 
1231 BackgroundImageGeometry RenderBoxModelObject::calculateBackgroundImageGeometry(const RenderLayerModelObject* paintContainer, const FillLayer&amp; fillLayer, const LayoutPoint&amp; paintOffset,
1232     const LayoutRect&amp; borderBoxRect, RenderElement* backgroundObject) const
1233 {
1234     LayoutUnit left;
1235     LayoutUnit top;
1236     LayoutSize positioningAreaSize;
1237     // Determine the background positioning area and set destination rect to the background painting area.
1238     // Destination rect will be adjusted later if the background is non-repeating.
1239     // FIXME: transforms spec says that fixed backgrounds behave like scroll inside transforms. https://bugs.webkit.org/show_bug.cgi?id=15679
1240     LayoutRect destinationRect(borderBoxRect);
1241     bool fixedAttachment = fillLayer.attachment() == FillAttachment::FixedBackground;
1242     float deviceScaleFactor = document().deviceScaleFactor();
1243     if (!fixedAttachment) {
1244         LayoutUnit right;
1245         LayoutUnit bottom;
1246         // Scroll and Local.
1247         if (fillLayer.origin() != FillBox::Border) {
1248             left = borderLeft();
1249             right = borderRight();
1250             top = borderTop();
1251             bottom = borderBottom();
1252             if (fillLayer.origin() == FillBox::Content) {
1253                 left += paddingLeft();
1254                 right += paddingRight();
1255                 top += paddingTop();
1256                 bottom += paddingBottom();
1257             }
1258         }
1259 
1260         // The background of the box generated by the root element covers the entire canvas including
1261         // its margins. Since those were added in already, we have to factor them out when computing
1262         // the background positioning area.
1263         if (isDocumentElementRenderer()) {
1264             positioningAreaSize = downcast&lt;RenderBox&gt;(*this).size() - LayoutSize(left + right, top + bottom);
1265             positioningAreaSize = LayoutSize(snapSizeToDevicePixel(positioningAreaSize, LayoutPoint(), deviceScaleFactor));
1266             if (view().frameView().hasExtendedBackgroundRectForPainting()) {
1267                 LayoutRect extendedBackgroundRect = view().frameView().extendedBackgroundRectForPainting();
1268                 left += (marginLeft() - extendedBackgroundRect.x());
1269                 top += (marginTop() - extendedBackgroundRect.y());
1270             }
1271         } else {
1272             positioningAreaSize = borderBoxRect.size() - LayoutSize(left + right, top + bottom);
1273             positioningAreaSize = LayoutSize(snapRectToDevicePixels(LayoutRect(paintOffset, positioningAreaSize), deviceScaleFactor).size());
1274         }
1275     } else {
1276         LayoutRect viewportRect;
1277         float topContentInset = 0;
1278         if (settings().fixedBackgroundsPaintRelativeToDocument())
1279             viewportRect = view().unscaledDocumentRect();
1280         else {
1281             FrameView&amp; frameView = view().frameView();
1282             bool useFixedLayout = frameView.useFixedLayout() &amp;&amp; !frameView.fixedLayoutSize().isEmpty();
1283 
1284             if (useFixedLayout) {
1285                 // Use the fixedLayoutSize() when useFixedLayout() because the rendering will scale
1286                 // down the frameView to to fit in the current viewport.
1287                 viewportRect.setSize(frameView.fixedLayoutSize());
1288             } else
1289                 viewportRect.setSize(frameView.sizeForVisibleContent());
1290 
1291             if (fixedBackgroundPaintsInLocalCoordinates()) {
1292                 if (!useFixedLayout) {
1293                     // Shifting location up by topContentInset is needed for layout tests which expect
1294                     // layout to be shifted down when calling window.internals.setTopContentInset().
1295                     topContentInset = frameView.topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset);
1296                     viewportRect.setLocation(LayoutPoint(0, -topContentInset));
1297                 }
1298             } else if (useFixedLayout || frameView.frameScaleFactor() != 1) {
1299                 // scrollPositionForFixedPosition() is adjusted for page scale and it does not include
1300                 // topContentInset so do not add it to the calculation below.
1301                 viewportRect.setLocation(frameView.scrollPositionForFixedPosition());
1302             } else {
1303                 // documentScrollPositionRelativeToViewOrigin() includes -topContentInset in its height
1304                 // so we need to account for that in calculating the phase size
1305                 topContentInset = frameView.topContentInset(ScrollView::TopContentInsetType::WebCoreOrPlatformContentInset);
1306                 viewportRect.setLocation(frameView.documentScrollPositionRelativeToViewOrigin());
1307             }
1308 
1309             top += topContentInset;
1310         }
1311 
1312         if (paintContainer)
1313             viewportRect.moveBy(LayoutPoint(-paintContainer-&gt;localToAbsolute(FloatPoint())));
1314 
1315         destinationRect = viewportRect;
1316         positioningAreaSize = destinationRect.size();
1317         positioningAreaSize.setHeight(positioningAreaSize.height() - topContentInset);
1318         positioningAreaSize = LayoutSize(snapRectToDevicePixels(LayoutRect(destinationRect.location(), positioningAreaSize), deviceScaleFactor).size());
1319     }
1320 
1321     auto clientForBackgroundImage = backgroundObject ? backgroundObject : this;
1322     LayoutSize tileSize = calculateFillTileSize(fillLayer, positioningAreaSize);
1323     if (StyleImage* layerImage = fillLayer.image())
1324         layerImage-&gt;setContainerContextForRenderer(*clientForBackgroundImage, tileSize, style().effectiveZoom());
1325 
1326     FillRepeat backgroundRepeatX = fillLayer.repeatX();
1327     FillRepeat backgroundRepeatY = fillLayer.repeatY();
1328     LayoutUnit availableWidth = positioningAreaSize.width() - tileSize.width();
1329     LayoutUnit availableHeight = positioningAreaSize.height() - tileSize.height();
1330 
1331     LayoutSize spaceSize;
1332     LayoutSize phase;
1333     LayoutSize noRepeat;
1334     LayoutUnit computedXPosition = resolveEdgeRelativeLength(fillLayer.xPosition(), fillLayer.backgroundXOrigin(), availableWidth, positioningAreaSize, tileSize);
1335     if (backgroundRepeatX == FillRepeat::Round &amp;&amp; positioningAreaSize.width() &gt; 0 &amp;&amp; tileSize.width() &gt; 0) {
1336         int numTiles = std::max(1, roundToInt(positioningAreaSize.width() / tileSize.width()));
1337         if (fillLayer.size().size.height.isAuto() &amp;&amp; backgroundRepeatY != FillRepeat::Round)
1338             tileSize.setHeight(tileSize.height() * positioningAreaSize.width() / (numTiles * tileSize.width()));
1339 
1340         tileSize.setWidth(positioningAreaSize.width() / numTiles);
1341         phase.setWidth(tileSize.width() ? tileSize.width() - fmodf((computedXPosition + left), tileSize.width()) : 0);
1342     }
1343 
1344     LayoutUnit computedYPosition = resolveEdgeRelativeLength(fillLayer.yPosition(), fillLayer.backgroundYOrigin(), availableHeight, positioningAreaSize, tileSize);
1345     if (backgroundRepeatY == FillRepeat::Round &amp;&amp; positioningAreaSize.height() &gt; 0 &amp;&amp; tileSize.height() &gt; 0) {
1346         int numTiles = std::max(1, roundToInt(positioningAreaSize.height() / tileSize.height()));
1347         if (fillLayer.size().size.width.isAuto() &amp;&amp; backgroundRepeatX != FillRepeat::Round)
1348             tileSize.setWidth(tileSize.width() * positioningAreaSize.height() / (numTiles * tileSize.height()));
1349 
1350         tileSize.setHeight(positioningAreaSize.height() / numTiles);
1351         phase.setHeight(tileSize.height() ? tileSize.height() - fmodf((computedYPosition + top), tileSize.height()) : 0);
1352     }
1353 
1354     if (backgroundRepeatX == FillRepeat::Repeat) {
1355         phase.setWidth(tileSize.width() ? tileSize.width() - fmodf(computedXPosition + left, tileSize.width()) : 0);
1356         spaceSize.setWidth(0);
1357     } else if (backgroundRepeatX == FillRepeat::Space &amp;&amp; tileSize.width() &gt; 0) {
1358         LayoutUnit space = getSpace(positioningAreaSize.width(), tileSize.width());
1359         if (space &gt;= 0) {
1360             LayoutUnit actualWidth = tileSize.width() + space;
1361             computedXPosition = minimumValueForLength(Length(), availableWidth);
1362             spaceSize.setWidth(space);
1363             spaceSize.setHeight(0);
1364             phase.setWidth(actualWidth ? actualWidth - fmodf((computedXPosition + left), actualWidth) : 0);
1365         } else
1366             backgroundRepeatX = FillRepeat::NoRepeat;
1367     }
1368 
1369     if (backgroundRepeatX == FillRepeat::NoRepeat) {
1370         LayoutUnit xOffset = left + computedXPosition;
1371         if (xOffset &gt; 0)
1372             destinationRect.move(xOffset, 0_lu);
1373         xOffset = std::min&lt;LayoutUnit&gt;(xOffset, 0);
1374         phase.setWidth(-xOffset);
1375         destinationRect.setWidth(tileSize.width() + xOffset);
1376         spaceSize.setWidth(0);
1377     }
1378 
1379     if (backgroundRepeatY == FillRepeat::Repeat) {
1380         phase.setHeight(tileSize.height() ? tileSize.height() - fmodf(computedYPosition + top, tileSize.height()) : 0);
1381         spaceSize.setHeight(0);
1382     } else if (backgroundRepeatY == FillRepeat::Space &amp;&amp; tileSize.height() &gt; 0) {
1383         LayoutUnit space = getSpace(positioningAreaSize.height(), tileSize.height());
1384 
1385         if (space &gt;= 0) {
1386             LayoutUnit actualHeight = tileSize.height() + space;
1387             computedYPosition = minimumValueForLength(Length(), availableHeight);
1388             spaceSize.setHeight(space);
1389             phase.setHeight(actualHeight ? actualHeight - fmodf((computedYPosition + top), actualHeight) : 0);
1390         } else
1391             backgroundRepeatY = FillRepeat::NoRepeat;
1392     }
1393     if (backgroundRepeatY == FillRepeat::NoRepeat) {
1394         LayoutUnit yOffset = top + computedYPosition;
1395         if (yOffset &gt; 0)
1396             destinationRect.move(0_lu, yOffset);
1397         yOffset = std::min&lt;LayoutUnit&gt;(yOffset, 0);
1398         phase.setHeight(-yOffset);
1399         destinationRect.setHeight(tileSize.height() + yOffset);
1400         spaceSize.setHeight(0);
1401     }
1402 
1403     if (fixedAttachment) {
1404         LayoutPoint attachmentPoint = borderBoxRect.location();
1405         phase.expand(std::max&lt;LayoutUnit&gt;(attachmentPoint.x() - destinationRect.x(), 0), std::max&lt;LayoutUnit&gt;(attachmentPoint.y() - destinationRect.y(), 0));
1406     }
1407 
1408     destinationRect.intersect(borderBoxRect);
1409     pixelSnapBackgroundImageGeometryForPainting(destinationRect, tileSize, phase, spaceSize, deviceScaleFactor);
1410     return BackgroundImageGeometry(destinationRect, tileSize, phase, spaceSize, fixedAttachment);
1411 }
1412 
1413 void RenderBoxModelObject::getGeometryForBackgroundImage(const RenderLayerModelObject* paintContainer, const LayoutPoint&amp; paintOffset, FloatRect&amp; destRect, FloatSize&amp; phase, FloatSize&amp; tileSize) const
1414 {
1415     LayoutRect paintRect(destRect);
1416     auto geometry = calculateBackgroundImageGeometry(paintContainer, style().backgroundLayers(), paintOffset, paintRect);
1417     phase = geometry.phase();
1418     tileSize = geometry.tileSize();
1419     destRect = geometry.destRect();
1420 }
1421 
1422 bool RenderBoxModelObject::paintNinePieceImage(GraphicsContext&amp; graphicsContext, const LayoutRect&amp; rect, const RenderStyle&amp; style,
1423                                                const NinePieceImage&amp; ninePieceImage, CompositeOperator op)
1424 {
1425     StyleImage* styleImage = ninePieceImage.image();
1426     if (!styleImage)
1427         return false;
1428 
1429     if (!styleImage-&gt;isLoaded())
1430         return true; // Never paint a nine-piece image incrementally, but don&#39;t paint the fallback borders either.
1431 
1432     if (!styleImage-&gt;canRender(this, style.effectiveZoom()))
1433         return false;
1434 
1435     // FIXME: border-image is broken with full page zooming when tiling has to happen, since the tiling function
1436     // doesn&#39;t have any understanding of the zoom that is in effect on the tile.
1437     float deviceScaleFactor = document().deviceScaleFactor();
1438 
1439     LayoutRect rectWithOutsets = rect;
1440     rectWithOutsets.expand(style.imageOutsets(ninePieceImage));
1441     LayoutRect destination = LayoutRect(snapRectToDevicePixels(rectWithOutsets, deviceScaleFactor));
1442 
1443     LayoutSize source = calculateImageIntrinsicDimensions(styleImage, destination.size(), DoNotScaleByEffectiveZoom);
1444 
1445     // If both values are â€˜autoâ€™ then the intrinsic width and/or height of the image should be used, if any.
1446     styleImage-&gt;setContainerContextForRenderer(*this, source, style.effectiveZoom());
1447 
1448     ninePieceImage.paint(graphicsContext, this, style, destination, source, deviceScaleFactor, op);
1449     return true;
1450 }
1451 
1452 static bool allCornersClippedOut(const RoundedRect&amp; border, const LayoutRect&amp; clipRect)
1453 {
1454     LayoutRect boundingRect = border.rect();
1455     if (clipRect.contains(boundingRect))
1456         return false;
1457 
1458     RoundedRect::Radii radii = border.radii();
1459 
1460     LayoutRect topLeftRect(boundingRect.location(), radii.topLeft());
1461     if (clipRect.intersects(topLeftRect))
1462         return false;
1463 
1464     LayoutRect topRightRect(boundingRect.location(), radii.topRight());
1465     topRightRect.setX(boundingRect.maxX() - topRightRect.width());
1466     if (clipRect.intersects(topRightRect))
1467         return false;
1468 
1469     LayoutRect bottomLeftRect(boundingRect.location(), radii.bottomLeft());
1470     bottomLeftRect.setY(boundingRect.maxY() - bottomLeftRect.height());
1471     if (clipRect.intersects(bottomLeftRect))
1472         return false;
1473 
1474     LayoutRect bottomRightRect(boundingRect.location(), radii.bottomRight());
1475     bottomRightRect.setX(boundingRect.maxX() - bottomRightRect.width());
1476     bottomRightRect.setY(boundingRect.maxY() - bottomRightRect.height());
1477     if (clipRect.intersects(bottomRightRect))
1478         return false;
1479 
1480     return true;
1481 }
1482 
1483 static bool borderWillArcInnerEdge(const LayoutSize&amp; firstRadius, const FloatSize&amp; secondRadius)
1484 {
1485     return !firstRadius.isZero() || !secondRadius.isZero();
1486 }
1487 
1488 inline bool styleRequiresClipPolygon(BorderStyle style)
1489 {
1490     return style == BorderStyle::Dotted || style == BorderStyle::Dashed; // These are drawn with a stroke, so we have to clip to get corner miters.
1491 }
1492 
1493 static bool borderStyleFillsBorderArea(BorderStyle style)
1494 {
1495     return !(style == BorderStyle::Dotted || style == BorderStyle::Dashed || style == BorderStyle::Double);
1496 }
1497 
1498 static bool borderStyleHasInnerDetail(BorderStyle style)
1499 {
1500     return style == BorderStyle::Groove || style == BorderStyle::Ridge || style == BorderStyle::Double;
1501 }
1502 
1503 static bool borderStyleIsDottedOrDashed(BorderStyle style)
1504 {
1505     return style == BorderStyle::Dotted || style == BorderStyle::Dashed;
1506 }
1507 
1508 // BorderStyle::Outset darkens the bottom and right (and maybe lightens the top and left)
1509 // BorderStyle::Inset darkens the top and left (and maybe lightens the bottom and right)
1510 static inline bool borderStyleHasUnmatchedColorsAtCorner(BorderStyle style, BoxSide side, BoxSide adjacentSide)
1511 {
1512     // These styles match at the top/left and bottom/right.
1513     if (style == BorderStyle::Inset || style == BorderStyle::Groove || style == BorderStyle::Ridge || style == BorderStyle::Outset) {
1514         const BorderEdgeFlags topRightFlags = edgeFlagForSide(BSTop) | edgeFlagForSide(BSRight);
1515         const BorderEdgeFlags bottomLeftFlags = edgeFlagForSide(BSBottom) | edgeFlagForSide(BSLeft);
1516 
1517         BorderEdgeFlags flags = edgeFlagForSide(side) | edgeFlagForSide(adjacentSide);
1518         return flags == topRightFlags || flags == bottomLeftFlags;
1519     }
1520     return false;
1521 }
1522 
1523 static inline bool colorsMatchAtCorner(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1524 {
1525     if (edges[side].shouldRender() != edges[adjacentSide].shouldRender())
1526         return false;
1527 
1528     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1529         return false;
1530 
1531     return !borderStyleHasUnmatchedColorsAtCorner(edges[side].style(), side, adjacentSide);
1532 }
1533 
1534 
1535 static inline bool colorNeedsAntiAliasAtCorner(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1536 {
1537     if (edges[side].color().isOpaque())
1538         return false;
1539 
1540     if (edges[side].shouldRender() != edges[adjacentSide].shouldRender())
1541         return false;
1542 
1543     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1544         return true;
1545 
1546     return borderStyleHasUnmatchedColorsAtCorner(edges[side].style(), side, adjacentSide);
1547 }
1548 
1549 // This assumes that we draw in order: top, bottom, left, right.
1550 static inline bool willBeOverdrawn(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[])
1551 {
1552     switch (side) {
1553     case BSTop:
1554     case BSBottom:
1555         if (edges[adjacentSide].presentButInvisible())
1556             return false;
1557 
1558         if (!edgesShareColor(edges[side], edges[adjacentSide]) &amp;&amp; !edges[adjacentSide].color().isOpaque())
1559             return false;
1560 
1561         if (!borderStyleFillsBorderArea(edges[adjacentSide].style()))
1562             return false;
1563 
1564         return true;
1565 
1566     case BSLeft:
1567     case BSRight:
1568         // These draw last, so are never overdrawn.
1569         return false;
1570     }
1571     return false;
1572 }
1573 
1574 static inline bool borderStylesRequireMitre(BoxSide side, BoxSide adjacentSide, BorderStyle style, BorderStyle adjacentStyle)
1575 {
1576     if (style == BorderStyle::Double || adjacentStyle == BorderStyle::Double || adjacentStyle == BorderStyle::Groove || adjacentStyle == BorderStyle::Ridge)
1577         return true;
1578 
1579     if (borderStyleIsDottedOrDashed(style) != borderStyleIsDottedOrDashed(adjacentStyle))
1580         return true;
1581 
1582     if (style != adjacentStyle)
1583         return true;
1584 
1585     return borderStyleHasUnmatchedColorsAtCorner(style, side, adjacentSide);
1586 }
1587 
1588 static bool joinRequiresMitre(BoxSide side, BoxSide adjacentSide, const BorderEdge edges[], bool allowOverdraw)
1589 {
1590     if ((edges[side].isTransparent() &amp;&amp; edges[adjacentSide].isTransparent()) || !edges[adjacentSide].isPresent())
1591         return false;
1592 
1593     if (allowOverdraw &amp;&amp; willBeOverdrawn(side, adjacentSide, edges))
1594         return false;
1595 
1596     if (!edgesShareColor(edges[side], edges[adjacentSide]))
1597         return true;
1598 
1599     if (borderStylesRequireMitre(side, adjacentSide, edges[side].style(), edges[adjacentSide].style()))
1600         return true;
1601 
1602     return false;
1603 }
1604 
1605 static RoundedRect calculateAdjustedInnerBorder(const RoundedRect&amp;innerBorder, BoxSide side)
1606 {
1607     // Expand the inner border as necessary to make it a rounded rect (i.e. radii contained within each edge).
1608     // This function relies on the fact we only get radii not contained within each edge if one of the radii
1609     // for an edge is zero, so we can shift the arc towards the zero radius corner.
1610     RoundedRect::Radii newRadii = innerBorder.radii();
1611     LayoutRect newRect = innerBorder.rect();
1612 
1613     float overshoot;
1614     float maxRadii;
1615 
1616     switch (side) {
1617     case BSTop:
1618         overshoot = newRadii.topLeft().width() + newRadii.topRight().width() - newRect.width();
1619         if (overshoot &gt; 0) {
1620             ASSERT(!(newRadii.topLeft().width() &amp;&amp; newRadii.topRight().width()));
1621             newRect.setWidth(newRect.width() + overshoot);
1622             if (!newRadii.topLeft().width())
1623                 newRect.move(-overshoot, 0);
1624         }
1625         newRadii.setBottomLeft(IntSize(0, 0));
1626         newRadii.setBottomRight(IntSize(0, 0));
1627         maxRadii = std::max(newRadii.topLeft().height(), newRadii.topRight().height());
1628         if (maxRadii &gt; newRect.height())
1629             newRect.setHeight(maxRadii);
1630         break;
1631 
1632     case BSBottom:
1633         overshoot = newRadii.bottomLeft().width() + newRadii.bottomRight().width() - newRect.width();
1634         if (overshoot &gt; 0) {
1635             ASSERT(!(newRadii.bottomLeft().width() &amp;&amp; newRadii.bottomRight().width()));
1636             newRect.setWidth(newRect.width() + overshoot);
1637             if (!newRadii.bottomLeft().width())
1638                 newRect.move(-overshoot, 0);
1639         }
1640         newRadii.setTopLeft(IntSize(0, 0));
1641         newRadii.setTopRight(IntSize(0, 0));
1642         maxRadii = std::max(newRadii.bottomLeft().height(), newRadii.bottomRight().height());
1643         if (maxRadii &gt; newRect.height()) {
1644             newRect.move(0, newRect.height() - maxRadii);
1645             newRect.setHeight(maxRadii);
1646         }
1647         break;
1648 
1649     case BSLeft:
1650         overshoot = newRadii.topLeft().height() + newRadii.bottomLeft().height() - newRect.height();
1651         if (overshoot &gt; 0) {
1652             ASSERT(!(newRadii.topLeft().height() &amp;&amp; newRadii.bottomLeft().height()));
1653             newRect.setHeight(newRect.height() + overshoot);
1654             if (!newRadii.topLeft().height())
1655                 newRect.move(0, -overshoot);
1656         }
1657         newRadii.setTopRight(IntSize(0, 0));
1658         newRadii.setBottomRight(IntSize(0, 0));
1659         maxRadii = std::max(newRadii.topLeft().width(), newRadii.bottomLeft().width());
1660         if (maxRadii &gt; newRect.width())
1661             newRect.setWidth(maxRadii);
1662         break;
1663 
1664     case BSRight:
1665         overshoot = newRadii.topRight().height() + newRadii.bottomRight().height() - newRect.height();
1666         if (overshoot &gt; 0) {
1667             ASSERT(!(newRadii.topRight().height() &amp;&amp; newRadii.bottomRight().height()));
1668             newRect.setHeight(newRect.height() + overshoot);
1669             if (!newRadii.topRight().height())
1670                 newRect.move(0, -overshoot);
1671         }
1672         newRadii.setTopLeft(IntSize(0, 0));
1673         newRadii.setBottomLeft(IntSize(0, 0));
1674         maxRadii = std::max(newRadii.topRight().width(), newRadii.bottomRight().width());
1675         if (maxRadii &gt; newRect.width()) {
1676             newRect.move(newRect.width() - maxRadii, 0);
1677             newRect.setWidth(maxRadii);
1678         }
1679         break;
1680     }
1681 
1682     return RoundedRect(newRect, newRadii);
1683 }
1684 
1685 void RenderBoxModelObject::paintOneBorderSide(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
1686     const LayoutRect&amp; sideRect, BoxSide side, BoxSide adjacentSide1, BoxSide adjacentSide2, const BorderEdge edges[], const Path* path,
1687     BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias, const Color* overrideColor)
1688 {
1689     const BorderEdge&amp; edgeToRender = edges[side];
1690     ASSERT(edgeToRender.widthForPainting());
1691     const BorderEdge&amp; adjacentEdge1 = edges[adjacentSide1];
1692     const BorderEdge&amp; adjacentEdge2 = edges[adjacentSide2];
1693 
1694     bool mitreAdjacentSide1 = joinRequiresMitre(side, adjacentSide1, edges, !antialias);
1695     bool mitreAdjacentSide2 = joinRequiresMitre(side, adjacentSide2, edges, !antialias);
1696 
1697     bool adjacentSide1StylesMatch = colorsMatchAtCorner(side, adjacentSide1, edges);
1698     bool adjacentSide2StylesMatch = colorsMatchAtCorner(side, adjacentSide2, edges);
1699 
1700     const Color&amp; colorToPaint = overrideColor ? *overrideColor : edgeToRender.color();
1701 
1702     if (path) {
1703         GraphicsContextStateSaver stateSaver(graphicsContext);
1704 
1705         clipBorderSidePolygon(graphicsContext, outerBorder, innerBorder, side, adjacentSide1StylesMatch, adjacentSide2StylesMatch);
1706 
1707         if (!innerBorder.isRenderable())
1708             graphicsContext.clipOutRoundedRect(FloatRoundedRect(calculateAdjustedInnerBorder(innerBorder, side)));
1709 
1710         float thickness = std::max(std::max(edgeToRender.widthForPainting(), adjacentEdge1.widthForPainting()), adjacentEdge2.widthForPainting());
1711         drawBoxSideFromPath(graphicsContext, outerBorder.rect(), *path, edges, edgeToRender.widthForPainting(), thickness, side, style,
1712             colorToPaint, edgeToRender.style(), bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
1713     } else {
1714         bool clipForStyle = styleRequiresClipPolygon(edgeToRender.style()) &amp;&amp; (mitreAdjacentSide1 || mitreAdjacentSide2);
1715         bool clipAdjacentSide1 = colorNeedsAntiAliasAtCorner(side, adjacentSide1, edges) &amp;&amp; mitreAdjacentSide1;
1716         bool clipAdjacentSide2 = colorNeedsAntiAliasAtCorner(side, adjacentSide2, edges) &amp;&amp; mitreAdjacentSide2;
1717         bool shouldClip = clipForStyle || clipAdjacentSide1 || clipAdjacentSide2;
1718 
1719         GraphicsContextStateSaver clipStateSaver(graphicsContext, shouldClip);
1720         if (shouldClip) {
1721             bool aliasAdjacentSide1 = clipAdjacentSide1 || (clipForStyle &amp;&amp; mitreAdjacentSide1);
1722             bool aliasAdjacentSide2 = clipAdjacentSide2 || (clipForStyle &amp;&amp; mitreAdjacentSide2);
1723             clipBorderSidePolygon(graphicsContext, outerBorder, innerBorder, side, !aliasAdjacentSide1, !aliasAdjacentSide2);
1724             // Since we clipped, no need to draw with a mitre.
1725             mitreAdjacentSide1 = false;
1726             mitreAdjacentSide2 = false;
1727         }
1728         drawLineForBoxSide(graphicsContext, sideRect, side, colorToPaint, edgeToRender.style(), mitreAdjacentSide1 ? adjacentEdge1.widthForPainting() : 0, mitreAdjacentSide2 ? adjacentEdge2.widthForPainting() : 0, antialias);
1729     }
1730 }
1731 
1732 static LayoutRect calculateSideRect(const RoundedRect&amp; outerBorder, const BorderEdge edges[], int side)
1733 {
1734     LayoutRect sideRect = outerBorder.rect();
1735     float width = edges[side].widthForPainting();
1736 
1737     if (side == BSTop)
1738         sideRect.setHeight(width);
1739     else if (side == BSBottom)
1740         sideRect.shiftYEdgeTo(sideRect.maxY() - width);
1741     else if (side == BSLeft)
1742         sideRect.setWidth(width);
1743     else
1744         sideRect.shiftXEdgeTo(sideRect.maxX() - width);
1745 
1746     return sideRect;
1747 }
1748 
1749 void RenderBoxModelObject::paintBorderSides(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
1750     const IntPoint&amp; innerBorderAdjustment, const BorderEdge edges[], BorderEdgeFlags edgeSet, BackgroundBleedAvoidance bleedAvoidance,
1751     bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias, const Color* overrideColor)
1752 {
1753     bool renderRadii = outerBorder.isRounded();
1754 
1755     Path roundedPath;
1756     if (renderRadii)
1757         roundedPath.addRoundedRect(outerBorder);
1758 
1759     // The inner border adjustment for bleed avoidance mode BackgroundBleedBackgroundOverBorder
1760     // is only applied to sideRect, which is okay since BackgroundBleedBackgroundOverBorder
1761     // is only to be used for solid borders and the shape of the border painted by drawBoxSideFromPath
1762     // only depends on sideRect when painting solid borders.
1763 
1764     if (edges[BSTop].shouldRender() &amp;&amp; includesEdge(edgeSet, BSTop)) {
1765         LayoutRect sideRect = outerBorder.rect();
1766         sideRect.setHeight(edges[BSTop].widthForPainting() + innerBorderAdjustment.y());
1767 
1768         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSTop].style()) || borderWillArcInnerEdge(innerBorder.radii().topLeft(), innerBorder.radii().topRight()));
1769         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSTop, BSLeft, BSRight, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1770     }
1771 
1772     if (edges[BSBottom].shouldRender() &amp;&amp; includesEdge(edgeSet, BSBottom)) {
1773         LayoutRect sideRect = outerBorder.rect();
1774         sideRect.shiftYEdgeTo(sideRect.maxY() - edges[BSBottom].widthForPainting() - innerBorderAdjustment.y());
1775 
1776         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSBottom].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomLeft(), innerBorder.radii().bottomRight()));
1777         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSBottom, BSLeft, BSRight, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1778     }
1779 
1780     if (edges[BSLeft].shouldRender() &amp;&amp; includesEdge(edgeSet, BSLeft)) {
1781         LayoutRect sideRect = outerBorder.rect();
1782         sideRect.setWidth(edges[BSLeft].widthForPainting() + innerBorderAdjustment.x());
1783 
1784         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSLeft].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomLeft(), innerBorder.radii().topLeft()));
1785         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSLeft, BSTop, BSBottom, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1786     }
1787 
1788     if (edges[BSRight].shouldRender() &amp;&amp; includesEdge(edgeSet, BSRight)) {
1789         LayoutRect sideRect = outerBorder.rect();
1790         sideRect.shiftXEdgeTo(sideRect.maxX() - edges[BSRight].widthForPainting() - innerBorderAdjustment.x());
1791 
1792         bool usePath = renderRadii &amp;&amp; (borderStyleHasInnerDetail(edges[BSRight].style()) || borderWillArcInnerEdge(innerBorder.radii().bottomRight(), innerBorder.radii().topRight()));
1793         paintOneBorderSide(graphicsContext, style, outerBorder, innerBorder, sideRect, BSRight, BSTop, BSBottom, edges, usePath ? &amp;roundedPath : nullptr, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, overrideColor);
1794     }
1795 }
1796 
1797 void RenderBoxModelObject::paintTranslucentBorderSides(GraphicsContext&amp; graphicsContext, const RenderStyle&amp; style, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder, const IntPoint&amp; innerBorderAdjustment,
1798     const BorderEdge edges[], BorderEdgeFlags edgesToDraw, BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge, bool antialias)
1799 {
1800     // willBeOverdrawn assumes that we draw in order: top, bottom, left, right.
1801     // This is different from BoxSide enum order.
1802     static const BoxSide paintOrder[] = { BSTop, BSBottom, BSLeft, BSRight };
1803 
1804     while (edgesToDraw) {
1805         // Find undrawn edges sharing a color.
1806         Color commonColor;
1807 
1808         BorderEdgeFlags commonColorEdgeSet = 0;
1809         for (size_t i = 0; i &lt; sizeof(paintOrder) / sizeof(paintOrder[0]); ++i) {
1810             BoxSide currSide = paintOrder[i];
1811             if (!includesEdge(edgesToDraw, currSide))
1812                 continue;
1813 
1814             bool includeEdge;
1815             if (!commonColorEdgeSet) {
1816                 commonColor = edges[currSide].color();
1817                 includeEdge = true;
1818             } else
1819                 includeEdge = edges[currSide].color() == commonColor;
1820 
1821             if (includeEdge)
1822                 commonColorEdgeSet |= edgeFlagForSide(currSide);
1823         }
1824 
1825         bool useTransparencyLayer = includesAdjacentEdges(commonColorEdgeSet) &amp;&amp; !commonColor.isOpaque();
1826         if (useTransparencyLayer) {
1827             graphicsContext.beginTransparencyLayer(commonColor.alphaAsFloat());
1828             commonColor = commonColor.opaqueColor();
1829         }
1830 
1831         paintBorderSides(graphicsContext, style, outerBorder, innerBorder, innerBorderAdjustment, edges, commonColorEdgeSet, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias, &amp;commonColor);
1832 
1833         if (useTransparencyLayer)
1834             graphicsContext.endTransparencyLayer();
1835 
1836         edgesToDraw &amp;= ~commonColorEdgeSet;
1837     }
1838 }
1839 
1840 void RenderBoxModelObject::paintBorder(const PaintInfo&amp; info, const LayoutRect&amp; rect, const RenderStyle&amp; style,
1841                                        BackgroundBleedAvoidance bleedAvoidance, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
1842 {
1843     GraphicsContext&amp; graphicsContext = info.context();
1844 
1845     if (graphicsContext.paintingDisabled())
1846         return;
1847 
1848     if (rect.isEmpty())
1849         return;
1850 
1851     auto rectToClipOut = paintRectToClipOutFromBorder(rect);
1852     bool appliedClipAlready = !rectToClipOut.isEmpty();
1853     GraphicsContextStateSaver stateSave(graphicsContext, appliedClipAlready);
1854     if (!rectToClipOut.isEmpty())
1855         graphicsContext.clipOut(snapRectToDevicePixels(rectToClipOut, document().deviceScaleFactor()));
1856 
1857     // border-image is not affected by border-radius.
1858     if (paintNinePieceImage(graphicsContext, rect, style, style.borderImage()))
1859         return;
1860 
1861     BorderEdge edges[4];
1862     BorderEdge::getBorderEdgeInfo(edges, style, document().deviceScaleFactor(), includeLogicalLeftEdge, includeLogicalRightEdge);
1863     RoundedRect outerBorder = style.getRoundedBorderFor(rect, includeLogicalLeftEdge, includeLogicalRightEdge);
1864     RoundedRect innerBorder = style.getRoundedInnerBorderFor(borderInnerRectAdjustedForBleedAvoidance(graphicsContext, rect, bleedAvoidance), includeLogicalLeftEdge, includeLogicalRightEdge);
1865 
1866     // If no borders intersects with the dirty area, we can skip the border painting.
1867     if (innerBorder.contains(info.rect))
1868         return;
1869 
1870     bool haveAlphaColor = false;
1871     bool haveAllSolidEdges = true;
1872     bool haveAllDoubleEdges = true;
1873     int numEdgesVisible = 4;
1874     bool allEdgesShareColor = true;
1875     int firstVisibleEdge = -1;
1876     BorderEdgeFlags edgesToDraw = 0;
1877 
1878     for (int i = BSTop; i &lt;= BSLeft; ++i) {
1879         const BorderEdge&amp; currEdge = edges[i];
1880 
1881         if (edges[i].shouldRender())
1882             edgesToDraw |= edgeFlagForSide(static_cast&lt;BoxSide&gt;(i));
1883 
1884         if (currEdge.presentButInvisible()) {
1885             --numEdgesVisible;
1886             allEdgesShareColor = false;
1887             continue;
1888         }
1889 
1890         if (!currEdge.widthForPainting()) {
1891             --numEdgesVisible;
1892             continue;
1893         }
1894 
1895         if (firstVisibleEdge == -1)
1896             firstVisibleEdge = i;
1897         else if (currEdge.color() != edges[firstVisibleEdge].color())
1898             allEdgesShareColor = false;
1899 
1900         if (!currEdge.color().isOpaque())
1901             haveAlphaColor = true;
1902 
1903         if (currEdge.style() != BorderStyle::Solid)
1904             haveAllSolidEdges = false;
1905 
1906         if (currEdge.style() != BorderStyle::Double)
1907             haveAllDoubleEdges = false;
1908     }
1909 
1910     // If no corner intersects the clip region, we can pretend outerBorder is
1911     // rectangular to improve performance.
1912     if (haveAllSolidEdges &amp;&amp; outerBorder.isRounded() &amp;&amp; allCornersClippedOut(outerBorder, info.rect))
1913         outerBorder.setRadii(RoundedRect::Radii());
1914 
1915     float deviceScaleFactor = document().deviceScaleFactor();
1916     // isRenderable() check avoids issue described in https://bugs.webkit.org/show_bug.cgi?id=38787
1917     if ((haveAllSolidEdges || haveAllDoubleEdges) &amp;&amp; allEdgesShareColor &amp;&amp; innerBorder.isRenderable()) {
1918         // Fast path for drawing all solid edges and all unrounded double edges
1919         if (numEdgesVisible == 4 &amp;&amp; (outerBorder.isRounded() || haveAlphaColor)
1920             &amp;&amp; (haveAllSolidEdges || (!outerBorder.isRounded() &amp;&amp; !innerBorder.isRounded()))) {
1921             Path path;
1922 
1923             FloatRoundedRect pixelSnappedOuterBorder = outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1924             if (pixelSnappedOuterBorder.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1925                 path.addRoundedRect(pixelSnappedOuterBorder);
1926             else
1927                 path.addRect(pixelSnappedOuterBorder.rect());
1928 
1929             if (haveAllDoubleEdges) {
1930                 LayoutRect innerThirdRect = outerBorder.rect();
1931                 LayoutRect outerThirdRect = outerBorder.rect();
1932                 for (int side = BSTop; side &lt;= BSLeft; ++side) {
1933                     LayoutUnit outerWidth;
1934                     LayoutUnit innerWidth;
1935                     edges[side].getDoubleBorderStripeWidths(outerWidth, innerWidth);
1936 
1937                     if (side == BSTop) {
1938                         innerThirdRect.shiftYEdgeTo(innerThirdRect.y() + innerWidth);
1939                         outerThirdRect.shiftYEdgeTo(outerThirdRect.y() + outerWidth);
1940                     } else if (side == BSBottom) {
1941                         innerThirdRect.setHeight(innerThirdRect.height() - innerWidth);
1942                         outerThirdRect.setHeight(outerThirdRect.height() - outerWidth);
1943                     } else if (side == BSLeft) {
1944                         innerThirdRect.shiftXEdgeTo(innerThirdRect.x() + innerWidth);
1945                         outerThirdRect.shiftXEdgeTo(outerThirdRect.x() + outerWidth);
1946                     } else {
1947                         innerThirdRect.setWidth(innerThirdRect.width() - innerWidth);
1948                         outerThirdRect.setWidth(outerThirdRect.width() - outerWidth);
1949                     }
1950                 }
1951 
1952                 FloatRoundedRect pixelSnappedOuterThird = outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1953                 pixelSnappedOuterThird.setRect(snapRectToDevicePixels(outerThirdRect, deviceScaleFactor));
1954 
1955                 if (pixelSnappedOuterThird.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1956                     path.addRoundedRect(pixelSnappedOuterThird);
1957                 else
1958                     path.addRect(pixelSnappedOuterThird.rect());
1959 
1960                 FloatRoundedRect pixelSnappedInnerThird = innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1961                 pixelSnappedInnerThird.setRect(snapRectToDevicePixels(innerThirdRect, deviceScaleFactor));
1962                 if (pixelSnappedInnerThird.isRounded() &amp;&amp; bleedAvoidance != BackgroundBleedUseTransparencyLayer)
1963                     path.addRoundedRect(pixelSnappedInnerThird);
1964                 else
1965                     path.addRect(pixelSnappedInnerThird.rect());
1966             }
1967 
1968             FloatRoundedRect pixelSnappedInnerBorder = innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
1969             if (pixelSnappedInnerBorder.isRounded())
1970                 path.addRoundedRect(pixelSnappedInnerBorder);
1971             else
1972                 path.addRect(pixelSnappedInnerBorder.rect());
1973 
1974             graphicsContext.setFillRule(WindRule::EvenOdd);
1975             graphicsContext.setFillColor(edges[firstVisibleEdge].color());
1976             graphicsContext.fillPath(path);
1977             return;
1978         }
1979         // Avoid creating transparent layers
1980         if (haveAllSolidEdges &amp;&amp; numEdgesVisible != 4 &amp;&amp; !outerBorder.isRounded() &amp;&amp; haveAlphaColor) {
1981             Path path;
1982 
1983             for (int i = BSTop; i &lt;= BSLeft; ++i) {
1984                 const BorderEdge&amp; currEdge = edges[i];
1985                 if (currEdge.shouldRender()) {
1986                     LayoutRect sideRect = calculateSideRect(outerBorder, edges, i);
1987                     path.addRect(sideRect);
1988                 }
1989             }
1990 
1991             graphicsContext.setFillRule(WindRule::NonZero);
1992             graphicsContext.setFillColor(edges[firstVisibleEdge].color());
1993             graphicsContext.fillPath(path);
1994             return;
1995         }
1996     }
1997 
1998     bool clipToOuterBorder = outerBorder.isRounded();
1999     GraphicsContextStateSaver stateSaver(graphicsContext, clipToOuterBorder &amp;&amp; !appliedClipAlready);
2000     if (clipToOuterBorder) {
2001         // Clip to the inner and outer radii rects.
2002         if (bleedAvoidance != BackgroundBleedUseTransparencyLayer)
2003             graphicsContext.clipRoundedRect(outerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
2004         // isRenderable() check avoids issue described in https://bugs.webkit.org/show_bug.cgi?id=38787
2005         // The inside will be clipped out later (in clipBorderSideForComplexInnerPath)
2006         if (innerBorder.isRenderable())
2007             graphicsContext.clipOutRoundedRect(innerBorder.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
2008     }
2009 
2010     // If only one edge visible antialiasing doesn&#39;t create seams
2011     bool antialias = shouldAntialiasLines(graphicsContext) || numEdgesVisible == 1;
2012     RoundedRect unadjustedInnerBorder = (bleedAvoidance == BackgroundBleedBackgroundOverBorder) ? style.getRoundedInnerBorderFor(rect, includeLogicalLeftEdge, includeLogicalRightEdge) : innerBorder;
2013     IntPoint innerBorderAdjustment(innerBorder.rect().x() - unadjustedInnerBorder.rect().x(), innerBorder.rect().y() - unadjustedInnerBorder.rect().y());
2014     if (haveAlphaColor)
2015         paintTranslucentBorderSides(graphicsContext, style, outerBorder, unadjustedInnerBorder, innerBorderAdjustment, edges, edgesToDraw, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias);
2016     else
2017         paintBorderSides(graphicsContext, style, outerBorder, unadjustedInnerBorder, innerBorderAdjustment, edges, edgesToDraw, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge, antialias);
2018 }
2019 
2020 void RenderBoxModelObject::drawBoxSideFromPath(GraphicsContext&amp; graphicsContext, const LayoutRect&amp; borderRect, const Path&amp; borderPath, const BorderEdge edges[],
2021     float thickness, float drawThickness, BoxSide side, const RenderStyle&amp; style, Color color, BorderStyle borderStyle, BackgroundBleedAvoidance bleedAvoidance,
2022     bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
2023 {
2024     if (thickness &lt;= 0)
2025         return;
2026 
2027     if (borderStyle == BorderStyle::Double &amp;&amp; thickness &lt; 3)
2028         borderStyle = BorderStyle::Solid;
2029 
2030     switch (borderStyle) {
2031     case BorderStyle::None:
2032     case BorderStyle::Hidden:
2033         return;
2034     case BorderStyle::Dotted:
2035     case BorderStyle::Dashed: {
2036         graphicsContext.setStrokeColor(color);
2037 
2038         // The stroke is doubled here because the provided path is the
2039         // outside edge of the border so half the stroke is clipped off.
2040         // The extra multiplier is so that the clipping mask can antialias
2041         // the edges to prevent jaggies.
2042         graphicsContext.setStrokeThickness(drawThickness * 2 * 1.1f);
2043         graphicsContext.setStrokeStyle(borderStyle == BorderStyle::Dashed ? DashedStroke : DottedStroke);
2044 
2045         // If the number of dashes that fit in the path is odd and non-integral then we
2046         // will have an awkwardly-sized dash at the end of the path. To try to avoid that
2047         // here, we simply make the whitespace dashes ever so slightly bigger.
2048         // FIXME: This could be even better if we tried to manipulate the dash offset
2049         // and possibly the gapLength to get the corners dash-symmetrical.
2050         float dashLength = thickness * ((borderStyle == BorderStyle::Dashed) ? 3.0f : 1.0f);
2051         float gapLength = dashLength;
2052         float numberOfDashes = borderPath.length() / dashLength;
2053         // Don&#39;t try to show dashes if we have less than 2 dashes + 2 gaps.
2054         // FIXME: should do this test per side.
2055         if (numberOfDashes &gt;= 4) {
2056             bool evenNumberOfFullDashes = !((int)numberOfDashes % 2);
2057             bool integralNumberOfDashes = !(numberOfDashes - (int)numberOfDashes);
2058             if (!evenNumberOfFullDashes &amp;&amp; !integralNumberOfDashes) {
2059                 float numberOfGaps = numberOfDashes / 2;
2060                 gapLength += (dashLength  / numberOfGaps);
2061             }
2062 
2063             DashArray lineDash;
2064             lineDash.append(dashLength);
2065             lineDash.append(gapLength);
2066             graphicsContext.setLineDash(lineDash, dashLength);
2067         }
2068 
2069         // FIXME: stroking the border path causes issues with tight corners:
2070         // https://bugs.webkit.org/show_bug.cgi?id=58711
2071         // Also, to get the best appearance we should stroke a path between the two borders.
2072         graphicsContext.strokePath(borderPath);
2073         return;
2074     }
2075     case BorderStyle::Double: {
2076         // Get the inner border rects for both the outer border line and the inner border line
2077         LayoutUnit outerBorderTopWidth;
2078         LayoutUnit innerBorderTopWidth;
2079         edges[BSTop].getDoubleBorderStripeWidths(outerBorderTopWidth, innerBorderTopWidth);
2080 
2081         LayoutUnit outerBorderRightWidth;
2082         LayoutUnit innerBorderRightWidth;
2083         edges[BSRight].getDoubleBorderStripeWidths(outerBorderRightWidth, innerBorderRightWidth);
2084 
2085         LayoutUnit outerBorderBottomWidth;
2086         LayoutUnit innerBorderBottomWidth;
2087         edges[BSBottom].getDoubleBorderStripeWidths(outerBorderBottomWidth, innerBorderBottomWidth);
2088 
2089         LayoutUnit outerBorderLeftWidth;
2090         LayoutUnit innerBorderLeftWidth;
2091         edges[BSLeft].getDoubleBorderStripeWidths(outerBorderLeftWidth, innerBorderLeftWidth);
2092 
2093         // Draw inner border line
2094         {
2095             GraphicsContextStateSaver stateSaver(graphicsContext);
2096             RoundedRect innerClip = style.getRoundedInnerBorderFor(borderRect,
2097                 innerBorderTopWidth, innerBorderBottomWidth, innerBorderLeftWidth, innerBorderRightWidth,
2098                 includeLogicalLeftEdge, includeLogicalRightEdge);
2099 
2100             graphicsContext.clipRoundedRect(FloatRoundedRect(innerClip));
2101             drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, BorderStyle::Solid, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2102         }
2103 
2104         // Draw outer border line
2105         {
2106             GraphicsContextStateSaver stateSaver(graphicsContext);
2107             LayoutRect outerRect = borderRect;
2108             if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
2109                 outerRect.inflate(1);
2110                 ++outerBorderTopWidth;
2111                 ++outerBorderBottomWidth;
2112                 ++outerBorderLeftWidth;
2113                 ++outerBorderRightWidth;
2114             }
2115 
2116             RoundedRect outerClip = style.getRoundedInnerBorderFor(outerRect,
2117                 outerBorderTopWidth, outerBorderBottomWidth, outerBorderLeftWidth, outerBorderRightWidth,
2118                 includeLogicalLeftEdge, includeLogicalRightEdge);
2119             graphicsContext.clipOutRoundedRect(FloatRoundedRect(outerClip));
2120             drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, BorderStyle::Solid, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2121         }
2122         return;
2123     }
2124     case BorderStyle::Ridge:
2125     case BorderStyle::Groove:
2126     {
2127         BorderStyle s1;
2128         BorderStyle s2;
2129         if (borderStyle == BorderStyle::Groove) {
2130             s1 = BorderStyle::Inset;
2131             s2 = BorderStyle::Outset;
2132         } else {
2133             s1 = BorderStyle::Outset;
2134             s2 = BorderStyle::Inset;
2135         }
2136 
2137         // Paint full border
2138         drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, s1, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2139 
2140         // Paint inner only
2141         GraphicsContextStateSaver stateSaver(graphicsContext);
2142         LayoutUnit topWidth = edges[BSTop].widthForPainting() / 2;
2143         LayoutUnit bottomWidth = edges[BSBottom].widthForPainting() / 2;
2144         LayoutUnit leftWidth = edges[BSLeft].widthForPainting() / 2;
2145         LayoutUnit rightWidth = edges[BSRight].widthForPainting() / 2;
2146 
2147         RoundedRect clipRect = style.getRoundedInnerBorderFor(borderRect,
2148             topWidth, bottomWidth, leftWidth, rightWidth,
2149             includeLogicalLeftEdge, includeLogicalRightEdge);
2150 
2151         graphicsContext.clipRoundedRect(FloatRoundedRect(clipRect));
2152         drawBoxSideFromPath(graphicsContext, borderRect, borderPath, edges, thickness, drawThickness, side, style, color, s2, bleedAvoidance, includeLogicalLeftEdge, includeLogicalRightEdge);
2153         return;
2154     }
2155     case BorderStyle::Inset:
2156     case BorderStyle::Outset:
2157         calculateBorderStyleColor(borderStyle, side, color);
2158         break;
2159     default:
2160         break;
2161     }
2162 
2163     graphicsContext.setStrokeStyle(NoStroke);
2164     graphicsContext.setFillColor(color);
2165     graphicsContext.drawRect(snapRectToDevicePixels(borderRect, document().deviceScaleFactor()));
2166 }
2167 
2168 void RenderBoxModelObject::clipBorderSidePolygon(GraphicsContext&amp; graphicsContext, const RoundedRect&amp; outerBorder, const RoundedRect&amp; innerBorder,
2169                                                  BoxSide side, bool firstEdgeMatches, bool secondEdgeMatches)
2170 {
2171     float deviceScaleFactor = document().deviceScaleFactor();
2172     const FloatRect&amp; outerRect = snapRectToDevicePixels(outerBorder.rect(), deviceScaleFactor);
2173     const FloatRect&amp; innerRect = snapRectToDevicePixels(innerBorder.rect(), deviceScaleFactor);
2174 
2175     // For each side, create a quad that encompasses all parts of that side that may draw,
2176     // including areas inside the innerBorder.
2177     //
2178     //         0----------------3
2179     //       0  \              /  0
2180     //       |\  1----------- 2  /|
2181     //       | 1                1 |
2182     //       | |                | |
2183     //       | |                | |
2184     //       | 2                2 |
2185     //       |/  1------------2  \|
2186     //       3  /              \  3
2187     //         0----------------3
2188     //
2189     Vector&lt;FloatPoint&gt; quad;
2190     quad.reserveInitialCapacity(4);
2191     switch (side) {
2192     case BSTop:
2193         quad.uncheckedAppend(outerRect.minXMinYCorner());
2194         quad.uncheckedAppend(innerRect.minXMinYCorner());
2195         quad.uncheckedAppend(innerRect.maxXMinYCorner());
2196         quad.uncheckedAppend(outerRect.maxXMinYCorner());
2197 
2198         if (!innerBorder.radii().topLeft().isZero())
2199             findIntersection(outerRect.minXMinYCorner(), innerRect.minXMinYCorner(), innerRect.minXMaxYCorner(), innerRect.maxXMinYCorner(), quad[1]);
2200 
2201         if (!innerBorder.radii().topRight().isZero())
2202             findIntersection(outerRect.maxXMinYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[2]);
2203         break;
2204 
2205     case BSLeft:
2206         quad.uncheckedAppend(outerRect.minXMinYCorner());
2207         quad.uncheckedAppend(innerRect.minXMinYCorner());
2208         quad.uncheckedAppend(innerRect.minXMaxYCorner());
2209         quad.uncheckedAppend(outerRect.minXMaxYCorner());
2210 
2211         if (!innerBorder.radii().topLeft().isZero())
2212             findIntersection(outerRect.minXMinYCorner(), innerRect.minXMinYCorner(), innerRect.minXMaxYCorner(), innerRect.maxXMinYCorner(), quad[1]);
2213 
2214         if (!innerBorder.radii().bottomLeft().isZero())
2215             findIntersection(outerRect.minXMaxYCorner(), innerRect.minXMaxYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[2]);
2216         break;
2217 
2218     case BSBottom:
2219         quad.uncheckedAppend(outerRect.minXMaxYCorner());
2220         quad.uncheckedAppend(innerRect.minXMaxYCorner());
2221         quad.uncheckedAppend(innerRect.maxXMaxYCorner());
2222         quad.uncheckedAppend(outerRect.maxXMaxYCorner());
2223 
2224         if (!innerBorder.radii().bottomLeft().isZero())
2225             findIntersection(outerRect.minXMaxYCorner(), innerRect.minXMaxYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[1]);
2226 
2227         if (!innerBorder.radii().bottomRight().isZero())
2228             findIntersection(outerRect.maxXMaxYCorner(), innerRect.maxXMaxYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMaxYCorner(), quad[2]);
2229         break;
2230 
2231     case BSRight:
2232         quad.uncheckedAppend(outerRect.maxXMinYCorner());
2233         quad.uncheckedAppend(innerRect.maxXMinYCorner());
2234         quad.uncheckedAppend(innerRect.maxXMaxYCorner());
2235         quad.uncheckedAppend(outerRect.maxXMaxYCorner());
2236 
2237         if (!innerBorder.radii().topRight().isZero())
2238             findIntersection(outerRect.maxXMinYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMinYCorner(), innerRect.maxXMaxYCorner(), quad[1]);
2239 
2240         if (!innerBorder.radii().bottomRight().isZero())
2241             findIntersection(outerRect.maxXMaxYCorner(), innerRect.maxXMaxYCorner(), innerRect.maxXMinYCorner(), innerRect.minXMaxYCorner(), quad[2]);
2242         break;
2243     }
2244 
2245     // If the border matches both of its adjacent sides, don&#39;t anti-alias the clip, and
2246     // if neither side matches, anti-alias the clip.
2247     if (firstEdgeMatches == secondEdgeMatches) {
2248         bool wasAntialiased = graphicsContext.shouldAntialias();
2249         graphicsContext.setShouldAntialias(!firstEdgeMatches);
2250         graphicsContext.clipPath(Path::polygonPathFromPoints(quad), WindRule::NonZero);
2251         graphicsContext.setShouldAntialias(wasAntialiased);
2252         return;
2253     }
2254 
2255     // Square off the end which shouldn&#39;t be affected by antialiasing, and clip.
2256     Vector&lt;FloatPoint&gt; firstQuad = {
2257         quad[0],
2258         quad[1],
2259         quad[2],
2260         side == BSTop || side == BSBottom ? FloatPoint(quad[3].x(), quad[2].y()) : FloatPoint(quad[2].x(), quad[3].y()),
2261         quad[3]
2262     };
2263     bool wasAntialiased = graphicsContext.shouldAntialias();
2264     graphicsContext.setShouldAntialias(!firstEdgeMatches);
2265     graphicsContext.clipPath(Path::polygonPathFromPoints(firstQuad), WindRule::NonZero);
2266 
2267     Vector&lt;FloatPoint&gt; secondQuad = {
2268         quad[0],
2269         side == BSTop || side == BSBottom ? FloatPoint(quad[0].x(), quad[1].y()) : FloatPoint(quad[1].x(), quad[0].y()),
2270         quad[1],
2271         quad[2],
2272         quad[3]
2273     };
2274     // Antialiasing affects the second side.
2275     graphicsContext.setShouldAntialias(!secondEdgeMatches);
2276     graphicsContext.clipPath(Path::polygonPathFromPoints(secondQuad), WindRule::NonZero);
2277 
2278     graphicsContext.setShouldAntialias(wasAntialiased);
2279 }
2280 
2281 bool RenderBoxModelObject::borderObscuresBackgroundEdge(const FloatSize&amp; contextScale) const
2282 {
2283     BorderEdge edges[4];
2284     BorderEdge::getBorderEdgeInfo(edges, style(), document().deviceScaleFactor());
2285 
2286     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2287         const BorderEdge&amp; currEdge = edges[i];
2288         // FIXME: for vertical text
2289         float axisScale = (i == BSTop || i == BSBottom) ? contextScale.height() : contextScale.width();
2290         if (!currEdge.obscuresBackgroundEdge(axisScale))
2291             return false;
2292     }
2293 
2294     return true;
2295 }
2296 
2297 bool RenderBoxModelObject::borderObscuresBackground() const
2298 {
2299     if (!style().hasBorder())
2300         return false;
2301 
2302     // Bail if we have any border-image for now. We could look at the image alpha to improve this.
2303     if (style().borderImage().image())
2304         return false;
2305 
2306     BorderEdge edges[4];
2307     BorderEdge::getBorderEdgeInfo(edges, style(), document().deviceScaleFactor());
2308 
2309     for (int i = BSTop; i &lt;= BSLeft; ++i) {
2310         const BorderEdge&amp; currEdge = edges[i];
2311         if (!currEdge.obscuresBackground())
2312             return false;
2313     }
2314 
2315     return true;
2316 }
2317 
2318 bool RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp;, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox* inlineFlowBox) const
2319 {
2320     if (bleedAvoidance != BackgroundBleedNone)
2321         return false;
2322 
2323     if (style().hasAppearance())
2324         return false;
2325 
2326     bool hasOneNormalBoxShadow = false;
2327     for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
2328         if (currentShadow-&gt;style() != Normal)
2329             continue;
2330 
2331         if (hasOneNormalBoxShadow)
2332             return false;
2333         hasOneNormalBoxShadow = true;
2334 
2335         if (currentShadow-&gt;spread())
2336             return false;
2337     }
2338 
2339     if (!hasOneNormalBoxShadow)
2340         return false;
2341 
2342     Color backgroundColor = style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
2343     if (!backgroundColor.isOpaque())
2344         return false;
2345 
2346     auto* lastBackgroundLayer = &amp;style().backgroundLayers();
2347     while (auto* next = lastBackgroundLayer-&gt;next())
2348         lastBackgroundLayer = next;
2349 
2350     if (lastBackgroundLayer-&gt;clip() != FillBox::Border)
2351         return false;
2352 
2353     if (lastBackgroundLayer-&gt;image() &amp;&amp; style().hasBorderRadius())
2354         return false;
2355 
2356     if (inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;boxShadowCanBeAppliedToBackground(*lastBackgroundLayer))
2357         return false;
2358 
2359     if (hasOverflowClip() &amp;&amp; lastBackgroundLayer-&gt;attachment() == FillAttachment::LocalBackground)
2360         return false;
2361 
2362     return true;
2363 }
2364 
2365 static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, int shadowExtent, int shadowSpread, const IntSize&amp; shadowOffset)
2366 {
2367     LayoutRect bounds(holeRect);
2368 
2369     bounds.inflate(shadowExtent);
2370 
2371     if (shadowSpread &lt; 0)
2372         bounds.inflate(-shadowSpread);
2373 
2374     LayoutRect offsetBounds = bounds;
2375     offsetBounds.move(-shadowOffset);
2376     return unionRect(bounds, offsetBounds);
2377 }
2378 
2379 void RenderBoxModelObject::paintBoxShadow(const PaintInfo&amp; info, const LayoutRect&amp; paintRect, const RenderStyle&amp; style, ShadowStyle shadowStyle, bool includeLogicalLeftEdge, bool includeLogicalRightEdge)
2380 {
2381     // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
2382     GraphicsContext&amp; context = info.context();
2383     if (context.paintingDisabled() || !style.boxShadow())
2384         return;
2385 
2386     RoundedRect border = (shadowStyle == Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)
2387         : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
2388 
2389     bool hasBorderRadius = style.hasBorderRadius();
2390     bool isHorizontal = style.isHorizontalWritingMode();
2391     float deviceScaleFactor = document().deviceScaleFactor();
2392 
2393     bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
2394     for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
2395         if (shadow-&gt;style() != shadowStyle)
2396             continue;
2397 
2398         // FIXME: Add subpixel support for the shadow values. Soon after the shadow offset becomes fractional,
2399         // all the early snappings here need to be pushed to the actual painting operations.
2400         IntSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());
2401         int shadowRadius = shadow-&gt;radius();
2402         int shadowPaintingExtent = shadow-&gt;paintingExtent();
2403         int shadowSpread = shadow-&gt;spread();
2404 
2405         if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
2406             continue;
2407 
2408         Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
2409 
2410         if (shadow-&gt;style() == Normal) {
2411             RoundedRect fillRect = border;
2412             fillRect.inflate(shadowSpread);
2413             if (fillRect.isEmpty())
2414                 continue;
2415 
2416             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(border.rect(), deviceScaleFactor);
2417             pixelSnappedShadowRect.inflate(shadowPaintingExtent + shadowSpread);
2418             pixelSnappedShadowRect.move(shadowOffset);
2419 
2420             GraphicsContextStateSaver stateSaver(context);
2421             context.clip(pixelSnappedShadowRect);
2422 
2423             // Move the fill just outside the clip, adding 1 pixel separation so that the fill does not
2424             // bleed in (due to antialiasing) if the context is transformed.
2425             IntSize extraOffset(roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + 1, 0);
2426             shadowOffset -= extraOffset;
2427             fillRect.move(extraOffset);
2428 
2429             if (shadow-&gt;isWebkitBoxShadow())
2430                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
2431             else
2432                 context.setShadow(shadowOffset, shadowRadius, shadowColor);
2433 
2434             FloatRoundedRect rectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
2435             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
2436             if (hasBorderRadius) {
2437                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2438                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2439                 // corners. Those are avoided by insetting the clipping path by one pixel.
2440                 if (hasOpaqueBackground)
2441                     rectToClipOut.inflateWithRadii(-1.0f);
2442 
2443                 if (!rectToClipOut.isEmpty())
2444                     context.clipOutRoundedRect(rectToClipOut);
2445 
2446                 RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
2447                 influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
2448 
2449                 if (allCornersClippedOut(influenceRect, info.rect))
2450                     context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2451                 else {
2452                     pixelSnappedFillRect.expandRadii(shadowSpread);
2453                     if (!pixelSnappedFillRect.isRenderable())
2454                         pixelSnappedFillRect.adjustRadii();
2455                     context.fillRoundedRect(pixelSnappedFillRect, Color::black);
2456                 }
2457             } else {
2458                 // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
2459                 // when painting the shadow. On the other hand, it introduces subpixel gaps along the
2460                 // edges if they are not pixel-aligned. Those are avoided by insetting the clipping path
2461                 // by one pixel.
2462                 if (hasOpaqueBackground) {
2463                     // FIXME: The function to decide on the policy based on the transform should be a named function.
2464                     // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
2465                     AffineTransform transform = context.getCTM();
2466                     if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
2467                         rectToClipOut.inflate(-1.0f);
2468                 }
2469 
2470                 if (!rectToClipOut.isEmpty())
2471                     context.clipOut(rectToClipOut.rect());
2472                 context.fillRect(pixelSnappedFillRect.rect(), Color::black);
2473             }
2474         } else {
2475             // Inset shadow.
2476             FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
2477             FloatRect pixelSnappedHoleRect = pixelSnappedBorderRect.rect();
2478             pixelSnappedHoleRect.inflate(-shadowSpread);
2479 
2480             if (pixelSnappedHoleRect.isEmpty()) {
2481                 if (hasBorderRadius)
2482                     context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
2483                 else
2484                     context.fillRect(pixelSnappedBorderRect.rect(), shadowColor);
2485                 continue;
2486             }
2487 
2488             if (!includeLogicalLeftEdge) {
2489                 if (isHorizontal) {
2490                     pixelSnappedHoleRect.move(-std::max(shadowOffset.width(), 0) - shadowPaintingExtent, 0);
2491                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() + std::max(shadowOffset.width(), 0) + shadowPaintingExtent);
2492                 } else {
2493                     pixelSnappedHoleRect.move(0, -std::max(shadowOffset.height(), 0) - shadowPaintingExtent);
2494                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() + std::max(shadowOffset.height(), 0) + shadowPaintingExtent);
2495                 }
2496             }
2497             if (!includeLogicalRightEdge) {
2498                 if (isHorizontal)
2499                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() - std::min(shadowOffset.width(), 0) + shadowPaintingExtent);
2500                 else
2501                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() - std::min(shadowOffset.height(), 0) + shadowPaintingExtent);
2502             }
2503 
2504             Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
2505 
2506             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(areaCastingShadowInHole(LayoutRect(pixelSnappedBorderRect.rect()), shadowPaintingExtent, shadowSpread, shadowOffset), deviceScaleFactor);
2507             FloatRoundedRect pixelSnappedRoundedHole = FloatRoundedRect(pixelSnappedHoleRect, pixelSnappedBorderRect.radii());
2508 
2509             GraphicsContextStateSaver stateSaver(context);
2510             if (hasBorderRadius) {
2511                 context.clipRoundedRect(pixelSnappedBorderRect);
2512                 pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
2513             } else
2514                 context.clip(pixelSnappedBorderRect.rect());
2515 
2516             IntSize extraOffset(2 * roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent - 2 * shadowSpread + 1, 0);
2517             context.translate(extraOffset);
2518             shadowOffset -= extraOffset;
2519 
2520             if (shadow-&gt;isWebkitBoxShadow())
2521                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
2522             else
2523                 context.setShadow(shadowOffset, shadowRadius, shadowColor);
2524 
2525             context.fillRectWithRoundedHole(enclosingIntRect(pixelSnappedOuterRect), pixelSnappedRoundedHole, fillColor); // todo tav IntRect is required as first param
2526         }
2527     }
2528 }
2529 
2530 LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
2531 {
2532     if (auto* containingBlock = this-&gt;containingBlock())
2533         return containingBlock-&gt;availableLogicalWidth();
2534     return { };
2535 }
2536 
2537 RenderBoxModelObject* RenderBoxModelObject::continuation() const
2538 {
2539     if (!hasContinuationChainNode())
2540         return nullptr;
2541 
2542     auto&amp; continuationChainNode = *continuationChainNodeMap().get(this);
2543     if (!continuationChainNode.next)
2544         return nullptr;
2545     return continuationChainNode.next-&gt;renderer.get();
2546 }
2547 
2548 RenderInline* RenderBoxModelObject::inlineContinuation() const
2549 {
2550     if (!hasContinuationChainNode())
2551         return nullptr;
2552 
2553     for (auto* next = continuationChainNodeMap().get(this)-&gt;next; next; next = next-&gt;next) {
2554         if (is&lt;RenderInline&gt;(*next-&gt;renderer))
2555             return downcast&lt;RenderInline&gt;(next-&gt;renderer.get());
2556     }
2557     return nullptr;
2558 }
2559 
2560 RenderBoxModelObject::ContinuationChainNode* RenderBoxModelObject::continuationChainNode() const
2561 {
2562     return continuationChainNodeMap().get(this);
2563 }
2564 
2565 void RenderBoxModelObject::insertIntoContinuationChainAfter(RenderBoxModelObject&amp; afterRenderer)
2566 {
2567     ASSERT(isContinuation());
2568     ASSERT(!continuationChainNodeMap().contains(this));
2569 
2570     auto&amp; after = afterRenderer.ensureContinuationChainNode();
2571     ensureContinuationChainNode().insertAfter(after);
2572 }
2573 
2574 void RenderBoxModelObject::removeFromContinuationChain()
2575 {
2576     ASSERT(hasContinuationChainNode());
2577     ASSERT(continuationChainNodeMap().contains(this));
2578     setHasContinuationChainNode(false);
2579     continuationChainNodeMap().remove(this);
2580 }
2581 
2582 auto RenderBoxModelObject::ensureContinuationChainNode() -&gt; ContinuationChainNode&amp;
2583 {
2584     setHasContinuationChainNode(true);
2585     return *continuationChainNodeMap().ensure(this, [&amp;] {
2586         return std::make_unique&lt;ContinuationChainNode&gt;(*this);
2587     }).iterator-&gt;value;
2588 }
2589 
2590 RenderTextFragment* RenderBoxModelObject::firstLetterRemainingText() const
2591 {
2592     if (!isFirstLetter())
2593         return nullptr;
2594     return firstLetterRemainingTextMap().get(this).get();
2595 }
2596 
2597 void RenderBoxModelObject::setFirstLetterRemainingText(RenderTextFragment&amp; remainingText)
2598 {
2599     ASSERT(isFirstLetter());
2600     firstLetterRemainingTextMap().set(this, makeWeakPtr(remainingText));
2601 }
2602 
2603 void RenderBoxModelObject::clearFirstLetterRemainingText()
2604 {
2605     ASSERT(isFirstLetter());
2606     firstLetterRemainingTextMap().remove(this);
2607 }
2608 
2609 LayoutRect RenderBoxModelObject::localCaretRectForEmptyElement(LayoutUnit width, LayoutUnit textIndentOffset)
2610 {
2611     ASSERT(!firstChild());
2612 
2613     // FIXME: This does not take into account either :first-line or :first-letter
2614     // However, as soon as some content is entered, the line boxes will be
2615     // constructed and this kludge is not called any more. So only the caret size
2616     // of an empty :first-line&#39;d block is wrong. I think we can live with that.
2617     const RenderStyle&amp; currentStyle = firstLineStyle();
2618     LayoutUnit height = lineHeight(true, currentStyle.isHorizontalWritingMode() ? HorizontalLine : VerticalLine);
2619 
2620     enum CaretAlignment { alignLeft, alignRight, alignCenter };
2621 
2622     CaretAlignment alignment = alignLeft;
2623 
2624     switch (currentStyle.textAlign()) {
2625     case TextAlignMode::Left:
2626     case TextAlignMode::WebKitLeft:
2627         break;
2628     case TextAlignMode::Center:
2629     case TextAlignMode::WebKitCenter:
2630         alignment = alignCenter;
2631         break;
2632     case TextAlignMode::Right:
2633     case TextAlignMode::WebKitRight:
2634         alignment = alignRight;
2635         break;
2636     case TextAlignMode::Justify:
2637     case TextAlignMode::Start:
2638         if (!currentStyle.isLeftToRightDirection())
2639             alignment = alignRight;
2640         break;
2641     case TextAlignMode::End:
2642         if (currentStyle.isLeftToRightDirection())
2643             alignment = alignRight;
2644         break;
2645     }
2646 
2647     LayoutUnit x = borderLeft() + paddingLeft();
2648     LayoutUnit maxX = width - borderRight() - paddingRight();
2649 
2650     switch (alignment) {
2651     case alignLeft:
2652         if (currentStyle.isLeftToRightDirection())
2653             x += textIndentOffset;
2654         break;
2655     case alignCenter:
2656         x = (x + maxX) / 2;
2657         if (currentStyle.isLeftToRightDirection())
2658             x += textIndentOffset / 2;
2659         else
2660             x -= textIndentOffset / 2;
2661         break;
2662     case alignRight:
2663         x = maxX - caretWidth;
2664         if (!currentStyle.isLeftToRightDirection())
2665             x -= textIndentOffset;
2666         break;
2667     }
2668     x = std::min(x, std::max&lt;LayoutUnit&gt;(maxX - caretWidth, 0));
2669 
2670     LayoutUnit y = paddingTop() + borderTop();
2671 
2672     return currentStyle.isHorizontalWritingMode() ? LayoutRect(x, y, caretWidth, height) : LayoutRect(y, x, height, caretWidth);
2673 }
2674 
2675 bool RenderBoxModelObject::shouldAntialiasLines(GraphicsContext&amp; context)
2676 {
2677     // FIXME: We may want to not antialias when scaled by an integral value,
2678     // and we may want to antialias when translated by a non-integral value.
2679     return !context.getCTM().isIdentityOrTranslationOrFlipped();
2680 }
2681 
2682 void RenderBoxModelObject::mapAbsoluteToLocalPoint(MapCoordinatesFlags mode, TransformState&amp; transformState) const
2683 {
2684     RenderElement* container = this-&gt;container();
2685     if (!container)
2686         return;
2687 
2688     // FIXME: This code is wrong for named flow threads since it only works for content in the first region.
2689     // We also don&#39;t want to run it for multicolumn flow threads, since we can use our knowledge of column
2690     // geometry to actually get a better result.
2691     // The point inside a box that&#39;s inside a region has its coordinates relative to the region,
2692     // not the FragmentedFlow that is its container in the RenderObject tree.
2693     if (is&lt;RenderBox&gt;(*this) &amp;&amp; container-&gt;isOutOfFlowRenderFragmentedFlow()) {
2694         RenderFragmentContainer* startFragment = nullptr;
2695         RenderFragmentContainer* endFragment = nullptr;
2696         if (downcast&lt;RenderFragmentedFlow&gt;(*container).getFragmentRangeForBox(downcast&lt;RenderBox&gt;(this), startFragment, endFragment))
2697             container = startFragment;
2698     }
2699 
2700     container-&gt;mapAbsoluteToLocalPoint(mode, transformState);
2701 
2702     LayoutSize containerOffset = offsetFromContainer(*container, LayoutPoint());
2703 
2704     bool preserve3D = mode &amp; UseTransforms &amp;&amp; (container-&gt;style().preserves3D() || style().preserves3D());
2705     if (mode &amp; UseTransforms &amp;&amp; shouldUseTransformFromContainer(container)) {
2706         TransformationMatrix t;
2707         getTransformFromContainer(container, containerOffset, t);
2708         transformState.applyTransform(t, preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2709     } else
2710         transformState.move(containerOffset.width(), containerOffset.height(), preserve3D ? TransformState::AccumulateTransform : TransformState::FlattenTransform);
2711 }
2712 
2713 bool RenderBoxModelObject::hasRunningAcceleratedAnimations() const
2714 {
2715     if (auto* node = element()) {
2716         if (auto* timeline = node-&gt;document().existingTimeline())
2717             return timeline-&gt;runningAnimationsForElementAreAllAccelerated(*node);
2718     }
2719     return false;
2720 }
2721 
2722 } // namespace WebCore
    </pre>
  </body>
</html>