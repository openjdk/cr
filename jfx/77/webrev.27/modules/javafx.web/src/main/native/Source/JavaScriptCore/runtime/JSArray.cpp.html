<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;JSArray.h&quot;
  25 
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CodeBlock.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;GetterSetter.h&quot;
  31 #include &quot;IndexingHeaderInlines.h&quot;
  32 #include &quot;JSArrayInlines.h&quot;
  33 #include &quot;JSCInlines.h&quot;
  34 #include &quot;PropertyNameArray.h&quot;
  35 #include &quot;TypeError.h&quot;
  36 #include &lt;wtf/Assertions.h&gt;
  37 
  38 namespace JSC {
  39 
  40 const ASCIILiteral LengthExceededTheMaximumArrayLengthError { &quot;Length exceeded the maximum array length&quot;_s };
  41 
  42 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSArray);
  43 
  44 const ClassInfo JSArray::s_info = {&quot;Array&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArray)};
  45 
  46 JSArray* JSArray::tryCreateUninitializedRestricted(ObjectInitializationScope&amp; scope, GCDeferralContext* deferralContext, Structure* structure, unsigned initialLength)
  47 {
  48     VM&amp; vm = scope.vm();
  49 
  50     if (UNLIKELY(initialLength &gt; MAX_STORAGE_VECTOR_LENGTH))
  51         return nullptr;
  52 
  53     unsigned outOfLineStorage = structure-&gt;outOfLineCapacity();
  54     Butterfly* butterfly;
  55     IndexingType indexingType = structure-&gt;indexingType();
  56     if (LIKELY(!hasAnyArrayStorage(indexingType))) {
  57         ASSERT(
  58             hasUndecided(indexingType)
  59             || hasInt32(indexingType)
  60             || hasDouble(indexingType)
  61             || hasContiguous(indexingType));
  62 
  63         unsigned vectorLength = Butterfly::optimalContiguousVectorLength(structure, initialLength);
  64         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  65             vm,
  66             Butterfly::totalSize(0, outOfLineStorage, true, vectorLength * sizeof(EncodedJSValue)),
  67             deferralContext, AllocationFailureMode::ReturnNull);
  68         if (UNLIKELY(!temp))
  69             return nullptr;
  70         butterfly = Butterfly::fromBase(temp, 0, outOfLineStorage);
  71         butterfly-&gt;setVectorLength(vectorLength);
  72         butterfly-&gt;setPublicLength(initialLength);
  73         if (hasDouble(indexingType)) {
  74             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  75                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
  76         } else {
  77             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  78                 butterfly-&gt;contiguous().atUnsafe(i).clear();
  79         }
  80     } else {
  81         ASSERT(
  82             indexingType == ArrayWithSlowPutArrayStorage
  83             || indexingType == ArrayWithArrayStorage);
  84         static const unsigned indexBias = 0;
  85         unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
  86         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  87             vm,
  88             Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
  89             deferralContext, AllocationFailureMode::ReturnNull);
  90         if (UNLIKELY(!temp))
  91             return nullptr;
  92         butterfly = Butterfly::fromBase(temp, indexBias, outOfLineStorage);
  93         *butterfly-&gt;indexingHeader() = indexingHeaderForArrayStorage(initialLength, vectorLength);
  94         ArrayStorage* storage = butterfly-&gt;arrayStorage();
  95         storage-&gt;m_indexBias = indexBias;
  96         storage-&gt;m_sparseMap.clear();
  97         storage-&gt;m_numValuesInVector = initialLength;
  98         for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  99             storage-&gt;m_vector[i].clear();
 100     }
 101 
 102     JSArray* result = createWithButterfly(vm, deferralContext, structure, butterfly);
 103 
 104     const bool createUninitialized = true;
 105     scope.notifyAllocated(result, createUninitialized);
 106     return result;
 107 }
 108 
 109 void JSArray::eagerlyInitializeButterfly(ObjectInitializationScope&amp; scope, JSArray* array, unsigned initialLength)
 110 {
 111     Structure* structure = array-&gt;structure(scope.vm());
 112     IndexingType indexingType = structure-&gt;indexingType();
 113     Butterfly* butterfly = array-&gt;butterfly();
 114 
 115     // This function only serves as a companion to tryCreateUninitializedRestricted()
 116     // in the event that we really can&#39;t defer initialization of the butterfly after all.
 117     // tryCreateUninitializedRestricted() already initialized the elements between
 118     // initialLength and vector length. We just need to do 0 - initialLength.
 119     // ObjectInitializationScope::notifyInitialized() will verify that all elements are
 120     // initialized.
 121     if (LIKELY(!hasAnyArrayStorage(indexingType))) {
 122         if (hasDouble(indexingType)) {
 123             for (unsigned i = 0; i &lt; initialLength; ++i)
 124                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
 125         } else {
 126             for (unsigned i = 0; i &lt; initialLength; ++i)
 127                 butterfly-&gt;contiguous().atUnsafe(i).clear();
 128         }
 129     } else {
 130         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 131         for (unsigned i = 0; i &lt; initialLength; ++i)
 132             storage-&gt;m_vector[i].clear();
 133     }
 134     scope.notifyInitialized(array);
 135 }
 136 
 137 void JSArray::setLengthWritable(ExecState* exec, bool writable)
 138 {
 139     ASSERT(isLengthWritable() || !writable);
 140     if (!isLengthWritable() || writable)
 141         return;
 142 
 143     enterDictionaryIndexingMode(exec-&gt;vm());
 144 
 145     SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
 146     ASSERT(map);
 147     map-&gt;setLengthIsReadOnly();
 148 }
 149 
 150 // Defined in ES5.1 15.4.5.1
 151 bool JSArray::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)
 152 {
 153     VM&amp; vm = exec-&gt;vm();
 154     auto scope = DECLARE_THROW_SCOPE(vm);
 155 
 156     JSArray* array = jsCast&lt;JSArray*&gt;(object);
 157 
 158     // 3. If P is &quot;length&quot;, then
 159     if (propertyName == vm.propertyNames-&gt;length) {
 160         // All paths through length definition call the default [[DefineOwnProperty]], hence:
 161         // from ES5.1 8.12.9 7.a.
 162         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
 163             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
 164         // from ES5.1 8.12.9 7.b.
 165         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
 166             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
 167 
 168         // a. If the [[Value]] field of Desc is absent, then
 169         // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, Desc, and Throw as arguments.
 170         if (descriptor.isAccessorDescriptor())
 171             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
 172         // from ES5.1 8.12.9 10.a.
 173         if (!array-&gt;isLengthWritable() &amp;&amp; descriptor.writablePresent() &amp;&amp; descriptor.writable())
 174             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
 175         // This descriptor is either just making length read-only, or changing nothing!
 176         if (!descriptor.value()) {
 177             if (descriptor.writablePresent())
 178                 array-&gt;setLengthWritable(exec, descriptor.writable());
 179             return true;
 180         }
 181 
 182         // b. Let newLenDesc be a copy of Desc.
 183         // c. Let newLen be ToUint32(Desc.[[Value]]).
 184         unsigned newLen = descriptor.value().toUInt32(exec);
 185         RETURN_IF_EXCEPTION(scope, false);
 186         // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
 187         double valueAsNumber = descriptor.value().toNumber(exec);
 188         RETURN_IF_EXCEPTION(scope, false);
 189         if (newLen != valueAsNumber) {
 190             JSC::throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));
 191             return false;
 192         }
 193 
 194         // Based on SameValue check in 8.12.9, this is always okay.
 195         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 196         if (newLen == array-&gt;length()) {
 197             if (descriptor.writablePresent())
 198                 array-&gt;setLengthWritable(exec, descriptor.writable());
 199             return true;
 200         }
 201 
 202         // e. Set newLenDesc.[[Value] to newLen.
 203         // f. If newLen &gt;= oldLen, then
 204         // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 205         // g. Reject if oldLenDesc.[[Writable]] is false.
 206         if (!array-&gt;isLengthWritable())
 207             return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);
 208 
 209         // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
 210         // i. Else,
 211         // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
 212         // i.ii. Let newWritable be false.
 213         // i.iii. Set newLenDesc.[[Writable] to true.
 214         // j. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 215         // k. If succeeded is false, return false.
 216         // l. While newLen &lt; oldLen repeat,
 217         // l.i. Set oldLen to oldLen â€“ 1.
 218         // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
 219         // l.iii. If deleteSucceeded is false, then
 220         bool success = array-&gt;setLength(exec, newLen, throwException);
 221         EXCEPTION_ASSERT(!scope.exception() || !success);
 222         if (!success) {
 223             // 1. Set newLenDesc.[[Value] to oldLen+1.
 224             // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
 225             // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and false as arguments.
 226             // 4. Reject.
 227             if (descriptor.writablePresent())
 228                 array-&gt;setLengthWritable(exec, descriptor.writable());
 229             return false;
 230         }
 231 
 232         // m. If newWritable is false, then
 233         // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;,
 234         //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
 235         //    return true.
 236         if (descriptor.writablePresent())
 237             array-&gt;setLengthWritable(exec, descriptor.writable());
 238         // n. Return true.
 239         return true;
 240     }
 241 
 242     // 4. Else if P is an array index (15.4), then
 243     // a. Let index be ToUint32(P).
 244     if (Optional&lt;uint32_t&gt; optionalIndex = parseIndex(propertyName)) {
 245         // b. Reject if index &gt;= oldLen and oldLenDesc.[[Writable]] is false.
 246         uint32_t index = optionalIndex.value();
 247         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 248         if (index &gt;= array-&gt;length() &amp;&amp; !array-&gt;isLengthWritable())
 249             return typeError(exec, scope, throwException, &quot;Attempting to define numeric property on array with non-writable length property.&quot;_s);
 250         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
 251         // d. Reject if succeeded is false.
 252         // e. If index &gt;= oldLen
 253         // e.i. Set oldLenDesc.[[Value]] to index + 1.
 254         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
 255         // f. Return true.
 256         RELEASE_AND_RETURN(scope, array-&gt;defineOwnIndexedProperty(exec, index, descriptor, throwException));
 257     }
 258 
 259     RELEASE_AND_RETURN(scope, array-&gt;JSObject::defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException));
 260 }
 261 
 262 bool JSArray::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 263 {
 264     VM&amp; vm = exec-&gt;vm();
 265     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 266     if (propertyName == vm.propertyNames-&gt;length) {
 267         unsigned attributes = thisObject-&gt;isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 268         slot.setValue(thisObject, attributes, jsNumber(thisObject-&gt;length()));
 269         return true;
 270     }
 271 
 272     return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
 273 }
 274 
 275 // ECMA 15.4.5.1
 276 bool JSArray::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 277 {
 278     VM&amp; vm = exec-&gt;vm();
 279     auto scope = DECLARE_THROW_SCOPE(vm);
 280 
 281     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 282 
 283     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
 284         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
 285 
 286     thisObject-&gt;ensureWritable(vm);
 287 
 288     if (propertyName == vm.propertyNames-&gt;length) {
 289         if (!thisObject-&gt;isLengthWritable()) {
 290             if (slot.isStrictMode())
 291                 throwTypeError(exec, scope, &quot;Array length is not writable&quot;_s);
 292             return false;
 293         }
 294 
 295         unsigned newLength = value.toUInt32(exec);
 296         RETURN_IF_EXCEPTION(scope, false);
 297         double valueAsNumber = value.toNumber(exec);
 298         RETURN_IF_EXCEPTION(scope, false);
 299         if (valueAsNumber != static_cast&lt;double&gt;(newLength)) {
 300             throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));
 301             return false;
 302         }
 303         RELEASE_AND_RETURN(scope, thisObject-&gt;setLength(exec, newLength, slot.isStrictMode()));
 304     }
 305 
 306     RELEASE_AND_RETURN(scope, JSObject::put(thisObject, exec, propertyName, value, slot));
 307 }
 308 
 309 bool JSArray::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
 310 {
 311     VM&amp; vm = exec-&gt;vm();
 312     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 313 
 314     if (propertyName == vm.propertyNames-&gt;length)
 315         return false;
 316 
 317     return JSObject::deleteProperty(thisObject, exec, propertyName);
 318 }
 319 
 320 static int compareKeysForQSort(const void* a, const void* b)
 321 {
 322     unsigned da = *static_cast&lt;const unsigned*&gt;(a);
 323     unsigned db = *static_cast&lt;const unsigned*&gt;(b);
 324     return (da &gt; db) - (da &lt; db);
 325 }
 326 
 327 void JSArray::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
 328 {
 329     VM&amp; vm = exec-&gt;vm();
 330     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 331 
 332     if (mode.includeDontEnumProperties())
 333         propertyNames.add(vm.propertyNames-&gt;length);
 334 
 335     JSObject::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);
 336 }
 337 
 338 // This method makes room in the vector, but leaves the new space for count slots uncleared.
 339 bool JSArray::unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp; vm, DeferGC&amp;, bool addToFront, unsigned count)
 340 {
 341     ASSERT(cellLock().isLocked());
 342 
 343     ArrayStorage* storage = ensureArrayStorage(vm);
 344     Butterfly* butterfly = storage-&gt;butterfly();
 345     Structure* structure = this-&gt;structure(vm);
 346     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
 347     unsigned propertySize = structure-&gt;outOfLineSize();
 348 
 349     // If not, we should have handled this on the fast path.
 350     ASSERT(!addToFront || count &gt; storage-&gt;m_indexBias);
 351 
 352     // Step 1:
 353     // Gather 4 key metrics:
 354     //  * usedVectorLength - how many entries are currently in the vector (conservative estimate - fewer may be in use in sparse vectors).
 355     //  * requiredVectorLength - how many entries are will there be in the vector, after allocating space for &#39;count&#39; more.
 356     //  * currentCapacity - what is the current size of the vector, including any pre-capacity.
 357     //  * desiredCapacity - how large should we like to grow the vector to - based on 2x requiredVectorLength.
 358 
 359     unsigned length = storage-&gt;length();
 360     unsigned oldVectorLength = storage-&gt;vectorLength();
 361     unsigned usedVectorLength = std::min(oldVectorLength, length);
 362     ASSERT(usedVectorLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
 363     // Check that required vector length is possible, in an overflow-safe fashion.
 364     if (count &gt; MAX_STORAGE_VECTOR_LENGTH - usedVectorLength)
 365         return false;
 366     unsigned requiredVectorLength = usedVectorLength + count;
 367     ASSERT(requiredVectorLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
 368     // The sum of m_vectorLength and m_indexBias will never exceed MAX_STORAGE_VECTOR_LENGTH.
 369     ASSERT(storage-&gt;vectorLength() &lt;= MAX_STORAGE_VECTOR_LENGTH &amp;&amp; (MAX_STORAGE_VECTOR_LENGTH - storage-&gt;vectorLength()) &gt;= storage-&gt;m_indexBias);
 370     unsigned currentCapacity = storage-&gt;vectorLength() + storage-&gt;m_indexBias;
 371     // The calculation of desiredCapacity won&#39;t overflow, due to the range of MAX_STORAGE_VECTOR_LENGTH.
 372     // FIXME: This code should be fixed to avoid internal fragmentation. It&#39;s not super high
 373     // priority since increaseVectorLength() will &quot;fix&quot; any mistakes we make, but it would be cool
 374     // to get this right eventually.
 375     unsigned desiredCapacity = std::min(MAX_STORAGE_VECTOR_LENGTH, std::max(BASE_ARRAY_STORAGE_VECTOR_LEN, requiredVectorLength) &lt;&lt; 1);
 376 
 377     // Step 2:
 378     // We&#39;re either going to choose to allocate a new ArrayStorage, or we&#39;re going to reuse the existing one.
 379 
 380     void* newAllocBase = nullptr;
 381     unsigned newStorageCapacity;
 382     bool allocatedNewStorage;
 383     // If the current storage array is sufficiently large (but not too large!) then just keep using it.
 384     if (currentCapacity &gt; desiredCapacity &amp;&amp; isDenseEnoughForVector(currentCapacity, requiredVectorLength)) {
 385         newAllocBase = butterfly-&gt;base(structure);
 386         newStorageCapacity = currentCapacity;
 387         allocatedNewStorage = false;
 388     } else {
 389         const unsigned preCapacity = 0;
 390         Butterfly* newButterfly = Butterfly::tryCreateUninitialized(vm, this, preCapacity, propertyCapacity, true, ArrayStorage::sizeFor(desiredCapacity));
 391         if (!newButterfly)
 392             return false;
 393         newAllocBase = newButterfly-&gt;base(preCapacity, propertyCapacity);
 394         newStorageCapacity = desiredCapacity;
 395         allocatedNewStorage = true;
 396     }
 397 
 398     // Step 3:
 399     // Work out where we&#39;re going to move things to.
 400 
 401     // Determine how much of the vector to use as pre-capacity, and how much as post-capacity.
 402     // If we&#39;re adding to the end, we&#39;ll add all the new space to the end.
 403     // If the vector had no free post-capacity (length &gt;= m_vectorLength), don&#39;t give it any.
 404     // If it did, we calculate the amount that will remain based on an atomic decay - leave the
 405     // vector with half the post-capacity it had previously.
 406     unsigned postCapacity = 0;
 407     if (!addToFront)
 408         postCapacity = newStorageCapacity - requiredVectorLength;
 409     else if (length &lt; storage-&gt;vectorLength()) {
 410         // Atomic decay, + the post-capacity cannot be greater than what is available.
 411         postCapacity = std::min((storage-&gt;vectorLength() - length) &gt;&gt; 1, newStorageCapacity - requiredVectorLength);
 412         // If we&#39;re moving contents within the same allocation, the post-capacity is being reduced.
 413         ASSERT(newAllocBase != butterfly-&gt;base(structure) || postCapacity &lt; storage-&gt;vectorLength() - length);
 414     }
 415 
 416     unsigned newVectorLength = requiredVectorLength + postCapacity;
 417     RELEASE_ASSERT(newVectorLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
 418     unsigned preCapacity = newStorageCapacity - newVectorLength;
 419 
 420     Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
 421 
 422     if (addToFront) {
 423         ASSERT(count + usedVectorLength &lt;= newVectorLength);
 424         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector + count, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);
 425         memmove(newButterfly-&gt;propertyStorage() - propertySize, butterfly-&gt;propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
 426 
 427         // We don&#39;t need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
 428         memset(newButterfly-&gt;base(0, propertyCapacity), 0, (propertyCapacity - propertySize) * sizeof(JSValue));
 429 
 430         if (allocatedNewStorage) {
 431             // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
 432             // (usedVectorLength + count), which is less. Clear the difference.
 433             for (unsigned i = requiredVectorLength; i &lt; newVectorLength; ++i)
 434                 newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 435         }
 436     } else if ((newAllocBase != butterfly-&gt;base(structure)) || (preCapacity != storage-&gt;m_indexBias)) {
 437         memmove(newButterfly-&gt;propertyStorage() - propertyCapacity, butterfly-&gt;propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
 438         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);
 439 
 440         for (unsigned i = requiredVectorLength; i &lt; newVectorLength; i++)
 441             newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 442     }
 443 
 444     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
 445     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = preCapacity;
 446 
 447     setButterfly(vm, newButterfly);
 448 
 449     return true;
 450 }
 451 
 452 bool JSArray::setLengthWithArrayStorage(ExecState* exec, unsigned newLength, bool throwException, ArrayStorage* storage)
 453 {
 454     VM&amp; vm = exec-&gt;vm();
 455     auto scope = DECLARE_THROW_SCOPE(vm);
 456 
 457     unsigned length = storage-&gt;length();
 458 
 459     // If the length is read only then we enter sparse mode, so should enter the following &#39;if&#39;.
 460     ASSERT(isLengthWritable() || storage-&gt;m_sparseMap);
 461 
 462     if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 463         // Fail if the length is not writable.
 464         if (map-&gt;lengthIsReadOnly())
 465             return typeError(exec, scope, throwException, ReadonlyPropertyWriteError);
 466 
 467         if (newLength &lt; length) {
 468             // Copy any keys we might be interested in into a vector.
 469             Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
 470             keys.reserveInitialCapacity(std::min(map-&gt;size(), static_cast&lt;size_t&gt;(length - newLength)));
 471             SparseArrayValueMap::const_iterator end = map-&gt;end();
 472             for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
 473                 unsigned index = static_cast&lt;unsigned&gt;(it-&gt;key);
 474                 if (index &lt; length &amp;&amp; index &gt;= newLength)
 475                     keys.append(index);
 476             }
 477 
 478             // Check if the array is in sparse mode. If so there may be non-configurable
 479             // properties, so we have to perform deletion with caution, if not we can
 480             // delete values in any order.
 481             if (map-&gt;sparseMode()) {
 482                 qsort(keys.begin(), keys.size(), sizeof(unsigned), compareKeysForQSort);
 483                 unsigned i = keys.size();
 484                 while (i) {
 485                     unsigned index = keys[--i];
 486                     SparseArrayValueMap::iterator it = map-&gt;find(index);
 487                     ASSERT(it != map-&gt;notFound());
 488                     if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete) {
 489                         storage-&gt;setLength(index + 1);
 490                         return typeError(exec, scope, throwException, UnableToDeletePropertyError);
 491                     }
 492                     map-&gt;remove(it);
 493                 }
 494             } else {
 495                 for (unsigned i = 0; i &lt; keys.size(); ++i)
 496                     map-&gt;remove(keys[i]);
 497                 if (map-&gt;isEmpty())
 498                     deallocateSparseIndexMap();
 499             }
 500         }
 501     }
 502 
 503     if (newLength &lt; length) {
 504         // Delete properties from the vector.
 505         unsigned usedVectorLength = std::min(length, storage-&gt;vectorLength());
 506         for (unsigned i = newLength; i &lt; usedVectorLength; ++i) {
 507             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[i];
 508             bool hadValue = !!valueSlot;
 509             valueSlot.clear();
 510             storage-&gt;m_numValuesInVector -= hadValue;
 511         }
 512     }
 513 
 514     storage-&gt;setLength(newLength);
 515 
 516     return true;
 517 }
 518 
 519 bool JSArray::appendMemcpy(ExecState* exec, VM&amp; vm, unsigned startIndex, JSC::JSArray* otherArray)
 520 {
 521     auto scope = DECLARE_THROW_SCOPE(vm);
 522 
 523     if (!canFastCopy(vm, otherArray))
 524         return false;
 525 
 526     IndexingType type = indexingType();
 527     IndexingType otherType = otherArray-&gt;indexingType();
 528     IndexingType copyType = mergeIndexingTypeForCopying(otherType);
 529     if (type == ArrayWithUndecided &amp;&amp; copyType != NonArray) {
 530         if (copyType == ArrayWithInt32)
 531             convertUndecidedToInt32(vm);
 532         else if (copyType == ArrayWithDouble)
 533             convertUndecidedToDouble(vm);
 534         else if (copyType == ArrayWithContiguous)
 535             convertUndecidedToContiguous(vm);
 536         else {
 537             ASSERT(copyType == ArrayWithUndecided);
 538             return true;
 539         }
 540     } else if (type != copyType)
 541         return false;
 542 
 543     unsigned otherLength = otherArray-&gt;length();
 544     Checked&lt;unsigned, RecordOverflow&gt; checkedNewLength = startIndex;
 545     checkedNewLength += otherLength;
 546 
 547     unsigned newLength;
 548     if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
 549         throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));
 550         return false;
 551     }
 552 
 553     if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX)
 554         return false;
 555 
 556     if (!ensureLength(vm, newLength)) {
 557         throwOutOfMemoryError(exec, scope);
 558         return false;
 559     }
 560     ASSERT(copyType == indexingType());
 561 
 562     if (UNLIKELY(otherType == ArrayWithUndecided)) {
 563         auto* butterfly = this-&gt;butterfly();
 564         if (type == ArrayWithDouble) {
 565             for (unsigned i = startIndex; i &lt; newLength; ++i)
 566                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 567         } else {
 568             for (unsigned i = startIndex; i &lt; newLength; ++i)
 569                 butterfly-&gt;contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
 570         }
 571     } else if (type == ArrayWithDouble)
 572         memcpy(butterfly()-&gt;contiguousDouble().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguousDouble().data(), sizeof(JSValue) * otherLength);
 573     else {
 574         memcpy(butterfly()-&gt;contiguous().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguous().data(), sizeof(JSValue) * otherLength);
 575         vm.heap.writeBarrier(this);
 576     }
 577 
 578     return true;
 579 }
 580 
 581 bool JSArray::setLength(ExecState* exec, unsigned newLength, bool throwException)
 582 {
 583     VM&amp; vm = exec-&gt;vm();
 584     auto scope = DECLARE_THROW_SCOPE(vm);
 585 
 586     Butterfly* butterfly = this-&gt;butterfly();
 587     switch (indexingMode()) {
 588     case ArrayClass:
 589         if (!newLength)
 590             return true;
 591         if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) {
 592             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
 593                 exec, newLength, throwException,
 594                 ensureArrayStorage(vm)));
 595         }
 596         createInitialUndecided(vm, newLength);
 597         return true;
 598 
 599     case CopyOnWriteArrayWithInt32:
 600     case CopyOnWriteArrayWithDouble:
 601     case CopyOnWriteArrayWithContiguous:
 602         if (newLength == butterfly-&gt;publicLength())
 603             return true;
 604         convertFromCopyOnWrite(vm);
 605         butterfly = this-&gt;butterfly();
 606         FALLTHROUGH;
 607 
 608     case ArrayWithUndecided:
 609     case ArrayWithInt32:
 610     case ArrayWithDouble:
 611     case ArrayWithContiguous: {
 612         if (newLength == butterfly-&gt;publicLength())
 613             return true;
 614         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
 615             || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
 616                 &amp;&amp; !isDenseEnoughForVector(newLength, countElements()))) {
 617             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
 618                 exec, newLength, throwException,
 619                 ensureArrayStorage(vm)));
 620         }
 621         if (newLength &gt; butterfly-&gt;publicLength()) {
 622             if (!ensureLength(vm, newLength)) {
 623                 throwOutOfMemoryError(exec, scope);
 624                 return false;
 625             }
 626             return true;
 627         }
 628 
 629         unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;
 630         unsigned costToAllocateNewButterfly = 64; // a heuristic.
 631         if (lengthToClear &gt; newLength &amp;&amp; lengthToClear &gt; costToAllocateNewButterfly) {
 632             reallocateAndShrinkButterfly(vm, newLength);
 633             return true;
 634         }
 635 
 636         if (indexingType() == ArrayWithDouble) {
 637             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 638                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 639         } else {
 640             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 641                 butterfly-&gt;contiguous().at(this, i).clear();
 642         }
 643         butterfly-&gt;setPublicLength(newLength);
 644         return true;
 645     }
 646 
 647     case ArrayWithArrayStorage:
 648     case ArrayWithSlowPutArrayStorage:
 649         RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(exec, newLength, throwException, arrayStorage()));
 650 
 651     default:
 652         CRASH();
 653         return false;
 654     }
 655 }
 656 
 657 JSValue JSArray::pop(ExecState* exec)
 658 {
 659     VM&amp; vm = exec-&gt;vm();
 660     auto scope = DECLARE_THROW_SCOPE(vm);
 661 
 662     ensureWritable(vm);
 663 
 664     Butterfly* butterfly = this-&gt;butterfly();
 665 
 666     switch (indexingType()) {
 667     case ArrayClass:
 668         return jsUndefined();
 669 
 670     case ArrayWithUndecided:
 671         if (!butterfly-&gt;publicLength())
 672             return jsUndefined();
 673         // We have nothing but holes. So, drop down to the slow version.
 674         break;
 675 
 676     case ArrayWithInt32:
 677     case ArrayWithContiguous: {
 678         unsigned length = butterfly-&gt;publicLength();
 679 
 680         if (!length--)
 681             return jsUndefined();
 682 
 683         RELEASE_ASSERT(length &lt; butterfly-&gt;vectorLength());
 684         JSValue value = butterfly-&gt;contiguous().at(this, length).get();
 685         if (value) {
 686             butterfly-&gt;contiguous().at(this, length).clear();
 687             butterfly-&gt;setPublicLength(length);
 688             return value;
 689         }
 690         break;
 691     }
 692 
 693     case ArrayWithDouble: {
 694         unsigned length = butterfly-&gt;publicLength();
 695 
 696         if (!length--)
 697             return jsUndefined();
 698 
 699         RELEASE_ASSERT(length &lt; butterfly-&gt;vectorLength());
 700         double value = butterfly-&gt;contiguousDouble().at(this, length);
 701         if (value == value) {
 702             butterfly-&gt;contiguousDouble().at(this, length) = PNaN;
 703             butterfly-&gt;setPublicLength(length);
 704             return JSValue(JSValue::EncodeAsDouble, value);
 705         }
 706         break;
 707     }
 708 
 709     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
 710         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 711 
 712         unsigned length = storage-&gt;length();
 713         if (!length) {
 714             if (!isLengthWritable())
 715                 throwTypeError(exec, scope, ReadonlyPropertyWriteError);
 716             return jsUndefined();
 717         }
 718 
 719         unsigned index = length - 1;
 720         if (index &lt; storage-&gt;vectorLength()) {
 721             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[index];
 722             if (valueSlot) {
 723                 --storage-&gt;m_numValuesInVector;
 724                 JSValue element = valueSlot.get();
 725                 valueSlot.clear();
 726 
 727                 RELEASE_ASSERT(isLengthWritable());
 728                 storage-&gt;setLength(index);
 729                 return element;
 730             }
 731         }
 732         break;
 733     }
 734 
 735     default:
 736         CRASH();
 737         return JSValue();
 738     }
 739 
 740     unsigned index = getArrayLength() - 1;
 741     // Let element be the result of calling the [[Get]] internal method of O with argument indx.
 742     JSValue element = get(exec, index);
 743     RETURN_IF_EXCEPTION(scope, JSValue());
 744     // Call the [[Delete]] internal method of O with arguments indx and true.
 745     bool success = deletePropertyByIndex(this, exec, index);
 746     RETURN_IF_EXCEPTION(scope, JSValue());
 747     if (!success) {
 748         throwTypeError(exec, scope, UnableToDeletePropertyError);
 749         return jsUndefined();
 750     }
 751     // Call the [[Put]] internal method of O with arguments &quot;length&quot;, indx, and true.
 752     scope.release();
 753     setLength(exec, index, true);
 754     // Return element.
 755     return element;
 756 }
 757 
 758 // Push &amp; putIndex are almost identical, with two small differences.
 759 //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length &amp; m_numValuesInVector.
 760 //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
 761 NEVER_INLINE void JSArray::push(ExecState* exec, JSValue value)
 762 {
 763     pushInline(exec, value);
 764 }
 765 
 766 JSArray* JSArray::fastSlice(ExecState&amp; exec, unsigned startIndex, unsigned count)
 767 {
 768     VM&amp; vm = exec.vm();
 769 
 770     ensureWritable(vm);
 771 
 772     auto arrayType = indexingMode();
 773     switch (arrayType) {
 774     case ArrayWithDouble:
 775     case ArrayWithInt32:
 776     case ArrayWithContiguous: {
 777         if (count &gt;= MIN_SPARSE_ARRAY_INDEX || structure(vm)-&gt;holesMustForwardToPrototype(vm, this))
 778             return nullptr;
 779 
 780         JSGlobalObject* lexicalGlobalObject = exec.lexicalGlobalObject();
 781         Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(arrayType);
 782         if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
 783             return nullptr;
 784 
 785         ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());
 786         ObjectInitializationScope scope(vm);
 787         JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
 788         if (UNLIKELY(!resultArray))
 789             return nullptr;
 790 
 791         auto&amp; resultButterfly = *resultArray-&gt;butterfly();
 792         if (arrayType == ArrayWithDouble)
 793             memcpy(resultButterfly.contiguousDouble().data(), butterfly()-&gt;contiguousDouble().data() + startIndex, sizeof(JSValue) * count);
 794         else
 795             memcpy(resultButterfly.contiguous().data(), butterfly()-&gt;contiguous().data() + startIndex, sizeof(JSValue) * count);
 796         resultButterfly.setPublicLength(count);
 797 
 798         return resultArray;
 799     }
 800     default:
 801         return nullptr;
 802     }
 803 }
 804 
 805 bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
 806 {
 807     unsigned oldLength = storage-&gt;length();
 808     RELEASE_ASSERT(count &lt;= oldLength);
 809 
 810     // If the array contains holes or is otherwise in an abnormal state,
 811     // use the generic algorithm in ArrayPrototype.
 812     if (storage-&gt;hasHoles()
 813         || hasSparseMap()
 814         || shouldUseSlowPut(indexingType())) {
 815         return false;
 816     }
 817 
 818     if (!oldLength)
 819         return true;
 820 
 821     unsigned length = oldLength - count;
 822 
 823     storage-&gt;m_numValuesInVector -= count;
 824     storage-&gt;setLength(length);
 825 
 826     unsigned vectorLength = storage-&gt;vectorLength();
 827     if (!vectorLength)
 828         return true;
 829 
 830     if (startIndex &gt;= vectorLength)
 831         return true;
 832 
 833     DisallowGC disallowGC;
 834     auto locker = holdLock(cellLock());
 835 
 836     if (startIndex + count &gt; vectorLength)
 837         count = vectorLength - startIndex;
 838 
 839     unsigned usedVectorLength = std::min(vectorLength, oldLength);
 840 
 841     unsigned numElementsBeforeShiftRegion = startIndex;
 842     unsigned firstIndexAfterShiftRegion = startIndex + count;
 843     unsigned numElementsAfterShiftRegion = usedVectorLength - firstIndexAfterShiftRegion;
 844     ASSERT(numElementsBeforeShiftRegion + count + numElementsAfterShiftRegion == usedVectorLength);
 845 
 846     // The point of this comparison seems to be to minimize the amount of elements that have to
 847     // be moved during a shift operation.
 848     if (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) {
 849         // The number of elements before the shift region is less than the number of elements
 850         // after the shift region, so we move the elements before to the right.
 851         if (numElementsBeforeShiftRegion) {
 852             RELEASE_ASSERT(count + startIndex &lt;= vectorLength);
 853             memmove(storage-&gt;m_vector + count,
 854                 storage-&gt;m_vector,
 855                 sizeof(JSValue) * startIndex);
 856         }
 857         // Adjust the Butterfly and the index bias. We only need to do this here because we&#39;re changing
 858         // the start of the Butterfly, which needs to point at the first indexed property in the used
 859         // portion of the vector.
 860         Butterfly* butterfly = this-&gt;butterfly()-&gt;shift(structure(vm), count);
 861         storage = butterfly-&gt;arrayStorage();
 862         storage-&gt;m_indexBias += count;
 863 
 864         // Since we&#39;re consuming part of the vector by moving its beginning to the left,
 865         // we need to modify the vector length appropriately.
 866         storage-&gt;setVectorLength(vectorLength - count);
 867         setButterfly(vm, butterfly);
 868     } else {
 869         // The number of elements before the shift region is greater than or equal to the number
 870         // of elements after the shift region, so we move the elements after the shift region to the left.
 871         memmove(storage-&gt;m_vector + startIndex,
 872             storage-&gt;m_vector + firstIndexAfterShiftRegion,
 873             sizeof(JSValue) * numElementsAfterShiftRegion);
 874 
 875         // Clear the slots of the elements we just moved.
 876         unsigned startOfEmptyVectorTail = usedVectorLength - count;
 877         for (unsigned i = startOfEmptyVectorTail; i &lt; usedVectorLength; ++i)
 878             storage-&gt;m_vector[i].clear();
 879         // We don&#39;t modify the index bias or the Butterfly pointer in this case because we&#39;re not changing
 880         // the start of the Butterfly, which needs to point at the first indexed property in the used
 881         // portion of the vector. We also don&#39;t modify the vector length because we&#39;re not actually changing
 882         // its length; we&#39;re just using less of it.
 883     }
 884 
 885     return true;
 886 }
 887 
 888 bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned&amp; startIndex, unsigned count)
 889 {
 890     VM&amp; vm = exec-&gt;vm();
 891     RELEASE_ASSERT(count &gt; 0);
 892 
 893     ensureWritable(vm);
 894 
 895     Butterfly* butterfly = this-&gt;butterfly();
 896 
 897     switch (indexingType()) {
 898     case ArrayClass:
 899         return true;
 900 
 901     case ArrayWithUndecided:
 902         // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
 903         return false;
 904 
 905     case ArrayWithInt32:
 906     case ArrayWithContiguous: {
 907         unsigned oldLength = butterfly-&gt;publicLength();
 908         RELEASE_ASSERT(count &lt;= oldLength);
 909 
 910         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 911         // so only if it&#39;s not horribly slow.
 912         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 913             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 914 
 915         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 916         // is totally not fine, since we might have to read from the proto chain.
 917         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 918         // through shifting and then realize we should have been in ArrayStorage mode.
 919         unsigned end = oldLength - count;
 920         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 921             for (unsigned i = startIndex; i &lt; end; ++i) {
 922                 JSValue v = butterfly-&gt;contiguous().at(this, i + count).get();
 923                 if (UNLIKELY(!v)) {
 924                     startIndex = i;
 925                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 926                 }
 927                 butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 928             }
 929         } else {
 930             memmove(butterfly-&gt;contiguous().data() + startIndex,
 931                 butterfly-&gt;contiguous().data() + startIndex + count,
 932                 sizeof(JSValue) * (end - startIndex));
 933         }
 934 
 935         for (unsigned i = end; i &lt; oldLength; ++i)
 936             butterfly-&gt;contiguous().at(this, i).clear();
 937 
 938         butterfly-&gt;setPublicLength(oldLength - count);
 939 
 940         // Our memmoving of values around in the array could have concealed some of them from
 941         // the collector. Let&#39;s make sure that the collector scans this object again.
 942         vm.heap.writeBarrier(this);
 943 
 944         return true;
 945     }
 946 
 947     case ArrayWithDouble: {
 948         unsigned oldLength = butterfly-&gt;publicLength();
 949         RELEASE_ASSERT(count &lt;= oldLength);
 950 
 951         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 952         // so only if it&#39;s not horribly slow.
 953         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 954             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 955 
 956         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 957         // is totally not fine, since we might have to read from the proto chain.
 958         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 959         // through shifting and then realize we should have been in ArrayStorage mode.
 960         unsigned end = oldLength - count;
 961         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 962             for (unsigned i = startIndex; i &lt; end; ++i) {
 963                 double v = butterfly-&gt;contiguousDouble().at(this, i + count);
 964                 if (UNLIKELY(v != v)) {
 965                     startIndex = i;
 966                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 967                 }
 968                 butterfly-&gt;contiguousDouble().at(this, i) = v;
 969             }
 970         } else {
 971             memmove(butterfly-&gt;contiguousDouble().data() + startIndex,
 972                 butterfly-&gt;contiguousDouble().data() + startIndex + count,
 973                 sizeof(JSValue) * (end - startIndex));
 974         }
 975         for (unsigned i = end; i &lt; oldLength; ++i)
 976             butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 977 
 978         butterfly-&gt;setPublicLength(oldLength - count);
 979         return true;
 980     }
 981 
 982     case ArrayWithArrayStorage:
 983     case ArrayWithSlowPutArrayStorage:
 984         return shiftCountWithArrayStorage(vm, startIndex, count, arrayStorage());
 985 
 986     default:
 987         CRASH();
 988         return false;
 989     }
 990 }
 991 
 992 // Returns true if the unshift can be handled, false to fallback.
 993 bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)
 994 {
 995     VM&amp; vm = exec-&gt;vm();
 996     auto scope = DECLARE_THROW_SCOPE(vm);
 997 
 998     unsigned length = storage-&gt;length();
 999 
1000     RELEASE_ASSERT(startIndex &lt;= length);
1001 
1002     // If the array contains holes or is otherwise in an abnormal state,
1003     // use the generic algorithm in ArrayPrototype.
1004     if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))
1005         return false;
1006 
1007     bool moveFront = !startIndex || startIndex &lt; length / 2;
1008 
1009     unsigned vectorLength = storage-&gt;vectorLength();
1010 
1011     // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in
1012     // a weird state: some parts of it will be left uninitialized, which we will fill in here.
1013     DeferGC deferGC(vm.heap);
1014     auto locker = holdLock(cellLock());
1015 
1016     if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) {
1017         Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);
1018         storage = newButterfly-&gt;arrayStorage();
1019         storage-&gt;m_indexBias -= count;
1020         storage-&gt;setVectorLength(vectorLength + count);
1021         setButterfly(vm, newButterfly);
1022     } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
1023         storage = storage-&gt;butterfly()-&gt;arrayStorage();
1024     else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
1025         storage = arrayStorage();
1026     else {
1027         throwOutOfMemoryError(exec, scope);
1028         return true;
1029     }
1030 
1031     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
1032 
1033     if (startIndex) {
1034         if (moveFront)
1035             memmove(vector, vector + count, startIndex * sizeof(JSValue));
1036         else if (length - startIndex)
1037             memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));
1038     }
1039 
1040     for (unsigned i = 0; i &lt; count; i++)
1041         vector[i + startIndex].clear();
1042 
1043     return true;
1044 }
1045 
1046 bool JSArray::unshiftCountWithAnyIndexingType(ExecState* exec, unsigned startIndex, unsigned count)
1047 {
1048     VM&amp; vm = exec-&gt;vm();
1049     auto scope = DECLARE_THROW_SCOPE(vm);
1050 
1051     ensureWritable(vm);
1052 
1053     Butterfly* butterfly = this-&gt;butterfly();
1054 
1055     switch (indexingType()) {
1056     case ArrayClass:
1057     case ArrayWithUndecided:
1058         // We could handle this. But it shouldn&#39;t ever come up, so we won&#39;t.
1059         return false;
1060 
1061     case ArrayWithInt32:
1062     case ArrayWithContiguous: {
1063         unsigned oldLength = butterfly-&gt;publicLength();
1064 
1065         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1066         // only if it&#39;s not horribly slow.
1067         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
1068             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
1069 
1070         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1071         checkedLength += count;
1072         unsigned newLength;
1073         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
1074             throwOutOfMemoryError(exec, scope);
1075             return true;
1076         }
1077         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1078             return false;
1079         if (!ensureLength(vm, newLength)) {
1080             throwOutOfMemoryError(exec, scope);
1081             return true;
1082         }
1083         butterfly = this-&gt;butterfly();
1084 
1085         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1086         // through shifting and then realize we should have been in ArrayStorage mode.
1087         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1088             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1089             if (UNLIKELY(!v))
1090                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
1091         }
1092 
1093         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1094             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1095             ASSERT(v);
1096             butterfly-&gt;contiguous().at(this, i + count).setWithoutWriteBarrier(v);
1097         }
1098 
1099         // Our memmoving of values around in the array could have concealed some of them from
1100         // the collector. Let&#39;s make sure that the collector scans this object again.
1101         vm.heap.writeBarrier(this);
1102 
1103         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1104         // of. This is fine because the caller is required to store over that area, and
1105         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1106         // as storing over an existing element.
1107 
1108         return true;
1109     }
1110 
1111     case ArrayWithDouble: {
1112         unsigned oldLength = butterfly-&gt;publicLength();
1113 
1114         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1115         // only if it&#39;s not horribly slow.
1116         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
1117             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
1118 
1119         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1120         checkedLength += count;
1121         unsigned newLength;
1122         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
1123             throwOutOfMemoryError(exec, scope);
1124             return true;
1125         }
1126         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1127             return false;
1128         if (!ensureLength(vm, newLength)) {
1129             throwOutOfMemoryError(exec, scope);
1130             return true;
1131         }
1132         butterfly = this-&gt;butterfly();
1133 
1134         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1135         // through shifting and then realize we should have been in ArrayStorage mode.
1136         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1137             double v = butterfly-&gt;contiguousDouble().at(this, i);
1138             if (UNLIKELY(v != v))
1139                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));
1140         }
1141 
1142         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1143             double v = butterfly-&gt;contiguousDouble().at(this, i);
1144             ASSERT(v == v);
1145             butterfly-&gt;contiguousDouble().at(this, i + count) = v;
1146         }
1147 
1148         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1149         // of. This is fine because the caller is required to store over that area, and
1150         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1151         // as storing over an existing element.
1152 
1153         return true;
1154     }
1155 
1156     case ArrayWithArrayStorage:
1157     case ArrayWithSlowPutArrayStorage:
1158         RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, arrayStorage()));
1159 
1160     default:
1161         CRASH();
1162         return false;
1163     }
1164 }
1165 
1166 void JSArray::fillArgList(ExecState* exec, MarkedArgumentBuffer&amp; args)
1167 {
1168     unsigned i = 0;
1169     unsigned vectorEnd;
1170     WriteBarrier&lt;Unknown&gt;* vector;
1171 
1172     Butterfly* butterfly = this-&gt;butterfly();
1173 
1174     switch (indexingType()) {
1175     case ArrayClass:
1176         return;
1177 
1178     case ArrayWithUndecided: {
1179         vector = 0;
1180         vectorEnd = 0;
1181         break;
1182     }
1183 
1184     case ArrayWithInt32:
1185     case ArrayWithContiguous: {
1186         vectorEnd = butterfly-&gt;publicLength();
1187         vector = butterfly-&gt;contiguous().data();
1188         break;
1189     }
1190 
1191     case ArrayWithDouble: {
1192         vector = 0;
1193         vectorEnd = 0;
1194         for (; i &lt; butterfly-&gt;publicLength(); ++i) {
1195             double v = butterfly-&gt;contiguousDouble().at(this, i);
1196             if (v != v)
1197                 break;
1198             args.append(JSValue(JSValue::EncodeAsDouble, v));
1199         }
1200         break;
1201     }
1202 
1203     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
1204         ArrayStorage* storage = butterfly-&gt;arrayStorage();
1205 
1206         vector = storage-&gt;m_vector;
1207         vectorEnd = std::min(storage-&gt;length(), storage-&gt;vectorLength());
1208         break;
1209     }
1210 
1211     default:
1212         CRASH();
1213 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1214         vector = 0;
1215         vectorEnd = 0;
1216         break;
1217 #endif
1218     }
1219 
1220     for (; i &lt; vectorEnd; ++i) {
1221         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1222         if (!v)
1223             break;
1224         args.append(v.get());
1225     }
1226 
1227     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1228     for (; i &lt; length(); ++i)
1229         args.append(get(exec, i));
1230 }
1231 
1232 void JSArray::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)
1233 {
1234     VM&amp; vm = exec-&gt;vm();
1235     auto scope = DECLARE_THROW_SCOPE(vm);
1236 
1237     unsigned i = offset;
1238     WriteBarrier&lt;Unknown&gt;* vector;
1239     unsigned vectorEnd;
1240     length += offset; // We like to think of the length as being our length, rather than the output length.
1241 
1242     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1243     ASSERT(length == this-&gt;length());
1244 
1245     Butterfly* butterfly = this-&gt;butterfly();
1246     switch (indexingType()) {
1247     case ArrayClass:
1248         return;
1249 
1250     case ArrayWithUndecided: {
1251         vector = 0;
1252         vectorEnd = 0;
1253         break;
1254     }
1255 
1256     case ArrayWithInt32:
1257     case ArrayWithContiguous: {
1258         vector = butterfly-&gt;contiguous().data();
1259         vectorEnd = butterfly-&gt;publicLength();
1260         break;
1261     }
1262 
1263     case ArrayWithDouble: {
1264         vector = 0;
1265         vectorEnd = 0;
1266         for (; i &lt; butterfly-&gt;publicLength(); ++i) {
1267             ASSERT(i &lt; butterfly-&gt;vectorLength());
1268             double v = butterfly-&gt;contiguousDouble().at(this, i);
1269             if (v != v)
1270                 break;
1271             exec-&gt;r(firstElementDest + i - offset) = JSValue(JSValue::EncodeAsDouble, v);
1272         }
1273         break;
1274     }
1275 
1276     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
1277         ArrayStorage* storage = butterfly-&gt;arrayStorage();
1278         vector = storage-&gt;m_vector;
1279         vectorEnd = std::min(length, storage-&gt;vectorLength());
1280         break;
1281     }
1282 
1283     default:
1284         CRASH();
1285 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1286         vector = 0;
1287         vectorEnd = 0;
1288         break;
1289 #endif
1290     }
1291 
1292     for (; i &lt; vectorEnd; ++i) {
1293         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1294         if (!v)
1295             break;
1296         exec-&gt;r(firstElementDest + i - offset) = v.get();
1297     }
1298 
1299     for (; i &lt; length; ++i) {
1300         exec-&gt;r(firstElementDest + i - offset) = get(exec, i);
1301         RETURN_IF_EXCEPTION(scope, void());
1302     }
1303 }
1304 
1305 bool JSArray::isIteratorProtocolFastAndNonObservable()
1306 {
1307     JSGlobalObject* globalObject = this-&gt;globalObject();
1308     if (!globalObject-&gt;isArrayPrototypeIteratorProtocolFastAndNonObservable())
1309         return false;
1310 
1311     VM&amp; vm = globalObject-&gt;vm();
1312     Structure* structure = this-&gt;structure(vm);
1313     // This is the fast case. Many arrays will be an original array.
1314     if (globalObject-&gt;isOriginalArrayStructure(structure))
1315         return true;
1316 
1317     if (structure-&gt;mayInterceptIndexedAccesses())
1318         return false;
1319 
1320     if (getPrototypeDirect(vm) != globalObject-&gt;arrayPrototype())
1321         return false;
1322 
1323     if (getDirectOffset(vm, vm.propertyNames-&gt;iteratorSymbol) != invalidOffset)
1324         return false;
1325 
1326     return true;
1327 }
1328 
1329 inline JSArray* constructArray(ObjectInitializationScope&amp; scope, Structure* arrayStructure, unsigned length)
1330 {
1331     JSArray* array = JSArray::tryCreateUninitializedRestricted(scope, arrayStructure, length);
1332 
1333     // FIXME: we should probably throw an out of memory error here, but
1334     // when making this change we should check that all clients of this
1335     // function will correctly handle an exception being thrown from here.
1336     // https://bugs.webkit.org/show_bug.cgi?id=169786
1337     RELEASE_ASSERT(array);
1338 
1339     // FIXME: We only need this for subclasses of Array because we might need to allocate a new structure to change
1340     // indexing types while initializing. If this triggered a GC then we might scan our currently uninitialized
1341     // array and crash. https://bugs.webkit.org/show_bug.cgi?id=186811
1342     if (!arrayStructure-&gt;globalObject()-&gt;isOriginalArrayStructure(arrayStructure))
1343         JSArray::eagerlyInitializeButterfly(scope, array, length);
1344 
1345     return array;
1346 }
1347 
1348 JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const ArgList&amp; values)
1349 {
1350     VM&amp; vm = exec-&gt;vm();
1351     unsigned length = values.size();
1352     ObjectInitializationScope scope(vm);
1353 
1354     JSArray* array = constructArray(scope, arrayStructure, length);
1355     for (unsigned i = 0; i &lt; length; ++i)
1356         array-&gt;initializeIndex(scope, i, values.at(i));
1357     return array;
1358 }
1359 
1360 JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)
1361 {
1362     VM&amp; vm = exec-&gt;vm();
1363     ObjectInitializationScope scope(vm);
1364 
1365     JSArray* array = constructArray(scope, arrayStructure, length);
1366     for (unsigned i = 0; i &lt; length; ++i)
1367         array-&gt;initializeIndex(scope, i, values[i]);
1368     return array;
1369 }
1370 
1371 JSArray* constructArrayNegativeIndexed(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)
1372 {
1373     VM&amp; vm = exec-&gt;vm();
1374     ObjectInitializationScope scope(vm);
1375 
1376     JSArray* array = constructArray(scope, arrayStructure, length);
1377     for (int i = 0; i &lt; static_cast&lt;int&gt;(length); ++i)
1378         array-&gt;initializeIndex(scope, i, values[-i]);
1379     return array;
1380 }
1381 
1382 } // namespace JSC
    </pre>
  </body>
</html>