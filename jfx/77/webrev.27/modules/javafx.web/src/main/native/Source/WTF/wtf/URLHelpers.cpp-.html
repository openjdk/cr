<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/URLHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  3  * Copyright (C) 2018 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;URLHelpers.h&quot;
 32 
 33 #include &quot;URLParser.h&quot;
 34 #include &lt;mutex&gt;
 35 #include &lt;unicode/uidna.h&gt;
 36 #include &lt;unicode/uscript.h&gt;
 37 
 38 namespace WTF {
 39 namespace URLHelpers {
 40 
 41 // Needs to be big enough to hold an IDN-encoded name.
 42 // For host names bigger than this, we won&#39;t do IDN encoding, which is almost certainly OK.
 43 const unsigned hostNameBufferLength = 2048;
 44 const unsigned urlBytesBufferLength = 2048;
 45 
 46 static uint32_t IDNScriptWhiteList[(USCRIPT_CODE_LIMIT + 31) / 32];
 47 
 48 #if !PLATFORM(COCOA)
 49 
 50 // Cocoa has an implementation that uses a whitelist in /Library or ~/Library,
 51 // if it exists.
 52 void loadIDNScriptWhiteList()
 53 {
 54     static std::once_flag flag;
 55     std::call_once(flag, initializeDefaultIDNScriptWhiteList);
 56 }
 57 
 58 #endif // !PLATFORM(COCOA)
 59 
 60 static bool isArmenianLookalikeCharacter(UChar32 codePoint)
 61 {
 62     return codePoint == 0x0548 || codePoint == 0x054D || codePoint == 0x0578 || codePoint == 0x057D;
 63 }
 64 
 65 static bool isArmenianScriptCharacter(UChar32 codePoint)
 66 {
 67     UErrorCode error = U_ZERO_ERROR;
 68     UScriptCode script = uscript_getScript(codePoint, &amp;error);
 69     if (error != U_ZERO_ERROR) {
 70         LOG_ERROR(&quot;got ICU error while trying to look at scripts: %d&quot;, error);
 71         return false;
 72     }
 73 
 74     return script == USCRIPT_ARMENIAN;
 75 }
 76 
 77 template&lt;typename CharacterType&gt; inline bool isASCIIDigitOrValidHostCharacter(CharacterType charCode)
 78 {
 79     if (!isASCIIDigitOrPunctuation(charCode))
 80         return false;
 81 
 82     // Things the URL Parser rejects:
 83     switch (charCode) {
 84     case &#39;#&#39;:
 85     case &#39;%&#39;:
 86     case &#39;/&#39;:
 87     case &#39;:&#39;:
 88     case &#39;?&#39;:
 89     case &#39;@&#39;:
 90     case &#39;[&#39;:
 91     case &#39;\\&#39;:
 92     case &#39;]&#39;:
 93         return false;
 94     default:
 95         return true;
 96     }
 97 }
 98 
 99 static bool isLookalikeCharacter(const Optional&lt;UChar32&gt;&amp; previousCodePoint, UChar32 charCode)
100 {
101     // This function treats the following as unsafe, lookalike characters:
102     // any non-printable character, any character considered as whitespace,
103     // any ignorable character, and emoji characters related to locks.
104 
105     // We also considered the characters in Mozilla&#39;s blacklist &lt;http://kb.mozillazine.org/Network.IDN.blacklist_chars&gt;.
106 
107     // Some of the characters here will never appear once ICU has encoded.
108     // For example, ICU transforms most spaces into an ASCII space and most
109     // slashes into an ASCII solidus. But one of the two callers uses this
110     // on characters that have not been processed by ICU, so they are needed here.
111 
112     if (!u_isprint(charCode) || u_isUWhiteSpace(charCode) || u_hasBinaryProperty(charCode, UCHAR_DEFAULT_IGNORABLE_CODE_POINT))
113         return true;
114 
115     switch (charCode) {
116     case 0x00BC: /* VULGAR FRACTION ONE QUARTER */
117     case 0x00BD: /* VULGAR FRACTION ONE HALF */
118     case 0x00BE: /* VULGAR FRACTION THREE QUARTERS */
119     case 0x00ED: /* LATIN SMALL LETTER I WITH ACUTE */
120     /* 0x0131 LATIN SMALL LETTER DOTLESS I is intentionally not considered a lookalike character because it is visually distinguishable from i and it has legitimate use in the Turkish language. */
121     case 0x01C3: /* LATIN LETTER RETROFLEX CLICK */
122     case 0x0251: /* LATIN SMALL LETTER ALPHA */
123     case 0x0261: /* LATIN SMALL LETTER SCRIPT G */
124     case 0x027E: /* LATIN SMALL LETTER R WITH FISHHOOK */
125     case 0x02D0: /* MODIFIER LETTER TRIANGULAR COLON */
126     case 0x0335: /* COMBINING SHORT STROKE OVERLAY */
127     case 0x0337: /* COMBINING SHORT SOLIDUS OVERLAY */
128     case 0x0338: /* COMBINING LONG SOLIDUS OVERLAY */
129     case 0x0589: /* ARMENIAN FULL STOP */
130     case 0x05B4: /* HEBREW POINT HIRIQ */
131     case 0x05BC: /* HEBREW POINT DAGESH OR MAPIQ */
132     case 0x05C3: /* HEBREW PUNCTUATION SOF PASUQ */
133     case 0x05F4: /* HEBREW PUNCTUATION GERSHAYIM */
134     case 0x0609: /* ARABIC-INDIC PER MILLE SIGN */
135     case 0x060A: /* ARABIC-INDIC PER TEN THOUSAND SIGN */
136     case 0x0650: /* ARABIC KASRA */
137     case 0x0660: /* ARABIC INDIC DIGIT ZERO */
138     case 0x066A: /* ARABIC PERCENT SIGN */
139     case 0x06D4: /* ARABIC FULL STOP */
140     case 0x06F0: /* EXTENDED ARABIC INDIC DIGIT ZERO */
141     case 0x0701: /* SYRIAC SUPRALINEAR FULL STOP */
142     case 0x0702: /* SYRIAC SUBLINEAR FULL STOP */
143     case 0x0703: /* SYRIAC SUPRALINEAR COLON */
144     case 0x0704: /* SYRIAC SUBLINEAR COLON */
145     case 0x1735: /* PHILIPPINE SINGLE PUNCTUATION */
146     case 0x1D04: /* LATIN LETTER SMALL CAPITAL C */
147     case 0x1D0F: /* LATIN LETTER SMALL CAPITAL O */
148     case 0x1D1C: /* LATIN LETTER SMALL CAPITAL U */
149     case 0x1D20: /* LATIN LETTER SMALL CAPITAL V */
150     case 0x1D21: /* LATIN LETTER SMALL CAPITAL W */
151     case 0x1D22: /* LATIN LETTER SMALL CAPITAL Z */
152     case 0x1ECD: /* LATIN SMALL LETTER O WITH DOT BELOW */
153     case 0x2010: /* HYPHEN */
154     case 0x2011: /* NON-BREAKING HYPHEN */
155     case 0x2024: /* ONE DOT LEADER */
156     case 0x2027: /* HYPHENATION POINT */
157     case 0x2039: /* SINGLE LEFT-POINTING ANGLE QUOTATION MARK */
158     case 0x203A: /* SINGLE RIGHT-POINTING ANGLE QUOTATION MARK */
159     case 0x2041: /* CARET INSERTION POINT */
160     case 0x2044: /* FRACTION SLASH */
161     case 0x2052: /* COMMERCIAL MINUS SIGN */
162     case 0x2153: /* VULGAR FRACTION ONE THIRD */
163     case 0x2154: /* VULGAR FRACTION TWO THIRDS */
164     case 0x2155: /* VULGAR FRACTION ONE FIFTH */
165     case 0x2156: /* VULGAR FRACTION TWO FIFTHS */
166     case 0x2157: /* VULGAR FRACTION THREE FIFTHS */
167     case 0x2158: /* VULGAR FRACTION FOUR FIFTHS */
168     case 0x2159: /* VULGAR FRACTION ONE SIXTH */
169     case 0x215A: /* VULGAR FRACTION FIVE SIXTHS */
170     case 0x215B: /* VULGAR FRACTION ONE EIGHT */
171     case 0x215C: /* VULGAR FRACTION THREE EIGHTHS */
172     case 0x215D: /* VULGAR FRACTION FIVE EIGHTHS */
173     case 0x215E: /* VULGAR FRACTION SEVEN EIGHTHS */
174     case 0x215F: /* FRACTION NUMERATOR ONE */
175     case 0x2212: /* MINUS SIGN */
176     case 0x2215: /* DIVISION SLASH */
177     case 0x2216: /* SET MINUS */
178     case 0x2236: /* RATIO */
179     case 0x233F: /* APL FUNCTIONAL SYMBOL SLASH BAR */
180     case 0x23AE: /* INTEGRAL EXTENSION */
181     case 0x244A: /* OCR DOUBLE BACKSLASH */
182     case 0x2571: /* BOX DRAWINGS LIGHT DIAGONAL UPPER RIGHT TO LOWER LEFT */
183     case 0x2572: /* BOX DRAWINGS LIGHT DIAGONAL UPPER LEFT TO LOWER RIGHT */
184     case 0x29F6: /* SOLIDUS WITH OVERBAR */
185     case 0x29F8: /* BIG SOLIDUS */
186     case 0x2AFB: /* TRIPLE SOLIDUS BINARY RELATION */
187     case 0x2AFD: /* DOUBLE SOLIDUS OPERATOR */
188     case 0x2FF0: /* IDEOGRAPHIC DESCRIPTION CHARACTER LEFT TO RIGHT */
189     case 0x2FF1: /* IDEOGRAPHIC DESCRIPTION CHARACTER ABOVE TO BELOW */
190     case 0x2FF2: /* IDEOGRAPHIC DESCRIPTION CHARACTER LEFT TO MIDDLE AND RIGHT */
191     case 0x2FF3: /* IDEOGRAPHIC DESCRIPTION CHARACTER ABOVE TO MIDDLE AND BELOW */
192     case 0x2FF4: /* IDEOGRAPHIC DESCRIPTION CHARACTER FULL SURROUND */
193     case 0x2FF5: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM ABOVE */
194     case 0x2FF6: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM BELOW */
195     case 0x2FF7: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM LEFT */
196     case 0x2FF8: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM UPPER LEFT */
197     case 0x2FF9: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM UPPER RIGHT */
198     case 0x2FFA: /* IDEOGRAPHIC DESCRIPTION CHARACTER SURROUND FROM LOWER LEFT */
199     case 0x2FFB: /* IDEOGRAPHIC DESCRIPTION CHARACTER OVERLAID */
200     case 0x3002: /* IDEOGRAPHIC FULL STOP */
201     case 0x3008: /* LEFT ANGLE BRACKET */
202     case 0x3014: /* LEFT TORTOISE SHELL BRACKET */
203     case 0x3015: /* RIGHT TORTOISE SHELL BRACKET */
204     case 0x3033: /* VERTICAL KANA REPEAT MARK UPPER HALF */
205     case 0x3035: /* VERTICAL KANA REPEAT MARK LOWER HALF */
206     case 0x321D: /* PARENTHESIZED KOREAN CHARACTER OJEON */
207     case 0x321E: /* PARENTHESIZED KOREAN CHARACTER O HU */
208     case 0x33AE: /* SQUARE RAD OVER S */
209     case 0x33AF: /* SQUARE RAD OVER S SQUARED */
210     case 0x33C6: /* SQUARE C OVER KG */
211     case 0x33DF: /* SQUARE A OVER M */
212     case 0x05B9: /* HEBREW POINT HOLAM */
213     case 0x05BA: /* HEBREW POINT HOLAM HASER FOR VAV */
214     case 0x05C1: /* HEBREW POINT SHIN DOT */
215     case 0x05C2: /* HEBREW POINT SIN DOT */
216     case 0x05C4: /* HEBREW MARK UPPER DOT */
217     case 0xA731: /* LATIN LETTER SMALL CAPITAL S */
218     case 0xA771: /* LATIN SMALL LETTER DUM */
219     case 0xA789: /* MODIFIER LETTER COLON */
220     case 0xFE14: /* PRESENTATION FORM FOR VERTICAL SEMICOLON */
221     case 0xFE15: /* PRESENTATION FORM FOR VERTICAL EXCLAMATION MARK */
222     case 0xFE3F: /* PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET */
223     case 0xFE5D: /* SMALL LEFT TORTOISE SHELL BRACKET */
224     case 0xFE5E: /* SMALL RIGHT TORTOISE SHELL BRACKET */
225     case 0xFF0E: /* FULLWIDTH FULL STOP */
226     case 0xFF0F: /* FULL WIDTH SOLIDUS */
227     case 0xFF61: /* HALFWIDTH IDEOGRAPHIC FULL STOP */
228     case 0xFFFC: /* OBJECT REPLACEMENT CHARACTER */
229     case 0xFFFD: /* REPLACEMENT CHARACTER */
230     case 0x1F50F: /* LOCK WITH INK PEN */
231     case 0x1F510: /* CLOSED LOCK WITH KEY */
232     case 0x1F511: /* KEY */
233     case 0x1F512: /* LOCK */
234     case 0x1F513: /* OPEN LOCK */
235         return true;
236     case 0x0307: /* COMBINING DOT ABOVE */
237         return previousCodePoint == 0x0237 /* LATIN SMALL LETTER DOTLESS J */
238             || previousCodePoint == 0x0131 /* LATIN SMALL LETTER DOTLESS I */
239             || previousCodePoint == 0x05D5; /* HEBREW LETTER VAV */
240     case 0x0548: /* ARMENIAN CAPITAL LETTER VO */
241     case 0x054D: /* ARMENIAN CAPITAL LETTER SEH */
242     case 0x0578: /* ARMENIAN SMALL LETTER VO */
243     case 0x057D: /* ARMENIAN SMALL LETTER SEH */
244         return previousCodePoint
245             &amp;&amp; !isASCIIDigitOrValidHostCharacter(previousCodePoint.value())
246             &amp;&amp; !isArmenianScriptCharacter(previousCodePoint.value());
247     case &#39;.&#39;:
248         return false;
249     default:
250         return previousCodePoint
251             &amp;&amp; isArmenianLookalikeCharacter(previousCodePoint.value())
252             &amp;&amp; !(isArmenianScriptCharacter(charCode) || isASCIIDigitOrValidHostCharacter(charCode));
253     }
254 }
255 
256 void whiteListIDNScript(const char* scriptName)
257 {
258     int32_t script = u_getPropertyValueEnum(UCHAR_SCRIPT, scriptName);
259     if (script &gt;= 0 &amp;&amp; script &lt; USCRIPT_CODE_LIMIT) {
260         size_t index = script / 32;
261         uint32_t mask = 1 &lt;&lt; (script % 32);
262         IDNScriptWhiteList[index] |= mask;
263     }
264 }
265 
266 void initializeDefaultIDNScriptWhiteList()
267 {
268     const char* defaultIDNScriptWhiteList[20] = {
269         &quot;Common&quot;,
270         &quot;Inherited&quot;,
271         &quot;Arabic&quot;,
272         &quot;Armenian&quot;,
273         &quot;Bopomofo&quot;,
274         &quot;Canadian_Aboriginal&quot;,
275         &quot;Devanagari&quot;,
276         &quot;Deseret&quot;,
277         &quot;Gujarati&quot;,
278         &quot;Gurmukhi&quot;,
279         &quot;Hangul&quot;,
280         &quot;Han&quot;,
281         &quot;Hebrew&quot;,
282         &quot;Hiragana&quot;,
283         &quot;Katakana_Or_Hiragana&quot;,
284         &quot;Katakana&quot;,
285         &quot;Latin&quot;,
286         &quot;Tamil&quot;,
287         &quot;Thai&quot;,
288         &quot;Yi&quot;,
289     };
290     for (const char* scriptName : defaultIDNScriptWhiteList)
291         whiteListIDNScript(scriptName);
292 }
293 
294 static bool allCharactersInIDNScriptWhiteList(const UChar* buffer, int32_t length)
295 {
296     loadIDNScriptWhiteList();
297     int32_t i = 0;
298     Optional&lt;UChar32&gt; previousCodePoint;
299     while (i &lt; length) {
300         UChar32 c;
301         U16_NEXT(buffer, i, length, c)
302         UErrorCode error = U_ZERO_ERROR;
303         UScriptCode script = uscript_getScript(c, &amp;error);
304         if (error != U_ZERO_ERROR) {
305             LOG_ERROR(&quot;got ICU error while trying to look at scripts: %d&quot;, error);
306             return false;
307         }
308         if (script &lt; 0) {
309             LOG_ERROR(&quot;got negative number for script code from ICU: %d&quot;, script);
310             return false;
311         }
312         if (script &gt;= USCRIPT_CODE_LIMIT)
313             return false;
314 
315         size_t index = script / 32;
316         uint32_t mask = 1 &lt;&lt; (script % 32);
317         if (!(IDNScriptWhiteList[index] &amp; mask))
318             return false;
319 
320         if (isLookalikeCharacter(previousCodePoint, c))
321             return false;
322         previousCodePoint = c;
323     }
324     return true;
325 }
326 
327 static bool isSecondLevelDomainNameAllowedByTLDRules(const UChar* buffer, int32_t length, const WTF::Function&lt;bool(UChar)&gt;&amp; characterIsAllowed)
328 {
329     ASSERT(length &gt; 0);
330 
331     for (int32_t i = length - 1; i &gt;= 0; --i) {
332         UChar ch = buffer[i];
333 
334         if (characterIsAllowed(ch))
335             continue;
336 
337         // Only check the second level domain. Lower level registrars may have different rules.
338         if (ch == &#39;.&#39;)
339             break;
340 
341         return false;
342     }
343     return true;
344 }
345 
346 #define CHECK_RULES_IF_SUFFIX_MATCHES(suffix, function) \
347     { \
348         static const int32_t suffixLength = sizeof(suffix) / sizeof(suffix[0]); \
349         if (length &gt; suffixLength &amp;&amp; !memcmp(buffer + length - suffixLength, suffix, sizeof(suffix))) \
350             return isSecondLevelDomainNameAllowedByTLDRules(buffer, length - suffixLength, function); \
351     }
352 
353 static bool isRussianDomainNameCharacter(UChar ch)
354 {
355     // Only modern Russian letters, digits and dashes are allowed.
356     return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044f) || ch == 0x0451 || isASCIIDigit(ch) || ch == &#39;-&#39;;
357 }
358 
359 static bool allCharactersAllowedByTLDRules(const UChar* buffer, int32_t length)
360 {
361     // Skip trailing dot for root domain.
362     if (buffer[length - 1] == &#39;.&#39;)
363         length--;
364 
365     // http://cctld.ru/files/pdf/docs/rules_ru-rf.pdf
366     static const UChar cyrillicRF[] = {
367         &#39;.&#39;,
368         0x0440, // CYRILLIC SMALL LETTER ER
369         0x0444, // CYRILLIC SMALL LETTER EF
370     };
371     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicRF, isRussianDomainNameCharacter);
372 
373     // http://rusnames.ru/rules.pl
374     static const UChar cyrillicRUS[] = {
375         &#39;.&#39;,
376         0x0440, // CYRILLIC SMALL LETTER ER
377         0x0443, // CYRILLIC SMALL LETTER U
378         0x0441, // CYRILLIC SMALL LETTER ES
379     };
380     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicRUS, isRussianDomainNameCharacter);
381 
382     // http://ru.faitid.org/projects/moscow/documents/moskva/idn
383     static const UChar cyrillicMOSKVA[] = {
384         &#39;.&#39;,
385         0x043C, // CYRILLIC SMALL LETTER EM
386         0x043E, // CYRILLIC SMALL LETTER O
387         0x0441, // CYRILLIC SMALL LETTER ES
388         0x043A, // CYRILLIC SMALL LETTER KA
389         0x0432, // CYRILLIC SMALL LETTER VE
390         0x0430, // CYRILLIC SMALL LETTER A
391     };
392     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicMOSKVA, isRussianDomainNameCharacter);
393 
394     // http://www.dotdeti.ru/foruser/docs/regrules.php
395     static const UChar cyrillicDETI[] = {
396         &#39;.&#39;,
397         0x0434, // CYRILLIC SMALL LETTER DE
398         0x0435, // CYRILLIC SMALL LETTER IE
399         0x0442, // CYRILLIC SMALL LETTER TE
400         0x0438, // CYRILLIC SMALL LETTER I
401     };
402     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicDETI, isRussianDomainNameCharacter);
403 
404     // http://corenic.org - rules not published. The word is Russian, so only allowing Russian at this time,
405     // although we may need to revise the checks if this ends up being used with other languages spoken in Russia.
406     static const UChar cyrillicONLAYN[] = {
407         &#39;.&#39;,
408         0x043E, // CYRILLIC SMALL LETTER O
409         0x043D, // CYRILLIC SMALL LETTER EN
410         0x043B, // CYRILLIC SMALL LETTER EL
411         0x0430, // CYRILLIC SMALL LETTER A
412         0x0439, // CYRILLIC SMALL LETTER SHORT I
413         0x043D, // CYRILLIC SMALL LETTER EN
414     };
415     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicONLAYN, isRussianDomainNameCharacter);
416 
417     // http://corenic.org - same as above.
418     static const UChar cyrillicSAYT[] = {
419         &#39;.&#39;,
420         0x0441, // CYRILLIC SMALL LETTER ES
421         0x0430, // CYRILLIC SMALL LETTER A
422         0x0439, // CYRILLIC SMALL LETTER SHORT I
423         0x0442, // CYRILLIC SMALL LETTER TE
424     };
425     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicSAYT, isRussianDomainNameCharacter);
426 
427     // http://pir.org/products/opr-domain/ - rules not published. According to the registry site,
428     // the intended audience is &quot;Russian and other Slavic-speaking markets&quot;.
429     // Chrome appears to only allow Russian, so sticking with that for now.
430     static const UChar cyrillicORG[] = {
431         &#39;.&#39;,
432         0x043E, // CYRILLIC SMALL LETTER O
433         0x0440, // CYRILLIC SMALL LETTER ER
434         0x0433, // CYRILLIC SMALL LETTER GHE
435     };
436     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicORG, isRussianDomainNameCharacter);
437 
438     // http://cctld.by/rules.html
439     static const UChar cyrillicBEL[] = {
440         &#39;.&#39;,
441         0x0431, // CYRILLIC SMALL LETTER BE
442         0x0435, // CYRILLIC SMALL LETTER IE
443         0x043B, // CYRILLIC SMALL LETTER EL
444     };
445     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicBEL, [](UChar ch) {
446         // Russian and Byelorussian letters, digits and dashes are allowed.
447         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044f) || ch == 0x0451 || ch == 0x0456 || ch == 0x045E || ch == 0x2019 || isASCIIDigit(ch) || ch == &#39;-&#39;;
448     });
449 
450     // http://www.nic.kz/docs/poryadok_vnedreniya_kaz_ru.pdf
451     static const UChar cyrillicKAZ[] = {
452         &#39;.&#39;,
453         0x049B, // CYRILLIC SMALL LETTER KA WITH DESCENDER
454         0x0430, // CYRILLIC SMALL LETTER A
455         0x0437, // CYRILLIC SMALL LETTER ZE
456     };
457     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicKAZ, [](UChar ch) {
458         // Kazakh letters, digits and dashes are allowed.
459         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044f) || ch == 0x0451 || ch == 0x04D9 || ch == 0x0493 || ch == 0x049B || ch == 0x04A3 || ch == 0x04E9 || ch == 0x04B1 || ch == 0x04AF || ch == 0x04BB || ch == 0x0456 || isASCIIDigit(ch) || ch == &#39;-&#39;;
460     });
461 
462     // http://uanic.net/docs/documents-ukr/Rules%20of%20UKR_v4.0.pdf
463     static const UChar cyrillicUKR[] = {
464         &#39;.&#39;,
465         0x0443, // CYRILLIC SMALL LETTER U
466         0x043A, // CYRILLIC SMALL LETTER KA
467         0x0440, // CYRILLIC SMALL LETTER ER
468     };
469     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicUKR, [](UChar ch) {
470         // Russian and Ukrainian letters, digits and dashes are allowed.
471         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044f) || ch == 0x0451 || ch == 0x0491 || ch == 0x0404 || ch == 0x0456 || ch == 0x0457 || isASCIIDigit(ch) || ch == &#39;-&#39;;
472     });
473 
474     // http://www.rnids.rs/data/DOKUMENTI/idn-srb-policy-termsofuse-v1.4-eng.pdf
475     static const UChar cyrillicSRB[] = {
476         &#39;.&#39;,
477         0x0441, // CYRILLIC SMALL LETTER ES
478         0x0440, // CYRILLIC SMALL LETTER ER
479         0x0431, // CYRILLIC SMALL LETTER BE
480     };
481     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicSRB, [](UChar ch) {
482         // Serbian letters, digits and dashes are allowed.
483         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x0438) || (ch &gt;= 0x043A &amp;&amp; ch &lt;= 0x0448) || ch == 0x0452 || ch == 0x0458 || ch == 0x0459 || ch == 0x045A || ch == 0x045B || ch == 0x045F || isASCIIDigit(ch) || ch == &#39;-&#39;;
484     });
485 
486     // http://marnet.mk/doc/pravilnik-mk-mkd.pdf
487     static const UChar cyrillicMKD[] = {
488         &#39;.&#39;,
489         0x043C, // CYRILLIC SMALL LETTER EM
490         0x043A, // CYRILLIC SMALL LETTER KA
491         0x0434, // CYRILLIC SMALL LETTER DE
492     };
493     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicMKD, [](UChar ch) {
494         // Macedonian letters, digits and dashes are allowed.
495         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x0438) || (ch &gt;= 0x043A &amp;&amp; ch &lt;= 0x0448) || ch == 0x0453 || ch == 0x0455 || ch == 0x0458 || ch == 0x0459 || ch == 0x045A || ch == 0x045C || ch == 0x045F || isASCIIDigit(ch) || ch == &#39;-&#39;;
496     });
497 
498     // https://www.mon.mn/cs/
499     static const UChar cyrillicMON[] = {
500         &#39;.&#39;,
501         0x043C, // CYRILLIC SMALL LETTER EM
502         0x043E, // CYRILLIC SMALL LETTER O
503         0x043D, // CYRILLIC SMALL LETTER EN
504     };
505     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicMON, [](UChar ch) {
506         // Mongolian letters, digits and dashes are allowed.
507         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044f) || ch == 0x0451 || ch == 0x04E9 || ch == 0x04AF || isASCIIDigit(ch) || ch == &#39;-&#39;;
508     });
509 
510     // https://www.icann.org/sites/default/files/packages/lgr/lgr-second-level-bulgarian-30aug16-en.html
511     static const UChar cyrillicBG[] = {
512         &#39;.&#39;,
513         0x0431, // CYRILLIC SMALL LETTER BE
514         0x0433 // CYRILLIC SMALL LETTER GHE
515     };
516     CHECK_RULES_IF_SUFFIX_MATCHES(cyrillicBG, [](UChar ch) {
517         return (ch &gt;= 0x0430 &amp;&amp; ch &lt;= 0x044A) || ch == 0x044C || (ch &gt;= 0x044E &amp;&amp; ch &lt;= 0x0450) || ch == 0x045D || isASCIIDigit(ch) || ch == &#39;-&#39;;
518     });
519 
520     // Not a known top level domain with special rules.
521     return false;
522 }
523 
524 // Return value of null means no mapping is necessary.
525 Optional&lt;String&gt; mapHostName(const String&amp; hostName, const Optional&lt;URLDecodeFunction&gt;&amp; decodeFunction)
526 {
527     if (hostName.length() &gt; hostNameBufferLength)
528         return String();
529 
530     if (!hostName.length())
531         return String();
532 
533     String string;
534     if (decodeFunction &amp;&amp; string.contains(&#39;%&#39;))
535         string = (*decodeFunction)(hostName);
536     else
537         string = hostName;
538 
539     unsigned length = string.length();
540 
541     auto sourceBuffer = string.charactersWithNullTermination();
542 
543     UChar destinationBuffer[hostNameBufferLength];
544     UErrorCode uerror = U_ZERO_ERROR;
545     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
546     int32_t numCharactersConverted = (decodeFunction ? uidna_nameToASCII : uidna_nameToUnicode)(&amp;URLParser::internationalDomainNameTranscoder(), sourceBuffer.data(), length, destinationBuffer, hostNameBufferLength, &amp;processingDetails, &amp;uerror);
547     if (length &amp;&amp; (U_FAILURE(uerror) || processingDetails.errors))
548         return nullopt;
549 
550     if (numCharactersConverted == static_cast&lt;int32_t&gt;(length) &amp;&amp; !memcmp(sourceBuffer.data(), destinationBuffer, length * sizeof(UChar)))
551         return String();
552 
553     if (!decodeFunction &amp;&amp; !allCharactersInIDNScriptWhiteList(destinationBuffer, numCharactersConverted) &amp;&amp; !allCharactersAllowedByTLDRules(destinationBuffer, numCharactersConverted))
554         return String();
555 
556     return String(destinationBuffer, numCharactersConverted);
557 }
558 
559 using MappingRangesVector = Optional&lt;Vector&lt;std::tuple&lt;unsigned, unsigned, String&gt;&gt;&gt;;
560 
561 static void collectRangesThatNeedMapping(const String&amp; string, unsigned location, unsigned length, MappingRangesVector&amp; array, const Optional&lt;URLDecodeFunction&gt;&amp; decodeFunction)
562 {
563     // Generally, we want to optimize for the case where there is one host name that does not need mapping.
564     // Therefore, we use null to indicate no mapping here and an empty array to indicate error.
565 
566     String substring = string.substringSharingImpl(location, length);
567     Optional&lt;String&gt; host = mapHostName(substring, decodeFunction);
568 
569     if (host &amp;&amp; !*host)
570         return;
571 
572     if (!array)
573         array = Vector&lt;std::tuple&lt;unsigned, unsigned, String&gt;&gt;();
574 
575     if (host)
576         array-&gt;constructAndAppend(location, length, *host);
577 }
578 
579 static void applyHostNameFunctionToMailToURLString(const String&amp; string, const Optional&lt;URLDecodeFunction&gt;&amp; decodeFunction, MappingRangesVector&amp; array)
580 {
581     // In a mailto: URL, host names come after a &#39;@&#39; character and end with a &#39;&gt;&#39; or &#39;,&#39; or &#39;?&#39; character.
582     // Skip quoted strings so that characters in them don&#39;t confuse us.
583     // When we find a &#39;?&#39; character, we are past the part of the URL that contains host names.
584 
585     unsigned stringLength = string.length();
586     unsigned current = 0;
587 
588     while (1) {
589         // Find start of host name or of quoted string.
590         auto hostNameOrStringStart = string.find([](UChar ch) {
591             return ch == &#39;&quot;&#39; || ch == &#39;@&#39; || ch == &#39;?&#39;;
592         }, current);
593         if (hostNameOrStringStart == notFound)
594             return;
595 
596         UChar c = string[hostNameOrStringStart];
597         current = hostNameOrStringStart + 1;
598 
599         if (c == &#39;?&#39;)
600             return;
601 
602         if (c == &#39;@&#39;) {
603             // Find end of host name.
604             unsigned hostNameStart = current;
605             auto hostNameEnd = string.find([](UChar ch) {
606                 return ch == &#39;&gt;&#39; || ch == &#39;,&#39; || ch == &#39;?&#39;;
607             }, current);
608 
609             bool done;
610             if (hostNameEnd == notFound) {
611                 hostNameEnd = stringLength;
612                 done = true;
613             } else {
614                 current = hostNameEnd;
615                 done = false;
616             }
617 
618             // Process host name range.
619             collectRangesThatNeedMapping(string, hostNameStart, hostNameEnd - hostNameStart, array, decodeFunction);
620 
621             if (done)
622                 return;
623         } else {
624             // Skip quoted string.
625             ASSERT(c == &#39;&quot;&#39;);
626             while (1) {
627                 auto escapedCharacterOrStringEnd = string.find([](UChar ch) {
628                     return ch == &#39;&quot;&#39; || ch == &#39;\\&#39;;
629                 }, current);
630                 if (escapedCharacterOrStringEnd == notFound)
631                     return;
632 
633                 c = string[escapedCharacterOrStringEnd];
634                 current = escapedCharacterOrStringEnd + 1;
635 
636                 // If we are the end of the string, then break from the string loop back to the host name loop.
637                 if (c == &#39;&quot;&#39;)
638                     break;
639 
640                 // Skip escaped character.
641                 ASSERT(c == &#39;\\&#39;);
642                 if (current == stringLength)
643                     return;
644 
645                 ++current;
646             }
647         }
648     }
649 }
650 
651 static void applyHostNameFunctionToURLString(const String&amp; string, const Optional&lt;URLDecodeFunction&gt;&amp; decodeFunction, MappingRangesVector&amp; array)
652 {
653     // Find hostnames. Too bad we can&#39;t use any real URL-parsing code to do this,
654     // but we have to do it before doing all the %-escaping, and this is the only
655     // code we have that parses mailto URLs anyway.
656 
657     // Maybe we should implement this using a character buffer instead?
658 
659     if (protocolIs(string, &quot;mailto&quot;)) {
660         applyHostNameFunctionToMailToURLString(string, decodeFunction, array);
661         return;
662     }
663 
664     // Find the host name in a hierarchical URL.
665     // It comes after a &quot;://&quot; sequence, with scheme characters preceding.
666     // If ends with the end of the string or a &quot;:&quot;, &quot;/&quot;, or a &quot;?&quot;.
667     // If there is a &quot;@&quot; character, the host part is just the part after the &quot;@&quot;.
668     static const char* separator = &quot;://&quot;;
669     auto separatorIndex = string.find(separator);
670     if (separatorIndex == notFound)
671         return;
672 
673     unsigned authorityStart = separatorIndex + strlen(separator);
674 
675     // Check that all characters before the :// are valid scheme characters.
676     auto invalidSchemeCharacter = string.substringSharingImpl(0, separatorIndex).find([](UChar ch) {
677         static const char* allowedCharacters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-.&quot;;
678         static size_t length = strlen(allowedCharacters);
679         for (size_t i = 0; i &lt; length; ++i) {
680             if (allowedCharacters[i] == ch)
681                 return false;
682         }
683         return true;
684     });
685 
686     if (invalidSchemeCharacter != notFound)
687         return;
688 
689     unsigned stringLength = string.length();
690 
691     // Find terminating character.
692     auto hostNameTerminator = string.find([](UChar ch) {
693         static const char* terminatingCharacters = &quot;:/?#&quot;;
694         static size_t length = strlen(terminatingCharacters);
695         for (size_t i = 0; i &lt; length; ++i) {
696             if (terminatingCharacters[i] == ch)
697                 return true;
698         }
699         return false;
700     }, authorityStart);
701     unsigned hostNameEnd = hostNameTerminator == notFound ? stringLength : hostNameTerminator;
702 
703     // Find &quot;@&quot; for the start of the host name.
704     auto userInfoTerminator = string.substringSharingImpl(0, hostNameEnd).find(&#39;@&#39;, authorityStart);
705     unsigned hostNameStart = userInfoTerminator == notFound ? authorityStart : userInfoTerminator + 1;
706 
707     collectRangesThatNeedMapping(string, hostNameStart, hostNameEnd - hostNameStart, array, decodeFunction);
708 }
709 
710 String mapHostNames(const String&amp; string, const Optional&lt;URLDecodeFunction&gt;&amp; decodeFunction)
711 {
712     // Generally, we want to optimize for the case where there is one host name that does not need mapping.
713 
714     if (decodeFunction &amp;&amp; string.isAllASCII())
715         return string;
716 
717     // Make a list of ranges that actually need mapping.
718     MappingRangesVector hostNameRanges;
719     applyHostNameFunctionToURLString(string, decodeFunction, hostNameRanges);
720     if (!hostNameRanges)
721         return string;
722 
723     if (hostNameRanges-&gt;isEmpty())
724         return { };
725 
726     // Do the mapping.
727     String result = string;
728     while (!hostNameRanges-&gt;isEmpty()) {
729         unsigned location, length;
730         String mappedHostName;
731         std::tie(location, length, mappedHostName) = hostNameRanges-&gt;takeLast();
732         result = result.replace(location, length, mappedHostName);
733     }
734     return result;
735 }
736 
737 static String escapeUnsafeCharacters(const String&amp; sourceBuffer)
738 {
739     unsigned length = sourceBuffer.length();
740 
741     Optional&lt;UChar32&gt; previousCodePoint;
742 
743     unsigned i;
744     for (i = 0; i &lt; length; ) {
745         UChar32 c = sourceBuffer.characterStartingAt(i);
746         if (isLookalikeCharacter(previousCodePoint, sourceBuffer.characterStartingAt(i)))
747             break;
748         previousCodePoint = c;
749         i += U16_LENGTH(c);
750     }
751 
752     if (i == length)
753         return sourceBuffer;
754 
755     Vector&lt;UChar, urlBytesBufferLength&gt; outBuffer;
756 
757     outBuffer.grow(i);
758     if (sourceBuffer.is8Bit())
759         StringImpl::copyCharacters(outBuffer.data(), sourceBuffer.characters8(), i);
760     else
761         StringImpl::copyCharacters(outBuffer.data(), sourceBuffer.characters16(), i);
762 
763     for (; i &lt; length; ) {
764         UChar32 c = sourceBuffer.characterStartingAt(i);
765         unsigned characterLength = U16_LENGTH(c);
766         if (isLookalikeCharacter(previousCodePoint, c)) {
767             uint8_t utf8Buffer[4];
768             size_t offset = 0;
769             UBool failure = false;
770             U8_APPEND(utf8Buffer, offset, 4, c, failure)
771             ASSERT(!failure);
772 
773             for (size_t j = 0; j &lt; offset; ++j) {
774                 outBuffer.append(&#39;%&#39;);
775                 outBuffer.append(upperNibbleToASCIIHexDigit(utf8Buffer[j]));
776                 outBuffer.append(lowerNibbleToASCIIHexDigit(utf8Buffer[j]));
777             }
778         } else {
779             for (unsigned j = 0; j &lt; characterLength; ++j)
780                 outBuffer.append(sourceBuffer[i + j]);
781         }
782         previousCodePoint = c;
783         i += characterLength;
784         }
785 
786     return String::adopt(WTFMove(outBuffer));
787 }
788 
789 String userVisibleURL(const CString&amp; url)
790 {
791     auto* before = reinterpret_cast&lt;const unsigned char*&gt;(url.data());
792     int length = url.length();
793 
794     if (!length)
795         return { };
796 
797     bool mayNeedHostNameDecoding = false;
798 
799     Checked&lt;int, RecordOverflow&gt; bufferLength = length;
800     bufferLength = bufferLength * 3 + 1; // The buffer should be large enough to %-escape every character.
801     if (bufferLength.hasOverflowed())
802         return { };
803     Vector&lt;char, urlBytesBufferLength&gt; after(bufferLength.unsafeGet());
804 
805     char* q = after.data();
806     {
807         const unsigned char* p = before;
808         for (int i = 0; i &lt; length; i++) {
809             unsigned char c = p[i];
810             // unescape escape sequences that indicate bytes greater than 0x7f
811             if (c == &#39;%&#39; &amp;&amp; i + 2 &lt; length &amp;&amp; isASCIIHexDigit(p[i + 1]) &amp;&amp; isASCIIHexDigit(p[i + 2])) {
812                 auto u = toASCIIHexValue(p[i + 1], p[i + 2]);
813                 if (u &gt; 0x7f) {
814                     // unescape
815                     *q++ = u;
816                 } else {
817                     // do not unescape
818                     *q++ = p[i];
819                     *q++ = p[i + 1];
820                     *q++ = p[i + 2];
821                 }
822                 i += 2;
823             } else {
824                 *q++ = c;
825 
826                 // Check for &quot;xn--&quot; in an efficient, non-case-sensitive, way.
827                 if (c == &#39;-&#39; &amp;&amp; i &gt;= 3 &amp;&amp; !mayNeedHostNameDecoding &amp;&amp; (q[-4] | 0x20) == &#39;x&#39; &amp;&amp; (q[-3] | 0x20) == &#39;n&#39; &amp;&amp; q[-2] == &#39;-&#39;)
828                     mayNeedHostNameDecoding = true;
829             }
830         }
831         *q = &#39;\0&#39;;
832     }
833 
834     // Check string to see if it can be converted to display using UTF-8
835     String result = String::fromUTF8(after.data());
836     if (!result) {
837         // Could not convert to UTF-8.
838         // Convert characters greater than 0x7f to escape sequences.
839         // Shift current string to the end of the buffer
840         // then we will copy back bytes to the start of the buffer
841         // as we convert.
842         int afterlength = q - after.data();
843         char* p = after.data() + bufferLength.unsafeGet() - afterlength - 1;
844         memmove(p, after.data(), afterlength + 1); // copies trailing &#39;\0&#39;
845         char* q = after.data();
846         while (*p) {
847             unsigned char c = *p;
848             if (c &gt; 0x7f) {
849                 *q++ = &#39;%&#39;;
850                 *q++ = upperNibbleToASCIIHexDigit(c);
851                 *q++ = lowerNibbleToASCIIHexDigit(c);
852             } else
853                 *q++ = *p;
854             p++;
855         }
856         *q = &#39;\0&#39;;
857         // Note: after.data() points to a null-terminated, pure ASCII string.
858         result = String::fromUTF8(after.data());
859         ASSERT(!!result);
860     }
861 
862     // Note: result is UTFâ€“16 string, created from either a valid UTF-8 string,
863     //       or a pure ASCII string (where all bytes with the high bit set are
864     //       percent-encoded).
865 
866     if (mayNeedHostNameDecoding) {
867         // FIXME: Is it good to ignore the failure of mapHostNames and keep result intact?
868         auto mappedResult = mapHostNames(result, nullopt);
869         if (!!mappedResult)
870             result = mappedResult;
871     }
872 
873     return escapeUnsafeCharacters(normalizedNFC(result));
874 }
875 
876 } // namespace URLHelpers
877 } // namespace WTF
    </pre>
  </body>
</html>