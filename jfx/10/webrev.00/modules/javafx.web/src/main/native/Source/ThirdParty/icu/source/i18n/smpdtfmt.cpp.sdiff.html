<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/smpdtfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="simpletz.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="timezone.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/smpdtfmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 213     -1,  // &#39;Q&#39; - UDAT_QUARTER_FIELD (1-4?)
 214     -1,  // &#39;q&#39; - UDAT_STANDALONE_QUARTER_FIELD
 215     -1,  // &#39;V&#39; - UDAT_TIMEZONE_SPECIAL_FIELD
 216     -1,  // &#39;U&#39; - UDAT_YEAR_NAME_FIELD
 217     -1,  // &#39;O&#39; - UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD
 218     -1,  // &#39;X&#39; - UDAT_TIMEZONE_ISO_FIELD
 219     -1,  // &#39;x&#39; - UDAT_TIMEZONE_ISO_LOCAL_FIELD
 220     -1,  // &#39;r&#39; - UDAT_RELATED_YEAR_FIELD
 221 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
 222     -1,  // &#39;:&#39; - UDAT_TIME_SEPARATOR_FIELD
 223 #else
 224     -1,  // (no pattern character currently) - UDAT_TIME_SEPARATOR_FIELD
 225 #endif
 226 };
 227 
 228 // When calendar uses hebr numbering (i.e. he@calendar=hebrew),
 229 // offset the years within the current millenium down to 1-999
 230 static const int32_t HEBREW_CAL_CUR_MILLENIUM_START_YEAR = 5000;
 231 static const int32_t HEBREW_CAL_CUR_MILLENIUM_END_YEAR = 6000;
 232 
<span class="line-modified"> 233 static UMutex LOCK = U_MUTEX_INITIALIZER;</span>



 234 
 235 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleDateFormat)
 236 
 237 SimpleDateFormat::NSOverride::~NSOverride() {
 238     if (snf != NULL) {
 239         snf-&gt;removeRef();
 240     }
 241 }
 242 
 243 
 244 void SimpleDateFormat::NSOverride::free() {
 245     NSOverride *cur = this;
 246     while (cur) {
<span class="line-modified"> 247         NSOverride *next = cur-&gt;next;</span>
 248         delete cur;
<span class="line-modified"> 249         cur = next;</span>
 250     }
 251 }
 252 
 253 // no matter what the locale&#39;s default number format looked like, we want
 254 // to modify it so that it doesn&#39;t use thousands separators, doesn&#39;t always
 255 // show the decimal point, and recognizes integers only when parsing
 256 static void fixNumberFormatForDates(NumberFormat &amp;nf) {
 257     nf.setGroupingUsed(FALSE);
 258     DecimalFormat* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(&amp;nf);
 259     if (decfmt != NULL) {
 260         decfmt-&gt;setDecimalSeparatorAlwaysShown(FALSE);
 261     }
 262     nf.setParseIntegerOnly(TRUE);
 263     nf.setMinimumFractionDigits(0); // To prevent &quot;Jan 1.00, 1997.00&quot;
 264 }
 265 
 266 static const SharedNumberFormat *createSharedNumberFormat(
 267         NumberFormat *nfToAdopt) {
 268     fixNumberFormatForDates(*nfToAdopt);
 269     const SharedNumberFormat *result = new SharedNumberFormat(nfToAdopt);
</pre>
<hr />
<pre>
 839     initialize(locale, status);
 840 }
 841 
 842 //----------------------------------------------------------------------
 843 
 844 Calendar*
 845 SimpleDateFormat::initializeCalendar(TimeZone* adoptZone, const Locale&amp; locale, UErrorCode&amp; status)
 846 {
 847     if(!U_FAILURE(status)) {
 848         fCalendar = Calendar::createInstance(adoptZone?adoptZone:TimeZone::createDefault(), locale, status);
 849     }
 850     return fCalendar;
 851 }
 852 
 853 void
 854 SimpleDateFormat::initialize(const Locale&amp; locale,
 855                              UErrorCode&amp; status)
 856 {
 857     if (U_FAILURE(status)) return;
 858 











 859     // We don&#39;t need to check that the row count is &gt;= 1, since all 2d arrays have at
 860     // least one row
 861     fNumberFormat = NumberFormat::createInstance(locale, status);
 862     if (fNumberFormat != NULL &amp;&amp; U_SUCCESS(status))
 863     {
 864         fixNumberFormatForDates(*fNumberFormat);
 865         //fNumberFormat-&gt;setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse
 866 
 867         initNumberFormatters(locale, status);
 868         initFastNumberFormatters(status);
 869 
 870     }
 871     else if (U_SUCCESS(status))
 872     {
 873         status = U_MISSING_RESOURCE_ERROR;
 874     }
<span class="line-removed"> 875 </span>
<span class="line-removed"> 876     parsePattern();</span>
 877 }
 878 
 879 /* Initialize the fields we use to disambiguate ambiguous years. Separate
 880  * so we can call it from readObject().
 881  */
 882 void SimpleDateFormat::initializeDefaultCentury()
 883 {
 884   if(fCalendar) {
 885     fHaveDefaultCentury = fCalendar-&gt;haveDefaultCentury();
 886     if(fHaveDefaultCentury) {
 887       fDefaultCenturyStart = fCalendar-&gt;defaultCenturyStart();
 888       fDefaultCenturyStartYear = fCalendar-&gt;defaultCenturyStartYear();
 889     } else {
 890       fDefaultCenturyStart = DBL_MIN;
 891       fDefaultCenturyStartYear = -1;
 892     }
 893   }
 894 }
 895 
 896 /*
</pre>
<hr />
<pre>
1237     delete fFastNumberFormatters[SMPDTFMT_NF_2x10];
1238     delete fFastNumberFormatters[SMPDTFMT_NF_3x10];
1239     delete fFastNumberFormatters[SMPDTFMT_NF_4x10];
1240     delete fFastNumberFormatters[SMPDTFMT_NF_2x2];
1241     fFastNumberFormatters[SMPDTFMT_NF_1x10] = nullptr;
1242     fFastNumberFormatters[SMPDTFMT_NF_2x10] = nullptr;
1243     fFastNumberFormatters[SMPDTFMT_NF_3x10] = nullptr;
1244     fFastNumberFormatters[SMPDTFMT_NF_4x10] = nullptr;
1245     fFastNumberFormatters[SMPDTFMT_NF_2x2] = nullptr;
1246 }
1247 
1248 
1249 void
1250 SimpleDateFormat::initNumberFormatters(const Locale &amp;locale,UErrorCode &amp;status) {
1251     if (U_FAILURE(status)) {
1252         return;
1253     }
1254     if ( fDateOverride.isBogus() &amp;&amp; fTimeOverride.isBogus() ) {
1255         return;
1256     }
<span class="line-modified">1257     umtx_lock(&amp;LOCK);</span>
1258     if (fSharedNumberFormatters == NULL) {
1259         fSharedNumberFormatters = allocSharedNumberFormatters();
1260         if (fSharedNumberFormatters == NULL) {
1261             status = U_MEMORY_ALLOCATION_ERROR;
1262         }
1263     }
<span class="line-modified">1264     umtx_unlock(&amp;LOCK);</span>
1265 
1266     if (U_FAILURE(status)) {
1267         return;
1268     }
1269 
1270     processOverrideString(locale,fDateOverride,kOvrStrDate,status);
1271     processOverrideString(locale,fTimeOverride,kOvrStrTime,status);
1272 }
1273 
1274 void
1275 SimpleDateFormat::processOverrideString(const Locale &amp;locale, const UnicodeString &amp;str, int8_t type, UErrorCode &amp;status) {
1276     if (str.isBogus() || U_FAILURE(status)) {
1277         return;
1278     }
1279 
1280     int32_t start = 0;
1281     int32_t len;
1282     UnicodeString nsName;
1283     UnicodeString ovrField;
1284     UBool moreToProcess = TRUE;
</pre>
<hr />
<pre>
1287     while (moreToProcess) {
1288         int32_t delimiterPosition = str.indexOf((UChar)ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE,start);
1289         if (delimiterPosition == -1) {
1290             moreToProcess = FALSE;
1291             len = str.length() - start;
1292         } else {
1293             len = delimiterPosition - start;
1294         }
1295         UnicodeString currentString(str,start,len);
1296         int32_t equalSignPosition = currentString.indexOf((UChar)ULOC_KEYWORD_ASSIGN_UNICODE,0);
1297         if (equalSignPosition == -1) { // Simple override string such as &quot;hebrew&quot;
1298             nsName.setTo(currentString);
1299             ovrField.setToBogus();
1300         } else { // Field specific override string such as &quot;y=hebrew&quot;
1301             nsName.setTo(currentString,equalSignPosition+1);
1302             ovrField.setTo(currentString,0,1); // We just need the first character.
1303         }
1304 
1305         int32_t nsNameHash = nsName.hashCode();
1306         // See if the numbering system is in the override list, if not, then add it.
<span class="line-modified">1307         NSOverride *cur = overrideList;</span>
1308         const SharedNumberFormat *snf = NULL;
1309         UBool found = FALSE;
<span class="line-modified">1310         while ( cur &amp;&amp; !found ) {</span>
<span class="line-modified">1311             if ( cur-&gt;hash == nsNameHash ) {</span>
<span class="line-modified">1312                 snf = cur-&gt;snf;</span>
1313                 found = TRUE;
1314             }
<span class="line-modified">1315             cur = cur-&gt;next;</span>
1316         }
1317 
1318         if (!found) {
1319            LocalPointer&lt;NSOverride&gt; cur(new NSOverride);
1320            if (!cur.isNull()) {
1321                char kw[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1322                uprv_strcpy(kw,&quot;numbers=&quot;);
1323                nsName.extract(0,len,kw+8,ULOC_KEYWORD_AND_VALUES_CAPACITY-8,US_INV);
1324 
1325                Locale ovrLoc(locale.getLanguage(),locale.getCountry(),locale.getVariant(),kw);
1326                cur-&gt;hash = nsNameHash;
1327                cur-&gt;next = overrideList;
1328                SharedObject::copyPtr(
1329                        createSharedNumberFormat(ovrLoc, status), cur-&gt;snf);
1330                if (U_FAILURE(status)) {
1331                    if (overrideList) {
1332                        overrideList-&gt;free();
1333                    }
1334                    return;
1335                }
</pre>
<hr />
<pre>
1761                 }
1762                 else if (patternCharIndex == UDAT_TIMEZONE_ISO_LOCAL_FIELD) {
1763                     if (count == 1) {
1764                         // &quot;x&quot;
1765                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT, tz, date, zoneString);
1766                     } else if (count == 2) {
1767                         // &quot;xx&quot;
1768                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED, tz, date, zoneString);
1769                     } else if (count == 3) {
1770                         // &quot;xxx&quot;
1771                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED, tz, date, zoneString);
1772                     } else if (count == 4) {
1773                         // &quot;xxxx&quot;
1774                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL, tz, date, zoneString);
1775                     } else if (count == 5) {
1776                         // &quot;xxxxx&quot;
1777                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL, tz, date, zoneString);
1778                     }
1779                 }
1780                 else {
<span class="line-modified">1781                     U_ASSERT(FALSE);</span>
1782                 }
1783             }
1784             appendTo += zoneString;
1785         }
1786         break;
1787 
1788     case UDAT_QUARTER_FIELD:
1789         if (count &gt;= 4)
1790             _appendSymbol(appendTo, value/3, fSymbols-&gt;fQuarters,
1791                           fSymbols-&gt;fQuartersCount);
1792         else if (count == 3)
1793             _appendSymbol(appendTo, value/3, fSymbols-&gt;fShortQuarters,
1794                           fSymbols-&gt;fShortQuartersCount);
1795         else
1796             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1797         break;
1798 
1799     case UDAT_STANDALONE_QUARTER_FIELD:
1800         if (count &gt;= 4)
1801             _appendSymbol(appendTo, value/3, fSymbols-&gt;fStandaloneQuarters,
</pre>
<hr />
<pre>
1807             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1808         break;
1809 
1810     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
1811     {
1812         const UnicodeString *toAppend = NULL;
1813         int32_t hour = cal.get(UCAL_HOUR_OF_DAY, status);
1814 
1815         // Note: &quot;midnight&quot; can be ambiguous as to whether it refers to beginning of day or end of day.
1816         // For ICU 57 output of &quot;midnight&quot; is temporarily suppressed.
1817 
1818         // For &quot;midnight&quot; and &quot;noon&quot;:
1819         // Time, as displayed, must be exactly noon or midnight.
1820         // This means minutes and seconds, if present, must be zero.
1821         if ((/*hour == 0 ||*/ hour == 12) &amp;&amp;
1822                 (!fHasMinute || cal.get(UCAL_MINUTE, status) == 0) &amp;&amp;
1823                 (!fHasSecond || cal.get(UCAL_SECOND, status) == 0)) {
1824             // Stealing am/pm value to use as our array index.
1825             // It works out: am/midnight are both 0, pm/noon are both 1,
1826             // 12 am is 12 midnight, and 12 pm is 12 noon.
<span class="line-modified">1827             int32_t value = cal.get(UCAL_AM_PM, status);</span>
1828 
1829             if (count &lt;= 3) {
<span class="line-modified">1830                 toAppend = &amp;fSymbols-&gt;fAbbreviatedDayPeriods[value];</span>
1831             } else if (count == 4 || count &gt; 5) {
<span class="line-modified">1832                 toAppend = &amp;fSymbols-&gt;fWideDayPeriods[value];</span>
1833             } else { // count == 5
<span class="line-modified">1834                 toAppend = &amp;fSymbols-&gt;fNarrowDayPeriods[value];</span>
1835             }
1836         }
1837 
1838         // toAppend is NULL if time isn&#39;t exactly midnight or noon (as displayed).
1839         // toAppend is bogus if time is midnight or noon, but no localized string exists.
1840         // In either case, fall back to am/pm.
1841         if (toAppend == NULL || toAppend-&gt;isBogus()) {
1842             // Reformat with identical arguments except ch, now changed to &#39;a&#39;.
1843             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1844                       handler, cal, status);
1845         } else {
1846             appendTo += *toAppend;
1847         }
1848 
1849         break;
1850     }
1851 
1852     case UDAT_FLEXIBLE_DAY_PERIOD_FIELD:
1853     {
1854         // TODO: Maybe fetch the DayperiodRules during initialization (instead of at the first
</pre>
<hr />
<pre>
1933             periodType == DayPeriodRules::DAYPERIOD_PM ||
1934             toAppend-&gt;isBogus()) {
1935             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1936                       handler, cal, status);
1937         }
1938         else {
1939             appendTo += *toAppend;
1940         }
1941 
1942         break;
1943     }
1944 
1945     // all of the other pattern symbols can be formatted as simple numbers with
1946     // appropriate zero padding
1947     default:
1948         zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1949         break;
1950     }
1951 #if !UCONFIG_NO_BREAK_ITERATION
1952     // if first field, check to see whether we need to and are able to titlecase it
<span class="line-modified">1953     if (fieldNum == 0 &amp;&amp; u_islower(appendTo.char32At(beginOffset)) &amp;&amp; fCapitalizationBrkIter != NULL) {</span>

1954         UBool titlecase = FALSE;
1955         switch (capitalizationContext) {
1956             case UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE:
1957                 titlecase = TRUE;
1958                 break;
1959             case UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU:
1960                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][0];
1961                 break;
1962             case UDISPCTX_CAPITALIZATION_FOR_STANDALONE:
1963                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][1];
1964                 break;
1965             default:
1966                 // titlecase = FALSE;
1967                 break;
1968         }
1969         if (titlecase) {
1970             UnicodeString firstField(appendTo, beginOffset);
1971             firstField.toTitle(fCapitalizationBrkIter, fLocale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1972             appendTo.replaceBetween(beginOffset, appendTo.length(), firstField);
1973         }
</pre>
<hr />
<pre>
2062             } else if (minDigits == 3) {
2063                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_3x10];
2064             } else if (minDigits == 4) {
2065                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_4x10];
2066             }
2067         } else if (maxDigits == 2) {
2068             if (minDigits == 2) {
2069                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_2x2];
2070             }
2071         }
2072     }
2073     if (fastFormatter != nullptr) {
2074         // Can use fast path
2075         number::impl::UFormattedNumberData result;
2076         result.quantity.setToInt(value);
2077         UErrorCode localStatus = U_ZERO_ERROR;
2078         fastFormatter-&gt;formatImpl(&amp;result, localStatus);
2079         if (U_FAILURE(localStatus)) {
2080             return;
2081         }
<span class="line-modified">2082         appendTo.append(result.string.toTempUnicodeString());</span>
2083         return;
2084     }
2085 
2086     // Check for RBNF (no clone necessary)
2087     auto* rbnf = dynamic_cast&lt;const RuleBasedNumberFormat*&gt;(currentNumberFormat);
2088     if (rbnf != nullptr) {
2089         FieldPosition pos(FieldPosition::DONT_CARE);
2090         rbnf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2091         return;
2092     }
2093 
2094     // Fall back to slow path (clone and mutate the NumberFormat)
2095     if (currentNumberFormat != nullptr) {
2096         FieldPosition pos(FieldPosition::DONT_CARE);
2097         LocalPointer&lt;NumberFormat&gt; nf(dynamic_cast&lt;NumberFormat*&gt;(currentNumberFormat-&gt;clone()));
2098         nf-&gt;setMinimumIntegerDigits(minDigits);
2099         nf-&gt;setMaximumIntegerDigits(maxDigits);
2100         nf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2101     }
2102 }
</pre>
<hr />
<pre>
2264                 if (pos &lt; 0) {
2265                     i = abutPat - 1;
2266                     pos = abutStart;
2267                     continue;
2268                 }
2269             }
2270 
2271             // Handle non-numeric fields and non-abutting numeric
2272             // fields.
2273             else if (ch != 0x6C) { // pattern char &#39;l&#39; (SMALL LETTER L) just gets ignored
2274                 int32_t s = subParse(text, pos, ch, count,
2275                                FALSE, TRUE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &amp;tzTimeType, &amp;dayPeriodInt);
2276 
2277                 if (s == -pos-1) {
2278                     // era not present, in special cases allow this to continue
2279                     // from the position where the era was expected
2280                     s = pos;
2281 
2282                     if (i+1 &lt; fPattern.length()) {
2283                         // move to next pattern character
<span class="line-modified">2284                         UChar ch = fPattern.charAt(i+1);</span>
2285 
2286                         // check for whitespace
<span class="line-modified">2287                         if (PatternProps::isWhiteSpace(ch)) {</span>
2288                             i++;
2289                             // Advance over run in pattern
2290                             while ((i+1)&lt;fPattern.length() &amp;&amp;
2291                                    PatternProps::isWhiteSpace(fPattern.charAt(i+1))) {
2292                                 ++i;
2293                             }
2294                         }
2295                     }
2296                 }
2297                 else if (s &lt;= 0) {
2298                     status = U_PARSE_ERROR;
2299                     goto ExitParse;
2300                 }
2301                 pos = s;
2302             }
2303         }
2304 
2305         // Handle literal pattern characters.  These are any
2306         // quoted characters and non-alphabetic unquoted
2307         // characters.
</pre>
<hr />
<pre>
3145             if (newStart &gt; 0) {
3146                 return newStart;
3147             }
3148         }
3149         if (gotNumber &amp;&amp; (getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC,status) || value &gt; fSymbols-&gt;fShortYearNamesCount)) {
3150             cal.set(UCAL_YEAR, value);
3151             return pos.getIndex();
3152         }
3153         return -start;
3154 
3155     case UDAT_MONTH_FIELD:
3156     case UDAT_STANDALONE_MONTH_FIELD:
3157         if (gotNumber) // i.e., M or MM.
3158         {
3159             // When parsing month numbers from the Hebrew Calendar, we might need to adjust the month depending on whether
3160             // or not it was a leap year.  We may or may not yet know what year it is, so might have to delay checking until
3161             // the year is parsed.
3162             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3163                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3164                 if (cal.isSet(UCAL_YEAR)) {
<span class="line-modified">3165                    UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">3166                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR,status)) &amp;&amp; value &gt;= 6) {</span>
3167                        cal.set(UCAL_MONTH, value);
3168                    } else {
3169                        cal.set(UCAL_MONTH, value - 1);
3170                    }
3171                 } else {
3172                     saveHebrewMonth = value;
3173                 }
3174             } else {
3175                 // Don&#39;t want to parse the month if it is a string
3176                 // while pattern uses numeric style: M/MM, L/LL
3177                 // [We computed &#39;value&#39; above.]
3178                 cal.set(UCAL_MONTH, value - 1);
3179             }
3180             return pos.getIndex();
3181         } else {
3182             // count &gt;= 3 // i.e., MMM/MMMM, LLL/LLLL
3183             // Want to be able to parse both short and long forms.
3184             // Try count == 4 first:
3185             UnicodeString * wideMonthPat = NULL;
3186             UnicodeString * shortMonthPat = NULL;
</pre>
<hr />
<pre>
3554                 break;
3555             }
3556             const TimeZoneFormat *tzfmt = tzFormat(status);
3557             if (U_SUCCESS(status)) {
3558                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3559                 if (tz != NULL) {
3560                     cal.adoptTimeZone(tz);
3561                     return pos.getIndex();
3562                 }
3563             }
3564             return -start;
3565         }
3566     // currently no pattern character is defined for UDAT_TIME_SEPARATOR_FIELD
3567     // so we should not get here. Leave support in for future definition.
3568     case UDAT_TIME_SEPARATOR_FIELD:
3569         {
3570             static const UChar def_sep = DateFormatSymbols::DEFAULT_TIME_SEPARATOR;
3571             static const UChar alt_sep = DateFormatSymbols::ALTERNATE_TIME_SEPARATOR;
3572 
3573             // Try matching a time separator.
<span class="line-modified">3574             int32_t count = 1;</span>
3575             UnicodeString data[3];
3576             fSymbols-&gt;getTimeSeparatorString(data[0]);
3577 
3578             // Add the default, if different from the locale.
3579             if (data[0].compare(&amp;def_sep, 1) != 0) {
<span class="line-modified">3580                 data[count++].setTo(def_sep);</span>
3581             }
3582 
3583             // If lenient, add also the alternate, if different from the locale.
3584             if (isLenient() &amp;&amp; data[0].compare(&amp;alt_sep, 1) != 0) {
<span class="line-modified">3585                 data[count++].setTo(alt_sep);</span>
3586             }
3587 
<span class="line-modified">3588             return matchString(text, start, UCAL_FIELD_COUNT /* =&gt; nothing to set */, data, count, NULL, cal);</span>
3589         }
3590 
3591     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
3592     {
3593         U_ASSERT(dayPeriod != NULL);
3594         int32_t ampmStart = subParse(text, start, 0x61, count,
3595                            obeyCount, allowNegative, ambiguousYear, saveHebrewMonth, cal,
3596                            patLoc, numericLeapMonthFormatter, tzTimeType);
3597 
3598         if (ampmStart &gt; 0) {
3599             return ampmStart;
3600         } else {
3601             int32_t newStart = 0;
3602 
3603             // Only match the first two strings from the day period strings array.
3604             if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3605                 if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fAbbreviatedDayPeriods,
3606                                                         2, *dayPeriod)) &gt; 0) {
3607                     return newStart;
3608                 }
</pre>
<hr />
<pre>
3657         // this is now handled below, outside the switch block
3658         break;
3659     }
3660     // Handle &quot;generic&quot; fields:
3661     // switch default case now handled here (outside switch block) to allow
3662     // parsing of some string fields as digits for lenient case
3663 
3664     int32_t parseStart = pos.getIndex();
3665     const UnicodeString* src;
3666     if (obeyCount) {
3667         if ((start+count) &gt; text.length()) {
3668             return -start;
3669         }
3670         text.extractBetween(0, start + count, temp);
3671         src = &amp;temp;
3672     } else {
3673         src = &amp;text;
3674     }
3675     parseInt(*src, number, pos, allowNegative,currentNumberFormat);
3676     if (pos.getIndex() != parseStart) {
<span class="line-modified">3677         int32_t value = number.getLong();</span>
3678 
3679         // Don&#39;t need suffix processing here (as in number processing at the beginning of the function);
3680         // the new fields being handled as numeric values (month, weekdays, quarters) should not have suffixes.
3681 
3682         if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status)) {
3683             // Check the range of the value
3684             int32_t bias = gFieldRangeBias[patternCharIndex];
<span class="line-modified">3685             if (bias &gt;= 0 &amp;&amp; (value &gt; cal.getMaximum(field) + bias || value &lt; cal.getMinimum(field) + bias)) {</span>
3686                 return -start;
3687             }
3688         }
3689 
3690         // For the following, need to repeat some of the &quot;if (gotNumber)&quot; code above:
3691         // UDAT_[STANDALONE_]MONTH_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_STANDALONE_DAY_FIELD,
3692         // UDAT_[STANDALONE_]QUARTER_FIELD
3693         switch (patternCharIndex) {
3694         case UDAT_MONTH_FIELD:
3695             // See notes under UDAT_MONTH_FIELD case above
3696             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3697                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3698                 if (cal.isSet(UCAL_YEAR)) {
<span class="line-modified">3699                    UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-modified">3700                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR,status)) &amp;&amp; value &gt;= 6) {</span>
<span class="line-modified">3701                        cal.set(UCAL_MONTH, value);</span>
3702                    } else {
<span class="line-modified">3703                        cal.set(UCAL_MONTH, value - 1);</span>
3704                    }
3705                 } else {
<span class="line-modified">3706                     saveHebrewMonth = value;</span>
3707                 }
3708             } else {
<span class="line-modified">3709                 cal.set(UCAL_MONTH, value - 1);</span>
3710             }
3711             break;
3712         case UDAT_STANDALONE_MONTH_FIELD:
<span class="line-modified">3713             cal.set(UCAL_MONTH, value - 1);</span>
3714             break;
3715         case UDAT_DOW_LOCAL_FIELD:
3716         case UDAT_STANDALONE_DAY_FIELD:
<span class="line-modified">3717             cal.set(UCAL_DOW_LOCAL, value);</span>
3718             break;
3719         case UDAT_QUARTER_FIELD:
3720         case UDAT_STANDALONE_QUARTER_FIELD:
<span class="line-modified">3721              cal.set(UCAL_MONTH, (value - 1) * 3);</span>
3722              break;
3723         case UDAT_RELATED_YEAR_FIELD:
<span class="line-modified">3724             cal.setRelatedYear(value);</span>
3725             break;
3726         default:
<span class="line-modified">3727             cal.set(field, value);</span>
3728             break;
3729         }
3730         return pos.getIndex();
3731     }
3732     return -start;
3733 }
3734 
3735 /**
3736  * Parse an integer using fNumberFormat.  This method is semantically
3737  * const, but actually may modify fNumberFormat.
3738  */
3739 void SimpleDateFormat::parseInt(const UnicodeString&amp; text,
3740                                 Formattable&amp; number,
3741                                 ParsePosition&amp; pos,
3742                                 UBool allowNegative,
3743                                 const NumberFormat *fmt) const {
3744     parseInt(text, number, -1, pos, allowNegative,fmt);
3745 }
3746 
3747 /**
</pre>
<hr />
<pre>
3855 
3856 //----------------------------------------------------------------------
3857 
3858 UnicodeString&amp;
3859 SimpleDateFormat::toLocalizedPattern(UnicodeString&amp; result,
3860                                      UErrorCode&amp; status) const
3861 {
3862     translatePattern(fPattern, result,
3863                      UnicodeString(DateFormatSymbols::getPatternUChars()),
3864                      fSymbols-&gt;fLocalPatternChars, status);
3865     return result;
3866 }
3867 
3868 //----------------------------------------------------------------------
3869 
3870 void
3871 SimpleDateFormat::applyPattern(const UnicodeString&amp; pattern)
3872 {
3873     fPattern = pattern;
3874     parsePattern();




































3875 }
3876 
3877 //----------------------------------------------------------------------
3878 
3879 void
3880 SimpleDateFormat::applyLocalizedPattern(const UnicodeString&amp; pattern,
3881                                         UErrorCode &amp;status)
3882 {
3883     translatePattern(pattern, fPattern,
3884                      fSymbols-&gt;fLocalPatternChars,
3885                      UnicodeString(DateFormatSymbols::getPatternUChars()), status);
3886 }
3887 
3888 //----------------------------------------------------------------------
3889 
3890 const DateFormatSymbols*
3891 SimpleDateFormat::getDateFormatSymbols() const
3892 {
3893     return fSymbols;
3894 }
</pre>
<hr />
<pre>
3954   DateFormat::adoptCalendar(calendarToAdopt);
3955   delete fSymbols;
3956   fSymbols = newSymbols;
3957   initializeDefaultCentury();  // we need a new century (possibly)
3958 }
3959 
3960 
3961 //----------------------------------------------------------------------
3962 
3963 
3964 // override the DateFormat implementation in order to
3965 // lazily initialize fCapitalizationBrkIter
3966 void
3967 SimpleDateFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
3968 {
3969     DateFormat::setContext(value, status);
3970 #if !UCONFIG_NO_BREAK_ITERATION
3971     if (U_SUCCESS(status)) {
3972         if ( fCapitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
3973                 value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE) ) {
<span class="line-modified">3974             UErrorCode status = U_ZERO_ERROR;</span>
3975             fCapitalizationBrkIter = BreakIterator::createSentenceInstance(fLocale, status);
3976             if (U_FAILURE(status)) {
3977                 delete fCapitalizationBrkIter;
3978                 fCapitalizationBrkIter = NULL;
3979             }
3980         }
3981     }
3982 #endif
3983 }
3984 
3985 
3986 //----------------------------------------------------------------------
3987 
3988 
3989 UBool
3990 SimpleDateFormat::isFieldUnitIgnored(UCalendarDateFields field) const {
3991     return isFieldUnitIgnored(fPattern, field);
3992 }
3993 
3994 
</pre>
<hr />
<pre>
4171 //----------------------------------------------------------------------
4172 
4173 int32_t
4174 SimpleDateFormat::skipUWhiteSpace(const UnicodeString&amp; text, int32_t pos) const {
4175     while (pos &lt; text.length()) {
4176         UChar32 c = text.char32At(pos);
4177         if (!u_isUWhiteSpace(c)) {
4178             break;
4179         }
4180         pos += U16_LENGTH(c);
4181     }
4182     return pos;
4183 }
4184 
4185 //----------------------------------------------------------------------
4186 
4187 // Lazy TimeZoneFormat instantiation, semantically const.
4188 TimeZoneFormat *
4189 SimpleDateFormat::tzFormat(UErrorCode &amp;status) const {
4190     if (fTimeZoneFormat == NULL) {
<span class="line-modified">4191         umtx_lock(&amp;LOCK);</span>
4192         {
4193             if (fTimeZoneFormat == NULL) {
4194                 TimeZoneFormat *tzfmt = TimeZoneFormat::createInstance(fLocale, status);
4195                 if (U_FAILURE(status)) {
4196                     return NULL;
4197                 }
4198 
4199                 const_cast&lt;SimpleDateFormat *&gt;(this)-&gt;fTimeZoneFormat = tzfmt;
4200             }
4201         }
<span class="line-modified">4202         umtx_unlock(&amp;LOCK);</span>
4203     }
4204     return fTimeZoneFormat;
4205 }
4206 
4207 void SimpleDateFormat::parsePattern() {
4208     fHasMinute = FALSE;
4209     fHasSecond = FALSE;

4210 
4211     int len = fPattern.length();
4212     UBool inQuote = FALSE;
4213     for (int32_t i = 0; i &lt; len; ++i) {
4214         UChar ch = fPattern[i];
4215         if (ch == QUOTE) {
4216             inQuote = !inQuote;
4217         }



4218         if (!inQuote) {
4219             if (ch == 0x6D) {  // 0x6D == &#39;m&#39;
4220                 fHasMinute = TRUE;
4221             }
4222             if (ch == 0x73) {  // 0x73 == &#39;s&#39;
4223                 fHasSecond = TRUE;
4224             }
4225         }
4226     }
4227 }
4228 
4229 U_NAMESPACE_END
4230 
4231 #endif /* #if !UCONFIG_NO_FORMATTING */
4232 
4233 //eof
</pre>
</td>
<td>
<hr />
<pre>
 213     -1,  // &#39;Q&#39; - UDAT_QUARTER_FIELD (1-4?)
 214     -1,  // &#39;q&#39; - UDAT_STANDALONE_QUARTER_FIELD
 215     -1,  // &#39;V&#39; - UDAT_TIMEZONE_SPECIAL_FIELD
 216     -1,  // &#39;U&#39; - UDAT_YEAR_NAME_FIELD
 217     -1,  // &#39;O&#39; - UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD
 218     -1,  // &#39;X&#39; - UDAT_TIMEZONE_ISO_FIELD
 219     -1,  // &#39;x&#39; - UDAT_TIMEZONE_ISO_LOCAL_FIELD
 220     -1,  // &#39;r&#39; - UDAT_RELATED_YEAR_FIELD
 221 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
 222     -1,  // &#39;:&#39; - UDAT_TIME_SEPARATOR_FIELD
 223 #else
 224     -1,  // (no pattern character currently) - UDAT_TIME_SEPARATOR_FIELD
 225 #endif
 226 };
 227 
 228 // When calendar uses hebr numbering (i.e. he@calendar=hebrew),
 229 // offset the years within the current millenium down to 1-999
 230 static const int32_t HEBREW_CAL_CUR_MILLENIUM_START_YEAR = 5000;
 231 static const int32_t HEBREW_CAL_CUR_MILLENIUM_END_YEAR = 6000;
 232 
<span class="line-modified"> 233 static UMutex *LOCK() {</span>
<span class="line-added"> 234     static UMutex m = U_MUTEX_INITIALIZER;</span>
<span class="line-added"> 235     return &amp;m;</span>
<span class="line-added"> 236 }</span>
 237 
 238 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleDateFormat)
 239 
 240 SimpleDateFormat::NSOverride::~NSOverride() {
 241     if (snf != NULL) {
 242         snf-&gt;removeRef();
 243     }
 244 }
 245 
 246 
 247 void SimpleDateFormat::NSOverride::free() {
 248     NSOverride *cur = this;
 249     while (cur) {
<span class="line-modified"> 250         NSOverride *next_temp = cur-&gt;next;</span>
 251         delete cur;
<span class="line-modified"> 252         cur = next_temp;</span>
 253     }
 254 }
 255 
 256 // no matter what the locale&#39;s default number format looked like, we want
 257 // to modify it so that it doesn&#39;t use thousands separators, doesn&#39;t always
 258 // show the decimal point, and recognizes integers only when parsing
 259 static void fixNumberFormatForDates(NumberFormat &amp;nf) {
 260     nf.setGroupingUsed(FALSE);
 261     DecimalFormat* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(&amp;nf);
 262     if (decfmt != NULL) {
 263         decfmt-&gt;setDecimalSeparatorAlwaysShown(FALSE);
 264     }
 265     nf.setParseIntegerOnly(TRUE);
 266     nf.setMinimumFractionDigits(0); // To prevent &quot;Jan 1.00, 1997.00&quot;
 267 }
 268 
 269 static const SharedNumberFormat *createSharedNumberFormat(
 270         NumberFormat *nfToAdopt) {
 271     fixNumberFormatForDates(*nfToAdopt);
 272     const SharedNumberFormat *result = new SharedNumberFormat(nfToAdopt);
</pre>
<hr />
<pre>
 842     initialize(locale, status);
 843 }
 844 
 845 //----------------------------------------------------------------------
 846 
 847 Calendar*
 848 SimpleDateFormat::initializeCalendar(TimeZone* adoptZone, const Locale&amp; locale, UErrorCode&amp; status)
 849 {
 850     if(!U_FAILURE(status)) {
 851         fCalendar = Calendar::createInstance(adoptZone?adoptZone:TimeZone::createDefault(), locale, status);
 852     }
 853     return fCalendar;
 854 }
 855 
 856 void
 857 SimpleDateFormat::initialize(const Locale&amp; locale,
 858                              UErrorCode&amp; status)
 859 {
 860     if (U_FAILURE(status)) return;
 861 
<span class="line-added"> 862     parsePattern(); // Need this before initNumberFormatters(), to set fHasHanYearChar</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864     // Simple-minded hack to force Gannen year numbering for ja@calendar=japanese</span>
<span class="line-added"> 865     // if format is non-numeric (includes å¹´) and fDateOverride is not already specified.</span>
<span class="line-added"> 866     // Now this does get updated if applyPattern subsequently changes the pattern type.</span>
<span class="line-added"> 867     if (fDateOverride.isBogus() &amp;&amp; fHasHanYearChar &amp;&amp;</span>
<span class="line-added"> 868             fCalendar != nullptr &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(),&quot;japanese&quot;) == 0 &amp;&amp;</span>
<span class="line-added"> 869             uprv_strcmp(fLocale.getLanguage(),&quot;ja&quot;) == 0) {</span>
<span class="line-added"> 870         fDateOverride.setTo(u&quot;y=jpanyear&quot;, -1);</span>
<span class="line-added"> 871     }</span>
<span class="line-added"> 872 </span>
 873     // We don&#39;t need to check that the row count is &gt;= 1, since all 2d arrays have at
 874     // least one row
 875     fNumberFormat = NumberFormat::createInstance(locale, status);
 876     if (fNumberFormat != NULL &amp;&amp; U_SUCCESS(status))
 877     {
 878         fixNumberFormatForDates(*fNumberFormat);
 879         //fNumberFormat-&gt;setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse
 880 
 881         initNumberFormatters(locale, status);
 882         initFastNumberFormatters(status);
 883 
 884     }
 885     else if (U_SUCCESS(status))
 886     {
 887         status = U_MISSING_RESOURCE_ERROR;
 888     }


 889 }
 890 
 891 /* Initialize the fields we use to disambiguate ambiguous years. Separate
 892  * so we can call it from readObject().
 893  */
 894 void SimpleDateFormat::initializeDefaultCentury()
 895 {
 896   if(fCalendar) {
 897     fHaveDefaultCentury = fCalendar-&gt;haveDefaultCentury();
 898     if(fHaveDefaultCentury) {
 899       fDefaultCenturyStart = fCalendar-&gt;defaultCenturyStart();
 900       fDefaultCenturyStartYear = fCalendar-&gt;defaultCenturyStartYear();
 901     } else {
 902       fDefaultCenturyStart = DBL_MIN;
 903       fDefaultCenturyStartYear = -1;
 904     }
 905   }
 906 }
 907 
 908 /*
</pre>
<hr />
<pre>
1249     delete fFastNumberFormatters[SMPDTFMT_NF_2x10];
1250     delete fFastNumberFormatters[SMPDTFMT_NF_3x10];
1251     delete fFastNumberFormatters[SMPDTFMT_NF_4x10];
1252     delete fFastNumberFormatters[SMPDTFMT_NF_2x2];
1253     fFastNumberFormatters[SMPDTFMT_NF_1x10] = nullptr;
1254     fFastNumberFormatters[SMPDTFMT_NF_2x10] = nullptr;
1255     fFastNumberFormatters[SMPDTFMT_NF_3x10] = nullptr;
1256     fFastNumberFormatters[SMPDTFMT_NF_4x10] = nullptr;
1257     fFastNumberFormatters[SMPDTFMT_NF_2x2] = nullptr;
1258 }
1259 
1260 
1261 void
1262 SimpleDateFormat::initNumberFormatters(const Locale &amp;locale,UErrorCode &amp;status) {
1263     if (U_FAILURE(status)) {
1264         return;
1265     }
1266     if ( fDateOverride.isBogus() &amp;&amp; fTimeOverride.isBogus() ) {
1267         return;
1268     }
<span class="line-modified">1269     umtx_lock(LOCK());</span>
1270     if (fSharedNumberFormatters == NULL) {
1271         fSharedNumberFormatters = allocSharedNumberFormatters();
1272         if (fSharedNumberFormatters == NULL) {
1273             status = U_MEMORY_ALLOCATION_ERROR;
1274         }
1275     }
<span class="line-modified">1276     umtx_unlock(LOCK());</span>
1277 
1278     if (U_FAILURE(status)) {
1279         return;
1280     }
1281 
1282     processOverrideString(locale,fDateOverride,kOvrStrDate,status);
1283     processOverrideString(locale,fTimeOverride,kOvrStrTime,status);
1284 }
1285 
1286 void
1287 SimpleDateFormat::processOverrideString(const Locale &amp;locale, const UnicodeString &amp;str, int8_t type, UErrorCode &amp;status) {
1288     if (str.isBogus() || U_FAILURE(status)) {
1289         return;
1290     }
1291 
1292     int32_t start = 0;
1293     int32_t len;
1294     UnicodeString nsName;
1295     UnicodeString ovrField;
1296     UBool moreToProcess = TRUE;
</pre>
<hr />
<pre>
1299     while (moreToProcess) {
1300         int32_t delimiterPosition = str.indexOf((UChar)ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE,start);
1301         if (delimiterPosition == -1) {
1302             moreToProcess = FALSE;
1303             len = str.length() - start;
1304         } else {
1305             len = delimiterPosition - start;
1306         }
1307         UnicodeString currentString(str,start,len);
1308         int32_t equalSignPosition = currentString.indexOf((UChar)ULOC_KEYWORD_ASSIGN_UNICODE,0);
1309         if (equalSignPosition == -1) { // Simple override string such as &quot;hebrew&quot;
1310             nsName.setTo(currentString);
1311             ovrField.setToBogus();
1312         } else { // Field specific override string such as &quot;y=hebrew&quot;
1313             nsName.setTo(currentString,equalSignPosition+1);
1314             ovrField.setTo(currentString,0,1); // We just need the first character.
1315         }
1316 
1317         int32_t nsNameHash = nsName.hashCode();
1318         // See if the numbering system is in the override list, if not, then add it.
<span class="line-modified">1319         NSOverride *curr = overrideList;</span>
1320         const SharedNumberFormat *snf = NULL;
1321         UBool found = FALSE;
<span class="line-modified">1322         while ( curr &amp;&amp; !found ) {</span>
<span class="line-modified">1323             if ( curr-&gt;hash == nsNameHash ) {</span>
<span class="line-modified">1324                 snf = curr-&gt;snf;</span>
1325                 found = TRUE;
1326             }
<span class="line-modified">1327             curr = curr-&gt;next;</span>
1328         }
1329 
1330         if (!found) {
1331            LocalPointer&lt;NSOverride&gt; cur(new NSOverride);
1332            if (!cur.isNull()) {
1333                char kw[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1334                uprv_strcpy(kw,&quot;numbers=&quot;);
1335                nsName.extract(0,len,kw+8,ULOC_KEYWORD_AND_VALUES_CAPACITY-8,US_INV);
1336 
1337                Locale ovrLoc(locale.getLanguage(),locale.getCountry(),locale.getVariant(),kw);
1338                cur-&gt;hash = nsNameHash;
1339                cur-&gt;next = overrideList;
1340                SharedObject::copyPtr(
1341                        createSharedNumberFormat(ovrLoc, status), cur-&gt;snf);
1342                if (U_FAILURE(status)) {
1343                    if (overrideList) {
1344                        overrideList-&gt;free();
1345                    }
1346                    return;
1347                }
</pre>
<hr />
<pre>
1773                 }
1774                 else if (patternCharIndex == UDAT_TIMEZONE_ISO_LOCAL_FIELD) {
1775                     if (count == 1) {
1776                         // &quot;x&quot;
1777                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT, tz, date, zoneString);
1778                     } else if (count == 2) {
1779                         // &quot;xx&quot;
1780                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED, tz, date, zoneString);
1781                     } else if (count == 3) {
1782                         // &quot;xxx&quot;
1783                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED, tz, date, zoneString);
1784                     } else if (count == 4) {
1785                         // &quot;xxxx&quot;
1786                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL, tz, date, zoneString);
1787                     } else if (count == 5) {
1788                         // &quot;xxxxx&quot;
1789                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL, tz, date, zoneString);
1790                     }
1791                 }
1792                 else {
<span class="line-modified">1793                     UPRV_UNREACHABLE;</span>
1794                 }
1795             }
1796             appendTo += zoneString;
1797         }
1798         break;
1799 
1800     case UDAT_QUARTER_FIELD:
1801         if (count &gt;= 4)
1802             _appendSymbol(appendTo, value/3, fSymbols-&gt;fQuarters,
1803                           fSymbols-&gt;fQuartersCount);
1804         else if (count == 3)
1805             _appendSymbol(appendTo, value/3, fSymbols-&gt;fShortQuarters,
1806                           fSymbols-&gt;fShortQuartersCount);
1807         else
1808             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1809         break;
1810 
1811     case UDAT_STANDALONE_QUARTER_FIELD:
1812         if (count &gt;= 4)
1813             _appendSymbol(appendTo, value/3, fSymbols-&gt;fStandaloneQuarters,
</pre>
<hr />
<pre>
1819             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1820         break;
1821 
1822     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
1823     {
1824         const UnicodeString *toAppend = NULL;
1825         int32_t hour = cal.get(UCAL_HOUR_OF_DAY, status);
1826 
1827         // Note: &quot;midnight&quot; can be ambiguous as to whether it refers to beginning of day or end of day.
1828         // For ICU 57 output of &quot;midnight&quot; is temporarily suppressed.
1829 
1830         // For &quot;midnight&quot; and &quot;noon&quot;:
1831         // Time, as displayed, must be exactly noon or midnight.
1832         // This means minutes and seconds, if present, must be zero.
1833         if ((/*hour == 0 ||*/ hour == 12) &amp;&amp;
1834                 (!fHasMinute || cal.get(UCAL_MINUTE, status) == 0) &amp;&amp;
1835                 (!fHasSecond || cal.get(UCAL_SECOND, status) == 0)) {
1836             // Stealing am/pm value to use as our array index.
1837             // It works out: am/midnight are both 0, pm/noon are both 1,
1838             // 12 am is 12 midnight, and 12 pm is 12 noon.
<span class="line-modified">1839             int32_t val = cal.get(UCAL_AM_PM, status);</span>
1840 
1841             if (count &lt;= 3) {
<span class="line-modified">1842                 toAppend = &amp;fSymbols-&gt;fAbbreviatedDayPeriods[val];</span>
1843             } else if (count == 4 || count &gt; 5) {
<span class="line-modified">1844                 toAppend = &amp;fSymbols-&gt;fWideDayPeriods[val];</span>
1845             } else { // count == 5
<span class="line-modified">1846                 toAppend = &amp;fSymbols-&gt;fNarrowDayPeriods[val];</span>
1847             }
1848         }
1849 
1850         // toAppend is NULL if time isn&#39;t exactly midnight or noon (as displayed).
1851         // toAppend is bogus if time is midnight or noon, but no localized string exists.
1852         // In either case, fall back to am/pm.
1853         if (toAppend == NULL || toAppend-&gt;isBogus()) {
1854             // Reformat with identical arguments except ch, now changed to &#39;a&#39;.
1855             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1856                       handler, cal, status);
1857         } else {
1858             appendTo += *toAppend;
1859         }
1860 
1861         break;
1862     }
1863 
1864     case UDAT_FLEXIBLE_DAY_PERIOD_FIELD:
1865     {
1866         // TODO: Maybe fetch the DayperiodRules during initialization (instead of at the first
</pre>
<hr />
<pre>
1945             periodType == DayPeriodRules::DAYPERIOD_PM ||
1946             toAppend-&gt;isBogus()) {
1947             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1948                       handler, cal, status);
1949         }
1950         else {
1951             appendTo += *toAppend;
1952         }
1953 
1954         break;
1955     }
1956 
1957     // all of the other pattern symbols can be formatted as simple numbers with
1958     // appropriate zero padding
1959     default:
1960         zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1961         break;
1962     }
1963 #if !UCONFIG_NO_BREAK_ITERATION
1964     // if first field, check to see whether we need to and are able to titlecase it
<span class="line-modified">1965     if (fieldNum == 0 &amp;&amp; fCapitalizationBrkIter != NULL &amp;&amp; appendTo.length() &gt; beginOffset &amp;&amp;</span>
<span class="line-added">1966             u_islower(appendTo.char32At(beginOffset))) {</span>
1967         UBool titlecase = FALSE;
1968         switch (capitalizationContext) {
1969             case UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE:
1970                 titlecase = TRUE;
1971                 break;
1972             case UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU:
1973                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][0];
1974                 break;
1975             case UDISPCTX_CAPITALIZATION_FOR_STANDALONE:
1976                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][1];
1977                 break;
1978             default:
1979                 // titlecase = FALSE;
1980                 break;
1981         }
1982         if (titlecase) {
1983             UnicodeString firstField(appendTo, beginOffset);
1984             firstField.toTitle(fCapitalizationBrkIter, fLocale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1985             appendTo.replaceBetween(beginOffset, appendTo.length(), firstField);
1986         }
</pre>
<hr />
<pre>
2075             } else if (minDigits == 3) {
2076                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_3x10];
2077             } else if (minDigits == 4) {
2078                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_4x10];
2079             }
2080         } else if (maxDigits == 2) {
2081             if (minDigits == 2) {
2082                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_2x2];
2083             }
2084         }
2085     }
2086     if (fastFormatter != nullptr) {
2087         // Can use fast path
2088         number::impl::UFormattedNumberData result;
2089         result.quantity.setToInt(value);
2090         UErrorCode localStatus = U_ZERO_ERROR;
2091         fastFormatter-&gt;formatImpl(&amp;result, localStatus);
2092         if (U_FAILURE(localStatus)) {
2093             return;
2094         }
<span class="line-modified">2095         appendTo.append(result.getStringRef().toTempUnicodeString());</span>
2096         return;
2097     }
2098 
2099     // Check for RBNF (no clone necessary)
2100     auto* rbnf = dynamic_cast&lt;const RuleBasedNumberFormat*&gt;(currentNumberFormat);
2101     if (rbnf != nullptr) {
2102         FieldPosition pos(FieldPosition::DONT_CARE);
2103         rbnf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2104         return;
2105     }
2106 
2107     // Fall back to slow path (clone and mutate the NumberFormat)
2108     if (currentNumberFormat != nullptr) {
2109         FieldPosition pos(FieldPosition::DONT_CARE);
2110         LocalPointer&lt;NumberFormat&gt; nf(dynamic_cast&lt;NumberFormat*&gt;(currentNumberFormat-&gt;clone()));
2111         nf-&gt;setMinimumIntegerDigits(minDigits);
2112         nf-&gt;setMaximumIntegerDigits(maxDigits);
2113         nf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2114     }
2115 }
</pre>
<hr />
<pre>
2277                 if (pos &lt; 0) {
2278                     i = abutPat - 1;
2279                     pos = abutStart;
2280                     continue;
2281                 }
2282             }
2283 
2284             // Handle non-numeric fields and non-abutting numeric
2285             // fields.
2286             else if (ch != 0x6C) { // pattern char &#39;l&#39; (SMALL LETTER L) just gets ignored
2287                 int32_t s = subParse(text, pos, ch, count,
2288                                FALSE, TRUE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &amp;tzTimeType, &amp;dayPeriodInt);
2289 
2290                 if (s == -pos-1) {
2291                     // era not present, in special cases allow this to continue
2292                     // from the position where the era was expected
2293                     s = pos;
2294 
2295                     if (i+1 &lt; fPattern.length()) {
2296                         // move to next pattern character
<span class="line-modified">2297                         UChar c = fPattern.charAt(i+1);</span>
2298 
2299                         // check for whitespace
<span class="line-modified">2300                         if (PatternProps::isWhiteSpace(c)) {</span>
2301                             i++;
2302                             // Advance over run in pattern
2303                             while ((i+1)&lt;fPattern.length() &amp;&amp;
2304                                    PatternProps::isWhiteSpace(fPattern.charAt(i+1))) {
2305                                 ++i;
2306                             }
2307                         }
2308                     }
2309                 }
2310                 else if (s &lt;= 0) {
2311                     status = U_PARSE_ERROR;
2312                     goto ExitParse;
2313                 }
2314                 pos = s;
2315             }
2316         }
2317 
2318         // Handle literal pattern characters.  These are any
2319         // quoted characters and non-alphabetic unquoted
2320         // characters.
</pre>
<hr />
<pre>
3158             if (newStart &gt; 0) {
3159                 return newStart;
3160             }
3161         }
3162         if (gotNumber &amp;&amp; (getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC,status) || value &gt; fSymbols-&gt;fShortYearNamesCount)) {
3163             cal.set(UCAL_YEAR, value);
3164             return pos.getIndex();
3165         }
3166         return -start;
3167 
3168     case UDAT_MONTH_FIELD:
3169     case UDAT_STANDALONE_MONTH_FIELD:
3170         if (gotNumber) // i.e., M or MM.
3171         {
3172             // When parsing month numbers from the Hebrew Calendar, we might need to adjust the month depending on whether
3173             // or not it was a leap year.  We may or may not yet know what year it is, so might have to delay checking until
3174             // the year is parsed.
3175             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3176                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3177                 if (cal.isSet(UCAL_YEAR)) {
<span class="line-modified">3178                    UErrorCode monthStatus = U_ZERO_ERROR;</span>
<span class="line-modified">3179                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR, monthStatus)) &amp;&amp; value &gt;= 6) {</span>
3180                        cal.set(UCAL_MONTH, value);
3181                    } else {
3182                        cal.set(UCAL_MONTH, value - 1);
3183                    }
3184                 } else {
3185                     saveHebrewMonth = value;
3186                 }
3187             } else {
3188                 // Don&#39;t want to parse the month if it is a string
3189                 // while pattern uses numeric style: M/MM, L/LL
3190                 // [We computed &#39;value&#39; above.]
3191                 cal.set(UCAL_MONTH, value - 1);
3192             }
3193             return pos.getIndex();
3194         } else {
3195             // count &gt;= 3 // i.e., MMM/MMMM, LLL/LLLL
3196             // Want to be able to parse both short and long forms.
3197             // Try count == 4 first:
3198             UnicodeString * wideMonthPat = NULL;
3199             UnicodeString * shortMonthPat = NULL;
</pre>
<hr />
<pre>
3567                 break;
3568             }
3569             const TimeZoneFormat *tzfmt = tzFormat(status);
3570             if (U_SUCCESS(status)) {
3571                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3572                 if (tz != NULL) {
3573                     cal.adoptTimeZone(tz);
3574                     return pos.getIndex();
3575                 }
3576             }
3577             return -start;
3578         }
3579     // currently no pattern character is defined for UDAT_TIME_SEPARATOR_FIELD
3580     // so we should not get here. Leave support in for future definition.
3581     case UDAT_TIME_SEPARATOR_FIELD:
3582         {
3583             static const UChar def_sep = DateFormatSymbols::DEFAULT_TIME_SEPARATOR;
3584             static const UChar alt_sep = DateFormatSymbols::ALTERNATE_TIME_SEPARATOR;
3585 
3586             // Try matching a time separator.
<span class="line-modified">3587             int32_t count_sep = 1;</span>
3588             UnicodeString data[3];
3589             fSymbols-&gt;getTimeSeparatorString(data[0]);
3590 
3591             // Add the default, if different from the locale.
3592             if (data[0].compare(&amp;def_sep, 1) != 0) {
<span class="line-modified">3593                 data[count_sep++].setTo(def_sep);</span>
3594             }
3595 
3596             // If lenient, add also the alternate, if different from the locale.
3597             if (isLenient() &amp;&amp; data[0].compare(&amp;alt_sep, 1) != 0) {
<span class="line-modified">3598                 data[count_sep++].setTo(alt_sep);</span>
3599             }
3600 
<span class="line-modified">3601             return matchString(text, start, UCAL_FIELD_COUNT /* =&gt; nothing to set */, data, count_sep, NULL, cal);</span>
3602         }
3603 
3604     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
3605     {
3606         U_ASSERT(dayPeriod != NULL);
3607         int32_t ampmStart = subParse(text, start, 0x61, count,
3608                            obeyCount, allowNegative, ambiguousYear, saveHebrewMonth, cal,
3609                            patLoc, numericLeapMonthFormatter, tzTimeType);
3610 
3611         if (ampmStart &gt; 0) {
3612             return ampmStart;
3613         } else {
3614             int32_t newStart = 0;
3615 
3616             // Only match the first two strings from the day period strings array.
3617             if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3618                 if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fAbbreviatedDayPeriods,
3619                                                         2, *dayPeriod)) &gt; 0) {
3620                     return newStart;
3621                 }
</pre>
<hr />
<pre>
3670         // this is now handled below, outside the switch block
3671         break;
3672     }
3673     // Handle &quot;generic&quot; fields:
3674     // switch default case now handled here (outside switch block) to allow
3675     // parsing of some string fields as digits for lenient case
3676 
3677     int32_t parseStart = pos.getIndex();
3678     const UnicodeString* src;
3679     if (obeyCount) {
3680         if ((start+count) &gt; text.length()) {
3681             return -start;
3682         }
3683         text.extractBetween(0, start + count, temp);
3684         src = &amp;temp;
3685     } else {
3686         src = &amp;text;
3687     }
3688     parseInt(*src, number, pos, allowNegative,currentNumberFormat);
3689     if (pos.getIndex() != parseStart) {
<span class="line-modified">3690         int32_t val = number.getLong();</span>
3691 
3692         // Don&#39;t need suffix processing here (as in number processing at the beginning of the function);
3693         // the new fields being handled as numeric values (month, weekdays, quarters) should not have suffixes.
3694 
3695         if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status)) {
3696             // Check the range of the value
3697             int32_t bias = gFieldRangeBias[patternCharIndex];
<span class="line-modified">3698             if (bias &gt;= 0 &amp;&amp; (val &gt; cal.getMaximum(field) + bias || val &lt; cal.getMinimum(field) + bias)) {</span>
3699                 return -start;
3700             }
3701         }
3702 
3703         // For the following, need to repeat some of the &quot;if (gotNumber)&quot; code above:
3704         // UDAT_[STANDALONE_]MONTH_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_STANDALONE_DAY_FIELD,
3705         // UDAT_[STANDALONE_]QUARTER_FIELD
3706         switch (patternCharIndex) {
3707         case UDAT_MONTH_FIELD:
3708             // See notes under UDAT_MONTH_FIELD case above
3709             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3710                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3711                 if (cal.isSet(UCAL_YEAR)) {
<span class="line-modified">3712                    UErrorCode monthStatus = U_ZERO_ERROR;</span>
<span class="line-modified">3713                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR, monthStatus)) &amp;&amp; val &gt;= 6) {</span>
<span class="line-modified">3714                        cal.set(UCAL_MONTH, val);</span>
3715                    } else {
<span class="line-modified">3716                        cal.set(UCAL_MONTH, val - 1);</span>
3717                    }
3718                 } else {
<span class="line-modified">3719                     saveHebrewMonth = val;</span>
3720                 }
3721             } else {
<span class="line-modified">3722                 cal.set(UCAL_MONTH, val - 1);</span>
3723             }
3724             break;
3725         case UDAT_STANDALONE_MONTH_FIELD:
<span class="line-modified">3726             cal.set(UCAL_MONTH, val - 1);</span>
3727             break;
3728         case UDAT_DOW_LOCAL_FIELD:
3729         case UDAT_STANDALONE_DAY_FIELD:
<span class="line-modified">3730             cal.set(UCAL_DOW_LOCAL, val);</span>
3731             break;
3732         case UDAT_QUARTER_FIELD:
3733         case UDAT_STANDALONE_QUARTER_FIELD:
<span class="line-modified">3734              cal.set(UCAL_MONTH, (val - 1) * 3);</span>
3735              break;
3736         case UDAT_RELATED_YEAR_FIELD:
<span class="line-modified">3737             cal.setRelatedYear(val);</span>
3738             break;
3739         default:
<span class="line-modified">3740             cal.set(field, val);</span>
3741             break;
3742         }
3743         return pos.getIndex();
3744     }
3745     return -start;
3746 }
3747 
3748 /**
3749  * Parse an integer using fNumberFormat.  This method is semantically
3750  * const, but actually may modify fNumberFormat.
3751  */
3752 void SimpleDateFormat::parseInt(const UnicodeString&amp; text,
3753                                 Formattable&amp; number,
3754                                 ParsePosition&amp; pos,
3755                                 UBool allowNegative,
3756                                 const NumberFormat *fmt) const {
3757     parseInt(text, number, -1, pos, allowNegative,fmt);
3758 }
3759 
3760 /**
</pre>
<hr />
<pre>
3868 
3869 //----------------------------------------------------------------------
3870 
3871 UnicodeString&amp;
3872 SimpleDateFormat::toLocalizedPattern(UnicodeString&amp; result,
3873                                      UErrorCode&amp; status) const
3874 {
3875     translatePattern(fPattern, result,
3876                      UnicodeString(DateFormatSymbols::getPatternUChars()),
3877                      fSymbols-&gt;fLocalPatternChars, status);
3878     return result;
3879 }
3880 
3881 //----------------------------------------------------------------------
3882 
3883 void
3884 SimpleDateFormat::applyPattern(const UnicodeString&amp; pattern)
3885 {
3886     fPattern = pattern;
3887     parsePattern();
<span class="line-added">3888 </span>
<span class="line-added">3889     // Hack to update use of Gannen year numbering for ja@calendar=japanese -</span>
<span class="line-added">3890     // use only if format is non-numeric (includes å¹´) and no other fDateOverride.</span>
<span class="line-added">3891     if (fCalendar != nullptr &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(),&quot;japanese&quot;) == 0 &amp;&amp;</span>
<span class="line-added">3892             uprv_strcmp(fLocale.getLanguage(),&quot;ja&quot;) == 0) {</span>
<span class="line-added">3893         if (fDateOverride==UnicodeString(u&quot;y=jpanyear&quot;) &amp;&amp; !fHasHanYearChar) {</span>
<span class="line-added">3894             // Gannen numbering is set but new pattern should not use it, unset;</span>
<span class="line-added">3895             // use procedure from adoptNumberFormat to clear overrides</span>
<span class="line-added">3896             if (fSharedNumberFormatters) {</span>
<span class="line-added">3897                 freeSharedNumberFormatters(fSharedNumberFormatters);</span>
<span class="line-added">3898                 fSharedNumberFormatters = NULL;</span>
<span class="line-added">3899             }</span>
<span class="line-added">3900             fDateOverride.setToBogus(); // record status</span>
<span class="line-added">3901         } else if (fDateOverride.isBogus() &amp;&amp; fHasHanYearChar) {</span>
<span class="line-added">3902             // No current override (=&gt; no Gannen numbering) but new pattern needs it;</span>
<span class="line-added">3903             // use procedures from initNUmberFormatters / adoptNumberFormat</span>
<span class="line-added">3904             umtx_lock(LOCK());</span>
<span class="line-added">3905             if (fSharedNumberFormatters == NULL) {</span>
<span class="line-added">3906                 fSharedNumberFormatters = allocSharedNumberFormatters();</span>
<span class="line-added">3907             }</span>
<span class="line-added">3908             umtx_unlock(LOCK());</span>
<span class="line-added">3909             if (fSharedNumberFormatters != NULL) {</span>
<span class="line-added">3910                 Locale ovrLoc(fLocale.getLanguage(),fLocale.getCountry(),fLocale.getVariant(),&quot;numbers=jpanyear&quot;);</span>
<span class="line-added">3911                 UErrorCode status = U_ZERO_ERROR;</span>
<span class="line-added">3912                 const SharedNumberFormat *snf = createSharedNumberFormat(ovrLoc, status);</span>
<span class="line-added">3913                 if (U_SUCCESS(status)) {</span>
<span class="line-added">3914                     // Now that we have an appropriate number formatter, fill in the</span>
<span class="line-added">3915                     // appropriate slot in the number formatters table.</span>
<span class="line-added">3916                     UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(u&#39;y&#39;);</span>
<span class="line-added">3917                     SharedObject::copyPtr(snf, fSharedNumberFormatters[patternCharIndex]);</span>
<span class="line-added">3918                     snf-&gt;deleteIfZeroRefCount();</span>
<span class="line-added">3919                     fDateOverride.setTo(u&quot;y=jpanyear&quot;, -1); // record status</span>
<span class="line-added">3920                 }</span>
<span class="line-added">3921             }</span>
<span class="line-added">3922         }</span>
<span class="line-added">3923     }</span>
3924 }
3925 
3926 //----------------------------------------------------------------------
3927 
3928 void
3929 SimpleDateFormat::applyLocalizedPattern(const UnicodeString&amp; pattern,
3930                                         UErrorCode &amp;status)
3931 {
3932     translatePattern(pattern, fPattern,
3933                      fSymbols-&gt;fLocalPatternChars,
3934                      UnicodeString(DateFormatSymbols::getPatternUChars()), status);
3935 }
3936 
3937 //----------------------------------------------------------------------
3938 
3939 const DateFormatSymbols*
3940 SimpleDateFormat::getDateFormatSymbols() const
3941 {
3942     return fSymbols;
3943 }
</pre>
<hr />
<pre>
4003   DateFormat::adoptCalendar(calendarToAdopt);
4004   delete fSymbols;
4005   fSymbols = newSymbols;
4006   initializeDefaultCentury();  // we need a new century (possibly)
4007 }
4008 
4009 
4010 //----------------------------------------------------------------------
4011 
4012 
4013 // override the DateFormat implementation in order to
4014 // lazily initialize fCapitalizationBrkIter
4015 void
4016 SimpleDateFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
4017 {
4018     DateFormat::setContext(value, status);
4019 #if !UCONFIG_NO_BREAK_ITERATION
4020     if (U_SUCCESS(status)) {
4021         if ( fCapitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
4022                 value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE) ) {
<span class="line-modified">4023             status = U_ZERO_ERROR;</span>
4024             fCapitalizationBrkIter = BreakIterator::createSentenceInstance(fLocale, status);
4025             if (U_FAILURE(status)) {
4026                 delete fCapitalizationBrkIter;
4027                 fCapitalizationBrkIter = NULL;
4028             }
4029         }
4030     }
4031 #endif
4032 }
4033 
4034 
4035 //----------------------------------------------------------------------
4036 
4037 
4038 UBool
4039 SimpleDateFormat::isFieldUnitIgnored(UCalendarDateFields field) const {
4040     return isFieldUnitIgnored(fPattern, field);
4041 }
4042 
4043 
</pre>
<hr />
<pre>
4220 //----------------------------------------------------------------------
4221 
4222 int32_t
4223 SimpleDateFormat::skipUWhiteSpace(const UnicodeString&amp; text, int32_t pos) const {
4224     while (pos &lt; text.length()) {
4225         UChar32 c = text.char32At(pos);
4226         if (!u_isUWhiteSpace(c)) {
4227             break;
4228         }
4229         pos += U16_LENGTH(c);
4230     }
4231     return pos;
4232 }
4233 
4234 //----------------------------------------------------------------------
4235 
4236 // Lazy TimeZoneFormat instantiation, semantically const.
4237 TimeZoneFormat *
4238 SimpleDateFormat::tzFormat(UErrorCode &amp;status) const {
4239     if (fTimeZoneFormat == NULL) {
<span class="line-modified">4240         umtx_lock(LOCK());</span>
4241         {
4242             if (fTimeZoneFormat == NULL) {
4243                 TimeZoneFormat *tzfmt = TimeZoneFormat::createInstance(fLocale, status);
4244                 if (U_FAILURE(status)) {
4245                     return NULL;
4246                 }
4247 
4248                 const_cast&lt;SimpleDateFormat *&gt;(this)-&gt;fTimeZoneFormat = tzfmt;
4249             }
4250         }
<span class="line-modified">4251         umtx_unlock(LOCK());</span>
4252     }
4253     return fTimeZoneFormat;
4254 }
4255 
4256 void SimpleDateFormat::parsePattern() {
4257     fHasMinute = FALSE;
4258     fHasSecond = FALSE;
<span class="line-added">4259     fHasHanYearChar = FALSE;</span>
4260 
4261     int len = fPattern.length();
4262     UBool inQuote = FALSE;
4263     for (int32_t i = 0; i &lt; len; ++i) {
4264         UChar ch = fPattern[i];
4265         if (ch == QUOTE) {
4266             inQuote = !inQuote;
4267         }
<span class="line-added">4268         if (ch == 0x5E74) { // don&#39;t care whether this is inside quotes</span>
<span class="line-added">4269             fHasHanYearChar = TRUE;</span>
<span class="line-added">4270         }</span>
4271         if (!inQuote) {
4272             if (ch == 0x6D) {  // 0x6D == &#39;m&#39;
4273                 fHasMinute = TRUE;
4274             }
4275             if (ch == 0x73) {  // 0x73 == &#39;s&#39;
4276                 fHasSecond = TRUE;
4277             }
4278         }
4279     }
4280 }
4281 
4282 U_NAMESPACE_END
4283 
4284 #endif /* #if !UCONFIG_NO_FORMATTING */
4285 
4286 //eof
</pre>
</td>
</tr>
</table>
<center><a href="simpletz.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="timezone.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>