<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="region.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldtfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/reldatefmt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // © 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 * Copyright (C) 2014-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File reldatefmt.cpp
  10 ******************************************************************************
  11 */
  12 
  13 #include &quot;unicode/reldatefmt.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
  16 
  17 #include &lt;cmath&gt;

  18 #include &quot;unicode/dtfmtsym.h&quot;
  19 #include &quot;unicode/ucasemap.h&quot;
  20 #include &quot;unicode/ureldatefmt.h&quot;
  21 #include &quot;unicode/udisplaycontext.h&quot;
  22 #include &quot;unicode/unum.h&quot;
  23 #include &quot;unicode/localpointer.h&quot;
  24 #include &quot;unicode/plurrule.h&quot;
  25 #include &quot;unicode/simpleformatter.h&quot;
  26 #include &quot;unicode/decimfmt.h&quot;
  27 #include &quot;unicode/numfmt.h&quot;
  28 #include &quot;unicode/brkiter.h&quot;
  29 #include &quot;unicode/simpleformatter.h&quot;
  30 #include &quot;uresimp.h&quot;
  31 #include &quot;unicode/ures.h&quot;
  32 #include &quot;cstring.h&quot;
  33 #include &quot;ucln_in.h&quot;
  34 #include &quot;mutex.h&quot;
  35 #include &quot;charstr.h&quot;
  36 #include &quot;uassert.h&quot;
  37 #include &quot;quantityformatter.h&quot;
  38 #include &quot;resource.h&quot;
  39 #include &quot;sharedbreakiterator.h&quot;
  40 #include &quot;sharedpluralrules.h&quot;
  41 #include &quot;sharednumberformat.h&quot;
  42 #include &quot;standardplural.h&quot;
  43 #include &quot;unifiedcache.h&quot;






  44 
  45 // Copied from uscript_props.cpp
  46 
<span class="line-removed">  47 static UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
<span class="line-removed">  48 </span>
  49 U_NAMESPACE_BEGIN
  50 
  51 // RelativeDateTimeFormatter specific data for a single locale
  52 class RelativeDateTimeCacheData: public SharedObject {
  53 public:
<span class="line-modified">  54     RelativeDateTimeCacheData() : combinedDateAndTime(NULL) {</span>
  55         // Initialize the cache arrays
  56         for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">  57             for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
  58                 for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<span class="line-modified">  59                     relativeUnitsFormatters[style][relUnit][0][pl] = NULL;</span>
<span class="line-modified">  60                     relativeUnitsFormatters[style][relUnit][1][pl] = NULL;</span>
  61                 }
  62             }
  63         }
  64         for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
  65           fallBackCache[i] = -1;
  66         }
  67     }
  68     virtual ~RelativeDateTimeCacheData();
  69 
  70     // no numbers: e.g Next Tuesday; Yesterday; etc.
  71     UnicodeString absoluteUnits[UDAT_STYLE_COUNT][UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT];
  72 
  73     // SimpleFormatter pointers for relative unit format,
  74     // e.g., Next Tuesday; Yesterday; etc. For third index, 0
  75     // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
  76     SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<span class="line-modified">  77         [UDAT_RELATIVE_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  78 
  79     const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
  80                                                UDateAbsoluteUnit unit,
  81                                                UDateDirection direction) const;
  82     const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
  83                                                     UDateRelativeUnit unit,
  84                                                     int32_t pastFutureIndex,
  85                                                     int32_t pluralUnit) const;




  86 
  87     const UnicodeString emptyString;
  88 
  89     // Mappping from source to target styles for alias fallback.
  90     int32_t fallBackCache[UDAT_STYLE_COUNT];
  91 
  92     void adoptCombinedDateAndTime(SimpleFormatter *fmtToAdopt) {
  93         delete combinedDateAndTime;
  94         combinedDateAndTime = fmtToAdopt;
  95     }
  96     const SimpleFormatter *getCombinedDateAndTime() const {
  97         return combinedDateAndTime;
  98     }
  99 
 100 private:
 101     SimpleFormatter *combinedDateAndTime;
 102     RelativeDateTimeCacheData(const RelativeDateTimeCacheData &amp;other);
 103     RelativeDateTimeCacheData&amp; operator=(
 104             const RelativeDateTimeCacheData &amp;other);
 105 };
 106 
 107 RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
 108     // clear out the cache arrays
 109     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified"> 110         for (int32_t relUnit = 0; relUnit &lt; UDAT_RELATIVE_UNIT_COUNT; ++relUnit) {</span>
 111             for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
 112                 delete relativeUnitsFormatters[style][relUnit][0][pl];
 113                 delete relativeUnitsFormatters[style][relUnit][1][pl];
 114             }
 115         }
 116     }
 117     delete combinedDateAndTime;
 118 }
 119 
 120 
 121 // Use fallback cache for absolute units.
 122 const UnicodeString&amp; RelativeDateTimeCacheData::getAbsoluteUnitString(
 123         int32_t fStyle, UDateAbsoluteUnit unit, UDateDirection direction) const {
 124     int32_t style = fStyle;
 125     do {
 126         if (!absoluteUnits[style][unit][direction].isEmpty()) {
 127             return absoluteUnits[style][unit][direction];
 128         }
 129         style = fallBackCache[style];
 130     } while (style != -1);
 131     return emptyString;
 132 }
 133 
<span class="line-removed"> 134  // Use fallback cache for SimpleFormatter relativeUnits.</span>
 135  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
 136         int32_t fStyle,
 137         UDateRelativeUnit unit,
 138         int32_t pastFutureIndex,
 139         int32_t pluralUnit) const {
<span class="line-modified"> 140     int32_t style = fStyle;</span>
<span class="line-modified"> 141     do {</span>
<span class="line-modified"> 142         if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != NULL) {</span>
<span class="line-modified"> 143             return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>





























 144         }
<span class="line-modified"> 145         style = fallBackCache[style];</span>
<span class="line-modified"> 146     } while (style != -1);</span>
<span class="line-modified"> 147     return NULL;  // No formatter found.</span>
 148  }
 149 
 150 static UBool getStringWithFallback(
 151         const UResourceBundle *resource,
 152         const char *key,
 153         UnicodeString &amp;result,
 154         UErrorCode &amp;status) {
 155     int32_t len = 0;
 156     const UChar *resStr = ures_getStringByKeyWithFallback(
 157         resource, key, &amp;len, &amp;status);
 158     if (U_FAILURE(status)) {
 159         return FALSE;
 160     }
 161     result.setTo(TRUE, resStr, len);
 162     return TRUE;
 163 }
 164 
 165 
 166 static UBool getStringByIndex(
 167         const UResourceBundle *resource,
</pre>
<hr />
<pre>
 200         MINUTE,
 201         HOUR,
 202         DAY,
 203         WEEK,
 204         MONTH,
 205         QUARTER,
 206         YEAR,
 207         SUNDAY,
 208         MONDAY,
 209         TUESDAY,
 210         WEDNESDAY,
 211         THURSDAY,
 212         FRIDAY,
 213         SATURDAY
 214     } RelAbsUnit;
 215 
 216     static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
 217         // Converts the generic units to UDAT_RELATIVE version.
 218         switch (genUnit) {
 219             case SECOND:
<span class="line-modified"> 220                 return UDAT_RELATIVE_SECONDS;</span>
 221             case MINUTE:
<span class="line-modified"> 222                 return UDAT_RELATIVE_MINUTES;</span>
 223             case HOUR:
<span class="line-modified"> 224                 return UDAT_RELATIVE_HOURS;</span>
 225             case DAY:
<span class="line-modified"> 226                 return UDAT_RELATIVE_DAYS;</span>
 227             case WEEK:
<span class="line-modified"> 228                 return UDAT_RELATIVE_WEEKS;</span>
 229             case MONTH:
<span class="line-modified"> 230                 return UDAT_RELATIVE_MONTHS;</span>
<span class="line-modified"> 231             /*</span>
<span class="line-modified"> 232              * case QUARTER:</span>
<span class="line-removed"> 233              * return UDATE_RELATIVE_QUARTERS;</span>
<span class="line-removed"> 234              */</span>
 235             case YEAR:
<span class="line-modified"> 236                 return UDAT_RELATIVE_YEARS;</span>














 237             default:
 238                 return -1;
 239         }
 240     }
 241 
 242     static int32_t absUnitFromGeneric(RelAbsUnit genUnit) {
 243         // Converts the generic units to UDAT_RELATIVE version.
 244         switch (genUnit) {
 245             case DAY:
 246                 return UDAT_ABSOLUTE_DAY;
 247             case WEEK:
 248                 return UDAT_ABSOLUTE_WEEK;
 249             case MONTH:
 250                 return UDAT_ABSOLUTE_MONTH;
<span class="line-modified"> 251             /* TODO: Add in QUARTER</span>
<span class="line-modified"> 252              *  case QUARTER:</span>
<span class="line-removed"> 253              * return UDAT_ABSOLUTE_QUARTER;</span>
<span class="line-removed"> 254              */</span>
 255             case YEAR:
 256                 return UDAT_ABSOLUTE_YEAR;
 257             case SUNDAY:
 258                 return UDAT_ABSOLUTE_SUNDAY;
 259             case MONDAY:
 260                 return UDAT_ABSOLUTE_MONDAY;
 261             case TUESDAY:
 262                 return UDAT_ABSOLUTE_TUESDAY;
 263             case WEDNESDAY:
 264                 return UDAT_ABSOLUTE_WEDNESDAY;
 265             case THURSDAY:
 266                 return UDAT_ABSOLUTE_THURSDAY;
 267             case FRIDAY:
 268                 return UDAT_ABSOLUTE_FRIDAY;
 269             case SATURDAY:
 270                 return UDAT_ABSOLUTE_SATURDAY;
 271             default:
 272                 return -1;
 273         }
 274     }
</pre>
<hr />
<pre>
 295     // Values kept between levels of parsing the CLDR data.
 296     int32_t pastFutureIndex;  // 0 == past or 1 ==  future
 297     UDateRelativeDateTimeFormatterStyle style;  // {LONG, SHORT, NARROW}
 298     RelAbsUnit genericUnit;
 299 
 300     RelativeDateTimeCacheData &amp;outputData;
 301 
 302     // Constructor
 303     RelDateTimeFmtDataSink(RelativeDateTimeCacheData&amp; cacheData)
 304         : outputData(cacheData) {
 305         // Clear cacheData.fallBackCache
 306         cacheData.fallBackCache[UDAT_STYLE_LONG] = -1;
 307         cacheData.fallBackCache[UDAT_STYLE_SHORT] = -1;
 308         cacheData.fallBackCache[UDAT_STYLE_NARROW] = -1;
 309     }
 310 
 311     ~RelDateTimeFmtDataSink();
 312 
 313     // Utility functions
 314     static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<span class="line-modified"> 315         int32_t len = uprv_strlen(s);</span>
 316         if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
 317             return UDAT_STYLE_NARROW;
 318         }
 319         if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
 320             return UDAT_STYLE_SHORT;
 321         }
 322         return UDAT_STYLE_LONG;
 323     }
 324 
 325     static int32_t styleSuffixLength(UDateRelativeDateTimeFormatterStyle style) {
 326         switch (style) {
 327             case UDAT_STYLE_NARROW:
 328                 return 7;
 329             case UDAT_STYLE_SHORT:
 330                 return 6;
 331             default:
 332                 return 0;
 333         }
 334     }
 335 
</pre>
<hr />
<pre>
 413         if (outputData.absoluteUnits[style]
 414             [absUnit][UDAT_DIRECTION_PLAIN].isEmpty()) {
 415             outputData.absoluteUnits[style]
 416                 [absUnit][UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 417             return;
 418         }
 419     }
 420 
 421     void consumeTableRelative(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 422         ResourceTable unitTypesTable = value.getTable(errorCode);
 423         if (U_FAILURE(errorCode)) { return; }
 424 
 425         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 426             if (value.getType() == URES_STRING) {
 427                 int32_t direction = keyToDirection(key);
 428                 if (direction &lt; 0) {
 429                   continue;
 430                 }
 431 
 432                 int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<span class="line-modified"> 433                 if (relUnitIndex == UDAT_RELATIVE_SECONDS &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
 434                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
 435                     // Handle &quot;NOW&quot;
 436                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
 437                         [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 438                 }
 439 
 440                 int32_t absUnitIndex = absUnitFromGeneric(genericUnit);
 441                 if (absUnitIndex &lt; 0) {
 442                     continue;
 443                 }
 444                 // Only reset if slot is empty.
 445                 if (outputData.absoluteUnits[style][absUnitIndex][direction].isEmpty()) {
 446                     outputData.absoluteUnits[style][absUnitIndex]
 447                         [direction].fastCopyFrom(value.getUnicodeString(errorCode));
 448                 }
 449             }
 450         }
 451     }
 452 
 453     void consumeTimeDetail(int32_t relUnitIndex,
 454                            const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 455         ResourceTable unitTypesTable = value.getTable(errorCode);
 456         if (U_FAILURE(errorCode)) { return; }
 457 
 458           for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 459             if (value.getType() == URES_STRING) {
 460                 int32_t pluralIndex = StandardPlural::indexOrNegativeFromString(key);
 461                 if (pluralIndex &gt;= 0) {
 462                     SimpleFormatter **patterns =
 463                         outputData.relativeUnitsFormatters[style][relUnitIndex]
 464                         [pastFutureIndex];
 465                     // Only set if not already established.
<span class="line-modified"> 466                     if (patterns[pluralIndex] == NULL) {</span>
 467                         patterns[pluralIndex] = new SimpleFormatter(
 468                             value.getUnicodeString(errorCode), 0, 1, errorCode);
<span class="line-modified"> 469                         if (patterns[pluralIndex] == NULL) {</span>
 470                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 471                         }
 472                     }
 473                 }
 474             }
 475         }
 476     }
 477 
 478     void consumeTableRelativeTime(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 479         ResourceTable relativeTimeTable = value.getTable(errorCode);
 480         if (U_FAILURE(errorCode)) { return; }
 481 
 482         int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
 483         if (relUnitIndex &lt; 0) {
 484             return;
 485         }
 486         for (int32_t i = 0; relativeTimeTable.getKeyAndValue(i, key, value); ++i) {
 487             if (uprv_strcmp(key, &quot;past&quot;) == 0) {
 488                 pastFutureIndex = 0;
 489             } else if (uprv_strcmp(key, &quot;future&quot;) == 0) {
</pre>
<hr />
<pre>
 529             if (value.getType() == URES_TABLE) {
 530                 if (uprv_strcmp(key, &quot;relative&quot;) == 0) {
 531                     consumeTableRelative(key, value, errorCode);
 532                 } else if (uprv_strcmp(key, &quot;relativeTime&quot;) == 0) {
 533                     consumeTableRelativeTime(key, value, errorCode);
 534                 }
 535             }
 536         }
 537     }
 538 
 539     virtual void put(const char *key, ResourceValue &amp;value,
 540                      UBool /*noFallback*/, UErrorCode &amp;errorCode) {
 541         // Main entry point to sink
 542         ResourceTable table = value.getTable(errorCode);
 543         if (U_FAILURE(errorCode)) { return; }
 544         for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
 545             if (value.getType() == URES_ALIAS) {
 546                 consumeAlias(key, value, errorCode);
 547             } else {
 548                 style = styleFromString(key);
<span class="line-modified"> 549                 int32_t unitSize = uprv_strlen(key) - styleSuffixLength(style);</span>
 550                 genericUnit = unitOrNegativeFromString(key, unitSize);
 551                 if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
 552                     consumeTimeUnit(key, value, errorCode);
 553                 }
 554             }
 555         }
 556     }
 557 
 558 };
 559 
 560 // Virtual destructors must be defined out of line.
 561 RelDateTimeFmtDataSink::~RelDateTimeFmtDataSink() {}
 562 } // namespace
 563 
 564 static const DateFormatSymbols::DtWidthType styleToDateFormatSymbolWidth[UDAT_STYLE_COUNT] = {
 565   DateFormatSymbols::WIDE, DateFormatSymbols::SHORT, DateFormatSymbols::NARROW
 566 };
 567 
 568 // Get days of weeks from the DateFormatSymbols class.
 569 static void loadWeekdayNames(UnicodeString absoluteUnits[UDAT_STYLE_COUNT]
 570                                  [UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT],
 571                              const char* localeId,
 572                              UErrorCode&amp; status) {



 573     Locale locale(localeId);
 574     DateFormatSymbols dfSym(locale, status);



 575     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
 576         DateFormatSymbols::DtWidthType dtfmtWidth = styleToDateFormatSymbolWidth[style];
 577         int32_t count;
 578         const UnicodeString* weekdayNames =
 579             dfSym.getWeekdays(count, DateFormatSymbols::STANDALONE, dtfmtWidth);
 580         for (int32_t dayIndex = UDAT_ABSOLUTE_SUNDAY;
 581                 dayIndex &lt;= UDAT_ABSOLUTE_SATURDAY; ++ dayIndex) {
 582             int32_t dateSymbolIndex = (dayIndex - UDAT_ABSOLUTE_SUNDAY) + UCAL_SUNDAY;
 583             absoluteUnits[style][dayIndex][UDAT_DIRECTION_PLAIN].fastCopyFrom(
 584                 weekdayNames[dateSymbolIndex]);
 585         }
 586     }
 587 }
 588 
 589 static UBool loadUnitData(
 590         const UResourceBundle *resource,
 591         RelativeDateTimeCacheData &amp;cacheData,
 592         const char* localeId,
 593         UErrorCode &amp;status) {
 594 
 595     RelDateTimeFmtDataSink sink(cacheData);
 596 
 597     ures_getAllItemsWithFallback(resource, &quot;fields&quot;, sink, status);



 598 
 599     // Get the weekday names from DateFormatSymbols.
 600     loadWeekdayNames(cacheData.absoluteUnits, localeId, status);
 601     return U_SUCCESS(status);
 602 }
 603 
 604 static UBool getDateTimePattern(
 605         const UResourceBundle *resource,
 606         UnicodeString &amp;result,
 607         UErrorCode &amp;status) {
 608     UnicodeString defaultCalendarName;
 609     if (!getStringWithFallback(
 610             resource,
 611             &quot;calendar/default&quot;,
 612             defaultCalendarName,
 613             status)) {
 614         return FALSE;
 615     }
 616     CharString pathBuffer;
 617     pathBuffer.append(&quot;calendar/&quot;, status)
 618             .appendInvariantChars(defaultCalendarName, status)
 619             .append(&quot;/DateTimePatterns&quot;, status);
 620     LocalUResourceBundlePointer topLevel(
 621             ures_getByKeyWithFallback(
<span class="line-modified"> 622                     resource, pathBuffer.data(), NULL, &amp;status));</span>
 623     if (U_FAILURE(status)) {
 624         return FALSE;
 625     }
 626     int32_t size = ures_getSize(topLevel.getAlias());
 627     if (size &lt;= 8) {
 628         // Oops, size is too small to access the index that we want, fallback
 629         // to a hard-coded value.
 630         result = UNICODE_STRING_SIMPLE(&quot;{1} {0}&quot;);
 631         return TRUE;
 632     }
 633     return getStringByIndex(topLevel.getAlias(), 8, result, status);
 634 }
 635 
 636 template&lt;&gt; U_I18N_API
 637 const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
 638     const char *localeId = fLoc.getName();
<span class="line-modified"> 639     LocalUResourceBundlePointer topLevel(ures_open(NULL, localeId, &amp;status));</span>
 640     if (U_FAILURE(status)) {
<span class="line-modified"> 641         return NULL;</span>
 642     }
 643     LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
 644             new RelativeDateTimeCacheData());
 645     if (result.isNull()) {
 646         status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified"> 647         return NULL;</span>
 648     }
 649     if (!loadUnitData(
 650             topLevel.getAlias(),
 651             *result,
 652             localeId,
 653             status)) {
<span class="line-modified"> 654         return NULL;</span>
 655     }
 656     UnicodeString dateTimePattern;
 657     if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<span class="line-modified"> 658         return NULL;</span>
 659     }
 660     result-&gt;adoptCombinedDateAndTime(
 661             new SimpleFormatter(dateTimePattern, 2, 2, status));
 662     if (U_FAILURE(status)) {
<span class="line-modified"> 663         return NULL;</span>
 664     }
 665     result-&gt;addRef();
 666     return result.orphan();
 667 }
 668 




















 669 RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<span class="line-modified"> 670         fCache(NULL),</span>
<span class="line-modified"> 671         fNumberFormat(NULL),</span>
<span class="line-modified"> 672         fPluralRules(NULL),</span>
 673         fStyle(UDAT_STYLE_LONG),
 674         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 675         fOptBreakIterator(NULL) {</span>
<span class="line-modified"> 676     init(NULL, NULL, status);</span>
 677 }
 678 
 679 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 680         const Locale&amp; locale, UErrorCode&amp; status) :
<span class="line-modified"> 681         fCache(NULL),</span>
<span class="line-modified"> 682         fNumberFormat(NULL),</span>
<span class="line-modified"> 683         fPluralRules(NULL),</span>
 684         fStyle(UDAT_STYLE_LONG),
 685         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 686         fOptBreakIterator(NULL),</span>
 687         fLocale(locale) {
<span class="line-modified"> 688     init(NULL, NULL, status);</span>
 689 }
 690 
 691 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 692         const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<span class="line-modified"> 693         fCache(NULL),</span>
<span class="line-modified"> 694         fNumberFormat(NULL),</span>
<span class="line-modified"> 695         fPluralRules(NULL),</span>
 696         fStyle(UDAT_STYLE_LONG),
 697         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 698         fOptBreakIterator(NULL),</span>
 699         fLocale(locale) {
<span class="line-modified"> 700     init(nfToAdopt, NULL, status);</span>
 701 }
 702 
 703 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 704         const Locale&amp; locale,
 705         NumberFormat *nfToAdopt,
 706         UDateRelativeDateTimeFormatterStyle styl,
 707         UDisplayContext capitalizationContext,
 708         UErrorCode&amp; status) :
<span class="line-modified"> 709         fCache(NULL),</span>
<span class="line-modified"> 710         fNumberFormat(NULL),</span>
<span class="line-modified"> 711         fPluralRules(NULL),</span>
 712         fStyle(styl),
 713         fContext(capitalizationContext),
<span class="line-modified"> 714         fOptBreakIterator(NULL),</span>
 715         fLocale(locale) {
 716     if (U_FAILURE(status)) {
 717         return;
 718     }
 719     if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
 720         status = U_ILLEGAL_ARGUMENT_ERROR;
 721         return;
 722     }
 723     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
 724         BreakIterator *bi = BreakIterator::createSentenceInstance(locale, status);
 725         if (U_FAILURE(status)) {
 726             return;
 727         }
 728         init(nfToAdopt, bi, status);
 729     } else {
<span class="line-modified"> 730         init(nfToAdopt, NULL, status);</span>
 731     }
 732 }
 733 
 734 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 735         const RelativeDateTimeFormatter&amp; other)
 736         : UObject(other),
 737           fCache(other.fCache),
 738           fNumberFormat(other.fNumberFormat),
 739           fPluralRules(other.fPluralRules),
 740           fStyle(other.fStyle),
 741           fContext(other.fContext),
 742           fOptBreakIterator(other.fOptBreakIterator),
 743           fLocale(other.fLocale) {
 744     fCache-&gt;addRef();
 745     fNumberFormat-&gt;addRef();
 746     fPluralRules-&gt;addRef();
<span class="line-modified"> 747     if (fOptBreakIterator != NULL) {</span>
 748       fOptBreakIterator-&gt;addRef();
 749     }
 750 }
 751 
 752 RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
 753         const RelativeDateTimeFormatter&amp; other) {
 754     if (this != &amp;other) {
 755         SharedObject::copyPtr(other.fCache, fCache);
 756         SharedObject::copyPtr(other.fNumberFormat, fNumberFormat);
 757         SharedObject::copyPtr(other.fPluralRules, fPluralRules);
 758         SharedObject::copyPtr(other.fOptBreakIterator, fOptBreakIterator);
 759         fStyle = other.fStyle;
 760         fContext = other.fContext;
 761         fLocale = other.fLocale;
 762     }
 763     return *this;
 764 }
 765 
 766 RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<span class="line-modified"> 767     if (fCache != NULL) {</span>
 768         fCache-&gt;removeRef();
 769     }
<span class="line-modified"> 770     if (fNumberFormat != NULL) {</span>
 771         fNumberFormat-&gt;removeRef();
 772     }
<span class="line-modified"> 773     if (fPluralRules != NULL) {</span>
 774         fPluralRules-&gt;removeRef();
 775     }
<span class="line-modified"> 776     if (fOptBreakIterator != NULL) {</span>
 777         fOptBreakIterator-&gt;removeRef();
 778     }
 779 }
 780 
 781 const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
 782     return **fNumberFormat;
 783 }
 784 
 785 UDisplayContext RelativeDateTimeFormatter::getCapitalizationContext() const {
 786     return fContext;
 787 }
 788 
 789 UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
 790     return fStyle;
 791 }
 792 
<span class="line-modified"> 793 UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-modified"> 794         double quantity, UDateDirection direction, UDateRelativeUnit unit,</span>
<span class="line-modified"> 795         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>









 796     if (U_FAILURE(status)) {
 797         return appendTo;
 798     }



























































 799     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
 800         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 801         return appendTo;</span>
 802     }
 803     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;
<span class="line-removed"> 804     FieldPosition pos(FieldPosition::DONT_CARE);</span>
<span class="line-removed"> 805 </span>
<span class="line-removed"> 806     UnicodeString result;</span>
<span class="line-removed"> 807     UnicodeString formattedNumber;</span>
 808 
<span class="line-modified"> 809     StandardPlural::Form pluralIndex = QuantityFormatter::selectPlural(</span>
<span class="line-modified"> 810         quantity, **fNumberFormat, **fPluralRules, formattedNumber, pos,</span>





 811         status);



 812 
 813     const SimpleFormatter* formatter =
<span class="line-modified"> 814         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralIndex);</span>
<span class="line-modified"> 815     if (formatter == NULL) {</span>
 816         // TODO: WARN - look at quantity formatter&#39;s action with an error.
 817         status = U_INVALID_FORMAT_ERROR;
<span class="line-modified"> 818         return appendTo;</span>
 819     }
<span class="line-modified"> 820     formatter-&gt;format(formattedNumber, result, status);</span>
<span class="line-modified"> 821     adjustForContext(result);</span>
<span class="line-modified"> 822     return appendTo.append(result);</span>

 823 }
 824 
 825 UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<span class="line-modified"> 826         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified"> 827         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 828     if (U_FAILURE(status)) {
<span class="line-modified"> 829         return appendTo;</span>
<span class="line-removed"> 830     }</span>
<span class="line-removed"> 831     // TODO:</span>
<span class="line-removed"> 832     // The full implementation of this depends on CLDR data that is not yet available,</span>
<span class="line-removed"> 833     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.</span>
<span class="line-removed"> 834     // In the meantime do a quick bring-up by calling the old format method; this</span>
<span class="line-removed"> 835     // leaves some holes (even for data that is currently available, such as quarter).</span>
<span class="line-removed"> 836     // When the new CLDR data is available, update the data storage accordingly,</span>
<span class="line-removed"> 837     // rewrite this to use it directly, and rewrite the old format method to call this</span>
<span class="line-removed"> 838     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.</span>
<span class="line-removed"> 839     UDateRelativeUnit relunit = UDAT_RELATIVE_UNIT_COUNT;</span>
<span class="line-removed"> 840     switch (unit) {</span>
<span class="line-removed"> 841         case UDAT_REL_UNIT_YEAR:    relunit = UDAT_RELATIVE_YEARS; break;</span>
<span class="line-removed"> 842         case UDAT_REL_UNIT_MONTH:   relunit = UDAT_RELATIVE_MONTHS; break;</span>
<span class="line-removed"> 843         case UDAT_REL_UNIT_WEEK:    relunit = UDAT_RELATIVE_WEEKS; break;</span>
<span class="line-removed"> 844         case UDAT_REL_UNIT_DAY:     relunit = UDAT_RELATIVE_DAYS; break;</span>
<span class="line-removed"> 845         case UDAT_REL_UNIT_HOUR:    relunit = UDAT_RELATIVE_HOURS; break;</span>
<span class="line-removed"> 846         case UDAT_REL_UNIT_MINUTE:  relunit = UDAT_RELATIVE_MINUTES; break;</span>
<span class="line-removed"> 847         case UDAT_REL_UNIT_SECOND:  relunit = UDAT_RELATIVE_SECONDS; break;</span>
<span class="line-removed"> 848         default: // a unit that the above method does not handle</span>
<span class="line-removed"> 849             status = U_UNSUPPORTED_ERROR;</span>
<span class="line-removed"> 850             return appendTo;</span>
 851     }
 852     UDateDirection direction = UDAT_DIRECTION_NEXT;
 853     if (std::signbit(offset)) { // needed to handle -0.0
 854         direction = UDAT_DIRECTION_LAST;
 855         offset = -offset;
 856     }
<span class="line-modified"> 857     return format(offset, direction, relunit, appendTo, status);</span>




























 858 }
 859 
 860 UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified"> 861         UDateDirection direction, UDateAbsoluteUnit unit,</span>
<span class="line-modified"> 862         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 863     if (U_FAILURE(status)) {
<span class="line-modified"> 864         return appendTo;</span>
 865     }
 866     if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
 867         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 868         return appendTo;</span>
 869     }
 870 
 871     // Get string using fallback.
<span class="line-modified"> 872     UnicodeString result;</span>
<span class="line-modified"> 873     result.fastCopyFrom(fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction));</span>
<span class="line-modified"> 874     if (fOptBreakIterator != NULL) {</span>
<span class="line-modified"> 875         adjustForContext(result);</span>
<span class="line-removed"> 876     }</span>
<span class="line-removed"> 877     return appendTo.append(result);</span>
 878 }
 879 
 880 UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified"> 881         double offset, URelativeDateTimeUnit unit,</span>
<span class="line-modified"> 882         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {</span>


























 883     if (U_FAILURE(status)) {
<span class="line-modified"> 884         return appendTo;</span>
 885     }
 886     // TODO:
 887     // The full implementation of this depends on CLDR data that is not yet available,
 888     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
 889     // In the meantime do a quick bring-up by calling the old format method; this
 890     // leaves some holes (even for data that is currently available, such as quarter).
 891     // When the new CLDR data is available, update the data storage accordingly,
 892     // rewrite this to use it directly, and rewrite the old format method to call this
 893     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.
 894     UDateDirection direction = UDAT_DIRECTION_COUNT;
 895     if (offset &gt; -2.1 &amp;&amp; offset &lt; 2.1) {
 896         // Allow a 1% epsilon, so offsets in -1.01..-0.99 map to LAST
 897         double offsetx100 = offset * 100.0;
 898         int32_t intoffset = (offsetx100 &lt; 0)? (int32_t)(offsetx100-0.5) : (int32_t)(offsetx100+0.5);
 899         switch (intoffset) {
 900             case -200/*-2*/: direction = UDAT_DIRECTION_LAST_2; break;
 901             case -100/*-1*/: direction = UDAT_DIRECTION_LAST; break;
 902             case    0/* 0*/: direction = UDAT_DIRECTION_THIS; break;
 903             case  100/* 1*/: direction = UDAT_DIRECTION_NEXT; break;
 904             case  200/* 2*/: direction = UDAT_DIRECTION_NEXT_2; break;
 905             default: break;
 906         }
 907     }
 908     UDateAbsoluteUnit absunit = UDAT_ABSOLUTE_UNIT_COUNT;
 909     switch (unit) {
 910         case UDAT_REL_UNIT_YEAR:    absunit = UDAT_ABSOLUTE_YEAR; break;

 911         case UDAT_REL_UNIT_MONTH:   absunit = UDAT_ABSOLUTE_MONTH; break;
 912         case UDAT_REL_UNIT_WEEK:    absunit = UDAT_ABSOLUTE_WEEK; break;
 913         case UDAT_REL_UNIT_DAY:     absunit = UDAT_ABSOLUTE_DAY; break;
 914         case UDAT_REL_UNIT_SECOND:
 915             if (direction == UDAT_DIRECTION_THIS) {
 916                 absunit = UDAT_ABSOLUTE_NOW;
 917                 direction = UDAT_DIRECTION_PLAIN;
 918             }
 919             break;
 920         case UDAT_REL_UNIT_SUNDAY:  absunit = UDAT_ABSOLUTE_SUNDAY; break;
 921         case UDAT_REL_UNIT_MONDAY:  absunit = UDAT_ABSOLUTE_MONDAY; break;
 922         case UDAT_REL_UNIT_TUESDAY:  absunit = UDAT_ABSOLUTE_TUESDAY; break;
 923         case UDAT_REL_UNIT_WEDNESDAY:  absunit = UDAT_ABSOLUTE_WEDNESDAY; break;
 924         case UDAT_REL_UNIT_THURSDAY:  absunit = UDAT_ABSOLUTE_THURSDAY; break;
 925         case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
 926         case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
 927         default: break;
 928     }
 929     if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<span class="line-modified"> 930         const UnicodeString &amp;unitFormatString =</span>
<span class="line-modified"> 931             fCache-&gt;getAbsoluteUnitString(fStyle, absunit, direction);</span>
<span class="line-modified"> 932         if (!unitFormatString.isEmpty()) {</span>
<span class="line-removed"> 933             if (fOptBreakIterator != NULL) {</span>
<span class="line-removed"> 934                 UnicodeString result(unitFormatString);</span>
<span class="line-removed"> 935                 adjustForContext(result);</span>
<span class="line-removed"> 936                 return appendTo.append(result);</span>
<span class="line-removed"> 937             } else {</span>
<span class="line-removed"> 938                 return appendTo.append(unitFormatString);</span>
<span class="line-removed"> 939             }</span>
 940         }
 941     }
 942     // otherwise fallback to formatNumeric
<span class="line-modified"> 943     return formatNumeric(offset, unit, appendTo, status);</span>
 944 }
 945 
 946 UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
 947         const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
 948         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
 949     return fCache-&gt;getCombinedDateAndTime()-&gt;format(
 950             timeString, relativeDateString, appendTo, status);
 951 }
 952 
<span class="line-modified"> 953 void RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified"> 954     if (fOptBreakIterator == NULL</span>
 955         || str.length() == 0 || !u_islower(str.char32At(0))) {
<span class="line-modified"> 956         return;</span>
 957     }
 958 
 959     // Must guarantee that one thread at a time accesses the shared break
 960     // iterator.

 961     Mutex lock(&amp;gBrkIterMutex);
 962     str.toTitle(
 963             fOptBreakIterator-&gt;get(),
 964             fLocale,
 965             U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);











 966 }
 967 
 968 void RelativeDateTimeFormatter::init(
 969         NumberFormat *nfToAdopt,
 970         BreakIterator *biToAdopt,
 971         UErrorCode &amp;status) {
 972     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
 973     LocalPointer&lt;BreakIterator&gt; bi(biToAdopt);
 974     UnifiedCache::getByLocale(fLocale, fCache, status);
 975     if (U_FAILURE(status)) {
 976         return;
 977     }
 978     const SharedPluralRules *pr = PluralRules::createSharedInstance(
 979             fLocale, UPLURAL_TYPE_CARDINAL, status);
 980     if (U_FAILURE(status)) {
 981         return;
 982     }
 983     SharedObject::copyPtr(pr, fPluralRules);
 984     pr-&gt;removeRef();
 985     if (nf.isNull()) {
 986        const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
 987                fLocale, UNUM_DECIMAL, status);
 988         if (U_FAILURE(status)) {
 989             return;
 990         }
 991         SharedObject::copyPtr(shared, fNumberFormat);
 992         shared-&gt;removeRef();
 993     } else {
 994         SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<span class="line-modified"> 995         if (shared == NULL) {</span>
 996             status = U_MEMORY_ALLOCATION_ERROR;
 997             return;
 998         }
 999         nf.orphan();
1000         SharedObject::copyPtr(shared, fNumberFormat);
1001     }
1002     if (bi.isNull()) {
1003         SharedObject::clearPtr(fOptBreakIterator);
1004     } else {
1005         SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<span class="line-modified">1006         if (shared == NULL) {</span>
1007             status = U_MEMORY_ALLOCATION_ERROR;
1008             return;
1009         }
1010         bi.orphan();
1011         SharedObject::copyPtr(shared, fOptBreakIterator);
1012     }
1013 }
1014 
1015 U_NAMESPACE_END
1016 
1017 // Plain C API
1018 
1019 U_NAMESPACE_USE
1020 











1021 U_CAPI URelativeDateTimeFormatter* U_EXPORT2
1022 ureldatefmt_open( const char*          locale,
1023                   UNumberFormat*       nfToAdopt,
1024                   UDateRelativeDateTimeFormatterStyle width,
1025                   UDisplayContext      capitalizationContext,
1026                   UErrorCode*          status )
1027 {
1028     if (U_FAILURE(*status)) {
<span class="line-modified">1029         return NULL;</span>
1030     }
1031     LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
1032                                                               (NumberFormat*)nfToAdopt, width,
1033                                                               capitalizationContext, *status), *status);
1034     if (U_FAILURE(*status)) {
<span class="line-modified">1035         return NULL;</span>
1036     }
1037     return (URelativeDateTimeFormatter*)formatter.orphan();
1038 }
1039 
1040 U_CAPI void U_EXPORT2
1041 ureldatefmt_close(URelativeDateTimeFormatter *reldatefmt)
1042 {
1043     delete (RelativeDateTimeFormatter*)reldatefmt;
1044 }
1045 
1046 U_CAPI int32_t U_EXPORT2
1047 ureldatefmt_formatNumeric( const URelativeDateTimeFormatter* reldatefmt,
1048                     double                offset,
1049                     URelativeDateTimeUnit unit,
1050                     UChar*                result,
1051                     int32_t               resultCapacity,
1052                     UErrorCode*           status)
1053 {
1054     if (U_FAILURE(*status)) {
1055         return 0;
1056     }
<span class="line-modified">1057     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1058         *status = U_ILLEGAL_ARGUMENT_ERROR;
1059         return 0;
1060     }
1061     UnicodeString res;
<span class="line-modified">1062     if (result != NULL) {</span>
<span class="line-modified">1063         // NULL destination for pure preflighting: empty dummy string</span>
1064         // otherwise, alias the destination buffer (copied from udat_format)
1065         res.setTo(result, 0, resultCapacity);
1066     }
1067     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
1068     if (U_FAILURE(*status)) {
1069         return 0;
1070     }
1071     return res.extract(result, resultCapacity, *status);
1072 }
1073 















1074 U_CAPI int32_t U_EXPORT2
1075 ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
1076                     double                offset,
1077                     URelativeDateTimeUnit unit,
1078                     UChar*                result,
1079                     int32_t               resultCapacity,
1080                     UErrorCode*           status)
1081 {
1082     if (U_FAILURE(*status)) {
1083         return 0;
1084     }
<span class="line-modified">1085     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1086         *status = U_ILLEGAL_ARGUMENT_ERROR;
1087         return 0;
1088     }
1089     UnicodeString res;
<span class="line-modified">1090     if (result != NULL) {</span>
<span class="line-modified">1091         // NULL destination for pure preflighting: empty dummy string</span>
1092         // otherwise, alias the destination buffer (copied from udat_format)
1093         res.setTo(result, 0, resultCapacity);
1094     }
1095     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
1096     if (U_FAILURE(*status)) {
1097         return 0;
1098     }
1099     return res.extract(result, resultCapacity, *status);
1100 }
1101 















1102 U_CAPI int32_t U_EXPORT2
1103 ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
1104                     const UChar *     relativeDateString,
1105                     int32_t           relativeDateStringLen,
1106                     const UChar *     timeString,
1107                     int32_t           timeStringLen,
1108                     UChar*            result,
1109                     int32_t           resultCapacity,
1110                     UErrorCode*       status )
1111 {
1112     if (U_FAILURE(*status)) {
1113         return 0;
1114     }
<span class="line-modified">1115     if (result == NULL ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">1116             (relativeDateString == NULL ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">1117             (timeString == NULL ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
1118         *status = U_ILLEGAL_ARGUMENT_ERROR;
1119         return 0;
1120     }
1121     UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
1122     UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
1123     UnicodeString res(result, 0, resultCapacity);
1124     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;combineDateAndTime(relDateStr, timeStr, res, *status);
1125     if (U_FAILURE(*status)) {
1126         return 0;
1127     }
1128     return res.extract(result, resultCapacity, *status);
1129 }
1130 
1131 #endif /* !UCONFIG_NO_FORMATTING */
</pre>
</td>
<td>
<hr />
<pre>
   1 // © 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ******************************************************************************
   5 * Copyright (C) 2014-2016, International Business Machines Corporation and
   6 * others. All Rights Reserved.
   7 ******************************************************************************
   8 *
   9 * File reldatefmt.cpp
  10 ******************************************************************************
  11 */
  12 
  13 #include &quot;unicode/reldatefmt.h&quot;
  14 
  15 #if !UCONFIG_NO_FORMATTING &amp;&amp; !UCONFIG_NO_BREAK_ITERATION
  16 
  17 #include &lt;cmath&gt;
<span class="line-added">  18 #include &lt;functional&gt;</span>
  19 #include &quot;unicode/dtfmtsym.h&quot;
  20 #include &quot;unicode/ucasemap.h&quot;
  21 #include &quot;unicode/ureldatefmt.h&quot;
  22 #include &quot;unicode/udisplaycontext.h&quot;
  23 #include &quot;unicode/unum.h&quot;
  24 #include &quot;unicode/localpointer.h&quot;
  25 #include &quot;unicode/plurrule.h&quot;
  26 #include &quot;unicode/simpleformatter.h&quot;
  27 #include &quot;unicode/decimfmt.h&quot;
  28 #include &quot;unicode/numfmt.h&quot;
  29 #include &quot;unicode/brkiter.h&quot;
  30 #include &quot;unicode/simpleformatter.h&quot;
  31 #include &quot;uresimp.h&quot;
  32 #include &quot;unicode/ures.h&quot;
  33 #include &quot;cstring.h&quot;
  34 #include &quot;ucln_in.h&quot;
  35 #include &quot;mutex.h&quot;
  36 #include &quot;charstr.h&quot;
  37 #include &quot;uassert.h&quot;
  38 #include &quot;quantityformatter.h&quot;
  39 #include &quot;resource.h&quot;
  40 #include &quot;sharedbreakiterator.h&quot;
  41 #include &quot;sharedpluralrules.h&quot;
  42 #include &quot;sharednumberformat.h&quot;
  43 #include &quot;standardplural.h&quot;
  44 #include &quot;unifiedcache.h&quot;
<span class="line-added">  45 #include &quot;util.h&quot;</span>
<span class="line-added">  46 #include &quot;number_stringbuilder.h&quot;</span>
<span class="line-added">  47 #include &quot;number_utypes.h&quot;</span>
<span class="line-added">  48 #include &quot;number_modifiers.h&quot;</span>
<span class="line-added">  49 #include &quot;formattedval_impl.h&quot;</span>
<span class="line-added">  50 #include &quot;number_utils.h&quot;</span>
  51 
  52 // Copied from uscript_props.cpp
  53 


  54 U_NAMESPACE_BEGIN
  55 
  56 // RelativeDateTimeFormatter specific data for a single locale
  57 class RelativeDateTimeCacheData: public SharedObject {
  58 public:
<span class="line-modified">  59     RelativeDateTimeCacheData() : combinedDateAndTime(nullptr) {</span>
  60         // Initialize the cache arrays
  61         for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified">  62             for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
  63                 for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
<span class="line-modified">  64                     relativeUnitsFormatters[style][relUnit][0][pl] = nullptr;</span>
<span class="line-modified">  65                     relativeUnitsFormatters[style][relUnit][1][pl] = nullptr;</span>
  66                 }
  67             }
  68         }
  69         for (int32_t i = 0; i &lt; UDAT_STYLE_COUNT; ++i) {
  70           fallBackCache[i] = -1;
  71         }
  72     }
  73     virtual ~RelativeDateTimeCacheData();
  74 
  75     // no numbers: e.g Next Tuesday; Yesterday; etc.
  76     UnicodeString absoluteUnits[UDAT_STYLE_COUNT][UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT];
  77 
  78     // SimpleFormatter pointers for relative unit format,
  79     // e.g., Next Tuesday; Yesterday; etc. For third index, 0
  80     // means past, e.g., 5 days ago; 1 means future, e.g., in 5 days.
  81     SimpleFormatter *relativeUnitsFormatters[UDAT_STYLE_COUNT]
<span class="line-modified">  82         [UDAT_REL_UNIT_COUNT][2][StandardPlural::COUNT];</span>
  83 
  84     const UnicodeString&amp; getAbsoluteUnitString(int32_t fStyle,
  85                                                UDateAbsoluteUnit unit,
  86                                                UDateDirection direction) const;
  87     const SimpleFormatter* getRelativeUnitFormatter(int32_t fStyle,
  88                                                     UDateRelativeUnit unit,
  89                                                     int32_t pastFutureIndex,
  90                                                     int32_t pluralUnit) const;
<span class="line-added">  91     const SimpleFormatter* getRelativeDateTimeUnitFormatter(int32_t fStyle,</span>
<span class="line-added">  92                                                     URelativeDateTimeUnit unit,</span>
<span class="line-added">  93                                                     int32_t pastFutureIndex,</span>
<span class="line-added">  94                                                     int32_t pluralUnit) const;</span>
  95 
  96     const UnicodeString emptyString;
  97 
  98     // Mappping from source to target styles for alias fallback.
  99     int32_t fallBackCache[UDAT_STYLE_COUNT];
 100 
 101     void adoptCombinedDateAndTime(SimpleFormatter *fmtToAdopt) {
 102         delete combinedDateAndTime;
 103         combinedDateAndTime = fmtToAdopt;
 104     }
 105     const SimpleFormatter *getCombinedDateAndTime() const {
 106         return combinedDateAndTime;
 107     }
 108 
 109 private:
 110     SimpleFormatter *combinedDateAndTime;
 111     RelativeDateTimeCacheData(const RelativeDateTimeCacheData &amp;other);
 112     RelativeDateTimeCacheData&amp; operator=(
 113             const RelativeDateTimeCacheData &amp;other);
 114 };
 115 
 116 RelativeDateTimeCacheData::~RelativeDateTimeCacheData() {
 117     // clear out the cache arrays
 118     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
<span class="line-modified"> 119         for (int32_t relUnit = 0; relUnit &lt; UDAT_REL_UNIT_COUNT; ++relUnit) {</span>
 120             for (int32_t pl = 0; pl &lt; StandardPlural::COUNT; ++pl) {
 121                 delete relativeUnitsFormatters[style][relUnit][0][pl];
 122                 delete relativeUnitsFormatters[style][relUnit][1][pl];
 123             }
 124         }
 125     }
 126     delete combinedDateAndTime;
 127 }
 128 
 129 
 130 // Use fallback cache for absolute units.
 131 const UnicodeString&amp; RelativeDateTimeCacheData::getAbsoluteUnitString(
 132         int32_t fStyle, UDateAbsoluteUnit unit, UDateDirection direction) const {
 133     int32_t style = fStyle;
 134     do {
 135         if (!absoluteUnits[style][unit][direction].isEmpty()) {
 136             return absoluteUnits[style][unit][direction];
 137         }
 138         style = fallBackCache[style];
 139     } while (style != -1);
 140     return emptyString;
 141 }
 142 

 143  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeUnitFormatter(
 144         int32_t fStyle,
 145         UDateRelativeUnit unit,
 146         int32_t pastFutureIndex,
 147         int32_t pluralUnit) const {
<span class="line-modified"> 148    URelativeDateTimeUnit rdtunit = UDAT_REL_UNIT_COUNT;</span>
<span class="line-modified"> 149    switch (unit) {</span>
<span class="line-modified"> 150        case UDAT_RELATIVE_YEARS:   rdtunit = UDAT_REL_UNIT_YEAR; break;</span>
<span class="line-modified"> 151        case UDAT_RELATIVE_MONTHS:  rdtunit = UDAT_REL_UNIT_MONTH; break;</span>
<span class="line-added"> 152        case UDAT_RELATIVE_WEEKS:   rdtunit = UDAT_REL_UNIT_WEEK; break;</span>
<span class="line-added"> 153        case UDAT_RELATIVE_DAYS:    rdtunit = UDAT_REL_UNIT_DAY; break;</span>
<span class="line-added"> 154        case UDAT_RELATIVE_HOURS:   rdtunit = UDAT_REL_UNIT_HOUR; break;</span>
<span class="line-added"> 155        case UDAT_RELATIVE_MINUTES: rdtunit = UDAT_REL_UNIT_MINUTE; break;</span>
<span class="line-added"> 156        case UDAT_RELATIVE_SECONDS: rdtunit = UDAT_REL_UNIT_SECOND; break;</span>
<span class="line-added"> 157        default: // a unit that the above method does not handle</span>
<span class="line-added"> 158             return nullptr;</span>
<span class="line-added"> 159    }</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161    return getRelativeDateTimeUnitFormatter(fStyle, rdtunit, pastFutureIndex, pluralUnit);</span>
<span class="line-added"> 162  }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164  // Use fallback cache for SimpleFormatter relativeUnits.</span>
<span class="line-added"> 165  const SimpleFormatter* RelativeDateTimeCacheData::getRelativeDateTimeUnitFormatter(</span>
<span class="line-added"> 166         int32_t fStyle,</span>
<span class="line-added"> 167         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 168         int32_t pastFutureIndex,</span>
<span class="line-added"> 169         int32_t pluralUnit) const {</span>
<span class="line-added"> 170     while (true) {</span>
<span class="line-added"> 171         int32_t style = fStyle;</span>
<span class="line-added"> 172         do {</span>
<span class="line-added"> 173             if (relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit] != nullptr) {</span>
<span class="line-added"> 174                 return relativeUnitsFormatters[style][unit][pastFutureIndex][pluralUnit];</span>
<span class="line-added"> 175             }</span>
<span class="line-added"> 176             style = fallBackCache[style];</span>
<span class="line-added"> 177         } while (style != -1);</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179         if (pluralUnit == StandardPlural::OTHER) {</span>
<span class="line-added"> 180             break;</span>
 181         }
<span class="line-modified"> 182         pluralUnit = StandardPlural::OTHER;</span>
<span class="line-modified"> 183     }</span>
<span class="line-modified"> 184     return nullptr;  // No formatter found.</span>
 185  }
 186 
 187 static UBool getStringWithFallback(
 188         const UResourceBundle *resource,
 189         const char *key,
 190         UnicodeString &amp;result,
 191         UErrorCode &amp;status) {
 192     int32_t len = 0;
 193     const UChar *resStr = ures_getStringByKeyWithFallback(
 194         resource, key, &amp;len, &amp;status);
 195     if (U_FAILURE(status)) {
 196         return FALSE;
 197     }
 198     result.setTo(TRUE, resStr, len);
 199     return TRUE;
 200 }
 201 
 202 
 203 static UBool getStringByIndex(
 204         const UResourceBundle *resource,
</pre>
<hr />
<pre>
 237         MINUTE,
 238         HOUR,
 239         DAY,
 240         WEEK,
 241         MONTH,
 242         QUARTER,
 243         YEAR,
 244         SUNDAY,
 245         MONDAY,
 246         TUESDAY,
 247         WEDNESDAY,
 248         THURSDAY,
 249         FRIDAY,
 250         SATURDAY
 251     } RelAbsUnit;
 252 
 253     static int32_t relUnitFromGeneric(RelAbsUnit genUnit) {
 254         // Converts the generic units to UDAT_RELATIVE version.
 255         switch (genUnit) {
 256             case SECOND:
<span class="line-modified"> 257                 return UDAT_REL_UNIT_SECOND;</span>
 258             case MINUTE:
<span class="line-modified"> 259                 return UDAT_REL_UNIT_MINUTE;</span>
 260             case HOUR:
<span class="line-modified"> 261                 return UDAT_REL_UNIT_HOUR;</span>
 262             case DAY:
<span class="line-modified"> 263                 return UDAT_REL_UNIT_DAY;</span>
 264             case WEEK:
<span class="line-modified"> 265                 return UDAT_REL_UNIT_WEEK;</span>
 266             case MONTH:
<span class="line-modified"> 267                 return UDAT_REL_UNIT_MONTH;</span>
<span class="line-modified"> 268             case QUARTER:</span>
<span class="line-modified"> 269                 return UDAT_REL_UNIT_QUARTER;</span>


 270             case YEAR:
<span class="line-modified"> 271                 return UDAT_REL_UNIT_YEAR;</span>
<span class="line-added"> 272             case SUNDAY:</span>
<span class="line-added"> 273                 return UDAT_REL_UNIT_SUNDAY;</span>
<span class="line-added"> 274             case MONDAY:</span>
<span class="line-added"> 275                 return UDAT_REL_UNIT_MONDAY;</span>
<span class="line-added"> 276             case TUESDAY:</span>
<span class="line-added"> 277                 return UDAT_REL_UNIT_TUESDAY;</span>
<span class="line-added"> 278             case WEDNESDAY:</span>
<span class="line-added"> 279                 return UDAT_REL_UNIT_WEDNESDAY;</span>
<span class="line-added"> 280             case THURSDAY:</span>
<span class="line-added"> 281                 return UDAT_REL_UNIT_THURSDAY;</span>
<span class="line-added"> 282             case FRIDAY:</span>
<span class="line-added"> 283                 return UDAT_REL_UNIT_FRIDAY;</span>
<span class="line-added"> 284             case SATURDAY:</span>
<span class="line-added"> 285                 return UDAT_REL_UNIT_SATURDAY;</span>
 286             default:
 287                 return -1;
 288         }
 289     }
 290 
 291     static int32_t absUnitFromGeneric(RelAbsUnit genUnit) {
 292         // Converts the generic units to UDAT_RELATIVE version.
 293         switch (genUnit) {
 294             case DAY:
 295                 return UDAT_ABSOLUTE_DAY;
 296             case WEEK:
 297                 return UDAT_ABSOLUTE_WEEK;
 298             case MONTH:
 299                 return UDAT_ABSOLUTE_MONTH;
<span class="line-modified"> 300             case QUARTER:</span>
<span class="line-modified"> 301                 return UDAT_ABSOLUTE_QUARTER;</span>


 302             case YEAR:
 303                 return UDAT_ABSOLUTE_YEAR;
 304             case SUNDAY:
 305                 return UDAT_ABSOLUTE_SUNDAY;
 306             case MONDAY:
 307                 return UDAT_ABSOLUTE_MONDAY;
 308             case TUESDAY:
 309                 return UDAT_ABSOLUTE_TUESDAY;
 310             case WEDNESDAY:
 311                 return UDAT_ABSOLUTE_WEDNESDAY;
 312             case THURSDAY:
 313                 return UDAT_ABSOLUTE_THURSDAY;
 314             case FRIDAY:
 315                 return UDAT_ABSOLUTE_FRIDAY;
 316             case SATURDAY:
 317                 return UDAT_ABSOLUTE_SATURDAY;
 318             default:
 319                 return -1;
 320         }
 321     }
</pre>
<hr />
<pre>
 342     // Values kept between levels of parsing the CLDR data.
 343     int32_t pastFutureIndex;  // 0 == past or 1 ==  future
 344     UDateRelativeDateTimeFormatterStyle style;  // {LONG, SHORT, NARROW}
 345     RelAbsUnit genericUnit;
 346 
 347     RelativeDateTimeCacheData &amp;outputData;
 348 
 349     // Constructor
 350     RelDateTimeFmtDataSink(RelativeDateTimeCacheData&amp; cacheData)
 351         : outputData(cacheData) {
 352         // Clear cacheData.fallBackCache
 353         cacheData.fallBackCache[UDAT_STYLE_LONG] = -1;
 354         cacheData.fallBackCache[UDAT_STYLE_SHORT] = -1;
 355         cacheData.fallBackCache[UDAT_STYLE_NARROW] = -1;
 356     }
 357 
 358     ~RelDateTimeFmtDataSink();
 359 
 360     // Utility functions
 361     static UDateRelativeDateTimeFormatterStyle styleFromString(const char *s) {
<span class="line-modified"> 362         int32_t len = static_cast&lt;int32_t&gt;(uprv_strlen(s));</span>
 363         if (len &gt;= 7 &amp;&amp; uprv_strcmp(s + len - 7, &quot;-narrow&quot;) == 0) {
 364             return UDAT_STYLE_NARROW;
 365         }
 366         if (len &gt;= 6 &amp;&amp; uprv_strcmp(s + len - 6, &quot;-short&quot;) == 0) {
 367             return UDAT_STYLE_SHORT;
 368         }
 369         return UDAT_STYLE_LONG;
 370     }
 371 
 372     static int32_t styleSuffixLength(UDateRelativeDateTimeFormatterStyle style) {
 373         switch (style) {
 374             case UDAT_STYLE_NARROW:
 375                 return 7;
 376             case UDAT_STYLE_SHORT:
 377                 return 6;
 378             default:
 379                 return 0;
 380         }
 381     }
 382 
</pre>
<hr />
<pre>
 460         if (outputData.absoluteUnits[style]
 461             [absUnit][UDAT_DIRECTION_PLAIN].isEmpty()) {
 462             outputData.absoluteUnits[style]
 463                 [absUnit][UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 464             return;
 465         }
 466     }
 467 
 468     void consumeTableRelative(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 469         ResourceTable unitTypesTable = value.getTable(errorCode);
 470         if (U_FAILURE(errorCode)) { return; }
 471 
 472         for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 473             if (value.getType() == URES_STRING) {
 474                 int32_t direction = keyToDirection(key);
 475                 if (direction &lt; 0) {
 476                   continue;
 477                 }
 478 
 479                 int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
<span class="line-modified"> 480                 if (relUnitIndex == UDAT_REL_UNIT_SECOND &amp;&amp; uprv_strcmp(key, &quot;0&quot;) == 0 &amp;&amp;</span>
 481                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW][UDAT_DIRECTION_PLAIN].isEmpty()) {
 482                     // Handle &quot;NOW&quot;
 483                     outputData.absoluteUnits[style][UDAT_ABSOLUTE_NOW]
 484                         [UDAT_DIRECTION_PLAIN].fastCopyFrom(value.getUnicodeString(errorCode));
 485                 }
 486 
 487                 int32_t absUnitIndex = absUnitFromGeneric(genericUnit);
 488                 if (absUnitIndex &lt; 0) {
 489                     continue;
 490                 }
 491                 // Only reset if slot is empty.
 492                 if (outputData.absoluteUnits[style][absUnitIndex][direction].isEmpty()) {
 493                     outputData.absoluteUnits[style][absUnitIndex]
 494                         [direction].fastCopyFrom(value.getUnicodeString(errorCode));
 495                 }
 496             }
 497         }
 498     }
 499 
 500     void consumeTimeDetail(int32_t relUnitIndex,
 501                            const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 502         ResourceTable unitTypesTable = value.getTable(errorCode);
 503         if (U_FAILURE(errorCode)) { return; }
 504 
 505           for (int32_t i = 0; unitTypesTable.getKeyAndValue(i, key, value); ++i) {
 506             if (value.getType() == URES_STRING) {
 507                 int32_t pluralIndex = StandardPlural::indexOrNegativeFromString(key);
 508                 if (pluralIndex &gt;= 0) {
 509                     SimpleFormatter **patterns =
 510                         outputData.relativeUnitsFormatters[style][relUnitIndex]
 511                         [pastFutureIndex];
 512                     // Only set if not already established.
<span class="line-modified"> 513                     if (patterns[pluralIndex] == nullptr) {</span>
 514                         patterns[pluralIndex] = new SimpleFormatter(
 515                             value.getUnicodeString(errorCode), 0, 1, errorCode);
<span class="line-modified"> 516                         if (patterns[pluralIndex] == nullptr) {</span>
 517                             errorCode = U_MEMORY_ALLOCATION_ERROR;
 518                         }
 519                     }
 520                 }
 521             }
 522         }
 523     }
 524 
 525     void consumeTableRelativeTime(const char *key, ResourceValue &amp;value, UErrorCode &amp;errorCode) {
 526         ResourceTable relativeTimeTable = value.getTable(errorCode);
 527         if (U_FAILURE(errorCode)) { return; }
 528 
 529         int32_t relUnitIndex = relUnitFromGeneric(genericUnit);
 530         if (relUnitIndex &lt; 0) {
 531             return;
 532         }
 533         for (int32_t i = 0; relativeTimeTable.getKeyAndValue(i, key, value); ++i) {
 534             if (uprv_strcmp(key, &quot;past&quot;) == 0) {
 535                 pastFutureIndex = 0;
 536             } else if (uprv_strcmp(key, &quot;future&quot;) == 0) {
</pre>
<hr />
<pre>
 576             if (value.getType() == URES_TABLE) {
 577                 if (uprv_strcmp(key, &quot;relative&quot;) == 0) {
 578                     consumeTableRelative(key, value, errorCode);
 579                 } else if (uprv_strcmp(key, &quot;relativeTime&quot;) == 0) {
 580                     consumeTableRelativeTime(key, value, errorCode);
 581                 }
 582             }
 583         }
 584     }
 585 
 586     virtual void put(const char *key, ResourceValue &amp;value,
 587                      UBool /*noFallback*/, UErrorCode &amp;errorCode) {
 588         // Main entry point to sink
 589         ResourceTable table = value.getTable(errorCode);
 590         if (U_FAILURE(errorCode)) { return; }
 591         for (int32_t i = 0; table.getKeyAndValue(i, key, value); ++i) {
 592             if (value.getType() == URES_ALIAS) {
 593                 consumeAlias(key, value, errorCode);
 594             } else {
 595                 style = styleFromString(key);
<span class="line-modified"> 596                 int32_t unitSize = static_cast&lt;int32_t&gt;(uprv_strlen(key)) - styleSuffixLength(style);</span>
 597                 genericUnit = unitOrNegativeFromString(key, unitSize);
 598                 if (style &gt;= 0 &amp;&amp; genericUnit != INVALID_UNIT) {
 599                     consumeTimeUnit(key, value, errorCode);
 600                 }
 601             }
 602         }
 603     }
 604 
 605 };
 606 
 607 // Virtual destructors must be defined out of line.
 608 RelDateTimeFmtDataSink::~RelDateTimeFmtDataSink() {}
 609 } // namespace
 610 
 611 static const DateFormatSymbols::DtWidthType styleToDateFormatSymbolWidth[UDAT_STYLE_COUNT] = {
 612   DateFormatSymbols::WIDE, DateFormatSymbols::SHORT, DateFormatSymbols::NARROW
 613 };
 614 
 615 // Get days of weeks from the DateFormatSymbols class.
 616 static void loadWeekdayNames(UnicodeString absoluteUnits[UDAT_STYLE_COUNT]
 617                                  [UDAT_ABSOLUTE_UNIT_COUNT][UDAT_DIRECTION_COUNT],
 618                              const char* localeId,
 619                              UErrorCode&amp; status) {
<span class="line-added"> 620     if (U_FAILURE(status)) {</span>
<span class="line-added"> 621         return;</span>
<span class="line-added"> 622     }</span>
 623     Locale locale(localeId);
 624     DateFormatSymbols dfSym(locale, status);
<span class="line-added"> 625     if (U_FAILURE(status)) {</span>
<span class="line-added"> 626         return;</span>
<span class="line-added"> 627     }</span>
 628     for (int32_t style = 0; style &lt; UDAT_STYLE_COUNT; ++style) {
 629         DateFormatSymbols::DtWidthType dtfmtWidth = styleToDateFormatSymbolWidth[style];
 630         int32_t count;
 631         const UnicodeString* weekdayNames =
 632             dfSym.getWeekdays(count, DateFormatSymbols::STANDALONE, dtfmtWidth);
 633         for (int32_t dayIndex = UDAT_ABSOLUTE_SUNDAY;
 634                 dayIndex &lt;= UDAT_ABSOLUTE_SATURDAY; ++ dayIndex) {
 635             int32_t dateSymbolIndex = (dayIndex - UDAT_ABSOLUTE_SUNDAY) + UCAL_SUNDAY;
 636             absoluteUnits[style][dayIndex][UDAT_DIRECTION_PLAIN].fastCopyFrom(
 637                 weekdayNames[dateSymbolIndex]);
 638         }
 639     }
 640 }
 641 
 642 static UBool loadUnitData(
 643         const UResourceBundle *resource,
 644         RelativeDateTimeCacheData &amp;cacheData,
 645         const char* localeId,
 646         UErrorCode &amp;status) {
 647 
 648     RelDateTimeFmtDataSink sink(cacheData);
 649 
 650     ures_getAllItemsWithFallback(resource, &quot;fields&quot;, sink, status);
<span class="line-added"> 651     if (U_FAILURE(status)) {</span>
<span class="line-added"> 652         return false;</span>
<span class="line-added"> 653     }</span>
 654 
 655     // Get the weekday names from DateFormatSymbols.
 656     loadWeekdayNames(cacheData.absoluteUnits, localeId, status);
 657     return U_SUCCESS(status);
 658 }
 659 
 660 static UBool getDateTimePattern(
 661         const UResourceBundle *resource,
 662         UnicodeString &amp;result,
 663         UErrorCode &amp;status) {
 664     UnicodeString defaultCalendarName;
 665     if (!getStringWithFallback(
 666             resource,
 667             &quot;calendar/default&quot;,
 668             defaultCalendarName,
 669             status)) {
 670         return FALSE;
 671     }
 672     CharString pathBuffer;
 673     pathBuffer.append(&quot;calendar/&quot;, status)
 674             .appendInvariantChars(defaultCalendarName, status)
 675             .append(&quot;/DateTimePatterns&quot;, status);
 676     LocalUResourceBundlePointer topLevel(
 677             ures_getByKeyWithFallback(
<span class="line-modified"> 678                     resource, pathBuffer.data(), nullptr, &amp;status));</span>
 679     if (U_FAILURE(status)) {
 680         return FALSE;
 681     }
 682     int32_t size = ures_getSize(topLevel.getAlias());
 683     if (size &lt;= 8) {
 684         // Oops, size is too small to access the index that we want, fallback
 685         // to a hard-coded value.
 686         result = UNICODE_STRING_SIMPLE(&quot;{1} {0}&quot;);
 687         return TRUE;
 688     }
 689     return getStringByIndex(topLevel.getAlias(), 8, result, status);
 690 }
 691 
 692 template&lt;&gt; U_I18N_API
 693 const RelativeDateTimeCacheData *LocaleCacheKey&lt;RelativeDateTimeCacheData&gt;::createObject(const void * /*unused*/, UErrorCode &amp;status) const {
 694     const char *localeId = fLoc.getName();
<span class="line-modified"> 695     LocalUResourceBundlePointer topLevel(ures_open(nullptr, localeId, &amp;status));</span>
 696     if (U_FAILURE(status)) {
<span class="line-modified"> 697         return nullptr;</span>
 698     }
 699     LocalPointer&lt;RelativeDateTimeCacheData&gt; result(
 700             new RelativeDateTimeCacheData());
 701     if (result.isNull()) {
 702         status = U_MEMORY_ALLOCATION_ERROR;
<span class="line-modified"> 703         return nullptr;</span>
 704     }
 705     if (!loadUnitData(
 706             topLevel.getAlias(),
 707             *result,
 708             localeId,
 709             status)) {
<span class="line-modified"> 710         return nullptr;</span>
 711     }
 712     UnicodeString dateTimePattern;
 713     if (!getDateTimePattern(topLevel.getAlias(), dateTimePattern, status)) {
<span class="line-modified"> 714         return nullptr;</span>
 715     }
 716     result-&gt;adoptCombinedDateAndTime(
 717             new SimpleFormatter(dateTimePattern, 2, 2, status));
 718     if (U_FAILURE(status)) {
<span class="line-modified"> 719         return nullptr;</span>
 720     }
 721     result-&gt;addRef();
 722     return result.orphan();
 723 }
 724 
<span class="line-added"> 725 </span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727 static constexpr number::impl::Field kRDTNumericField</span>
<span class="line-added"> 728     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_NUMERIC_FIELD&gt;();</span>
<span class="line-added"> 729 </span>
<span class="line-added"> 730 static constexpr number::impl::Field kRDTLiteralField</span>
<span class="line-added"> 731     = number::impl::NumFieldUtils::compress&lt;UFIELD_CATEGORY_RELATIVE_DATETIME, UDAT_REL_LITERAL_FIELD&gt;();</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733 class FormattedRelativeDateTimeData : public FormattedValueNumberStringBuilderImpl {</span>
<span class="line-added"> 734 public:</span>
<span class="line-added"> 735     FormattedRelativeDateTimeData() : FormattedValueNumberStringBuilderImpl(kRDTNumericField) {}</span>
<span class="line-added"> 736     virtual ~FormattedRelativeDateTimeData();</span>
<span class="line-added"> 737 };</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739 FormattedRelativeDateTimeData::~FormattedRelativeDateTimeData() = default;</span>
<span class="line-added"> 740 </span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742 UPRV_FORMATTED_VALUE_SUBCLASS_AUTO_IMPL(FormattedRelativeDateTime)</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744 </span>
 745 RelativeDateTimeFormatter::RelativeDateTimeFormatter(UErrorCode&amp; status) :
<span class="line-modified"> 746         fCache(nullptr),</span>
<span class="line-modified"> 747         fNumberFormat(nullptr),</span>
<span class="line-modified"> 748         fPluralRules(nullptr),</span>
 749         fStyle(UDAT_STYLE_LONG),
 750         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 751         fOptBreakIterator(nullptr) {</span>
<span class="line-modified"> 752     init(nullptr, nullptr, status);</span>
 753 }
 754 
 755 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 756         const Locale&amp; locale, UErrorCode&amp; status) :
<span class="line-modified"> 757         fCache(nullptr),</span>
<span class="line-modified"> 758         fNumberFormat(nullptr),</span>
<span class="line-modified"> 759         fPluralRules(nullptr),</span>
 760         fStyle(UDAT_STYLE_LONG),
 761         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 762         fOptBreakIterator(nullptr),</span>
 763         fLocale(locale) {
<span class="line-modified"> 764     init(nullptr, nullptr, status);</span>
 765 }
 766 
 767 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 768         const Locale&amp; locale, NumberFormat *nfToAdopt, UErrorCode&amp; status) :
<span class="line-modified"> 769         fCache(nullptr),</span>
<span class="line-modified"> 770         fNumberFormat(nullptr),</span>
<span class="line-modified"> 771         fPluralRules(nullptr),</span>
 772         fStyle(UDAT_STYLE_LONG),
 773         fContext(UDISPCTX_CAPITALIZATION_NONE),
<span class="line-modified"> 774         fOptBreakIterator(nullptr),</span>
 775         fLocale(locale) {
<span class="line-modified"> 776     init(nfToAdopt, nullptr, status);</span>
 777 }
 778 
 779 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 780         const Locale&amp; locale,
 781         NumberFormat *nfToAdopt,
 782         UDateRelativeDateTimeFormatterStyle styl,
 783         UDisplayContext capitalizationContext,
 784         UErrorCode&amp; status) :
<span class="line-modified"> 785         fCache(nullptr),</span>
<span class="line-modified"> 786         fNumberFormat(nullptr),</span>
<span class="line-modified"> 787         fPluralRules(nullptr),</span>
 788         fStyle(styl),
 789         fContext(capitalizationContext),
<span class="line-modified"> 790         fOptBreakIterator(nullptr),</span>
 791         fLocale(locale) {
 792     if (U_FAILURE(status)) {
 793         return;
 794     }
 795     if ((capitalizationContext &gt;&gt; 8) != UDISPCTX_TYPE_CAPITALIZATION) {
 796         status = U_ILLEGAL_ARGUMENT_ERROR;
 797         return;
 798     }
 799     if (capitalizationContext == UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
 800         BreakIterator *bi = BreakIterator::createSentenceInstance(locale, status);
 801         if (U_FAILURE(status)) {
 802             return;
 803         }
 804         init(nfToAdopt, bi, status);
 805     } else {
<span class="line-modified"> 806         init(nfToAdopt, nullptr, status);</span>
 807     }
 808 }
 809 
 810 RelativeDateTimeFormatter::RelativeDateTimeFormatter(
 811         const RelativeDateTimeFormatter&amp; other)
 812         : UObject(other),
 813           fCache(other.fCache),
 814           fNumberFormat(other.fNumberFormat),
 815           fPluralRules(other.fPluralRules),
 816           fStyle(other.fStyle),
 817           fContext(other.fContext),
 818           fOptBreakIterator(other.fOptBreakIterator),
 819           fLocale(other.fLocale) {
 820     fCache-&gt;addRef();
 821     fNumberFormat-&gt;addRef();
 822     fPluralRules-&gt;addRef();
<span class="line-modified"> 823     if (fOptBreakIterator != nullptr) {</span>
 824       fOptBreakIterator-&gt;addRef();
 825     }
 826 }
 827 
 828 RelativeDateTimeFormatter&amp; RelativeDateTimeFormatter::operator=(
 829         const RelativeDateTimeFormatter&amp; other) {
 830     if (this != &amp;other) {
 831         SharedObject::copyPtr(other.fCache, fCache);
 832         SharedObject::copyPtr(other.fNumberFormat, fNumberFormat);
 833         SharedObject::copyPtr(other.fPluralRules, fPluralRules);
 834         SharedObject::copyPtr(other.fOptBreakIterator, fOptBreakIterator);
 835         fStyle = other.fStyle;
 836         fContext = other.fContext;
 837         fLocale = other.fLocale;
 838     }
 839     return *this;
 840 }
 841 
 842 RelativeDateTimeFormatter::~RelativeDateTimeFormatter() {
<span class="line-modified"> 843     if (fCache != nullptr) {</span>
 844         fCache-&gt;removeRef();
 845     }
<span class="line-modified"> 846     if (fNumberFormat != nullptr) {</span>
 847         fNumberFormat-&gt;removeRef();
 848     }
<span class="line-modified"> 849     if (fPluralRules != nullptr) {</span>
 850         fPluralRules-&gt;removeRef();
 851     }
<span class="line-modified"> 852     if (fOptBreakIterator != nullptr) {</span>
 853         fOptBreakIterator-&gt;removeRef();
 854     }
 855 }
 856 
 857 const NumberFormat&amp; RelativeDateTimeFormatter::getNumberFormat() const {
 858     return **fNumberFormat;
 859 }
 860 
 861 UDisplayContext RelativeDateTimeFormatter::getCapitalizationContext() const {
 862     return fContext;
 863 }
 864 
 865 UDateRelativeDateTimeFormatterStyle RelativeDateTimeFormatter::getFormatStyle() const {
 866     return fStyle;
 867 }
 868 
<span class="line-modified"> 869 </span>
<span class="line-modified"> 870 // To reduce boilerplate code, we use a helper function that forwards variadic</span>
<span class="line-modified"> 871 // arguments to the formatImpl function.</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873 template&lt;typename F, typename... Args&gt;</span>
<span class="line-added"> 874 UnicodeString&amp; RelativeDateTimeFormatter::doFormat(</span>
<span class="line-added"> 875         F callback,</span>
<span class="line-added"> 876         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 877         UErrorCode&amp; status,</span>
<span class="line-added"> 878         Args... args) const {</span>
<span class="line-added"> 879     FormattedRelativeDateTimeData output;</span>
<span class="line-added"> 880     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., output, status);</span>
 881     if (U_FAILURE(status)) {
 882         return appendTo;
 883     }
<span class="line-added"> 884     UnicodeString result = output.getStringRef().toUnicodeString();</span>
<span class="line-added"> 885     return appendTo.append(adjustForContext(result));</span>
<span class="line-added"> 886 }</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888 template&lt;typename F, typename... Args&gt;</span>
<span class="line-added"> 889 FormattedRelativeDateTime RelativeDateTimeFormatter::doFormatToValue(</span>
<span class="line-added"> 890         F callback,</span>
<span class="line-added"> 891         UErrorCode&amp; status,</span>
<span class="line-added"> 892         Args... args) const {</span>
<span class="line-added"> 893     if (!checkNoAdjustForContext(status)) {</span>
<span class="line-added"> 894         return FormattedRelativeDateTime(status);</span>
<span class="line-added"> 895     }</span>
<span class="line-added"> 896     LocalPointer&lt;FormattedRelativeDateTimeData&gt; output(</span>
<span class="line-added"> 897         new FormattedRelativeDateTimeData(), status);</span>
<span class="line-added"> 898     if (U_FAILURE(status)) {</span>
<span class="line-added"> 899         return FormattedRelativeDateTime(status);</span>
<span class="line-added"> 900     }</span>
<span class="line-added"> 901     (this-&gt;*callback)(std::forward&lt;Args&gt;(args)..., *output, status);</span>
<span class="line-added"> 902     output-&gt;getStringRef().writeTerminator(status);</span>
<span class="line-added"> 903     return FormattedRelativeDateTime(output.orphan());</span>
<span class="line-added"> 904 }</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906 UnicodeString&amp; RelativeDateTimeFormatter::format(</span>
<span class="line-added"> 907         double quantity,</span>
<span class="line-added"> 908         UDateDirection direction,</span>
<span class="line-added"> 909         UDateRelativeUnit unit,</span>
<span class="line-added"> 910         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 911         UErrorCode&amp; status) const {</span>
<span class="line-added"> 912     return doFormat(</span>
<span class="line-added"> 913         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added"> 914         appendTo,</span>
<span class="line-added"> 915         status,</span>
<span class="line-added"> 916         quantity,</span>
<span class="line-added"> 917         direction,</span>
<span class="line-added"> 918         unit);</span>
<span class="line-added"> 919 }</span>
<span class="line-added"> 920 </span>
<span class="line-added"> 921 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added"> 922         double quantity,</span>
<span class="line-added"> 923         UDateDirection direction,</span>
<span class="line-added"> 924         UDateRelativeUnit unit,</span>
<span class="line-added"> 925         UErrorCode&amp; status) const {</span>
<span class="line-added"> 926     return doFormatToValue(</span>
<span class="line-added"> 927         &amp;RelativeDateTimeFormatter::formatImpl,</span>
<span class="line-added"> 928         status,</span>
<span class="line-added"> 929         quantity,</span>
<span class="line-added"> 930         direction,</span>
<span class="line-added"> 931         unit);</span>
<span class="line-added"> 932 }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934 void RelativeDateTimeFormatter::formatImpl(</span>
<span class="line-added"> 935         double quantity,</span>
<span class="line-added"> 936         UDateDirection direction,</span>
<span class="line-added"> 937         UDateRelativeUnit unit,</span>
<span class="line-added"> 938         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added"> 939         UErrorCode&amp; status) const {</span>
<span class="line-added"> 940     if (U_FAILURE(status)) {</span>
<span class="line-added"> 941         return;</span>
<span class="line-added"> 942     }</span>
 943     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {
 944         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified"> 945         return;</span>
 946     }
 947     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;




 948 
<span class="line-modified"> 949     StandardPlural::Form pluralForm;</span>
<span class="line-modified"> 950     QuantityFormatter::formatAndSelect(</span>
<span class="line-added"> 951         quantity,</span>
<span class="line-added"> 952         **fNumberFormat,</span>
<span class="line-added"> 953         **fPluralRules,</span>
<span class="line-added"> 954         output.getStringRef(),</span>
<span class="line-added"> 955         pluralForm,</span>
 956         status);
<span class="line-added"> 957     if (U_FAILURE(status)) {</span>
<span class="line-added"> 958         return;</span>
<span class="line-added"> 959     }</span>
 960 
 961     const SimpleFormatter* formatter =
<span class="line-modified"> 962         fCache-&gt;getRelativeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-modified"> 963     if (formatter == nullptr) {</span>
 964         // TODO: WARN - look at quantity formatter&#39;s action with an error.
 965         status = U_INVALID_FORMAT_ERROR;
<span class="line-modified"> 966         return;</span>
 967     }
<span class="line-modified"> 968 </span>
<span class="line-modified"> 969     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-modified"> 970     modifier.formatAsPrefixSuffix(</span>
<span class="line-added"> 971         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
 972 }
 973 
 974 UnicodeString&amp; RelativeDateTimeFormatter::formatNumeric(
<span class="line-modified"> 975         double offset,</span>
<span class="line-modified"> 976         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 977         UnicodeString&amp; appendTo,</span>
<span class="line-added"> 978         UErrorCode&amp; status) const {</span>
<span class="line-added"> 979     return doFormat(</span>
<span class="line-added"> 980         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added"> 981         appendTo,</span>
<span class="line-added"> 982         status,</span>
<span class="line-added"> 983         offset,</span>
<span class="line-added"> 984         unit);</span>
<span class="line-added"> 985 }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987 FormattedRelativeDateTime RelativeDateTimeFormatter::formatNumericToValue(</span>
<span class="line-added"> 988         double offset,</span>
<span class="line-added"> 989         URelativeDateTimeUnit unit,</span>
<span class="line-added"> 990         UErrorCode&amp; status) const {</span>
<span class="line-added"> 991     return doFormatToValue(</span>
<span class="line-added"> 992         &amp;RelativeDateTimeFormatter::formatNumericImpl,</span>
<span class="line-added"> 993         status,</span>
<span class="line-added"> 994         offset,</span>
<span class="line-added"> 995         unit);</span>
<span class="line-added"> 996 }</span>
<span class="line-added"> 997 </span>
<span class="line-added"> 998 void RelativeDateTimeFormatter::formatNumericImpl(</span>
<span class="line-added"> 999         double offset,</span>
<span class="line-added">1000         URelativeDateTimeUnit unit,</span>
<span class="line-added">1001         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1002         UErrorCode&amp; status) const {</span>
1003     if (U_FAILURE(status)) {
<span class="line-modified">1004         return;</span>





















1005     }
1006     UDateDirection direction = UDAT_DIRECTION_NEXT;
1007     if (std::signbit(offset)) { // needed to handle -0.0
1008         direction = UDAT_DIRECTION_LAST;
1009         offset = -offset;
1010     }
<span class="line-modified">1011     if (direction != UDAT_DIRECTION_LAST &amp;&amp; direction != UDAT_DIRECTION_NEXT) {</span>
<span class="line-added">1012         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="line-added">1013         return;</span>
<span class="line-added">1014     }</span>
<span class="line-added">1015     int32_t bFuture = direction == UDAT_DIRECTION_NEXT ? 1 : 0;</span>
<span class="line-added">1016 </span>
<span class="line-added">1017     StandardPlural::Form pluralForm;</span>
<span class="line-added">1018     QuantityFormatter::formatAndSelect(</span>
<span class="line-added">1019         offset,</span>
<span class="line-added">1020         **fNumberFormat,</span>
<span class="line-added">1021         **fPluralRules,</span>
<span class="line-added">1022         output.getStringRef(),</span>
<span class="line-added">1023         pluralForm,</span>
<span class="line-added">1024         status);</span>
<span class="line-added">1025     if (U_FAILURE(status)) {</span>
<span class="line-added">1026         return;</span>
<span class="line-added">1027     }</span>
<span class="line-added">1028 </span>
<span class="line-added">1029     const SimpleFormatter* formatter =</span>
<span class="line-added">1030         fCache-&gt;getRelativeDateTimeUnitFormatter(fStyle, unit, bFuture, pluralForm);</span>
<span class="line-added">1031     if (formatter == nullptr) {</span>
<span class="line-added">1032         // TODO: WARN - look at quantity formatter&#39;s action with an error.</span>
<span class="line-added">1033         status = U_INVALID_FORMAT_ERROR;</span>
<span class="line-added">1034         return;</span>
<span class="line-added">1035     }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037     number::impl::SimpleModifier modifier(*formatter, kRDTLiteralField, false);</span>
<span class="line-added">1038     modifier.formatAsPrefixSuffix(</span>
<span class="line-added">1039         output.getStringRef(), 0, output.getStringRef().length(), status);</span>
1040 }
1041 
1042 UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">1043         UDateDirection direction,</span>
<span class="line-modified">1044         UDateAbsoluteUnit unit,</span>
<span class="line-added">1045         UnicodeString&amp; appendTo,</span>
<span class="line-added">1046         UErrorCode&amp; status) const {</span>
<span class="line-added">1047     return doFormat(</span>
<span class="line-added">1048         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">1049         appendTo,</span>
<span class="line-added">1050         status,</span>
<span class="line-added">1051         direction,</span>
<span class="line-added">1052         unit);</span>
<span class="line-added">1053 }</span>
<span class="line-added">1054 </span>
<span class="line-added">1055 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">1056         UDateDirection direction,</span>
<span class="line-added">1057         UDateAbsoluteUnit unit,</span>
<span class="line-added">1058         UErrorCode&amp; status) const {</span>
<span class="line-added">1059     return doFormatToValue(</span>
<span class="line-added">1060         &amp;RelativeDateTimeFormatter::formatAbsoluteImpl,</span>
<span class="line-added">1061         status,</span>
<span class="line-added">1062         direction,</span>
<span class="line-added">1063         unit);</span>
<span class="line-added">1064 }</span>
<span class="line-added">1065 </span>
<span class="line-added">1066 void RelativeDateTimeFormatter::formatAbsoluteImpl(</span>
<span class="line-added">1067         UDateDirection direction,</span>
<span class="line-added">1068         UDateAbsoluteUnit unit,</span>
<span class="line-added">1069         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1070         UErrorCode&amp; status) const {</span>
1071     if (U_FAILURE(status)) {
<span class="line-modified">1072         return;</span>
1073     }
1074     if (unit == UDAT_ABSOLUTE_NOW &amp;&amp; direction != UDAT_DIRECTION_PLAIN) {
1075         status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="line-modified">1076         return;</span>
1077     }
1078 
1079     // Get string using fallback.
<span class="line-modified">1080     output.getStringRef().append(</span>
<span class="line-modified">1081         fCache-&gt;getAbsoluteUnitString(fStyle, unit, direction),</span>
<span class="line-modified">1082         kRDTLiteralField,</span>
<span class="line-modified">1083         status);</span>


1084 }
1085 
1086 UnicodeString&amp; RelativeDateTimeFormatter::format(
<span class="line-modified">1087         double offset,</span>
<span class="line-modified">1088         URelativeDateTimeUnit unit,</span>
<span class="line-added">1089         UnicodeString&amp; appendTo,</span>
<span class="line-added">1090         UErrorCode&amp; status) const {</span>
<span class="line-added">1091     return doFormat(</span>
<span class="line-added">1092         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">1093         appendTo,</span>
<span class="line-added">1094         status,</span>
<span class="line-added">1095         offset,</span>
<span class="line-added">1096         unit);</span>
<span class="line-added">1097 }</span>
<span class="line-added">1098 </span>
<span class="line-added">1099 FormattedRelativeDateTime RelativeDateTimeFormatter::formatToValue(</span>
<span class="line-added">1100         double offset,</span>
<span class="line-added">1101         URelativeDateTimeUnit unit,</span>
<span class="line-added">1102         UErrorCode&amp; status) const {</span>
<span class="line-added">1103     return doFormatToValue(</span>
<span class="line-added">1104         &amp;RelativeDateTimeFormatter::formatRelativeImpl,</span>
<span class="line-added">1105         status,</span>
<span class="line-added">1106         offset,</span>
<span class="line-added">1107         unit);</span>
<span class="line-added">1108 }</span>
<span class="line-added">1109 </span>
<span class="line-added">1110 void RelativeDateTimeFormatter::formatRelativeImpl(</span>
<span class="line-added">1111         double offset,</span>
<span class="line-added">1112         URelativeDateTimeUnit unit,</span>
<span class="line-added">1113         FormattedRelativeDateTimeData&amp; output,</span>
<span class="line-added">1114         UErrorCode&amp; status) const {</span>
1115     if (U_FAILURE(status)) {
<span class="line-modified">1116         return;</span>
1117     }
1118     // TODO:
1119     // The full implementation of this depends on CLDR data that is not yet available,
1120     // see: http://unicode.org/cldr/trac/ticket/9165 Add more relative field data.
1121     // In the meantime do a quick bring-up by calling the old format method; this
1122     // leaves some holes (even for data that is currently available, such as quarter).
1123     // When the new CLDR data is available, update the data storage accordingly,
1124     // rewrite this to use it directly, and rewrite the old format method to call this
1125     // new one; that is covered by http://bugs.icu-project.org/trac/ticket/12171.
1126     UDateDirection direction = UDAT_DIRECTION_COUNT;
1127     if (offset &gt; -2.1 &amp;&amp; offset &lt; 2.1) {
1128         // Allow a 1% epsilon, so offsets in -1.01..-0.99 map to LAST
1129         double offsetx100 = offset * 100.0;
1130         int32_t intoffset = (offsetx100 &lt; 0)? (int32_t)(offsetx100-0.5) : (int32_t)(offsetx100+0.5);
1131         switch (intoffset) {
1132             case -200/*-2*/: direction = UDAT_DIRECTION_LAST_2; break;
1133             case -100/*-1*/: direction = UDAT_DIRECTION_LAST; break;
1134             case    0/* 0*/: direction = UDAT_DIRECTION_THIS; break;
1135             case  100/* 1*/: direction = UDAT_DIRECTION_NEXT; break;
1136             case  200/* 2*/: direction = UDAT_DIRECTION_NEXT_2; break;
1137             default: break;
1138         }
1139     }
1140     UDateAbsoluteUnit absunit = UDAT_ABSOLUTE_UNIT_COUNT;
1141     switch (unit) {
1142         case UDAT_REL_UNIT_YEAR:    absunit = UDAT_ABSOLUTE_YEAR; break;
<span class="line-added">1143         case UDAT_REL_UNIT_QUARTER: absunit = UDAT_ABSOLUTE_QUARTER; break;</span>
1144         case UDAT_REL_UNIT_MONTH:   absunit = UDAT_ABSOLUTE_MONTH; break;
1145         case UDAT_REL_UNIT_WEEK:    absunit = UDAT_ABSOLUTE_WEEK; break;
1146         case UDAT_REL_UNIT_DAY:     absunit = UDAT_ABSOLUTE_DAY; break;
1147         case UDAT_REL_UNIT_SECOND:
1148             if (direction == UDAT_DIRECTION_THIS) {
1149                 absunit = UDAT_ABSOLUTE_NOW;
1150                 direction = UDAT_DIRECTION_PLAIN;
1151             }
1152             break;
1153         case UDAT_REL_UNIT_SUNDAY:  absunit = UDAT_ABSOLUTE_SUNDAY; break;
1154         case UDAT_REL_UNIT_MONDAY:  absunit = UDAT_ABSOLUTE_MONDAY; break;
1155         case UDAT_REL_UNIT_TUESDAY:  absunit = UDAT_ABSOLUTE_TUESDAY; break;
1156         case UDAT_REL_UNIT_WEDNESDAY:  absunit = UDAT_ABSOLUTE_WEDNESDAY; break;
1157         case UDAT_REL_UNIT_THURSDAY:  absunit = UDAT_ABSOLUTE_THURSDAY; break;
1158         case UDAT_REL_UNIT_FRIDAY:  absunit = UDAT_ABSOLUTE_FRIDAY; break;
1159         case UDAT_REL_UNIT_SATURDAY:  absunit = UDAT_ABSOLUTE_SATURDAY; break;
1160         default: break;
1161     }
1162     if (direction != UDAT_DIRECTION_COUNT &amp;&amp; absunit != UDAT_ABSOLUTE_UNIT_COUNT) {
<span class="line-modified">1163         formatAbsoluteImpl(direction, absunit, output, status);</span>
<span class="line-modified">1164         if (output.getStringRef().length() != 0) {</span>
<span class="line-modified">1165             return;</span>







1166         }
1167     }
1168     // otherwise fallback to formatNumeric
<span class="line-modified">1169     formatNumericImpl(offset, unit, output, status);</span>
1170 }
1171 
1172 UnicodeString&amp; RelativeDateTimeFormatter::combineDateAndTime(
1173         const UnicodeString&amp; relativeDateString, const UnicodeString&amp; timeString,
1174         UnicodeString&amp; appendTo, UErrorCode&amp; status) const {
1175     return fCache-&gt;getCombinedDateAndTime()-&gt;format(
1176             timeString, relativeDateString, appendTo, status);
1177 }
1178 
<span class="line-modified">1179 UnicodeString&amp; RelativeDateTimeFormatter::adjustForContext(UnicodeString &amp;str) const {</span>
<span class="line-modified">1180     if (fOptBreakIterator == nullptr</span>
1181         || str.length() == 0 || !u_islower(str.char32At(0))) {
<span class="line-modified">1182         return str;</span>
1183     }
1184 
1185     // Must guarantee that one thread at a time accesses the shared break
1186     // iterator.
<span class="line-added">1187     static icu::UMutex gBrkIterMutex = U_MUTEX_INITIALIZER;</span>
1188     Mutex lock(&amp;gBrkIterMutex);
1189     str.toTitle(
1190             fOptBreakIterator-&gt;get(),
1191             fLocale,
1192             U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
<span class="line-added">1193     return str;</span>
<span class="line-added">1194 }</span>
<span class="line-added">1195 </span>
<span class="line-added">1196 UBool RelativeDateTimeFormatter::checkNoAdjustForContext(UErrorCode&amp; status) const {</span>
<span class="line-added">1197     // This is unsupported because it&#39;s hard to keep fields in sync with title</span>
<span class="line-added">1198     // casing. The code could be written and tested if there is demand.</span>
<span class="line-added">1199     if (fOptBreakIterator != nullptr) {</span>
<span class="line-added">1200         status = U_UNSUPPORTED_ERROR;</span>
<span class="line-added">1201         return FALSE;</span>
<span class="line-added">1202     }</span>
<span class="line-added">1203     return TRUE;</span>
1204 }
1205 
1206 void RelativeDateTimeFormatter::init(
1207         NumberFormat *nfToAdopt,
1208         BreakIterator *biToAdopt,
1209         UErrorCode &amp;status) {
1210     LocalPointer&lt;NumberFormat&gt; nf(nfToAdopt);
1211     LocalPointer&lt;BreakIterator&gt; bi(biToAdopt);
1212     UnifiedCache::getByLocale(fLocale, fCache, status);
1213     if (U_FAILURE(status)) {
1214         return;
1215     }
1216     const SharedPluralRules *pr = PluralRules::createSharedInstance(
1217             fLocale, UPLURAL_TYPE_CARDINAL, status);
1218     if (U_FAILURE(status)) {
1219         return;
1220     }
1221     SharedObject::copyPtr(pr, fPluralRules);
1222     pr-&gt;removeRef();
1223     if (nf.isNull()) {
1224        const SharedNumberFormat *shared = NumberFormat::createSharedInstance(
1225                fLocale, UNUM_DECIMAL, status);
1226         if (U_FAILURE(status)) {
1227             return;
1228         }
1229         SharedObject::copyPtr(shared, fNumberFormat);
1230         shared-&gt;removeRef();
1231     } else {
1232         SharedNumberFormat *shared = new SharedNumberFormat(nf.getAlias());
<span class="line-modified">1233         if (shared == nullptr) {</span>
1234             status = U_MEMORY_ALLOCATION_ERROR;
1235             return;
1236         }
1237         nf.orphan();
1238         SharedObject::copyPtr(shared, fNumberFormat);
1239     }
1240     if (bi.isNull()) {
1241         SharedObject::clearPtr(fOptBreakIterator);
1242     } else {
1243         SharedBreakIterator *shared = new SharedBreakIterator(bi.getAlias());
<span class="line-modified">1244         if (shared == nullptr) {</span>
1245             status = U_MEMORY_ALLOCATION_ERROR;
1246             return;
1247         }
1248         bi.orphan();
1249         SharedObject::copyPtr(shared, fOptBreakIterator);
1250     }
1251 }
1252 
1253 U_NAMESPACE_END
1254 
1255 // Plain C API
1256 
1257 U_NAMESPACE_USE
1258 
<span class="line-added">1259 </span>
<span class="line-added">1260 // Magic number: &quot;FRDT&quot; (FormattedRelativeDateTime) in ASCII</span>
<span class="line-added">1261 UPRV_FORMATTED_VALUE_CAPI_AUTO_IMPL(</span>
<span class="line-added">1262     FormattedRelativeDateTime,</span>
<span class="line-added">1263     UFormattedRelativeDateTime,</span>
<span class="line-added">1264     UFormattedRelativeDateTimeImpl,</span>
<span class="line-added">1265     UFormattedRelativeDateTimeApiHelper,</span>
<span class="line-added">1266     ureldatefmt,</span>
<span class="line-added">1267     0x46524454)</span>
<span class="line-added">1268 </span>
<span class="line-added">1269 </span>
1270 U_CAPI URelativeDateTimeFormatter* U_EXPORT2
1271 ureldatefmt_open( const char*          locale,
1272                   UNumberFormat*       nfToAdopt,
1273                   UDateRelativeDateTimeFormatterStyle width,
1274                   UDisplayContext      capitalizationContext,
1275                   UErrorCode*          status )
1276 {
1277     if (U_FAILURE(*status)) {
<span class="line-modified">1278         return nullptr;</span>
1279     }
1280     LocalPointer&lt;RelativeDateTimeFormatter&gt; formatter(new RelativeDateTimeFormatter(Locale(locale),
1281                                                               (NumberFormat*)nfToAdopt, width,
1282                                                               capitalizationContext, *status), *status);
1283     if (U_FAILURE(*status)) {
<span class="line-modified">1284         return nullptr;</span>
1285     }
1286     return (URelativeDateTimeFormatter*)formatter.orphan();
1287 }
1288 
1289 U_CAPI void U_EXPORT2
1290 ureldatefmt_close(URelativeDateTimeFormatter *reldatefmt)
1291 {
1292     delete (RelativeDateTimeFormatter*)reldatefmt;
1293 }
1294 
1295 U_CAPI int32_t U_EXPORT2
1296 ureldatefmt_formatNumeric( const URelativeDateTimeFormatter* reldatefmt,
1297                     double                offset,
1298                     URelativeDateTimeUnit unit,
1299                     UChar*                result,
1300                     int32_t               resultCapacity,
1301                     UErrorCode*           status)
1302 {
1303     if (U_FAILURE(*status)) {
1304         return 0;
1305     }
<span class="line-modified">1306     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1307         *status = U_ILLEGAL_ARGUMENT_ERROR;
1308         return 0;
1309     }
1310     UnicodeString res;
<span class="line-modified">1311     if (result != nullptr) {</span>
<span class="line-modified">1312         // nullptr destination for pure preflighting: empty dummy string</span>
1313         // otherwise, alias the destination buffer (copied from udat_format)
1314         res.setTo(result, 0, resultCapacity);
1315     }
1316     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;formatNumeric(offset, unit, res, *status);
1317     if (U_FAILURE(*status)) {
1318         return 0;
1319     }
1320     return res.extract(result, resultCapacity, *status);
1321 }
1322 
<span class="line-added">1323 U_STABLE void U_EXPORT2</span>
<span class="line-added">1324 ureldatefmt_formatNumericToResult(</span>
<span class="line-added">1325         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">1326         double                            offset,</span>
<span class="line-added">1327         URelativeDateTimeUnit             unit,</span>
<span class="line-added">1328         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">1329         UErrorCode*                       status) {</span>
<span class="line-added">1330     if (U_FAILURE(*status)) {</span>
<span class="line-added">1331         return;</span>
<span class="line-added">1332     }</span>
<span class="line-added">1333     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">1334     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">1335     resultImpl-&gt;fImpl = fmt-&gt;formatNumericToValue(offset, unit, *status);</span>
<span class="line-added">1336 }</span>
<span class="line-added">1337 </span>
1338 U_CAPI int32_t U_EXPORT2
1339 ureldatefmt_format( const URelativeDateTimeFormatter* reldatefmt,
1340                     double                offset,
1341                     URelativeDateTimeUnit unit,
1342                     UChar*                result,
1343                     int32_t               resultCapacity,
1344                     UErrorCode*           status)
1345 {
1346     if (U_FAILURE(*status)) {
1347         return 0;
1348     }
<span class="line-modified">1349     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0) {</span>
1350         *status = U_ILLEGAL_ARGUMENT_ERROR;
1351         return 0;
1352     }
1353     UnicodeString res;
<span class="line-modified">1354     if (result != nullptr) {</span>
<span class="line-modified">1355         // nullptr destination for pure preflighting: empty dummy string</span>
1356         // otherwise, alias the destination buffer (copied from udat_format)
1357         res.setTo(result, 0, resultCapacity);
1358     }
1359     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;format(offset, unit, res, *status);
1360     if (U_FAILURE(*status)) {
1361         return 0;
1362     }
1363     return res.extract(result, resultCapacity, *status);
1364 }
1365 
<span class="line-added">1366 U_DRAFT void U_EXPORT2</span>
<span class="line-added">1367 ureldatefmt_formatToResult(</span>
<span class="line-added">1368         const URelativeDateTimeFormatter* reldatefmt,</span>
<span class="line-added">1369         double                            offset,</span>
<span class="line-added">1370         URelativeDateTimeUnit             unit,</span>
<span class="line-added">1371         UFormattedRelativeDateTime*       result,</span>
<span class="line-added">1372         UErrorCode*                       status) {</span>
<span class="line-added">1373     if (U_FAILURE(*status)) {</span>
<span class="line-added">1374         return;</span>
<span class="line-added">1375     }</span>
<span class="line-added">1376     auto* fmt = reinterpret_cast&lt;const RelativeDateTimeFormatter*&gt;(reldatefmt);</span>
<span class="line-added">1377     auto* resultImpl = UFormattedRelativeDateTimeApiHelper::validate(result, *status);</span>
<span class="line-added">1378     resultImpl-&gt;fImpl = fmt-&gt;formatToValue(offset, unit, *status);</span>
<span class="line-added">1379 }</span>
<span class="line-added">1380 </span>
1381 U_CAPI int32_t U_EXPORT2
1382 ureldatefmt_combineDateAndTime( const URelativeDateTimeFormatter* reldatefmt,
1383                     const UChar *     relativeDateString,
1384                     int32_t           relativeDateStringLen,
1385                     const UChar *     timeString,
1386                     int32_t           timeStringLen,
1387                     UChar*            result,
1388                     int32_t           resultCapacity,
1389                     UErrorCode*       status )
1390 {
1391     if (U_FAILURE(*status)) {
1392         return 0;
1393     }
<span class="line-modified">1394     if (result == nullptr ? resultCapacity != 0 : resultCapacity &lt; 0 ||</span>
<span class="line-modified">1395             (relativeDateString == nullptr ? relativeDateStringLen != 0 : relativeDateStringLen &lt; -1) ||</span>
<span class="line-modified">1396             (timeString == nullptr ? timeStringLen != 0 : timeStringLen &lt; -1)) {</span>
1397         *status = U_ILLEGAL_ARGUMENT_ERROR;
1398         return 0;
1399     }
1400     UnicodeString relDateStr((UBool)(relativeDateStringLen == -1), relativeDateString, relativeDateStringLen);
1401     UnicodeString timeStr((UBool)(timeStringLen == -1), timeString, timeStringLen);
1402     UnicodeString res(result, 0, resultCapacity);
1403     ((RelativeDateTimeFormatter*)reldatefmt)-&gt;combineDateAndTime(relDateStr, timeStr, res, *status);
1404     if (U_FAILURE(*status)) {
1405         return 0;
1406     }
1407     return res.extract(result, resultCapacity, *status);
1408 }
1409 
1410 #endif /* !UCONFIG_NO_FORMATTING */
</pre>
</td>
</tr>
</table>
<center><a href="region.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="reldtfmt.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>