<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/smpdtfmt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // © 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 *******************************************************************************
   5 * Copyright (C) 1997-2016, International Business Machines Corporation and    *
   6 * others. All Rights Reserved.                                                *
   7 *******************************************************************************
   8 *
   9 * File SMPDTFMT.CPP
  10 *
  11 * Modification History:
  12 *
  13 *   Date        Name        Description
  14 *   02/19/97    aliu        Converted from java.
  15 *   03/31/97    aliu        Modified extensively to work with 50 locales.
  16 *   04/01/97    aliu        Added support for centuries.
  17 *   07/09/97    helena      Made ParsePosition into a class.
  18 *   07/21/98    stephen     Added initializeDefaultCentury.
  19 *                             Removed getZoneIndex (added in DateFormatSymbols)
  20 *                             Removed subParseLong
  21 *                             Removed chk
  22 *   02/22/99    stephen     Removed character literals for EBCDIC safety
  23 *   10/14/99    aliu        Updated 2-digit year parsing so that only &quot;00&quot; thru
  24 *                           &quot;99&quot; are recognized. {j28 4182066}
  25 *   11/15/99    weiv        Added support for week of year/day of week format
  26 ********************************************************************************
  27 */
  28 
  29 #define ZID_KEY_MAX 128
  30 
  31 #include &quot;unicode/utypes.h&quot;
  32 
  33 #if !UCONFIG_NO_FORMATTING
  34 #include &quot;unicode/smpdtfmt.h&quot;
  35 #include &quot;unicode/dtfmtsym.h&quot;
  36 #include &quot;unicode/ures.h&quot;
  37 #include &quot;unicode/msgfmt.h&quot;
  38 #include &quot;unicode/calendar.h&quot;
  39 #include &quot;unicode/gregocal.h&quot;
  40 #include &quot;unicode/timezone.h&quot;
  41 #include &quot;unicode/decimfmt.h&quot;
  42 #include &quot;unicode/dcfmtsym.h&quot;
  43 #include &quot;unicode/uchar.h&quot;
  44 #include &quot;unicode/uniset.h&quot;
  45 #include &quot;unicode/ustring.h&quot;
  46 #include &quot;unicode/basictz.h&quot;
  47 #include &quot;unicode/simpleformatter.h&quot;
  48 #include &quot;unicode/simpletz.h&quot;
  49 #include &quot;unicode/rbtz.h&quot;
  50 #include &quot;unicode/tzfmt.h&quot;
  51 #include &quot;unicode/ucasemap.h&quot;
  52 #include &quot;unicode/utf16.h&quot;
  53 #include &quot;unicode/vtzone.h&quot;
  54 #include &quot;unicode/udisplaycontext.h&quot;
  55 #include &quot;unicode/brkiter.h&quot;
  56 #include &quot;unicode/rbnf.h&quot;
  57 #include &quot;uresimp.h&quot;
  58 #include &quot;olsontz.h&quot;
  59 #include &quot;patternprops.h&quot;
  60 #include &quot;fphdlimp.h&quot;
  61 #include &quot;hebrwcal.h&quot;
  62 #include &quot;cstring.h&quot;
  63 #include &quot;uassert.h&quot;
  64 #include &quot;cmemory.h&quot;
  65 #include &quot;umutex.h&quot;
  66 #include &lt;float.h&gt;
  67 #include &quot;smpdtfst.h&quot;
  68 #include &quot;sharednumberformat.h&quot;
  69 #include &quot;ucasemap_imp.h&quot;
  70 #include &quot;ustr_imp.h&quot;
  71 #include &quot;charstr.h&quot;
  72 #include &quot;uvector.h&quot;
  73 #include &quot;cstr.h&quot;
  74 #include &quot;dayperiodrules.h&quot;
  75 #include &quot;tznames_impl.h&quot;   // ZONE_NAME_U16_MAX
  76 #include &quot;number_utypes.h&quot;
  77 
  78 #if defined( U_DEBUG_CALSVC ) || defined (U_DEBUG_CAL)
  79 #include &lt;stdio.h&gt;
  80 #endif
  81 
  82 // *****************************************************************************
  83 // class SimpleDateFormat
  84 // *****************************************************************************
  85 
  86 U_NAMESPACE_BEGIN
  87 
  88 /**
  89  * Last-resort string to use for &quot;GMT&quot; when constructing time zone strings.
  90  */
  91 // For time zones that have no names, use strings GMT+minutes and
  92 // GMT-minutes. For instance, in France the time zone is GMT+60.
  93 // Also accepted are GMT+H:MM or GMT-H:MM.
  94 // Currently not being used
  95 //static const UChar gGmt[]      = {0x0047, 0x004D, 0x0054, 0x0000};         // &quot;GMT&quot;
  96 //static const UChar gGmtPlus[]  = {0x0047, 0x004D, 0x0054, 0x002B, 0x0000}; // &quot;GMT+&quot;
  97 //static const UChar gGmtMinus[] = {0x0047, 0x004D, 0x0054, 0x002D, 0x0000}; // &quot;GMT-&quot;
  98 //static const UChar gDefGmtPat[]       = {0x0047, 0x004D, 0x0054, 0x007B, 0x0030, 0x007D, 0x0000}; /* GMT{0} */
  99 //static const UChar gDefGmtNegHmsPat[] = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* -HH:mm:ss */
 100 //static const UChar gDefGmtNegHmPat[]  = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* -HH:mm */
 101 //static const UChar gDefGmtPosHmsPat[] = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* +HH:mm:ss */
 102 //static const UChar gDefGmtPosHmPat[]  = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* +HH:mm */
 103 //static const UChar gUt[]       = {0x0055, 0x0054, 0x0000};  // &quot;UT&quot;
 104 //static const UChar gUtc[]      = {0x0055, 0x0054, 0x0043, 0x0000};  // &quot;UT&quot;
 105 
 106 typedef enum GmtPatSize {
 107     kGmtLen = 3,
 108     kGmtPatLen = 6,
 109     kNegHmsLen = 9,
 110     kNegHmLen = 6,
 111     kPosHmsLen = 9,
 112     kPosHmLen = 6,
 113     kUtLen = 2,
 114     kUtcLen = 3
 115 } GmtPatSize;
 116 
 117 // Stuff needed for numbering system overrides
 118 
 119 typedef enum OvrStrType {
 120     kOvrStrDate = 0,
 121     kOvrStrTime = 1,
 122     kOvrStrBoth = 2
 123 } OvrStrType;
 124 
 125 static const UDateFormatField kDateFields[] = {
 126     UDAT_YEAR_FIELD,
 127     UDAT_MONTH_FIELD,
 128     UDAT_DATE_FIELD,
 129     UDAT_DAY_OF_YEAR_FIELD,
 130     UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
 131     UDAT_WEEK_OF_YEAR_FIELD,
 132     UDAT_WEEK_OF_MONTH_FIELD,
 133     UDAT_YEAR_WOY_FIELD,
 134     UDAT_EXTENDED_YEAR_FIELD,
 135     UDAT_JULIAN_DAY_FIELD,
 136     UDAT_STANDALONE_DAY_FIELD,
 137     UDAT_STANDALONE_MONTH_FIELD,
 138     UDAT_QUARTER_FIELD,
 139     UDAT_STANDALONE_QUARTER_FIELD,
 140     UDAT_YEAR_NAME_FIELD,
 141     UDAT_RELATED_YEAR_FIELD };
 142 static const int8_t kDateFieldsCount = 16;
 143 
 144 static const UDateFormatField kTimeFields[] = {
 145     UDAT_HOUR_OF_DAY1_FIELD,
 146     UDAT_HOUR_OF_DAY0_FIELD,
 147     UDAT_MINUTE_FIELD,
 148     UDAT_SECOND_FIELD,
 149     UDAT_FRACTIONAL_SECOND_FIELD,
 150     UDAT_HOUR1_FIELD,
 151     UDAT_HOUR0_FIELD,
 152     UDAT_MILLISECONDS_IN_DAY_FIELD,
 153     UDAT_TIMEZONE_RFC_FIELD,
 154     UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD };
 155 static const int8_t kTimeFieldsCount = 10;
 156 
 157 
 158 // This is a pattern-of-last-resort used when we can&#39;t load a usable pattern out
 159 // of a resource.
 160 static const UChar gDefaultPattern[] =
 161 {
 162     0x79, 0x79, 0x79, 0x79, 0x4D, 0x4D, 0x64, 0x64, 0x20, 0x68, 0x68, 0x3A, 0x6D, 0x6D, 0x20, 0x61, 0
 163 };  /* &quot;yyyyMMdd hh:mm a&quot; */
 164 
 165 // This prefix is designed to NEVER MATCH real text, in order to
 166 // suppress the parsing of negative numbers.  Adjust as needed (if
 167 // this becomes valid Unicode).
 168 static const UChar SUPPRESS_NEGATIVE_PREFIX[] = {0xAB00, 0};
 169 
 170 /**
 171  * These are the tags we expect to see in normal resource bundle files associated
 172  * with a locale.
 173  */
 174 static const UChar QUOTE = 0x27; // Single quote
 175 
 176 /*
 177  * The field range check bias for each UDateFormatField.
 178  * The bias is added to the minimum and maximum values
 179  * before they are compared to the parsed number.
 180  * For example, the calendar stores zero-based month numbers
 181  * but the parsed month numbers start at 1, so the bias is 1.
 182  *
 183  * A value of -1 means that the value is not checked.
 184  */
 185 static const int32_t gFieldRangeBias[] = {
 186     -1,  // &#39;G&#39; - UDAT_ERA_FIELD
 187     -1,  // &#39;y&#39; - UDAT_YEAR_FIELD
 188      1,  // &#39;M&#39; - UDAT_MONTH_FIELD
 189      0,  // &#39;d&#39; - UDAT_DATE_FIELD
 190     -1,  // &#39;k&#39; - UDAT_HOUR_OF_DAY1_FIELD
 191     -1,  // &#39;H&#39; - UDAT_HOUR_OF_DAY0_FIELD
 192      0,  // &#39;m&#39; - UDAT_MINUTE_FIELD
 193      0,  // &#39;s&#39; - UDAT_SECOND_FIELD
 194     -1,  // &#39;S&#39; - UDAT_FRACTIONAL_SECOND_FIELD (0-999?)
 195     -1,  // &#39;E&#39; - UDAT_DAY_OF_WEEK_FIELD (1-7?)
 196     -1,  // &#39;D&#39; - UDAT_DAY_OF_YEAR_FIELD (1 - 366?)
 197     -1,  // &#39;F&#39; - UDAT_DAY_OF_WEEK_IN_MONTH_FIELD (1-5?)
 198     -1,  // &#39;w&#39; - UDAT_WEEK_OF_YEAR_FIELD (1-52?)
 199     -1,  // &#39;W&#39; - UDAT_WEEK_OF_MONTH_FIELD (1-5?)
 200     -1,  // &#39;a&#39; - UDAT_AM_PM_FIELD
 201     -1,  // &#39;h&#39; - UDAT_HOUR1_FIELD
 202     -1,  // &#39;K&#39; - UDAT_HOUR0_FIELD
 203     -1,  // &#39;z&#39; - UDAT_TIMEZONE_FIELD
 204     -1,  // &#39;Y&#39; - UDAT_YEAR_WOY_FIELD
 205     -1,  // &#39;e&#39; - UDAT_DOW_LOCAL_FIELD
 206     -1,  // &#39;u&#39; - UDAT_EXTENDED_YEAR_FIELD
 207     -1,  // &#39;g&#39; - UDAT_JULIAN_DAY_FIELD
 208     -1,  // &#39;A&#39; - UDAT_MILLISECONDS_IN_DAY_FIELD
 209     -1,  // &#39;Z&#39; - UDAT_TIMEZONE_RFC_FIELD
 210     -1,  // &#39;v&#39; - UDAT_TIMEZONE_GENERIC_FIELD
 211      0,  // &#39;c&#39; - UDAT_STANDALONE_DAY_FIELD
 212      1,  // &#39;L&#39; - UDAT_STANDALONE_MONTH_FIELD
 213     -1,  // &#39;Q&#39; - UDAT_QUARTER_FIELD (1-4?)
 214     -1,  // &#39;q&#39; - UDAT_STANDALONE_QUARTER_FIELD
 215     -1,  // &#39;V&#39; - UDAT_TIMEZONE_SPECIAL_FIELD
 216     -1,  // &#39;U&#39; - UDAT_YEAR_NAME_FIELD
 217     -1,  // &#39;O&#39; - UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD
 218     -1,  // &#39;X&#39; - UDAT_TIMEZONE_ISO_FIELD
 219     -1,  // &#39;x&#39; - UDAT_TIMEZONE_ISO_LOCAL_FIELD
 220     -1,  // &#39;r&#39; - UDAT_RELATED_YEAR_FIELD
 221 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
 222     -1,  // &#39;:&#39; - UDAT_TIME_SEPARATOR_FIELD
 223 #else
 224     -1,  // (no pattern character currently) - UDAT_TIME_SEPARATOR_FIELD
 225 #endif
 226 };
 227 
 228 // When calendar uses hebr numbering (i.e. he@calendar=hebrew),
 229 // offset the years within the current millenium down to 1-999
 230 static const int32_t HEBREW_CAL_CUR_MILLENIUM_START_YEAR = 5000;
 231 static const int32_t HEBREW_CAL_CUR_MILLENIUM_END_YEAR = 6000;
 232 
 233 static UMutex *LOCK() {
 234     static UMutex m = U_MUTEX_INITIALIZER;
 235     return &amp;m;
 236 }
 237 
 238 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleDateFormat)
 239 
 240 SimpleDateFormat::NSOverride::~NSOverride() {
 241     if (snf != NULL) {
 242         snf-&gt;removeRef();
 243     }
 244 }
 245 
 246 
 247 void SimpleDateFormat::NSOverride::free() {
 248     NSOverride *cur = this;
 249     while (cur) {
 250         NSOverride *next_temp = cur-&gt;next;
 251         delete cur;
 252         cur = next_temp;
 253     }
 254 }
 255 
 256 // no matter what the locale&#39;s default number format looked like, we want
 257 // to modify it so that it doesn&#39;t use thousands separators, doesn&#39;t always
 258 // show the decimal point, and recognizes integers only when parsing
 259 static void fixNumberFormatForDates(NumberFormat &amp;nf) {
 260     nf.setGroupingUsed(FALSE);
 261     DecimalFormat* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(&amp;nf);
 262     if (decfmt != NULL) {
 263         decfmt-&gt;setDecimalSeparatorAlwaysShown(FALSE);
 264     }
 265     nf.setParseIntegerOnly(TRUE);
 266     nf.setMinimumFractionDigits(0); // To prevent &quot;Jan 1.00, 1997.00&quot;
 267 }
 268 
 269 static const SharedNumberFormat *createSharedNumberFormat(
 270         NumberFormat *nfToAdopt) {
 271     fixNumberFormatForDates(*nfToAdopt);
 272     const SharedNumberFormat *result = new SharedNumberFormat(nfToAdopt);
 273     if (result == NULL) {
 274         delete nfToAdopt;
 275     }
 276     return result;
 277 }
 278 
 279 static const SharedNumberFormat *createSharedNumberFormat(
 280         const Locale &amp;loc, UErrorCode &amp;status) {
 281     NumberFormat *nf = NumberFormat::createInstance(loc, status);
 282     if (U_FAILURE(status)) {
 283         return NULL;
 284     }
 285     const SharedNumberFormat *result = createSharedNumberFormat(nf);
 286     if (result == NULL) {
 287         status = U_MEMORY_ALLOCATION_ERROR;
 288     }
 289     return result;
 290 }
 291 
 292 static const SharedNumberFormat **allocSharedNumberFormatters() {
 293     const SharedNumberFormat **result = (const SharedNumberFormat**)
 294             uprv_malloc(UDAT_FIELD_COUNT * sizeof(const SharedNumberFormat*));
 295     if (result == NULL) {
 296         return NULL;
 297     }
 298     for (int32_t i = 0; i &lt; UDAT_FIELD_COUNT; ++i) {
 299         result[i] = NULL;
 300     }
 301     return result;
 302 }
 303 
 304 static void freeSharedNumberFormatters(const SharedNumberFormat ** list) {
 305     for (int32_t i = 0; i &lt; UDAT_FIELD_COUNT; ++i) {
 306         SharedObject::clearPtr(list[i]);
 307     }
 308     uprv_free(list);
 309 }
 310 
 311 const NumberFormat *SimpleDateFormat::getNumberFormatByIndex(
 312         UDateFormatField index) const {
 313     if (fSharedNumberFormatters == NULL ||
 314         fSharedNumberFormatters[index] == NULL) {
 315         return fNumberFormat;
 316     }
 317     return &amp;(**fSharedNumberFormatters[index]);
 318 }
 319 
 320 //----------------------------------------------------------------------
 321 
 322 SimpleDateFormat::~SimpleDateFormat()
 323 {
 324     delete fSymbols;
 325     if (fSharedNumberFormatters) {
 326         freeSharedNumberFormatters(fSharedNumberFormatters);
 327     }
 328     if (fTimeZoneFormat) {
 329         delete fTimeZoneFormat;
 330     }
 331     freeFastNumberFormatters();
 332 
 333 #if !UCONFIG_NO_BREAK_ITERATION
 334     delete fCapitalizationBrkIter;
 335 #endif
 336 }
 337 
 338 //----------------------------------------------------------------------
 339 
 340 SimpleDateFormat::SimpleDateFormat(UErrorCode&amp; status)
 341   :   fLocale(Locale::getDefault()),
 342       fSymbols(NULL),
 343       fTimeZoneFormat(NULL),
 344       fSharedNumberFormatters(NULL),
 345       fCapitalizationBrkIter(NULL)
 346 {
 347     initializeBooleanAttributes();
 348     construct(kShort, (EStyle) (kShort + kDateOffset), fLocale, status);
 349     initializeDefaultCentury();
 350 }
 351 
 352 //----------------------------------------------------------------------
 353 
 354 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 355                                    UErrorCode &amp;status)
 356 :   fPattern(pattern),
 357     fLocale(Locale::getDefault()),
 358     fSymbols(NULL),
 359     fTimeZoneFormat(NULL),
 360     fSharedNumberFormatters(NULL),
 361     fCapitalizationBrkIter(NULL)
 362 {
 363     fDateOverride.setToBogus();
 364     fTimeOverride.setToBogus();
 365     initializeBooleanAttributes();
 366     initializeCalendar(NULL,fLocale,status);
 367     fSymbols = DateFormatSymbols::createForLocale(fLocale, status);
 368     initialize(fLocale, status);
 369     initializeDefaultCentury();
 370 
 371 }
 372 //----------------------------------------------------------------------
 373 
 374 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 375                                    const UnicodeString&amp; override,
 376                                    UErrorCode &amp;status)
 377 :   fPattern(pattern),
 378     fLocale(Locale::getDefault()),
 379     fSymbols(NULL),
 380     fTimeZoneFormat(NULL),
 381     fSharedNumberFormatters(NULL),
 382     fCapitalizationBrkIter(NULL)
 383 {
 384     fDateOverride.setTo(override);
 385     fTimeOverride.setToBogus();
 386     initializeBooleanAttributes();
 387     initializeCalendar(NULL,fLocale,status);
 388     fSymbols = DateFormatSymbols::createForLocale(fLocale, status);
 389     initialize(fLocale, status);
 390     initializeDefaultCentury();
 391 
 392     processOverrideString(fLocale,override,kOvrStrBoth,status);
 393 
 394 }
 395 
 396 //----------------------------------------------------------------------
 397 
 398 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 399                                    const Locale&amp; locale,
 400                                    UErrorCode&amp; status)
 401 :   fPattern(pattern),
 402     fLocale(locale),
 403     fTimeZoneFormat(NULL),
 404     fSharedNumberFormatters(NULL),
 405     fCapitalizationBrkIter(NULL)
 406 {
 407 
 408     fDateOverride.setToBogus();
 409     fTimeOverride.setToBogus();
 410     initializeBooleanAttributes();
 411 
 412     initializeCalendar(NULL,fLocale,status);
 413     fSymbols = DateFormatSymbols::createForLocale(fLocale, status);
 414     initialize(fLocale, status);
 415     initializeDefaultCentury();
 416 }
 417 
 418 //----------------------------------------------------------------------
 419 
 420 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 421                                    const UnicodeString&amp; override,
 422                                    const Locale&amp; locale,
 423                                    UErrorCode&amp; status)
 424 :   fPattern(pattern),
 425     fLocale(locale),
 426     fTimeZoneFormat(NULL),
 427     fSharedNumberFormatters(NULL),
 428     fCapitalizationBrkIter(NULL)
 429 {
 430 
 431     fDateOverride.setTo(override);
 432     fTimeOverride.setToBogus();
 433     initializeBooleanAttributes();
 434 
 435     initializeCalendar(NULL,fLocale,status);
 436     fSymbols = DateFormatSymbols::createForLocale(fLocale, status);
 437     initialize(fLocale, status);
 438     initializeDefaultCentury();
 439 
 440     processOverrideString(locale,override,kOvrStrBoth,status);
 441 
 442 }
 443 
 444 //----------------------------------------------------------------------
 445 
 446 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 447                                    DateFormatSymbols* symbolsToAdopt,
 448                                    UErrorCode&amp; status)
 449 :   fPattern(pattern),
 450     fLocale(Locale::getDefault()),
 451     fSymbols(symbolsToAdopt),
 452     fTimeZoneFormat(NULL),
 453     fSharedNumberFormatters(NULL),
 454     fCapitalizationBrkIter(NULL)
 455 {
 456 
 457     fDateOverride.setToBogus();
 458     fTimeOverride.setToBogus();
 459     initializeBooleanAttributes();
 460 
 461     initializeCalendar(NULL,fLocale,status);
 462     initialize(fLocale, status);
 463     initializeDefaultCentury();
 464 }
 465 
 466 //----------------------------------------------------------------------
 467 
 468 SimpleDateFormat::SimpleDateFormat(const UnicodeString&amp; pattern,
 469                                    const DateFormatSymbols&amp; symbols,
 470                                    UErrorCode&amp; status)
 471 :   fPattern(pattern),
 472     fLocale(Locale::getDefault()),
 473     fSymbols(new DateFormatSymbols(symbols)),
 474     fTimeZoneFormat(NULL),
 475     fSharedNumberFormatters(NULL),
 476     fCapitalizationBrkIter(NULL)
 477 {
 478 
 479     fDateOverride.setToBogus();
 480     fTimeOverride.setToBogus();
 481     initializeBooleanAttributes();
 482 
 483     initializeCalendar(NULL, fLocale, status);
 484     initialize(fLocale, status);
 485     initializeDefaultCentury();
 486 }
 487 
 488 //----------------------------------------------------------------------
 489 
 490 // Not for public consumption; used by DateFormat
 491 SimpleDateFormat::SimpleDateFormat(EStyle timeStyle,
 492                                    EStyle dateStyle,
 493                                    const Locale&amp; locale,
 494                                    UErrorCode&amp; status)
 495 :   fLocale(locale),
 496     fSymbols(NULL),
 497     fTimeZoneFormat(NULL),
 498     fSharedNumberFormatters(NULL),
 499     fCapitalizationBrkIter(NULL)
 500 {
 501     initializeBooleanAttributes();
 502     construct(timeStyle, dateStyle, fLocale, status);
 503     if(U_SUCCESS(status)) {
 504       initializeDefaultCentury();
 505     }
 506 }
 507 
 508 //----------------------------------------------------------------------
 509 
 510 /**
 511  * Not for public consumption; used by DateFormat.  This constructor
 512  * never fails.  If the resource data is not available, it uses the
 513  * the last resort symbols.
 514  */
 515 SimpleDateFormat::SimpleDateFormat(const Locale&amp; locale,
 516                                    UErrorCode&amp; status)
 517 :   fPattern(gDefaultPattern),
 518     fLocale(locale),
 519     fSymbols(NULL),
 520     fTimeZoneFormat(NULL),
 521     fSharedNumberFormatters(NULL),
 522     fCapitalizationBrkIter(NULL)
 523 {
 524     if (U_FAILURE(status)) return;
 525     initializeBooleanAttributes();
 526     initializeCalendar(NULL, fLocale, status);
 527     fSymbols = DateFormatSymbols::createForLocale(fLocale, status);
 528     if (U_FAILURE(status))
 529     {
 530         status = U_ZERO_ERROR;
 531         delete fSymbols;
 532         // This constructor doesn&#39;t fail; it uses last resort data
 533         fSymbols = new DateFormatSymbols(status);
 534         /* test for NULL */
 535         if (fSymbols == 0) {
 536             status = U_MEMORY_ALLOCATION_ERROR;
 537             return;
 538         }
 539     }
 540 
 541     fDateOverride.setToBogus();
 542     fTimeOverride.setToBogus();
 543 
 544     initialize(fLocale, status);
 545     if(U_SUCCESS(status)) {
 546       initializeDefaultCentury();
 547     }
 548 }
 549 
 550 //----------------------------------------------------------------------
 551 
 552 SimpleDateFormat::SimpleDateFormat(const SimpleDateFormat&amp; other)
 553 :   DateFormat(other),
 554     fLocale(other.fLocale),
 555     fSymbols(NULL),
 556     fTimeZoneFormat(NULL),
 557     fSharedNumberFormatters(NULL),
 558     fCapitalizationBrkIter(NULL)
 559 {
 560     initializeBooleanAttributes();
 561     *this = other;
 562 }
 563 
 564 //----------------------------------------------------------------------
 565 
 566 SimpleDateFormat&amp; SimpleDateFormat::operator=(const SimpleDateFormat&amp; other)
 567 {
 568     if (this == &amp;other) {
 569         return *this;
 570     }
 571     DateFormat::operator=(other);
 572     fDateOverride = other.fDateOverride;
 573     fTimeOverride = other.fTimeOverride;
 574 
 575     delete fSymbols;
 576     fSymbols = NULL;
 577 
 578     if (other.fSymbols)
 579         fSymbols = new DateFormatSymbols(*other.fSymbols);
 580 
 581     fDefaultCenturyStart         = other.fDefaultCenturyStart;
 582     fDefaultCenturyStartYear     = other.fDefaultCenturyStartYear;
 583     fHaveDefaultCentury          = other.fHaveDefaultCentury;
 584 
 585     fPattern = other.fPattern;
 586     fHasMinute = other.fHasMinute;
 587     fHasSecond = other.fHasSecond;
 588 
 589     // TimeZoneFormat in ICU4C only depends on a locale for now
 590     if (fLocale != other.fLocale) {
 591         delete fTimeZoneFormat;
 592         fTimeZoneFormat = NULL; // forces lazy instantiation with the other locale
 593         fLocale = other.fLocale;
 594     }
 595 
 596 #if !UCONFIG_NO_BREAK_ITERATION
 597     if (other.fCapitalizationBrkIter != NULL) {
 598         fCapitalizationBrkIter = (other.fCapitalizationBrkIter)-&gt;clone();
 599     }
 600 #endif
 601 
 602     if (fSharedNumberFormatters != NULL) {
 603         freeSharedNumberFormatters(fSharedNumberFormatters);
 604         fSharedNumberFormatters = NULL;
 605     }
 606     if (other.fSharedNumberFormatters != NULL) {
 607         fSharedNumberFormatters = allocSharedNumberFormatters();
 608         if (fSharedNumberFormatters) {
 609             for (int32_t i = 0; i &lt; UDAT_FIELD_COUNT; ++i) {
 610                 SharedObject::copyPtr(
 611                         other.fSharedNumberFormatters[i],
 612                         fSharedNumberFormatters[i]);
 613             }
 614         }
 615     }
 616 
 617     UErrorCode localStatus = U_ZERO_ERROR;
 618     freeFastNumberFormatters();
 619     initFastNumberFormatters(localStatus);
 620 
 621     return *this;
 622 }
 623 
 624 //----------------------------------------------------------------------
 625 
 626 Format*
 627 SimpleDateFormat::clone() const
 628 {
 629     return new SimpleDateFormat(*this);
 630 }
 631 
 632 //----------------------------------------------------------------------
 633 
 634 UBool
 635 SimpleDateFormat::operator==(const Format&amp; other) const
 636 {
 637     if (DateFormat::operator==(other)) {
 638         // The DateFormat::operator== check for fCapitalizationContext equality above
 639         //   is sufficient to check equality of all derived context-related data.
 640         // DateFormat::operator== guarantees following cast is safe
 641         SimpleDateFormat* that = (SimpleDateFormat*)&amp;other;
 642         return (fPattern             == that-&gt;fPattern &amp;&amp;
 643                 fSymbols             != NULL &amp;&amp; // Check for pathological object
 644                 that-&gt;fSymbols       != NULL &amp;&amp; // Check for pathological object
 645                 *fSymbols            == *that-&gt;fSymbols &amp;&amp;
 646                 fHaveDefaultCentury  == that-&gt;fHaveDefaultCentury &amp;&amp;
 647                 fDefaultCenturyStart == that-&gt;fDefaultCenturyStart);
 648     }
 649     return FALSE;
 650 }
 651 
 652 //----------------------------------------------------------------------
 653 
 654 void SimpleDateFormat::construct(EStyle timeStyle,
 655                                  EStyle dateStyle,
 656                                  const Locale&amp; locale,
 657                                  UErrorCode&amp; status)
 658 {
 659     // called by several constructors to load pattern data from the resources
 660     if (U_FAILURE(status)) return;
 661 
 662     // We will need the calendar to know what type of symbols to load.
 663     initializeCalendar(NULL, locale, status);
 664     if (U_FAILURE(status)) return;
 665 
 666     // Load date time patterns directly from resources.
 667     const char* cType = fCalendar ? fCalendar-&gt;getType() : NULL;
 668     LocalUResourceBundlePointer bundle(ures_open(NULL, locale.getBaseName(), &amp;status));
 669     if (U_FAILURE(status)) return;
 670 
 671     UBool cTypeIsGregorian = TRUE;
 672     LocalUResourceBundlePointer dateTimePatterns;
 673     if (cType != NULL &amp;&amp; uprv_strcmp(cType, &quot;gregorian&quot;) != 0) {
 674         CharString resourcePath(&quot;calendar/&quot;, status);
 675         resourcePath.append(cType, status).append(&quot;/DateTimePatterns&quot;, status);
 676         dateTimePatterns.adoptInstead(
 677             ures_getByKeyWithFallback(bundle.getAlias(), resourcePath.data(),
 678                                       (UResourceBundle*)NULL, &amp;status));
 679         cTypeIsGregorian = FALSE;
 680     }
 681 
 682     // Check for &quot;gregorian&quot; fallback.
 683     if (cTypeIsGregorian || status == U_MISSING_RESOURCE_ERROR) {
 684         status = U_ZERO_ERROR;
 685         dateTimePatterns.adoptInstead(
 686             ures_getByKeyWithFallback(bundle.getAlias(),
 687                                       &quot;calendar/gregorian/DateTimePatterns&quot;,
 688                                       (UResourceBundle*)NULL, &amp;status));
 689     }
 690     if (U_FAILURE(status)) return;
 691 
 692     LocalUResourceBundlePointer currentBundle;
 693 
 694     if (ures_getSize(dateTimePatterns.getAlias()) &lt;= kDateTime)
 695     {
 696         status = U_INVALID_FORMAT_ERROR;
 697         return;
 698     }
 699 
 700     setLocaleIDs(ures_getLocaleByType(dateTimePatterns.getAlias(), ULOC_VALID_LOCALE, &amp;status),
 701                  ures_getLocaleByType(dateTimePatterns.getAlias(), ULOC_ACTUAL_LOCALE, &amp;status));
 702 
 703     // create a symbols object from the locale
 704     fSymbols = DateFormatSymbols::createForLocale(locale, status);
 705     if (U_FAILURE(status)) return;
 706     /* test for NULL */
 707     if (fSymbols == 0) {
 708         status = U_MEMORY_ALLOCATION_ERROR;
 709         return;
 710     }
 711 
 712     const UChar *resStr,*ovrStr;
 713     int32_t resStrLen,ovrStrLen = 0;
 714     fDateOverride.setToBogus();
 715     fTimeOverride.setToBogus();
 716 
 717     // if the pattern should include both date and time information, use the date/time
 718     // pattern string as a guide to tell use how to glue together the appropriate date
 719     // and time pattern strings.
 720     if ((timeStyle != kNone) &amp;&amp; (dateStyle != kNone))
 721     {
 722         currentBundle.adoptInstead(
 723                 ures_getByIndex(dateTimePatterns.getAlias(), (int32_t)timeStyle, NULL, &amp;status));
 724         if (U_FAILURE(status)) {
 725            status = U_INVALID_FORMAT_ERROR;
 726            return;
 727         }
 728         switch (ures_getType(currentBundle.getAlias())) {
 729             case URES_STRING: {
 730                resStr = ures_getString(currentBundle.getAlias(), &amp;resStrLen, &amp;status);
 731                break;
 732             }
 733             case URES_ARRAY: {
 734                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &amp;resStrLen, &amp;status);
 735                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &amp;ovrStrLen, &amp;status);
 736                fTimeOverride.setTo(TRUE, ovrStr, ovrStrLen);
 737                break;
 738             }
 739             default: {
 740                status = U_INVALID_FORMAT_ERROR;
 741                return;
 742             }
 743         }
 744 
 745         UnicodeString tempus1(TRUE, resStr, resStrLen);
 746 
 747         currentBundle.adoptInstead(
 748                 ures_getByIndex(dateTimePatterns.getAlias(), (int32_t)dateStyle, NULL, &amp;status));
 749         if (U_FAILURE(status)) {
 750            status = U_INVALID_FORMAT_ERROR;
 751            return;
 752         }
 753         switch (ures_getType(currentBundle.getAlias())) {
 754             case URES_STRING: {
 755                resStr = ures_getString(currentBundle.getAlias(), &amp;resStrLen, &amp;status);
 756                break;
 757             }
 758             case URES_ARRAY: {
 759                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &amp;resStrLen, &amp;status);
 760                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &amp;ovrStrLen, &amp;status);
 761                fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
 762                break;
 763             }
 764             default: {
 765                status = U_INVALID_FORMAT_ERROR;
 766                return;
 767             }
 768         }
 769 
 770         UnicodeString tempus2(TRUE, resStr, resStrLen);
 771 
 772         int32_t glueIndex = kDateTime;
 773         int32_t patternsSize = ures_getSize(dateTimePatterns.getAlias());
 774         if (patternsSize &gt;= (kDateTimeOffset + kShort + 1)) {
 775             // Get proper date time format
 776             glueIndex = (int32_t)(kDateTimeOffset + (dateStyle - kDateOffset));
 777         }
 778 
 779         resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), glueIndex, &amp;resStrLen, &amp;status);
 780         SimpleFormatter(UnicodeString(TRUE, resStr, resStrLen), 2, 2, status).
 781                 format(tempus1, tempus2, fPattern, status);
 782     }
 783     // if the pattern includes just time data or just date date, load the appropriate
 784     // pattern string from the resources
 785     // setTo() - see DateFormatSymbols::assignArray comments
 786     else if (timeStyle != kNone) {
 787         currentBundle.adoptInstead(
 788                 ures_getByIndex(dateTimePatterns.getAlias(), (int32_t)timeStyle, NULL, &amp;status));
 789         if (U_FAILURE(status)) {
 790            status = U_INVALID_FORMAT_ERROR;
 791            return;
 792         }
 793         switch (ures_getType(currentBundle.getAlias())) {
 794             case URES_STRING: {
 795                resStr = ures_getString(currentBundle.getAlias(), &amp;resStrLen, &amp;status);
 796                break;
 797             }
 798             case URES_ARRAY: {
 799                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &amp;resStrLen, &amp;status);
 800                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &amp;ovrStrLen, &amp;status);
 801                fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
 802                break;
 803             }
 804             default: {
 805                status = U_INVALID_FORMAT_ERROR;
 806                return;
 807             }
 808         }
 809         fPattern.setTo(TRUE, resStr, resStrLen);
 810     }
 811     else if (dateStyle != kNone) {
 812         currentBundle.adoptInstead(
 813                 ures_getByIndex(dateTimePatterns.getAlias(), (int32_t)dateStyle, NULL, &amp;status));
 814         if (U_FAILURE(status)) {
 815            status = U_INVALID_FORMAT_ERROR;
 816            return;
 817         }
 818         switch (ures_getType(currentBundle.getAlias())) {
 819             case URES_STRING: {
 820                resStr = ures_getString(currentBundle.getAlias(), &amp;resStrLen, &amp;status);
 821                break;
 822             }
 823             case URES_ARRAY: {
 824                resStr = ures_getStringByIndex(currentBundle.getAlias(), 0, &amp;resStrLen, &amp;status);
 825                ovrStr = ures_getStringByIndex(currentBundle.getAlias(), 1, &amp;ovrStrLen, &amp;status);
 826                fDateOverride.setTo(TRUE, ovrStr, ovrStrLen);
 827                break;
 828             }
 829             default: {
 830                status = U_INVALID_FORMAT_ERROR;
 831                return;
 832             }
 833         }
 834         fPattern.setTo(TRUE, resStr, resStrLen);
 835     }
 836 
 837     // and if it includes _neither_, that&#39;s an error
 838     else
 839         status = U_INVALID_FORMAT_ERROR;
 840 
 841     // finally, finish initializing by creating a Calendar and a NumberFormat
 842     initialize(locale, status);
 843 }
 844 
 845 //----------------------------------------------------------------------
 846 
 847 Calendar*
 848 SimpleDateFormat::initializeCalendar(TimeZone* adoptZone, const Locale&amp; locale, UErrorCode&amp; status)
 849 {
 850     if(!U_FAILURE(status)) {
 851         fCalendar = Calendar::createInstance(adoptZone?adoptZone:TimeZone::createDefault(), locale, status);
 852     }
 853     return fCalendar;
 854 }
 855 
 856 void
 857 SimpleDateFormat::initialize(const Locale&amp; locale,
 858                              UErrorCode&amp; status)
 859 {
 860     if (U_FAILURE(status)) return;
 861 
 862     parsePattern(); // Need this before initNumberFormatters(), to set fHasHanYearChar
 863 
 864     // Simple-minded hack to force Gannen year numbering for ja@calendar=japanese
 865     // if format is non-numeric (includes 年) and fDateOverride is not already specified.
 866     // Now this does get updated if applyPattern subsequently changes the pattern type.
 867     if (fDateOverride.isBogus() &amp;&amp; fHasHanYearChar &amp;&amp;
 868             fCalendar != nullptr &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(),&quot;japanese&quot;) == 0 &amp;&amp;
 869             uprv_strcmp(fLocale.getLanguage(),&quot;ja&quot;) == 0) {
 870         fDateOverride.setTo(u&quot;y=jpanyear&quot;, -1);
 871     }
 872 
 873     // We don&#39;t need to check that the row count is &gt;= 1, since all 2d arrays have at
 874     // least one row
 875     fNumberFormat = NumberFormat::createInstance(locale, status);
 876     if (fNumberFormat != NULL &amp;&amp; U_SUCCESS(status))
 877     {
 878         fixNumberFormatForDates(*fNumberFormat);
 879         //fNumberFormat-&gt;setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse
 880 
 881         initNumberFormatters(locale, status);
 882         initFastNumberFormatters(status);
 883 
 884     }
 885     else if (U_SUCCESS(status))
 886     {
 887         status = U_MISSING_RESOURCE_ERROR;
 888     }
 889 }
 890 
 891 /* Initialize the fields we use to disambiguate ambiguous years. Separate
 892  * so we can call it from readObject().
 893  */
 894 void SimpleDateFormat::initializeDefaultCentury()
 895 {
 896   if(fCalendar) {
 897     fHaveDefaultCentury = fCalendar-&gt;haveDefaultCentury();
 898     if(fHaveDefaultCentury) {
 899       fDefaultCenturyStart = fCalendar-&gt;defaultCenturyStart();
 900       fDefaultCenturyStartYear = fCalendar-&gt;defaultCenturyStartYear();
 901     } else {
 902       fDefaultCenturyStart = DBL_MIN;
 903       fDefaultCenturyStartYear = -1;
 904     }
 905   }
 906 }
 907 
 908 /*
 909  * Initialize the boolean attributes. Separate so we can call it from all constructors.
 910  */
 911 void SimpleDateFormat::initializeBooleanAttributes()
 912 {
 913     UErrorCode status = U_ZERO_ERROR;
 914 
 915     setBooleanAttribute(UDAT_PARSE_ALLOW_WHITESPACE, true, status);
 916     setBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, true, status);
 917     setBooleanAttribute(UDAT_PARSE_PARTIAL_LITERAL_MATCH, true, status);
 918     setBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, true, status);
 919 }
 920 
 921 /* Define one-century window into which to disambiguate dates using
 922  * two-digit years. Make public in JDK 1.2.
 923  */
 924 void SimpleDateFormat::parseAmbiguousDatesAsAfter(UDate startDate, UErrorCode&amp; status)
 925 {
 926     if(U_FAILURE(status)) {
 927         return;
 928     }
 929     if(!fCalendar) {
 930       status = U_ILLEGAL_ARGUMENT_ERROR;
 931       return;
 932     }
 933 
 934     fCalendar-&gt;setTime(startDate, status);
 935     if(U_SUCCESS(status)) {
 936         fHaveDefaultCentury = TRUE;
 937         fDefaultCenturyStart = startDate;
 938         fDefaultCenturyStartYear = fCalendar-&gt;get(UCAL_YEAR, status);
 939     }
 940 }
 941 
 942 //----------------------------------------------------------------------
 943 
 944 UnicodeString&amp;
 945 SimpleDateFormat::format(Calendar&amp; cal, UnicodeString&amp; appendTo, FieldPosition&amp; pos) const
 946 {
 947   UErrorCode status = U_ZERO_ERROR;
 948   FieldPositionOnlyHandler handler(pos);
 949   return _format(cal, appendTo, handler, status);
 950 }
 951 
 952 //----------------------------------------------------------------------
 953 
 954 UnicodeString&amp;
 955 SimpleDateFormat::format(Calendar&amp; cal, UnicodeString&amp; appendTo,
 956                          FieldPositionIterator* posIter, UErrorCode&amp; status) const
 957 {
 958   FieldPositionIteratorHandler handler(posIter, status);
 959   return _format(cal, appendTo, handler, status);
 960 }
 961 
 962 //----------------------------------------------------------------------
 963 
 964 UnicodeString&amp;
 965 SimpleDateFormat::_format(Calendar&amp; cal, UnicodeString&amp; appendTo,
 966                             FieldPositionHandler&amp; handler, UErrorCode&amp; status) const
 967 {
 968     if ( U_FAILURE(status) ) {
 969        return appendTo;
 970     }
 971     Calendar* workCal = &amp;cal;
 972     Calendar* calClone = NULL;
 973     if (&amp;cal != fCalendar &amp;&amp; uprv_strcmp(cal.getType(), fCalendar-&gt;getType()) != 0) {
 974         // Different calendar type
 975         // We use the time and time zone from the input calendar, but
 976         // do not use the input calendar for field calculation.
 977         calClone = fCalendar-&gt;clone();
 978         if (calClone != NULL) {
 979             UDate t = cal.getTime(status);
 980             calClone-&gt;setTime(t, status);
 981             calClone-&gt;setTimeZone(cal.getTimeZone());
 982             workCal = calClone;
 983         } else {
 984             status = U_MEMORY_ALLOCATION_ERROR;
 985             return appendTo;
 986         }
 987     }
 988 
 989     UBool inQuote = FALSE;
 990     UChar prevCh = 0;
 991     int32_t count = 0;
 992     int32_t fieldNum = 0;
 993     UDisplayContext capitalizationContext = getContext(UDISPCTX_TYPE_CAPITALIZATION, status);
 994 
 995     // loop through the pattern string character by character
 996     for (int32_t i = 0; i &lt; fPattern.length() &amp;&amp; U_SUCCESS(status); ++i) {
 997         UChar ch = fPattern[i];
 998 
 999         // Use subFormat() to format a repeated pattern character
1000         // when a different pattern or non-pattern character is seen
1001         if (ch != prevCh &amp;&amp; count &gt; 0) {
1002             subFormat(appendTo, prevCh, count, capitalizationContext, fieldNum++, handler, *workCal, status);
1003             count = 0;
1004         }
1005         if (ch == QUOTE) {
1006             // Consecutive single quotes are a single quote literal,
1007             // either outside of quotes or between quotes
1008             if ((i+1) &lt; fPattern.length() &amp;&amp; fPattern[i+1] == QUOTE) {
1009                 appendTo += (UChar)QUOTE;
1010                 ++i;
1011             } else {
1012                 inQuote = ! inQuote;
1013             }
1014         }
1015         else if (!inQuote &amp;&amp; isSyntaxChar(ch)) {
1016             // ch is a date-time pattern character to be interpreted
1017             // by subFormat(); count the number of times it is repeated
1018             prevCh = ch;
1019             ++count;
1020         }
1021         else {
1022             // Append quoted characters and unquoted non-pattern characters
1023             appendTo += ch;
1024         }
1025     }
1026 
1027     // Format the last item in the pattern, if any
1028     if (count &gt; 0) {
1029         subFormat(appendTo, prevCh, count, capitalizationContext, fieldNum++, handler, *workCal, status);
1030     }
1031 
1032     if (calClone != NULL) {
1033         delete calClone;
1034     }
1035 
1036     return appendTo;
1037 }
1038 
1039 //----------------------------------------------------------------------
1040 
1041 /* Map calendar field into calendar field level.
1042  * the larger the level, the smaller the field unit.
1043  * For example, UCAL_ERA level is 0, UCAL_YEAR level is 10,
1044  * UCAL_MONTH level is 20.
1045  * NOTE: if new fields adds in, the table needs to update.
1046  */
1047 const int32_t
1048 SimpleDateFormat::fgCalendarFieldToLevel[] =
1049 {
1050     /*GyM*/ 0, 10, 20,
1051     /*wW*/ 20, 30,
1052     /*dDEF*/ 30, 20, 30, 30,
1053     /*ahHm*/ 40, 50, 50, 60,
1054     /*sS*/ 70, 80,
1055     /*z?Y*/ 0, 0, 10,
1056     /*eug*/ 30, 10, 0,
1057     /*A?.*/ 40, 0, 0
1058 };
1059 
1060 int32_t SimpleDateFormat::getLevelFromChar(UChar ch) {
1061     // Map date field LETTER into calendar field level.
1062     // the larger the level, the smaller the field unit.
1063     // NOTE: if new fields adds in, the table needs to update.
1064     static const int32_t mapCharToLevel[] = {
1065             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1066         //
1067             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1068         //       !   &quot;   #   $   %   &amp;   &#39;   (   )   *   +   ,   -   .   /
1069             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1070 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
1071         //   0   1   2   3   4   5   6   7   8   9   :   ;   &lt;   =   &gt;   ?
1072             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0, -1, -1, -1, -1, -1,
1073 #else
1074         //   0   1   2   3   4   5   6   7   8   9   :   ;   &lt;   =   &gt;   ?
1075             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1076 #endif
1077         //   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
1078             -1, 40, -1, -1, 20, 30, 30,  0, 50, -1, -1, 50, 20, 20, -1,  0,
1079         //   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
1080             -1, 20, -1, 80, -1, 10,  0, 30,  0, 10,  0, -1, -1, -1, -1, -1,
1081         //   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
1082             -1, 40, -1, 30, 30, 30, -1,  0, 50, -1, -1, 50,  0, 60, -1, -1,
1083         //   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
1084             -1, 20, 10, 70, -1, 10,  0, 20,  0, 10,  0, -1, -1, -1, -1, -1
1085     };
1086 
1087     return ch &lt; UPRV_LENGTHOF(mapCharToLevel) ? mapCharToLevel[ch] : -1;
1088 }
1089 
1090 UBool SimpleDateFormat::isSyntaxChar(UChar ch) {
1091     static const UBool mapCharToIsSyntax[] = {
1092         //
1093         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1094         //
1095         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1096         //
1097         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1098         //
1099         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1100         //         !      &quot;      #      $      %      &amp;      &#39;
1101         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1102         //  (      )      *      +      ,      -      .      /
1103         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1104         //  0      1      2      3      4      5      6      7
1105         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1106 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
1107         //  8      9      :      ;      &lt;      =      &gt;      ?
1108         FALSE, FALSE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,
1109 #else
1110         //  8      9      :      ;      &lt;      =      &gt;      ?
1111         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
1112 #endif
1113         //  @      A      B      C      D      E      F      G
1114         FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1115         //  H      I      J      K      L      M      N      O
1116          TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1117         //  P      Q      R      S      T      U      V      W
1118          TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1119         //  X      Y      Z      [      \      ]      ^      _
1120          TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE,
1121         //  `      a      b      c      d      e      f      g
1122         FALSE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1123         //  h      i      j      k      l      m      n      o
1124          TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1125         //  p      q      r      s      t      u      v      w
1126          TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
1127         //  x      y      z      {      |      }      ~
1128          TRUE,  TRUE,  TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
1129     };
1130 
1131     return ch &lt; UPRV_LENGTHOF(mapCharToIsSyntax) ? mapCharToIsSyntax[ch] : FALSE;
1132 }
1133 
1134 // Map index into pattern character string to Calendar field number.
1135 const UCalendarDateFields
1136 SimpleDateFormat::fgPatternIndexToCalendarField[] =
1137 {
1138     /*GyM*/ UCAL_ERA, UCAL_YEAR, UCAL_MONTH,
1139     /*dkH*/ UCAL_DATE, UCAL_HOUR_OF_DAY, UCAL_HOUR_OF_DAY,
1140     /*msS*/ UCAL_MINUTE, UCAL_SECOND, UCAL_MILLISECOND,
1141     /*EDF*/ UCAL_DAY_OF_WEEK, UCAL_DAY_OF_YEAR, UCAL_DAY_OF_WEEK_IN_MONTH,
1142     /*wWa*/ UCAL_WEEK_OF_YEAR, UCAL_WEEK_OF_MONTH, UCAL_AM_PM,
1143     /*hKz*/ UCAL_HOUR, UCAL_HOUR, UCAL_ZONE_OFFSET,
1144     /*Yeu*/ UCAL_YEAR_WOY, UCAL_DOW_LOCAL, UCAL_EXTENDED_YEAR,
1145     /*gAZ*/ UCAL_JULIAN_DAY, UCAL_MILLISECONDS_IN_DAY, UCAL_ZONE_OFFSET,
1146     /*v*/   UCAL_ZONE_OFFSET,
1147     /*c*/   UCAL_DOW_LOCAL,
1148     /*L*/   UCAL_MONTH,
1149     /*Q*/   UCAL_MONTH,
1150     /*q*/   UCAL_MONTH,
1151     /*V*/   UCAL_ZONE_OFFSET,
1152     /*U*/   UCAL_YEAR,
1153     /*O*/   UCAL_ZONE_OFFSET,
1154     /*Xx*/  UCAL_ZONE_OFFSET, UCAL_ZONE_OFFSET,
1155     /*r*/   UCAL_EXTENDED_YEAR,
1156     /*bB*/   UCAL_FIELD_COUNT, UCAL_FIELD_COUNT,  // no mappings to calendar fields
1157 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
1158     /*:*/   UCAL_FIELD_COUNT, /* =&gt; no useful mapping to any calendar field */
1159 #else
1160     /*no pattern char for UDAT_TIME_SEPARATOR_FIELD*/   UCAL_FIELD_COUNT, /* =&gt; no useful mapping to any calendar field */
1161 #endif
1162 };
1163 
1164 // Map index into pattern character string to DateFormat field number
1165 const UDateFormatField
1166 SimpleDateFormat::fgPatternIndexToDateFormatField[] = {
1167     /*GyM*/ UDAT_ERA_FIELD, UDAT_YEAR_FIELD, UDAT_MONTH_FIELD,
1168     /*dkH*/ UDAT_DATE_FIELD, UDAT_HOUR_OF_DAY1_FIELD, UDAT_HOUR_OF_DAY0_FIELD,
1169     /*msS*/ UDAT_MINUTE_FIELD, UDAT_SECOND_FIELD, UDAT_FRACTIONAL_SECOND_FIELD,
1170     /*EDF*/ UDAT_DAY_OF_WEEK_FIELD, UDAT_DAY_OF_YEAR_FIELD, UDAT_DAY_OF_WEEK_IN_MONTH_FIELD,
1171     /*wWa*/ UDAT_WEEK_OF_YEAR_FIELD, UDAT_WEEK_OF_MONTH_FIELD, UDAT_AM_PM_FIELD,
1172     /*hKz*/ UDAT_HOUR1_FIELD, UDAT_HOUR0_FIELD, UDAT_TIMEZONE_FIELD,
1173     /*Yeu*/ UDAT_YEAR_WOY_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_EXTENDED_YEAR_FIELD,
1174     /*gAZ*/ UDAT_JULIAN_DAY_FIELD, UDAT_MILLISECONDS_IN_DAY_FIELD, UDAT_TIMEZONE_RFC_FIELD,
1175     /*v*/   UDAT_TIMEZONE_GENERIC_FIELD,
1176     /*c*/   UDAT_STANDALONE_DAY_FIELD,
1177     /*L*/   UDAT_STANDALONE_MONTH_FIELD,
1178     /*Q*/   UDAT_QUARTER_FIELD,
1179     /*q*/   UDAT_STANDALONE_QUARTER_FIELD,
1180     /*V*/   UDAT_TIMEZONE_SPECIAL_FIELD,
1181     /*U*/   UDAT_YEAR_NAME_FIELD,
1182     /*O*/   UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD,
1183     /*Xx*/  UDAT_TIMEZONE_ISO_FIELD, UDAT_TIMEZONE_ISO_LOCAL_FIELD,
1184     /*r*/   UDAT_RELATED_YEAR_FIELD,
1185     /*bB*/  UDAT_AM_PM_MIDNIGHT_NOON_FIELD, UDAT_FLEXIBLE_DAY_PERIOD_FIELD,
1186 #if UDAT_HAS_PATTERN_CHAR_FOR_TIME_SEPARATOR
1187     /*:*/   UDAT_TIME_SEPARATOR_FIELD,
1188 #else
1189     /*no pattern char for UDAT_TIME_SEPARATOR_FIELD*/   UDAT_TIME_SEPARATOR_FIELD,
1190 #endif
1191 };
1192 
1193 //----------------------------------------------------------------------
1194 
1195 /**
1196  * Append symbols[value] to dst.  Make sure the array index is not out
1197  * of bounds.
1198  */
1199 static inline void
1200 _appendSymbol(UnicodeString&amp; dst,
1201               int32_t value,
1202               const UnicodeString* symbols,
1203               int32_t symbolsCount) {
1204     U_ASSERT(0 &lt;= value &amp;&amp; value &lt; symbolsCount);
1205     if (0 &lt;= value &amp;&amp; value &lt; symbolsCount) {
1206         dst += symbols[value];
1207     }
1208 }
1209 
1210 static inline void
1211 _appendSymbolWithMonthPattern(UnicodeString&amp; dst, int32_t value, const UnicodeString* symbols, int32_t symbolsCount,
1212               const UnicodeString* monthPattern, UErrorCode&amp; status) {
1213     U_ASSERT(0 &lt;= value &amp;&amp; value &lt; symbolsCount);
1214     if (0 &lt;= value &amp;&amp; value &lt; symbolsCount) {
1215         if (monthPattern == NULL) {
1216             dst += symbols[value];
1217         } else {
1218             SimpleFormatter(*monthPattern, 1, 1, status).format(symbols[value], dst, status);
1219         }
1220     }
1221 }
1222 
1223 //----------------------------------------------------------------------
1224 
1225 static number::LocalizedNumberFormatter*
1226 createFastFormatter(const DecimalFormat* df, int32_t minInt, int32_t maxInt) {
1227     return new number::LocalizedNumberFormatter(
1228             df-&gt;toNumberFormatter()
1229                     .integerWidth(number::IntegerWidth::zeroFillTo(minInt).truncateAt(maxInt)));
1230 }
1231 
1232 void SimpleDateFormat::initFastNumberFormatters(UErrorCode&amp; status) {
1233     if (U_FAILURE(status)) {
1234         return;
1235     }
1236     auto* df = dynamic_cast&lt;const DecimalFormat*&gt;(fNumberFormat);
1237     if (df == nullptr) {
1238         return;
1239     }
1240     fFastNumberFormatters[SMPDTFMT_NF_1x10] = createFastFormatter(df, 1, 10);
1241     fFastNumberFormatters[SMPDTFMT_NF_2x10] = createFastFormatter(df, 2, 10);
1242     fFastNumberFormatters[SMPDTFMT_NF_3x10] = createFastFormatter(df, 3, 10);
1243     fFastNumberFormatters[SMPDTFMT_NF_4x10] = createFastFormatter(df, 4, 10);
1244     fFastNumberFormatters[SMPDTFMT_NF_2x2] = createFastFormatter(df, 2, 2);
1245 }
1246 
1247 void SimpleDateFormat::freeFastNumberFormatters() {
1248     delete fFastNumberFormatters[SMPDTFMT_NF_1x10];
1249     delete fFastNumberFormatters[SMPDTFMT_NF_2x10];
1250     delete fFastNumberFormatters[SMPDTFMT_NF_3x10];
1251     delete fFastNumberFormatters[SMPDTFMT_NF_4x10];
1252     delete fFastNumberFormatters[SMPDTFMT_NF_2x2];
1253     fFastNumberFormatters[SMPDTFMT_NF_1x10] = nullptr;
1254     fFastNumberFormatters[SMPDTFMT_NF_2x10] = nullptr;
1255     fFastNumberFormatters[SMPDTFMT_NF_3x10] = nullptr;
1256     fFastNumberFormatters[SMPDTFMT_NF_4x10] = nullptr;
1257     fFastNumberFormatters[SMPDTFMT_NF_2x2] = nullptr;
1258 }
1259 
1260 
1261 void
1262 SimpleDateFormat::initNumberFormatters(const Locale &amp;locale,UErrorCode &amp;status) {
1263     if (U_FAILURE(status)) {
1264         return;
1265     }
1266     if ( fDateOverride.isBogus() &amp;&amp; fTimeOverride.isBogus() ) {
1267         return;
1268     }
1269     umtx_lock(LOCK());
1270     if (fSharedNumberFormatters == NULL) {
1271         fSharedNumberFormatters = allocSharedNumberFormatters();
1272         if (fSharedNumberFormatters == NULL) {
1273             status = U_MEMORY_ALLOCATION_ERROR;
1274         }
1275     }
1276     umtx_unlock(LOCK());
1277 
1278     if (U_FAILURE(status)) {
1279         return;
1280     }
1281 
1282     processOverrideString(locale,fDateOverride,kOvrStrDate,status);
1283     processOverrideString(locale,fTimeOverride,kOvrStrTime,status);
1284 }
1285 
1286 void
1287 SimpleDateFormat::processOverrideString(const Locale &amp;locale, const UnicodeString &amp;str, int8_t type, UErrorCode &amp;status) {
1288     if (str.isBogus() || U_FAILURE(status)) {
1289         return;
1290     }
1291 
1292     int32_t start = 0;
1293     int32_t len;
1294     UnicodeString nsName;
1295     UnicodeString ovrField;
1296     UBool moreToProcess = TRUE;
1297     NSOverride *overrideList = NULL;
1298 
1299     while (moreToProcess) {
1300         int32_t delimiterPosition = str.indexOf((UChar)ULOC_KEYWORD_ITEM_SEPARATOR_UNICODE,start);
1301         if (delimiterPosition == -1) {
1302             moreToProcess = FALSE;
1303             len = str.length() - start;
1304         } else {
1305             len = delimiterPosition - start;
1306         }
1307         UnicodeString currentString(str,start,len);
1308         int32_t equalSignPosition = currentString.indexOf((UChar)ULOC_KEYWORD_ASSIGN_UNICODE,0);
1309         if (equalSignPosition == -1) { // Simple override string such as &quot;hebrew&quot;
1310             nsName.setTo(currentString);
1311             ovrField.setToBogus();
1312         } else { // Field specific override string such as &quot;y=hebrew&quot;
1313             nsName.setTo(currentString,equalSignPosition+1);
1314             ovrField.setTo(currentString,0,1); // We just need the first character.
1315         }
1316 
1317         int32_t nsNameHash = nsName.hashCode();
1318         // See if the numbering system is in the override list, if not, then add it.
1319         NSOverride *curr = overrideList;
1320         const SharedNumberFormat *snf = NULL;
1321         UBool found = FALSE;
1322         while ( curr &amp;&amp; !found ) {
1323             if ( curr-&gt;hash == nsNameHash ) {
1324                 snf = curr-&gt;snf;
1325                 found = TRUE;
1326             }
1327             curr = curr-&gt;next;
1328         }
1329 
1330         if (!found) {
1331            LocalPointer&lt;NSOverride&gt; cur(new NSOverride);
1332            if (!cur.isNull()) {
1333                char kw[ULOC_KEYWORD_AND_VALUES_CAPACITY];
1334                uprv_strcpy(kw,&quot;numbers=&quot;);
1335                nsName.extract(0,len,kw+8,ULOC_KEYWORD_AND_VALUES_CAPACITY-8,US_INV);
1336 
1337                Locale ovrLoc(locale.getLanguage(),locale.getCountry(),locale.getVariant(),kw);
1338                cur-&gt;hash = nsNameHash;
1339                cur-&gt;next = overrideList;
1340                SharedObject::copyPtr(
1341                        createSharedNumberFormat(ovrLoc, status), cur-&gt;snf);
1342                if (U_FAILURE(status)) {
1343                    if (overrideList) {
1344                        overrideList-&gt;free();
1345                    }
1346                    return;
1347                }
1348                snf = cur-&gt;snf;
1349                overrideList = cur.orphan();
1350            } else {
1351                status = U_MEMORY_ALLOCATION_ERROR;
1352                if (overrideList) {
1353                    overrideList-&gt;free();
1354                }
1355                return;
1356            }
1357         }
1358 
1359         // Now that we have an appropriate number formatter, fill in the appropriate spaces in the
1360         // number formatters table.
1361         if (ovrField.isBogus()) {
1362             switch (type) {
1363                 case kOvrStrDate:
1364                 case kOvrStrBoth: {
1365                     for ( int8_t i=0 ; i&lt;kDateFieldsCount; i++ ) {
1366                         SharedObject::copyPtr(snf, fSharedNumberFormatters[kDateFields[i]]);
1367                     }
1368                     if (type==kOvrStrDate) {
1369                         break;
1370                     }
1371                     U_FALLTHROUGH;
1372                 }
1373                 case kOvrStrTime : {
1374                     for ( int8_t i=0 ; i&lt;kTimeFieldsCount; i++ ) {
1375                         SharedObject::copyPtr(snf, fSharedNumberFormatters[kTimeFields[i]]);
1376                     }
1377                     break;
1378                 }
1379             }
1380         } else {
1381            // if the pattern character is unrecognized, signal an error and bail out
1382            UDateFormatField patternCharIndex =
1383               DateFormatSymbols::getPatternCharIndex(ovrField.charAt(0));
1384            if (patternCharIndex == UDAT_FIELD_COUNT) {
1385                status = U_INVALID_FORMAT_ERROR;
1386                if (overrideList) {
1387                    overrideList-&gt;free();
1388                }
1389                return;
1390            }
1391            SharedObject::copyPtr(snf, fSharedNumberFormatters[patternCharIndex]);
1392         }
1393 
1394         start = delimiterPosition + 1;
1395     }
1396     if (overrideList) {
1397         overrideList-&gt;free();
1398     }
1399 }
1400 
1401 //---------------------------------------------------------------------
1402 void
1403 SimpleDateFormat::subFormat(UnicodeString &amp;appendTo,
1404                             UChar ch,
1405                             int32_t count,
1406                             UDisplayContext capitalizationContext,
1407                             int32_t fieldNum,
1408                             FieldPositionHandler&amp; handler,
1409                             Calendar&amp; cal,
1410                             UErrorCode&amp; status) const
1411 {
1412     if (U_FAILURE(status)) {
1413         return;
1414     }
1415 
1416     // this function gets called by format() to produce the appropriate substitution
1417     // text for an individual pattern symbol (e.g., &quot;HH&quot; or &quot;yyyy&quot;)
1418 
1419     UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(ch);
1420     const int32_t maxIntCount = 10;
1421     int32_t beginOffset = appendTo.length();
1422     const NumberFormat *currentNumberFormat;
1423     DateFormatSymbols::ECapitalizationContextUsageType capContextUsageType = DateFormatSymbols::kCapContextUsageOther;
1424 
1425     UBool isHebrewCalendar = (uprv_strcmp(cal.getType(),&quot;hebrew&quot;) == 0);
1426     UBool isChineseCalendar = (uprv_strcmp(cal.getType(),&quot;chinese&quot;) == 0 || uprv_strcmp(cal.getType(),&quot;dangi&quot;) == 0);
1427 
1428     // if the pattern character is unrecognized, signal an error and dump out
1429     if (patternCharIndex == UDAT_FIELD_COUNT)
1430     {
1431         if (ch != 0x6C) { // pattern char &#39;l&#39; (SMALL LETTER L) just gets ignored
1432             status = U_INVALID_FORMAT_ERROR;
1433         }
1434         return;
1435     }
1436 
1437     UCalendarDateFields field = fgPatternIndexToCalendarField[patternCharIndex];
1438     int32_t value = 0;
1439     // Don&#39;t get value unless it is useful
1440     if (field &lt; UCAL_FIELD_COUNT) {
1441         value = (patternCharIndex != UDAT_RELATED_YEAR_FIELD)? cal.get(field, status): cal.getRelatedYear(status);
1442     }
1443     if (U_FAILURE(status)) {
1444         return;
1445     }
1446 
1447     currentNumberFormat = getNumberFormatByIndex(patternCharIndex);
1448     if (currentNumberFormat == NULL) {
1449         status = U_INTERNAL_PROGRAM_ERROR;
1450         return;
1451     }
1452     UnicodeString hebr(&quot;hebr&quot;, 4, US_INV);
1453 
1454     switch (patternCharIndex) {
1455 
1456     // for any &quot;G&quot; symbol, write out the appropriate era string
1457     // &quot;GGGG&quot; is wide era name, &quot;GGGGG&quot; is narrow era name, anything else is abbreviated name
1458     case UDAT_ERA_FIELD:
1459         if (isChineseCalendar) {
1460             zeroPaddingNumber(currentNumberFormat,appendTo, value, 1, 9); // as in ICU4J
1461         } else {
1462             if (count == 5) {
1463                 _appendSymbol(appendTo, value, fSymbols-&gt;fNarrowEras, fSymbols-&gt;fNarrowErasCount);
1464                 capContextUsageType = DateFormatSymbols::kCapContextUsageEraNarrow;
1465             } else if (count == 4) {
1466                 _appendSymbol(appendTo, value, fSymbols-&gt;fEraNames, fSymbols-&gt;fEraNamesCount);
1467                 capContextUsageType = DateFormatSymbols::kCapContextUsageEraWide;
1468             } else {
1469                 _appendSymbol(appendTo, value, fSymbols-&gt;fEras, fSymbols-&gt;fErasCount);
1470                 capContextUsageType = DateFormatSymbols::kCapContextUsageEraAbbrev;
1471             }
1472         }
1473         break;
1474 
1475      case UDAT_YEAR_NAME_FIELD:
1476         if (fSymbols-&gt;fShortYearNames != NULL &amp;&amp; value &lt;= fSymbols-&gt;fShortYearNamesCount) {
1477             // the Calendar YEAR field runs 1 through 60 for cyclic years
1478             _appendSymbol(appendTo, value - 1, fSymbols-&gt;fShortYearNames, fSymbols-&gt;fShortYearNamesCount);
1479             break;
1480         }
1481         // else fall through to numeric year handling, do not break here
1482         U_FALLTHROUGH;
1483 
1484    // OLD: for &quot;yyyy&quot;, write out the whole year; for &quot;yy&quot;, write out the last 2 digits
1485     // NEW: UTS#35:
1486 //Year         y     yy     yyy     yyyy     yyyyy
1487 //AD 1         1     01     001     0001     00001
1488 //AD 12       12     12     012     0012     00012
1489 //AD 123     123     23     123     0123     00123
1490 //AD 1234   1234     34    1234     1234     01234
1491 //AD 12345 12345     45   12345    12345     12345
1492     case UDAT_YEAR_FIELD:
1493     case UDAT_YEAR_WOY_FIELD:
1494         if (fDateOverride.compare(hebr)==0 &amp;&amp; value&gt;HEBREW_CAL_CUR_MILLENIUM_START_YEAR &amp;&amp; value&lt;HEBREW_CAL_CUR_MILLENIUM_END_YEAR) {
1495             value-=HEBREW_CAL_CUR_MILLENIUM_START_YEAR;
1496         }
1497         if(count == 2)
1498             zeroPaddingNumber(currentNumberFormat, appendTo, value, 2, 2);
1499         else
1500             zeroPaddingNumber(currentNumberFormat, appendTo, value, count, maxIntCount);
1501         break;
1502 
1503     // for &quot;MMMM&quot;/&quot;LLLL&quot;, write out the whole month name, for &quot;MMM&quot;/&quot;LLL&quot;, write out the month
1504     // abbreviation, for &quot;M&quot;/&quot;L&quot; or &quot;MM&quot;/&quot;LL&quot;, write out the month as a number with the
1505     // appropriate number of digits
1506     // for &quot;MMMMM&quot;/&quot;LLLLL&quot;, use the narrow form
1507     case UDAT_MONTH_FIELD:
1508     case UDAT_STANDALONE_MONTH_FIELD:
1509         if ( isHebrewCalendar ) {
1510            HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
1511            if (hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR,status)) &amp;&amp; value == 6 &amp;&amp; count &gt;= 3 )
1512                value = 13; // Show alternate form for Adar II in leap years in Hebrew calendar.
1513            if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR,status)) &amp;&amp; value &gt;= 6 &amp;&amp; count &lt; 3 )
1514                value--; // Adjust the month number down 1 in Hebrew non-leap years, i.e. Adar is 6, not 7.
1515         }
1516         {
1517             int32_t isLeapMonth = (fSymbols-&gt;fLeapMonthPatterns != NULL &amp;&amp; fSymbols-&gt;fLeapMonthPatternsCount &gt;= DateFormatSymbols::kMonthPatternsCount)?
1518                         cal.get(UCAL_IS_LEAP_MONTH, status): 0;
1519             // should consolidate the next section by using arrays of pointers &amp; counts for the right symbols...
1520             if (count == 5) {
1521                 if (patternCharIndex == UDAT_MONTH_FIELD) {
1522                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fNarrowMonths, fSymbols-&gt;fNarrowMonthsCount,
1523                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternFormatNarrow]): NULL, status);
1524                 } else {
1525                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fStandaloneNarrowMonths, fSymbols-&gt;fStandaloneNarrowMonthsCount,
1526                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternStandaloneNarrow]): NULL, status);
1527                 }
1528                 capContextUsageType = DateFormatSymbols::kCapContextUsageMonthNarrow;
1529             } else if (count == 4) {
1530                 if (patternCharIndex == UDAT_MONTH_FIELD) {
1531                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fMonths, fSymbols-&gt;fMonthsCount,
1532                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternFormatWide]): NULL, status);
1533                     capContextUsageType = DateFormatSymbols::kCapContextUsageMonthFormat;
1534                 } else {
1535                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fStandaloneMonths, fSymbols-&gt;fStandaloneMonthsCount,
1536                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternStandaloneWide]): NULL, status);
1537                     capContextUsageType = DateFormatSymbols::kCapContextUsageMonthStandalone;
1538                 }
1539             } else if (count == 3) {
1540                 if (patternCharIndex == UDAT_MONTH_FIELD) {
1541                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fShortMonths, fSymbols-&gt;fShortMonthsCount,
1542                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternFormatAbbrev]): NULL, status);
1543                     capContextUsageType = DateFormatSymbols::kCapContextUsageMonthFormat;
1544                 } else {
1545                     _appendSymbolWithMonthPattern(appendTo, value, fSymbols-&gt;fStandaloneShortMonths, fSymbols-&gt;fStandaloneShortMonthsCount,
1546                             (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternStandaloneAbbrev]): NULL, status);
1547                     capContextUsageType = DateFormatSymbols::kCapContextUsageMonthStandalone;
1548                 }
1549             } else {
1550                 UnicodeString monthNumber;
1551                 zeroPaddingNumber(currentNumberFormat,monthNumber, value + 1, count, maxIntCount);
1552                 _appendSymbolWithMonthPattern(appendTo, 0, &amp;monthNumber, 1,
1553                         (isLeapMonth!=0)? &amp;(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternNumeric]): NULL, status);
1554             }
1555         }
1556         break;
1557 
1558     // for &quot;k&quot; and &quot;kk&quot;, write out the hour, adjusting midnight to appear as &quot;24&quot;
1559     case UDAT_HOUR_OF_DAY1_FIELD:
1560         if (value == 0)
1561             zeroPaddingNumber(currentNumberFormat,appendTo, cal.getMaximum(UCAL_HOUR_OF_DAY) + 1, count, maxIntCount);
1562         else
1563             zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1564         break;
1565 
1566     case UDAT_FRACTIONAL_SECOND_FIELD:
1567         // Fractional seconds left-justify
1568         {
1569             int32_t minDigits = (count &gt; 3) ? 3 : count;
1570             if (count == 1) {
1571                 value /= 100;
1572             } else if (count == 2) {
1573                 value /= 10;
1574             }
1575             zeroPaddingNumber(currentNumberFormat, appendTo, value, minDigits, maxIntCount);
1576             if (count &gt; 3) {
1577                 zeroPaddingNumber(currentNumberFormat, appendTo, 0, count - 3, maxIntCount);
1578             }
1579         }
1580         break;
1581 
1582     // for &quot;ee&quot; or &quot;e&quot;, use local numeric day-of-the-week
1583     // for &quot;EEEEEE&quot; or &quot;eeeeee&quot;, write out the short day-of-the-week name
1584     // for &quot;EEEEE&quot; or &quot;eeeee&quot;, write out the narrow day-of-the-week name
1585     // for &quot;EEEE&quot; or &quot;eeee&quot;, write out the wide day-of-the-week name
1586     // for &quot;EEE&quot; or &quot;EE&quot; or &quot;E&quot; or &quot;eee&quot;, write out the abbreviated day-of-the-week name
1587     case UDAT_DOW_LOCAL_FIELD:
1588         if ( count &lt; 3 ) {
1589             zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1590             break;
1591         }
1592         // fall through to EEEEE-EEE handling, but for that we don&#39;t want local day-of-week,
1593         // we want standard day-of-week, so first fix value to work for EEEEE-EEE.
1594         value = cal.get(UCAL_DAY_OF_WEEK, status);
1595         if (U_FAILURE(status)) {
1596             return;
1597         }
1598         // fall through, do not break here
1599         U_FALLTHROUGH;
1600     case UDAT_DAY_OF_WEEK_FIELD:
1601         if (count == 5) {
1602             _appendSymbol(appendTo, value, fSymbols-&gt;fNarrowWeekdays,
1603                           fSymbols-&gt;fNarrowWeekdaysCount);
1604             capContextUsageType = DateFormatSymbols::kCapContextUsageDayNarrow;
1605         } else if (count == 4) {
1606             _appendSymbol(appendTo, value, fSymbols-&gt;fWeekdays,
1607                           fSymbols-&gt;fWeekdaysCount);
1608             capContextUsageType = DateFormatSymbols::kCapContextUsageDayFormat;
1609         } else if (count == 6) {
1610             _appendSymbol(appendTo, value, fSymbols-&gt;fShorterWeekdays,
1611                           fSymbols-&gt;fShorterWeekdaysCount);
1612             capContextUsageType = DateFormatSymbols::kCapContextUsageDayFormat;
1613         } else {
1614             _appendSymbol(appendTo, value, fSymbols-&gt;fShortWeekdays,
1615                           fSymbols-&gt;fShortWeekdaysCount);
1616             capContextUsageType = DateFormatSymbols::kCapContextUsageDayFormat;
1617         }
1618         break;
1619 
1620     // for &quot;ccc&quot;, write out the abbreviated day-of-the-week name
1621     // for &quot;cccc&quot;, write out the wide day-of-the-week name
1622     // for &quot;ccccc&quot;, use the narrow day-of-the-week name
1623     // for &quot;ccccc&quot;, use the short day-of-the-week name
1624     case UDAT_STANDALONE_DAY_FIELD:
1625         if ( count &lt; 3 ) {
1626             zeroPaddingNumber(currentNumberFormat,appendTo, value, 1, maxIntCount);
1627             break;
1628         }
1629         // fall through to alpha DOW handling, but for that we don&#39;t want local day-of-week,
1630         // we want standard day-of-week, so first fix value.
1631         value = cal.get(UCAL_DAY_OF_WEEK, status);
1632         if (U_FAILURE(status)) {
1633             return;
1634         }
1635         if (count == 5) {
1636             _appendSymbol(appendTo, value, fSymbols-&gt;fStandaloneNarrowWeekdays,
1637                           fSymbols-&gt;fStandaloneNarrowWeekdaysCount);
1638             capContextUsageType = DateFormatSymbols::kCapContextUsageDayNarrow;
1639         } else if (count == 4) {
1640             _appendSymbol(appendTo, value, fSymbols-&gt;fStandaloneWeekdays,
1641                           fSymbols-&gt;fStandaloneWeekdaysCount);
1642             capContextUsageType = DateFormatSymbols::kCapContextUsageDayStandalone;
1643         } else if (count == 6) {
1644             _appendSymbol(appendTo, value, fSymbols-&gt;fStandaloneShorterWeekdays,
1645                           fSymbols-&gt;fStandaloneShorterWeekdaysCount);
1646             capContextUsageType = DateFormatSymbols::kCapContextUsageDayStandalone;
1647         } else { // count == 3
1648             _appendSymbol(appendTo, value, fSymbols-&gt;fStandaloneShortWeekdays,
1649                           fSymbols-&gt;fStandaloneShortWeekdaysCount);
1650             capContextUsageType = DateFormatSymbols::kCapContextUsageDayStandalone;
1651         }
1652         break;
1653 
1654     // for &quot;a&quot; symbol, write out the whole AM/PM string
1655     case UDAT_AM_PM_FIELD:
1656         if (count &lt; 5) {
1657             _appendSymbol(appendTo, value, fSymbols-&gt;fAmPms,
1658                           fSymbols-&gt;fAmPmsCount);
1659         } else {
1660             _appendSymbol(appendTo, value, fSymbols-&gt;fNarrowAmPms,
1661                           fSymbols-&gt;fNarrowAmPmsCount);
1662         }
1663         break;
1664 
1665     // if we see pattern character for UDAT_TIME_SEPARATOR_FIELD (none currently defined),
1666     // write out the time separator string. Leave support in for future definition.
1667     case UDAT_TIME_SEPARATOR_FIELD:
1668         {
1669             UnicodeString separator;
1670             appendTo += fSymbols-&gt;getTimeSeparatorString(separator);
1671         }
1672         break;
1673 
1674     // for &quot;h&quot; and &quot;hh&quot;, write out the hour, adjusting noon and midnight to show up
1675     // as &quot;12&quot;
1676     case UDAT_HOUR1_FIELD:
1677         if (value == 0)
1678             zeroPaddingNumber(currentNumberFormat,appendTo, cal.getLeastMaximum(UCAL_HOUR) + 1, count, maxIntCount);
1679         else
1680             zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1681         break;
1682 
1683     case UDAT_TIMEZONE_FIELD: // &#39;z&#39;
1684     case UDAT_TIMEZONE_RFC_FIELD: // &#39;Z&#39;
1685     case UDAT_TIMEZONE_GENERIC_FIELD: // &#39;v&#39;
1686     case UDAT_TIMEZONE_SPECIAL_FIELD: // &#39;V&#39;
1687     case UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD: // &#39;O&#39;
1688     case UDAT_TIMEZONE_ISO_FIELD: // &#39;X&#39;
1689     case UDAT_TIMEZONE_ISO_LOCAL_FIELD: // &#39;x&#39;
1690         {
1691             UChar zsbuf[ZONE_NAME_U16_MAX];
1692             UnicodeString zoneString(zsbuf, 0, UPRV_LENGTHOF(zsbuf));
1693             const TimeZone&amp; tz = cal.getTimeZone();
1694             UDate date = cal.getTime(status);
1695             const TimeZoneFormat *tzfmt = tzFormat(status);
1696             if (U_SUCCESS(status)) {
1697                 if (patternCharIndex == UDAT_TIMEZONE_FIELD) {
1698                     if (count &lt; 4) {
1699                         // &quot;z&quot;, &quot;zz&quot;, &quot;zzz&quot;
1700                         tzfmt-&gt;format(UTZFMT_STYLE_SPECIFIC_SHORT, tz, date, zoneString);
1701                         capContextUsageType = DateFormatSymbols::kCapContextUsageMetazoneShort;
1702                     } else {
1703                         // &quot;zzzz&quot; or longer
1704                         tzfmt-&gt;format(UTZFMT_STYLE_SPECIFIC_LONG, tz, date, zoneString);
1705                         capContextUsageType = DateFormatSymbols::kCapContextUsageMetazoneLong;
1706                     }
1707                 }
1708                 else if (patternCharIndex == UDAT_TIMEZONE_RFC_FIELD) {
1709                     if (count &lt; 4) {
1710                         // &quot;Z&quot;
1711                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL, tz, date, zoneString);
1712                     } else if (count == 5) {
1713                         // &quot;ZZZZZ&quot;
1714                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_FULL, tz, date, zoneString);
1715                     } else {
1716                         // &quot;ZZ&quot;, &quot;ZZZ&quot;, &quot;ZZZZ&quot;
1717                         tzfmt-&gt;format(UTZFMT_STYLE_LOCALIZED_GMT, tz, date, zoneString);
1718                     }
1719                 }
1720                 else if (patternCharIndex == UDAT_TIMEZONE_GENERIC_FIELD) {
1721                     if (count == 1) {
1722                         // &quot;v&quot;
1723                         tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_SHORT, tz, date, zoneString);
1724                         capContextUsageType = DateFormatSymbols::kCapContextUsageMetazoneShort;
1725                     } else if (count == 4) {
1726                         // &quot;vvvv&quot;
1727                         tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LONG, tz, date, zoneString);
1728                         capContextUsageType = DateFormatSymbols::kCapContextUsageMetazoneLong;
1729                     }
1730                 }
1731                 else if (patternCharIndex == UDAT_TIMEZONE_SPECIAL_FIELD) {
1732                     if (count == 1) {
1733                         // &quot;V&quot;
1734                         tzfmt-&gt;format(UTZFMT_STYLE_ZONE_ID_SHORT, tz, date, zoneString);
1735                     } else if (count == 2) {
1736                         // &quot;VV&quot;
1737                         tzfmt-&gt;format(UTZFMT_STYLE_ZONE_ID, tz, date, zoneString);
1738                     } else if (count == 3) {
1739                         // &quot;VVV&quot;
1740                         tzfmt-&gt;format(UTZFMT_STYLE_EXEMPLAR_LOCATION, tz, date, zoneString);
1741                     } else if (count == 4) {
1742                         // &quot;VVVV&quot;
1743                         tzfmt-&gt;format(UTZFMT_STYLE_GENERIC_LOCATION, tz, date, zoneString);
1744                         capContextUsageType = DateFormatSymbols::kCapContextUsageZoneLong;
1745                     }
1746                 }
1747                 else if (patternCharIndex == UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD) {
1748                     if (count == 1) {
1749                         // &quot;O&quot;
1750                         tzfmt-&gt;format(UTZFMT_STYLE_LOCALIZED_GMT_SHORT, tz, date, zoneString);
1751                     } else if (count == 4) {
1752                         // &quot;OOOO&quot;
1753                         tzfmt-&gt;format(UTZFMT_STYLE_LOCALIZED_GMT, tz, date, zoneString);
1754                     }
1755                 }
1756                 else if (patternCharIndex == UDAT_TIMEZONE_ISO_FIELD) {
1757                     if (count == 1) {
1758                         // &quot;X&quot;
1759                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_SHORT, tz, date, zoneString);
1760                     } else if (count == 2) {
1761                         // &quot;XX&quot;
1762                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_FIXED, tz, date, zoneString);
1763                     } else if (count == 3) {
1764                         // &quot;XXX&quot;
1765                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_FIXED, tz, date, zoneString);
1766                     } else if (count == 4) {
1767                         // &quot;XXXX&quot;
1768                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_FULL, tz, date, zoneString);
1769                     } else if (count == 5) {
1770                         // &quot;XXXXX&quot;
1771                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_FULL, tz, date, zoneString);
1772                     }
1773                 }
1774                 else if (patternCharIndex == UDAT_TIMEZONE_ISO_LOCAL_FIELD) {
1775                     if (count == 1) {
1776                         // &quot;x&quot;
1777                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT, tz, date, zoneString);
1778                     } else if (count == 2) {
1779                         // &quot;xx&quot;
1780                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED, tz, date, zoneString);
1781                     } else if (count == 3) {
1782                         // &quot;xxx&quot;
1783                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED, tz, date, zoneString);
1784                     } else if (count == 4) {
1785                         // &quot;xxxx&quot;
1786                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL, tz, date, zoneString);
1787                     } else if (count == 5) {
1788                         // &quot;xxxxx&quot;
1789                         tzfmt-&gt;format(UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL, tz, date, zoneString);
1790                     }
1791                 }
1792                 else {
1793                     UPRV_UNREACHABLE;
1794                 }
1795             }
1796             appendTo += zoneString;
1797         }
1798         break;
1799 
1800     case UDAT_QUARTER_FIELD:
1801         if (count &gt;= 4)
1802             _appendSymbol(appendTo, value/3, fSymbols-&gt;fQuarters,
1803                           fSymbols-&gt;fQuartersCount);
1804         else if (count == 3)
1805             _appendSymbol(appendTo, value/3, fSymbols-&gt;fShortQuarters,
1806                           fSymbols-&gt;fShortQuartersCount);
1807         else
1808             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1809         break;
1810 
1811     case UDAT_STANDALONE_QUARTER_FIELD:
1812         if (count &gt;= 4)
1813             _appendSymbol(appendTo, value/3, fSymbols-&gt;fStandaloneQuarters,
1814                           fSymbols-&gt;fStandaloneQuartersCount);
1815         else if (count == 3)
1816             _appendSymbol(appendTo, value/3, fSymbols-&gt;fStandaloneShortQuarters,
1817                           fSymbols-&gt;fStandaloneShortQuartersCount);
1818         else
1819             zeroPaddingNumber(currentNumberFormat,appendTo, (value/3) + 1, count, maxIntCount);
1820         break;
1821 
1822     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
1823     {
1824         const UnicodeString *toAppend = NULL;
1825         int32_t hour = cal.get(UCAL_HOUR_OF_DAY, status);
1826 
1827         // Note: &quot;midnight&quot; can be ambiguous as to whether it refers to beginning of day or end of day.
1828         // For ICU 57 output of &quot;midnight&quot; is temporarily suppressed.
1829 
1830         // For &quot;midnight&quot; and &quot;noon&quot;:
1831         // Time, as displayed, must be exactly noon or midnight.
1832         // This means minutes and seconds, if present, must be zero.
1833         if ((/*hour == 0 ||*/ hour == 12) &amp;&amp;
1834                 (!fHasMinute || cal.get(UCAL_MINUTE, status) == 0) &amp;&amp;
1835                 (!fHasSecond || cal.get(UCAL_SECOND, status) == 0)) {
1836             // Stealing am/pm value to use as our array index.
1837             // It works out: am/midnight are both 0, pm/noon are both 1,
1838             // 12 am is 12 midnight, and 12 pm is 12 noon.
1839             int32_t val = cal.get(UCAL_AM_PM, status);
1840 
1841             if (count &lt;= 3) {
1842                 toAppend = &amp;fSymbols-&gt;fAbbreviatedDayPeriods[val];
1843             } else if (count == 4 || count &gt; 5) {
1844                 toAppend = &amp;fSymbols-&gt;fWideDayPeriods[val];
1845             } else { // count == 5
1846                 toAppend = &amp;fSymbols-&gt;fNarrowDayPeriods[val];
1847             }
1848         }
1849 
1850         // toAppend is NULL if time isn&#39;t exactly midnight or noon (as displayed).
1851         // toAppend is bogus if time is midnight or noon, but no localized string exists.
1852         // In either case, fall back to am/pm.
1853         if (toAppend == NULL || toAppend-&gt;isBogus()) {
1854             // Reformat with identical arguments except ch, now changed to &#39;a&#39;.
1855             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1856                       handler, cal, status);
1857         } else {
1858             appendTo += *toAppend;
1859         }
1860 
1861         break;
1862     }
1863 
1864     case UDAT_FLEXIBLE_DAY_PERIOD_FIELD:
1865     {
1866         // TODO: Maybe fetch the DayperiodRules during initialization (instead of at the first
1867         // loading of an instance) if a relevant pattern character (b or B) is used.
1868         const DayPeriodRules *ruleSet = DayPeriodRules::getInstance(this-&gt;getSmpFmtLocale(), status);
1869         if (U_FAILURE(status)) {
1870             // Data doesn&#39;t conform to spec, therefore loading failed.
1871             break;
1872         }
1873         if (ruleSet == NULL) {
1874             // Data doesn&#39;t exist for the locale we&#39;re looking for.
1875             // Falling back to am/pm.
1876             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1877                       handler, cal, status);
1878             break;
1879         }
1880 
1881         // Get current display time.
1882         int32_t hour = cal.get(UCAL_HOUR_OF_DAY, status);
1883         int32_t minute = 0;
1884         if (fHasMinute) {
1885             minute = cal.get(UCAL_MINUTE, status);
1886         }
1887         int32_t second = 0;
1888         if (fHasSecond) {
1889             second = cal.get(UCAL_SECOND, status);
1890         }
1891 
1892         // Determine day period.
1893         DayPeriodRules::DayPeriod periodType;
1894         if (hour == 0 &amp;&amp; minute == 0 &amp;&amp; second == 0 &amp;&amp; ruleSet-&gt;hasMidnight()) {
1895             periodType = DayPeriodRules::DAYPERIOD_MIDNIGHT;
1896         } else if (hour == 12 &amp;&amp; minute == 0 &amp;&amp; second == 0 &amp;&amp; ruleSet-&gt;hasNoon()) {
1897             periodType = DayPeriodRules::DAYPERIOD_NOON;
1898         } else {
1899             periodType = ruleSet-&gt;getDayPeriodForHour(hour);
1900         }
1901 
1902         // Rule set exists, therefore periodType can&#39;t be UNKNOWN.
1903         // Get localized string.
1904         U_ASSERT(periodType != DayPeriodRules::DAYPERIOD_UNKNOWN);
1905         UnicodeString *toAppend = NULL;
1906         int32_t index;
1907 
1908         // Note: &quot;midnight&quot; can be ambiguous as to whether it refers to beginning of day or end of day.
1909         // For ICU 57 output of &quot;midnight&quot; is temporarily suppressed.
1910 
1911         if (periodType != DayPeriodRules::DAYPERIOD_AM &amp;&amp;
1912                 periodType != DayPeriodRules::DAYPERIOD_PM &amp;&amp;
1913                 periodType != DayPeriodRules::DAYPERIOD_MIDNIGHT) {
1914             index = (int32_t)periodType;
1915             if (count &lt;= 3) {
1916                 toAppend = &amp;fSymbols-&gt;fAbbreviatedDayPeriods[index];  // i.e. short
1917             } else if (count == 4 || count &gt; 5) {
1918                 toAppend = &amp;fSymbols-&gt;fWideDayPeriods[index];
1919             } else {  // count == 5
1920                 toAppend = &amp;fSymbols-&gt;fNarrowDayPeriods[index];
1921             }
1922         }
1923 
1924         // Fallback schedule:
1925         // Midnight/Noon -&gt; General Periods -&gt; AM/PM.
1926 
1927         // Midnight/Noon -&gt; General Periods.
1928         if ((toAppend == NULL || toAppend-&gt;isBogus()) &amp;&amp;
1929                 (periodType == DayPeriodRules::DAYPERIOD_MIDNIGHT ||
1930                  periodType == DayPeriodRules::DAYPERIOD_NOON)) {
1931             periodType = ruleSet-&gt;getDayPeriodForHour(hour);
1932             index = (int32_t)periodType;
1933 
1934             if (count &lt;= 3) {
1935                 toAppend = &amp;fSymbols-&gt;fAbbreviatedDayPeriods[index];  // i.e. short
1936             } else if (count == 4 || count &gt; 5) {
1937                 toAppend = &amp;fSymbols-&gt;fWideDayPeriods[index];
1938             } else {  // count == 5
1939                 toAppend = &amp;fSymbols-&gt;fNarrowDayPeriods[index];
1940             }
1941         }
1942 
1943         // General Periods -&gt; AM/PM.
1944         if (periodType == DayPeriodRules::DAYPERIOD_AM ||
1945             periodType == DayPeriodRules::DAYPERIOD_PM ||
1946             toAppend-&gt;isBogus()) {
1947             subFormat(appendTo, 0x61, count, capitalizationContext, fieldNum,
1948                       handler, cal, status);
1949         }
1950         else {
1951             appendTo += *toAppend;
1952         }
1953 
1954         break;
1955     }
1956 
1957     // all of the other pattern symbols can be formatted as simple numbers with
1958     // appropriate zero padding
1959     default:
1960         zeroPaddingNumber(currentNumberFormat,appendTo, value, count, maxIntCount);
1961         break;
1962     }
1963 #if !UCONFIG_NO_BREAK_ITERATION
1964     // if first field, check to see whether we need to and are able to titlecase it
1965     if (fieldNum == 0 &amp;&amp; fCapitalizationBrkIter != NULL &amp;&amp; appendTo.length() &gt; beginOffset &amp;&amp;
1966             u_islower(appendTo.char32At(beginOffset))) {
1967         UBool titlecase = FALSE;
1968         switch (capitalizationContext) {
1969             case UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE:
1970                 titlecase = TRUE;
1971                 break;
1972             case UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU:
1973                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][0];
1974                 break;
1975             case UDISPCTX_CAPITALIZATION_FOR_STANDALONE:
1976                 titlecase = fSymbols-&gt;fCapitalization[capContextUsageType][1];
1977                 break;
1978             default:
1979                 // titlecase = FALSE;
1980                 break;
1981         }
1982         if (titlecase) {
1983             UnicodeString firstField(appendTo, beginOffset);
1984             firstField.toTitle(fCapitalizationBrkIter, fLocale, U_TITLECASE_NO_LOWERCASE | U_TITLECASE_NO_BREAK_ADJUSTMENT);
1985             appendTo.replaceBetween(beginOffset, appendTo.length(), firstField);
1986         }
1987     }
1988 #endif
1989 
1990     handler.addAttribute(fgPatternIndexToDateFormatField[patternCharIndex], beginOffset, appendTo.length());
1991 }
1992 
1993 //----------------------------------------------------------------------
1994 
1995 void SimpleDateFormat::adoptNumberFormat(NumberFormat *formatToAdopt) {
1996     fixNumberFormatForDates(*formatToAdopt);
1997     delete fNumberFormat;
1998     fNumberFormat = formatToAdopt;
1999 
2000     // We successfully set the default number format. Now delete the overrides
2001     // (can&#39;t fail).
2002     if (fSharedNumberFormatters) {
2003         freeSharedNumberFormatters(fSharedNumberFormatters);
2004         fSharedNumberFormatters = NULL;
2005     }
2006 
2007     // Also re-compute the fast formatters.
2008     UErrorCode localStatus = U_ZERO_ERROR;
2009     freeFastNumberFormatters();
2010     initFastNumberFormatters(localStatus);
2011 }
2012 
2013 void SimpleDateFormat::adoptNumberFormat(const UnicodeString&amp; fields, NumberFormat *formatToAdopt, UErrorCode &amp;status){
2014     fixNumberFormatForDates(*formatToAdopt);
2015     LocalPointer&lt;NumberFormat&gt; fmt(formatToAdopt);
2016     if (U_FAILURE(status)) {
2017         return;
2018     }
2019 
2020     // We must ensure fSharedNumberFormatters is allocated.
2021     if (fSharedNumberFormatters == NULL) {
2022         fSharedNumberFormatters = allocSharedNumberFormatters();
2023         if (fSharedNumberFormatters == NULL) {
2024             status = U_MEMORY_ALLOCATION_ERROR;
2025             return;
2026         }
2027     }
2028     const SharedNumberFormat *newFormat = createSharedNumberFormat(fmt.orphan());
2029     if (newFormat == NULL) {
2030         status = U_MEMORY_ALLOCATION_ERROR;
2031         return;
2032     }
2033     for (int i=0; i&lt;fields.length(); i++) {
2034         UChar field = fields.charAt(i);
2035         // if the pattern character is unrecognized, signal an error and bail out
2036         UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(field);
2037         if (patternCharIndex == UDAT_FIELD_COUNT) {
2038             status = U_INVALID_FORMAT_ERROR;
2039             newFormat-&gt;deleteIfZeroRefCount();
2040             return;
2041         }
2042 
2043         // Set the number formatter in the table
2044         SharedObject::copyPtr(
2045                 newFormat, fSharedNumberFormatters[patternCharIndex]);
2046     }
2047     newFormat-&gt;deleteIfZeroRefCount();
2048 }
2049 
2050 const NumberFormat *
2051 SimpleDateFormat::getNumberFormatForField(UChar field) const {
2052     UDateFormatField index = DateFormatSymbols::getPatternCharIndex(field);
2053     if (index == UDAT_FIELD_COUNT) {
2054         return NULL;
2055     }
2056     return getNumberFormatByIndex(index);
2057 }
2058 
2059 //----------------------------------------------------------------------
2060 void
2061 SimpleDateFormat::zeroPaddingNumber(
2062         const NumberFormat *currentNumberFormat,
2063         UnicodeString &amp;appendTo,
2064         int32_t value, int32_t minDigits, int32_t maxDigits) const
2065 {
2066     const number::LocalizedNumberFormatter* fastFormatter = nullptr;
2067     // NOTE: This uses the heuristic that these five min/max int settings account for the vast majority
2068     // of SimpleDateFormat number formatting cases at the time of writing (ICU 62).
2069     if (currentNumberFormat == fNumberFormat) {
2070         if (maxDigits == 10) {
2071             if (minDigits == 1) {
2072                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_1x10];
2073             } else if (minDigits == 2) {
2074                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_2x10];
2075             } else if (minDigits == 3) {
2076                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_3x10];
2077             } else if (minDigits == 4) {
2078                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_4x10];
2079             }
2080         } else if (maxDigits == 2) {
2081             if (minDigits == 2) {
2082                 fastFormatter = fFastNumberFormatters[SMPDTFMT_NF_2x2];
2083             }
2084         }
2085     }
2086     if (fastFormatter != nullptr) {
2087         // Can use fast path
2088         number::impl::UFormattedNumberData result;
2089         result.quantity.setToInt(value);
2090         UErrorCode localStatus = U_ZERO_ERROR;
2091         fastFormatter-&gt;formatImpl(&amp;result, localStatus);
2092         if (U_FAILURE(localStatus)) {
2093             return;
2094         }
2095         appendTo.append(result.getStringRef().toTempUnicodeString());
2096         return;
2097     }
2098 
2099     // Check for RBNF (no clone necessary)
2100     auto* rbnf = dynamic_cast&lt;const RuleBasedNumberFormat*&gt;(currentNumberFormat);
2101     if (rbnf != nullptr) {
2102         FieldPosition pos(FieldPosition::DONT_CARE);
2103         rbnf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2104         return;
2105     }
2106 
2107     // Fall back to slow path (clone and mutate the NumberFormat)
2108     if (currentNumberFormat != nullptr) {
2109         FieldPosition pos(FieldPosition::DONT_CARE);
2110         LocalPointer&lt;NumberFormat&gt; nf(dynamic_cast&lt;NumberFormat*&gt;(currentNumberFormat-&gt;clone()));
2111         nf-&gt;setMinimumIntegerDigits(minDigits);
2112         nf-&gt;setMaximumIntegerDigits(maxDigits);
2113         nf-&gt;format(value, appendTo, pos);  // 3rd arg is there to speed up processing
2114     }
2115 }
2116 
2117 //----------------------------------------------------------------------
2118 
2119 /**
2120  * Return true if the given format character, occuring count
2121  * times, represents a numeric field.
2122  */
2123 UBool SimpleDateFormat::isNumeric(UChar formatChar, int32_t count) {
2124     return DateFormatSymbols::isNumericPatternChar(formatChar, count);
2125 }
2126 
2127 UBool
2128 SimpleDateFormat::isAtNumericField(const UnicodeString &amp;pattern, int32_t patternOffset) {
2129     if (patternOffset &gt;= pattern.length()) {
2130         // not at any field
2131         return FALSE;
2132     }
2133     UChar ch = pattern.charAt(patternOffset);
2134     UDateFormatField f = DateFormatSymbols::getPatternCharIndex(ch);
2135     if (f == UDAT_FIELD_COUNT) {
2136         // not at any field
2137         return FALSE;
2138     }
2139     int32_t i = patternOffset;
2140     while (pattern.charAt(++i) == ch) {}
2141     return DateFormatSymbols::isNumericField(f, i - patternOffset);
2142 }
2143 
2144 UBool
2145 SimpleDateFormat::isAfterNonNumericField(const UnicodeString &amp;pattern, int32_t patternOffset) {
2146     if (patternOffset &lt;= 0) {
2147         // not after any field
2148         return FALSE;
2149     }
2150     UChar ch = pattern.charAt(--patternOffset);
2151     UDateFormatField f = DateFormatSymbols::getPatternCharIndex(ch);
2152     if (f == UDAT_FIELD_COUNT) {
2153         // not after any field
2154         return FALSE;
2155     }
2156     int32_t i = patternOffset;
2157     while (pattern.charAt(--i) == ch) {}
2158     return !DateFormatSymbols::isNumericField(f, patternOffset - i);
2159 }
2160 
2161 void
2162 SimpleDateFormat::parse(const UnicodeString&amp; text, Calendar&amp; cal, ParsePosition&amp; parsePos) const
2163 {
2164     UErrorCode status = U_ZERO_ERROR;
2165     int32_t pos = parsePos.getIndex();
2166     if(parsePos.getIndex() &lt; 0) {
2167         parsePos.setErrorIndex(0);
2168         return;
2169     }
2170     int32_t start = pos;
2171 
2172     // Hold the day period until everything else is parsed, because we need
2173     // the hour to interpret time correctly.
2174     int32_t dayPeriodInt = -1;
2175 
2176     UBool ambiguousYear[] = { FALSE };
2177     int32_t saveHebrewMonth = -1;
2178     int32_t count = 0;
2179     UTimeZoneFormatTimeType tzTimeType = UTZFMT_TIME_TYPE_UNKNOWN;
2180 
2181     // For parsing abutting numeric fields. &#39;abutPat&#39; is the
2182     // offset into &#39;pattern&#39; of the first of 2 or more abutting
2183     // numeric fields.  &#39;abutStart&#39; is the offset into &#39;text&#39;
2184     // where parsing the fields begins. &#39;abutPass&#39; starts off as 0
2185     // and increments each time we try to parse the fields.
2186     int32_t abutPat = -1; // If &gt;=0, we are in a run of abutting numeric fields
2187     int32_t abutStart = 0;
2188     int32_t abutPass = 0;
2189     UBool inQuote = FALSE;
2190 
2191     MessageFormat * numericLeapMonthFormatter = NULL;
2192 
2193     Calendar* calClone = NULL;
2194     Calendar *workCal = &amp;cal;
2195     if (&amp;cal != fCalendar &amp;&amp; uprv_strcmp(cal.getType(), fCalendar-&gt;getType()) != 0) {
2196         // Different calendar type
2197         // We use the time/zone from the input calendar, but
2198         // do not use the input calendar for field calculation.
2199         calClone = fCalendar-&gt;clone();
2200         if (calClone != NULL) {
2201             calClone-&gt;setTime(cal.getTime(status),status);
2202             if (U_FAILURE(status)) {
2203                 goto ExitParse;
2204             }
2205             calClone-&gt;setTimeZone(cal.getTimeZone());
2206             workCal = calClone;
2207         } else {
2208             status = U_MEMORY_ALLOCATION_ERROR;
2209             goto ExitParse;
2210         }
2211     }
2212 
2213     if (fSymbols-&gt;fLeapMonthPatterns != NULL &amp;&amp; fSymbols-&gt;fLeapMonthPatternsCount &gt;= DateFormatSymbols::kMonthPatternsCount) {
2214         numericLeapMonthFormatter = new MessageFormat(fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternNumeric], fLocale, status);
2215         if (numericLeapMonthFormatter == NULL) {
2216              status = U_MEMORY_ALLOCATION_ERROR;
2217              goto ExitParse;
2218         } else if (U_FAILURE(status)) {
2219              goto ExitParse; // this will delete numericLeapMonthFormatter
2220         }
2221     }
2222 
2223     for (int32_t i=0; i&lt;fPattern.length(); ++i) {
2224         UChar ch = fPattern.charAt(i);
2225 
2226         // Handle alphabetic field characters.
2227         if (!inQuote &amp;&amp; isSyntaxChar(ch)) {
2228             int32_t fieldPat = i;
2229 
2230             // Count the length of this field specifier
2231             count = 1;
2232             while ((i+1)&lt;fPattern.length() &amp;&amp;
2233                    fPattern.charAt(i+1) == ch) {
2234                 ++count;
2235                 ++i;
2236             }
2237 
2238             if (isNumeric(ch, count)) {
2239                 if (abutPat &lt; 0) {
2240                     // Determine if there is an abutting numeric field.
2241                     // Record the start of a set of abutting numeric fields.
2242                     if (isAtNumericField(fPattern, i + 1)) {
2243                         abutPat = fieldPat;
2244                         abutStart = pos;
2245                         abutPass = 0;
2246                     }
2247                 }
2248             } else {
2249                 abutPat = -1; // End of any abutting fields
2250             }
2251 
2252             // Handle fields within a run of abutting numeric fields.  Take
2253             // the pattern &quot;HHmmss&quot; as an example. We will try to parse
2254             // 2/2/2 characters of the input text, then if that fails,
2255             // 1/2/2.  We only adjust the width of the leftmost field; the
2256             // others remain fixed.  This allows &quot;123456&quot; =&gt; 12:34:56, but
2257             // &quot;12345&quot; =&gt; 1:23:45.  Likewise, for the pattern &quot;yyyyMMdd&quot; we
2258             // try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.
2259             if (abutPat &gt;= 0) {
2260                 // If we are at the start of a run of abutting fields, then
2261                 // shorten this field in each pass.  If we can&#39;t shorten
2262                 // this field any more, then the parse of this set of
2263                 // abutting numeric fields has failed.
2264                 if (fieldPat == abutPat) {
2265                     count -= abutPass++;
2266                     if (count == 0) {
2267                         status = U_PARSE_ERROR;
2268                         goto ExitParse;
2269                     }
2270                 }
2271 
2272                 pos = subParse(text, pos, ch, count,
2273                                TRUE, FALSE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &amp;tzTimeType);
2274 
2275                 // If the parse fails anywhere in the run, back up to the
2276                 // start of the run and retry.
2277                 if (pos &lt; 0) {
2278                     i = abutPat - 1;
2279                     pos = abutStart;
2280                     continue;
2281                 }
2282             }
2283 
2284             // Handle non-numeric fields and non-abutting numeric
2285             // fields.
2286             else if (ch != 0x6C) { // pattern char &#39;l&#39; (SMALL LETTER L) just gets ignored
2287                 int32_t s = subParse(text, pos, ch, count,
2288                                FALSE, TRUE, ambiguousYear, saveHebrewMonth, *workCal, i, numericLeapMonthFormatter, &amp;tzTimeType, &amp;dayPeriodInt);
2289 
2290                 if (s == -pos-1) {
2291                     // era not present, in special cases allow this to continue
2292                     // from the position where the era was expected
2293                     s = pos;
2294 
2295                     if (i+1 &lt; fPattern.length()) {
2296                         // move to next pattern character
2297                         UChar c = fPattern.charAt(i+1);
2298 
2299                         // check for whitespace
2300                         if (PatternProps::isWhiteSpace(c)) {
2301                             i++;
2302                             // Advance over run in pattern
2303                             while ((i+1)&lt;fPattern.length() &amp;&amp;
2304                                    PatternProps::isWhiteSpace(fPattern.charAt(i+1))) {
2305                                 ++i;
2306                             }
2307                         }
2308                     }
2309                 }
2310                 else if (s &lt;= 0) {
2311                     status = U_PARSE_ERROR;
2312                     goto ExitParse;
2313                 }
2314                 pos = s;
2315             }
2316         }
2317 
2318         // Handle literal pattern characters.  These are any
2319         // quoted characters and non-alphabetic unquoted
2320         // characters.
2321         else {
2322 
2323             abutPat = -1; // End of any abutting fields
2324 
2325             if (! matchLiterals(fPattern, i, text, pos, getBooleanAttribute(UDAT_PARSE_ALLOW_WHITESPACE, status), getBooleanAttribute(UDAT_PARSE_PARTIAL_LITERAL_MATCH, status), isLenient())) {
2326                 status = U_PARSE_ERROR;
2327                 goto ExitParse;
2328             }
2329         }
2330     }
2331 
2332     // Special hack for trailing &quot;.&quot; after non-numeric field.
2333     if (text.charAt(pos) == 0x2e &amp;&amp; getBooleanAttribute(UDAT_PARSE_ALLOW_WHITESPACE, status)) {
2334         // only do if the last field is not numeric
2335         if (isAfterNonNumericField(fPattern, fPattern.length())) {
2336             pos++; // skip the extra &quot;.&quot;
2337         }
2338     }
2339 
2340     // If dayPeriod is set, use it in conjunction with hour-of-day to determine am/pm.
2341     if (dayPeriodInt &gt;= 0) {
2342         DayPeriodRules::DayPeriod dayPeriod = (DayPeriodRules::DayPeriod)dayPeriodInt;
2343         const DayPeriodRules *ruleSet = DayPeriodRules::getInstance(this-&gt;getSmpFmtLocale(), status);
2344 
2345         if (!cal.isSet(UCAL_HOUR) &amp;&amp; !cal.isSet(UCAL_HOUR_OF_DAY)) {
2346             // If hour is not set, set time to the midpoint of current day period, overwriting
2347             // minutes if it&#39;s set.
2348             double midPoint = ruleSet-&gt;getMidPointForDayPeriod(dayPeriod, status);
2349 
2350             // If we can&#39;t get midPoint we do nothing.
2351             if (U_SUCCESS(status)) {
2352                 // Truncate midPoint toward zero to get the hour.
2353                 // Any leftover means it was a half-hour.
2354                 int32_t midPointHour = (int32_t) midPoint;
2355                 int32_t midPointMinute = (midPoint - midPointHour) &gt; 0 ? 30 : 0;
2356 
2357                 // No need to set am/pm because hour-of-day is set last therefore takes precedence.
2358                 cal.set(UCAL_HOUR_OF_DAY, midPointHour);
2359                 cal.set(UCAL_MINUTE, midPointMinute);
2360             }
2361         } else {
2362             int hourOfDay;
2363 
2364             if (cal.isSet(UCAL_HOUR_OF_DAY)) {  // Hour is parsed in 24-hour format.
2365                 hourOfDay = cal.get(UCAL_HOUR_OF_DAY, status);
2366             } else {  // Hour is parsed in 12-hour format.
2367                 hourOfDay = cal.get(UCAL_HOUR, status);
2368                 // cal.get() turns 12 to 0 for 12-hour time; change 0 to 12
2369                 // so 0 unambiguously means a 24-hour time from above.
2370                 if (hourOfDay == 0) { hourOfDay = 12; }
2371             }
2372             U_ASSERT(0 &lt;= hourOfDay &amp;&amp; hourOfDay &lt;= 23);
2373 
2374 
2375             // If hour-of-day is 0 or 13 thru 23 then input time in unambiguously in 24-hour format.
2376             if (hourOfDay == 0 || (13 &lt;= hourOfDay &amp;&amp; hourOfDay &lt;= 23)) {
2377                 // Make hour-of-day take precedence over (hour + am/pm) by setting it again.
2378                 cal.set(UCAL_HOUR_OF_DAY, hourOfDay);
2379             } else {
2380                 // We have a 12-hour time and need to choose between am and pm.
2381                 // Behave as if dayPeriod spanned 6 hours each way from its center point.
2382                 // This will parse correctly for consistent time + period (e.g. 10 at night) as
2383                 // well as provide a reasonable recovery for inconsistent time + period (e.g.
2384                 // 9 in the afternoon).
2385 
2386                 // Assume current time is in the AM.
2387                 // - Change 12 back to 0 for easier handling of 12am.
2388                 // - Append minutes as fractional hours because e.g. 8:15 and 8:45 could be parsed
2389                 // into different half-days if center of dayPeriod is at 14:30.
2390                 // - cal.get(MINUTE) will return 0 if MINUTE is unset, which works.
2391                 if (hourOfDay == 12) { hourOfDay = 0; }
2392                 double currentHour = hourOfDay + (cal.get(UCAL_MINUTE, status)) / 60.0;
2393                 double midPointHour = ruleSet-&gt;getMidPointForDayPeriod(dayPeriod, status);
2394 
2395                 if (U_SUCCESS(status)) {
2396                     double hoursAheadMidPoint = currentHour - midPointHour;
2397 
2398                     // Assume current time is in the AM.
2399                     if (-6 &lt;= hoursAheadMidPoint &amp;&amp; hoursAheadMidPoint &lt; 6) {
2400                         // Assumption holds; set time as such.
2401                         cal.set(UCAL_AM_PM, 0);
2402                     } else {
2403                         cal.set(UCAL_AM_PM, 1);
2404                     }
2405                 }
2406             }
2407         }
2408     }
2409 
2410     // At this point the fields of Calendar have been set.  Calendar
2411     // will fill in default values for missing fields when the time
2412     // is computed.
2413 
2414     parsePos.setIndex(pos);
2415 
2416     // This part is a problem:  When we call parsedDate.after, we compute the time.
2417     // Take the date April 3 2004 at 2:30 am.  When this is first set up, the year
2418     // will be wrong if we&#39;re parsing a 2-digit year pattern.  It will be 1904.
2419     // April 3 1904 is a Sunday (unlike 2004) so it is the DST onset day.  2:30 am
2420     // is therefore an &quot;impossible&quot; time, since the time goes from 1:59 to 3:00 am
2421     // on that day.  It is therefore parsed out to fields as 3:30 am.  Then we
2422     // add 100 years, and get April 3 2004 at 3:30 am.  Note that April 3 2004 is
2423     // a Saturday, so it can have a 2:30 am -- and it should. [LIU]
2424     /*
2425         UDate parsedDate = calendar.getTime();
2426         if( ambiguousYear[0] &amp;&amp; !parsedDate.after(fDefaultCenturyStart) ) {
2427             calendar.add(Calendar.YEAR, 100);
2428             parsedDate = calendar.getTime();
2429         }
2430     */
2431     // Because of the above condition, save off the fields in case we need to readjust.
2432     // The procedure we use here is not particularly efficient, but there is no other
2433     // way to do this given the API restrictions present in Calendar.  We minimize
2434     // inefficiency by only performing this computation when it might apply, that is,
2435     // when the two-digit year is equal to the start year, and thus might fall at the
2436     // front or the back of the default century.  This only works because we adjust
2437     // the year correctly to start with in other cases -- see subParse().
2438     if (ambiguousYear[0] || tzTimeType != UTZFMT_TIME_TYPE_UNKNOWN) // If this is true then the two-digit year == the default start year
2439     {
2440         // We need a copy of the fields, and we need to avoid triggering a call to
2441         // complete(), which will recalculate the fields.  Since we can&#39;t access
2442         // the fields[] array in Calendar, we clone the entire object.  This will
2443         // stop working if Calendar.clone() is ever rewritten to call complete().
2444         Calendar *copy;
2445         if (ambiguousYear[0]) {
2446             copy = cal.clone();
2447             // Check for failed cloning.
2448             if (copy == NULL) {
2449                 status = U_MEMORY_ALLOCATION_ERROR;
2450                 goto ExitParse;
2451             }
2452             UDate parsedDate = copy-&gt;getTime(status);
2453             // {sfb} check internalGetDefaultCenturyStart
2454             if (fHaveDefaultCentury &amp;&amp; (parsedDate &lt; fDefaultCenturyStart)) {
2455                 // We can&#39;t use add here because that does a complete() first.
2456                 cal.set(UCAL_YEAR, fDefaultCenturyStartYear + 100);
2457             }
2458             delete copy;
2459         }
2460 
2461         if (tzTimeType != UTZFMT_TIME_TYPE_UNKNOWN) {
2462             copy = cal.clone();
2463             // Check for failed cloning.
2464             if (copy == NULL) {
2465                 status = U_MEMORY_ALLOCATION_ERROR;
2466                 goto ExitParse;
2467             }
2468             const TimeZone &amp; tz = cal.getTimeZone();
2469             BasicTimeZone *btz = NULL;
2470 
2471             if (dynamic_cast&lt;const OlsonTimeZone *&gt;(&amp;tz) != NULL
2472                 || dynamic_cast&lt;const SimpleTimeZone *&gt;(&amp;tz) != NULL
2473                 || dynamic_cast&lt;const RuleBasedTimeZone *&gt;(&amp;tz) != NULL
2474                 || dynamic_cast&lt;const VTimeZone *&gt;(&amp;tz) != NULL) {
2475                 btz = (BasicTimeZone*)&amp;tz;
2476             }
2477 
2478             // Get local millis
2479             copy-&gt;set(UCAL_ZONE_OFFSET, 0);
2480             copy-&gt;set(UCAL_DST_OFFSET, 0);
2481             UDate localMillis = copy-&gt;getTime(status);
2482 
2483             // Make sure parsed time zone type (Standard or Daylight)
2484             // matches the rule used by the parsed time zone.
2485             int32_t raw, dst;
2486             if (btz != NULL) {
2487                 if (tzTimeType == UTZFMT_TIME_TYPE_STANDARD) {
2488                     btz-&gt;getOffsetFromLocal(localMillis,
2489                         BasicTimeZone::kStandard, BasicTimeZone::kStandard, raw, dst, status);
2490                 } else {
2491                     btz-&gt;getOffsetFromLocal(localMillis,
2492                         BasicTimeZone::kDaylight, BasicTimeZone::kDaylight, raw, dst, status);
2493                 }
2494             } else {
2495                 // No good way to resolve ambiguous time at transition,
2496                 // but following code work in most case.
2497                 tz.getOffset(localMillis, TRUE, raw, dst, status);
2498             }
2499 
2500             // Now, compare the results with parsed type, either standard or daylight saving time
2501             int32_t resolvedSavings = dst;
2502             if (tzTimeType == UTZFMT_TIME_TYPE_STANDARD) {
2503                 if (dst != 0) {
2504                     // Override DST_OFFSET = 0 in the result calendar
2505                     resolvedSavings = 0;
2506                 }
2507             } else { // tztype == TZTYPE_DST
2508                 if (dst == 0) {
2509                     if (btz != NULL) {
2510                         UDate time = localMillis + raw;
2511                         // We use the nearest daylight saving time rule.
2512                         TimeZoneTransition beforeTrs, afterTrs;
2513                         UDate beforeT = time, afterT = time;
2514                         int32_t beforeSav = 0, afterSav = 0;
2515                         UBool beforeTrsAvail, afterTrsAvail;
2516 
2517                         // Search for DST rule before or on the time
2518                         while (TRUE) {
2519                             beforeTrsAvail = btz-&gt;getPreviousTransition(beforeT, TRUE, beforeTrs);
2520                             if (!beforeTrsAvail) {
2521                                 break;
2522                             }
2523                             beforeT = beforeTrs.getTime() - 1;
2524                             beforeSav = beforeTrs.getFrom()-&gt;getDSTSavings();
2525                             if (beforeSav != 0) {
2526                                 break;
2527                             }
2528                         }
2529 
2530                         // Search for DST rule after the time
2531                         while (TRUE) {
2532                             afterTrsAvail = btz-&gt;getNextTransition(afterT, FALSE, afterTrs);
2533                             if (!afterTrsAvail) {
2534                                 break;
2535                             }
2536                             afterT = afterTrs.getTime();
2537                             afterSav = afterTrs.getTo()-&gt;getDSTSavings();
2538                             if (afterSav != 0) {
2539                                 break;
2540                             }
2541                         }
2542 
2543                         if (beforeTrsAvail &amp;&amp; afterTrsAvail) {
2544                             if (time - beforeT &gt; afterT - time) {
2545                                 resolvedSavings = afterSav;
2546                             } else {
2547                                 resolvedSavings = beforeSav;
2548                             }
2549                         } else if (beforeTrsAvail &amp;&amp; beforeSav != 0) {
2550                             resolvedSavings = beforeSav;
2551                         } else if (afterTrsAvail &amp;&amp; afterSav != 0) {
2552                             resolvedSavings = afterSav;
2553                         } else {
2554                             resolvedSavings = btz-&gt;getDSTSavings();
2555                         }
2556                     } else {
2557                         resolvedSavings = tz.getDSTSavings();
2558                     }
2559                     if (resolvedSavings == 0) {
2560                         // final fallback
2561                         resolvedSavings = U_MILLIS_PER_HOUR;
2562                     }
2563                 }
2564             }
2565             cal.set(UCAL_ZONE_OFFSET, raw);
2566             cal.set(UCAL_DST_OFFSET, resolvedSavings);
2567             delete copy;
2568         }
2569     }
2570 ExitParse:
2571     // Set the parsed result if local calendar is used
2572     // instead of the input calendar
2573     if (U_SUCCESS(status) &amp;&amp; workCal != &amp;cal) {
2574         cal.setTimeZone(workCal-&gt;getTimeZone());
2575         cal.setTime(workCal-&gt;getTime(status), status);
2576     }
2577 
2578     if (numericLeapMonthFormatter != NULL) {
2579         delete numericLeapMonthFormatter;
2580     }
2581     if (calClone != NULL) {
2582         delete calClone;
2583     }
2584 
2585     // If any Calendar calls failed, we pretend that we
2586     // couldn&#39;t parse the string, when in reality this isn&#39;t quite accurate--
2587     // we did parse it; the Calendar calls just failed.
2588     if (U_FAILURE(status)) {
2589         parsePos.setErrorIndex(pos);
2590         parsePos.setIndex(start);
2591     }
2592 }
2593 
2594 //----------------------------------------------------------------------
2595 
2596 static int32_t
2597 matchStringWithOptionalDot(const UnicodeString &amp;text,
2598                             int32_t index,
2599                             const UnicodeString &amp;data);
2600 
2601 int32_t SimpleDateFormat::matchQuarterString(const UnicodeString&amp; text,
2602                               int32_t start,
2603                               UCalendarDateFields field,
2604                               const UnicodeString* data,
2605                               int32_t dataCount,
2606                               Calendar&amp; cal) const
2607 {
2608     int32_t i = 0;
2609     int32_t count = dataCount;
2610 
2611     // There may be multiple strings in the data[] array which begin with
2612     // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
2613     // We keep track of the longest match, and return that.  Note that this
2614     // unfortunately requires us to test all array elements.
2615     int32_t bestMatchLength = 0, bestMatch = -1;
2616     UnicodeString bestMatchName;
2617 
2618     for (; i &lt; count; ++i) {
2619         int32_t matchLength = 0;
2620         if ((matchLength = matchStringWithOptionalDot(text, start, data[i])) &gt; bestMatchLength) {
2621             bestMatchLength = matchLength;
2622             bestMatch = i;
2623         }
2624     }
2625 
2626     if (bestMatch &gt;= 0) {
2627         cal.set(field, bestMatch * 3);
2628         return start + bestMatchLength;
2629     }
2630 
2631     return -start;
2632 }
2633 
2634 int32_t SimpleDateFormat::matchDayPeriodStrings(const UnicodeString&amp; text, int32_t start,
2635                               const UnicodeString* data, int32_t dataCount,
2636                               int32_t &amp;dayPeriod) const
2637 {
2638 
2639     int32_t bestMatchLength = 0, bestMatch = -1;
2640 
2641     for (int32_t i = 0; i &lt; dataCount; ++i) {
2642         int32_t matchLength = 0;
2643         if ((matchLength = matchStringWithOptionalDot(text, start, data[i])) &gt; bestMatchLength) {
2644             bestMatchLength = matchLength;
2645             bestMatch = i;
2646         }
2647     }
2648 
2649     if (bestMatch &gt;= 0) {
2650         dayPeriod = bestMatch;
2651         return start + bestMatchLength;
2652     }
2653 
2654     return -start;
2655 }
2656 
2657 //----------------------------------------------------------------------
2658 UBool SimpleDateFormat::matchLiterals(const UnicodeString &amp;pattern,
2659                                       int32_t &amp;patternOffset,
2660                                       const UnicodeString &amp;text,
2661                                       int32_t &amp;textOffset,
2662                                       UBool whitespaceLenient,
2663                                       UBool partialMatchLenient,
2664                                       UBool oldLeniency)
2665 {
2666     UBool inQuote = FALSE;
2667     UnicodeString literal;
2668     int32_t i = patternOffset;
2669 
2670     // scan pattern looking for contiguous literal characters
2671     for ( ; i &lt; pattern.length(); i += 1) {
2672         UChar ch = pattern.charAt(i);
2673 
2674         if (!inQuote &amp;&amp; isSyntaxChar(ch)) {
2675             break;
2676         }
2677 
2678         if (ch == QUOTE) {
2679             // Match a quote literal (&#39;&#39;) inside OR outside of quotes
2680             if ((i + 1) &lt; pattern.length() &amp;&amp; pattern.charAt(i + 1) == QUOTE) {
2681                 i += 1;
2682             } else {
2683                 inQuote = !inQuote;
2684                 continue;
2685             }
2686         }
2687 
2688         literal += ch;
2689     }
2690 
2691     // at this point, literal contains the literal text
2692     // and i is the index of the next non-literal pattern character.
2693     int32_t p;
2694     int32_t t = textOffset;
2695 
2696     if (whitespaceLenient) {
2697         // trim leading, trailing whitespace from
2698         // the literal text
2699         literal.trim();
2700 
2701         // ignore any leading whitespace in the text
2702         while (t &lt; text.length() &amp;&amp; u_isWhitespace(text.charAt(t))) {
2703             t += 1;
2704         }
2705     }
2706 
2707     for (p = 0; p &lt; literal.length() &amp;&amp; t &lt; text.length();) {
2708         UBool needWhitespace = FALSE;
2709 
2710         while (p &lt; literal.length() &amp;&amp; PatternProps::isWhiteSpace(literal.charAt(p))) {
2711             needWhitespace = TRUE;
2712             p += 1;
2713         }
2714 
2715         if (needWhitespace) {
2716             int32_t tStart = t;
2717 
2718             while (t &lt; text.length()) {
2719                 UChar tch = text.charAt(t);
2720 
2721                 if (!u_isUWhiteSpace(tch) &amp;&amp; !PatternProps::isWhiteSpace(tch)) {
2722                     break;
2723                 }
2724 
2725                 t += 1;
2726             }
2727 
2728             // TODO: should we require internal spaces
2729             // in lenient mode? (There won&#39;t be any
2730             // leading or trailing spaces)
2731             if (!whitespaceLenient &amp;&amp; t == tStart) {
2732                 // didn&#39;t find matching whitespace:
2733                 // an error in strict mode
2734                 return FALSE;
2735             }
2736 
2737             // In strict mode, this run of whitespace
2738             // may have been at the end.
2739             if (p &gt;= literal.length()) {
2740                 break;
2741             }
2742         }
2743         if (t &gt;= text.length() || literal.charAt(p) != text.charAt(t)) {
2744             // Ran out of text, or found a non-matching character:
2745             // OK in lenient mode, an error in strict mode.
2746             if (whitespaceLenient) {
2747                 if (t == textOffset &amp;&amp; text.charAt(t) == 0x2e &amp;&amp;
2748                         isAfterNonNumericField(pattern, patternOffset)) {
2749                     // Lenient mode and the literal input text begins with a &quot;.&quot; and
2750                     // we are after a non-numeric field: We skip the &quot;.&quot;
2751                     ++t;
2752                     continue;  // Do not update p.
2753                 }
2754                 // if it is actual whitespace and we&#39;re whitespace lenient it&#39;s OK
2755 
2756                 UChar wsc = text.charAt(t);
2757                 if(PatternProps::isWhiteSpace(wsc)) {
2758                     // Lenient mode and it&#39;s just whitespace we skip it
2759                     ++t;
2760                     continue;  // Do not update p.
2761                 }
2762             }
2763             // hack around oldleniency being a bit of a catch-all bucket and we&#39;re just adding support specifically for paritial matches
2764             if(partialMatchLenient &amp;&amp; oldLeniency) {
2765                 break;
2766             }
2767 
2768             return FALSE;
2769         }
2770         ++p;
2771         ++t;
2772     }
2773 
2774     // At this point if we&#39;re in strict mode we have a complete match.
2775     // If we&#39;re in lenient mode we may have a partial match, or no
2776     // match at all.
2777     if (p &lt;= 0) {
2778         // no match. Pretend it matched a run of whitespace
2779         // and ignorables in the text.
2780         const  UnicodeSet *ignorables = NULL;
2781         UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(pattern.charAt(i));
2782         if (patternCharIndex != UDAT_FIELD_COUNT) {
2783             ignorables = SimpleDateFormatStaticSets::getIgnorables(patternCharIndex);
2784         }
2785 
2786         for (t = textOffset; t &lt; text.length(); t += 1) {
2787             UChar ch = text.charAt(t);
2788 
2789             if (ignorables == NULL || !ignorables-&gt;contains(ch)) {
2790                 break;
2791             }
2792         }
2793     }
2794 
2795     // if we get here, we&#39;ve got a complete match.
2796     patternOffset = i - 1;
2797     textOffset = t;
2798 
2799     return TRUE;
2800 }
2801 
2802 //----------------------------------------------------------------------
2803 
2804 int32_t SimpleDateFormat::matchString(const UnicodeString&amp; text,
2805                               int32_t start,
2806                               UCalendarDateFields field,
2807                               const UnicodeString* data,
2808                               int32_t dataCount,
2809                               const UnicodeString* monthPattern,
2810                               Calendar&amp; cal) const
2811 {
2812     int32_t i = 0;
2813     int32_t count = dataCount;
2814 
2815     if (field == UCAL_DAY_OF_WEEK) i = 1;
2816 
2817     // There may be multiple strings in the data[] array which begin with
2818     // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
2819     // We keep track of the longest match, and return that.  Note that this
2820     // unfortunately requires us to test all array elements.
2821     int32_t bestMatchLength = 0, bestMatch = -1;
2822     UnicodeString bestMatchName;
2823     int32_t isLeapMonth = 0;
2824 
2825     for (; i &lt; count; ++i) {
2826         int32_t matchLen = 0;
2827         if ((matchLen = matchStringWithOptionalDot(text, start, data[i])) &gt; bestMatchLength) {
2828             bestMatch = i;
2829             bestMatchLength = matchLen;
2830         }
2831 
2832         if (monthPattern != NULL) {
2833             UErrorCode status = U_ZERO_ERROR;
2834             UnicodeString leapMonthName;
2835             SimpleFormatter(*monthPattern, 1, 1, status).format(data[i], leapMonthName, status);
2836             if (U_SUCCESS(status)) {
2837                 if ((matchLen = matchStringWithOptionalDot(text, start, leapMonthName)) &gt; bestMatchLength) {
2838                     bestMatch = i;
2839                     bestMatchLength = matchLen;
2840                     isLeapMonth = 1;
2841                 }
2842             }
2843         }
2844     }
2845 
2846     if (bestMatch &gt;= 0) {
2847         if (field &lt; UCAL_FIELD_COUNT) {
2848             // Adjustment for Hebrew Calendar month Adar II
2849             if (!strcmp(cal.getType(),&quot;hebrew&quot;) &amp;&amp; field==UCAL_MONTH &amp;&amp; bestMatch==13) {
2850                 cal.set(field,6);
2851             } else {
2852                 if (field == UCAL_YEAR) {
2853                     bestMatch++; // only get here for cyclic year names, which match 1-based years 1-60
2854                 }
2855                 cal.set(field, bestMatch);
2856             }
2857             if (monthPattern != NULL) {
2858                 cal.set(UCAL_IS_LEAP_MONTH, isLeapMonth);
2859             }
2860         }
2861 
2862         return start + bestMatchLength;
2863     }
2864 
2865     return -start;
2866 }
2867 
2868 static int32_t
2869 matchStringWithOptionalDot(const UnicodeString &amp;text,
2870                             int32_t index,
2871                             const UnicodeString &amp;data) {
2872     UErrorCode sts = U_ZERO_ERROR;
2873     int32_t matchLenText = 0;
2874     int32_t matchLenData = 0;
2875 
2876     u_caseInsensitivePrefixMatch(text.getBuffer() + index, text.length() - index,
2877                                  data.getBuffer(), data.length(),
2878                                  0 /* default case option */,
2879                                  &amp;matchLenText, &amp;matchLenData,
2880                                  &amp;sts);
2881     U_ASSERT (U_SUCCESS(sts));
2882 
2883     if (matchLenData == data.length() /* normal match */
2884         || (data.charAt(data.length() - 1) == 0x2e
2885             &amp;&amp; matchLenData == data.length() - 1 /* match without trailing dot */)) {
2886         return matchLenText;
2887     }
2888 
2889     return 0;
2890 }
2891 
2892 //----------------------------------------------------------------------
2893 
2894 void
2895 SimpleDateFormat::set2DigitYearStart(UDate d, UErrorCode&amp; status)
2896 {
2897     parseAmbiguousDatesAsAfter(d, status);
2898 }
2899 
2900 /**
2901  * Private member function that converts the parsed date strings into
2902  * timeFields. Returns -start (for ParsePosition) if failed.
2903  */
2904 int32_t SimpleDateFormat::subParse(const UnicodeString&amp; text, int32_t&amp; start, UChar ch, int32_t count,
2905                            UBool obeyCount, UBool allowNegative, UBool ambiguousYear[], int32_t&amp; saveHebrewMonth, Calendar&amp; cal,
2906                            int32_t patLoc, MessageFormat * numericLeapMonthFormatter, UTimeZoneFormatTimeType *tzTimeType,
2907                            int32_t *dayPeriod) const
2908 {
2909     Formattable number;
2910     int32_t value = 0;
2911     int32_t i;
2912     int32_t ps = 0;
2913     UErrorCode status = U_ZERO_ERROR;
2914     ParsePosition pos(0);
2915     UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(ch);
2916     const NumberFormat *currentNumberFormat;
2917     UnicodeString temp;
2918     UBool gotNumber = FALSE;
2919 
2920 #if defined (U_DEBUG_CAL)
2921     //fprintf(stderr, &quot;%s:%d - [%c]  st=%d \n&quot;, __FILE__, __LINE__, (char) ch, start);
2922 #endif
2923 
2924     if (patternCharIndex == UDAT_FIELD_COUNT) {
2925         return -start;
2926     }
2927 
2928     currentNumberFormat = getNumberFormatByIndex(patternCharIndex);
2929     if (currentNumberFormat == NULL) {
2930         return -start;
2931     }
2932     UCalendarDateFields field = fgPatternIndexToCalendarField[patternCharIndex]; // UCAL_FIELD_COUNT if irrelevant
2933     UnicodeString hebr(&quot;hebr&quot;, 4, US_INV);
2934 
2935     if (numericLeapMonthFormatter != NULL) {
2936         numericLeapMonthFormatter-&gt;setFormats((const Format **)&amp;currentNumberFormat, 1);
2937     }
2938     UBool isChineseCalendar = (uprv_strcmp(cal.getType(),&quot;chinese&quot;) == 0 || uprv_strcmp(cal.getType(),&quot;dangi&quot;) == 0);
2939 
2940     // If there are any spaces here, skip over them.  If we hit the end
2941     // of the string, then fail.
2942     for (;;) {
2943         if (start &gt;= text.length()) {
2944             return -start;
2945         }
2946         UChar32 c = text.char32At(start);
2947         if (!u_isUWhiteSpace(c) /*||*/ &amp;&amp; !PatternProps::isWhiteSpace(c)) {
2948             break;
2949         }
2950         start += U16_LENGTH(c);
2951     }
2952     pos.setIndex(start);
2953 
2954     // We handle a few special cases here where we need to parse
2955     // a number value.  We handle further, more generic cases below.  We need
2956     // to handle some of them here because some fields require extra processing on
2957     // the parsed value.
2958     if (patternCharIndex == UDAT_HOUR_OF_DAY1_FIELD ||                       // k
2959         patternCharIndex == UDAT_HOUR_OF_DAY0_FIELD ||                       // H
2960         patternCharIndex == UDAT_HOUR1_FIELD ||                              // h
2961         patternCharIndex == UDAT_HOUR0_FIELD ||                              // K
2962         (patternCharIndex == UDAT_DOW_LOCAL_FIELD &amp;&amp; count &lt;= 2) ||          // e
2963         (patternCharIndex == UDAT_STANDALONE_DAY_FIELD &amp;&amp; count &lt;= 2) ||     // c
2964         (patternCharIndex == UDAT_MONTH_FIELD &amp;&amp; count &lt;= 2) ||              // M
2965         (patternCharIndex == UDAT_STANDALONE_MONTH_FIELD &amp;&amp; count &lt;= 2) ||   // L
2966         (patternCharIndex == UDAT_QUARTER_FIELD &amp;&amp; count &lt;= 2) ||            // Q
2967         (patternCharIndex == UDAT_STANDALONE_QUARTER_FIELD &amp;&amp; count &lt;= 2) || // q
2968         patternCharIndex == UDAT_YEAR_FIELD ||                               // y
2969         patternCharIndex == UDAT_YEAR_WOY_FIELD ||                           // Y
2970         patternCharIndex == UDAT_YEAR_NAME_FIELD ||                          // U (falls back to numeric)
2971         (patternCharIndex == UDAT_ERA_FIELD &amp;&amp; isChineseCalendar) ||         // G
2972         patternCharIndex == UDAT_FRACTIONAL_SECOND_FIELD)                    // S
2973     {
2974         int32_t parseStart = pos.getIndex();
2975         // It would be good to unify this with the obeyCount logic below,
2976         // but that&#39;s going to be difficult.
2977         const UnicodeString* src;
2978 
2979         UBool parsedNumericLeapMonth = FALSE;
2980         if (numericLeapMonthFormatter != NULL &amp;&amp; (patternCharIndex == UDAT_MONTH_FIELD || patternCharIndex == UDAT_STANDALONE_MONTH_FIELD)) {
2981             int32_t argCount;
2982             Formattable * args = numericLeapMonthFormatter-&gt;parse(text, pos, argCount);
2983             if (args != NULL &amp;&amp; argCount == 1 &amp;&amp; pos.getIndex() &gt; parseStart &amp;&amp; args[0].isNumeric()) {
2984                 parsedNumericLeapMonth = TRUE;
2985                 number.setLong(args[0].getLong());
2986                 cal.set(UCAL_IS_LEAP_MONTH, 1);
2987                 delete[] args;
2988             } else {
2989                 pos.setIndex(parseStart);
2990                 cal.set(UCAL_IS_LEAP_MONTH, 0);
2991             }
2992         }
2993 
2994         if (!parsedNumericLeapMonth) {
2995             if (obeyCount) {
2996                 if ((start+count) &gt; text.length()) {
2997                     return -start;
2998                 }
2999 
3000                 text.extractBetween(0, start + count, temp);
3001                 src = &amp;temp;
3002             } else {
3003                 src = &amp;text;
3004             }
3005 
3006             parseInt(*src, number, pos, allowNegative,currentNumberFormat);
3007         }
3008 
3009         int32_t txtLoc = pos.getIndex();
3010 
3011         if (txtLoc &gt; parseStart) {
3012             value = number.getLong();
3013             gotNumber = TRUE;
3014 
3015             // suffix processing
3016             if (value &lt; 0 ) {
3017                 txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, TRUE);
3018                 if (txtLoc != pos.getIndex()) {
3019                     value *= -1;
3020                 }
3021             }
3022             else {
3023                 txtLoc = checkIntSuffix(text, txtLoc, patLoc+1, FALSE);
3024             }
3025 
3026             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_WHITESPACE, status)) {
3027                 // Check the range of the value
3028                 int32_t bias = gFieldRangeBias[patternCharIndex];
3029                 if (bias &gt;= 0 &amp;&amp; (value &gt; cal.getMaximum(field) + bias || value &lt; cal.getMinimum(field) + bias)) {
3030                     return -start;
3031                 }
3032             }
3033 
3034             pos.setIndex(txtLoc);
3035         }
3036     }
3037 
3038     // Make sure that we got a number if
3039     // we want one, and didn&#39;t get one
3040     // if we don&#39;t want one.
3041     switch (patternCharIndex) {
3042         case UDAT_HOUR_OF_DAY1_FIELD:
3043         case UDAT_HOUR_OF_DAY0_FIELD:
3044         case UDAT_HOUR1_FIELD:
3045         case UDAT_HOUR0_FIELD:
3046             // special range check for hours:
3047             if (value &lt; 0 || value &gt; 24) {
3048                 return -start;
3049             }
3050 
3051             // fall through to gotNumber check
3052             U_FALLTHROUGH;
3053         case UDAT_YEAR_FIELD:
3054         case UDAT_YEAR_WOY_FIELD:
3055         case UDAT_FRACTIONAL_SECOND_FIELD:
3056             // these must be a number
3057             if (! gotNumber) {
3058                 return -start;
3059             }
3060 
3061             break;
3062 
3063         default:
3064             // we check the rest of the fields below.
3065             break;
3066     }
3067 
3068     switch (patternCharIndex) {
3069     case UDAT_ERA_FIELD:
3070         if (isChineseCalendar) {
3071             if (!gotNumber) {
3072                 return -start;
3073             }
3074             cal.set(UCAL_ERA, value);
3075             return pos.getIndex();
3076         }
3077         if (count == 5) {
3078             ps = matchString(text, start, UCAL_ERA, fSymbols-&gt;fNarrowEras, fSymbols-&gt;fNarrowErasCount, NULL, cal);
3079         } else if (count == 4) {
3080             ps = matchString(text, start, UCAL_ERA, fSymbols-&gt;fEraNames, fSymbols-&gt;fEraNamesCount, NULL, cal);
3081         } else {
3082             ps = matchString(text, start, UCAL_ERA, fSymbols-&gt;fEras, fSymbols-&gt;fErasCount, NULL, cal);
3083         }
3084 
3085         // check return position, if it equals -start, then matchString error
3086         // special case the return code so we don&#39;t necessarily fail out until we
3087         // verify no year information also
3088         if (ps == -start)
3089             ps--;
3090 
3091         return ps;
3092 
3093     case UDAT_YEAR_FIELD:
3094         // If there are 3 or more YEAR pattern characters, this indicates
3095         // that the year value is to be treated literally, without any
3096         // two-digit year adjustments (e.g., from &quot;01&quot; to 2001).  Otherwise
3097         // we made adjustments to place the 2-digit year in the proper
3098         // century, for parsed strings from &quot;00&quot; to &quot;99&quot;.  Any other string
3099         // is treated literally:  &quot;2250&quot;, &quot;-1&quot;, &quot;1&quot;, &quot;002&quot;.
3100         if (fDateOverride.compare(hebr)==0 &amp;&amp; value &lt; 1000) {
3101             value += HEBREW_CAL_CUR_MILLENIUM_START_YEAR;
3102         } else if (text.moveIndex32(start, 2) == pos.getIndex() &amp;&amp; !isChineseCalendar
3103             &amp;&amp; u_isdigit(text.char32At(start))
3104             &amp;&amp; u_isdigit(text.char32At(text.moveIndex32(start, 1))))
3105         {
3106             // only adjust year for patterns less than 3.
3107             if(count &lt; 3) {
3108                 // Assume for example that the defaultCenturyStart is 6/18/1903.
3109                 // This means that two-digit years will be forced into the range
3110                 // 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
3111                 // correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
3112                 // to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
3113                 // other fields specify a date before 6/18, or 1903 if they specify a
3114                 // date afterwards.  As a result, 03 is an ambiguous year.  All other
3115                 // two-digit years are unambiguous.
3116                 if(fHaveDefaultCentury) { // check if this formatter even has a pivot year
3117                     int32_t ambiguousTwoDigitYear = fDefaultCenturyStartYear % 100;
3118                     ambiguousYear[0] = (value == ambiguousTwoDigitYear);
3119                     value += (fDefaultCenturyStartYear/100)*100 +
3120                             (value &lt; ambiguousTwoDigitYear ? 100 : 0);
3121                 }
3122             }
3123         }
3124         cal.set(UCAL_YEAR, value);
3125 
3126         // Delayed checking for adjustment of Hebrew month numbers in non-leap years.
3127         if (saveHebrewMonth &gt;= 0) {
3128             HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3129             if (!hc-&gt;isLeapYear(value) &amp;&amp; saveHebrewMonth &gt;= 6) {
3130                cal.set(UCAL_MONTH,saveHebrewMonth);
3131             } else {
3132                cal.set(UCAL_MONTH,saveHebrewMonth-1);
3133             }
3134             saveHebrewMonth = -1;
3135         }
3136         return pos.getIndex();
3137 
3138     case UDAT_YEAR_WOY_FIELD:
3139         // Comment is the same as for UDAT_Year_FIELDs - look above
3140         if (fDateOverride.compare(hebr)==0 &amp;&amp; value &lt; 1000) {
3141             value += HEBREW_CAL_CUR_MILLENIUM_START_YEAR;
3142         } else if (text.moveIndex32(start, 2) == pos.getIndex()
3143             &amp;&amp; u_isdigit(text.char32At(start))
3144             &amp;&amp; u_isdigit(text.char32At(text.moveIndex32(start, 1)))
3145             &amp;&amp; fHaveDefaultCentury )
3146         {
3147             int32_t ambiguousTwoDigitYear = fDefaultCenturyStartYear % 100;
3148             ambiguousYear[0] = (value == ambiguousTwoDigitYear);
3149             value += (fDefaultCenturyStartYear/100)*100 +
3150                 (value &lt; ambiguousTwoDigitYear ? 100 : 0);
3151         }
3152         cal.set(UCAL_YEAR_WOY, value);
3153         return pos.getIndex();
3154 
3155     case UDAT_YEAR_NAME_FIELD:
3156         if (fSymbols-&gt;fShortYearNames != NULL) {
3157             int32_t newStart = matchString(text, start, UCAL_YEAR, fSymbols-&gt;fShortYearNames, fSymbols-&gt;fShortYearNamesCount, NULL, cal);
3158             if (newStart &gt; 0) {
3159                 return newStart;
3160             }
3161         }
3162         if (gotNumber &amp;&amp; (getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC,status) || value &gt; fSymbols-&gt;fShortYearNamesCount)) {
3163             cal.set(UCAL_YEAR, value);
3164             return pos.getIndex();
3165         }
3166         return -start;
3167 
3168     case UDAT_MONTH_FIELD:
3169     case UDAT_STANDALONE_MONTH_FIELD:
3170         if (gotNumber) // i.e., M or MM.
3171         {
3172             // When parsing month numbers from the Hebrew Calendar, we might need to adjust the month depending on whether
3173             // or not it was a leap year.  We may or may not yet know what year it is, so might have to delay checking until
3174             // the year is parsed.
3175             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3176                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3177                 if (cal.isSet(UCAL_YEAR)) {
3178                    UErrorCode monthStatus = U_ZERO_ERROR;
3179                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR, monthStatus)) &amp;&amp; value &gt;= 6) {
3180                        cal.set(UCAL_MONTH, value);
3181                    } else {
3182                        cal.set(UCAL_MONTH, value - 1);
3183                    }
3184                 } else {
3185                     saveHebrewMonth = value;
3186                 }
3187             } else {
3188                 // Don&#39;t want to parse the month if it is a string
3189                 // while pattern uses numeric style: M/MM, L/LL
3190                 // [We computed &#39;value&#39; above.]
3191                 cal.set(UCAL_MONTH, value - 1);
3192             }
3193             return pos.getIndex();
3194         } else {
3195             // count &gt;= 3 // i.e., MMM/MMMM, LLL/LLLL
3196             // Want to be able to parse both short and long forms.
3197             // Try count == 4 first:
3198             UnicodeString * wideMonthPat = NULL;
3199             UnicodeString * shortMonthPat = NULL;
3200             if (fSymbols-&gt;fLeapMonthPatterns != NULL &amp;&amp; fSymbols-&gt;fLeapMonthPatternsCount &gt;= DateFormatSymbols::kMonthPatternsCount) {
3201                 if (patternCharIndex==UDAT_MONTH_FIELD) {
3202                     wideMonthPat = &amp;fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternFormatWide];
3203                     shortMonthPat = &amp;fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternFormatAbbrev];
3204                 } else {
3205                     wideMonthPat = &amp;fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternStandaloneWide];
3206                     shortMonthPat = &amp;fSymbols-&gt;fLeapMonthPatterns[DateFormatSymbols::kLeapMonthPatternStandaloneAbbrev];
3207                 }
3208             }
3209             int32_t newStart = 0;
3210             if (patternCharIndex==UDAT_MONTH_FIELD) {
3211                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3212                     newStart = matchString(text, start, UCAL_MONTH, fSymbols-&gt;fMonths, fSymbols-&gt;fMonthsCount, wideMonthPat, cal); // try MMMM
3213                     if (newStart &gt; 0) {
3214                         return newStart;
3215                     }
3216                 }
3217                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3218                     newStart = matchString(text, start, UCAL_MONTH, fSymbols-&gt;fShortMonths, fSymbols-&gt;fShortMonthsCount, shortMonthPat, cal); // try MMM
3219                 }
3220             } else {
3221                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3222                     newStart = matchString(text, start, UCAL_MONTH, fSymbols-&gt;fStandaloneMonths, fSymbols-&gt;fStandaloneMonthsCount, wideMonthPat, cal); // try LLLL
3223                     if (newStart &gt; 0) {
3224                         return newStart;
3225                     }
3226                 }
3227                 if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3228                     newStart = matchString(text, start, UCAL_MONTH, fSymbols-&gt;fStandaloneShortMonths, fSymbols-&gt;fStandaloneShortMonthsCount, shortMonthPat, cal); // try LLL
3229                 }
3230             }
3231             if (newStart &gt; 0 || !getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status))  // currently we do not try to parse MMMMM/LLLLL: #8860
3232                 return newStart;
3233             // else we allowing parsing as number, below
3234         }
3235         break;
3236 
3237     case UDAT_HOUR_OF_DAY1_FIELD:
3238         // [We computed &#39;value&#39; above.]
3239         if (value == cal.getMaximum(UCAL_HOUR_OF_DAY) + 1)
3240             value = 0;
3241 
3242         // fall through to set field
3243         U_FALLTHROUGH;
3244     case UDAT_HOUR_OF_DAY0_FIELD:
3245         cal.set(UCAL_HOUR_OF_DAY, value);
3246         return pos.getIndex();
3247 
3248     case UDAT_FRACTIONAL_SECOND_FIELD:
3249         // Fractional seconds left-justify
3250         i = countDigits(text, start, pos.getIndex());
3251         if (i &lt; 3) {
3252             while (i &lt; 3) {
3253                 value *= 10;
3254                 i++;
3255             }
3256         } else {
3257             int32_t a = 1;
3258             while (i &gt; 3) {
3259                 a *= 10;
3260                 i--;
3261             }
3262             value /= a;
3263         }
3264         cal.set(UCAL_MILLISECOND, value);
3265         return pos.getIndex();
3266 
3267     case UDAT_DOW_LOCAL_FIELD:
3268         if (gotNumber) // i.e., e or ee
3269         {
3270             // [We computed &#39;value&#39; above.]
3271             cal.set(UCAL_DOW_LOCAL, value);
3272             return pos.getIndex();
3273         }
3274         // else for eee-eeeee fall through to handling of EEE-EEEEE
3275         // fall through, do not break here
3276         U_FALLTHROUGH;
3277     case UDAT_DAY_OF_WEEK_FIELD:
3278         {
3279             // Want to be able to parse both short and long forms.
3280             // Try count == 4 (EEEE) wide first:
3281             int32_t newStart = 0;
3282             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3283                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3284                                           fSymbols-&gt;fWeekdays, fSymbols-&gt;fWeekdaysCount, NULL, cal)) &gt; 0)
3285                     return newStart;
3286             }
3287             // EEEE wide failed, now try EEE abbreviated
3288             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3289                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3290                                        fSymbols-&gt;fShortWeekdays, fSymbols-&gt;fShortWeekdaysCount, NULL, cal)) &gt; 0)
3291                     return newStart;
3292             }
3293             // EEE abbreviated failed, now try EEEEEE short
3294             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 6) {
3295                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3296                                        fSymbols-&gt;fShorterWeekdays, fSymbols-&gt;fShorterWeekdaysCount, NULL, cal)) &gt; 0)
3297                     return newStart;
3298             }
3299             // EEEEEE short failed, now try EEEEE narrow
3300             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 5) {
3301                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3302                                        fSymbols-&gt;fNarrowWeekdays, fSymbols-&gt;fNarrowWeekdaysCount, NULL, cal)) &gt; 0)
3303                     return newStart;
3304             }
3305             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status) || patternCharIndex == UDAT_DAY_OF_WEEK_FIELD)
3306                 return newStart;
3307             // else we allowing parsing as number, below
3308         }
3309         break;
3310 
3311     case UDAT_STANDALONE_DAY_FIELD:
3312         {
3313             if (gotNumber) // c or cc
3314             {
3315                 // [We computed &#39;value&#39; above.]
3316                 cal.set(UCAL_DOW_LOCAL, value);
3317                 return pos.getIndex();
3318             }
3319             // Want to be able to parse both short and long forms.
3320             // Try count == 4 (cccc) first:
3321             int32_t newStart = 0;
3322             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3323                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3324                                       fSymbols-&gt;fStandaloneWeekdays, fSymbols-&gt;fStandaloneWeekdaysCount, NULL, cal)) &gt; 0)
3325                     return newStart;
3326             }
3327             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3328                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3329                                           fSymbols-&gt;fStandaloneShortWeekdays, fSymbols-&gt;fStandaloneShortWeekdaysCount, NULL, cal)) &gt; 0)
3330                     return newStart;
3331             }
3332             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 6) {
3333                 if ((newStart = matchString(text, start, UCAL_DAY_OF_WEEK,
3334                                           fSymbols-&gt;fStandaloneShorterWeekdays, fSymbols-&gt;fStandaloneShorterWeekdaysCount, NULL, cal)) &gt; 0)
3335                     return newStart;
3336             }
3337             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status))
3338                 return newStart;
3339             // else we allowing parsing as number, below
3340         }
3341         break;
3342 
3343     case UDAT_AM_PM_FIELD:
3344         {
3345             // optionally try both wide/abbrev and narrow forms
3346             int32_t newStart = 0;
3347             // try wide/abbrev
3348             if( getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count &lt; 5 ) {
3349                 if ((newStart = matchString(text, start, UCAL_AM_PM, fSymbols-&gt;fAmPms, fSymbols-&gt;fAmPmsCount, NULL, cal)) &gt; 0) {
3350                     return newStart;
3351                 }
3352             }
3353             // try narrow
3354             if( getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count &gt;= 5 ) {
3355                 if ((newStart = matchString(text, start, UCAL_AM_PM, fSymbols-&gt;fNarrowAmPms, fSymbols-&gt;fNarrowAmPmsCount, NULL, cal)) &gt; 0) {
3356                     return newStart;
3357                 }
3358             }
3359             // no matches for given options
3360             return -start;
3361         }
3362 
3363     case UDAT_HOUR1_FIELD:
3364         // [We computed &#39;value&#39; above.]
3365         if (value == cal.getLeastMaximum(UCAL_HOUR)+1)
3366             value = 0;
3367 
3368         // fall through to set field
3369         U_FALLTHROUGH;
3370     case UDAT_HOUR0_FIELD:
3371         cal.set(UCAL_HOUR, value);
3372         return pos.getIndex();
3373 
3374     case UDAT_QUARTER_FIELD:
3375         if (gotNumber) // i.e., Q or QQ.
3376         {
3377             // Don&#39;t want to parse the month if it is a string
3378             // while pattern uses numeric style: Q or QQ.
3379             // [We computed &#39;value&#39; above.]
3380             cal.set(UCAL_MONTH, (value - 1) * 3);
3381             return pos.getIndex();
3382         } else {
3383             // count &gt;= 3 // i.e., QQQ or QQQQ
3384             // Want to be able to parse both short and long forms.
3385             // Try count == 4 first:
3386             int32_t newStart = 0;
3387 
3388             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3389                 if ((newStart = matchQuarterString(text, start, UCAL_MONTH,
3390                                       fSymbols-&gt;fQuarters, fSymbols-&gt;fQuartersCount, cal)) &gt; 0)
3391                     return newStart;
3392             }
3393             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3394                 if ((newStart = matchQuarterString(text, start, UCAL_MONTH,
3395                                           fSymbols-&gt;fShortQuarters, fSymbols-&gt;fShortQuartersCount, cal)) &gt; 0)
3396                     return newStart;
3397             }
3398             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status))
3399                 return newStart;
3400             // else we allowing parsing as number, below
3401             if(!getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status))
3402                 return -start;
3403         }
3404         break;
3405 
3406     case UDAT_STANDALONE_QUARTER_FIELD:
3407         if (gotNumber) // i.e., q or qq.
3408         {
3409             // Don&#39;t want to parse the month if it is a string
3410             // while pattern uses numeric style: q or q.
3411             // [We computed &#39;value&#39; above.]
3412             cal.set(UCAL_MONTH, (value - 1) * 3);
3413             return pos.getIndex();
3414         } else {
3415             // count &gt;= 3 // i.e., qqq or qqqq
3416             // Want to be able to parse both short and long forms.
3417             // Try count == 4 first:
3418             int32_t newStart = 0;
3419 
3420             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3421                 if ((newStart = matchQuarterString(text, start, UCAL_MONTH,
3422                                       fSymbols-&gt;fStandaloneQuarters, fSymbols-&gt;fStandaloneQuartersCount, cal)) &gt; 0)
3423                     return newStart;
3424             }
3425             if(getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3426                 if ((newStart = matchQuarterString(text, start, UCAL_MONTH,
3427                                           fSymbols-&gt;fStandaloneShortQuarters, fSymbols-&gt;fStandaloneShortQuartersCount, cal)) &gt; 0)
3428                     return newStart;
3429             }
3430             if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status))
3431                 return newStart;
3432             // else we allowing parsing as number, below
3433             if(!getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status))
3434                 return -start;
3435         }
3436         break;
3437 
3438     case UDAT_TIMEZONE_FIELD: // &#39;z&#39;
3439         {
3440             UTimeZoneFormatStyle style = (count &lt; 4) ? UTZFMT_STYLE_SPECIFIC_SHORT : UTZFMT_STYLE_SPECIFIC_LONG;
3441             const TimeZoneFormat *tzfmt = tzFormat(status);
3442             if (U_SUCCESS(status)) {
3443                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3444                 if (tz != NULL) {
3445                     cal.adoptTimeZone(tz);
3446                     return pos.getIndex();
3447                 }
3448             }
3449             return -start;
3450     }
3451         break;
3452     case UDAT_TIMEZONE_RFC_FIELD: // &#39;Z&#39;
3453         {
3454             UTimeZoneFormatStyle style = (count &lt; 4) ?
3455                 UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL : ((count == 5) ? UTZFMT_STYLE_ISO_EXTENDED_FULL: UTZFMT_STYLE_LOCALIZED_GMT);
3456             const TimeZoneFormat *tzfmt = tzFormat(status);
3457             if (U_SUCCESS(status)) {
3458                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3459                 if (tz != NULL) {
3460                     cal.adoptTimeZone(tz);
3461                     return pos.getIndex();
3462                 }
3463             }
3464             return -start;
3465         }
3466     case UDAT_TIMEZONE_GENERIC_FIELD: // &#39;v&#39;
3467         {
3468             UTimeZoneFormatStyle style = (count &lt; 4) ? UTZFMT_STYLE_GENERIC_SHORT : UTZFMT_STYLE_GENERIC_LONG;
3469             const TimeZoneFormat *tzfmt = tzFormat(status);
3470             if (U_SUCCESS(status)) {
3471                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3472                 if (tz != NULL) {
3473                     cal.adoptTimeZone(tz);
3474                     return pos.getIndex();
3475                 }
3476             }
3477             return -start;
3478         }
3479     case UDAT_TIMEZONE_SPECIAL_FIELD: // &#39;V&#39;
3480         {
3481             UTimeZoneFormatStyle style;
3482             switch (count) {
3483             case 1:
3484                 style = UTZFMT_STYLE_ZONE_ID_SHORT;
3485                 break;
3486             case 2:
3487                 style = UTZFMT_STYLE_ZONE_ID;
3488                 break;
3489             case 3:
3490                 style = UTZFMT_STYLE_EXEMPLAR_LOCATION;
3491                 break;
3492             default:
3493                 style = UTZFMT_STYLE_GENERIC_LOCATION;
3494                 break;
3495             }
3496             const TimeZoneFormat *tzfmt = tzFormat(status);
3497             if (U_SUCCESS(status)) {
3498                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3499                 if (tz != NULL) {
3500                     cal.adoptTimeZone(tz);
3501                     return pos.getIndex();
3502                 }
3503             }
3504             return -start;
3505         }
3506     case UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD: // &#39;O&#39;
3507         {
3508             UTimeZoneFormatStyle style = (count &lt; 4) ? UTZFMT_STYLE_LOCALIZED_GMT_SHORT : UTZFMT_STYLE_LOCALIZED_GMT;
3509             const TimeZoneFormat *tzfmt = tzFormat(status);
3510             if (U_SUCCESS(status)) {
3511                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3512                 if (tz != NULL) {
3513                     cal.adoptTimeZone(tz);
3514                     return pos.getIndex();
3515                 }
3516             }
3517             return -start;
3518         }
3519     case UDAT_TIMEZONE_ISO_FIELD: // &#39;X&#39;
3520         {
3521             UTimeZoneFormatStyle style;
3522             switch (count) {
3523             case 1:
3524                 style = UTZFMT_STYLE_ISO_BASIC_SHORT;
3525                 break;
3526             case 2:
3527                 style = UTZFMT_STYLE_ISO_BASIC_FIXED;
3528                 break;
3529             case 3:
3530                 style = UTZFMT_STYLE_ISO_EXTENDED_FIXED;
3531                 break;
3532             case 4:
3533                 style = UTZFMT_STYLE_ISO_BASIC_FULL;
3534                 break;
3535             default:
3536                 style = UTZFMT_STYLE_ISO_EXTENDED_FULL;
3537                 break;
3538             }
3539             const TimeZoneFormat *tzfmt = tzFormat(status);
3540             if (U_SUCCESS(status)) {
3541                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3542                 if (tz != NULL) {
3543                     cal.adoptTimeZone(tz);
3544                     return pos.getIndex();
3545                 }
3546             }
3547             return -start;
3548         }
3549     case UDAT_TIMEZONE_ISO_LOCAL_FIELD: // &#39;x&#39;
3550         {
3551             UTimeZoneFormatStyle style;
3552             switch (count) {
3553             case 1:
3554                 style = UTZFMT_STYLE_ISO_BASIC_LOCAL_SHORT;
3555                 break;
3556             case 2:
3557                 style = UTZFMT_STYLE_ISO_BASIC_LOCAL_FIXED;
3558                 break;
3559             case 3:
3560                 style = UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FIXED;
3561                 break;
3562             case 4:
3563                 style = UTZFMT_STYLE_ISO_BASIC_LOCAL_FULL;
3564                 break;
3565             default:
3566                 style = UTZFMT_STYLE_ISO_EXTENDED_LOCAL_FULL;
3567                 break;
3568             }
3569             const TimeZoneFormat *tzfmt = tzFormat(status);
3570             if (U_SUCCESS(status)) {
3571                 TimeZone *tz = tzfmt-&gt;parse(style, text, pos, tzTimeType);
3572                 if (tz != NULL) {
3573                     cal.adoptTimeZone(tz);
3574                     return pos.getIndex();
3575                 }
3576             }
3577             return -start;
3578         }
3579     // currently no pattern character is defined for UDAT_TIME_SEPARATOR_FIELD
3580     // so we should not get here. Leave support in for future definition.
3581     case UDAT_TIME_SEPARATOR_FIELD:
3582         {
3583             static const UChar def_sep = DateFormatSymbols::DEFAULT_TIME_SEPARATOR;
3584             static const UChar alt_sep = DateFormatSymbols::ALTERNATE_TIME_SEPARATOR;
3585 
3586             // Try matching a time separator.
3587             int32_t count_sep = 1;
3588             UnicodeString data[3];
3589             fSymbols-&gt;getTimeSeparatorString(data[0]);
3590 
3591             // Add the default, if different from the locale.
3592             if (data[0].compare(&amp;def_sep, 1) != 0) {
3593                 data[count_sep++].setTo(def_sep);
3594             }
3595 
3596             // If lenient, add also the alternate, if different from the locale.
3597             if (isLenient() &amp;&amp; data[0].compare(&amp;alt_sep, 1) != 0) {
3598                 data[count_sep++].setTo(alt_sep);
3599             }
3600 
3601             return matchString(text, start, UCAL_FIELD_COUNT /* =&gt; nothing to set */, data, count_sep, NULL, cal);
3602         }
3603 
3604     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
3605     {
3606         U_ASSERT(dayPeriod != NULL);
3607         int32_t ampmStart = subParse(text, start, 0x61, count,
3608                            obeyCount, allowNegative, ambiguousYear, saveHebrewMonth, cal,
3609                            patLoc, numericLeapMonthFormatter, tzTimeType);
3610 
3611         if (ampmStart &gt; 0) {
3612             return ampmStart;
3613         } else {
3614             int32_t newStart = 0;
3615 
3616             // Only match the first two strings from the day period strings array.
3617             if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3618                 if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fAbbreviatedDayPeriods,
3619                                                         2, *dayPeriod)) &gt; 0) {
3620                     return newStart;
3621                 }
3622             }
3623             if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 5) {
3624                 if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fNarrowDayPeriods,
3625                                                         2, *dayPeriod)) &gt; 0) {
3626                     return newStart;
3627                 }
3628             }
3629             // count == 4, but allow other counts
3630             if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status)) {
3631                 if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fWideDayPeriods,
3632                                                         2, *dayPeriod)) &gt; 0) {
3633                     return newStart;
3634                 }
3635             }
3636 
3637             return -start;
3638         }
3639     }
3640 
3641     case UDAT_FLEXIBLE_DAY_PERIOD_FIELD:
3642     {
3643         U_ASSERT(dayPeriod != NULL);
3644         int32_t newStart = 0;
3645 
3646         if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 3) {
3647             if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fAbbreviatedDayPeriods,
3648                                 fSymbols-&gt;fAbbreviatedDayPeriodsCount, *dayPeriod)) &gt; 0) {
3649                 return newStart;
3650             }
3651         }
3652         if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 5) {
3653             if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fNarrowDayPeriods,
3654                                 fSymbols-&gt;fNarrowDayPeriodsCount, *dayPeriod)) &gt; 0) {
3655                 return newStart;
3656             }
3657         }
3658         if (getBooleanAttribute(UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH, status) || count == 4) {
3659             if ((newStart = matchDayPeriodStrings(text, start, fSymbols-&gt;fWideDayPeriods,
3660                                 fSymbols-&gt;fWideDayPeriodsCount, *dayPeriod)) &gt; 0) {
3661                 return newStart;
3662             }
3663         }
3664 
3665         return -start;
3666     }
3667 
3668     default:
3669         // Handle &quot;generic&quot; fields
3670         // this is now handled below, outside the switch block
3671         break;
3672     }
3673     // Handle &quot;generic&quot; fields:
3674     // switch default case now handled here (outside switch block) to allow
3675     // parsing of some string fields as digits for lenient case
3676 
3677     int32_t parseStart = pos.getIndex();
3678     const UnicodeString* src;
3679     if (obeyCount) {
3680         if ((start+count) &gt; text.length()) {
3681             return -start;
3682         }
3683         text.extractBetween(0, start + count, temp);
3684         src = &amp;temp;
3685     } else {
3686         src = &amp;text;
3687     }
3688     parseInt(*src, number, pos, allowNegative,currentNumberFormat);
3689     if (pos.getIndex() != parseStart) {
3690         int32_t val = number.getLong();
3691 
3692         // Don&#39;t need suffix processing here (as in number processing at the beginning of the function);
3693         // the new fields being handled as numeric values (month, weekdays, quarters) should not have suffixes.
3694 
3695         if (!getBooleanAttribute(UDAT_PARSE_ALLOW_NUMERIC, status)) {
3696             // Check the range of the value
3697             int32_t bias = gFieldRangeBias[patternCharIndex];
3698             if (bias &gt;= 0 &amp;&amp; (val &gt; cal.getMaximum(field) + bias || val &lt; cal.getMinimum(field) + bias)) {
3699                 return -start;
3700             }
3701         }
3702 
3703         // For the following, need to repeat some of the &quot;if (gotNumber)&quot; code above:
3704         // UDAT_[STANDALONE_]MONTH_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_STANDALONE_DAY_FIELD,
3705         // UDAT_[STANDALONE_]QUARTER_FIELD
3706         switch (patternCharIndex) {
3707         case UDAT_MONTH_FIELD:
3708             // See notes under UDAT_MONTH_FIELD case above
3709             if (!strcmp(cal.getType(),&quot;hebrew&quot;)) {
3710                 HebrewCalendar *hc = (HebrewCalendar*)&amp;cal;
3711                 if (cal.isSet(UCAL_YEAR)) {
3712                    UErrorCode monthStatus = U_ZERO_ERROR;
3713                    if (!hc-&gt;isLeapYear(hc-&gt;get(UCAL_YEAR, monthStatus)) &amp;&amp; val &gt;= 6) {
3714                        cal.set(UCAL_MONTH, val);
3715                    } else {
3716                        cal.set(UCAL_MONTH, val - 1);
3717                    }
3718                 } else {
3719                     saveHebrewMonth = val;
3720                 }
3721             } else {
3722                 cal.set(UCAL_MONTH, val - 1);
3723             }
3724             break;
3725         case UDAT_STANDALONE_MONTH_FIELD:
3726             cal.set(UCAL_MONTH, val - 1);
3727             break;
3728         case UDAT_DOW_LOCAL_FIELD:
3729         case UDAT_STANDALONE_DAY_FIELD:
3730             cal.set(UCAL_DOW_LOCAL, val);
3731             break;
3732         case UDAT_QUARTER_FIELD:
3733         case UDAT_STANDALONE_QUARTER_FIELD:
3734              cal.set(UCAL_MONTH, (val - 1) * 3);
3735              break;
3736         case UDAT_RELATED_YEAR_FIELD:
3737             cal.setRelatedYear(val);
3738             break;
3739         default:
3740             cal.set(field, val);
3741             break;
3742         }
3743         return pos.getIndex();
3744     }
3745     return -start;
3746 }
3747 
3748 /**
3749  * Parse an integer using fNumberFormat.  This method is semantically
3750  * const, but actually may modify fNumberFormat.
3751  */
3752 void SimpleDateFormat::parseInt(const UnicodeString&amp; text,
3753                                 Formattable&amp; number,
3754                                 ParsePosition&amp; pos,
3755                                 UBool allowNegative,
3756                                 const NumberFormat *fmt) const {
3757     parseInt(text, number, -1, pos, allowNegative,fmt);
3758 }
3759 
3760 /**
3761  * Parse an integer using fNumberFormat up to maxDigits.
3762  */
3763 void SimpleDateFormat::parseInt(const UnicodeString&amp; text,
3764                                 Formattable&amp; number,
3765                                 int32_t maxDigits,
3766                                 ParsePosition&amp; pos,
3767                                 UBool allowNegative,
3768                                 const NumberFormat *fmt) const {
3769     UnicodeString oldPrefix;
3770     auto* fmtAsDF = dynamic_cast&lt;const DecimalFormat*&gt;(fmt);
3771     LocalPointer&lt;DecimalFormat&gt; df;
3772     if (!allowNegative &amp;&amp; fmtAsDF != nullptr) {
3773         df.adoptInstead(dynamic_cast&lt;DecimalFormat*&gt;(fmtAsDF-&gt;clone()));
3774         if (df.isNull()) {
3775             // Memory allocation error
3776             return;
3777         }
3778         df-&gt;setNegativePrefix(UnicodeString(TRUE, SUPPRESS_NEGATIVE_PREFIX, -1));
3779         fmt = df.getAlias();
3780     }
3781     int32_t oldPos = pos.getIndex();
3782     fmt-&gt;parse(text, number, pos);
3783 
3784     if (maxDigits &gt; 0) {
3785         // adjust the result to fit into
3786         // the maxDigits and move the position back
3787         int32_t nDigits = pos.getIndex() - oldPos;
3788         if (nDigits &gt; maxDigits) {
3789             int32_t val = number.getLong();
3790             nDigits -= maxDigits;
3791             while (nDigits &gt; 0) {
3792                 val /= 10;
3793                 nDigits--;
3794             }
3795             pos.setIndex(oldPos + maxDigits);
3796             number.setLong(val);
3797         }
3798     }
3799 }
3800 
3801 int32_t SimpleDateFormat::countDigits(const UnicodeString&amp; text, int32_t start, int32_t end) const {
3802     int32_t numDigits = 0;
3803     int32_t idx = start;
3804     while (idx &lt; end) {
3805         UChar32 cp = text.char32At(idx);
3806         if (u_isdigit(cp)) {
3807             numDigits++;
3808         }
3809         idx += U16_LENGTH(cp);
3810     }
3811     return numDigits;
3812 }
3813 
3814 //----------------------------------------------------------------------
3815 
3816 void SimpleDateFormat::translatePattern(const UnicodeString&amp; originalPattern,
3817                                         UnicodeString&amp; translatedPattern,
3818                                         const UnicodeString&amp; from,
3819                                         const UnicodeString&amp; to,
3820                                         UErrorCode&amp; status)
3821 {
3822     // run through the pattern and convert any pattern symbols from the version
3823     // in &quot;from&quot; to the corresponding character in &quot;to&quot;.  This code takes
3824     // quoted strings into account (it doesn&#39;t try to translate them), and it signals
3825     // an error if a particular &quot;pattern character&quot; doesn&#39;t appear in &quot;from&quot;.
3826     // Depending on the values of &quot;from&quot; and &quot;to&quot; this can convert from generic
3827     // to localized patterns or localized to generic.
3828     if (U_FAILURE(status)) {
3829         return;
3830     }
3831 
3832     translatedPattern.remove();
3833     UBool inQuote = FALSE;
3834     for (int32_t i = 0; i &lt; originalPattern.length(); ++i) {
3835         UChar c = originalPattern[i];
3836         if (inQuote) {
3837             if (c == QUOTE) {
3838                 inQuote = FALSE;
3839             }
3840         } else {
3841             if (c == QUOTE) {
3842                 inQuote = TRUE;
3843             } else if (isSyntaxChar(c)) {
3844                 int32_t ci = from.indexOf(c);
3845                 if (ci == -1) {
3846                     status = U_INVALID_FORMAT_ERROR;
3847                     return;
3848                 }
3849                 c = to[ci];
3850             }
3851         }
3852         translatedPattern += c;
3853     }
3854     if (inQuote) {
3855         status = U_INVALID_FORMAT_ERROR;
3856         return;
3857     }
3858 }
3859 
3860 //----------------------------------------------------------------------
3861 
3862 UnicodeString&amp;
3863 SimpleDateFormat::toPattern(UnicodeString&amp; result) const
3864 {
3865     result = fPattern;
3866     return result;
3867 }
3868 
3869 //----------------------------------------------------------------------
3870 
3871 UnicodeString&amp;
3872 SimpleDateFormat::toLocalizedPattern(UnicodeString&amp; result,
3873                                      UErrorCode&amp; status) const
3874 {
3875     translatePattern(fPattern, result,
3876                      UnicodeString(DateFormatSymbols::getPatternUChars()),
3877                      fSymbols-&gt;fLocalPatternChars, status);
3878     return result;
3879 }
3880 
3881 //----------------------------------------------------------------------
3882 
3883 void
3884 SimpleDateFormat::applyPattern(const UnicodeString&amp; pattern)
3885 {
3886     fPattern = pattern;
3887     parsePattern();
3888 
3889     // Hack to update use of Gannen year numbering for ja@calendar=japanese -
3890     // use only if format is non-numeric (includes 年) and no other fDateOverride.
3891     if (fCalendar != nullptr &amp;&amp; uprv_strcmp(fCalendar-&gt;getType(),&quot;japanese&quot;) == 0 &amp;&amp;
3892             uprv_strcmp(fLocale.getLanguage(),&quot;ja&quot;) == 0) {
3893         if (fDateOverride==UnicodeString(u&quot;y=jpanyear&quot;) &amp;&amp; !fHasHanYearChar) {
3894             // Gannen numbering is set but new pattern should not use it, unset;
3895             // use procedure from adoptNumberFormat to clear overrides
3896             if (fSharedNumberFormatters) {
3897                 freeSharedNumberFormatters(fSharedNumberFormatters);
3898                 fSharedNumberFormatters = NULL;
3899             }
3900             fDateOverride.setToBogus(); // record status
3901         } else if (fDateOverride.isBogus() &amp;&amp; fHasHanYearChar) {
3902             // No current override (=&gt; no Gannen numbering) but new pattern needs it;
3903             // use procedures from initNUmberFormatters / adoptNumberFormat
3904             umtx_lock(LOCK());
3905             if (fSharedNumberFormatters == NULL) {
3906                 fSharedNumberFormatters = allocSharedNumberFormatters();
3907             }
3908             umtx_unlock(LOCK());
3909             if (fSharedNumberFormatters != NULL) {
3910                 Locale ovrLoc(fLocale.getLanguage(),fLocale.getCountry(),fLocale.getVariant(),&quot;numbers=jpanyear&quot;);
3911                 UErrorCode status = U_ZERO_ERROR;
3912                 const SharedNumberFormat *snf = createSharedNumberFormat(ovrLoc, status);
3913                 if (U_SUCCESS(status)) {
3914                     // Now that we have an appropriate number formatter, fill in the
3915                     // appropriate slot in the number formatters table.
3916                     UDateFormatField patternCharIndex = DateFormatSymbols::getPatternCharIndex(u&#39;y&#39;);
3917                     SharedObject::copyPtr(snf, fSharedNumberFormatters[patternCharIndex]);
3918                     snf-&gt;deleteIfZeroRefCount();
3919                     fDateOverride.setTo(u&quot;y=jpanyear&quot;, -1); // record status
3920                 }
3921             }
3922         }
3923     }
3924 }
3925 
3926 //----------------------------------------------------------------------
3927 
3928 void
3929 SimpleDateFormat::applyLocalizedPattern(const UnicodeString&amp; pattern,
3930                                         UErrorCode &amp;status)
3931 {
3932     translatePattern(pattern, fPattern,
3933                      fSymbols-&gt;fLocalPatternChars,
3934                      UnicodeString(DateFormatSymbols::getPatternUChars()), status);
3935 }
3936 
3937 //----------------------------------------------------------------------
3938 
3939 const DateFormatSymbols*
3940 SimpleDateFormat::getDateFormatSymbols() const
3941 {
3942     return fSymbols;
3943 }
3944 
3945 //----------------------------------------------------------------------
3946 
3947 void
3948 SimpleDateFormat::adoptDateFormatSymbols(DateFormatSymbols* newFormatSymbols)
3949 {
3950     delete fSymbols;
3951     fSymbols = newFormatSymbols;
3952 }
3953 
3954 //----------------------------------------------------------------------
3955 void
3956 SimpleDateFormat::setDateFormatSymbols(const DateFormatSymbols&amp; newFormatSymbols)
3957 {
3958     delete fSymbols;
3959     fSymbols = new DateFormatSymbols(newFormatSymbols);
3960 }
3961 
3962 //----------------------------------------------------------------------
3963 const TimeZoneFormat*
3964 SimpleDateFormat::getTimeZoneFormat(void) const {
3965     // TimeZoneFormat initialization might fail when out of memory.
3966     // If we always initialize TimeZoneFormat instance, we can return
3967     // such status there. For now, this implementation lazily instantiates
3968     // a TimeZoneFormat for performance optimization reasons, but cannot
3969     // propagate such error (probably just out of memory case) to the caller.
3970     UErrorCode status = U_ZERO_ERROR;
3971     return (const TimeZoneFormat*)tzFormat(status);
3972 }
3973 
3974 //----------------------------------------------------------------------
3975 void
3976 SimpleDateFormat::adoptTimeZoneFormat(TimeZoneFormat* timeZoneFormatToAdopt)
3977 {
3978     delete fTimeZoneFormat;
3979     fTimeZoneFormat = timeZoneFormatToAdopt;
3980 }
3981 
3982 //----------------------------------------------------------------------
3983 void
3984 SimpleDateFormat::setTimeZoneFormat(const TimeZoneFormat&amp; newTimeZoneFormat)
3985 {
3986     delete fTimeZoneFormat;
3987     fTimeZoneFormat = new TimeZoneFormat(newTimeZoneFormat);
3988 }
3989 
3990 //----------------------------------------------------------------------
3991 
3992 
3993 void SimpleDateFormat::adoptCalendar(Calendar* calendarToAdopt)
3994 {
3995   UErrorCode status = U_ZERO_ERROR;
3996   Locale calLocale(fLocale);
3997   calLocale.setKeywordValue(&quot;calendar&quot;, calendarToAdopt-&gt;getType(), status);
3998   DateFormatSymbols *newSymbols =
3999           DateFormatSymbols::createForLocale(calLocale, status);
4000   if (U_FAILURE(status)) {
4001       return;
4002   }
4003   DateFormat::adoptCalendar(calendarToAdopt);
4004   delete fSymbols;
4005   fSymbols = newSymbols;
4006   initializeDefaultCentury();  // we need a new century (possibly)
4007 }
4008 
4009 
4010 //----------------------------------------------------------------------
4011 
4012 
4013 // override the DateFormat implementation in order to
4014 // lazily initialize fCapitalizationBrkIter
4015 void
4016 SimpleDateFormat::setContext(UDisplayContext value, UErrorCode&amp; status)
4017 {
4018     DateFormat::setContext(value, status);
4019 #if !UCONFIG_NO_BREAK_ITERATION
4020     if (U_SUCCESS(status)) {
4021         if ( fCapitalizationBrkIter == NULL &amp;&amp; (value==UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
4022                 value==UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU || value==UDISPCTX_CAPITALIZATION_FOR_STANDALONE) ) {
4023             status = U_ZERO_ERROR;
4024             fCapitalizationBrkIter = BreakIterator::createSentenceInstance(fLocale, status);
4025             if (U_FAILURE(status)) {
4026                 delete fCapitalizationBrkIter;
4027                 fCapitalizationBrkIter = NULL;
4028             }
4029         }
4030     }
4031 #endif
4032 }
4033 
4034 
4035 //----------------------------------------------------------------------
4036 
4037 
4038 UBool
4039 SimpleDateFormat::isFieldUnitIgnored(UCalendarDateFields field) const {
4040     return isFieldUnitIgnored(fPattern, field);
4041 }
4042 
4043 
4044 UBool
4045 SimpleDateFormat::isFieldUnitIgnored(const UnicodeString&amp; pattern,
4046                                      UCalendarDateFields field) {
4047     int32_t fieldLevel = fgCalendarFieldToLevel[field];
4048     int32_t level;
4049     UChar ch;
4050     UBool inQuote = FALSE;
4051     UChar prevCh = 0;
4052     int32_t count = 0;
4053 
4054     for (int32_t i = 0; i &lt; pattern.length(); ++i) {
4055         ch = pattern[i];
4056         if (ch != prevCh &amp;&amp; count &gt; 0) {
4057             level = getLevelFromChar(prevCh);
4058             // the larger the level, the smaller the field unit.
4059             if (fieldLevel &lt;= level) {
4060                 return FALSE;
4061             }
4062             count = 0;
4063         }
4064         if (ch == QUOTE) {
4065             if ((i+1) &lt; pattern.length() &amp;&amp; pattern[i+1] == QUOTE) {
4066                 ++i;
4067             } else {
4068                 inQuote = ! inQuote;
4069             }
4070         }
4071         else if (!inQuote &amp;&amp; isSyntaxChar(ch)) {
4072             prevCh = ch;
4073             ++count;
4074         }
4075     }
4076     if (count &gt; 0) {
4077         // last item
4078         level = getLevelFromChar(prevCh);
4079         if (fieldLevel &lt;= level) {
4080             return FALSE;
4081         }
4082     }
4083     return TRUE;
4084 }
4085 
4086 //----------------------------------------------------------------------
4087 
4088 const Locale&amp;
4089 SimpleDateFormat::getSmpFmtLocale(void) const {
4090     return fLocale;
4091 }
4092 
4093 //----------------------------------------------------------------------
4094 
4095 int32_t
4096 SimpleDateFormat::checkIntSuffix(const UnicodeString&amp; text, int32_t start,
4097                                  int32_t patLoc, UBool isNegative) const {
4098     // local variables
4099     UnicodeString suf;
4100     int32_t patternMatch;
4101     int32_t textPreMatch;
4102     int32_t textPostMatch;
4103 
4104     // check that we are still in range
4105     if ( (start &gt; text.length()) ||
4106          (start &lt; 0) ||
4107          (patLoc &lt; 0) ||
4108          (patLoc &gt; fPattern.length())) {
4109         // out of range, don&#39;t advance location in text
4110         return start;
4111     }
4112 
4113     // get the suffix
4114     DecimalFormat* decfmt = dynamic_cast&lt;DecimalFormat*&gt;(fNumberFormat);
4115     if (decfmt != NULL) {
4116         if (isNegative) {
4117             suf = decfmt-&gt;getNegativeSuffix(suf);
4118         }
4119         else {
4120             suf = decfmt-&gt;getPositiveSuffix(suf);
4121         }
4122     }
4123 
4124     // check for suffix
4125     if (suf.length() &lt;= 0) {
4126         return start;
4127     }
4128 
4129     // check suffix will be encountered in the pattern
4130     patternMatch = compareSimpleAffix(suf,fPattern,patLoc);
4131 
4132     // check if a suffix will be encountered in the text
4133     textPreMatch = compareSimpleAffix(suf,text,start);
4134 
4135     // check if a suffix was encountered in the text
4136     textPostMatch = compareSimpleAffix(suf,text,start-suf.length());
4137 
4138     // check for suffix match
4139     if ((textPreMatch &gt;= 0) &amp;&amp; (patternMatch &gt;= 0) &amp;&amp; (textPreMatch == patternMatch)) {
4140         return start;
4141     }
4142     else if ((textPostMatch &gt;= 0) &amp;&amp; (patternMatch &gt;= 0) &amp;&amp; (textPostMatch == patternMatch)) {
4143         return  start - suf.length();
4144     }
4145 
4146     // should not get here
4147     return start;
4148 }
4149 
4150 //----------------------------------------------------------------------
4151 
4152 int32_t
4153 SimpleDateFormat::compareSimpleAffix(const UnicodeString&amp; affix,
4154                    const UnicodeString&amp; input,
4155                    int32_t pos) const {
4156     int32_t start = pos;
4157     for (int32_t i=0; i&lt;affix.length(); ) {
4158         UChar32 c = affix.char32At(i);
4159         int32_t len = U16_LENGTH(c);
4160         if (PatternProps::isWhiteSpace(c)) {
4161             // We may have a pattern like: \u200F \u0020
4162             //        and input text like: \u200F \u0020
4163             // Note that U+200F and U+0020 are Pattern_White_Space but only
4164             // U+0020 is UWhiteSpace.  So we have to first do a direct
4165             // match of the run of Pattern_White_Space in the pattern,
4166             // then match any extra characters.
4167             UBool literalMatch = FALSE;
4168             while (pos &lt; input.length() &amp;&amp;
4169                    input.char32At(pos) == c) {
4170                 literalMatch = TRUE;
4171                 i += len;
4172                 pos += len;
4173                 if (i == affix.length()) {
4174                     break;
4175                 }
4176                 c = affix.char32At(i);
4177                 len = U16_LENGTH(c);
4178                 if (!PatternProps::isWhiteSpace(c)) {
4179                     break;
4180                 }
4181             }
4182 
4183             // Advance over run in pattern
4184             i = skipPatternWhiteSpace(affix, i);
4185 
4186             // Advance over run in input text
4187             // Must see at least one white space char in input,
4188             // unless we&#39;ve already matched some characters literally.
4189             int32_t s = pos;
4190             pos = skipUWhiteSpace(input, pos);
4191             if (pos == s &amp;&amp; !literalMatch) {
4192                 return -1;
4193             }
4194 
4195             // If we skip UWhiteSpace in the input text, we need to skip it in the pattern.
4196             // Otherwise, the previous lines may have skipped over text (such as U+00A0) that
4197             // is also in the affix.
4198             i = skipUWhiteSpace(affix, i);
4199         } else {
4200             if (pos &lt; input.length() &amp;&amp;
4201                 input.char32At(pos) == c) {
4202                 i += len;
4203                 pos += len;
4204             } else {
4205                 return -1;
4206             }
4207         }
4208     }
4209     return pos - start;
4210 }
4211 
4212 //----------------------------------------------------------------------
4213 
4214 int32_t
4215 SimpleDateFormat::skipPatternWhiteSpace(const UnicodeString&amp; text, int32_t pos) const {
4216     const UChar* s = text.getBuffer();
4217     return (int32_t)(PatternProps::skipWhiteSpace(s + pos, text.length() - pos) - s);
4218 }
4219 
4220 //----------------------------------------------------------------------
4221 
4222 int32_t
4223 SimpleDateFormat::skipUWhiteSpace(const UnicodeString&amp; text, int32_t pos) const {
4224     while (pos &lt; text.length()) {
4225         UChar32 c = text.char32At(pos);
4226         if (!u_isUWhiteSpace(c)) {
4227             break;
4228         }
4229         pos += U16_LENGTH(c);
4230     }
4231     return pos;
4232 }
4233 
4234 //----------------------------------------------------------------------
4235 
4236 // Lazy TimeZoneFormat instantiation, semantically const.
4237 TimeZoneFormat *
4238 SimpleDateFormat::tzFormat(UErrorCode &amp;status) const {
4239     if (fTimeZoneFormat == NULL) {
4240         umtx_lock(LOCK());
4241         {
4242             if (fTimeZoneFormat == NULL) {
4243                 TimeZoneFormat *tzfmt = TimeZoneFormat::createInstance(fLocale, status);
4244                 if (U_FAILURE(status)) {
4245                     return NULL;
4246                 }
4247 
4248                 const_cast&lt;SimpleDateFormat *&gt;(this)-&gt;fTimeZoneFormat = tzfmt;
4249             }
4250         }
4251         umtx_unlock(LOCK());
4252     }
4253     return fTimeZoneFormat;
4254 }
4255 
4256 void SimpleDateFormat::parsePattern() {
4257     fHasMinute = FALSE;
4258     fHasSecond = FALSE;
4259     fHasHanYearChar = FALSE;
4260 
4261     int len = fPattern.length();
4262     UBool inQuote = FALSE;
4263     for (int32_t i = 0; i &lt; len; ++i) {
4264         UChar ch = fPattern[i];
4265         if (ch == QUOTE) {
4266             inQuote = !inQuote;
4267         }
4268         if (ch == 0x5E74) { // don&#39;t care whether this is inside quotes
4269             fHasHanYearChar = TRUE;
4270         }
4271         if (!inQuote) {
4272             if (ch == 0x6D) {  // 0x6D == &#39;m&#39;
4273                 fHasMinute = TRUE;
4274             }
4275             if (ch == 0x73) {  // 0x73 == &#39;s&#39;
4276                 fHasSecond = TRUE;
4277             }
4278         }
4279     }
4280 }
4281 
4282 U_NAMESPACE_END
4283 
4284 #endif /* #if !UCONFIG_NO_FORMATTING */
4285 
4286 //eof
    </pre>
  </body>
</html>