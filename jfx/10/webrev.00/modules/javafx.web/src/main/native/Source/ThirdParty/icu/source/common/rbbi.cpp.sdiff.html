<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbi.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="putilimp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbi_cache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/common/rbbi.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 // © 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ***************************************************************************
   5 *   Copyright (C) 1999-2016 International Business Machines Corporation
   6 *   and others. All rights reserved.
   7 ***************************************************************************
   8 */
   9 //
  10 //  file:  rbbi.cpp  Contains the implementation of the rule based break iterator
  11 //                   runtime engine and the API implementation for
  12 //                   class RuleBasedBreakIterator
  13 //
  14 
  15 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  16 
  17 #include &quot;unicode/utypes.h&quot;
  18 
  19 #if !UCONFIG_NO_BREAK_ITERATION
  20 


  21 #include &quot;unicode/rbbi.h&quot;
  22 #include &quot;unicode/schriter.h&quot;
  23 #include &quot;unicode/uchriter.h&quot;
  24 #include &quot;unicode/uclean.h&quot;
  25 #include &quot;unicode/udata.h&quot;
  26 
  27 #include &quot;brkeng.h&quot;
  28 #include &quot;ucln_cmn.h&quot;
  29 #include &quot;cmemory.h&quot;
  30 #include &quot;cstring.h&quot;

  31 #include &quot;rbbidata.h&quot;
  32 #include &quot;rbbi_cache.h&quot;
  33 #include &quot;rbbirb.h&quot;
  34 #include &quot;uassert.h&quot;
  35 #include &quot;umutex.h&quot;
  36 #include &quot;uvectr32.h&quot;
  37 
<span class="line-removed">  38 // if U_LOCAL_SERVICE_HOOK is defined, then localsvc.cpp is expected to be included.</span>
<span class="line-removed">  39 #if U_LOCAL_SERVICE_HOOK</span>
<span class="line-removed">  40 #include &quot;localsvc.h&quot;</span>
<span class="line-removed">  41 #endif</span>
<span class="line-removed">  42 </span>
  43 #ifdef RBBI_DEBUG
  44 static UBool gTrace = FALSE;
  45 #endif
  46 
  47 U_NAMESPACE_BEGIN
  48 
  49 // The state number of the starting state
  50 constexpr int32_t START_STATE = 1;
  51 
  52 // The state-transition value indicating &quot;stop&quot;
  53 constexpr int32_t STOP_STATE = 0;
  54 
  55 
  56 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedBreakIterator)
  57 
  58 
  59 //=======================================================================
  60 // constructors
  61 //=======================================================================
  62 
</pre>
<hr />
<pre>
 611     UErrorCode status = U_ZERO_ERROR;
 612     fBreakCache-&gt;following(startPos, status);
 613     return fDone ? UBRK_DONE : fPosition;
 614 }
 615 
 616 /**
 617  * Sets the iterator to refer to the last boundary position before the
 618  * specified position.
 619  * @param offset The position to begin searching for a break from.
 620  * @return The position of the last boundary before the starting position.
 621  */
 622 int32_t RuleBasedBreakIterator::preceding(int32_t offset) {
 623     if (offset &gt; utext_nativeLength(&amp;fText)) {
 624         return last();
 625     }
 626 
 627     // Move requested offset to a code point start. It might be on a trail surrogate,
 628     // or on a trail byte if the input is UTF-8.
 629 
 630     utext_setNativeIndex(&amp;fText, offset);
<span class="line-modified"> 631     int32_t adjustedOffset = utext_getNativeIndex(&amp;fText);</span>
 632 
 633     UErrorCode status = U_ZERO_ERROR;
 634     fBreakCache-&gt;preceding(adjustedOffset, status);
 635     return fDone ? UBRK_DONE : fPosition;
 636 }
 637 
 638 /**
 639  * Returns true if the specfied position is a boundary position.  As a side
 640  * effect, leaves the iterator pointing to the first boundary position at
 641  * or after &quot;offset&quot;.
 642  *
 643  * @param offset the offset to check.
 644  * @return True if &quot;offset&quot; is a boundary position.
 645  */
 646 UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {
 647     // out-of-range indexes are never boundary positions
 648     if (offset &lt; 0) {
 649         first();       // For side effects on current position, tag values.
 650         return FALSE;
 651     }
 652 
 653     // Adjust offset to be on a code point boundary and not beyond the end of the text.
 654     // Note that isBoundary() is always false for offsets that are not on code point boundaries.
 655     // But we still need the side effect of leaving iteration at the following boundary.
 656 
 657     utext_setNativeIndex(&amp;fText, offset);
<span class="line-modified"> 658     int32_t adjustedOffset = utext_getNativeIndex(&amp;fText);</span>
 659 
 660     bool result = false;
 661     UErrorCode status = U_ZERO_ERROR;
 662     if (fBreakCache-&gt;seek(adjustedOffset) || fBreakCache-&gt;populateNear(adjustedOffset, status)) {
 663         result = (fBreakCache-&gt;current() == offset);
 664     }
 665 
 666     if (result &amp;&amp; adjustedOffset &lt; offset &amp;&amp; utext_char32At(&amp;fText, offset) == U_SENTINEL) {
 667         // Original offset is beyond the end of the text. Return FALSE, it&#39;s not a boundary,
 668         // but the iteration position remains set to the end of the text, which is a boundary.
 669         return FALSE;
 670     }
 671     if (!result) {
 672         // Not on a boundary. isBoundary() must leave iterator on the following boundary.
 673         // Cache-&gt;seek(), above, left us on the preceding boundary, so advance one.
 674         next();
 675     }
 676     return result;
 677 }
 678 
</pre>
<hr />
<pre>
 701     RBBI_END        // state machine processing is after end of user text.
 702 };
 703 
 704 
 705 // Map from look-ahead break states (corresponds to rules) to boundary positions.
 706 // Allows multiple lookahead break rules to be in flight at the same time.
 707 //
 708 // This is a temporary approach for ICU 57. A better fix is to make the look-ahead numbers
 709 // in the state table be sequential, then we can just index an array. And the
 710 // table could also tell us in advance how big that array needs to be.
 711 //
 712 // Before ICU 57 there was just a single simple variable for a look-ahead match that
 713 // was in progress. Two rules at once did not work.
 714 
 715 static const int32_t kMaxLookaheads = 8;
 716 struct LookAheadResults {
 717     int32_t    fUsedSlotLimit;
 718     int32_t    fPositions[8];
 719     int16_t    fKeys[8];
 720 
<span class="line-modified"> 721     LookAheadResults() : fUsedSlotLimit(0), fPositions(), fKeys() {};</span>
 722 
 723     int32_t getPosition(int16_t key) {
 724         for (int32_t i=0; i&lt;fUsedSlotLimit; ++i) {
 725             if (fKeys[i] == key) {
 726                 return fPositions[i];
 727             }
 728         }
<span class="line-modified"> 729         U_ASSERT(FALSE);</span>
<span class="line-removed"> 730         return -1;</span>
 731     }
 732 
 733     void setPosition(int16_t key, int32_t position) {
 734         int32_t i;
 735         for (i=0; i&lt;fUsedSlotLimit; ++i) {
 736             if (fKeys[i] == key) {
 737                 fPositions[i] = position;
 738                 return;
 739             }
 740         }
 741         if (i &gt;= kMaxLookaheads) {
<span class="line-modified"> 742             U_ASSERT(FALSE);</span>
<span class="line-removed"> 743             i = kMaxLookaheads - 1;</span>
 744         }
 745         fKeys[i] = key;
 746         fPositions[i] = position;
 747         U_ASSERT(fUsedSlotLimit == i);
 748         fUsedSlotLimit = i + 1;
 749     }
 750 };
 751 
 752 
 753 //-----------------------------------------------------------------------------------
 754 //
 755 //  handleNext()
 756 //     Run the state machine to find a boundary
 757 //
 758 //-----------------------------------------------------------------------------------
 759 int32_t RuleBasedBreakIterator::handleNext() {
 760     int32_t             state;
 761     uint16_t            category        = 0;
 762     RBBIRunMode         mode;
 763 
</pre>
<hr />
<pre>
 831             // which column in the state table to look at.
 832             // Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,
 833             //        not the size of the character going in, which is a UChar32.
 834             //
 835             category = UTRIE2_GET16(fData-&gt;fTrie, c);
 836 
 837             // Check the dictionary bit in the character&#39;s category.
 838             //    Counter is only used by dictionary based iteration.
 839             //    Chars that need to be handled by a dictionary have a flag bit set
 840             //    in their category values.
 841             //
 842             if ((category &amp; 0x4000) != 0)  {
 843                 fDictionaryCharCount++;
 844                 //  And off the dictionary flag bit.
 845                 category &amp;= ~0x4000;
 846             }
 847         }
 848 
 849        #ifdef RBBI_DEBUG
 850             if (gTrace) {
<span class="line-modified"> 851                 RBBIDebugPrintf(&quot;             %4ld   &quot;, utext_getNativeIndex(&amp;fText));</span>
 852                 if (0x20&lt;=c &amp;&amp; c&lt;0x7f) {
 853                     RBBIDebugPrintf(&quot;\&quot;%c\&quot;  &quot;, c);
 854                 } else {
 855                     RBBIDebugPrintf(&quot;%5x  &quot;, c);
 856                 }
 857                 RBBIDebugPrintf(&quot;%3d  %3d\n&quot;, state, category);
 858             }
 859         #endif
 860 
 861         // State Transition - move machine to its next state
 862         //
 863 
 864         // fNextState is a variable-length array.
 865         U_ASSERT(category&lt;fData-&gt;fHeader-&gt;fCatCount);
 866         state = row-&gt;fNextState[category];  /*Not accessing beyond memory*/
 867         row = (RBBIStateTableRow *)
 868             // (statetable-&gt;fTableData + (statetable-&gt;fRowLen * state));
 869             (tableData + tableRowLen * state);
 870 
 871 
</pre>
</td>
<td>
<hr />
<pre>
   1 // © 2016 and later: Unicode, Inc. and others.
   2 // License &amp; terms of use: http://www.unicode.org/copyright.html
   3 /*
   4 ***************************************************************************
   5 *   Copyright (C) 1999-2016 International Business Machines Corporation
   6 *   and others. All rights reserved.
   7 ***************************************************************************
   8 */
   9 //
  10 //  file:  rbbi.cpp  Contains the implementation of the rule based break iterator
  11 //                   runtime engine and the API implementation for
  12 //                   class RuleBasedBreakIterator
  13 //
  14 
  15 #include &quot;utypeinfo.h&quot;  // for &#39;typeid&#39; to work
  16 
  17 #include &quot;unicode/utypes.h&quot;
  18 
  19 #if !UCONFIG_NO_BREAK_ITERATION
  20 
<span class="line-added">  21 #include &lt;cinttypes&gt;</span>
<span class="line-added">  22 </span>
  23 #include &quot;unicode/rbbi.h&quot;
  24 #include &quot;unicode/schriter.h&quot;
  25 #include &quot;unicode/uchriter.h&quot;
  26 #include &quot;unicode/uclean.h&quot;
  27 #include &quot;unicode/udata.h&quot;
  28 
  29 #include &quot;brkeng.h&quot;
  30 #include &quot;ucln_cmn.h&quot;
  31 #include &quot;cmemory.h&quot;
  32 #include &quot;cstring.h&quot;
<span class="line-added">  33 #include &quot;localsvc.h&quot;</span>
  34 #include &quot;rbbidata.h&quot;
  35 #include &quot;rbbi_cache.h&quot;
  36 #include &quot;rbbirb.h&quot;
  37 #include &quot;uassert.h&quot;
  38 #include &quot;umutex.h&quot;
  39 #include &quot;uvectr32.h&quot;
  40 





  41 #ifdef RBBI_DEBUG
  42 static UBool gTrace = FALSE;
  43 #endif
  44 
  45 U_NAMESPACE_BEGIN
  46 
  47 // The state number of the starting state
  48 constexpr int32_t START_STATE = 1;
  49 
  50 // The state-transition value indicating &quot;stop&quot;
  51 constexpr int32_t STOP_STATE = 0;
  52 
  53 
  54 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedBreakIterator)
  55 
  56 
  57 //=======================================================================
  58 // constructors
  59 //=======================================================================
  60 
</pre>
<hr />
<pre>
 609     UErrorCode status = U_ZERO_ERROR;
 610     fBreakCache-&gt;following(startPos, status);
 611     return fDone ? UBRK_DONE : fPosition;
 612 }
 613 
 614 /**
 615  * Sets the iterator to refer to the last boundary position before the
 616  * specified position.
 617  * @param offset The position to begin searching for a break from.
 618  * @return The position of the last boundary before the starting position.
 619  */
 620 int32_t RuleBasedBreakIterator::preceding(int32_t offset) {
 621     if (offset &gt; utext_nativeLength(&amp;fText)) {
 622         return last();
 623     }
 624 
 625     // Move requested offset to a code point start. It might be on a trail surrogate,
 626     // or on a trail byte if the input is UTF-8.
 627 
 628     utext_setNativeIndex(&amp;fText, offset);
<span class="line-modified"> 629     int32_t adjustedOffset = static_cast&lt;int32_t&gt;(utext_getNativeIndex(&amp;fText));</span>
 630 
 631     UErrorCode status = U_ZERO_ERROR;
 632     fBreakCache-&gt;preceding(adjustedOffset, status);
 633     return fDone ? UBRK_DONE : fPosition;
 634 }
 635 
 636 /**
 637  * Returns true if the specfied position is a boundary position.  As a side
 638  * effect, leaves the iterator pointing to the first boundary position at
 639  * or after &quot;offset&quot;.
 640  *
 641  * @param offset the offset to check.
 642  * @return True if &quot;offset&quot; is a boundary position.
 643  */
 644 UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {
 645     // out-of-range indexes are never boundary positions
 646     if (offset &lt; 0) {
 647         first();       // For side effects on current position, tag values.
 648         return FALSE;
 649     }
 650 
 651     // Adjust offset to be on a code point boundary and not beyond the end of the text.
 652     // Note that isBoundary() is always false for offsets that are not on code point boundaries.
 653     // But we still need the side effect of leaving iteration at the following boundary.
 654 
 655     utext_setNativeIndex(&amp;fText, offset);
<span class="line-modified"> 656     int32_t adjustedOffset = static_cast&lt;int32_t&gt;(utext_getNativeIndex(&amp;fText));</span>
 657 
 658     bool result = false;
 659     UErrorCode status = U_ZERO_ERROR;
 660     if (fBreakCache-&gt;seek(adjustedOffset) || fBreakCache-&gt;populateNear(adjustedOffset, status)) {
 661         result = (fBreakCache-&gt;current() == offset);
 662     }
 663 
 664     if (result &amp;&amp; adjustedOffset &lt; offset &amp;&amp; utext_char32At(&amp;fText, offset) == U_SENTINEL) {
 665         // Original offset is beyond the end of the text. Return FALSE, it&#39;s not a boundary,
 666         // but the iteration position remains set to the end of the text, which is a boundary.
 667         return FALSE;
 668     }
 669     if (!result) {
 670         // Not on a boundary. isBoundary() must leave iterator on the following boundary.
 671         // Cache-&gt;seek(), above, left us on the preceding boundary, so advance one.
 672         next();
 673     }
 674     return result;
 675 }
 676 
</pre>
<hr />
<pre>
 699     RBBI_END        // state machine processing is after end of user text.
 700 };
 701 
 702 
 703 // Map from look-ahead break states (corresponds to rules) to boundary positions.
 704 // Allows multiple lookahead break rules to be in flight at the same time.
 705 //
 706 // This is a temporary approach for ICU 57. A better fix is to make the look-ahead numbers
 707 // in the state table be sequential, then we can just index an array. And the
 708 // table could also tell us in advance how big that array needs to be.
 709 //
 710 // Before ICU 57 there was just a single simple variable for a look-ahead match that
 711 // was in progress. Two rules at once did not work.
 712 
 713 static const int32_t kMaxLookaheads = 8;
 714 struct LookAheadResults {
 715     int32_t    fUsedSlotLimit;
 716     int32_t    fPositions[8];
 717     int16_t    fKeys[8];
 718 
<span class="line-modified"> 719     LookAheadResults() : fUsedSlotLimit(0), fPositions(), fKeys() {}</span>
 720 
 721     int32_t getPosition(int16_t key) {
 722         for (int32_t i=0; i&lt;fUsedSlotLimit; ++i) {
 723             if (fKeys[i] == key) {
 724                 return fPositions[i];
 725             }
 726         }
<span class="line-modified"> 727         UPRV_UNREACHABLE;</span>

 728     }
 729 
 730     void setPosition(int16_t key, int32_t position) {
 731         int32_t i;
 732         for (i=0; i&lt;fUsedSlotLimit; ++i) {
 733             if (fKeys[i] == key) {
 734                 fPositions[i] = position;
 735                 return;
 736             }
 737         }
 738         if (i &gt;= kMaxLookaheads) {
<span class="line-modified"> 739             UPRV_UNREACHABLE;</span>

 740         }
 741         fKeys[i] = key;
 742         fPositions[i] = position;
 743         U_ASSERT(fUsedSlotLimit == i);
 744         fUsedSlotLimit = i + 1;
 745     }
 746 };
 747 
 748 
 749 //-----------------------------------------------------------------------------------
 750 //
 751 //  handleNext()
 752 //     Run the state machine to find a boundary
 753 //
 754 //-----------------------------------------------------------------------------------
 755 int32_t RuleBasedBreakIterator::handleNext() {
 756     int32_t             state;
 757     uint16_t            category        = 0;
 758     RBBIRunMode         mode;
 759 
</pre>
<hr />
<pre>
 827             // which column in the state table to look at.
 828             // Note:  the 16 in UTRIE_GET16 refers to the size of the data being returned,
 829             //        not the size of the character going in, which is a UChar32.
 830             //
 831             category = UTRIE2_GET16(fData-&gt;fTrie, c);
 832 
 833             // Check the dictionary bit in the character&#39;s category.
 834             //    Counter is only used by dictionary based iteration.
 835             //    Chars that need to be handled by a dictionary have a flag bit set
 836             //    in their category values.
 837             //
 838             if ((category &amp; 0x4000) != 0)  {
 839                 fDictionaryCharCount++;
 840                 //  And off the dictionary flag bit.
 841                 category &amp;= ~0x4000;
 842             }
 843         }
 844 
 845        #ifdef RBBI_DEBUG
 846             if (gTrace) {
<span class="line-modified"> 847                 RBBIDebugPrintf(&quot;             %4&quot; PRId64 &quot;   &quot;, utext_getNativeIndex(&amp;fText));</span>
 848                 if (0x20&lt;=c &amp;&amp; c&lt;0x7f) {
 849                     RBBIDebugPrintf(&quot;\&quot;%c\&quot;  &quot;, c);
 850                 } else {
 851                     RBBIDebugPrintf(&quot;%5x  &quot;, c);
 852                 }
 853                 RBBIDebugPrintf(&quot;%3d  %3d\n&quot;, state, category);
 854             }
 855         #endif
 856 
 857         // State Transition - move machine to its next state
 858         //
 859 
 860         // fNextState is a variable-length array.
 861         U_ASSERT(category&lt;fData-&gt;fHeader-&gt;fCatCount);
 862         state = row-&gt;fNextState[category];  /*Not accessing beyond memory*/
 863         row = (RBBIStateTableRow *)
 864             // (statetable-&gt;fTableData + (statetable-&gt;fRowLen * state));
 865             (tableData + tableRowLen * state);
 866 
 867 
</pre>
</td>
</tr>
</table>
<center><a href="putilimp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="rbbi_cache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>