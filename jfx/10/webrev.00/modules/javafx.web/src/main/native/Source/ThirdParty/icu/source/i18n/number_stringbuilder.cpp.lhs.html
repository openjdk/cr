<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/icu/source/i18n/number_stringbuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // © 2017 and later: Unicode, Inc. and others.
  2 // License &amp; terms of use: http://www.unicode.org/copyright.html
  3 
  4 #include &quot;unicode/utypes.h&quot;
  5 
  6 #if !UCONFIG_NO_FORMATTING
  7 
  8 #include &quot;number_stringbuilder.h&quot;
<a name="1" id="anc1"></a>
  9 #include &quot;unicode/utf16.h&quot;
<a name="2" id="anc2"></a>
 10 
 11 using namespace icu;
 12 using namespace icu::number;
 13 using namespace icu::number::impl;
 14 
 15 namespace {
 16 
 17 // A version of uprv_memcpy that checks for length 0.
 18 // By default, uprv_memcpy requires a length of at least 1.
 19 inline void uprv_memcpy2(void* dest, const void* src, size_t len) {
 20     if (len &gt; 0) {
 21         uprv_memcpy(dest, src, len);
 22     }
 23 }
 24 
 25 // A version of uprv_memmove that checks for length 0.
 26 // By default, uprv_memmove requires a length of at least 1.
 27 inline void uprv_memmove2(void* dest, const void* src, size_t len) {
 28     if (len &gt; 0) {
 29         uprv_memmove(dest, src, len);
 30     }
 31 }
 32 
 33 } // namespace
 34 
<a name="3" id="anc3"></a><span class="line-modified"> 35 NumberStringBuilder::NumberStringBuilder() = default;</span>








 36 
 37 NumberStringBuilder::~NumberStringBuilder() {
 38     if (fUsingHeap) {
 39         uprv_free(fChars.heap.ptr);
 40         uprv_free(fFields.heap.ptr);
 41     }
 42 }
 43 
 44 NumberStringBuilder::NumberStringBuilder(const NumberStringBuilder &amp;other) {
 45     *this = other;
 46 }
 47 
 48 NumberStringBuilder &amp;NumberStringBuilder::operator=(const NumberStringBuilder &amp;other) {
 49     // Check for self-assignment
 50     if (this == &amp;other) {
 51         return *this;
 52     }
 53 
 54     // Continue with deallocation and copying
 55     if (fUsingHeap) {
 56         uprv_free(fChars.heap.ptr);
 57         uprv_free(fFields.heap.ptr);
 58         fUsingHeap = false;
 59     }
 60 
 61     int32_t capacity = other.getCapacity();
 62     if (capacity &gt; DEFAULT_CAPACITY) {
 63         // FIXME: uprv_malloc
 64         // C++ note: malloc appears in two places: here and in prepareForInsertHelper.
 65         auto newChars = static_cast&lt;char16_t *&gt; (uprv_malloc(sizeof(char16_t) * capacity));
 66         auto newFields = static_cast&lt;Field *&gt;(uprv_malloc(sizeof(Field) * capacity));
 67         if (newChars == nullptr || newFields == nullptr) {
 68             // UErrorCode is not available; fail silently.
 69             uprv_free(newChars);
 70             uprv_free(newFields);
 71             *this = NumberStringBuilder();  // can&#39;t fail
 72             return *this;
 73         }
 74 
 75         fUsingHeap = true;
 76         fChars.heap.capacity = capacity;
 77         fChars.heap.ptr = newChars;
 78         fFields.heap.capacity = capacity;
 79         fFields.heap.ptr = newFields;
 80     }
 81 
 82     uprv_memcpy2(getCharPtr(), other.getCharPtr(), sizeof(char16_t) * capacity);
 83     uprv_memcpy2(getFieldPtr(), other.getFieldPtr(), sizeof(Field) * capacity);
 84 
 85     fZero = other.fZero;
 86     fLength = other.fLength;
 87     return *this;
 88 }
 89 
 90 int32_t NumberStringBuilder::length() const {
 91     return fLength;
 92 }
 93 
 94 int32_t NumberStringBuilder::codePointCount() const {
 95     return u_countChar32(getCharPtr() + fZero, fLength);
 96 }
 97 
 98 UChar32 NumberStringBuilder::getFirstCodePoint() const {
 99     if (fLength == 0) {
100         return -1;
101     }
102     UChar32 cp;
103     U16_GET(getCharPtr() + fZero, 0, 0, fLength, cp);
104     return cp;
105 }
106 
107 UChar32 NumberStringBuilder::getLastCodePoint() const {
108     if (fLength == 0) {
109         return -1;
110     }
111     int32_t offset = fLength;
112     U16_BACK_1(getCharPtr() + fZero, 0, offset);
113     UChar32 cp;
114     U16_GET(getCharPtr() + fZero, 0, offset, fLength, cp);
115     return cp;
116 }
117 
118 UChar32 NumberStringBuilder::codePointAt(int32_t index) const {
119     UChar32 cp;
120     U16_GET(getCharPtr() + fZero, 0, index, fLength, cp);
121     return cp;
122 }
123 
124 UChar32 NumberStringBuilder::codePointBefore(int32_t index) const {
125     int32_t offset = index;
126     U16_BACK_1(getCharPtr() + fZero, 0, offset);
127     UChar32 cp;
128     U16_GET(getCharPtr() + fZero, 0, offset, fLength, cp);
129     return cp;
130 }
131 
132 NumberStringBuilder &amp;NumberStringBuilder::clear() {
133     // TODO: Reset the heap here?
134     fZero = getCapacity() / 2;
135     fLength = 0;
136     return *this;
137 }
138 
139 int32_t NumberStringBuilder::appendCodePoint(UChar32 codePoint, Field field, UErrorCode &amp;status) {
140     return insertCodePoint(fLength, codePoint, field, status);
141 }
142 
143 int32_t
144 NumberStringBuilder::insertCodePoint(int32_t index, UChar32 codePoint, Field field, UErrorCode &amp;status) {
145     int32_t count = U16_LENGTH(codePoint);
146     int32_t position = prepareForInsert(index, count, status);
147     if (U_FAILURE(status)) {
148         return count;
149     }
150     if (count == 1) {
151         getCharPtr()[position] = (char16_t) codePoint;
152         getFieldPtr()[position] = field;
153     } else {
154         getCharPtr()[position] = U16_LEAD(codePoint);
155         getCharPtr()[position + 1] = U16_TRAIL(codePoint);
156         getFieldPtr()[position] = getFieldPtr()[position + 1] = field;
157     }
158     return count;
159 }
160 
161 int32_t NumberStringBuilder::append(const UnicodeString &amp;unistr, Field field, UErrorCode &amp;status) {
162     return insert(fLength, unistr, field, status);
163 }
164 
165 int32_t NumberStringBuilder::insert(int32_t index, const UnicodeString &amp;unistr, Field field,
166                                     UErrorCode &amp;status) {
167     if (unistr.length() == 0) {
168         // Nothing to insert.
169         return 0;
170     } else if (unistr.length() == 1) {
171         // Fast path: insert using insertCodePoint.
172         return insertCodePoint(index, unistr.charAt(0), field, status);
173     } else {
174         return insert(index, unistr, 0, unistr.length(), field, status);
175     }
176 }
177 
178 int32_t
179 NumberStringBuilder::insert(int32_t index, const UnicodeString &amp;unistr, int32_t start, int32_t end,
180                             Field field, UErrorCode &amp;status) {
181     int32_t count = end - start;
182     int32_t position = prepareForInsert(index, count, status);
183     if (U_FAILURE(status)) {
184         return count;
185     }
186     for (int32_t i = 0; i &lt; count; i++) {
187         getCharPtr()[position + i] = unistr.charAt(start + i);
188         getFieldPtr()[position + i] = field;
189     }
190     return count;
191 }
192 
193 int32_t
194 NumberStringBuilder::splice(int32_t startThis, int32_t endThis,  const UnicodeString &amp;unistr,
195                             int32_t startOther, int32_t endOther, Field field, UErrorCode&amp; status) {
196     int32_t thisLength = endThis - startThis;
197     int32_t otherLength = endOther - startOther;
198     int32_t count = otherLength - thisLength;
199     int32_t position;
200     if (count &gt; 0) {
201         // Overall, chars need to be added.
202         position = prepareForInsert(startThis, count, status);
203     } else {
204         // Overall, chars need to be removed or kept the same.
205         position = remove(startThis, -count);
206     }
207     if (U_FAILURE(status)) {
208         return count;
209     }
210     for (int32_t i = 0; i &lt; otherLength; i++) {
211         getCharPtr()[position + i] = unistr.charAt(startOther + i);
212         getFieldPtr()[position + i] = field;
213     }
214     return count;
215 }
216 
217 int32_t NumberStringBuilder::append(const NumberStringBuilder &amp;other, UErrorCode &amp;status) {
218     return insert(fLength, other, status);
219 }
220 
221 int32_t
222 NumberStringBuilder::insert(int32_t index, const NumberStringBuilder &amp;other, UErrorCode &amp;status) {
223     if (this == &amp;other) {
224         status = U_ILLEGAL_ARGUMENT_ERROR;
225         return 0;
226     }
227     int32_t count = other.fLength;
228     if (count == 0) {
229         // Nothing to insert.
230         return 0;
231     }
232     int32_t position = prepareForInsert(index, count, status);
233     if (U_FAILURE(status)) {
234         return count;
235     }
236     for (int32_t i = 0; i &lt; count; i++) {
237         getCharPtr()[position + i] = other.charAt(i);
238         getFieldPtr()[position + i] = other.fieldAt(i);
239     }
240     return count;
241 }
242 
<a name="4" id="anc4"></a>









243 int32_t NumberStringBuilder::prepareForInsert(int32_t index, int32_t count, UErrorCode &amp;status) {
<a name="5" id="anc5"></a>


244     if (index == 0 &amp;&amp; fZero - count &gt;= 0) {
245         // Append to start
246         fZero -= count;
247         fLength += count;
248         return fZero;
249     } else if (index == fLength &amp;&amp; fZero + fLength + count &lt; getCapacity()) {
250         // Append to end
251         fLength += count;
252         return fZero + fLength - count;
253     } else {
254         // Move chars around and/or allocate more space
255         return prepareForInsertHelper(index, count, status);
256     }
257 }
258 
259 int32_t NumberStringBuilder::prepareForInsertHelper(int32_t index, int32_t count, UErrorCode &amp;status) {
260     int32_t oldCapacity = getCapacity();
261     int32_t oldZero = fZero;
262     char16_t *oldChars = getCharPtr();
263     Field *oldFields = getFieldPtr();
264     if (fLength + count &gt; oldCapacity) {
265         int32_t newCapacity = (fLength + count) * 2;
266         int32_t newZero = newCapacity / 2 - (fLength + count) / 2;
267 
268         // C++ note: malloc appears in two places: here and in the assignment operator.
269         auto newChars = static_cast&lt;char16_t *&gt; (uprv_malloc(sizeof(char16_t) * newCapacity));
270         auto newFields = static_cast&lt;Field *&gt;(uprv_malloc(sizeof(Field) * newCapacity));
271         if (newChars == nullptr || newFields == nullptr) {
272             uprv_free(newChars);
273             uprv_free(newFields);
274             status = U_MEMORY_ALLOCATION_ERROR;
275             return -1;
276         }
277 
278         // First copy the prefix and then the suffix, leaving room for the new chars that the
279         // caller wants to insert.
280         // C++ note: memcpy is OK because the src and dest do not overlap.
281         uprv_memcpy2(newChars + newZero, oldChars + oldZero, sizeof(char16_t) * index);
282         uprv_memcpy2(newChars + newZero + index + count,
283                 oldChars + oldZero + index,
284                 sizeof(char16_t) * (fLength - index));
285         uprv_memcpy2(newFields + newZero, oldFields + oldZero, sizeof(Field) * index);
286         uprv_memcpy2(newFields + newZero + index + count,
287                 oldFields + oldZero + index,
288                 sizeof(Field) * (fLength - index));
289 
290         if (fUsingHeap) {
291             uprv_free(oldChars);
292             uprv_free(oldFields);
293         }
294         fUsingHeap = true;
295         fChars.heap.ptr = newChars;
296         fChars.heap.capacity = newCapacity;
297         fFields.heap.ptr = newFields;
298         fFields.heap.capacity = newCapacity;
299         fZero = newZero;
300         fLength += count;
301     } else {
302         int32_t newZero = oldCapacity / 2 - (fLength + count) / 2;
303 
304         // C++ note: memmove is required because src and dest may overlap.
305         // First copy the entire string to the location of the prefix, and then move the suffix
306         // to make room for the new chars that the caller wants to insert.
307         uprv_memmove2(oldChars + newZero, oldChars + oldZero, sizeof(char16_t) * fLength);
308         uprv_memmove2(oldChars + newZero + index + count,
309                 oldChars + newZero + index,
310                 sizeof(char16_t) * (fLength - index));
311         uprv_memmove2(oldFields + newZero, oldFields + oldZero, sizeof(Field) * fLength);
312         uprv_memmove2(oldFields + newZero + index + count,
313                 oldFields + newZero + index,
314                 sizeof(Field) * (fLength - index));
315 
316         fZero = newZero;
317         fLength += count;
318     }
319     return fZero + index;
320 }
321 
322 int32_t NumberStringBuilder::remove(int32_t index, int32_t count) {
323     // TODO: Reset the heap here?  (If the string after removal can fit on stack?)
324     int32_t position = index + fZero;
325     uprv_memmove2(getCharPtr() + position,
326             getCharPtr() + position + count,
327             sizeof(char16_t) * (fLength - index - count));
328     uprv_memmove2(getFieldPtr() + position,
329             getFieldPtr() + position + count,
330             sizeof(Field) * (fLength - index - count));
331     fLength -= count;
332     return position;
333 }
334 
335 UnicodeString NumberStringBuilder::toUnicodeString() const {
336     return UnicodeString(getCharPtr() + fZero, fLength);
337 }
338 
339 const UnicodeString NumberStringBuilder::toTempUnicodeString() const {
340     // Readonly-alias constructor:
341     return UnicodeString(FALSE, getCharPtr() + fZero, fLength);
342 }
343 
344 UnicodeString NumberStringBuilder::toDebugString() const {
345     UnicodeString sb;
346     sb.append(u&quot;&lt;NumberStringBuilder [&quot;, -1);
347     sb.append(toUnicodeString());
348     sb.append(u&quot;] [&quot;, -1);
349     for (int i = 0; i &lt; fLength; i++) {
350         if (fieldAt(i) == UNUM_FIELD_COUNT) {
351             sb.append(u&#39;n&#39;);
352         } else {
353             char16_t c;
354             switch (fieldAt(i)) {
355                 case UNUM_SIGN_FIELD:
356                     c = u&#39;-&#39;;
357                     break;
358                 case UNUM_INTEGER_FIELD:
359                     c = u&#39;i&#39;;
360                     break;
361                 case UNUM_FRACTION_FIELD:
362                     c = u&#39;f&#39;;
363                     break;
364                 case UNUM_EXPONENT_FIELD:
365                     c = u&#39;e&#39;;
366                     break;
367                 case UNUM_EXPONENT_SIGN_FIELD:
368                     c = u&#39;+&#39;;
369                     break;
370                 case UNUM_EXPONENT_SYMBOL_FIELD:
371                     c = u&#39;E&#39;;
372                     break;
373                 case UNUM_DECIMAL_SEPARATOR_FIELD:
374                     c = u&#39;.&#39;;
375                     break;
376                 case UNUM_GROUPING_SEPARATOR_FIELD:
377                     c = u&#39;,&#39;;
378                     break;
379                 case UNUM_PERCENT_FIELD:
380                     c = u&#39;%&#39;;
381                     break;
382                 case UNUM_PERMILL_FIELD:
383                     c = u&#39;‰&#39;;
384                     break;
385                 case UNUM_CURRENCY_FIELD:
386                     c = u&#39;$&#39;;
387                     break;
388                 default:
389                     c = u&#39;?&#39;;
390                     break;
391             }
392             sb.append(c);
393         }
394     }
395     sb.append(u&quot;]&gt;&quot;, -1);
396     return sb;
397 }
398 
399 const char16_t *NumberStringBuilder::chars() const {
400     return getCharPtr() + fZero;
401 }
402 
403 bool NumberStringBuilder::contentEquals(const NumberStringBuilder &amp;other) const {
404     if (fLength != other.fLength) {
405         return false;
406     }
407     for (int32_t i = 0; i &lt; fLength; i++) {
408         if (charAt(i) != other.charAt(i) || fieldAt(i) != other.fieldAt(i)) {
409             return false;
410         }
411     }
412     return true;
413 }
414 
415 bool NumberStringBuilder::nextFieldPosition(FieldPosition&amp; fp, UErrorCode&amp; status) const {
416     int32_t rawField = fp.getField();
417 
418     if (rawField == FieldPosition::DONT_CARE) {
419         return FALSE;
420     }
421 
422     if (rawField &lt; 0 || rawField &gt;= UNUM_FIELD_COUNT) {
423         status = U_ILLEGAL_ARGUMENT_ERROR;
424         return FALSE;
425     }
426 
<a name="6" id="anc6"></a><span class="line-modified">427     auto field = static_cast&lt;Field&gt;(rawField);</span>







428 
<a name="7" id="anc7"></a><span class="line-modified">429     bool seenStart = false;</span>
<span class="line-modified">430     int32_t fractionStart = -1;</span>
<span class="line-modified">431     int32_t startIndex = fp.getEndIndex();</span>
<span class="line-modified">432     for (int i = fZero + startIndex; i &lt;= fZero + fLength; i++) {</span>
<span class="line-modified">433         Field _field = UNUM_FIELD_COUNT;</span>
<span class="line-modified">434         if (i &lt; fZero + fLength) {</span>
<span class="line-modified">435             _field = getFieldPtr()[i];</span>
<span class="line-modified">436         }</span>
<span class="line-modified">437         if (seenStart &amp;&amp; field != _field) {</span>
<span class="line-removed">438             // Special case: GROUPING_SEPARATOR counts as an INTEGER.</span>
<span class="line-removed">439             if (field == UNUM_INTEGER_FIELD &amp;&amp; _field == UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-removed">440                 continue;</span>
441             }
<a name="8" id="anc8"></a><span class="line-removed">442             fp.setEndIndex(i - fZero);</span>
<span class="line-removed">443             break;</span>
<span class="line-removed">444         } else if (!seenStart &amp;&amp; field == _field) {</span>
<span class="line-removed">445             fp.setBeginIndex(i - fZero);</span>
<span class="line-removed">446             seenStart = true;</span>
447         }
<a name="9" id="anc9"></a><span class="line-modified">448         if (_field == UNUM_INTEGER_FIELD || _field == UNUM_DECIMAL_SEPARATOR_FIELD) {</span>
<span class="line-modified">449             fractionStart = i - fZero + 1;</span>
<span class="line-removed">450         }</span>
<span class="line-removed">451     }</span>
<span class="line-removed">452 </span>
<span class="line-removed">453     // Backwards compatibility: FRACTION needs to start after INTEGER if empty.</span>
<span class="line-removed">454     // Do not return that a field was found, though, since there is not actually a fraction part.</span>
<span class="line-removed">455     if (field == UNUM_FRACTION_FIELD &amp;&amp; !seenStart &amp;&amp; fractionStart != -1) {</span>
<span class="line-removed">456         fp.setBeginIndex(fractionStart);</span>
<span class="line-removed">457         fp.setEndIndex(fractionStart);</span>
458     }
459 
<a name="10" id="anc10"></a><span class="line-modified">460     return seenStart;</span>
461 }
462 
463 void NumberStringBuilder::getAllFieldPositions(FieldPositionIteratorHandler&amp; fpih,
464                                                UErrorCode&amp; status) const {
<a name="11" id="anc11"></a><span class="line-modified">465     Field current = UNUM_FIELD_COUNT;</span>
<span class="line-modified">466     int32_t currentStart = -1;</span>
<span class="line-modified">467     for (int32_t i = 0; i &lt; fLength; i++) {</span>
<span class="line-modified">468         Field field = fieldAt(i);</span>
<span class="line-modified">469         if (current == UNUM_INTEGER_FIELD &amp;&amp; field == UNUM_GROUPING_SEPARATOR_FIELD) {</span>
<span class="line-modified">470             // Special case: GROUPING_SEPARATOR counts as an INTEGER.</span>
<span class="line-modified">471             fpih.addAttribute(UNUM_GROUPING_SEPARATOR_FIELD, i, i + 1);</span>
<span class="line-modified">472         } else if (current != field) {</span>
<span class="line-modified">473             if (current != UNUM_FIELD_COUNT) {</span>
<span class="line-modified">474                 fpih.addAttribute(current, currentStart, i);</span>




























475             }
<a name="12" id="anc12"></a><span class="line-modified">476             current = field;</span>
<span class="line-modified">477             currentStart = i;</span>











478         }
<a name="13" id="anc13"></a><span class="line-modified">479         if (U_FAILURE(status)) {</span>
<span class="line-modified">480             return;</span>


























481         }
482     }
<a name="14" id="anc14"></a><span class="line-modified">483     if (current != UNUM_FIELD_COUNT) {</span>
<span class="line-modified">484         fpih.addAttribute(current, currentStart, fLength);</span>








485     }
<a name="15" id="anc15"></a>























486 }
487 
488 #endif /* #if !UCONFIG_NO_FORMATTING */
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>