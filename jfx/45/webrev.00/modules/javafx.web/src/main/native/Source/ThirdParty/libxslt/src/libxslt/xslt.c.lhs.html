<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xslt.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * xslt.c: Implemetation of an XSL Transformation 1.0 engine
   3  *
   4  * Reference:
   5  *   XSLT specification
   6  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   7  *
   8  *   Associating Style Sheets with XML documents
   9  *   http://www.w3.org/1999/06/REC-xml-stylesheet-19990629
  10  *
  11  * See Copyright for the status of this software.
  12  *
  13  * daniel@veillard.com
  14  */
  15 
  16 #define IN_LIBXSLT
  17 #include &quot;libxslt.h&quot;
  18 
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parser.h&gt;
  23 #include &lt;libxml/tree.h&gt;
  24 #include &lt;libxml/valid.h&gt;
  25 #include &lt;libxml/hash.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/xmlerror.h&gt;
  28 #include &lt;libxml/parserInternals.h&gt;
  29 #include &lt;libxml/xpathInternals.h&gt;
  30 #include &lt;libxml/xpath.h&gt;
  31 #include &quot;xslt.h&quot;
  32 #include &quot;xsltInternals.h&quot;
  33 #include &quot;pattern.h&quot;
  34 #include &quot;variables.h&quot;
  35 #include &quot;namespaces.h&quot;
  36 #include &quot;attributes.h&quot;
  37 #include &quot;xsltutils.h&quot;
  38 #include &quot;imports.h&quot;
  39 #include &quot;keys.h&quot;
  40 #include &quot;documents.h&quot;
  41 #include &quot;extensions.h&quot;
  42 #include &quot;preproc.h&quot;
  43 #include &quot;extra.h&quot;
  44 #include &quot;security.h&quot;
  45 #include &quot;xsltlocale.h&quot;
  46 
  47 #ifdef WITH_XSLT_DEBUG
  48 #define WITH_XSLT_DEBUG_PARSING
  49 /* #define WITH_XSLT_DEBUG_BLANKS */
  50 #endif
  51 
  52 const char *xsltEngineVersion = LIBXSLT_VERSION_STRING LIBXSLT_VERSION_EXTRA;
  53 const int xsltLibxsltVersion = LIBXSLT_VERSION;
  54 const int xsltLibxmlVersion = LIBXML_VERSION;
  55 
  56 #ifdef XSLT_REFACTORED
  57 
  58 const xmlChar *xsltConstNamespaceNameXSLT = (const xmlChar *) XSLT_NAMESPACE;
  59 
  60 #define XSLT_ELEMENT_CATEGORY_XSLT 0
  61 #define XSLT_ELEMENT_CATEGORY_EXTENSION 1
  62 #define XSLT_ELEMENT_CATEGORY_LRE 2
  63 
  64 /*
  65 * xsltLiteralResultMarker:
  66 * Marker for Literal result elements, in order to avoid multiple attempts
  67 * to recognize such elements in the stylesheet&#39;s tree.
  68 * This marker is set on node-&gt;psvi during the initial traversal
  69 * of a stylesheet&#39;s node tree.
  70 *
  71 const xmlChar *xsltLiteralResultMarker =
  72     (const xmlChar *) &quot;Literal Result Element&quot;;
  73 */
  74 
  75 /*
  76 * xsltXSLTTextMarker:
  77 * Marker for xsl:text elements. Used to recognize xsl:text elements
  78 * for post-processing of the stylesheet&#39;s tree, where those
  79 * elements are removed from the tree.
  80 */
  81 const xmlChar *xsltXSLTTextMarker = (const xmlChar *) &quot;XSLT Text Element&quot;;
  82 
  83 /*
  84 * xsltXSLTAttrMarker:
  85 * Marker for XSLT attribute on Literal Result Elements.
  86 */
  87 const xmlChar *xsltXSLTAttrMarker = (const xmlChar *) &quot;LRE XSLT Attr&quot;;
  88 
  89 #endif
  90 
  91 #ifdef XSLT_LOCALE_WINAPI
  92 extern xmlRMutexPtr xsltLocaleMutex;
  93 #endif
  94 /*
  95  * Harmless but avoiding a problem when compiling against a
  96  * libxml &lt;= 2.3.11 without LIBXML_DEBUG_ENABLED
  97  */
  98 #ifndef LIBXML_DEBUG_ENABLED
  99 double xmlXPathStringEvalNumber(const xmlChar *str);
 100 #endif
 101 /*
 102  * Useful macros
 103  */
 104 
 105 #ifdef  IS_BLANK
 106 #undef  IS_BLANK
 107 #endif
 108 #define IS_BLANK(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) ||  \
 109                      ((c) == 0x0D))
 110 
 111 #ifdef  IS_BLANK_NODE
 112 #undef  IS_BLANK_NODE
 113 #endif
 114 #define IS_BLANK_NODE(n)                        \
 115     (((n)-&gt;type == XML_TEXT_NODE) &amp;&amp; (xsltIsBlank((n)-&gt;content)))
 116 
 117 /**
 118  * xsltParseContentError:
 119  *
 120  * @style: the stylesheet
 121  * @node: the node where the error occured
 122  *
 123  * Compile-time error function.
 124  */
 125 static void
 126 xsltParseContentError(xsltStylesheetPtr style,
 127                xmlNodePtr node)
 128 {
 129     if ((style == NULL) || (node == NULL))
 130     return;
 131 
 132     if (IS_XSLT_ELEM(node))
 133     xsltTransformError(NULL, style, node,
 134         &quot;The XSLT-element &#39;%s&#39; is not allowed at this position.\n&quot;,
 135         node-&gt;name);
 136     else
 137     xsltTransformError(NULL, style, node,
 138         &quot;The element &#39;%s&#39; is not allowed at this position.\n&quot;,
 139         node-&gt;name);
 140     style-&gt;errors++;
 141 }
 142 
 143 #ifdef XSLT_REFACTORED
 144 #else
 145 /**
 146  * exclPrefixPush:
 147  * @style: the transformation stylesheet
 148  * @value:  the excluded namespace name to push on the stack
 149  *
 150  * Push an excluded namespace name on the stack
 151  *
 152  * Returns the new index in the stack or -1 if already present or
 153  * in case of error
 154  */
 155 static int
 156 exclPrefixPush(xsltStylesheetPtr style, xmlChar * value)
 157 {
 158     int i;
 159 
 160     if (style-&gt;exclPrefixMax == 0) {
 161         style-&gt;exclPrefixMax = 4;
 162         style-&gt;exclPrefixTab =
 163             (xmlChar * *)xmlMalloc(style-&gt;exclPrefixMax *
 164                                    sizeof(style-&gt;exclPrefixTab[0]));
 165         if (style-&gt;exclPrefixTab == NULL) {
 166             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 167             return (-1);
 168         }
 169     }
 170     /* do not push duplicates */
 171     for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
 172         if (xmlStrEqual(style-&gt;exclPrefixTab[i], value))
 173         return(-1);
 174     }
 175     if (style-&gt;exclPrefixNr &gt;= style-&gt;exclPrefixMax) {
 176         style-&gt;exclPrefixMax *= 2;
 177         style-&gt;exclPrefixTab =
 178             (xmlChar * *)xmlRealloc(style-&gt;exclPrefixTab,
 179                                     style-&gt;exclPrefixMax *
 180                                     sizeof(style-&gt;exclPrefixTab[0]));
 181         if (style-&gt;exclPrefixTab == NULL) {
 182             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 183             return (-1);
 184         }
 185     }
 186     style-&gt;exclPrefixTab[style-&gt;exclPrefixNr] = value;
 187     style-&gt;exclPrefix = value;
 188     return (style-&gt;exclPrefixNr++);
 189 }
 190 /**
 191  * exclPrefixPop:
 192  * @style: the transformation stylesheet
 193  *
 194  * Pop an excluded prefix value from the stack
 195  *
 196  * Returns the stored excluded prefix value
 197  */
 198 static xmlChar *
 199 exclPrefixPop(xsltStylesheetPtr style)
 200 {
 201     xmlChar *ret;
 202 
 203     if (style-&gt;exclPrefixNr &lt;= 0)
 204         return (0);
 205     style-&gt;exclPrefixNr--;
 206     if (style-&gt;exclPrefixNr &gt; 0)
 207         style-&gt;exclPrefix = style-&gt;exclPrefixTab[style-&gt;exclPrefixNr - 1];
 208     else
 209         style-&gt;exclPrefix = NULL;
 210     ret = style-&gt;exclPrefixTab[style-&gt;exclPrefixNr];
 211     style-&gt;exclPrefixTab[style-&gt;exclPrefixNr] = 0;
 212     return (ret);
 213 }
 214 #endif
 215 
 216 /************************************************************************
 217  *                                  *
 218  *          Helper functions                *
 219  *                                  *
 220  ************************************************************************/
 221 
 222 static int initialized = 0;
 223 /**
 224  * xsltInit:
 225  *
 226  * Initializes the processor (e.g. registers built-in extensions,
 227  * etc.)
 228  */
 229 void
 230 xsltInit (void) {
 231     if (initialized == 0) {
 232     initialized = 1;
 233 #ifdef XSLT_LOCALE_WINAPI
 234     xsltLocaleMutex = xmlNewRMutex();
 235 #endif
 236         xsltRegisterAllExtras();
 237     }
 238 }
 239 
 240 /**
 241  * xsltUninit:
 242  *
 243  * Uninitializes the processor.
 244  */
 245 void
 246 xsltUninit (void) {
 247 #ifdef XSLT_LOCALE_WINAPI
 248     xmlFreeRMutex(xsltLocaleMutex);
 249     xsltLocaleMutex = NULL;
 250 #endif
 251     initialized = 0;
 252 }
 253 
 254 /**
 255  * xsltIsBlank:
 256  * @str:  a string
 257  *
 258  * Check if a string is ignorable
 259  *
 260  * Returns 1 if the string is NULL or made of blanks chars, 0 otherwise
 261  */
 262 int
 263 xsltIsBlank(xmlChar *str) {
 264     if (str == NULL)
 265     return(1);
 266     while (*str != 0) {
 267     if (!(IS_BLANK(*str))) return(0);
 268     str++;
 269     }
 270     return(1);
 271 }
 272 
 273 /************************************************************************
 274  *                                  *
 275  *      Routines to handle XSLT data structures         *
 276  *                                  *
 277  ************************************************************************/
 278 static xsltDecimalFormatPtr
 279 xsltNewDecimalFormat(const xmlChar *nsUri, xmlChar *name)
 280 {
 281     xsltDecimalFormatPtr self;
 282     /* UTF-8 for 0x2030 */
 283     static const xmlChar permille[4] = {0xe2, 0x80, 0xb0, 0};
 284 
 285     self = xmlMalloc(sizeof(xsltDecimalFormat));
 286     if (self != NULL) {
 287     self-&gt;next = NULL;
 288         self-&gt;nsUri = nsUri;
 289     self-&gt;name = name;
 290 
 291     /* Default values */
 292     self-&gt;digit = xmlStrdup(BAD_CAST(&quot;#&quot;));
 293     self-&gt;patternSeparator = xmlStrdup(BAD_CAST(&quot;;&quot;));
 294     self-&gt;decimalPoint = xmlStrdup(BAD_CAST(&quot;.&quot;));
 295     self-&gt;grouping = xmlStrdup(BAD_CAST(&quot;,&quot;));
 296     self-&gt;percent = xmlStrdup(BAD_CAST(&quot;%&quot;));
 297     self-&gt;permille = xmlStrdup(BAD_CAST(permille));
 298     self-&gt;zeroDigit = xmlStrdup(BAD_CAST(&quot;0&quot;));
 299     self-&gt;minusSign = xmlStrdup(BAD_CAST(&quot;-&quot;));
 300     self-&gt;infinity = xmlStrdup(BAD_CAST(&quot;Infinity&quot;));
 301     self-&gt;noNumber = xmlStrdup(BAD_CAST(&quot;NaN&quot;));
 302     }
 303     return self;
 304 }
 305 
 306 static void
 307 xsltFreeDecimalFormat(xsltDecimalFormatPtr self)
 308 {
 309     if (self != NULL) {
 310     if (self-&gt;digit)
 311         xmlFree(self-&gt;digit);
 312     if (self-&gt;patternSeparator)
 313         xmlFree(self-&gt;patternSeparator);
 314     if (self-&gt;decimalPoint)
 315         xmlFree(self-&gt;decimalPoint);
 316     if (self-&gt;grouping)
 317         xmlFree(self-&gt;grouping);
 318     if (self-&gt;percent)
 319         xmlFree(self-&gt;percent);
 320     if (self-&gt;permille)
 321         xmlFree(self-&gt;permille);
 322     if (self-&gt;zeroDigit)
 323         xmlFree(self-&gt;zeroDigit);
 324     if (self-&gt;minusSign)
 325         xmlFree(self-&gt;minusSign);
 326     if (self-&gt;infinity)
 327         xmlFree(self-&gt;infinity);
 328     if (self-&gt;noNumber)
 329         xmlFree(self-&gt;noNumber);
 330     if (self-&gt;name)
 331         xmlFree(self-&gt;name);
 332     xmlFree(self);
 333     }
 334 }
 335 
 336 static void
 337 xsltFreeDecimalFormatList(xsltStylesheetPtr self)
 338 {
 339     xsltDecimalFormatPtr iter;
 340     xsltDecimalFormatPtr tmp;
 341 
 342     if (self == NULL)
 343     return;
 344 
 345     iter = self-&gt;decimalFormat;
 346     while (iter != NULL) {
 347     tmp = iter-&gt;next;
 348     xsltFreeDecimalFormat(iter);
 349     iter = tmp;
 350     }
 351 }
 352 
 353 /**
 354  * xsltDecimalFormatGetByName:
 355  * @style: the XSLT stylesheet
 356  * @name: the decimal-format name to find
 357  *
 358  * Find decimal-format by name
 359  *
 360  * Returns the xsltDecimalFormatPtr
 361  */
 362 xsltDecimalFormatPtr
 363 xsltDecimalFormatGetByName(xsltStylesheetPtr style, xmlChar *name)
 364 {
 365     xsltDecimalFormatPtr result = NULL;
 366 
 367     if (name == NULL)
 368     return style-&gt;decimalFormat;
 369 
 370     while (style != NULL) {
 371     for (result = style-&gt;decimalFormat-&gt;next;
 372          result != NULL;
 373          result = result-&gt;next) {
 374         if ((result-&gt;nsUri == NULL) &amp;&amp; xmlStrEqual(name, result-&gt;name))
 375         return result;
 376     }
 377     style = xsltNextImport(style);
 378     }
 379     return result;
 380 }
 381 
 382 /**
 383  * xsltDecimalFormatGetByQName:
 384  * @style: the XSLT stylesheet
 385  * @nsUri: the namespace URI of the QName
 386  * @name: the local part of the QName
 387  *
 388  * Find decimal-format by QName
 389  *
 390  * Returns the xsltDecimalFormatPtr
 391  */
 392 xsltDecimalFormatPtr
 393 xsltDecimalFormatGetByQName(xsltStylesheetPtr style, const xmlChar *nsUri,
 394                             const xmlChar *name)
 395 {
 396     xsltDecimalFormatPtr result = NULL;
 397 
 398     if (name == NULL)
 399     return style-&gt;decimalFormat;
 400 
 401     while (style != NULL) {
 402     for (result = style-&gt;decimalFormat-&gt;next;
 403          result != NULL;
 404          result = result-&gt;next) {
 405         if (xmlStrEqual(nsUri, result-&gt;nsUri) &amp;&amp;
 406                 xmlStrEqual(name, result-&gt;name))
 407         return result;
 408     }
 409     style = xsltNextImport(style);
 410     }
 411     return result;
 412 }
 413 
 414 
 415 /**
 416  * xsltNewTemplate:
 417  *
 418  * Create a new XSLT Template
 419  *
 420  * Returns the newly allocated xsltTemplatePtr or NULL in case of error
 421  */
 422 static xsltTemplatePtr
 423 xsltNewTemplate(void) {
 424     xsltTemplatePtr cur;
 425 
 426     cur = (xsltTemplatePtr) xmlMalloc(sizeof(xsltTemplate));
 427     if (cur == NULL) {
 428     xsltTransformError(NULL, NULL, NULL,
 429         &quot;xsltNewTemplate : malloc failed\n&quot;);
 430     return(NULL);
 431     }
 432     memset(cur, 0, sizeof(xsltTemplate));
 433     cur-&gt;priority = XSLT_PAT_NO_PRIORITY;
 434     return(cur);
 435 }
 436 
 437 /**
 438  * xsltFreeTemplate:
 439  * @template:  an XSLT template
 440  *
 441  * Free up the memory allocated by @template
 442  */
 443 static void
 444 xsltFreeTemplate(xsltTemplatePtr template) {
 445     if (template == NULL)
 446     return;
 447     if (template-&gt;match) xmlFree(template-&gt;match);
 448 /*
 449 *   NOTE: @name and @nameURI are put into the string dict now.
 450 *   if (template-&gt;name) xmlFree(template-&gt;name);
 451 *   if (template-&gt;nameURI) xmlFree(template-&gt;nameURI);
 452 */
 453 /*
 454     if (template-&gt;mode) xmlFree(template-&gt;mode);
 455     if (template-&gt;modeURI) xmlFree(template-&gt;modeURI);
 456  */
 457     if (template-&gt;inheritedNs) xmlFree(template-&gt;inheritedNs);
 458 
 459     /* free profiling data */
 460     if (template-&gt;templCalledTab) xmlFree(template-&gt;templCalledTab);
 461     if (template-&gt;templCountTab) xmlFree(template-&gt;templCountTab);
 462 
 463     memset(template, -1, sizeof(xsltTemplate));
 464     xmlFree(template);
 465 }
 466 
 467 /**
 468  * xsltFreeTemplateList:
 469  * @template:  an XSLT template list
 470  *
 471  * Free up the memory allocated by all the elements of @template
 472  */
 473 static void
 474 xsltFreeTemplateList(xsltTemplatePtr template) {
 475     xsltTemplatePtr cur;
 476 
 477     while (template != NULL) {
 478     cur = template;
 479     template = template-&gt;next;
 480     xsltFreeTemplate(cur);
 481     }
 482 }
 483 
 484 #ifdef XSLT_REFACTORED
 485 
 486 static void
 487 xsltFreeNsAliasList(xsltNsAliasPtr item)
 488 {
 489     xsltNsAliasPtr tmp;
 490 
 491     while (item) {
 492     tmp = item;
 493     item = item-&gt;next;
 494     xmlFree(tmp);
 495     }
 496     return;
 497 }
 498 
 499 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 500 static void
 501 xsltFreeNamespaceMap(xsltNsMapPtr item)
 502 {
 503     xsltNsMapPtr tmp;
 504 
 505     while (item) {
 506     tmp = item;
 507     item = item-&gt;next;
 508     xmlFree(tmp);
 509     }
 510     return;
 511 }
 512 
 513 static xsltNsMapPtr
 514 xsltNewNamespaceMapItem(xsltCompilerCtxtPtr cctxt,
 515             xmlDocPtr doc,
 516             xmlNsPtr ns,
 517             xmlNodePtr elem)
 518 {
 519     xsltNsMapPtr ret;
 520 
 521     if ((cctxt == NULL) || (doc == NULL) || (ns == NULL))
 522     return(NULL);
 523 
 524     ret = (xsltNsMapPtr) xmlMalloc(sizeof(xsltNsMap));
 525     if (ret == NULL) {
 526     xsltTransformError(NULL, cctxt-&gt;style, elem,
 527         &quot;Internal error: (xsltNewNamespaceMapItem) &quot;
 528         &quot;memory allocation failed.\n&quot;);
 529     return(NULL);
 530     }
 531     memset(ret, 0, sizeof(xsltNsMap));
 532     ret-&gt;doc = doc;
 533     ret-&gt;ns = ns;
 534     ret-&gt;origNsName = ns-&gt;href;
 535     /*
 536     * Store the item at current stylesheet-level.
 537     */
 538     if (cctxt-&gt;psData-&gt;nsMap != NULL)
 539     ret-&gt;next = cctxt-&gt;psData-&gt;nsMap;
 540     cctxt-&gt;psData-&gt;nsMap = ret;
 541 
 542     return(ret);
 543 }
 544 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
 545 
 546 /**
 547  * xsltCompilerVarInfoFree:
 548  * @cctxt: the compilation context
 549  *
 550  * Frees the list of information for vars/params.
 551  */
 552 static void
 553 xsltCompilerVarInfoFree(xsltCompilerCtxtPtr cctxt)
 554 {
 555     xsltVarInfoPtr ivar = cctxt-&gt;ivars, ivartmp;
 556 
 557     while (ivar) {
 558     ivartmp = ivar;
 559     ivar = ivar-&gt;next;
 560     xmlFree(ivartmp);
 561     }
 562 }
 563 
 564 /**
 565  * xsltCompilerCtxtFree:
 566  *
 567  * Free an XSLT compiler context.
 568  */
 569 static void
 570 xsltCompilationCtxtFree(xsltCompilerCtxtPtr cctxt)
 571 {
 572     if (cctxt == NULL)
 573     return;
 574 #ifdef WITH_XSLT_DEBUG_PARSING
 575     xsltGenericDebug(xsltGenericDebugContext,
 576     &quot;Freeing compilation context\n&quot;);
 577     xsltGenericDebug(xsltGenericDebugContext,
 578     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
 579     xsltGenericDebug(xsltGenericDebugContext,
 580     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
 581 #endif
 582     /*
 583     * Free node-infos.
 584     */
 585     if (cctxt-&gt;inodeList != NULL) {
 586     xsltCompilerNodeInfoPtr tmp, cur = cctxt-&gt;inodeList;
 587     while (cur != NULL) {
 588         tmp = cur;
 589         cur = cur-&gt;next;
 590         xmlFree(tmp);
 591     }
 592     }
 593     if (cctxt-&gt;tmpList != NULL)
 594     xsltPointerListFree(cctxt-&gt;tmpList);
<a name="1" id="anc1"></a><span class="line-removed"> 595 #ifdef XSLT_REFACTORED_XPATHCOMP</span>
<span class="line-removed"> 596     if (cctxt-&gt;xpathCtxt != NULL)</span>
<span class="line-removed"> 597     xmlXPathFreeContext(cctxt-&gt;xpathCtxt);</span>
<span class="line-removed"> 598 #endif</span>
 599     if (cctxt-&gt;nsAliases != NULL)
 600     xsltFreeNsAliasList(cctxt-&gt;nsAliases);
 601 
 602     if (cctxt-&gt;ivars)
 603     xsltCompilerVarInfoFree(cctxt);
 604 
 605     xmlFree(cctxt);
 606 }
 607 
 608 /**
 609  * xsltCompilerCreate:
 610  *
 611  * Creates an XSLT compiler context.
 612  *
 613  * Returns the pointer to the created xsltCompilerCtxt or
 614  *         NULL in case of an internal error.
 615  */
 616 static xsltCompilerCtxtPtr
 617 xsltCompilationCtxtCreate(xsltStylesheetPtr style) {
 618     xsltCompilerCtxtPtr ret;
 619 
 620     ret = (xsltCompilerCtxtPtr) xmlMalloc(sizeof(xsltCompilerCtxt));
 621     if (ret == NULL) {
 622     xsltTransformError(NULL, style, NULL,
 623         &quot;xsltCompilerCreate: allocation of compiler &quot;
 624         &quot;context failed.\n&quot;);
 625     return(NULL);
 626     }
 627     memset(ret, 0, sizeof(xsltCompilerCtxt));
 628 
 629     ret-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
 630     ret-&gt;tmpList = xsltPointerListCreate(20);
 631     if (ret-&gt;tmpList == NULL) {
 632     goto internal_err;
 633     }
<a name="2" id="anc2"></a><span class="line-removed"> 634 #ifdef XSLT_REFACTORED_XPATHCOMP</span>
<span class="line-removed"> 635     /*</span>
<span class="line-removed"> 636     * Create the XPath compilation context in order</span>
<span class="line-removed"> 637     * to speed up precompilation of XPath expressions.</span>
<span class="line-removed"> 638     */</span>
<span class="line-removed"> 639     ret-&gt;xpathCtxt = xmlXPathNewContext(NULL);</span>
<span class="line-removed"> 640     if (ret-&gt;xpathCtxt == NULL)</span>
<span class="line-removed"> 641     goto internal_err;</span>
<span class="line-removed"> 642 #endif</span>
 643 
 644     return(ret);
 645 
 646 internal_err:
 647     xsltCompilationCtxtFree(ret);
 648     return(NULL);
 649 }
 650 
 651 static void
 652 xsltLREEffectiveNsNodesFree(xsltEffectiveNsPtr first)
 653 {
 654     xsltEffectiveNsPtr tmp;
 655 
 656     while (first != NULL) {
 657     tmp = first;
 658     first = first-&gt;nextInStore;
 659     xmlFree(tmp);
 660     }
 661 }
 662 
 663 static void
 664 xsltFreePrincipalStylesheetData(xsltPrincipalStylesheetDataPtr data)
 665 {
 666     if (data == NULL)
 667     return;
 668 
 669     if (data-&gt;inScopeNamespaces != NULL) {
 670     int i;
 671     xsltNsListContainerPtr nsi;
 672     xsltPointerListPtr list =
 673         (xsltPointerListPtr) data-&gt;inScopeNamespaces;
 674 
 675     for (i = 0; i &lt; list-&gt;number; i++) {
 676         /*
 677         * REVISIT TODO: Free info of in-scope namespaces.
 678         */
 679         nsi = (xsltNsListContainerPtr) list-&gt;items[i];
 680         if (nsi-&gt;list != NULL)
 681         xmlFree(nsi-&gt;list);
 682         xmlFree(nsi);
 683     }
 684     xsltPointerListFree(list);
 685     data-&gt;inScopeNamespaces = NULL;
 686     }
 687 
 688     if (data-&gt;exclResultNamespaces != NULL) {
 689     int i;
 690     xsltPointerListPtr list = (xsltPointerListPtr)
 691         data-&gt;exclResultNamespaces;
 692 
 693     for (i = 0; i &lt; list-&gt;number; i++)
 694         xsltPointerListFree((xsltPointerListPtr) list-&gt;items[i]);
 695 
 696     xsltPointerListFree(list);
 697     data-&gt;exclResultNamespaces = NULL;
 698     }
 699 
 700     if (data-&gt;extElemNamespaces != NULL) {
 701     xsltPointerListPtr list = (xsltPointerListPtr)
 702         data-&gt;extElemNamespaces;
 703     int i;
 704 
 705     for (i = 0; i &lt; list-&gt;number; i++)
 706         xsltPointerListFree((xsltPointerListPtr) list-&gt;items[i]);
 707 
 708     xsltPointerListFree(list);
 709     data-&gt;extElemNamespaces = NULL;
 710     }
 711     if (data-&gt;effectiveNs) {
 712     xsltLREEffectiveNsNodesFree(data-&gt;effectiveNs);
 713     data-&gt;effectiveNs = NULL;
 714     }
 715 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 716     xsltFreeNamespaceMap(data-&gt;nsMap);
 717 #endif
 718     xmlFree(data);
 719 }
 720 
 721 static xsltPrincipalStylesheetDataPtr
 722 xsltNewPrincipalStylesheetData(void)
 723 {
 724     xsltPrincipalStylesheetDataPtr ret;
 725 
 726     ret = (xsltPrincipalStylesheetDataPtr)
 727     xmlMalloc(sizeof(xsltPrincipalStylesheetData));
 728     if (ret == NULL) {
 729     xsltTransformError(NULL, NULL, NULL,
 730         &quot;xsltNewPrincipalStylesheetData: memory allocation failed.\n&quot;);
 731     return(NULL);
 732     }
 733     memset(ret, 0, sizeof(xsltPrincipalStylesheetData));
 734 
 735     /*
 736     * Global list of in-scope namespaces.
 737     */
 738     ret-&gt;inScopeNamespaces = xsltPointerListCreate(-1);
 739     if (ret-&gt;inScopeNamespaces == NULL)
 740     goto internal_err;
 741     /*
 742     * Global list of excluded result ns-decls.
 743     */
 744     ret-&gt;exclResultNamespaces = xsltPointerListCreate(-1);
 745     if (ret-&gt;exclResultNamespaces == NULL)
 746     goto internal_err;
 747     /*
 748     * Global list of extension instruction namespace names.
 749     */
 750     ret-&gt;extElemNamespaces = xsltPointerListCreate(-1);
 751     if (ret-&gt;extElemNamespaces == NULL)
 752     goto internal_err;
 753 
 754     return(ret);
 755 
 756 internal_err:
 757 
 758     return(NULL);
 759 }
 760 
 761 #endif
 762 
 763 /**
<a name="3" id="anc3"></a><span class="line-modified"> 764  * xsltNewStylesheet:</span>

 765  *
 766  * Create a new XSLT Stylesheet
 767  *
 768  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error
 769  */
<a name="4" id="anc4"></a><span class="line-modified"> 770 xsltStylesheetPtr</span>
<span class="line-modified"> 771 xsltNewStylesheet(void) {</span>
 772     xsltStylesheetPtr ret = NULL;
 773 
 774     ret = (xsltStylesheetPtr) xmlMalloc(sizeof(xsltStylesheet));
 775     if (ret == NULL) {
 776     xsltTransformError(NULL, NULL, NULL,
 777         &quot;xsltNewStylesheet : malloc failed\n&quot;);
 778     goto internal_err;
 779     }
 780     memset(ret, 0, sizeof(xsltStylesheet));
 781 
<a name="5" id="anc5"></a>
 782     ret-&gt;omitXmlDeclaration = -1;
 783     ret-&gt;standalone = -1;
 784     ret-&gt;decimalFormat = xsltNewDecimalFormat(NULL, NULL);
 785     ret-&gt;indent = -1;
 786     ret-&gt;errors = 0;
 787     ret-&gt;warnings = 0;
 788     ret-&gt;exclPrefixNr = 0;
 789     ret-&gt;exclPrefixMax = 0;
 790     ret-&gt;exclPrefixTab = NULL;
 791     ret-&gt;extInfos = NULL;
 792     ret-&gt;extrasNr = 0;
 793     ret-&gt;internalized = 1;
 794     ret-&gt;literal_result = 0;
 795     ret-&gt;forwards_compatible = 0;
 796     ret-&gt;dict = xmlDictCreate();
 797 #ifdef WITH_XSLT_DEBUG
 798     xsltGenericDebug(xsltGenericDebugContext,
 799     &quot;creating dictionary for stylesheet\n&quot;);
 800 #endif
 801 
<a name="6" id="anc6"></a>














 802     xsltInit();
 803 
 804     return(ret);
 805 
 806 internal_err:
 807     if (ret != NULL)
 808     xsltFreeStylesheet(ret);
 809     return(NULL);
 810 }
 811 
<a name="7" id="anc7"></a>











 812 /**
 813  * xsltAllocateExtra:
 814  * @style:  an XSLT stylesheet
 815  *
 816  * Allocate an extra runtime information slot statically while compiling
 817  * the stylesheet and return its number
 818  *
 819  * Returns the number of the slot
 820  */
 821 int
 822 xsltAllocateExtra(xsltStylesheetPtr style)
 823 {
 824     return(style-&gt;extrasNr++);
 825 }
 826 
 827 /**
 828  * xsltAllocateExtraCtxt:
 829  * @ctxt:  an XSLT transformation context
 830  *
 831  * Allocate an extra runtime information slot at run-time
 832  * and return its number
 833  * This make sure there is a slot ready in the transformation context
 834  *
 835  * Returns the number of the slot
 836  */
 837 int
 838 xsltAllocateExtraCtxt(xsltTransformContextPtr ctxt)
 839 {
 840     if (ctxt-&gt;extrasNr &gt;= ctxt-&gt;extrasMax) {
 841     int i;
 842     if (ctxt-&gt;extrasNr == 0) {
 843         ctxt-&gt;extrasMax = 20;
 844         ctxt-&gt;extras = (xsltRuntimeExtraPtr)
 845         xmlMalloc(ctxt-&gt;extrasMax * sizeof(xsltRuntimeExtra));
 846         if (ctxt-&gt;extras == NULL) {
 847         xsltTransformError(ctxt, NULL, NULL,
 848             &quot;xsltAllocateExtraCtxt: out of memory\n&quot;);
 849         return(0);
 850         }
 851         for (i = 0;i &lt; ctxt-&gt;extrasMax;i++) {
 852         ctxt-&gt;extras[i].info = NULL;
 853         ctxt-&gt;extras[i].deallocate = NULL;
 854         ctxt-&gt;extras[i].val.ptr = NULL;
 855         }
 856 
 857     } else {
 858         xsltRuntimeExtraPtr tmp;
 859 
 860         ctxt-&gt;extrasMax += 100;
 861         tmp = (xsltRuntimeExtraPtr) xmlRealloc(ctxt-&gt;extras,
 862                     ctxt-&gt;extrasMax * sizeof(xsltRuntimeExtra));
 863         if (tmp == NULL) {
 864         xsltTransformError(ctxt, NULL, NULL,
 865             &quot;xsltAllocateExtraCtxt: out of memory\n&quot;);
 866         return(0);
 867         }
 868         ctxt-&gt;extras = tmp;
 869         for (i = ctxt-&gt;extrasNr;i &lt; ctxt-&gt;extrasMax;i++) {
 870         ctxt-&gt;extras[i].info = NULL;
 871         ctxt-&gt;extras[i].deallocate = NULL;
 872         ctxt-&gt;extras[i].val.ptr = NULL;
 873         }
 874     }
 875     }
 876     return(ctxt-&gt;extrasNr++);
 877 }
 878 
 879 /**
 880  * xsltFreeStylesheetList:
 881  * @style:  an XSLT stylesheet list
 882  *
 883  * Free up the memory allocated by the list @style
 884  */
 885 static void
 886 xsltFreeStylesheetList(xsltStylesheetPtr style) {
 887     xsltStylesheetPtr next;
 888 
 889     while (style != NULL) {
 890     next = style-&gt;next;
 891     xsltFreeStylesheet(style);
 892     style = next;
 893     }
 894 }
 895 
 896 /**
 897  * xsltCleanupStylesheetTree:
 898  *
 899  * @doc: the document-node
 900  * @node: the element where the stylesheet is rooted at
 901  *
 902  * Actually @node need not be the document-element, but
 903  * currently Libxslt does not support embedded stylesheets.
 904  *
 905  * Returns 0 if OK, -1 on API or internal errors.
 906  */
 907 static int
 908 xsltCleanupStylesheetTree(xmlDocPtr doc ATTRIBUTE_UNUSED,
 909               xmlNodePtr rootElem ATTRIBUTE_UNUSED)
 910 {
 911 #if 0 /* TODO: Currently disabled, since probably not needed. */
 912     xmlNodePtr cur;
 913 
 914     if ((doc == NULL) || (rootElem == NULL) ||
 915     (rootElem-&gt;type != XML_ELEMENT_NODE) ||
 916     (doc != rootElem-&gt;doc))
 917     return(-1);
 918 
 919     /*
 920     * Cleanup was suggested by Aleksey Sanin:
 921     * Clear the PSVI field to avoid problems if the
 922     * node-tree of the stylesheet is intended to be used for
 923     * further processing by the user (e.g. for compiling it
 924     * once again - although not recommended).
 925     */
 926 
 927     cur = rootElem;
 928     while (cur != NULL) {
 929     if (cur-&gt;type == XML_ELEMENT_NODE) {
 930         /*
 931         * Clear the PSVI field.
 932         */
 933         cur-&gt;psvi = NULL;
 934         if (cur-&gt;children) {
 935         cur = cur-&gt;children;
 936         continue;
 937         }
 938     }
 939 
 940 leave_node:
 941     if (cur == rootElem)
 942         break;
 943     if (cur-&gt;next != NULL)
 944         cur = cur-&gt;next;
 945     else {
 946         cur = cur-&gt;parent;
 947         if (cur == NULL)
 948         break;
 949         goto leave_node;
 950     }
 951     }
 952 #endif /* #if 0 */
 953     return(0);
 954 }
 955 
 956 /**
 957  * xsltFreeStylesheet:
 958  * @style:  an XSLT stylesheet
 959  *
 960  * Free up the memory allocated by @style
 961  */
 962 void
 963 xsltFreeStylesheet(xsltStylesheetPtr style)
 964 {
 965     if (style == NULL)
 966         return;
 967 
 968 #ifdef XSLT_REFACTORED
 969     /*
 970     * Start with a cleanup of the main stylesheet&#39;s doc.
 971     */
 972     if ((style-&gt;principal == style) &amp;&amp; (style-&gt;doc))
 973     xsltCleanupStylesheetTree(style-&gt;doc,
 974         xmlDocGetRootElement(style-&gt;doc));
 975 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 976     /*
 977     * Restore changed ns-decls before freeing the document.
 978     */
 979     if ((style-&gt;doc != NULL) &amp;&amp;
 980     XSLT_HAS_INTERNAL_NSMAP(style))
 981     {
 982     xsltRestoreDocumentNamespaces(XSLT_GET_INTERNAL_NSMAP(style),
 983         style-&gt;doc);
 984     }
 985 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
 986 #else
 987     /*
 988     * Start with a cleanup of the main stylesheet&#39;s doc.
 989     */
 990     if ((style-&gt;parent == NULL) &amp;&amp; (style-&gt;doc))
 991     xsltCleanupStylesheetTree(style-&gt;doc,
 992         xmlDocGetRootElement(style-&gt;doc));
 993 #endif /* XSLT_REFACTORED */
 994 
 995     xsltFreeKeys(style);
 996     xsltFreeExts(style);
 997     xsltFreeTemplateHashes(style);
 998     xsltFreeDecimalFormatList(style);
 999     xsltFreeTemplateList(style-&gt;templates);
1000     xsltFreeAttributeSetsHashes(style);
1001     xsltFreeNamespaceAliasHashes(style);
1002     xsltFreeStylePreComps(style);
1003     /*
1004     * Free documents of all included stylsheet modules of this
1005     * stylesheet level.
1006     */
1007     xsltFreeStyleDocuments(style);
1008     /*
1009     * TODO: Best time to shutdown extension stuff?
1010     */
1011     xsltShutdownExts(style);
1012 
1013     if (style-&gt;variables != NULL)
1014         xsltFreeStackElemList(style-&gt;variables);
1015     if (style-&gt;cdataSection != NULL)
1016         xmlHashFree(style-&gt;cdataSection, NULL);
1017     if (style-&gt;stripSpaces != NULL)
1018         xmlHashFree(style-&gt;stripSpaces, NULL);
1019     if (style-&gt;nsHash != NULL)
1020         xmlHashFree(style-&gt;nsHash, NULL);
1021     if (style-&gt;exclPrefixTab != NULL)
1022         xmlFree(style-&gt;exclPrefixTab);
1023     if (style-&gt;method != NULL)
1024         xmlFree(style-&gt;method);
1025     if (style-&gt;methodURI != NULL)
1026         xmlFree(style-&gt;methodURI);
1027     if (style-&gt;version != NULL)
1028         xmlFree(style-&gt;version);
1029     if (style-&gt;encoding != NULL)
1030         xmlFree(style-&gt;encoding);
1031     if (style-&gt;doctypePublic != NULL)
1032         xmlFree(style-&gt;doctypePublic);
1033     if (style-&gt;doctypeSystem != NULL)
1034         xmlFree(style-&gt;doctypeSystem);
1035     if (style-&gt;mediaType != NULL)
1036         xmlFree(style-&gt;mediaType);
1037     if (style-&gt;attVTs)
1038         xsltFreeAVTList(style-&gt;attVTs);
1039     if (style-&gt;imports != NULL)
1040         xsltFreeStylesheetList(style-&gt;imports);
1041 
1042 #ifdef XSLT_REFACTORED
1043     /*
1044     * If this is the principal stylesheet, then
1045     * free its internal data.
1046     */
1047     if (style-&gt;principal == style) {
1048     if (style-&gt;principalData) {
1049         xsltFreePrincipalStylesheetData(style-&gt;principalData);
1050         style-&gt;principalData = NULL;
1051     }
1052     }
1053 #endif
1054     /*
1055     * Better to free the main document of this stylesheet level
1056     * at the end - so here.
1057     */
1058     if (style-&gt;doc != NULL) {
1059         xmlFreeDoc(style-&gt;doc);
1060     }
1061 
1062 #ifdef WITH_XSLT_DEBUG
1063     xsltGenericDebug(xsltGenericDebugContext,
1064                      &quot;freeing dictionary from stylesheet\n&quot;);
1065 #endif
1066     xmlDictFree(style-&gt;dict);
1067 
<a name="8" id="anc8"></a>


1068     memset(style, -1, sizeof(xsltStylesheet));
1069     xmlFree(style);
1070 }
1071 
1072 /************************************************************************
1073  *                                  *
1074  *      Parsing of an XSLT Stylesheet               *
1075  *                                  *
1076  ************************************************************************/
1077 
1078 #ifdef XSLT_REFACTORED
1079     /*
1080     * This is now performed in an optimized way in xsltParseXSLTTemplate.
1081     */
1082 #else
1083 /**
1084  * xsltGetInheritedNsList:
1085  * @style:  the stylesheet
1086  * @template: the template
1087  * @node:  the current node
1088  *
1089  * Search all the namespace applying to a given element except the ones
1090  * from excluded output prefixes currently in scope. Initialize the
1091  * template inheritedNs list with it.
1092  *
1093  * Returns the number of entries found
1094  */
1095 static int
1096 xsltGetInheritedNsList(xsltStylesheetPtr style,
1097                    xsltTemplatePtr template,
1098                    xmlNodePtr node)
1099 {
1100     xmlNsPtr cur;
1101     xmlNsPtr *ret = NULL;
1102     int nbns = 0;
1103     int maxns = 10;
1104     int i;
1105 
1106     if ((style == NULL) || (template == NULL) || (node == NULL) ||
1107     (template-&gt;inheritedNsNr != 0) || (template-&gt;inheritedNs != NULL))
1108     return(0);
1109     while (node != NULL) {
1110         if (node-&gt;type == XML_ELEMENT_NODE) {
1111             cur = node-&gt;nsDef;
1112             while (cur != NULL) {
1113         if (xmlStrEqual(cur-&gt;href, XSLT_NAMESPACE))
1114             goto skip_ns;
1115 
1116         if ((cur-&gt;prefix != NULL) &amp;&amp;
1117             (xsltCheckExtPrefix(style, cur-&gt;prefix)))
1118             goto skip_ns;
1119         /*
1120         * Check if this namespace was excluded.
1121         * Note that at this point only the exclusions defined
1122         * on the topmost stylesheet element are in the exclusion-list.
1123         */
1124         for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
1125             if (xmlStrEqual(cur-&gt;href, style-&gt;exclPrefixTab[i]))
1126             goto skip_ns;
1127         }
1128                 if (ret == NULL) {
1129                     ret =
1130                         (xmlNsPtr *) xmlMalloc((maxns + 1) *
1131                                                sizeof(xmlNsPtr));
1132                     if (ret == NULL) {
1133                         xmlGenericError(xmlGenericErrorContext,
1134                                         &quot;xsltGetInheritedNsList : out of memory!\n&quot;);
1135                         return(0);
1136                     }
1137                     ret[nbns] = NULL;
1138                 }
1139         /*
1140         * Skip shadowed namespace bindings.
1141         */
1142                 for (i = 0; i &lt; nbns; i++) {
1143                     if ((cur-&gt;prefix == ret[i]-&gt;prefix) ||
1144                         (xmlStrEqual(cur-&gt;prefix, ret[i]-&gt;prefix)))
1145                         break;
1146                 }
1147                 if (i &gt;= nbns) {
1148                     if (nbns &gt;= maxns) {
1149                         maxns *= 2;
1150                         ret = (xmlNsPtr *) xmlRealloc(ret,
1151                                                       (maxns +
1152                                                        1) *
1153                                                       sizeof(xmlNsPtr));
1154                         if (ret == NULL) {
1155                             xmlGenericError(xmlGenericErrorContext,
1156                                             &quot;xsltGetInheritedNsList : realloc failed!\n&quot;);
1157                             return(0);
1158                         }
1159                     }
1160                     ret[nbns++] = cur;
1161                     ret[nbns] = NULL;
1162                 }
1163 skip_ns:
1164                 cur = cur-&gt;next;
1165             }
1166         }
1167         node = node-&gt;parent;
1168     }
1169     if (nbns != 0) {
1170 #ifdef WITH_XSLT_DEBUG_PARSING
1171         xsltGenericDebug(xsltGenericDebugContext,
1172                          &quot;template has %d inherited namespaces\n&quot;, nbns);
1173 #endif
1174     template-&gt;inheritedNsNr = nbns;
1175     template-&gt;inheritedNs = ret;
1176     }
1177     return (nbns);
1178 }
1179 #endif /* else of XSLT_REFACTORED */
1180 
1181 /**
1182  * xsltParseStylesheetOutput:
1183  * @style:  the XSLT stylesheet
1184  * @cur:  the &quot;output&quot; element
1185  *
1186  * parse an XSLT stylesheet output element and record
1187  * information related to the stylesheet output
1188  */
1189 
1190 void
1191 xsltParseStylesheetOutput(xsltStylesheetPtr style, xmlNodePtr cur)
1192 {
1193     xmlChar *elements,
1194      *prop;
1195     xmlChar *element,
1196      *end;
1197 
1198     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1199         return;
1200 
1201     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;version&quot;, NULL);
1202     if (prop != NULL) {
1203         if (style-&gt;version != NULL)
1204             xmlFree(style-&gt;version);
1205         style-&gt;version = prop;
1206     }
1207 
1208     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;encoding&quot;, NULL);
1209     if (prop != NULL) {
1210         if (style-&gt;encoding != NULL)
1211             xmlFree(style-&gt;encoding);
1212         style-&gt;encoding = prop;
1213     }
1214 
1215     /* relaxed to support xt:document
1216     * TODO KB: What does &quot;relaxed to support xt:document&quot; mean?
1217     */
1218     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;method&quot;, NULL);
1219     if (prop != NULL) {
1220         const xmlChar *URI;
1221 
1222         if (style-&gt;method != NULL)
1223             xmlFree(style-&gt;method);
1224         style-&gt;method = NULL;
1225         if (style-&gt;methodURI != NULL)
1226             xmlFree(style-&gt;methodURI);
1227         style-&gt;methodURI = NULL;
1228 
1229     /*
1230     * TODO: Don&#39;t use xsltGetQNameURI().
1231     */
1232     URI = xsltGetQNameURI(cur, &amp;prop);
1233     if (prop == NULL) {
1234         if (style != NULL) style-&gt;errors++;
1235     } else if (URI == NULL) {
1236             if ((xmlStrEqual(prop, (const xmlChar *) &quot;xml&quot;)) ||
1237                 (xmlStrEqual(prop, (const xmlChar *) &quot;html&quot;)) ||
1238                 (xmlStrEqual(prop, (const xmlChar *) &quot;text&quot;))) {
1239                 style-&gt;method = prop;
1240             } else {
1241         xsltTransformError(NULL, style, cur,
1242                                  &quot;invalid value for method: %s\n&quot;, prop);
1243                 if (style != NULL) style-&gt;warnings++;
1244                 xmlFree(prop);
1245             }
1246     } else {
1247         style-&gt;method = prop;
1248         style-&gt;methodURI = xmlStrdup(URI);
1249     }
1250     }
1251 
1252     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;doctype-system&quot;, NULL);
1253     if (prop != NULL) {
1254         if (style-&gt;doctypeSystem != NULL)
1255             xmlFree(style-&gt;doctypeSystem);
1256         style-&gt;doctypeSystem = prop;
1257     }
1258 
1259     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;doctype-public&quot;, NULL);
1260     if (prop != NULL) {
1261         if (style-&gt;doctypePublic != NULL)
1262             xmlFree(style-&gt;doctypePublic);
1263         style-&gt;doctypePublic = prop;
1264     }
1265 
1266     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;standalone&quot;, NULL);
1267     if (prop != NULL) {
1268         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1269             style-&gt;standalone = 1;
1270         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1271             style-&gt;standalone = 0;
1272         } else {
1273         xsltTransformError(NULL, style, cur,
1274                              &quot;invalid value for standalone: %s\n&quot;, prop);
1275             style-&gt;errors++;
1276         }
1277         xmlFree(prop);
1278     }
1279 
1280     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;indent&quot;, NULL);
1281     if (prop != NULL) {
1282         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1283             style-&gt;indent = 1;
1284         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1285             style-&gt;indent = 0;
1286         } else {
1287         xsltTransformError(NULL, style, cur,
1288                              &quot;invalid value for indent: %s\n&quot;, prop);
1289             style-&gt;errors++;
1290         }
1291         xmlFree(prop);
1292     }
1293 
1294     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;omit-xml-declaration&quot;, NULL);
1295     if (prop != NULL) {
1296         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1297             style-&gt;omitXmlDeclaration = 1;
1298         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1299             style-&gt;omitXmlDeclaration = 0;
1300         } else {
1301         xsltTransformError(NULL, style, cur,
1302                              &quot;invalid value for omit-xml-declaration: %s\n&quot;,
1303                              prop);
1304             style-&gt;errors++;
1305         }
1306         xmlFree(prop);
1307     }
1308 
1309     elements = xmlGetNsProp(cur, (const xmlChar *) &quot;cdata-section-elements&quot;,
1310     NULL);
1311     if (elements != NULL) {
1312         if (style-&gt;cdataSection == NULL)
1313             style-&gt;cdataSection = xmlHashCreate(10);
1314         if (style-&gt;cdataSection == NULL)
1315             return;
1316 
1317         element = elements;
1318         while (*element != 0) {
1319             while (IS_BLANK(*element))
1320                 element++;
1321             if (*element == 0)
1322                 break;
1323             end = element;
1324             while ((*end != 0) &amp;&amp; (!IS_BLANK(*end)))
1325                 end++;
1326             element = xmlStrndup(element, end - element);
1327             if (element) {
1328 #ifdef WITH_XSLT_DEBUG_PARSING
1329                 xsltGenericDebug(xsltGenericDebugContext,
1330                                  &quot;add cdata section output element %s\n&quot;,
1331                                  element);
1332 #endif
1333         if (xmlValidateQName(BAD_CAST element, 0) != 0) {
1334             xsltTransformError(NULL, style, cur,
1335             &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;
1336             &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);
1337             xmlFree(element);
1338             style-&gt;errors++;
1339         } else {
1340             const xmlChar *URI;
1341 
1342             /*
1343             * TODO: Don&#39;t use xsltGetQNameURI().
1344             */
1345             URI = xsltGetQNameURI(cur, &amp;element);
1346             if (element == NULL) {
1347             /*
1348             * TODO: We&#39;ll report additionally an error
1349             *  via the stylesheet&#39;s error handling.
1350             */
1351             xsltTransformError(NULL, style, cur,
<a name="9" id="anc9"></a><span class="line-modified">1352                 &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;</span>
<span class="line-modified">1353                 &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);</span>
1354             style-&gt;errors++;
1355             } else {
1356             xmlNsPtr ns;
1357 
1358             /*
1359             * XSLT-1.0 &quot;Each QName is expanded into an
1360             *  expanded-name using the namespace declarations in
1361             *  effect on the xsl:output element in which the QName
1362             *  occurs; if there is a default namespace, it is used
1363             *  for QNames that do not have a prefix&quot;
1364             * NOTE: Fix of bug #339570.
1365             */
1366             if (URI == NULL) {
1367                 ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1368                 if (ns != NULL)
1369                 URI = ns-&gt;href;
1370             }
1371             xmlHashAddEntry2(style-&gt;cdataSection, element, URI,
1372                 (void *) &quot;cdata&quot;);
1373             xmlFree(element);
1374             }
1375         }
1376             }
1377             element = end;
1378         }
1379         xmlFree(elements);
1380     }
1381 
1382     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;media-type&quot;, NULL);
1383     if (prop != NULL) {
1384     if (style-&gt;mediaType)
1385         xmlFree(style-&gt;mediaType);
1386     style-&gt;mediaType = prop;
1387     }
1388     if (cur-&gt;children != NULL) {
1389     xsltParseContentError(style, cur-&gt;children);
1390     }
1391 }
1392 
1393 /**
1394  * xsltParseStylesheetDecimalFormat:
1395  * @style:  the XSLT stylesheet
1396  * @cur:  the &quot;decimal-format&quot; element
1397  *
1398  * &lt;!-- Category: top-level-element --&gt;
1399  * &lt;xsl:decimal-format
1400  *   name = qname, decimal-separator = char, grouping-separator = char,
1401  *   infinity = string, minus-sign = char, NaN = string, percent = char
1402  *   per-mille = char, zero-digit = char, digit = char,
1403  * pattern-separator = char /&gt;
1404  *
1405  * parse an XSLT stylesheet decimal-format element and
1406  * and record the formatting characteristics
1407  */
1408 static void
1409 xsltParseStylesheetDecimalFormat(xsltStylesheetPtr style, xmlNodePtr cur)
1410 {
1411     xmlChar *prop;
1412     xsltDecimalFormatPtr format;
1413     xsltDecimalFormatPtr iter;
1414 
1415     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1416     return;
1417 
1418     format = style-&gt;decimalFormat;
1419 
1420     prop = xmlGetNsProp(cur, BAD_CAST(&quot;name&quot;), NULL);
1421     if (prop != NULL) {
1422         const xmlChar *nsUri;
1423 
1424         if (xmlValidateQName(prop, 0) != 0) {
1425             xsltTransformError(NULL, style, cur,
1426                 &quot;xsl:decimal-format: Invalid QName &#39;%s&#39;.\n&quot;, prop);
1427         style-&gt;warnings++;
1428             xmlFree(prop);
1429             return;
1430         }
1431         /*
1432         * TODO: Don&#39;t use xsltGetQNameURI().
1433         */
1434         nsUri = xsltGetQNameURI(cur, &amp;prop);
1435         if (prop == NULL) {
1436         style-&gt;warnings++;
1437             return;
1438         }
1439     format = xsltDecimalFormatGetByQName(style, nsUri, prop);
1440     if (format != NULL) {
1441         xsltTransformError(NULL, style, cur,
1442      &quot;xsltParseStylestyleDecimalFormat: %s already exists\n&quot;, prop);
1443         style-&gt;warnings++;
1444             xmlFree(prop);
1445         return;
1446     }
1447     format = xsltNewDecimalFormat(nsUri, prop);
1448     if (format == NULL) {
1449         xsltTransformError(NULL, style, cur,
1450      &quot;xsltParseStylestyleDecimalFormat: failed creating new decimal-format\n&quot;);
1451         style-&gt;errors++;
1452             xmlFree(prop);
1453         return;
1454     }
1455     /* Append new decimal-format structure */
1456     for (iter = style-&gt;decimalFormat; iter-&gt;next; iter = iter-&gt;next)
1457         ;
1458     if (iter)
1459         iter-&gt;next = format;
1460     }
1461 
1462     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;decimal-separator&quot;, NULL);
1463     if (prop != NULL) {
1464     if (format-&gt;decimalPoint != NULL) xmlFree(format-&gt;decimalPoint);
1465     format-&gt;decimalPoint  = prop;
1466     }
1467 
1468     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;grouping-separator&quot;, NULL);
1469     if (prop != NULL) {
1470     if (format-&gt;grouping != NULL) xmlFree(format-&gt;grouping);
1471     format-&gt;grouping  = prop;
1472     }
1473 
1474     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;infinity&quot;, NULL);
1475     if (prop != NULL) {
1476     if (format-&gt;infinity != NULL) xmlFree(format-&gt;infinity);
1477     format-&gt;infinity  = prop;
1478     }
1479 
1480     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;minus-sign&quot;, NULL);
1481     if (prop != NULL) {
1482     if (format-&gt;minusSign != NULL) xmlFree(format-&gt;minusSign);
1483     format-&gt;minusSign  = prop;
1484     }
1485 
1486     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;NaN&quot;, NULL);
1487     if (prop != NULL) {
1488     if (format-&gt;noNumber != NULL) xmlFree(format-&gt;noNumber);
1489     format-&gt;noNumber  = prop;
1490     }
1491 
1492     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;percent&quot;, NULL);
1493     if (prop != NULL) {
1494     if (format-&gt;percent != NULL) xmlFree(format-&gt;percent);
1495     format-&gt;percent  = prop;
1496     }
1497 
1498     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;per-mille&quot;, NULL);
1499     if (prop != NULL) {
1500     if (format-&gt;permille != NULL) xmlFree(format-&gt;permille);
1501     format-&gt;permille  = prop;
1502     }
1503 
1504     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;zero-digit&quot;, NULL);
1505     if (prop != NULL) {
1506     if (format-&gt;zeroDigit != NULL) xmlFree(format-&gt;zeroDigit);
1507     format-&gt;zeroDigit  = prop;
1508     }
1509 
1510     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;digit&quot;, NULL);
1511     if (prop != NULL) {
1512     if (format-&gt;digit != NULL) xmlFree(format-&gt;digit);
1513     format-&gt;digit  = prop;
1514     }
1515 
1516     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;pattern-separator&quot;, NULL);
1517     if (prop != NULL) {
1518     if (format-&gt;patternSeparator != NULL) xmlFree(format-&gt;patternSeparator);
1519     format-&gt;patternSeparator  = prop;
1520     }
1521     if (cur-&gt;children != NULL) {
1522     xsltParseContentError(style, cur-&gt;children);
1523     }
1524 }
1525 
1526 /**
1527  * xsltParseStylesheetPreserveSpace:
1528  * @style:  the XSLT stylesheet
1529  * @cur:  the &quot;preserve-space&quot; element
1530  *
1531  * parse an XSLT stylesheet preserve-space element and record
1532  * elements needing preserving
1533  */
1534 
1535 static void
1536 xsltParseStylesheetPreserveSpace(xsltStylesheetPtr style, xmlNodePtr cur) {
1537     xmlChar *elements;
1538     xmlChar *element, *end;
1539 
1540     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1541     return;
1542 
1543     elements = xmlGetNsProp(cur, (const xmlChar *)&quot;elements&quot;, NULL);
1544     if (elements == NULL) {
1545     xsltTransformError(NULL, style, cur,
1546         &quot;xsltParseStylesheetPreserveSpace: missing elements attribute\n&quot;);
1547     if (style != NULL) style-&gt;warnings++;
1548     return;
1549     }
1550 
1551     if (style-&gt;stripSpaces == NULL)
1552     style-&gt;stripSpaces = xmlHashCreate(10);
1553     if (style-&gt;stripSpaces == NULL)
1554     return;
1555 
1556     element = elements;
1557     while (*element != 0) {
1558     while (IS_BLANK(*element)) element++;
1559     if (*element == 0)
1560         break;
1561         end = element;
1562     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1563     element = xmlStrndup(element, end - element);
1564     if (element) {
1565 #ifdef WITH_XSLT_DEBUG_PARSING
1566         xsltGenericDebug(xsltGenericDebugContext,
1567         &quot;add preserved space element %s\n&quot;, element);
1568 #endif
1569         if (xmlStrEqual(element, (const xmlChar *)&quot;*&quot;)) {
1570         style-&gt;stripAll = -1;
1571         } else {
1572         const xmlChar *URI;
1573 
1574         /*
1575         * TODO: Don&#39;t use xsltGetQNameURI().
1576         */
1577                 URI = xsltGetQNameURI(cur, &amp;element);
1578 
1579         xmlHashAddEntry2(style-&gt;stripSpaces, element, URI,
1580                 (xmlChar *) &quot;preserve&quot;);
1581         }
1582         xmlFree(element);
1583     }
1584     element = end;
1585     }
1586     xmlFree(elements);
1587     if (cur-&gt;children != NULL) {
1588     xsltParseContentError(style, cur-&gt;children);
1589     }
1590 }
1591 
1592 #ifdef XSLT_REFACTORED
1593 #else
1594 /**
1595  * xsltParseStylesheetExtPrefix:
1596  * @style:  the XSLT stylesheet
1597  * @template:  the &quot;extension-element-prefixes&quot; prefix
1598  *
1599  * parse an XSLT stylesheet&#39;s &quot;extension-element-prefix&quot; attribute value
1600  * and register the namespaces of extension instruction.
1601  * SPEC &quot;A namespace is designated as an extension namespace by using
1602  *   an extension-element-prefixes attribute on:
1603  *   1) an xsl:stylesheet element
1604  *   2) an xsl:extension-element-prefixes attribute on a
1605  *      literal result element
1606  *   3) an extension instruction.&quot;
1607  */
1608 static void
1609 xsltParseStylesheetExtPrefix(xsltStylesheetPtr style, xmlNodePtr cur,
1610                  int isXsltElem) {
1611     xmlChar *prefixes;
1612     xmlChar *prefix, *end;
1613 
1614     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1615     return;
1616 
1617     if (isXsltElem) {
1618     /* For xsl:stylesheet/xsl:transform. */
1619     prefixes = xmlGetNsProp(cur,
1620         (const xmlChar *)&quot;extension-element-prefixes&quot;, NULL);
1621     } else {
1622     /* For literal result elements and extension instructions. */
1623     prefixes = xmlGetNsProp(cur,
1624         (const xmlChar *)&quot;extension-element-prefixes&quot;, XSLT_NAMESPACE);
1625     }
1626     if (prefixes == NULL) {
1627     return;
1628     }
1629 
1630     prefix = prefixes;
1631     while (*prefix != 0) {
1632     while (IS_BLANK(*prefix)) prefix++;
1633     if (*prefix == 0)
1634         break;
1635         end = prefix;
1636     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1637     prefix = xmlStrndup(prefix, end - prefix);
1638     if (prefix) {
1639         xmlNsPtr ns;
1640 
1641         if (xmlStrEqual(prefix, (const xmlChar *)&quot;#default&quot;))
1642         ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1643         else
1644         ns = xmlSearchNs(style-&gt;doc, cur, prefix);
1645         if (ns == NULL) {
1646         xsltTransformError(NULL, style, cur,
1647         &quot;xsl:extension-element-prefix : undefined namespace %s\n&quot;,
1648                              prefix);
1649         if (style != NULL) style-&gt;warnings++;
1650         } else {
1651 #ifdef WITH_XSLT_DEBUG_PARSING
1652         xsltGenericDebug(xsltGenericDebugContext,
1653             &quot;add extension prefix %s\n&quot;, prefix);
1654 #endif
1655         xsltRegisterExtPrefix(style, prefix, ns-&gt;href);
1656         }
1657         xmlFree(prefix);
1658     }
1659     prefix = end;
1660     }
1661     xmlFree(prefixes);
1662 }
1663 #endif /* else of XSLT_REFACTORED */
1664 
1665 /**
1666  * xsltParseStylesheetStripSpace:
1667  * @style:  the XSLT stylesheet
1668  * @cur:  the &quot;strip-space&quot; element
1669  *
1670  * parse an XSLT stylesheet&#39;s strip-space element and record
1671  * the elements needing stripping
1672  */
1673 
1674 static void
1675 xsltParseStylesheetStripSpace(xsltStylesheetPtr style, xmlNodePtr cur) {
1676     xmlChar *elements;
1677     xmlChar *element, *end;
1678 
1679     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1680     return;
1681 
1682     elements = xmlGetNsProp(cur, (const xmlChar *)&quot;elements&quot;, NULL);
1683     if (elements == NULL) {
1684     xsltTransformError(NULL, style, cur,
1685         &quot;xsltParseStylesheetStripSpace: missing elements attribute\n&quot;);
1686     if (style != NULL) style-&gt;warnings++;
1687     return;
1688     }
1689 
1690     if (style-&gt;stripSpaces == NULL)
1691     style-&gt;stripSpaces = xmlHashCreate(10);
1692     if (style-&gt;stripSpaces == NULL)
1693     return;
1694 
1695     element = elements;
1696     while (*element != 0) {
1697     while (IS_BLANK(*element)) element++;
1698     if (*element == 0)
1699         break;
1700         end = element;
1701     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1702     element = xmlStrndup(element, end - element);
1703     if (element) {
1704 #ifdef WITH_XSLT_DEBUG_PARSING
1705         xsltGenericDebug(xsltGenericDebugContext,
1706         &quot;add stripped space element %s\n&quot;, element);
1707 #endif
1708         if (xmlStrEqual(element, (const xmlChar *)&quot;*&quot;)) {
1709         style-&gt;stripAll = 1;
1710         } else {
1711         const xmlChar *URI;
1712 
1713         /*
1714         * TODO: Don&#39;t use xsltGetQNameURI().
1715         */
1716                 URI = xsltGetQNameURI(cur, &amp;element);
1717 
1718         xmlHashAddEntry2(style-&gt;stripSpaces, element, URI,
1719                     (xmlChar *) &quot;strip&quot;);
1720         }
1721         xmlFree(element);
1722     }
1723     element = end;
1724     }
1725     xmlFree(elements);
1726     if (cur-&gt;children != NULL) {
1727     xsltParseContentError(style, cur-&gt;children);
1728     }
1729 }
1730 
1731 #ifdef XSLT_REFACTORED
1732 #else
1733 /**
1734  * xsltParseStylesheetExcludePrefix:
1735  * @style:  the XSLT stylesheet
1736  * @cur:  the current point in the stylesheet
1737  *
1738  * parse an XSLT stylesheet exclude prefix and record
1739  * namespaces needing stripping
1740  *
1741  * Returns the number of Excluded prefixes added at that level
1742  */
1743 
1744 static int
1745 xsltParseStylesheetExcludePrefix(xsltStylesheetPtr style, xmlNodePtr cur,
1746                  int isXsltElem)
1747 {
1748     int nb = 0;
1749     xmlChar *prefixes;
1750     xmlChar *prefix, *end;
1751 
1752     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1753     return(0);
1754 
1755     if (isXsltElem)
1756     prefixes = xmlGetNsProp(cur,
1757         (const xmlChar *)&quot;exclude-result-prefixes&quot;, NULL);
1758     else
1759     prefixes = xmlGetNsProp(cur,
1760         (const xmlChar *)&quot;exclude-result-prefixes&quot;, XSLT_NAMESPACE);
1761 
1762     if (prefixes == NULL) {
1763     return(0);
1764     }
1765 
1766     prefix = prefixes;
1767     while (*prefix != 0) {
1768     while (IS_BLANK(*prefix)) prefix++;
1769     if (*prefix == 0)
1770         break;
1771         end = prefix;
1772     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1773     prefix = xmlStrndup(prefix, end - prefix);
1774     if (prefix) {
1775         xmlNsPtr ns;
1776 
1777         if (xmlStrEqual(prefix, (const xmlChar *)&quot;#default&quot;))
1778         ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1779         else
1780         ns = xmlSearchNs(style-&gt;doc, cur, prefix);
1781         if (ns == NULL) {
1782         xsltTransformError(NULL, style, cur,
1783         &quot;xsl:exclude-result-prefixes : undefined namespace %s\n&quot;,
1784                              prefix);
1785         if (style != NULL) style-&gt;warnings++;
1786         } else {
1787         if (exclPrefixPush(style, (xmlChar *) ns-&gt;href) &gt;= 0) {
1788 #ifdef WITH_XSLT_DEBUG_PARSING
1789             xsltGenericDebug(xsltGenericDebugContext,
1790             &quot;exclude result prefix %s\n&quot;, prefix);
1791 #endif
1792             nb++;
1793         }
1794         }
1795         xmlFree(prefix);
1796     }
1797     prefix = end;
1798     }
1799     xmlFree(prefixes);
1800     return(nb);
1801 }
1802 #endif /* else of XSLT_REFACTORED */
1803 
1804 #ifdef XSLT_REFACTORED
1805 
1806 /*
1807 * xsltTreeEnsureXMLDecl:
1808 * @doc: the doc
1809 *
1810 * BIG NOTE:
1811 *  This was copy&amp;pasted from Libxml2&#39;s xmlTreeEnsureXMLDecl() in &quot;tree.c&quot;.
1812 * Ensures that there is an XML namespace declaration on the doc.
1813 *
1814 * Returns the XML ns-struct or NULL on API and internal errors.
1815 */
1816 static xmlNsPtr
1817 xsltTreeEnsureXMLDecl(xmlDocPtr doc)
1818 {
1819     if (doc == NULL)
1820     return (NULL);
1821     if (doc-&gt;oldNs != NULL)
1822     return (doc-&gt;oldNs);
1823     {
1824     xmlNsPtr ns;
1825     ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
1826     if (ns == NULL) {
1827         xmlGenericError(xmlGenericErrorContext,
1828         &quot;xsltTreeEnsureXMLDecl: Failed to allocate &quot;
1829         &quot;the XML namespace.\n&quot;);
1830         return (NULL);
1831     }
1832     memset(ns, 0, sizeof(xmlNs));
1833     ns-&gt;type = XML_LOCAL_NAMESPACE;
1834     /*
1835     * URGENT TODO: revisit this.
1836     */
1837 #ifdef LIBXML_NAMESPACE_DICT
1838     if (doc-&gt;dict)
1839         ns-&gt;href = xmlDictLookup(doc-&gt;dict, XML_XML_NAMESPACE, -1);
1840     else
1841         ns-&gt;href = xmlStrdup(XML_XML_NAMESPACE);
1842 #else
1843     ns-&gt;href = xmlStrdup(XML_XML_NAMESPACE);
1844 #endif
1845     ns-&gt;prefix = xmlStrdup((const xmlChar *)&quot;xml&quot;);
1846     doc-&gt;oldNs = ns;
1847     return (ns);
1848     }
1849 }
1850 
1851 /*
1852 * xsltTreeAcquireStoredNs:
1853 * @doc: the doc
1854 * @nsName: the namespace name
1855 * @prefix: the prefix
1856 *
1857 * BIG NOTE:
1858 *  This was copy&amp;pasted from Libxml2&#39;s xmlDOMWrapStoreNs() in &quot;tree.c&quot;.
1859 * Creates or reuses an xmlNs struct on doc-&gt;oldNs with
1860 * the given prefix and namespace name.
1861 *
1862 * Returns the aquired ns struct or NULL in case of an API
1863 *         or internal error.
1864 */
1865 static xmlNsPtr
1866 xsltTreeAcquireStoredNs(xmlDocPtr doc,
1867             const xmlChar *nsName,
1868             const xmlChar *prefix)
1869 {
1870     xmlNsPtr ns;
1871 
1872     if (doc == NULL)
1873     return (NULL);
1874     if (doc-&gt;oldNs != NULL)
1875     ns = doc-&gt;oldNs;
1876     else
1877     ns = xsltTreeEnsureXMLDecl(doc);
1878     if (ns == NULL)
1879     return (NULL);
1880     if (ns-&gt;next != NULL) {
1881     /* Reuse. */
1882     ns = ns-&gt;next;
1883     while (ns != NULL) {
1884         if ((ns-&gt;prefix == NULL) != (prefix == NULL)) {
1885         /* NOP */
1886         } else if (prefix == NULL) {
1887         if (xmlStrEqual(ns-&gt;href, nsName))
1888             return (ns);
1889         } else {
1890         if ((ns-&gt;prefix[0] == prefix[0]) &amp;&amp;
1891              xmlStrEqual(ns-&gt;prefix, prefix) &amp;&amp;
1892              xmlStrEqual(ns-&gt;href, nsName))
1893             return (ns);
1894 
1895         }
1896         if (ns-&gt;next == NULL)
1897         break;
1898         ns = ns-&gt;next;
1899     }
1900     }
1901     /* Create. */
1902     ns-&gt;next = xmlNewNs(NULL, nsName, prefix);
1903     return (ns-&gt;next);
1904 }
1905 
1906 /**
1907  * xsltLREBuildEffectiveNs:
1908  *
1909  * Apply ns-aliasing on the namespace of the given @elem and
1910  * its attributes.
1911  */
1912 static int
1913 xsltLREBuildEffectiveNs(xsltCompilerCtxtPtr cctxt,
1914             xmlNodePtr elem)
1915 {
1916     xmlNsPtr ns;
1917     xsltNsAliasPtr alias;
1918 
1919     if ((cctxt == NULL) || (elem == NULL))
1920     return(-1);
1921     if ((cctxt-&gt;nsAliases == NULL) || (! cctxt-&gt;hasNsAliases))
1922     return(0);
1923 
1924     alias = cctxt-&gt;nsAliases;
1925     while (alias != NULL) {
1926     if ( /* If both namespaces are NULL... */
1927         ( (elem-&gt;ns == NULL) &amp;&amp;
1928         ((alias-&gt;literalNs == NULL) ||
1929         (alias-&gt;literalNs-&gt;href == NULL)) ) ||
1930         /* ... or both namespace are equal */
1931         ( (elem-&gt;ns != NULL) &amp;&amp;
1932         (alias-&gt;literalNs != NULL) &amp;&amp;
1933         xmlStrEqual(elem-&gt;ns-&gt;href, alias-&gt;literalNs-&gt;href) ) )
1934     {
1935         if ((alias-&gt;targetNs != NULL) &amp;&amp;
1936         (alias-&gt;targetNs-&gt;href != NULL))
1937         {
1938         /*
1939         * Convert namespace.
1940         */
1941         if (elem-&gt;doc == alias-&gt;docOfTargetNs) {
1942             /*
1943             * This is the nice case: same docs.
1944             * This will eventually assign a ns-decl which
1945             * is shadowed, but this has no negative effect on
1946             * the generation of the result tree.
1947             */
1948             elem-&gt;ns = alias-&gt;targetNs;
1949         } else {
1950             /*
1951             * This target xmlNs originates from a different
1952             * stylesheet tree. Try to locate it in the
1953             * in-scope namespaces.
1954             * OPTIMIZE TODO: Use the compiler-node-info inScopeNs.
1955             */
1956             ns = xmlSearchNs(elem-&gt;doc, elem,
1957             alias-&gt;targetNs-&gt;prefix);
1958             /*
1959             * If no matching ns-decl found, then assign a
1960             * ns-decl stored in xmlDoc.
1961             */
1962             if ((ns == NULL) ||
1963             (! xmlStrEqual(ns-&gt;href, alias-&gt;targetNs-&gt;href)))
1964             {
1965             /*
1966             * BIG NOTE: The use of xsltTreeAcquireStoredNs()
1967             *  is not very efficient, but currently I don&#39;t
1968             *  see an other way of *safely* changing a node&#39;s
1969             *  namespace, since the xmlNs struct in
1970             *  alias-&gt;targetNs might come from an other
1971             *  stylesheet tree. So we need to anchor it in the
1972             *  current document, without adding it to the tree,
1973             *  which would otherwise change the in-scope-ns
1974             *  semantic of the tree.
1975             */
1976             ns = xsltTreeAcquireStoredNs(elem-&gt;doc,
1977                 alias-&gt;targetNs-&gt;href,
1978                 alias-&gt;targetNs-&gt;prefix);
1979 
1980             if (ns == NULL) {
1981                 xsltTransformError(NULL, cctxt-&gt;style, elem,
1982                 &quot;Internal error in &quot;
1983                 &quot;xsltLREBuildEffectiveNs(): &quot;
1984                 &quot;failed to acquire a stored &quot;
1985                 &quot;ns-declaration.\n&quot;);
1986                 cctxt-&gt;style-&gt;errors++;
1987                 return(-1);
1988 
1989             }
1990             }
1991             elem-&gt;ns = ns;
1992         }
1993         } else {
1994         /*
1995         * Move into or leave in the NULL namespace.
1996         */
1997         elem-&gt;ns = NULL;
1998         }
1999         break;
2000     }
2001     alias = alias-&gt;next;
2002     }
2003     /*
2004     * Same with attributes of literal result elements.
2005     */
2006     if (elem-&gt;properties != NULL) {
2007     xmlAttrPtr attr = elem-&gt;properties;
2008 
2009     while (attr != NULL) {
2010         if (attr-&gt;ns == NULL) {
2011         attr = attr-&gt;next;
2012         continue;
2013         }
2014         alias = cctxt-&gt;nsAliases;
2015         while (alias != NULL) {
2016         if ( /* If both namespaces are NULL... */
2017             ( (elem-&gt;ns == NULL) &amp;&amp;
2018             ((alias-&gt;literalNs == NULL) ||
2019             (alias-&gt;literalNs-&gt;href == NULL)) ) ||
2020             /* ... or both namespace are equal */
2021             ( (elem-&gt;ns != NULL) &amp;&amp;
2022             (alias-&gt;literalNs != NULL) &amp;&amp;
2023             xmlStrEqual(elem-&gt;ns-&gt;href, alias-&gt;literalNs-&gt;href) ) )
2024         {
2025             if ((alias-&gt;targetNs != NULL) &amp;&amp;
2026             (alias-&gt;targetNs-&gt;href != NULL))
2027             {
2028             if (elem-&gt;doc == alias-&gt;docOfTargetNs) {
2029                 elem-&gt;ns = alias-&gt;targetNs;
2030             } else {
2031                 ns = xmlSearchNs(elem-&gt;doc, elem,
2032                 alias-&gt;targetNs-&gt;prefix);
2033                 if ((ns == NULL) ||
2034                 (! xmlStrEqual(ns-&gt;href, alias-&gt;targetNs-&gt;href)))
2035                 {
2036                 ns = xsltTreeAcquireStoredNs(elem-&gt;doc,
2037                     alias-&gt;targetNs-&gt;href,
2038                     alias-&gt;targetNs-&gt;prefix);
2039 
2040                 if (ns == NULL) {
2041                     xsltTransformError(NULL, cctxt-&gt;style, elem,
2042                     &quot;Internal error in &quot;
2043                     &quot;xsltLREBuildEffectiveNs(): &quot;
2044                     &quot;failed to acquire a stored &quot;
2045                     &quot;ns-declaration.\n&quot;);
2046                     cctxt-&gt;style-&gt;errors++;
2047                     return(-1);
2048 
2049                 }
2050                 }
2051                 elem-&gt;ns = ns;
2052             }
2053             } else {
2054             /*
2055             * Move into or leave in the NULL namespace.
2056             */
2057             elem-&gt;ns = NULL;
2058             }
2059             break;
2060         }
2061         alias = alias-&gt;next;
2062         }
2063 
2064         attr = attr-&gt;next;
2065     }
2066     }
2067     return(0);
2068 }
2069 
2070 /**
2071  * xsltLREBuildEffectiveNsNodes:
2072  *
2073  * Computes the effective namespaces nodes for a literal result
2074  * element.
2075  * @effectiveNs is the set of effective ns-nodes
2076  *  on the literal result element, which will be added to the result
2077  *  element if not already existing in the result tree.
2078  *  This means that excluded namespaces (via exclude-result-prefixes,
2079  *  extension-element-prefixes and the XSLT namespace) not added
2080  *  to the set.
2081  *  Namespace-aliasing was applied on the @effectiveNs.
2082  */
2083 static int
2084 xsltLREBuildEffectiveNsNodes(xsltCompilerCtxtPtr cctxt,
2085                  xsltStyleItemLRElementInfoPtr item,
2086                  xmlNodePtr elem,
2087                  int isLRE)
2088 {
2089     xmlNsPtr ns, tmpns;
2090     xsltEffectiveNsPtr effNs, lastEffNs = NULL;
2091     int i, j, holdByElem;
2092     xsltPointerListPtr extElemNs = cctxt-&gt;inode-&gt;extElemNs;
2093     xsltPointerListPtr exclResultNs = cctxt-&gt;inode-&gt;exclResultNs;
2094 
2095     if ((cctxt == NULL) || (cctxt-&gt;inode == NULL) || (elem == NULL) ||
2096     (item == NULL) || (item-&gt;effectiveNs != NULL))
2097     return(-1);
2098 
2099     if (item-&gt;inScopeNs == NULL)
2100     return(0);
2101 
2102     extElemNs = cctxt-&gt;inode-&gt;extElemNs;
2103     exclResultNs = cctxt-&gt;inode-&gt;exclResultNs;
2104 
2105     for (i = 0; i &lt; item-&gt;inScopeNs-&gt;totalNumber; i++) {
2106     ns = item-&gt;inScopeNs-&gt;list[i];
2107     /*
2108     * Skip namespaces designated as excluded namespaces
2109     * -------------------------------------------------
2110     *
2111     * XSLT-20 TODO: In XSLT 2.0 we need to keep namespaces
2112     *  which are target namespaces of namespace-aliases
2113     *  regardless if designated as excluded.
2114     *
2115     * Exclude the XSLT namespace.
2116     */
2117     if (xmlStrEqual(ns-&gt;href, XSLT_NAMESPACE))
2118         goto skip_ns;
2119 
2120     /*
2121     * Apply namespace aliasing
2122     * ------------------------
2123     *
2124     * SPEC XSLT 2.0
2125     *  &quot;- A namespace node whose string value is a literal namespace
2126     *     URI is not copied to the result tree.
2127     *   - A namespace node whose string value is a target namespace URI
2128     *     is copied to the result tree, whether or not the URI
2129     *     identifies an excluded namespace.&quot;
2130     *
2131     * NOTE: The ns-aliasing machanism is non-cascading.
2132     *  (checked with Saxon, Xalan and MSXML .NET).
2133     * URGENT TODO: is style-&gt;nsAliases the effective list of
2134     *  ns-aliases, or do we need to lookup the whole
2135     *  import-tree?
2136     * TODO: Get rid of import-tree lookup.
2137     */
2138     if (cctxt-&gt;hasNsAliases) {
2139         xsltNsAliasPtr alias;
2140         /*
2141         * First check for being a target namespace.
2142         */
2143         alias = cctxt-&gt;nsAliases;
2144         do {
2145         /*
2146         * TODO: Is xmlns=&quot;&quot; handled already?
2147         */
2148         if ((alias-&gt;targetNs != NULL) &amp;&amp;
2149             (xmlStrEqual(alias-&gt;targetNs-&gt;href, ns-&gt;href)))
2150         {
2151             /*
2152             * Recognized as a target namespace; use it regardless
2153             * if excluded otherwise.
2154             */
2155             goto add_effective_ns;
2156         }
2157         alias = alias-&gt;next;
2158         } while (alias != NULL);
2159 
2160         alias = cctxt-&gt;nsAliases;
2161         do {
2162         /*
2163         * TODO: Is xmlns=&quot;&quot; handled already?
2164         */
2165         if ((alias-&gt;literalNs != NULL) &amp;&amp;
2166             (xmlStrEqual(alias-&gt;literalNs-&gt;href, ns-&gt;href)))
2167         {
2168             /*
2169             * Recognized as an namespace alias; do not use it.
2170             */
2171             goto skip_ns;
2172         }
2173         alias = alias-&gt;next;
2174         } while (alias != NULL);
2175     }
2176 
2177     /*
2178     * Exclude excluded result namespaces.
2179     */
2180     if (exclResultNs) {
2181         for (j = 0; j &lt; exclResultNs-&gt;number; j++)
2182         if (xmlStrEqual(ns-&gt;href, BAD_CAST exclResultNs-&gt;items[j]))
2183             goto skip_ns;
2184     }
2185     /*
2186     * Exclude extension-element namespaces.
2187     */
2188     if (extElemNs) {
2189         for (j = 0; j &lt; extElemNs-&gt;number; j++)
2190         if (xmlStrEqual(ns-&gt;href, BAD_CAST extElemNs-&gt;items[j]))
2191             goto skip_ns;
2192     }
2193 
2194 add_effective_ns:
2195     /*
2196     * OPTIMIZE TODO: This information may not be needed.
2197     */
2198     if (isLRE &amp;&amp; (elem-&gt;nsDef != NULL)) {
2199         holdByElem = 0;
2200         tmpns = elem-&gt;nsDef;
2201         do {
2202         if (tmpns == ns) {
2203             holdByElem = 1;
2204             break;
2205         }
2206         tmpns = tmpns-&gt;next;
2207         } while (tmpns != NULL);
2208     } else
2209         holdByElem = 0;
2210 
2211 
2212     /*
2213     * Add the effective namespace declaration.
2214     */
2215     effNs = (xsltEffectiveNsPtr) xmlMalloc(sizeof(xsltEffectiveNs));
2216     if (effNs == NULL) {
2217         xsltTransformError(NULL, cctxt-&gt;style, elem,
2218         &quot;Internal error in xsltLREBuildEffectiveNs(): &quot;
2219         &quot;failed to allocate memory.\n&quot;);
2220         cctxt-&gt;style-&gt;errors++;
2221         return(-1);
2222     }
2223     if (cctxt-&gt;psData-&gt;effectiveNs == NULL) {
2224         cctxt-&gt;psData-&gt;effectiveNs = effNs;
2225         effNs-&gt;nextInStore = NULL;
2226     } else {
2227         effNs-&gt;nextInStore = cctxt-&gt;psData-&gt;effectiveNs;
2228         cctxt-&gt;psData-&gt;effectiveNs = effNs;
2229     }
2230 
2231     effNs-&gt;next = NULL;
2232     effNs-&gt;prefix = ns-&gt;prefix;
2233     effNs-&gt;nsName = ns-&gt;href;
2234     effNs-&gt;holdByElem = holdByElem;
2235 
2236     if (lastEffNs == NULL)
2237         item-&gt;effectiveNs = effNs;
2238     else
2239         lastEffNs-&gt;next = effNs;
2240     lastEffNs = effNs;
2241 
2242 skip_ns:
2243     {}
2244     }
2245     return(0);
2246 }
2247 
2248 
2249 /**
2250  * xsltLREInfoCreate:
2251  *
2252  * @isLRE: indicates if the given @elem is a literal result element
2253  *
2254  * Creates a new info for a literal result element.
2255  */
2256 static int
2257 xsltLREInfoCreate(xsltCompilerCtxtPtr cctxt,
2258           xmlNodePtr elem,
2259           int isLRE)
2260 {
2261     xsltStyleItemLRElementInfoPtr item;
2262 
2263     if ((cctxt == NULL) || (cctxt-&gt;inode == NULL))
2264     return(-1);
2265 
2266     item = (xsltStyleItemLRElementInfoPtr)
2267     xmlMalloc(sizeof(xsltStyleItemLRElementInfo));
2268     if (item == NULL) {
2269     xsltTransformError(NULL, cctxt-&gt;style, NULL,
2270         &quot;Internal error in xsltLREInfoCreate(): &quot;
2271         &quot;memory allocation failed.\n&quot;);
2272     cctxt-&gt;style-&gt;errors++;
2273     return(-1);
2274     }
2275     memset(item, 0, sizeof(xsltStyleItemLRElementInfo));
2276     item-&gt;type = XSLT_FUNC_LITERAL_RESULT_ELEMENT;
2277     /*
2278     * Store it in the stylesheet.
2279     */
2280     item-&gt;next = cctxt-&gt;style-&gt;preComps;
2281     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
2282     /*
2283     * @inScopeNs are used for execution of XPath expressions
2284     *  in AVTs.
2285     */
2286     item-&gt;inScopeNs = cctxt-&gt;inode-&gt;inScopeNs;
2287 
2288     if (elem)
2289     xsltLREBuildEffectiveNsNodes(cctxt, item, elem, isLRE);
2290 
2291     cctxt-&gt;inode-&gt;litResElemInfo = item;
2292     cctxt-&gt;inode-&gt;nsChanged = 0;
2293     cctxt-&gt;maxLREs++;
2294     return(0);
2295 }
2296 
2297 /**
2298  * xsltCompilerVarInfoPush:
2299  * @cctxt: the compilation context
2300  *
2301  * Pushes a new var/param info onto the stack.
2302  *
2303  * Returns the acquired variable info.
2304  */
2305 static xsltVarInfoPtr
2306 xsltCompilerVarInfoPush(xsltCompilerCtxtPtr cctxt,
2307                   xmlNodePtr inst,
2308                   const xmlChar *name,
2309                   const xmlChar *nsName)
2310 {
2311     xsltVarInfoPtr ivar;
2312 
2313     if ((cctxt-&gt;ivar != NULL) &amp;&amp; (cctxt-&gt;ivar-&gt;next != NULL)) {
2314     ivar = cctxt-&gt;ivar-&gt;next;
2315     } else if ((cctxt-&gt;ivar == NULL) &amp;&amp; (cctxt-&gt;ivars != NULL)) {
2316     ivar = cctxt-&gt;ivars;
2317     } else {
2318     ivar = (xsltVarInfoPtr) xmlMalloc(sizeof(xsltVarInfo));
2319     if (ivar == NULL) {
2320         xsltTransformError(NULL, cctxt-&gt;style, inst,
2321         &quot;xsltParseInScopeVarPush: xmlMalloc() failed!\n&quot;);
2322         cctxt-&gt;style-&gt;errors++;
2323         return(NULL);
2324     }
2325     /* memset(retVar, 0, sizeof(xsltInScopeVar)); */
2326     if (cctxt-&gt;ivars == NULL) {
2327         cctxt-&gt;ivars = ivar;
2328         ivar-&gt;prev = NULL;
2329     } else {
2330         cctxt-&gt;ivar-&gt;next = ivar;
2331         ivar-&gt;prev = cctxt-&gt;ivar;
2332     }
2333     cctxt-&gt;ivar = ivar;
2334     ivar-&gt;next = NULL;
2335     }
2336     ivar-&gt;depth = cctxt-&gt;depth;
2337     ivar-&gt;name = name;
2338     ivar-&gt;nsName = nsName;
2339     return(ivar);
2340 }
2341 
2342 /**
2343  * xsltCompilerVarInfoPop:
2344  * @cctxt: the compilation context
2345  *
2346  * Pops all var/param infos from the stack, which
2347  * have the current depth.
2348  */
2349 static void
2350 xsltCompilerVarInfoPop(xsltCompilerCtxtPtr cctxt)
2351 {
2352 
2353     while ((cctxt-&gt;ivar != NULL) &amp;&amp;
2354     (cctxt-&gt;ivar-&gt;depth &gt; cctxt-&gt;depth))
2355     {
2356     cctxt-&gt;ivar = cctxt-&gt;ivar-&gt;prev;
2357     }
2358 }
2359 
2360 /*
2361 * xsltCompilerNodePush:
2362 *
2363 * @cctxt: the compilation context
2364 * @node: the node to be pushed (this can also be the doc-node)
2365 *
2366 *
2367 *
2368 * Returns the current node info structure or
2369 *         NULL in case of an internal error.
2370 */
2371 static xsltCompilerNodeInfoPtr
2372 xsltCompilerNodePush(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2373 {
2374     xsltCompilerNodeInfoPtr inode, iprev;
2375 
2376     if ((cctxt-&gt;inode != NULL) &amp;&amp; (cctxt-&gt;inode-&gt;next != NULL)) {
2377     inode = cctxt-&gt;inode-&gt;next;
2378     } else if ((cctxt-&gt;inode == NULL) &amp;&amp; (cctxt-&gt;inodeList != NULL)) {
2379     inode = cctxt-&gt;inodeList;
2380     } else {
2381     /*
2382     * Create a new node-info.
2383     */
2384     inode = (xsltCompilerNodeInfoPtr)
2385         xmlMalloc(sizeof(xsltCompilerNodeInfo));
2386     if (inode == NULL) {
2387         xsltTransformError(NULL, cctxt-&gt;style, NULL,
2388         &quot;xsltCompilerNodePush: malloc failed.\n&quot;);
2389         return(NULL);
2390     }
2391     memset(inode, 0, sizeof(xsltCompilerNodeInfo));
2392     if (cctxt-&gt;inodeList == NULL)
2393         cctxt-&gt;inodeList = inode;
2394     else {
2395         cctxt-&gt;inodeLast-&gt;next = inode;
2396         inode-&gt;prev = cctxt-&gt;inodeLast;
2397     }
2398     cctxt-&gt;inodeLast = inode;
2399     cctxt-&gt;maxNodeInfos++;
2400     if (cctxt-&gt;inode == NULL) {
2401         cctxt-&gt;inode = inode;
2402         /*
2403         * Create an initial literal result element info for
2404         * the root of the stylesheet.
2405         */
2406         xsltLREInfoCreate(cctxt, NULL, 0);
2407     }
2408     }
2409     cctxt-&gt;depth++;
2410     cctxt-&gt;inode = inode;
2411     /*
2412     * REVISIT TODO: Keep the reset always complete.
2413     * NOTE: Be carefull with the @node, since it might be
2414     *  a doc-node.
2415     */
2416     inode-&gt;node = node;
2417     inode-&gt;depth = cctxt-&gt;depth;
2418     inode-&gt;templ = NULL;
2419     inode-&gt;category = XSLT_ELEMENT_CATEGORY_XSLT;
2420     inode-&gt;type = 0;
2421     inode-&gt;item = NULL;
2422     inode-&gt;curChildType = 0;
2423     inode-&gt;extContentHandled = 0;
2424     inode-&gt;isRoot = 0;
2425 
2426     if (inode-&gt;prev != NULL) {
2427     iprev = inode-&gt;prev;
2428     /*
2429     * Inherit the following information:
2430     * ---------------------------------
2431     *
2432     * In-scope namespaces
2433     */
2434     inode-&gt;inScopeNs = iprev-&gt;inScopeNs;
2435     /*
2436     * Info for literal result elements
2437     */
2438     inode-&gt;litResElemInfo = iprev-&gt;litResElemInfo;
2439     inode-&gt;nsChanged = iprev-&gt;nsChanged;
2440     /*
2441     * Excluded result namespaces
2442     */
2443     inode-&gt;exclResultNs = iprev-&gt;exclResultNs;
2444     /*
2445     * Extension instruction namespaces
2446     */
2447     inode-&gt;extElemNs = iprev-&gt;extElemNs;
2448     /*
2449     * Whitespace preservation
2450     */
2451     inode-&gt;preserveWhitespace = iprev-&gt;preserveWhitespace;
2452     /*
2453     * Forwards-compatible mode
2454     */
2455     inode-&gt;forwardsCompat = iprev-&gt;forwardsCompat;
2456     } else {
2457     inode-&gt;inScopeNs = NULL;
2458     inode-&gt;exclResultNs = NULL;
2459     inode-&gt;extElemNs = NULL;
2460     inode-&gt;preserveWhitespace = 0;
2461     inode-&gt;forwardsCompat = 0;
2462     }
2463 
2464     return(inode);
2465 }
2466 
2467 /*
2468 * xsltCompilerNodePop:
2469 *
2470 * @cctxt: the compilation context
2471 * @node: the node to be pushed (this can also be the doc-node)
2472 *
2473 * Pops the current node info.
2474 */
2475 static void
2476 xsltCompilerNodePop(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2477 {
2478     if (cctxt-&gt;inode == NULL) {
2479     xmlGenericError(xmlGenericErrorContext,
2480         &quot;xsltCompilerNodePop: Top-node mismatch.\n&quot;);
2481     return;
2482     }
2483     /*
2484     * NOTE: Be carefull with the @node, since it might be
2485     *  a doc-node.
2486     */
2487     if (cctxt-&gt;inode-&gt;node != node) {
2488     xmlGenericError(xmlGenericErrorContext,
2489     &quot;xsltCompilerNodePop: Node mismatch.\n&quot;);
2490     goto mismatch;
2491     }
2492     if (cctxt-&gt;inode-&gt;depth != cctxt-&gt;depth) {
2493     xmlGenericError(xmlGenericErrorContext,
2494     &quot;xsltCompilerNodePop: Depth mismatch.\n&quot;);
2495     goto mismatch;
2496     }
2497     cctxt-&gt;depth--;
2498     /*
2499     * Pop information of variables.
2500     */
2501     if ((cctxt-&gt;ivar) &amp;&amp; (cctxt-&gt;ivar-&gt;depth &gt; cctxt-&gt;depth))
2502     xsltCompilerVarInfoPop(cctxt);
2503 
2504     cctxt-&gt;inode = cctxt-&gt;inode-&gt;prev;
2505     if (cctxt-&gt;inode != NULL)
2506     cctxt-&gt;inode-&gt;curChildType = 0;
2507     return;
2508 
2509 mismatch:
2510     {
2511     const xmlChar *nsName = NULL, *name = NULL;
2512     const xmlChar *infnsName = NULL, *infname = NULL;
2513 
2514     if (node) {
2515         if (node-&gt;type == XML_ELEMENT_NODE) {
2516         name = node-&gt;name;
2517         if (node-&gt;ns != NULL)
2518             nsName = node-&gt;ns-&gt;href;
2519         else
2520             nsName = BAD_CAST &quot;&quot;;
2521         } else {
2522         name = BAD_CAST &quot;#document&quot;;
2523         nsName = BAD_CAST &quot;&quot;;
2524         }
2525     } else
2526         name = BAD_CAST &quot;Not given&quot;;
2527 
2528     if (cctxt-&gt;inode-&gt;node) {
2529         if (node-&gt;type == XML_ELEMENT_NODE) {
2530         infname = cctxt-&gt;inode-&gt;node-&gt;name;
2531         if (cctxt-&gt;inode-&gt;node-&gt;ns != NULL)
2532             infnsName = cctxt-&gt;inode-&gt;node-&gt;ns-&gt;href;
2533         else
2534             infnsName = BAD_CAST &quot;&quot;;
2535         } else {
2536         infname = BAD_CAST &quot;#document&quot;;
2537         infnsName = BAD_CAST &quot;&quot;;
2538         }
2539     } else
2540         infname = BAD_CAST &quot;Not given&quot;;
2541 
2542 
2543     xmlGenericError(xmlGenericErrorContext,
2544         &quot;xsltCompilerNodePop: Given   : &#39;%s&#39; URI &#39;%s&#39;\n&quot;,
2545         name, nsName);
2546     xmlGenericError(xmlGenericErrorContext,
2547         &quot;xsltCompilerNodePop: Expected: &#39;%s&#39; URI &#39;%s&#39;\n&quot;,
2548         infname, infnsName);
2549     }
2550 }
2551 
2552 /*
2553 * xsltCompilerBuildInScopeNsList:
2554 *
2555 * Create and store the list of in-scope namespaces for the given
2556 * node in the stylesheet. If there are no changes in the in-scope
2557 * namespaces then the last ns-info of the ancestor axis will be returned.
2558 * Compilation-time only.
2559 *
2560 * Returns the ns-info or NULL if there are no namespaces in scope.
2561 */
2562 static xsltNsListContainerPtr
2563 xsltCompilerBuildInScopeNsList(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2564 {
2565     xsltNsListContainerPtr nsi = NULL;
2566     xmlNsPtr *list = NULL, ns;
2567     int i, maxns = 5;
2568     /*
2569     * Create a new ns-list for this position in the node-tree.
2570     * xmlGetNsList() will return NULL, if there are no ns-decls in the
2571     * tree. Note that the ns-decl for the XML namespace is not added
2572     * to the resulting list; the XPath module handles the XML namespace
2573     * internally.
2574     */
2575     while (node != NULL) {
2576         if (node-&gt;type == XML_ELEMENT_NODE) {
2577             ns = node-&gt;nsDef;
2578             while (ns != NULL) {
2579                 if (nsi == NULL) {
2580             nsi = (xsltNsListContainerPtr)
2581             xmlMalloc(sizeof(xsltNsListContainer));
2582             if (nsi == NULL) {
2583             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2584                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2585                 &quot;malloc failed!\n&quot;);
2586             goto internal_err;
2587             }
2588             memset(nsi, 0, sizeof(xsltNsListContainer));
2589                     nsi-&gt;list =
2590                         (xmlNsPtr *) xmlMalloc(maxns * sizeof(xmlNsPtr));
2591                     if (nsi-&gt;list == NULL) {
2592             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2593                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2594                 &quot;malloc failed!\n&quot;);
2595             goto internal_err;
2596                     }
2597                     nsi-&gt;list[0] = NULL;
2598                 }
2599         /*
2600         * Skip shadowed namespace bindings.
2601         */
2602                 for (i = 0; i &lt; nsi-&gt;totalNumber; i++) {
2603                     if ((ns-&gt;prefix == nsi-&gt;list[i]-&gt;prefix) ||
2604                         (xmlStrEqual(ns-&gt;prefix, nsi-&gt;list[i]-&gt;prefix)))
2605             break;
2606                 }
2607                 if (i &gt;= nsi-&gt;totalNumber) {
2608                     if (nsi-&gt;totalNumber +1 &gt;= maxns) {
2609                         maxns *= 2;
2610             nsi-&gt;list =
2611                 (xmlNsPtr *) xmlRealloc(nsi-&gt;list,
2612                 maxns * sizeof(xmlNsPtr));
2613                         if (nsi-&gt;list == NULL) {
2614                             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2615                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2616                 &quot;realloc failed!\n&quot;);
2617                 goto internal_err;
2618                         }
2619                     }
2620                     nsi-&gt;list[nsi-&gt;totalNumber++] = ns;
2621                     nsi-&gt;list[nsi-&gt;totalNumber] = NULL;
2622                 }
2623 
2624                 ns = ns-&gt;next;
2625             }
2626         }
2627         node = node-&gt;parent;
2628     }
2629     if (nsi == NULL)
2630     return(NULL);
2631     /*
2632     * Move the default namespace to last position.
2633     */
2634     nsi-&gt;xpathNumber = nsi-&gt;totalNumber;
2635     for (i = 0; i &lt; nsi-&gt;totalNumber; i++) {
2636     if (nsi-&gt;list[i]-&gt;prefix == NULL) {
2637         ns = nsi-&gt;list[i];
2638         nsi-&gt;list[i] = nsi-&gt;list[nsi-&gt;totalNumber-1];
2639         nsi-&gt;list[nsi-&gt;totalNumber-1] = ns;
2640         nsi-&gt;xpathNumber--;
2641         break;
2642     }
2643     }
2644     /*
2645     * Store the ns-list in the stylesheet.
2646     */
2647     if (xsltPointerListAddSize(
2648     (xsltPointerListPtr)cctxt-&gt;psData-&gt;inScopeNamespaces,
2649     (void *) nsi, 5) == -1)
2650     {
2651     xmlFree(nsi);
2652     nsi = NULL;
2653     xsltTransformError(NULL, cctxt-&gt;style, NULL,
2654         &quot;xsltCompilerBuildInScopeNsList: failed to add ns-info.\n&quot;);
2655     goto internal_err;
2656     }
2657     /*
2658     * Notify of change in status wrt namespaces.
2659     */
2660     if (cctxt-&gt;inode != NULL)
2661     cctxt-&gt;inode-&gt;nsChanged = 1;
2662 
2663     return(nsi);
2664 
2665 internal_err:
2666     if (list != NULL)
2667     xmlFree(list);
2668     cctxt-&gt;style-&gt;errors++;
2669     return(NULL);
2670 }
2671 
2672 static int
2673 xsltParseNsPrefixList(xsltCompilerCtxtPtr cctxt,
2674               xsltPointerListPtr list,
2675               xmlNodePtr node,
2676               const xmlChar *value)
2677 {
2678     xmlChar *cur, *end;
2679     xmlNsPtr ns;
2680 
2681     if ((cctxt == NULL) || (value == NULL) || (list == NULL))
2682     return(-1);
2683 
2684     list-&gt;number = 0;
2685 
2686     cur = (xmlChar *) value;
2687     while (*cur != 0) {
2688     while (IS_BLANK(*cur)) cur++;
2689     if (*cur == 0)
2690         break;
2691     end = cur;
2692     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
2693     cur = xmlStrndup(cur, end - cur);
2694     if (cur == NULL) {
2695         cur = end;
2696         continue;
2697     }
2698     /*
2699     * TODO: Export and use xmlSearchNsByPrefixStrict()
2700     *   in Libxml2, tree.c, since xmlSearchNs() is in most
2701     *   cases not efficient and in some cases not correct.
2702     *
2703     * XSLT-2 TODO: XSLT 2.0 allows an additional &quot;#all&quot; value.
2704     */
2705     if ((cur[0] == &#39;#&#39;) &amp;&amp;
2706         xmlStrEqual(cur, (const xmlChar *)&quot;#default&quot;))
2707         ns = xmlSearchNs(cctxt-&gt;style-&gt;doc, node, NULL);
2708     else
2709         ns = xmlSearchNs(cctxt-&gt;style-&gt;doc, node, cur);
2710 
2711     if (ns == NULL) {
2712         /*
2713         * TODO: Better to report the attr-node, otherwise
2714         *  the user won&#39;t know which attribute was invalid.
2715         */
2716         xsltTransformError(NULL, cctxt-&gt;style, node,
2717         &quot;No namespace binding in scope for prefix &#39;%s&#39;.\n&quot;, cur);
2718         /*
2719         * XSLT-1.0: &quot;It is an error if there is no namespace
2720         *  bound to the prefix on the element bearing the
2721         *  exclude-result-prefixes or xsl:exclude-result-prefixes
2722         *  attribute.&quot;
2723         */
2724         cctxt-&gt;style-&gt;errors++;
2725     } else {
2726 #ifdef WITH_XSLT_DEBUG_PARSING
2727         xsltGenericDebug(xsltGenericDebugContext,
2728         &quot;resolved prefix &#39;%s&#39;\n&quot;, cur);
2729 #endif
2730         /*
2731         * Note that we put the namespace name into the dict.
2732         */
2733         if (xsltPointerListAddSize(list,
2734         (void *) xmlDictLookup(cctxt-&gt;style-&gt;dict,
2735         ns-&gt;href, -1), 5) == -1)
2736         {
2737         xmlFree(cur);
2738         goto internal_err;
2739         }
2740     }
2741     xmlFree(cur);
2742 
2743     cur = end;
2744     }
2745     return(0);
2746 
2747 internal_err:
2748     cctxt-&gt;style-&gt;errors++;
2749     return(-1);
2750 }
2751 
2752 /**
2753  * xsltCompilerUtilsCreateMergedList:
2754  * @dest: the destination list (optional)
2755  * @first: the first list
2756  * @second: the second list (optional)
2757  *
2758  * Appends the content of @second to @first into @destination.
2759  * If @destination is NULL a new list will be created.
2760  *
2761  * Returns the merged list of items or NULL if there&#39;s nothing to merge.
2762  */
2763 static xsltPointerListPtr
2764 xsltCompilerUtilsCreateMergedList(xsltPointerListPtr first,
2765                 xsltPointerListPtr second)
2766 {
2767     xsltPointerListPtr ret;
2768     size_t num;
2769 
2770     if (first)
2771     num = first-&gt;number;
2772     else
2773     num = 0;
2774     if (second)
2775     num += second-&gt;number;
2776     if (num == 0)
2777     return(NULL);
2778     ret = xsltPointerListCreate(num);
2779     if (ret == NULL)
2780     return(NULL);
2781     /*
2782     * Copy contents.
2783     */
2784     if ((first != NULL) &amp;&amp;  (first-&gt;number != 0)) {
2785     memcpy(ret-&gt;items, first-&gt;items,
2786         first-&gt;number * sizeof(void *));
2787     if ((second != NULL) &amp;&amp; (second-&gt;number != 0))
2788         memcpy(ret-&gt;items + first-&gt;number, second-&gt;items,
2789         second-&gt;number * sizeof(void *));
2790     } else if ((second != NULL) &amp;&amp; (second-&gt;number != 0))
2791     memcpy(ret-&gt;items, (void *) second-&gt;items,
2792         second-&gt;number * sizeof(void *));
2793     ret-&gt;number = num;
2794     return(ret);
2795 }
2796 
2797 /*
2798 * xsltParseExclResultPrefixes:
2799 *
2800 * Create and store the list of in-scope namespaces for the given
2801 * node in the stylesheet. If there are no changes in the in-scope
2802 * namespaces then the last ns-info of the ancestor axis will be returned.
2803 * Compilation-time only.
2804 *
2805 * Returns the ns-info or NULL if there are no namespaces in scope.
2806 */
2807 static xsltPointerListPtr
2808 xsltParseExclResultPrefixes(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
2809                 xsltPointerListPtr def,
2810                 int instrCategory)
2811 {
2812     xsltPointerListPtr list = NULL;
2813     xmlChar *value;
2814     xmlAttrPtr attr;
2815 
2816     if ((cctxt == NULL) || (node == NULL))
2817     return(NULL);
2818 
2819     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
2820     attr = xmlHasNsProp(node, BAD_CAST &quot;exclude-result-prefixes&quot;, NULL);
2821     else
2822     attr = xmlHasNsProp(node, BAD_CAST &quot;exclude-result-prefixes&quot;,
2823         XSLT_NAMESPACE);
2824     if (attr == NULL)
2825     return(def);
2826 
2827     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
2828     /*
2829     * Mark the XSLT attr.
2830     */
2831     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
2832     }
2833 
2834     if ((attr-&gt;children != NULL) &amp;&amp;
2835     (attr-&gt;children-&gt;content != NULL))
2836     value = attr-&gt;children-&gt;content;
2837     else {
2838     xsltTransformError(NULL, cctxt-&gt;style, node,
2839         &quot;Attribute &#39;exclude-result-prefixes&#39;: Invalid value.\n&quot;);
2840     cctxt-&gt;style-&gt;errors++;
2841     return(def);
2842     }
2843 
2844     if (xsltParseNsPrefixList(cctxt, cctxt-&gt;tmpList, node,
2845     BAD_CAST value) != 0)
2846     goto exit;
2847     if (cctxt-&gt;tmpList-&gt;number == 0)
2848     goto exit;
2849     /*
2850     * Merge the list with the inherited list.
2851     */
2852     list = xsltCompilerUtilsCreateMergedList(def, cctxt-&gt;tmpList);
2853     if (list == NULL)
2854     goto exit;
2855     /*
2856     * Store the list in the stylesheet/compiler context.
2857     */
2858     if (xsltPointerListAddSize(
2859     cctxt-&gt;psData-&gt;exclResultNamespaces, list, 5) == -1)
2860     {
2861     xsltPointerListFree(list);
2862     list = NULL;
2863     goto exit;
2864     }
2865     /*
2866     * Notify of change in status wrt namespaces.
2867     */
2868     if (cctxt-&gt;inode != NULL)
2869     cctxt-&gt;inode-&gt;nsChanged = 1;
2870 
2871 exit:
2872     if (list != NULL)
2873     return(list);
2874     else
2875     return(def);
2876 }
2877 
2878 /*
2879 * xsltParseExtElemPrefixes:
2880 *
2881 * Create and store the list of in-scope namespaces for the given
2882 * node in the stylesheet. If there are no changes in the in-scope
2883 * namespaces then the last ns-info of the ancestor axis will be returned.
2884 * Compilation-time only.
2885 *
2886 * Returns the ns-info or NULL if there are no namespaces in scope.
2887 */
2888 static xsltPointerListPtr
2889 xsltParseExtElemPrefixes(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
2890              xsltPointerListPtr def,
2891              int instrCategory)
2892 {
2893     xsltPointerListPtr list = NULL;
2894     xmlAttrPtr attr;
2895     xmlChar *value;
2896     int i;
2897 
2898     if ((cctxt == NULL) || (node == NULL))
2899     return(NULL);
2900 
2901     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
2902     attr = xmlHasNsProp(node, BAD_CAST &quot;extension-element-prefixes&quot;, NULL);
2903     else
2904     attr = xmlHasNsProp(node, BAD_CAST &quot;extension-element-prefixes&quot;,
2905         XSLT_NAMESPACE);
2906     if (attr == NULL)
2907     return(def);
2908 
2909     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
2910     /*
2911     * Mark the XSLT attr.
2912     */
2913     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
2914     }
2915 
2916     if ((attr-&gt;children != NULL) &amp;&amp;
2917     (attr-&gt;children-&gt;content != NULL))
2918     value = attr-&gt;children-&gt;content;
2919     else {
2920     xsltTransformError(NULL, cctxt-&gt;style, node,
2921         &quot;Attribute &#39;extension-element-prefixes&#39;: Invalid value.\n&quot;);
2922     cctxt-&gt;style-&gt;errors++;
2923     return(def);
2924     }
2925 
2926 
2927     if (xsltParseNsPrefixList(cctxt, cctxt-&gt;tmpList, node,
2928     BAD_CAST value) != 0)
2929     goto exit;
2930 
2931     if (cctxt-&gt;tmpList-&gt;number == 0)
2932     goto exit;
2933     /*
2934     * REVISIT: Register the extension namespaces.
2935     */
2936     for (i = 0; i &lt; cctxt-&gt;tmpList-&gt;number; i++)
2937     xsltRegisterExtPrefix(cctxt-&gt;style, NULL,
2938     BAD_CAST cctxt-&gt;tmpList-&gt;items[i]);
2939     /*
2940     * Merge the list with the inherited list.
2941     */
2942     list = xsltCompilerUtilsCreateMergedList(def, cctxt-&gt;tmpList);
2943     if (list == NULL)
2944     goto exit;
2945     /*
2946     * Store the list in the stylesheet.
2947     */
2948     if (xsltPointerListAddSize(
2949     cctxt-&gt;psData-&gt;extElemNamespaces, list, 5) == -1)
2950     {
2951     xsltPointerListFree(list);
2952     list = NULL;
2953     goto exit;
2954     }
2955     /*
2956     * Notify of change in status wrt namespaces.
2957     */
2958     if (cctxt-&gt;inode != NULL)
2959     cctxt-&gt;inode-&gt;nsChanged = 1;
2960 
2961 exit:
2962     if (list != NULL)
2963     return(list);
2964     else
2965     return(def);
2966 }
2967 
2968 /*
2969 * xsltParseAttrXSLTVersion:
2970 *
2971 * @cctxt: the compilation context
2972 * @node: the element-node
2973 * @isXsltElem: whether this is an XSLT element
2974 *
2975 * Parses the attribute xsl:version.
2976 *
2977 * Returns 1 if there was such an attribute, 0 if not and
2978 *         -1 if an internal or API error occured.
2979 */
2980 static int
2981 xsltParseAttrXSLTVersion(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
2982              int instrCategory)
2983 {
2984     xmlChar *value;
2985     xmlAttrPtr attr;
2986 
2987     if ((cctxt == NULL) || (node == NULL))
2988     return(-1);
2989 
2990     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
2991     attr = xmlHasNsProp(node, BAD_CAST &quot;version&quot;, NULL);
2992     else
2993     attr = xmlHasNsProp(node, BAD_CAST &quot;version&quot;, XSLT_NAMESPACE);
2994 
2995     if (attr == NULL)
2996     return(0);
2997 
2998     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
2999 
3000     if ((attr-&gt;children != NULL) &amp;&amp;
3001     (attr-&gt;children-&gt;content != NULL))
3002     value = attr-&gt;children-&gt;content;
3003     else {
3004     xsltTransformError(NULL, cctxt-&gt;style, node,
3005         &quot;Attribute &#39;version&#39;: Invalid value.\n&quot;);
3006     cctxt-&gt;style-&gt;errors++;
3007     return(1);
3008     }
3009 
3010     if (! xmlStrEqual(value, (const xmlChar *)&quot;1.0&quot;)) {
3011     cctxt-&gt;inode-&gt;forwardsCompat = 1;
3012     /*
3013     * TODO: To what extent do we support the
3014     *  forwards-compatible mode?
3015     */
3016     /*
3017     * Report this only once per compilation episode.
3018     */
3019     if (! cctxt-&gt;hasForwardsCompat) {
3020         cctxt-&gt;hasForwardsCompat = 1;
3021         cctxt-&gt;errSeverity = XSLT_ERROR_SEVERITY_WARNING;
3022         xsltTransformError(NULL, cctxt-&gt;style, node,
3023         &quot;Warning: the attribute xsl:version specifies a value &quot;
3024         &quot;different from &#39;1.0&#39;. Switching to forwards-compatible &quot;
3025         &quot;mode. Only features of XSLT 1.0 are supported by this &quot;
3026         &quot;processor.\n&quot;);
3027         cctxt-&gt;style-&gt;warnings++;
3028         cctxt-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
3029     }
3030     } else {
3031     cctxt-&gt;inode-&gt;forwardsCompat = 0;
3032     }
3033 
3034     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
3035     /*
3036     * Set a marker on XSLT attributes.
3037     */
3038     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
3039     }
3040     return(1);
3041 }
3042 
3043 static int
3044 xsltParsePreprocessStylesheetTree(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
3045 {
3046     xmlNodePtr deleteNode, cur, txt, textNode = NULL;
3047     xmlDocPtr doc;
3048     xsltStylesheetPtr style;
3049     int internalize = 0, findSpaceAttr;
3050     int xsltStylesheetElemDepth;
3051     xmlAttrPtr attr;
3052     xmlChar *value;
3053     const xmlChar *name, *nsNameXSLT = NULL;
3054     int strictWhitespace, inXSLText = 0;
3055 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3056     xsltNsMapPtr nsMapItem;
3057 #endif
3058 
3059     if ((cctxt == NULL) || (cctxt-&gt;style == NULL) ||
3060     (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
3061         return(-1);
3062 
3063     doc = node-&gt;doc;
3064     if (doc == NULL)
3065     goto internal_err;
3066 
3067     style = cctxt-&gt;style;
3068     if ((style-&gt;dict != NULL) &amp;&amp; (doc-&gt;dict == style-&gt;dict))
3069     internalize = 1;
3070     else
3071         style-&gt;internalized = 0;
3072 
3073     /*
3074     * Init value of xml:space. Since this might be an embedded
3075     * stylesheet, this is needed to be performed on the element
3076     * where the stylesheet is rooted at, taking xml:space of
3077     * ancestors into account.
3078     */
3079     if (! cctxt-&gt;simplified)
3080     xsltStylesheetElemDepth = cctxt-&gt;depth +1;
3081     else
3082     xsltStylesheetElemDepth = 0;
3083 
3084     if (xmlNodeGetSpacePreserve(node) != 1)
3085     cctxt-&gt;inode-&gt;preserveWhitespace = 0;
3086     else
3087     cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3088 
3089     /*
3090     * Eval if we should keep the old incorrect behaviour.
3091     */
3092     strictWhitespace = (cctxt-&gt;strict != 0) ? 1 : 0;
3093 
3094     nsNameXSLT = xsltConstNamespaceNameXSLT;
3095 
3096     deleteNode = NULL;
3097     cur = node;
3098     while (cur != NULL) {
3099     if (deleteNode != NULL) {
3100 
3101 #ifdef WITH_XSLT_DEBUG_BLANKS
3102         xsltGenericDebug(xsltGenericDebugContext,
3103          &quot;xsltParsePreprocessStylesheetTree: removing node\n&quot;);
3104 #endif
3105         xmlUnlinkNode(deleteNode);
3106         xmlFreeNode(deleteNode);
3107         deleteNode = NULL;
3108     }
3109     if (cur-&gt;type == XML_ELEMENT_NODE) {
3110 
3111         /*
3112         * Clear the PSVI field.
3113         */
3114         cur-&gt;psvi = NULL;
3115 
3116         xsltCompilerNodePush(cctxt, cur);
3117 
3118         inXSLText = 0;
3119         textNode = NULL;
3120         findSpaceAttr = 1;
3121         cctxt-&gt;inode-&gt;stripWhitespace = 0;
3122         /*
3123         * TODO: I&#39;d love to use a string pointer comparison here :-/
3124         */
3125         if (IS_XSLT_ELEM(cur)) {
3126 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3127         if (cur-&gt;ns-&gt;href != nsNameXSLT) {
3128             nsMapItem = xsltNewNamespaceMapItem(cctxt,
3129             doc, cur-&gt;ns, cur);
3130             if (nsMapItem == NULL)
3131             goto internal_err;
3132             cur-&gt;ns-&gt;href = nsNameXSLT;
3133         }
3134 #endif
3135 
3136         if (cur-&gt;name == NULL)
3137             goto process_attributes;
3138         /*
3139         * Mark the XSLT element for later recognition.
3140         * TODO: Using the marker is still too dangerous, since if
3141         *   the parsing mechanism leaves out an XSLT element, then
3142         *   this might hit the transformation-mechanism, which
3143         *   will break if it doesn&#39;t expect such a marker.
3144         */
3145         /* cur-&gt;psvi = (void *) xsltXSLTElemMarker; */
3146 
3147         /*
3148         * XSLT 2.0: &quot;Any whitespace text node whose parent is
3149         * one of the following elements is removed from the &quot;
3150         * tree, regardless of any xml:space attributes:...&quot;
3151         * xsl:apply-imports,
3152         * xsl:apply-templates,
3153         * xsl:attribute-set,
3154         * xsl:call-template,
3155         * xsl:choose,
3156         * xsl:stylesheet, xsl:transform.
3157         * XSLT 2.0: xsl:analyze-string,
3158         *           xsl:character-map,
3159         *           xsl:next-match
3160         *
3161         * TODO: I&#39;d love to use a string pointer comparison here :-/
3162         */
3163         name = cur-&gt;name;
3164         switch (*name) {
3165             case &#39;t&#39;:
3166             if ((name[0] == &#39;t&#39;) &amp;&amp; (name[1] == &#39;e&#39;) &amp;&amp;
3167                 (name[2] == &#39;x&#39;) &amp;&amp; (name[3] == &#39;t&#39;) &amp;&amp;
3168                 (name[4] == 0))
3169             {
3170                 /*
3171                 * Process the xsl:text element.
3172                 * ----------------------------
3173                 * Mark it for later recognition.
3174                 */
3175                 cur-&gt;psvi = (void *) xsltXSLTTextMarker;
3176                 /*
3177                 * For stylesheets, the set of
3178                 * whitespace-preserving element names
3179                 * consists of just xsl:text.
3180                 */
3181                 findSpaceAttr = 0;
3182                 cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3183                 inXSLText = 1;
3184             }
3185             break;
3186             case &#39;c&#39;:
3187             if (xmlStrEqual(name, BAD_CAST &quot;choose&quot;) ||
3188                 xmlStrEqual(name, BAD_CAST &quot;call-template&quot;))
3189                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3190             break;
3191             case &#39;a&#39;:
3192             if (xmlStrEqual(name, BAD_CAST &quot;apply-templates&quot;) ||
3193                 xmlStrEqual(name, BAD_CAST &quot;apply-imports&quot;) ||
3194                 xmlStrEqual(name, BAD_CAST &quot;attribute-set&quot;))
3195 
3196                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3197             break;
3198             default:
3199             if (xsltStylesheetElemDepth == cctxt-&gt;depth) {
3200                 /*
3201                 * This is a xsl:stylesheet/xsl:transform.
3202                 */
3203                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3204                 break;
3205             }
3206 
3207             if ((cur-&gt;prev != NULL) &amp;&amp;
3208                 (cur-&gt;prev-&gt;type == XML_TEXT_NODE))
3209             {
3210                 /*
3211                 * XSLT 2.0 : &quot;Any whitespace text node whose
3212                 *  following-sibling node is an xsl:param or
3213                 *  xsl:sort element is removed from the tree,
3214                 *  regardless of any xml:space attributes.&quot;
3215                 */
3216                 if (((*name == &#39;p&#39;) || (*name == &#39;s&#39;)) &amp;&amp;
3217                 (xmlStrEqual(name, BAD_CAST &quot;param&quot;) ||
3218                  xmlStrEqual(name, BAD_CAST &quot;sort&quot;)))
3219                 {
3220                 do {
3221                     if (IS_BLANK_NODE(cur-&gt;prev)) {
3222                     txt = cur-&gt;prev;
3223                     xmlUnlinkNode(txt);
3224                     xmlFreeNode(txt);
3225                     } else {
3226                     /*
3227                     * This will result in a content
3228                     * error, when hitting the parsing
3229                     * functions.
3230                     */
3231                     break;
3232                     }
3233                 } while (cur-&gt;prev);
3234                 }
3235             }
3236             break;
3237         }
3238         }
3239 
3240 process_attributes:
3241         /*
3242         * Process attributes.
3243         * ------------------
3244         */
3245         if (cur-&gt;properties != NULL) {
3246         if (cur-&gt;children == NULL)
3247             findSpaceAttr = 0;
3248         attr = cur-&gt;properties;
3249         do {
3250 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3251             if ((attr-&gt;ns) &amp;&amp; (attr-&gt;ns-&gt;href != nsNameXSLT) &amp;&amp;
3252             xmlStrEqual(attr-&gt;ns-&gt;href, nsNameXSLT))
3253             {
3254             nsMapItem = xsltNewNamespaceMapItem(cctxt,
3255                 doc, attr-&gt;ns, cur);
3256             if (nsMapItem == NULL)
3257                 goto internal_err;
3258             attr-&gt;ns-&gt;href = nsNameXSLT;
3259             }
3260 #endif
3261             if (internalize) {
3262             /*
3263             * Internalize the attribute&#39;s value; the goal is to
3264             * speed up operations and minimize used space by
3265             * compiled stylesheets.
3266             */
3267             txt = attr-&gt;children;
3268             /*
3269             * NOTE that this assumes only one
3270             *  text-node in the attribute&#39;s content.
3271             */
3272             if ((txt != NULL) &amp;&amp; (txt-&gt;content != NULL) &amp;&amp;
3273                 (!xmlDictOwns(style-&gt;dict, txt-&gt;content)))
3274             {
3275                 value = (xmlChar *) xmlDictLookup(style-&gt;dict,
3276                 txt-&gt;content, -1);
3277                 xmlNodeSetContent(txt, NULL);
3278                 txt-&gt;content = value;
3279             }
3280             }
3281             /*
3282             * Process xml:space attributes.
3283             * ----------------------------
3284             */
3285             if ((findSpaceAttr != 0) &amp;&amp;
3286             (attr-&gt;ns != NULL) &amp;&amp;
3287             (attr-&gt;name != NULL) &amp;&amp;
3288             (attr-&gt;name[0] == &#39;s&#39;) &amp;&amp;
3289             (attr-&gt;ns-&gt;prefix != NULL) &amp;&amp;
3290             (attr-&gt;ns-&gt;prefix[0] == &#39;x&#39;) &amp;&amp;
3291             (attr-&gt;ns-&gt;prefix[1] == &#39;m&#39;) &amp;&amp;
3292             (attr-&gt;ns-&gt;prefix[2] == &#39;l&#39;) &amp;&amp;
3293             (attr-&gt;ns-&gt;prefix[3] == 0))
3294             {
3295             value = xmlGetNsProp(cur, BAD_CAST &quot;space&quot;,
3296                 XML_XML_NAMESPACE);
3297             if (value != NULL) {
3298                 if (xmlStrEqual(value, BAD_CAST &quot;preserve&quot;)) {
3299                 cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3300                 } else if (xmlStrEqual(value, BAD_CAST &quot;default&quot;)) {
3301                 cctxt-&gt;inode-&gt;preserveWhitespace = 0;
3302                 } else {
3303                 /* Invalid value for xml:space. */
3304                 xsltTransformError(NULL, style, cur,
3305                     &quot;Attribute xml:space: Invalid value.\n&quot;);
3306                 cctxt-&gt;style-&gt;warnings++;
3307                 }
3308                 findSpaceAttr = 0;
3309                 xmlFree(value);
3310             }
3311 
3312             }
3313             attr = attr-&gt;next;
3314         } while (attr != NULL);
3315         }
3316         /*
3317         * We&#39;ll descend into the children of element nodes only.
3318         */
3319         if (cur-&gt;children != NULL) {
3320         cur = cur-&gt;children;
3321         continue;
3322         }
3323     } else if ((cur-&gt;type == XML_TEXT_NODE) ||
3324         (cur-&gt;type == XML_CDATA_SECTION_NODE))
3325     {
3326         /*
3327         * Merge adjacent text/CDATA-section-nodes
3328         * ---------------------------------------
3329         * In order to avoid breaking of existing stylesheets,
3330         * if the old behaviour is wanted (strictWhitespace == 0),
3331         * then we *won&#39;t* merge adjacent text-nodes
3332         * (except in xsl:text); this will ensure that whitespace-only
3333         * text nodes are (incorrectly) not stripped in some cases.
3334         *
3335         * Example:               : &lt;foo&gt;  &lt;!-- bar --&gt;zoo&lt;/foo&gt;
3336         * Corrent (strict) result: &lt;foo&gt;  zoo&lt;/foo&gt;
3337         * Incorrect (old) result : &lt;foo&gt;zoo&lt;/foo&gt;
3338         *
3339         * NOTE that we *will* merge adjacent text-nodes if
3340         * they are in xsl:text.
3341         * Example, the following:
3342         * &lt;xsl:text&gt;  &lt;!-- bar --&gt;zoo&lt;xsl:text&gt;
3343         * will result in both cases in:
3344         * &lt;xsl:text&gt;  zoo&lt;xsl:text&gt;
3345         */
3346         cur-&gt;type = XML_TEXT_NODE;
3347         if ((strictWhitespace != 0) || (inXSLText != 0)) {
3348         /*
3349         * New behaviour; merge nodes.
3350         */
3351         if (textNode == NULL)
3352             textNode = cur;
3353         else {
3354             if (cur-&gt;content != NULL)
3355             xmlNodeAddContent(textNode, cur-&gt;content);
3356             deleteNode = cur;
3357         }
3358         if ((cur-&gt;next == NULL) ||
3359             (cur-&gt;next-&gt;type == XML_ELEMENT_NODE))
3360             goto end_of_text;
3361         else
3362             goto next_sibling;
3363         } else {
3364         /*
3365         * Old behaviour.
3366         */
3367         if (textNode == NULL)
3368             textNode = cur;
3369         goto end_of_text;
3370         }
3371     } else if ((cur-&gt;type == XML_COMMENT_NODE) ||
3372         (cur-&gt;type == XML_PI_NODE))
3373     {
3374         /*
3375         * Remove processing instructions and comments.
3376         */
3377         deleteNode = cur;
3378         if ((cur-&gt;next == NULL) ||
3379         (cur-&gt;next-&gt;type == XML_ELEMENT_NODE))
3380         goto end_of_text;
3381         else
3382         goto next_sibling;
3383     } else {
3384         textNode = NULL;
3385         /*
3386         * Invalid node-type for this data-model.
3387         */
3388         xsltTransformError(NULL, style, cur,
3389         &quot;Invalid type of node for the XSLT data model.\n&quot;);
3390         cctxt-&gt;style-&gt;errors++;
3391         goto next_sibling;
3392     }
3393 
3394 end_of_text:
3395     if (textNode) {
3396         value = textNode-&gt;content;
3397         /*
3398         * At this point all adjacent text/CDATA-section nodes
3399         * have been merged.
3400         *
3401         * Strip whitespace-only text-nodes.
3402         * (cctxt-&gt;inode-&gt;stripWhitespace)
3403         */
3404         if ((value == NULL) || (*value == 0) ||
3405         (((cctxt-&gt;inode-&gt;stripWhitespace) ||
3406           (! cctxt-&gt;inode-&gt;preserveWhitespace)) &amp;&amp;
3407          IS_BLANK(*value) &amp;&amp;
3408          xsltIsBlank(value)))
3409         {
3410         if (textNode != cur) {
3411             xmlUnlinkNode(textNode);
3412             xmlFreeNode(textNode);
3413         } else
3414             deleteNode = textNode;
3415         textNode = NULL;
3416         goto next_sibling;
3417         }
3418         /*
3419         * Convert CDATA-section nodes to text-nodes.
3420         * TODO: Can this produce problems?
3421         */
3422         if (textNode-&gt;type != XML_TEXT_NODE) {
3423         textNode-&gt;type = XML_TEXT_NODE;
3424         textNode-&gt;name = xmlStringText;
3425         }
3426         if (internalize &amp;&amp;
3427         (textNode-&gt;content != NULL) &amp;&amp;
3428         (!xmlDictOwns(style-&gt;dict, textNode-&gt;content)))
3429         {
3430         /*
3431         * Internalize the string.
3432         */
3433         value = (xmlChar *) xmlDictLookup(style-&gt;dict,
3434             textNode-&gt;content, -1);
3435         xmlNodeSetContent(textNode, NULL);
3436         textNode-&gt;content = value;
3437         }
3438         textNode = NULL;
3439         /*
3440         * Note that &quot;disable-output-escaping&quot; of the xsl:text
3441         * element will be applied at a later level, when
3442         * XSLT elements are processed.
3443         */
3444     }
3445 
3446 next_sibling:
3447     if (cur-&gt;type == XML_ELEMENT_NODE) {
3448         xsltCompilerNodePop(cctxt, cur);
3449     }
3450     if (cur == node)
3451         break;
3452     if (cur-&gt;next != NULL) {
3453         cur = cur-&gt;next;
3454     } else {
3455         cur = cur-&gt;parent;
3456         inXSLText = 0;
3457         goto next_sibling;
3458     };
3459     }
3460     if (deleteNode != NULL) {
3461 #ifdef WITH_XSLT_DEBUG_PARSING
3462     xsltGenericDebug(xsltGenericDebugContext,
3463      &quot;xsltParsePreprocessStylesheetTree: removing node\n&quot;);
3464 #endif
3465     xmlUnlinkNode(deleteNode);
3466     xmlFreeNode(deleteNode);
3467     }
3468     return(0);
3469 
3470 internal_err:
3471     return(-1);
3472 }
3473 
3474 #endif /* XSLT_REFACTORED */
3475 
3476 #ifdef XSLT_REFACTORED
3477 #else
3478 static void
3479 xsltPreprocessStylesheet(xsltStylesheetPtr style, xmlNodePtr cur)
3480 {
3481     xmlNodePtr deleteNode, styleelem;
3482     int internalize = 0;
3483 
3484     if ((style == NULL) || (cur == NULL))
3485         return;
3486 
3487     if ((cur-&gt;doc != NULL) &amp;&amp; (style-&gt;dict != NULL) &amp;&amp;
3488         (cur-&gt;doc-&gt;dict == style-&gt;dict))
3489     internalize = 1;
3490     else
3491         style-&gt;internalized = 0;
3492 
3493     if ((cur != NULL) &amp;&amp; (IS_XSLT_ELEM(cur)) &amp;&amp;
3494         (IS_XSLT_NAME(cur, &quot;stylesheet&quot;))) {
3495     styleelem = cur;
3496     } else {
3497         styleelem = NULL;
3498     }
3499 
3500     /*
3501      * This content comes from the stylesheet
3502      * For stylesheets, the set of whitespace-preserving
3503      * element names consists of just xsl:text.
3504      */
3505     deleteNode = NULL;
3506     while (cur != NULL) {
3507     if (deleteNode != NULL) {
3508 #ifdef WITH_XSLT_DEBUG_BLANKS
3509         xsltGenericDebug(xsltGenericDebugContext,
3510          &quot;xsltPreprocessStylesheet: removing ignorable blank node\n&quot;);
3511 #endif
3512         xmlUnlinkNode(deleteNode);
3513         xmlFreeNode(deleteNode);
3514         deleteNode = NULL;
3515     }
3516     if (cur-&gt;type == XML_ELEMENT_NODE) {
3517         int exclPrefixes;
3518         /*
3519          * Internalize attributes values.
3520          */
3521         if ((internalize) &amp;&amp; (cur-&gt;properties != NULL)) {
3522             xmlAttrPtr attr = cur-&gt;properties;
3523         xmlNodePtr txt;
3524 
3525         while (attr != NULL) {
3526             txt = attr-&gt;children;
3527             if ((txt != NULL) &amp;&amp; (txt-&gt;type == XML_TEXT_NODE) &amp;&amp;
3528                 (txt-&gt;content != NULL) &amp;&amp;
3529             (!xmlDictOwns(style-&gt;dict, txt-&gt;content)))
3530             {
3531             xmlChar *tmp;
3532 
3533             /*
3534              * internalize the text string, goal is to speed
3535              * up operations and minimize used space by compiled
3536              * stylesheets.
3537              */
3538             tmp = (xmlChar *) xmlDictLookup(style-&gt;dict,
3539                                             txt-&gt;content, -1);
3540             if (tmp != txt-&gt;content) {
3541                 xmlNodeSetContent(txt, NULL);
3542                 txt-&gt;content = tmp;
3543             }
3544             }
3545             attr = attr-&gt;next;
3546         }
3547         }
3548         if (IS_XSLT_ELEM(cur)) {
3549         exclPrefixes = 0;
3550         if (IS_XSLT_NAME(cur, &quot;text&quot;)) {
3551             for (;exclPrefixes &gt; 0;exclPrefixes--)
3552             exclPrefixPop(style);
3553             goto skip_children;
3554         }
3555         } else {
3556         exclPrefixes = xsltParseStylesheetExcludePrefix(style, cur, 0);
3557         }
3558 
3559         if ((cur-&gt;nsDef != NULL) &amp;&amp; (style-&gt;exclPrefixNr &gt; 0)) {
3560         xmlNsPtr ns = cur-&gt;nsDef, prev = NULL, next;
3561         xmlNodePtr root = NULL;
3562         int i, moved;
3563 
3564         root = xmlDocGetRootElement(cur-&gt;doc);
3565         if ((root != NULL) &amp;&amp; (root != cur)) {
3566             while (ns != NULL) {
3567             moved = 0;
3568             next = ns-&gt;next;
3569             for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
3570                 if ((ns-&gt;prefix != NULL) &amp;&amp;
3571                     (xmlStrEqual(ns-&gt;href,
3572                          style-&gt;exclPrefixTab[i]))) {
3573                 /*
3574                  * Move the namespace definition on the root
3575                  * element to avoid duplicating it without
3576                  * loosing it.
3577                  */
3578                 if (prev == NULL) {
3579                     cur-&gt;nsDef = ns-&gt;next;
3580                 } else {
3581                     prev-&gt;next = ns-&gt;next;
3582                 }
3583                 ns-&gt;next = root-&gt;nsDef;
3584                 root-&gt;nsDef = ns;
3585                 moved = 1;
3586                 break;
3587                 }
3588             }
3589             if (moved == 0)
3590                 prev = ns;
3591             ns = next;
3592             }
3593         }
3594         }
3595         /*
3596          * If we have prefixes locally, recurse and pop them up when
3597          * going back
3598          */
3599         if (exclPrefixes &gt; 0) {
3600         xsltPreprocessStylesheet(style, cur-&gt;children);
3601         for (;exclPrefixes &gt; 0;exclPrefixes--)
3602             exclPrefixPop(style);
3603         goto skip_children;
3604         }
3605     } else if (cur-&gt;type == XML_TEXT_NODE) {
3606         if (IS_BLANK_NODE(cur)) {
3607         if (xmlNodeGetSpacePreserve(cur-&gt;parent) != 1) {
3608             deleteNode = cur;
3609         }
3610         } else if ((cur-&gt;content != NULL) &amp;&amp; (internalize) &amp;&amp;
3611                    (!xmlDictOwns(style-&gt;dict, cur-&gt;content))) {
3612         xmlChar *tmp;
3613 
3614         /*
3615          * internalize the text string, goal is to speed
3616          * up operations and minimize used space by compiled
3617          * stylesheets.
3618          */
3619         tmp = (xmlChar *) xmlDictLookup(style-&gt;dict, cur-&gt;content, -1);
3620         xmlNodeSetContent(cur, NULL);
3621         cur-&gt;content = tmp;
3622         }
3623     } else if ((cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3624            (cur-&gt;type != XML_CDATA_SECTION_NODE)) {
3625         deleteNode = cur;
3626         goto skip_children;
3627     }
3628 
3629     /*
3630      * Skip to next node. In case of a namespaced element children of
3631      * the stylesheet and not in the XSLT namespace and not an extension
3632      * element, ignore its content.
3633      */
3634     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
3635         (styleelem != NULL) &amp;&amp; (cur-&gt;parent == styleelem) &amp;&amp;
3636         (!xmlStrEqual(cur-&gt;ns-&gt;href, XSLT_NAMESPACE)) &amp;&amp;
3637         (!xsltCheckExtURI(style, cur-&gt;ns-&gt;href))) {
3638         goto skip_children;
3639     } else if (cur-&gt;children != NULL) {
3640         if ((cur-&gt;children-&gt;type != XML_ENTITY_DECL) &amp;&amp;
3641         (cur-&gt;children-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
3642         (cur-&gt;children-&gt;type != XML_ENTITY_NODE)) {
3643         cur = cur-&gt;children;
3644         continue;
3645         }
3646     }
3647 
3648 skip_children:
3649     if (cur-&gt;next != NULL) {
3650         cur = cur-&gt;next;
3651         continue;
3652     }
3653     do {
3654 
3655         cur = cur-&gt;parent;
3656         if (cur == NULL)
3657         break;
3658         if (cur == (xmlNodePtr) style-&gt;doc) {
3659         cur = NULL;
3660         break;
3661         }
3662         if (cur-&gt;next != NULL) {
3663         cur = cur-&gt;next;
3664         break;
3665         }
3666     } while (cur != NULL);
3667     }
3668     if (deleteNode != NULL) {
3669 #ifdef WITH_XSLT_DEBUG_PARSING
3670     xsltGenericDebug(xsltGenericDebugContext,
3671      &quot;xsltPreprocessStylesheet: removing ignorable blank node\n&quot;);
3672 #endif
3673     xmlUnlinkNode(deleteNode);
3674     xmlFreeNode(deleteNode);
3675     }
3676 }
3677 #endif /* end of else XSLT_REFACTORED */
3678 
3679 /**
3680  * xsltGatherNamespaces:
3681  * @style:  the XSLT stylesheet
3682  *
3683  * Browse the stylesheet and build the namspace hash table which
3684  * will be used for XPath interpretation. If needed do a bit of normalization
3685  */
3686 
3687 static void
3688 xsltGatherNamespaces(xsltStylesheetPtr style) {
3689     xmlNodePtr cur;
3690     const xmlChar *URI;
3691 
3692     if (style == NULL)
3693         return;
3694     /*
3695      * TODO: basically if the stylesheet uses the same prefix for different
3696      *       patterns, well they may be in problem, hopefully they will get
3697      *       a warning first.
3698      */
3699     /*
3700     * TODO: Eliminate the use of the hash for XPath expressions.
3701     *   An expression should be evaluated in the context of the in-scope
3702     *   namespaces; eliminate the restriction of an XML document to contain
3703     *   no duplicate prefixes for different namespace names.
3704     *
3705     */
3706     cur = xmlDocGetRootElement(style-&gt;doc);
3707     while (cur != NULL) {
3708     if (cur-&gt;type == XML_ELEMENT_NODE) {
3709         xmlNsPtr ns = cur-&gt;nsDef;
3710         while (ns != NULL) {
3711         if (ns-&gt;prefix != NULL) {
3712             if (style-&gt;nsHash == NULL) {
3713             style-&gt;nsHash = xmlHashCreate(10);
3714             if (style-&gt;nsHash == NULL) {
3715                 xsltTransformError(NULL, style, cur,
3716          &quot;xsltGatherNamespaces: failed to create hash table\n&quot;);
3717                 style-&gt;errors++;
3718                 return;
3719             }
3720             }
3721             URI = xmlHashLookup(style-&gt;nsHash, ns-&gt;prefix);
3722             if ((URI != NULL) &amp;&amp; (!xmlStrEqual(URI, ns-&gt;href))) {
3723             xsltTransformError(NULL, style, cur,
3724          &quot;Namespaces prefix %s used for multiple namespaces\n&quot;,ns-&gt;prefix);
3725             style-&gt;warnings++;
3726             } else if (URI == NULL) {
3727             xmlHashUpdateEntry(style-&gt;nsHash, ns-&gt;prefix,
3728                 (void *) ns-&gt;href, NULL);
3729 
3730 #ifdef WITH_XSLT_DEBUG_PARSING
3731             xsltGenericDebug(xsltGenericDebugContext,
3732          &quot;Added namespace: %s mapped to %s\n&quot;, ns-&gt;prefix, ns-&gt;href);
3733 #endif
3734             }
3735         }
3736         ns = ns-&gt;next;
3737         }
3738     }
3739 
3740     /*
3741      * Skip to next node
3742      */
3743     if (cur-&gt;children != NULL) {
3744         if (cur-&gt;children-&gt;type != XML_ENTITY_DECL) {
3745         cur = cur-&gt;children;
3746         continue;
3747         }
3748     }
3749     if (cur-&gt;next != NULL) {
3750         cur = cur-&gt;next;
3751         continue;
3752     }
3753 
3754     do {
3755         cur = cur-&gt;parent;
3756         if (cur == NULL)
3757         break;
3758         if (cur == (xmlNodePtr) style-&gt;doc) {
3759         cur = NULL;
3760         break;
3761         }
3762         if (cur-&gt;next != NULL) {
3763         cur = cur-&gt;next;
3764         break;
3765         }
3766     } while (cur != NULL);
3767     }
3768 }
3769 
3770 #ifdef XSLT_REFACTORED
3771 
3772 static xsltStyleType
3773 xsltGetXSLTElementTypeByNode(xsltCompilerCtxtPtr cctxt,
3774                  xmlNodePtr node)
3775 {
3776     if ((node == NULL) || (node-&gt;type != XML_ELEMENT_NODE) ||
3777     (node-&gt;name == NULL))
3778     return(0);
3779 
3780     if (node-&gt;name[0] == &#39;a&#39;) {
3781     if (IS_XSLT_NAME(node, &quot;apply-templates&quot;))
3782         return(XSLT_FUNC_APPLYTEMPLATES);
3783     else if (IS_XSLT_NAME(node, &quot;attribute&quot;))
3784         return(XSLT_FUNC_ATTRIBUTE);
3785     else if (IS_XSLT_NAME(node, &quot;apply-imports&quot;))
3786         return(XSLT_FUNC_APPLYIMPORTS);
3787     else if (IS_XSLT_NAME(node, &quot;attribute-set&quot;))
3788         return(0);
3789 
3790     } else if (node-&gt;name[0] == &#39;c&#39;) {
3791     if (IS_XSLT_NAME(node, &quot;choose&quot;))
3792         return(XSLT_FUNC_CHOOSE);
3793     else if (IS_XSLT_NAME(node, &quot;copy&quot;))
3794         return(XSLT_FUNC_COPY);
3795     else if (IS_XSLT_NAME(node, &quot;copy-of&quot;))
3796         return(XSLT_FUNC_COPYOF);
3797     else if (IS_XSLT_NAME(node, &quot;call-template&quot;))
3798         return(XSLT_FUNC_CALLTEMPLATE);
3799     else if (IS_XSLT_NAME(node, &quot;comment&quot;))
3800         return(XSLT_FUNC_COMMENT);
3801 
3802     } else if (node-&gt;name[0] == &#39;d&#39;) {
3803     if (IS_XSLT_NAME(node, &quot;document&quot;))
3804         return(XSLT_FUNC_DOCUMENT);
3805     else if (IS_XSLT_NAME(node, &quot;decimal-format&quot;))
3806         return(0);
3807 
3808     } else if (node-&gt;name[0] == &#39;e&#39;) {
3809     if (IS_XSLT_NAME(node, &quot;element&quot;))
3810         return(XSLT_FUNC_ELEMENT);
3811 
3812     } else if (node-&gt;name[0] == &#39;f&#39;) {
3813     if (IS_XSLT_NAME(node, &quot;for-each&quot;))
3814         return(XSLT_FUNC_FOREACH);
3815     else if (IS_XSLT_NAME(node, &quot;fallback&quot;))
3816         return(XSLT_FUNC_FALLBACK);
3817 
3818     } else if (*(node-&gt;name) == &#39;i&#39;) {
3819     if (IS_XSLT_NAME(node, &quot;if&quot;))
3820         return(XSLT_FUNC_IF);
3821     else if (IS_XSLT_NAME(node, &quot;include&quot;))
3822         return(0);
3823     else if (IS_XSLT_NAME(node, &quot;import&quot;))
3824         return(0);
3825 
3826     } else if (*(node-&gt;name) == &#39;k&#39;) {
3827     if (IS_XSLT_NAME(node, &quot;key&quot;))
3828         return(0);
3829 
3830     } else if (*(node-&gt;name) == &#39;m&#39;) {
3831     if (IS_XSLT_NAME(node, &quot;message&quot;))
3832         return(XSLT_FUNC_MESSAGE);
3833 
3834     } else if (*(node-&gt;name) == &#39;n&#39;) {
3835     if (IS_XSLT_NAME(node, &quot;number&quot;))
3836         return(XSLT_FUNC_NUMBER);
3837     else if (IS_XSLT_NAME(node, &quot;namespace-alias&quot;))
3838         return(0);
3839 
3840     } else if (*(node-&gt;name) == &#39;o&#39;) {
3841     if (IS_XSLT_NAME(node, &quot;otherwise&quot;))
3842         return(XSLT_FUNC_OTHERWISE);
3843     else if (IS_XSLT_NAME(node, &quot;output&quot;))
3844         return(0);
3845 
3846     } else if (*(node-&gt;name) == &#39;p&#39;) {
3847     if (IS_XSLT_NAME(node, &quot;param&quot;))
3848         return(XSLT_FUNC_PARAM);
3849     else if (IS_XSLT_NAME(node, &quot;processing-instruction&quot;))
3850         return(XSLT_FUNC_PI);
3851     else if (IS_XSLT_NAME(node, &quot;preserve-space&quot;))
3852         return(0);
3853 
3854     } else if (*(node-&gt;name) == &#39;s&#39;) {
3855     if (IS_XSLT_NAME(node, &quot;sort&quot;))
3856         return(XSLT_FUNC_SORT);
3857     else if (IS_XSLT_NAME(node, &quot;strip-space&quot;))
3858         return(0);
3859     else if (IS_XSLT_NAME(node, &quot;stylesheet&quot;))
3860         return(0);
3861 
3862     } else if (node-&gt;name[0] == &#39;t&#39;) {
3863     if (IS_XSLT_NAME(node, &quot;text&quot;))
3864         return(XSLT_FUNC_TEXT);
3865     else if (IS_XSLT_NAME(node, &quot;template&quot;))
3866         return(0);
3867     else if (IS_XSLT_NAME(node, &quot;transform&quot;))
3868         return(0);
3869 
3870     } else if (*(node-&gt;name) == &#39;v&#39;) {
3871     if (IS_XSLT_NAME(node, &quot;value-of&quot;))
3872         return(XSLT_FUNC_VALUEOF);
3873     else if (IS_XSLT_NAME(node, &quot;variable&quot;))
3874         return(XSLT_FUNC_VARIABLE);
3875 
3876     } else if (*(node-&gt;name) == &#39;w&#39;) {
3877     if (IS_XSLT_NAME(node, &quot;when&quot;))
3878         return(XSLT_FUNC_WHEN);
3879     if (IS_XSLT_NAME(node, &quot;with-param&quot;))
3880         return(XSLT_FUNC_WITHPARAM);
3881     }
3882     return(0);
3883 }
3884 
3885 /**
3886  * xsltParseAnyXSLTElem:
3887  *
3888  * @cctxt: the compilation context
3889  * @elem: the element node of the XSLT instruction
3890  *
3891  * Parses, validates the content models and compiles XSLT instructions.
3892  *
3893  * Returns 0 if everything&#39;s fine;
3894  *         -1 on API or internal errors.
3895  */
3896 int
3897 xsltParseAnyXSLTElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr elem)
3898 {
3899     if ((cctxt == NULL) || (elem == NULL) ||
3900     (elem-&gt;type != XML_ELEMENT_NODE))
3901     return(-1);
3902 
3903     elem-&gt;psvi = NULL;
3904 
3905     if (! (IS_XSLT_ELEM_FAST(elem)))
3906     return(-1);
3907     /*
3908     * Detection of handled content of extension instructions.
3909     */
3910     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
3911     cctxt-&gt;inode-&gt;extContentHandled = 1;
3912     }
3913 
3914     xsltCompilerNodePush(cctxt, elem);
3915     /*
3916     * URGENT TODO: Find a way to speed up this annoying redundant
3917     *  textual node-name and namespace comparison.
3918     */
3919     if (cctxt-&gt;inode-&gt;prev-&gt;curChildType != 0)
3920     cctxt-&gt;inode-&gt;type = cctxt-&gt;inode-&gt;prev-&gt;curChildType;
3921     else
3922     cctxt-&gt;inode-&gt;type = xsltGetXSLTElementTypeByNode(cctxt, elem);
3923     /*
3924     * Update the in-scope namespaces if needed.
3925     */
3926     if (elem-&gt;nsDef != NULL)
3927     cctxt-&gt;inode-&gt;inScopeNs =
3928         xsltCompilerBuildInScopeNsList(cctxt, elem);
3929     /*
3930     * xsltStylePreCompute():
3931     *  This will compile the information found on the current
3932     *  element&#39;s attributes. NOTE that this won&#39;t process the
3933     *  children of the instruction.
3934     */
3935     xsltStylePreCompute(cctxt-&gt;style, elem);
3936     /*
3937     * TODO: How to react on errors in xsltStylePreCompute() ?
3938     */
3939 
3940     /*
3941     * Validate the content model of the XSLT-element.
3942     */
3943     switch (cctxt-&gt;inode-&gt;type) {
3944     case XSLT_FUNC_APPLYIMPORTS:
3945         /* EMPTY */
3946         goto empty_content;
3947     case XSLT_FUNC_APPLYTEMPLATES:
3948         /* &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt; */
3949         goto apply_templates;
3950     case XSLT_FUNC_ATTRIBUTE:
3951         /* &lt;!-- Content: template --&gt; */
3952         goto sequence_constructor;
3953     case XSLT_FUNC_CALLTEMPLATE:
3954         /* &lt;!-- Content: xsl:with-param* --&gt; */
3955         goto call_template;
3956     case XSLT_FUNC_CHOOSE:
3957         /* &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt; */
3958         goto choose;
3959     case XSLT_FUNC_COMMENT:
3960         /* &lt;!-- Content: template --&gt; */
3961         goto sequence_constructor;
3962     case XSLT_FUNC_COPY:
3963         /* &lt;!-- Content: template --&gt; */
3964         goto sequence_constructor;
3965     case XSLT_FUNC_COPYOF:
3966         /* EMPTY */
3967         goto empty_content;
3968     case XSLT_FUNC_DOCUMENT: /* Extra one */
3969         /* ?? template ?? */
3970         goto sequence_constructor;
3971     case XSLT_FUNC_ELEMENT:
3972         /* &lt;!-- Content: template --&gt; */
3973         goto sequence_constructor;
3974     case XSLT_FUNC_FALLBACK:
3975         /* &lt;!-- Content: template --&gt; */
3976         goto sequence_constructor;
3977     case XSLT_FUNC_FOREACH:
3978         /* &lt;!-- Content: (xsl:sort*, template) --&gt; */
3979         goto for_each;
3980     case XSLT_FUNC_IF:
3981         /* &lt;!-- Content: template --&gt; */
3982         goto sequence_constructor;
3983     case XSLT_FUNC_OTHERWISE:
3984         /* &lt;!-- Content: template --&gt; */
3985         goto sequence_constructor;
3986     case XSLT_FUNC_MESSAGE:
3987         /* &lt;!-- Content: template --&gt; */
3988         goto sequence_constructor;
3989     case XSLT_FUNC_NUMBER:
3990         /* EMPTY */
3991         goto empty_content;
3992     case XSLT_FUNC_PARAM:
3993         /*
3994         * Check for redefinition.
3995         */
3996         if ((elem-&gt;psvi != NULL) &amp;&amp; (cctxt-&gt;ivar != NULL)) {
3997         xsltVarInfoPtr ivar = cctxt-&gt;ivar;
3998 
3999         do {
4000             if ((ivar-&gt;name ==
4001              ((xsltStyleItemParamPtr) elem-&gt;psvi)-&gt;name) &amp;&amp;
4002             (ivar-&gt;nsName ==
4003              ((xsltStyleItemParamPtr) elem-&gt;psvi)-&gt;ns))
4004             {
4005             elem-&gt;psvi = NULL;
4006             xsltTransformError(NULL, cctxt-&gt;style, elem,
4007                 &quot;Redefinition of variable or parameter &#39;%s&#39;.\n&quot;,
4008                 ivar-&gt;name);
4009             cctxt-&gt;style-&gt;errors++;
4010             goto error;
4011             }
4012             ivar = ivar-&gt;prev;
4013         } while (ivar != NULL);
4014         }
4015         /*  &lt;!-- Content: template --&gt; */
4016         goto sequence_constructor;
4017     case XSLT_FUNC_PI:
4018         /*  &lt;!-- Content: template --&gt; */
4019         goto sequence_constructor;
4020     case XSLT_FUNC_SORT:
4021         /* EMPTY */
4022         goto empty_content;
4023     case XSLT_FUNC_TEXT:
4024         /* &lt;!-- Content: #PCDATA --&gt; */
4025         goto text;
4026     case XSLT_FUNC_VALUEOF:
4027         /* EMPTY */
4028         goto empty_content;
4029     case XSLT_FUNC_VARIABLE:
4030         /*
4031         * Check for redefinition.
4032         */
4033         if ((elem-&gt;psvi != NULL) &amp;&amp; (cctxt-&gt;ivar != NULL)) {
4034         xsltVarInfoPtr ivar = cctxt-&gt;ivar;
4035 
4036         do {
4037             if ((ivar-&gt;name ==
4038              ((xsltStyleItemVariablePtr) elem-&gt;psvi)-&gt;name) &amp;&amp;
4039             (ivar-&gt;nsName ==
4040              ((xsltStyleItemVariablePtr) elem-&gt;psvi)-&gt;ns))
4041             {
4042             elem-&gt;psvi = NULL;
4043             xsltTransformError(NULL, cctxt-&gt;style, elem,
4044                 &quot;Redefinition of variable or parameter &#39;%s&#39;.\n&quot;,
4045                 ivar-&gt;name);
4046             cctxt-&gt;style-&gt;errors++;
4047             goto error;
4048             }
4049             ivar = ivar-&gt;prev;
4050         } while (ivar != NULL);
4051         }
4052         /* &lt;!-- Content: template --&gt; */
4053         goto sequence_constructor;
4054     case XSLT_FUNC_WHEN:
4055         /* &lt;!-- Content: template --&gt; */
4056         goto sequence_constructor;
4057     case XSLT_FUNC_WITHPARAM:
4058         /* &lt;!-- Content: template --&gt; */
4059         goto sequence_constructor;
4060     default:
4061 #ifdef WITH_XSLT_DEBUG_PARSING
4062         xsltGenericDebug(xsltGenericDebugContext,
4063         &quot;xsltParseXSLTNode: Unhandled XSLT element &#39;%s&#39;.\n&quot;,
4064         elem-&gt;name);
4065 #endif
4066         xsltTransformError(NULL, cctxt-&gt;style, elem,
4067         &quot;xsltParseXSLTNode: Internal error; &quot;
4068         &quot;unhandled XSLT element &#39;%s&#39;.\n&quot;, elem-&gt;name);
4069         cctxt-&gt;style-&gt;errors++;
4070         goto internal_err;
4071     }
4072 
4073 apply_templates:
4074     /* &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt; */
4075     if (elem-&gt;children != NULL) {
4076     xmlNodePtr child = elem-&gt;children;
4077     do {
4078         if (child-&gt;type == XML_ELEMENT_NODE) {
4079         if (IS_XSLT_ELEM_FAST(child)) {
4080             if (xmlStrEqual(child-&gt;name, BAD_CAST &quot;with-param&quot;)) {
4081             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WITHPARAM;
4082             xsltParseAnyXSLTElem(cctxt, child);
4083             } else if (xmlStrEqual(child-&gt;name, BAD_CAST &quot;sort&quot;)) {
4084             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_SORT;
4085             xsltParseAnyXSLTElem(cctxt, child);
4086             } else
4087             xsltParseContentError(cctxt-&gt;style, child);
4088         } else
4089             xsltParseContentError(cctxt-&gt;style, child);
4090         }
4091         child = child-&gt;next;
4092     } while (child != NULL);
4093     }
4094     goto exit;
4095 
4096 call_template:
4097     /* &lt;!-- Content: xsl:with-param* --&gt; */
4098     if (elem-&gt;children != NULL) {
4099     xmlNodePtr child = elem-&gt;children;
4100     do {
4101         if (child-&gt;type == XML_ELEMENT_NODE) {
4102         if (IS_XSLT_ELEM_FAST(child)) {
4103             xsltStyleType type;
4104 
4105             type = xsltGetXSLTElementTypeByNode(cctxt, child);
4106             if (type == XSLT_FUNC_WITHPARAM) {
4107             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WITHPARAM;
4108             xsltParseAnyXSLTElem(cctxt, child);
4109             } else {
4110             xsltParseContentError(cctxt-&gt;style, child);
4111             }
4112         } else
4113             xsltParseContentError(cctxt-&gt;style, child);
4114         }
4115         child = child-&gt;next;
4116     } while (child != NULL);
4117     }
4118     goto exit;
4119 
4120 text:
4121     if (elem-&gt;children != NULL) {
4122     xmlNodePtr child = elem-&gt;children;
4123     do {
4124         if ((child-&gt;type != XML_TEXT_NODE) &amp;&amp;
4125         (child-&gt;type != XML_CDATA_SECTION_NODE))
4126         {
4127         xsltTransformError(NULL, cctxt-&gt;style, elem,
4128             &quot;The XSLT &#39;text&#39; element must have only character &quot;
4129             &quot;data as content.\n&quot;);
4130         }
4131         child = child-&gt;next;
4132     } while (child != NULL);
4133     }
4134     goto exit;
4135 
4136 empty_content:
4137     if (elem-&gt;children != NULL) {
4138     xmlNodePtr child = elem-&gt;children;
4139     /*
4140     * Relaxed behaviour: we will allow whitespace-only text-nodes.
4141     */
4142     do {
4143         if (((child-&gt;type != XML_TEXT_NODE) &amp;&amp;
4144          (child-&gt;type != XML_CDATA_SECTION_NODE)) ||
4145         (! IS_BLANK_NODE(child)))
4146         {
4147         xsltTransformError(NULL, cctxt-&gt;style, elem,
4148             &quot;This XSLT element must have no content.\n&quot;);
4149         cctxt-&gt;style-&gt;errors++;
4150         break;
4151         }
4152         child = child-&gt;next;
4153     } while (child != NULL);
4154     }
4155     goto exit;
4156 
4157 choose:
4158     /* &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt; */
4159     /*
4160     * TODO: text-nodes in between are *not* allowed in XSLT 1.0.
4161     *   The old behaviour did not check this.
4162     * NOTE: In XSLT 2.0 they are stripped beforehand
4163     *  if whitespace-only (regardless of xml:space).
4164     */
4165     if (elem-&gt;children != NULL) {
4166     xmlNodePtr child = elem-&gt;children;
4167     int nbWhen = 0, nbOtherwise = 0, err = 0;
4168     do {
4169         if (child-&gt;type == XML_ELEMENT_NODE) {
4170         if (IS_XSLT_ELEM_FAST(child)) {
4171             xsltStyleType type;
4172 
4173             type = xsltGetXSLTElementTypeByNode(cctxt, child);
4174             if (type == XSLT_FUNC_WHEN) {
4175             nbWhen++;
4176             if (nbOtherwise) {
4177                 xsltParseContentError(cctxt-&gt;style, child);
4178                 err = 1;
4179                 break;
4180             }
4181             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WHEN;
4182             xsltParseAnyXSLTElem(cctxt, child);
4183             } else if (type == XSLT_FUNC_OTHERWISE) {
4184             if (! nbWhen) {
4185                 xsltParseContentError(cctxt-&gt;style, child);
4186                 err = 1;
4187                 break;
4188             }
4189             if (nbOtherwise) {
4190                 xsltTransformError(NULL, cctxt-&gt;style, elem,
4191                 &quot;The XSLT &#39;choose&#39; element must not contain &quot;
4192                 &quot;more than one XSLT &#39;otherwise&#39; element.\n&quot;);
4193                 cctxt-&gt;style-&gt;errors++;
4194                 err = 1;
4195                 break;
4196             }
4197             nbOtherwise++;
4198             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_OTHERWISE;
4199             xsltParseAnyXSLTElem(cctxt, child);
4200             } else
4201             xsltParseContentError(cctxt-&gt;style, child);
4202         } else
4203             xsltParseContentError(cctxt-&gt;style, child);
4204         }
4205         /*
4206         else
4207             xsltParseContentError(cctxt, child);
4208         */
4209         child = child-&gt;next;
4210     } while (child != NULL);
4211     if ((! err) &amp;&amp; (! nbWhen)) {
4212         xsltTransformError(NULL, cctxt-&gt;style, elem,
4213         &quot;The XSLT element &#39;choose&#39; must contain at least one &quot;
4214         &quot;XSLT element &#39;when&#39;.\n&quot;);
4215         cctxt-&gt;style-&gt;errors++;
4216     }
4217     }
4218     goto exit;
4219 
4220 for_each:
4221     /* &lt;!-- Content: (xsl:sort*, template) --&gt; */
4222     /*
4223     * NOTE: Text-nodes before xsl:sort are *not* allowed in XSLT 1.0.
4224     *   The old behaviour did not allow this, but it catched this
4225     *   only at transformation-time.
4226     *   In XSLT 2.0 they are stripped beforehand if whitespace-only
4227     *   (regardless of xml:space).
4228     */
4229     if (elem-&gt;children != NULL) {
4230     xmlNodePtr child = elem-&gt;children;
4231     /*
4232     * Parse xsl:sort first.
4233     */
4234     do {
4235         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4236         IS_XSLT_ELEM_FAST(child))
4237         {
4238         if (xsltGetXSLTElementTypeByNode(cctxt, child) ==
4239             XSLT_FUNC_SORT)
4240         {
4241             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_SORT;
4242             xsltParseAnyXSLTElem(cctxt, child);
4243         } else
4244             break;
4245         } else
4246         break;
4247         child = child-&gt;next;
4248     } while (child != NULL);
4249     /*
4250     * Parse the sequece constructor.
4251     */
4252     if (child != NULL)
4253         xsltParseSequenceConstructor(cctxt, child);
4254     }
4255     goto exit;
4256 
4257 sequence_constructor:
4258     /*
4259     * Parse the sequence constructor.
4260     */
4261     if (elem-&gt;children != NULL)
4262     xsltParseSequenceConstructor(cctxt, elem-&gt;children);
4263 
4264     /*
4265     * Register information for vars/params. Only needed if there
4266     * are any following siblings.
4267     */
4268     if ((elem-&gt;next != NULL) &amp;&amp;
4269     ((cctxt-&gt;inode-&gt;type == XSLT_FUNC_VARIABLE) ||
4270      (cctxt-&gt;inode-&gt;type == XSLT_FUNC_PARAM)))
4271     {
4272     if ((elem-&gt;psvi != NULL) &amp;&amp;
4273         (((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;name))
4274     {
4275         xsltCompilerVarInfoPush(cctxt, elem,
4276         ((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;name,
4277         ((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;ns);
4278     }
4279     }
4280 
4281 error:
4282 exit:
4283     xsltCompilerNodePop(cctxt, elem);
4284     return(0);
4285 
4286 internal_err:
4287     xsltCompilerNodePop(cctxt, elem);
4288     return(-1);
4289 }
4290 
4291 /**
4292  * xsltForwardsCompatUnkownItemCreate:
4293  *
4294  * @cctxt: the compilation context
4295  *
4296  * Creates a compiled representation of the unknown
4297  * XSLT instruction.
4298  *
4299  * Returns the compiled representation.
4300  */
4301 static xsltStyleItemUknownPtr
4302 xsltForwardsCompatUnkownItemCreate(xsltCompilerCtxtPtr cctxt)
4303 {
4304     xsltStyleItemUknownPtr item;
4305 
4306     item = (xsltStyleItemUknownPtr) xmlMalloc(sizeof(xsltStyleItemUknown));
4307     if (item == NULL) {
4308     xsltTransformError(NULL, cctxt-&gt;style, NULL,
4309         &quot;Internal error in xsltForwardsCompatUnkownItemCreate(): &quot;
4310         &quot;Failed to allocate memory.\n&quot;);
4311     cctxt-&gt;style-&gt;errors++;
4312     return(NULL);
4313     }
4314     memset(item, 0, sizeof(xsltStyleItemUknown));
4315     item-&gt;type = XSLT_FUNC_UNKOWN_FORWARDS_COMPAT;
4316     /*
4317     * Store it in the stylesheet.
4318     */
4319     item-&gt;next = cctxt-&gt;style-&gt;preComps;
4320     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
4321     return(item);
4322 }
4323 
4324 /**
4325  * xsltParseUnknownXSLTElem:
4326  *
4327  * @cctxt: the compilation context
4328  * @node: the element of the unknown XSLT instruction
4329  *
4330  * Parses an unknown XSLT element.
4331  * If forwards compatible mode is enabled this will allow
4332  * such an unknown XSLT and; otherwise it is rejected.
4333  *
4334  * Returns 1 in the unknown XSLT instruction is rejected,
4335  *         0 if everything&#39;s fine and
4336  *         -1 on API or internal errors.
4337  */
4338 static int
4339 xsltParseUnknownXSLTElem(xsltCompilerCtxtPtr cctxt,
4340                 xmlNodePtr node)
4341 {
4342     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
4343     return(-1);
4344 
4345     /*
4346     * Detection of handled content of extension instructions.
4347     */
4348     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4349     cctxt-&gt;inode-&gt;extContentHandled = 1;
4350     }
4351     if (cctxt-&gt;inode-&gt;forwardsCompat == 0) {
4352     /*
4353     * We are not in forwards-compatible mode, so raise an error.
4354     */
4355     xsltTransformError(NULL, cctxt-&gt;style, node,
4356         &quot;Unknown XSLT element &#39;%s&#39;.\n&quot;, node-&gt;name);
4357     cctxt-&gt;style-&gt;errors++;
4358     return(1);
4359     }
4360     /*
4361     * Forwards-compatible mode.
4362     * ------------------------
4363     *
4364     * Parse/compile xsl:fallback elements.
4365     *
4366     * QUESTION: Do we have to raise an error if there&#39;s no xsl:fallback?
4367     * ANSWER: No, since in the stylesheet the fallback behaviour might
4368     *  also be provided by using the XSLT function &quot;element-available&quot;.
4369     */
4370     if (cctxt-&gt;unknownItem == NULL) {
4371     /*
4372     * Create a singleton for all unknown XSLT instructions.
4373     */
4374     cctxt-&gt;unknownItem = xsltForwardsCompatUnkownItemCreate(cctxt);
4375     if (cctxt-&gt;unknownItem == NULL) {
4376         node-&gt;psvi = NULL;
4377         return(-1);
4378     }
4379     }
4380     node-&gt;psvi = cctxt-&gt;unknownItem;
4381     if (node-&gt;children == NULL)
4382     return(0);
4383     else {
4384     xmlNodePtr child = node-&gt;children;
4385 
4386     xsltCompilerNodePush(cctxt, node);
4387     /*
4388     * Update the in-scope namespaces if needed.
4389     */
4390     if (node-&gt;nsDef != NULL)
4391         cctxt-&gt;inode-&gt;inScopeNs =
4392         xsltCompilerBuildInScopeNsList(cctxt, node);
4393     /*
4394     * Parse all xsl:fallback children.
4395     */
4396     do {
4397         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4398         IS_XSLT_ELEM_FAST(child) &amp;&amp;
4399         IS_XSLT_NAME(child, &quot;fallback&quot;))
4400         {
4401         cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_FALLBACK;
4402         xsltParseAnyXSLTElem(cctxt, child);
4403         }
4404         child = child-&gt;next;
4405     } while (child != NULL);
4406 
4407     xsltCompilerNodePop(cctxt, node);
4408     }
4409     return(0);
4410 }
4411 
4412 /**
4413  * xsltParseSequenceConstructor:
4414  *
4415  * @cctxt: the compilation context
4416  * @cur: the start-node of the content to be parsed
4417  *
4418  * Parses a &quot;template&quot; content (or &quot;sequence constructor&quot; in XSLT 2.0 terms).
4419  * This will additionally remove xsl:text elements from the tree.
4420  */
4421 void
4422 xsltParseSequenceConstructor(xsltCompilerCtxtPtr cctxt, xmlNodePtr cur)
4423 {
4424     xsltStyleType type;
4425     xmlNodePtr deleteNode = NULL;
4426 
4427     if (cctxt == NULL) {
4428     xmlGenericError(xmlGenericErrorContext,
4429         &quot;xsltParseSequenceConstructor: Bad arguments\n&quot;);
4430     cctxt-&gt;style-&gt;errors++;
4431     return;
4432     }
4433     /*
4434     * Detection of handled content of extension instructions.
4435     */
4436     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4437     cctxt-&gt;inode-&gt;extContentHandled = 1;
4438     }
4439     if ((cur == NULL) || (cur-&gt;type == XML_NAMESPACE_DECL))
4440     return;
4441     /*
4442     * This is the content reffered to as a &quot;template&quot;.
4443     * E.g. an xsl:element has such content model:
4444     * &lt;xsl:element
4445     *   name = { qname }
4446     *   namespace = { uri-reference }
4447     *   use-attribute-sets = qnames&gt;
4448     * &lt;!-- Content: template --&gt;
4449     *
4450     * NOTE that in XSLT-2 the term &quot;template&quot; was abandoned due to
4451     *  confusion with xsl:template and the term &quot;sequence constructor&quot;
4452     *  was introduced instead.
4453     *
4454     * The following XSLT-instructions are allowed to appear:
4455     *  xsl:apply-templates, xsl:call-template, xsl:apply-imports,
4456     *  xsl:for-each, xsl:value-of, xsl:copy-of, xsl:number,
4457     *  xsl:choose, xsl:if, xsl:text, xsl:copy, xsl:variable,
4458     *  xsl:message, xsl:fallback,
4459     *  xsl:processing-instruction, xsl:comment, xsl:element
4460     *  xsl:attribute.
4461     * Additional allowed content:
4462     * 1) extension instructions
4463     * 2) literal result elements
4464     * 3) PCDATA
4465     *
4466     * NOTE that this content model does *not* allow xsl:param.
4467     */
4468     while (cur != NULL) {
4469     if (deleteNode != NULL) {
4470 #ifdef WITH_XSLT_DEBUG_BLANKS
4471         xsltGenericDebug(xsltGenericDebugContext,
4472          &quot;xsltParseSequenceConstructor: removing xsl:text element\n&quot;);
4473 #endif
4474         xmlUnlinkNode(deleteNode);
4475         xmlFreeNode(deleteNode);
4476         deleteNode = NULL;
4477     }
4478     if (cur-&gt;type == XML_ELEMENT_NODE) {
4479 
4480         if (cur-&gt;psvi == xsltXSLTTextMarker) {
4481         /*
4482         * xsl:text elements
4483         * --------------------------------------------------------
4484         */
4485         xmlNodePtr tmp;
4486 
4487         cur-&gt;psvi = NULL;
4488         /*
4489         * Mark the xsl:text element for later deletion.
4490         */
4491         deleteNode = cur;
4492         /*
4493         * Validate content.
4494         */
4495         tmp = cur-&gt;children;
4496         if (tmp) {
4497             /*
4498             * We don&#39;t expect more than one text-node in the
4499             * content, since we already merged adjacent
4500             * text/CDATA-nodes and eliminated PI/comment-nodes.
4501             */
4502             if ((tmp-&gt;type == XML_TEXT_NODE) ||
4503             (tmp-&gt;next == NULL))
4504             {
4505             /*
4506             * Leave the contained text-node in the tree.
4507             */
4508             xmlUnlinkNode(tmp);
4509             xmlAddPrevSibling(cur, tmp);
4510             } else {
4511             tmp = NULL;
4512             xsltTransformError(NULL, cctxt-&gt;style, cur,
4513                 &quot;Element &#39;xsl:text&#39;: Invalid type &quot;
4514                 &quot;of node found in content.\n&quot;);
4515             cctxt-&gt;style-&gt;errors++;
4516             }
4517         }
4518         if (cur-&gt;properties) {
4519             xmlAttrPtr attr;
4520             /*
4521             * TODO: We need to report errors for
4522             *  invalid attrs.
4523             */
4524             attr = cur-&gt;properties;
4525             do {
4526             if ((attr-&gt;ns == NULL) &amp;&amp;
4527                 (attr-&gt;name != NULL) &amp;&amp;
4528                 (attr-&gt;name[0] == &#39;d&#39;) &amp;&amp;
4529                 xmlStrEqual(attr-&gt;name,
4530                 BAD_CAST &quot;disable-output-escaping&quot;))
4531             {
4532                 /*
4533                 * Attr &quot;disable-output-escaping&quot;.
4534                 * XSLT-2: This attribute is deprecated.
4535                 */
4536                 if ((attr-&gt;children != NULL) &amp;&amp;
4537                 xmlStrEqual(attr-&gt;children-&gt;content,
4538                 BAD_CAST &quot;yes&quot;))
4539                 {
4540                 /*
4541                 * Disable output escaping for this
4542                 * text node.
4543                 */
4544                 if (tmp)
4545                     tmp-&gt;name = xmlStringTextNoenc;
4546                 } else if ((attr-&gt;children == NULL) ||
4547                 (attr-&gt;children-&gt;content == NULL) ||
4548                 (!xmlStrEqual(attr-&gt;children-&gt;content,
4549                 BAD_CAST &quot;no&quot;)))
4550                 {
4551                 xsltTransformError(NULL, cctxt-&gt;style,
4552                     cur,
4553                     &quot;Attribute &#39;disable-output-escaping&#39;: &quot;
4554                     &quot;Invalid value. Expected is &quot;
4555                     &quot;&#39;yes&#39; or &#39;no&#39;.\n&quot;);
4556                 cctxt-&gt;style-&gt;errors++;
4557                 }
4558                 break;
4559             }
4560             attr = attr-&gt;next;
4561             } while (attr != NULL);
4562         }
4563         } else if (IS_XSLT_ELEM_FAST(cur)) {
4564         /*
4565         * TODO: Using the XSLT-marker is still not stable yet.
4566         */
4567         /* if (cur-&gt;psvi == xsltXSLTElemMarker) { */
4568         /*
4569         * XSLT instructions
4570         * --------------------------------------------------------
4571         */
4572         cur-&gt;psvi = NULL;
4573         type = xsltGetXSLTElementTypeByNode(cctxt, cur);
4574         switch (type) {
4575             case XSLT_FUNC_APPLYIMPORTS:
4576             case XSLT_FUNC_APPLYTEMPLATES:
4577             case XSLT_FUNC_ATTRIBUTE:
4578             case XSLT_FUNC_CALLTEMPLATE:
4579             case XSLT_FUNC_CHOOSE:
4580             case XSLT_FUNC_COMMENT:
4581             case XSLT_FUNC_COPY:
4582             case XSLT_FUNC_COPYOF:
4583             case XSLT_FUNC_DOCUMENT: /* Extra one */
4584             case XSLT_FUNC_ELEMENT:
4585             case XSLT_FUNC_FALLBACK:
4586             case XSLT_FUNC_FOREACH:
4587             case XSLT_FUNC_IF:
4588             case XSLT_FUNC_MESSAGE:
4589             case XSLT_FUNC_NUMBER:
4590             case XSLT_FUNC_PI:
4591             case XSLT_FUNC_TEXT:
4592             case XSLT_FUNC_VALUEOF:
4593             case XSLT_FUNC_VARIABLE:
4594             /*
4595             * Parse the XSLT element.
4596             */
4597             cctxt-&gt;inode-&gt;curChildType = type;
4598             xsltParseAnyXSLTElem(cctxt, cur);
4599             break;
4600             default:
4601             xsltParseUnknownXSLTElem(cctxt, cur);
4602             cur = cur-&gt;next;
4603             continue;
4604         }
4605         } else {
4606         /*
4607         * Non-XSLT elements
4608         * -----------------
4609         */
4610         xsltCompilerNodePush(cctxt, cur);
4611         /*
4612         * Update the in-scope namespaces if needed.
4613         */
4614         if (cur-&gt;nsDef != NULL)
4615             cctxt-&gt;inode-&gt;inScopeNs =
4616             xsltCompilerBuildInScopeNsList(cctxt, cur);
4617         /*
4618         * The current element is either a literal result element
4619         * or an extension instruction.
4620         *
4621         * Process attr &quot;xsl:extension-element-prefixes&quot;.
4622         * FUTURE TODO: IIRC in XSLT 2.0 this attribute must be
4623         * processed by the implementor of the extension function;
4624         * i.e., it won&#39;t be handled by the XSLT processor.
4625         */
4626         /* SPEC 1.0:
4627         *   &quot;exclude-result-prefixes&quot; is only allowed on literal
4628         *   result elements and &quot;xsl:exclude-result-prefixes&quot;
4629         *   on xsl:stylesheet/xsl:transform.
4630         * SPEC 2.0:
4631         *   &quot;There are a number of standard attributes
4632         *   that may appear on any XSLT element: specifically
4633         *   version, exclude-result-prefixes,
4634         *   extension-element-prefixes, xpath-default-namespace,
4635         *   default-collation, and use-when.&quot;
4636         *
4637         * SPEC 2.0:
4638         *   For literal result elements:
4639         *   &quot;xsl:version, xsl:exclude-result-prefixes,
4640         *    xsl:extension-element-prefixes,
4641         *    xsl:xpath-default-namespace,
4642         *    xsl:default-collation, or xsl:use-when.&quot;
4643         */
4644         if (cur-&gt;properties)
4645             cctxt-&gt;inode-&gt;extElemNs =
4646             xsltParseExtElemPrefixes(cctxt,
4647                 cur, cctxt-&gt;inode-&gt;extElemNs,
4648                 XSLT_ELEMENT_CATEGORY_LRE);
4649         /*
4650         * Eval if we have an extension instruction here.
4651         */
4652         if ((cur-&gt;ns != NULL) &amp;&amp;
4653             (cctxt-&gt;inode-&gt;extElemNs != NULL) &amp;&amp;
4654             (xsltCheckExtPrefix(cctxt-&gt;style, cur-&gt;ns-&gt;href) == 1))
4655         {
4656             /*
4657             * Extension instructions
4658             * ----------------------------------------------------
4659             * Mark the node information.
4660             */
4661             cctxt-&gt;inode-&gt;category = XSLT_ELEMENT_CATEGORY_EXTENSION;
4662             cctxt-&gt;inode-&gt;extContentHandled = 0;
4663             if (cur-&gt;psvi != NULL) {
4664             cur-&gt;psvi = NULL;
4665             /*
4666             * TODO: Temporary sanity check.
4667             */
4668             xsltTransformError(NULL, cctxt-&gt;style, cur,
4669                 &quot;Internal error in xsltParseSequenceConstructor(): &quot;
4670                 &quot;Occupied PSVI field.\n&quot;);
4671             cctxt-&gt;style-&gt;errors++;
4672             cur = cur-&gt;next;
4673             continue;
4674             }
4675             cur-&gt;psvi = (void *)
4676             xsltPreComputeExtModuleElement(cctxt-&gt;style, cur);
4677 
4678             if (cur-&gt;psvi == NULL) {
4679             /*
4680             * OLD COMMENT: &quot;Unknown element, maybe registered
4681             *  at the context level. Mark it for later
4682             *  recognition.&quot;
4683             * QUESTION: What does the xsltExtMarker mean?
4684             *  ANSWER: It is used in
4685             *   xsltApplySequenceConstructor() at
4686             *   transformation-time to look out for extension
4687             *   registered in the transformation context.
4688             */
4689             cur-&gt;psvi = (void *) xsltExtMarker;
4690             }
4691             /*
4692             * BIG NOTE: Now the ugly part. In previous versions
4693             *  of Libxslt (until 1.1.16), all the content of an
4694             *  extension instruction was processed and compiled without
4695             *  the need of the extension-author to explicitely call
4696             *  such a processing;.We now need to mimic this old
4697             *  behaviour in order to avoid breaking old code
4698             *  on the extension-author&#39;s side.
4699             * The mechanism:
4700             *  1) If the author does *not* set the
4701             *    compile-time-flag @extContentHandled, then we&#39;ll
4702             *    parse the content assuming that it&#39;s a &quot;template&quot;
4703             *    (or &quot;sequence constructor in XSLT 2.0 terms).
4704             *    NOTE: If the extension is registered at
4705             *    transformation-time only, then there&#39;s no way of
4706             *    knowing that content shall be valid, and we&#39;ll
4707             *    process the content the same way.
4708             *  2) If the author *does* set the flag, then we&#39;ll assume
4709             *   that the author has handled the parsing him/herself
4710             *   (e.g. called xsltParseSequenceConstructor(), etc.
4711             *   explicitely in his/her code).
4712             */
4713             if ((cur-&gt;children != NULL) &amp;&amp;
4714             (cctxt-&gt;inode-&gt;extContentHandled == 0))
4715             {
4716             /*
4717             * Default parsing of the content using the
4718             * sequence-constructor model.
4719             */
4720             xsltParseSequenceConstructor(cctxt, cur-&gt;children);
4721             }
4722         } else {
4723             /*
4724             * Literal result element
4725             * ----------------------------------------------------
4726             * Allowed XSLT attributes:
4727             *  xsl:extension-element-prefixes CDATA #IMPLIED
4728             *  xsl:exclude-result-prefixes CDATA #IMPLIED
4729             *  TODO: xsl:use-attribute-sets %qnames; #IMPLIED
4730             *  xsl:version NMTOKEN #IMPLIED
4731             */
4732             cur-&gt;psvi = NULL;
4733             cctxt-&gt;inode-&gt;category = XSLT_ELEMENT_CATEGORY_LRE;
4734             if (cur-&gt;properties != NULL) {
4735             xmlAttrPtr attr = cur-&gt;properties;
4736             /*
4737             * Attribute &quot;xsl:exclude-result-prefixes&quot;.
4738             */
4739             cctxt-&gt;inode-&gt;exclResultNs =
4740                 xsltParseExclResultPrefixes(cctxt, cur,
4741                 cctxt-&gt;inode-&gt;exclResultNs,
4742                 XSLT_ELEMENT_CATEGORY_LRE);
4743             /*
4744             * Attribute &quot;xsl:version&quot;.
4745             */
4746             xsltParseAttrXSLTVersion(cctxt, cur,
4747                 XSLT_ELEMENT_CATEGORY_LRE);
4748             /*
4749             * Report invalid XSLT attributes.
4750             * For XSLT 1.0 only xsl:use-attribute-sets is allowed
4751             * next to xsl:version, xsl:exclude-result-prefixes and
4752             * xsl:extension-element-prefixes.
4753             *
4754             * Mark all XSLT attributes, in order to skip such
4755             * attributes when instantiating the LRE.
4756             */
4757             do {
4758                 if ((attr-&gt;psvi != xsltXSLTAttrMarker) &amp;&amp;
4759                 IS_XSLT_ATTR_FAST(attr))
4760                 {
4761                 if (! xmlStrEqual(attr-&gt;name,
4762                     BAD_CAST &quot;use-attribute-sets&quot;))
4763                 {
4764                     xsltTransformError(NULL, cctxt-&gt;style,
4765                     cur,
4766                     &quot;Unknown XSLT attribute &#39;%s&#39;.\n&quot;,
4767                     attr-&gt;name);
4768                     cctxt-&gt;style-&gt;errors++;
4769                 } else {
4770                     /*
4771                     * XSLT attr marker.
4772                     */
4773                     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
4774                 }
4775                 }
4776                 attr = attr-&gt;next;
4777             } while (attr != NULL);
4778             }
4779             /*
4780             * Create/reuse info for the literal result element.
4781             */
4782             if (cctxt-&gt;inode-&gt;nsChanged)
4783             xsltLREInfoCreate(cctxt, cur, 1);
4784             cur-&gt;psvi = cctxt-&gt;inode-&gt;litResElemInfo;
4785             /*
4786             * Apply ns-aliasing on the element and on its attributes.
4787             */
4788             if (cctxt-&gt;hasNsAliases)
4789             xsltLREBuildEffectiveNs(cctxt, cur);
4790             /*
4791             * Compile attribute value templates (AVT).
4792             */
4793             if (cur-&gt;properties) {
4794             xmlAttrPtr attr = cur-&gt;properties;
4795 
4796             while (attr != NULL) {
4797                 xsltCompileAttr(cctxt-&gt;style, attr);
4798                 attr = attr-&gt;next;
4799             }
4800             }
4801             /*
4802             * Parse the content, which is defined to be a &quot;template&quot;
4803             * (or &quot;sequence constructor&quot; in XSLT 2.0 terms).
4804             */
4805             if (cur-&gt;children != NULL) {
4806             xsltParseSequenceConstructor(cctxt, cur-&gt;children);
4807             }
4808         }
4809         /*
4810         * Leave the non-XSLT element.
4811         */
4812         xsltCompilerNodePop(cctxt, cur);
4813         }
4814     }
4815     cur = cur-&gt;next;
4816     }
4817     if (deleteNode != NULL) {
4818 #ifdef WITH_XSLT_DEBUG_BLANKS
4819     xsltGenericDebug(xsltGenericDebugContext,
4820         &quot;xsltParseSequenceConstructor: removing xsl:text element\n&quot;);
4821 #endif
4822     xmlUnlinkNode(deleteNode);
4823     xmlFreeNode(deleteNode);
4824     deleteNode = NULL;
4825     }
4826 }
4827 
4828 /**
4829  * xsltParseTemplateContent:
4830  * @style:  the XSLT stylesheet
4831  * @templ:  the node containing the content to be parsed
4832  *
4833  * Parses and compiles the content-model of an xsl:template element.
4834  * Note that this is *not* the &quot;template&quot; content model (or &quot;sequence
4835  *  constructor&quot; in XSLT 2.0); it it allows addional xsl:param
4836  *  elements as immediate children of @templ.
4837  *
4838  * Called by:
4839  *   exsltFuncFunctionComp() (EXSLT, functions.c)
4840  *   So this is intended to be called from extension functions.
4841  */
4842 void
4843 xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {
4844     if ((style == NULL) || (templ == NULL) ||
4845         (templ-&gt;type == XML_NAMESPACE_DECL))
4846     return;
4847 
4848     /*
4849     * Detection of handled content of extension instructions.
4850     */
4851     if (XSLT_CCTXT(style)-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4852     XSLT_CCTXT(style)-&gt;inode-&gt;extContentHandled = 1;
4853     }
4854 
4855     if (templ-&gt;children != NULL) {
4856     xmlNodePtr child = templ-&gt;children;
4857     /*
4858     * Process xsl:param elements, which can only occur as the
4859     * immediate children of xsl:template (well, and of any
4860     * user-defined extension instruction if needed).
4861     */
4862     do {
4863         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4864         IS_XSLT_ELEM_FAST(child) &amp;&amp;
4865         IS_XSLT_NAME(child, &quot;param&quot;))
4866         {
4867         XSLT_CCTXT(style)-&gt;inode-&gt;curChildType = XSLT_FUNC_PARAM;
4868         xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);
4869         } else
4870         break;
4871         child = child-&gt;next;
4872     } while (child != NULL);
4873     /*
4874     * Parse the content and register the pattern.
4875     */
4876     xsltParseSequenceConstructor(XSLT_CCTXT(style), child);
4877     }
4878 }
4879 
4880 #else /* XSLT_REFACTORED */
4881 
4882 /**
4883  * xsltParseTemplateContent:
4884  * @style:  the XSLT stylesheet
4885  * @templ:  the container node (can be a document for literal results)
4886  *
4887  * parse a template content-model
4888  * Clean-up the template content from unwanted ignorable blank nodes
4889  * and process xslt:text
4890  */
4891 void
4892 xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {
4893     xmlNodePtr cur, delete;
4894 
4895     if ((style == NULL) || (templ == NULL) ||
4896         (templ-&gt;type == XML_NAMESPACE_DECL)) return;
4897 
4898     /*
4899      * This content comes from the stylesheet
4900      * For stylesheets, the set of whitespace-preserving
4901      * element names consists of just xsl:text.
4902      */
4903     cur = templ-&gt;children;
4904     delete = NULL;
4905     while (cur != NULL) {
4906     if (delete != NULL) {
4907 #ifdef WITH_XSLT_DEBUG_BLANKS
4908         xsltGenericDebug(xsltGenericDebugContext,
4909          &quot;xsltParseTemplateContent: removing text\n&quot;);
4910 #endif
4911         xmlUnlinkNode(delete);
4912         xmlFreeNode(delete);
4913         delete = NULL;
4914     }
4915     if (IS_XSLT_ELEM(cur)) {
4916             xsltStylePreCompute(style, cur);
4917 
4918         if (IS_XSLT_NAME(cur, &quot;text&quot;)) {
4919         /*
4920         * TODO: Processing of xsl:text should be moved to
4921         *   xsltPreprocessStylesheet(), since otherwise this
4922         *   will be performed for every multiply included
4923         *   stylesheet; i.e. this here is not skipped with
4924         *   the use of the style-&gt;nopreproc flag.
4925         */
4926         if (cur-&gt;children != NULL) {
4927             xmlChar *prop;
4928             xmlNodePtr text = cur-&gt;children, next;
4929             int noesc = 0;
4930 
4931             prop = xmlGetNsProp(cur,
4932             (const xmlChar *)&quot;disable-output-escaping&quot;,
4933             NULL);
4934             if (prop != NULL) {
4935 #ifdef WITH_XSLT_DEBUG_PARSING
4936             xsltGenericDebug(xsltGenericDebugContext,
4937                  &quot;Disable escaping: %s\n&quot;, text-&gt;content);
4938 #endif
4939             if (xmlStrEqual(prop, (const xmlChar *)&quot;yes&quot;)) {
4940                 noesc = 1;
4941             } else if (!xmlStrEqual(prop,
4942                         (const xmlChar *)&quot;no&quot;)){
4943                 xsltTransformError(NULL, style, cur,
4944          &quot;xsl:text: disable-output-escaping allows only yes or no\n&quot;);
4945                 style-&gt;warnings++;
4946 
4947             }
4948             xmlFree(prop);
4949             }
4950 
4951             while (text != NULL) {
4952             if (text-&gt;type == XML_COMMENT_NODE) {
4953                 text = text-&gt;next;
4954                 continue;
4955             }
4956             if ((text-&gt;type != XML_TEXT_NODE) &amp;&amp;
4957                  (text-&gt;type != XML_CDATA_SECTION_NODE)) {
4958                 xsltTransformError(NULL, style, cur,
4959          &quot;xsltParseTemplateContent: xslt:text content problem\n&quot;);
4960                 style-&gt;errors++;
4961                 break;
4962             }
4963             if ((noesc) &amp;&amp; (text-&gt;type != XML_CDATA_SECTION_NODE))
4964                 text-&gt;name = xmlStringTextNoenc;
4965             text = text-&gt;next;
4966             }
4967 
4968             /*
4969              * replace xsl:text by the list of childs
4970              */
4971             if (text == NULL) {
4972             text = cur-&gt;children;
4973             while (text != NULL) {
4974                 if ((style-&gt;internalized) &amp;&amp;
4975                     (text-&gt;content != NULL) &amp;&amp;
4976                     (!xmlDictOwns(style-&gt;dict, text-&gt;content))) {
4977 
4978                 /*
4979                  * internalize the text string
4980                  */
4981                 if (text-&gt;doc-&gt;dict != NULL) {
4982                     const xmlChar *tmp;
4983 
4984                     tmp = xmlDictLookup(text-&gt;doc-&gt;dict,
4985                                         text-&gt;content, -1);
4986                     if (tmp != text-&gt;content) {
4987                         xmlNodeSetContent(text, NULL);
4988                     text-&gt;content = (xmlChar *) tmp;
4989                     }
4990                 }
4991                 }
4992 
4993                 next = text-&gt;next;
4994                 xmlUnlinkNode(text);
4995                 xmlAddPrevSibling(cur, text);
4996                 text = next;
4997             }
4998             }
4999         }
5000         delete = cur;
5001         goto skip_children;
5002         }
5003     }
5004     else if ((cur-&gt;ns != NULL) &amp;&amp; (style-&gt;nsDefs != NULL) &amp;&amp;
5005         (xsltCheckExtPrefix(style, cur-&gt;ns-&gt;prefix)))
5006     {
5007         /*
5008          * okay this is an extension element compile it too
5009          */
5010         xsltStylePreCompute(style, cur);
5011     }
5012     else if (cur-&gt;type == XML_ELEMENT_NODE)
5013     {
5014         /*
5015          * This is an element which will be output as part of the
5016          * template exectution, precompile AVT if found.
5017          */
5018         if ((cur-&gt;ns == NULL) &amp;&amp; (style-&gt;defaultAlias != NULL)) {
5019         cur-&gt;ns = xmlSearchNsByHref(cur-&gt;doc, cur,
5020             style-&gt;defaultAlias);
5021         }
5022         if (cur-&gt;properties != NULL) {
5023             xmlAttrPtr attr = cur-&gt;properties;
5024 
5025         while (attr != NULL) {
5026             xsltCompileAttr(style, attr);
5027             attr = attr-&gt;next;
5028         }
5029         }
5030     }
5031     /*
5032      * Skip to next node
5033      */
5034     if (cur-&gt;children != NULL) {
5035         if (cur-&gt;children-&gt;type != XML_ENTITY_DECL) {
5036         cur = cur-&gt;children;
5037         continue;
5038         }
5039     }
5040 skip_children:
5041     if (cur-&gt;next != NULL) {
5042         cur = cur-&gt;next;
5043         continue;
5044     }
5045 
5046     do {
5047         cur = cur-&gt;parent;
5048         if (cur == NULL)
5049         break;
5050         if (cur == templ) {
5051         cur = NULL;
5052         break;
5053         }
5054         if (cur-&gt;next != NULL) {
5055         cur = cur-&gt;next;
5056         break;
5057         }
5058     } while (cur != NULL);
5059     }
5060     if (delete != NULL) {
5061 #ifdef WITH_XSLT_DEBUG_PARSING
5062     xsltGenericDebug(xsltGenericDebugContext,
5063      &quot;xsltParseTemplateContent: removing text\n&quot;);
5064 #endif
5065     xmlUnlinkNode(delete);
5066     xmlFreeNode(delete);
5067     delete = NULL;
5068     }
5069 
5070     /*
5071      * Skip the first params
5072      */
5073     cur = templ-&gt;children;
5074     while (cur != NULL) {
5075     if ((IS_XSLT_ELEM(cur)) &amp;&amp; (!(IS_XSLT_NAME(cur, &quot;param&quot;))))
5076         break;
5077     cur = cur-&gt;next;
5078     }
5079 
5080     /*
5081      * Browse the remainder of the template
5082      */
5083     while (cur != NULL) {
5084     if ((IS_XSLT_ELEM(cur)) &amp;&amp; (IS_XSLT_NAME(cur, &quot;param&quot;))) {
5085         xmlNodePtr param = cur;
5086 
5087         xsltTransformError(NULL, style, cur,
5088         &quot;xsltParseTemplateContent: ignoring misplaced param element\n&quot;);
5089         if (style != NULL) style-&gt;warnings++;
5090             cur = cur-&gt;next;
5091         xmlUnlinkNode(param);
5092         xmlFreeNode(param);
5093     } else
5094         break;
5095     }
5096 }
5097 
5098 #endif /* else XSLT_REFACTORED */
5099 
5100 /**
5101  * xsltParseStylesheetKey:
5102  * @style:  the XSLT stylesheet
5103  * @key:  the &quot;key&quot; element
5104  *
5105  * &lt;!-- Category: top-level-element --&gt;
5106  * &lt;xsl:key name = qname, match = pattern, use = expression /&gt;
5107  *
5108  * parse an XSLT stylesheet key definition and register it
5109  */
5110 
5111 static void
5112 xsltParseStylesheetKey(xsltStylesheetPtr style, xmlNodePtr key) {
5113     xmlChar *prop = NULL;
5114     xmlChar *use = NULL;
5115     xmlChar *match = NULL;
5116     xmlChar *name = NULL;
5117     xmlChar *nameURI = NULL;
5118 
5119     if ((style == NULL) || (key == NULL) || (key-&gt;type != XML_ELEMENT_NODE))
5120     return;
5121 
5122     /*
5123      * Get arguments
5124      */
5125     prop = xmlGetNsProp(key, (const xmlChar *)&quot;name&quot;, NULL);
5126     if (prop != NULL) {
5127         const xmlChar *URI;
5128 
5129     /*
5130     * TODO: Don&#39;t use xsltGetQNameURI().
5131     */
5132     URI = xsltGetQNameURI(key, &amp;prop);
5133     if (prop == NULL) {
5134         if (style != NULL) style-&gt;errors++;
5135         goto error;
5136     } else {
5137         name = prop;
5138         if (URI != NULL)
5139         nameURI = xmlStrdup(URI);
5140     }
5141 #ifdef WITH_XSLT_DEBUG_PARSING
5142     xsltGenericDebug(xsltGenericDebugContext,
5143          &quot;xsltParseStylesheetKey: name %s\n&quot;, name);
5144 #endif
5145     } else {
5146     xsltTransformError(NULL, style, key,
5147         &quot;xsl:key : error missing name\n&quot;);
5148     if (style != NULL) style-&gt;errors++;
5149     goto error;
5150     }
5151 
5152     match = xmlGetNsProp(key, (const xmlChar *)&quot;match&quot;, NULL);
5153     if (match == NULL) {
5154     xsltTransformError(NULL, style, key,
5155         &quot;xsl:key : error missing match\n&quot;);
5156     if (style != NULL) style-&gt;errors++;
5157     goto error;
5158     }
5159 
5160     use = xmlGetNsProp(key, (const xmlChar *)&quot;use&quot;, NULL);
5161     if (use == NULL) {
5162     xsltTransformError(NULL, style, key,
5163         &quot;xsl:key : error missing use\n&quot;);
5164     if (style != NULL) style-&gt;errors++;
5165     goto error;
5166     }
5167 
5168     /*
5169      * register the keys
5170      */
5171     xsltAddKey(style, name, nameURI, match, use, key);
5172 
5173 
5174 error:
5175     if (use != NULL)
5176     xmlFree(use);
5177     if (match != NULL)
5178     xmlFree(match);
5179     if (name != NULL)
5180     xmlFree(name);
5181     if (nameURI != NULL)
5182     xmlFree(nameURI);
5183 
5184     if (key-&gt;children != NULL) {
5185     xsltParseContentError(style, key-&gt;children);
5186     }
5187 }
5188 
5189 #ifdef XSLT_REFACTORED
5190 /**
5191  * xsltParseXSLTTemplate:
5192  * @style:  the XSLT stylesheet
5193  * @template:  the &quot;template&quot; element
5194  *
5195  * parse an XSLT stylesheet template building the associated structures
5196  * TODO: Is @style ever expected to be NULL?
5197  *
5198  * Called from:
5199  *   xsltParseXSLTStylesheet()
5200  *   xsltParseStylesheetTop()
5201  */
5202 
5203 static void
5204 xsltParseXSLTTemplate(xsltCompilerCtxtPtr cctxt, xmlNodePtr templNode) {
5205     xsltTemplatePtr templ;
5206     xmlChar *prop;
5207     double  priority;
5208 
5209     if ((cctxt == NULL) || (templNode == NULL) ||
5210         (templNode-&gt;type != XML_ELEMENT_NODE))
5211     return;
5212 
5213     /*
5214      * Create and link the structure
5215      */
5216     templ = xsltNewTemplate();
5217     if (templ == NULL)
5218     return;
5219 
5220     xsltCompilerNodePush(cctxt, templNode);
5221     if (templNode-&gt;nsDef != NULL)
5222     cctxt-&gt;inode-&gt;inScopeNs =
5223         xsltCompilerBuildInScopeNsList(cctxt, templNode);
5224 
5225     templ-&gt;next = cctxt-&gt;style-&gt;templates;
5226     cctxt-&gt;style-&gt;templates = templ;
5227     templ-&gt;style = cctxt-&gt;style;
5228 
5229     /*
5230     * Attribute &quot;mode&quot;.
5231     */
5232     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;mode&quot;, NULL);
5233     if (prop != NULL) {
5234         const xmlChar *modeURI;
5235 
5236     /*
5237     * TODO: We need a standardized function for extraction
5238     *  of namespace names and local names from QNames.
5239     *  Don&#39;t use xsltGetQNameURI() as it cannot channe
5240     *  reports through the context.
5241     */
5242     modeURI = xsltGetQNameURI(templNode, &amp;prop);
5243     if (prop == NULL) {
5244         cctxt-&gt;style-&gt;errors++;
5245         goto error;
5246     }
5247     templ-&gt;mode = xmlDictLookup(cctxt-&gt;style-&gt;dict, prop, -1);
5248     xmlFree(prop);
5249     prop = NULL;
5250     if (xmlValidateNCName(templ-&gt;mode, 0)) {
5251         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5252         &quot;xsl:template: Attribute &#39;mode&#39;: The local part &#39;%s&#39; &quot;
5253         &quot;of the value is not a valid NCName.\n&quot;, templ-&gt;name);
5254         cctxt-&gt;style-&gt;errors++;
5255         goto error;
5256     }
5257     if (modeURI != NULL)
5258         templ-&gt;modeURI = xmlDictLookup(cctxt-&gt;style-&gt;dict, modeURI, -1);
5259 #ifdef WITH_XSLT_DEBUG_PARSING
5260     xsltGenericDebug(xsltGenericDebugContext,
5261          &quot;xsltParseXSLTTemplate: mode %s\n&quot;, templ-&gt;mode);
5262 #endif
5263     }
5264     /*
5265     * Attribute &quot;match&quot;.
5266     */
5267     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;match&quot;, NULL);
5268     if (prop != NULL) {
5269     templ-&gt;match  = prop;
5270     prop = NULL;
5271     }
5272     /*
5273     * Attribute &quot;priority&quot;.
5274     */
5275     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;priority&quot;, NULL);
5276     if (prop != NULL) {
5277     priority = xmlXPathStringEvalNumber(prop);
5278     templ-&gt;priority = (float) priority;
5279     xmlFree(prop);
5280     prop = NULL;
5281     }
5282     /*
5283     * Attribute &quot;name&quot;.
5284     */
5285     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;name&quot;, NULL);
5286     if (prop != NULL) {
5287         const xmlChar *nameURI;
5288     xsltTemplatePtr curTempl;
5289 
5290     /*
5291     * TODO: Don&#39;t use xsltGetQNameURI().
5292     */
5293     nameURI = xsltGetQNameURI(templNode, &amp;prop);
5294     if (prop == NULL) {
5295         cctxt-&gt;style-&gt;errors++;
5296         goto error;
5297     }
5298     templ-&gt;name = xmlDictLookup(cctxt-&gt;style-&gt;dict, prop, -1);
5299     xmlFree(prop);
5300     prop = NULL;
5301     if (xmlValidateNCName(templ-&gt;name, 0)) {
5302         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5303         &quot;xsl:template: Attribute &#39;name&#39;: The local part &#39;%s&#39; of &quot;
5304         &quot;the value is not a valid NCName.\n&quot;, templ-&gt;name);
5305         cctxt-&gt;style-&gt;errors++;
5306         goto error;
5307     }
5308     if (nameURI != NULL)
5309         templ-&gt;nameURI = xmlDictLookup(cctxt-&gt;style-&gt;dict, nameURI, -1);
5310     curTempl = templ-&gt;next;
5311     while (curTempl != NULL) {
5312         if ((nameURI != NULL &amp;&amp; xmlStrEqual(curTempl-&gt;name, templ-&gt;name) &amp;&amp;
5313         xmlStrEqual(curTempl-&gt;nameURI, nameURI) ) ||
5314         (nameURI == NULL &amp;&amp; curTempl-&gt;nameURI == NULL &amp;&amp;
5315         xmlStrEqual(curTempl-&gt;name, templ-&gt;name)))
5316         {
5317         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5318             &quot;xsl:template: error duplicate name &#39;%s&#39;\n&quot;, templ-&gt;name);
5319         cctxt-&gt;style-&gt;errors++;
5320         goto error;
5321         }
5322         curTempl = curTempl-&gt;next;
5323     }
5324     }
5325     if (templNode-&gt;children != NULL) {
5326     xsltParseTemplateContent(cctxt-&gt;style, templNode);
5327     /*
5328     * MAYBE TODO: Custom behaviour: In order to stay compatible with
5329     * Xalan and MSXML(.NET), we could allow whitespace
5330     * to appear before an xml:param element; this whitespace
5331     * will additionally become part of the &quot;template&quot;.
5332     * NOTE that this is totally deviates from the spec, but
5333     * is the de facto behaviour of Xalan and MSXML(.NET).
5334     * Personally I wouldn&#39;t allow this, since if we have:
5335     * &lt;xsl:template ...xml:space=&quot;preserve&quot;&gt;
5336     *   &lt;xsl:param name=&quot;foo&quot;/&gt;
5337     *   &lt;xsl:param name=&quot;bar&quot;/&gt;
5338     *   &lt;xsl:param name=&quot;zoo&quot;/&gt;
5339     * ... the whitespace between every xsl:param would be
5340     * added to the result tree.
5341     */
5342     }
5343 
5344     templ-&gt;elem = templNode;
5345     templ-&gt;content = templNode-&gt;children;
5346     xsltAddTemplate(cctxt-&gt;style, templ, templ-&gt;mode, templ-&gt;modeURI);
5347 
5348 error:
5349     xsltCompilerNodePop(cctxt, templNode);
5350     return;
5351 }
5352 
5353 #else /* XSLT_REFACTORED */
5354 
5355 /**
5356  * xsltParseStylesheetTemplate:
5357  * @style:  the XSLT stylesheet
5358  * @template:  the &quot;template&quot; element
5359  *
5360  * parse an XSLT stylesheet template building the associated structures
5361  */
5362 
5363 static void
5364 xsltParseStylesheetTemplate(xsltStylesheetPtr style, xmlNodePtr template) {
5365     xsltTemplatePtr ret;
5366     xmlChar *prop;
5367     xmlChar *mode = NULL;
5368     xmlChar *modeURI = NULL;
5369     double  priority;
5370 
5371     if ((style == NULL) || (template == NULL) ||
5372         (template-&gt;type != XML_ELEMENT_NODE))
5373     return;
5374 
5375     /*
5376      * Create and link the structure
5377      */
5378     ret = xsltNewTemplate();
5379     if (ret == NULL)
5380     return;
5381     ret-&gt;next = style-&gt;templates;
5382     style-&gt;templates = ret;
5383     ret-&gt;style = style;
5384 
5385     /*
5386      * Get inherited namespaces
5387      */
5388     /*
5389     * TODO: Apply the optimized in-scope-namespace mechanism
5390     *   as for the other XSLT instructions.
5391     */
5392     xsltGetInheritedNsList(style, ret, template);
5393 
5394     /*
5395      * Get arguments
5396      */
5397     prop = xmlGetNsProp(template, (const xmlChar *)&quot;mode&quot;, NULL);
5398     if (prop != NULL) {
5399         const xmlChar *URI;
5400 
5401     /*
5402     * TODO: Don&#39;t use xsltGetQNameURI().
5403     */
5404     URI = xsltGetQNameURI(template, &amp;prop);
5405     if (prop == NULL) {
5406         if (style != NULL) style-&gt;errors++;
5407         goto error;
5408     } else {
5409         mode = prop;
5410         if (URI != NULL)
5411         modeURI = xmlStrdup(URI);
5412     }
5413     ret-&gt;mode = xmlDictLookup(style-&gt;dict, mode, -1);
5414     ret-&gt;modeURI = xmlDictLookup(style-&gt;dict, modeURI, -1);
5415 #ifdef WITH_XSLT_DEBUG_PARSING
5416     xsltGenericDebug(xsltGenericDebugContext,
5417          &quot;xsltParseStylesheetTemplate: mode %s\n&quot;, mode);
5418 #endif
5419         if (mode != NULL) xmlFree(mode);
5420     if (modeURI != NULL) xmlFree(modeURI);
5421     }
5422     prop = xmlGetNsProp(template, (const xmlChar *)&quot;match&quot;, NULL);
5423     if (prop != NULL) {
5424     if (ret-&gt;match != NULL) xmlFree(ret-&gt;match);
5425     ret-&gt;match  = prop;
5426     }
5427 
5428     prop = xmlGetNsProp(template, (const xmlChar *)&quot;priority&quot;, NULL);
5429     if (prop != NULL) {
5430     priority = xmlXPathStringEvalNumber(prop);
5431     ret-&gt;priority = (float) priority;
5432     xmlFree(prop);
5433     }
5434 
5435     prop = xmlGetNsProp(template, (const xmlChar *)&quot;name&quot;, NULL);
5436     if (prop != NULL) {
5437         const xmlChar *URI;
5438 
5439     /*
5440     * TODO: Don&#39;t use xsltGetQNameURI().
5441     */
5442     URI = xsltGetQNameURI(template, &amp;prop);
5443     if (prop == NULL) {
5444         if (style != NULL) style-&gt;errors++;
5445         goto error;
5446     } else {
5447         if (xmlValidateNCName(prop,0)) {
5448             xsltTransformError(NULL, style, template,
5449                 &quot;xsl:template : error invalid name &#39;%s&#39;\n&quot;, prop);
5450         if (style != NULL) style-&gt;errors++;
5451                 xmlFree(prop);
5452         goto error;
5453         }
5454         ret-&gt;name = xmlDictLookup(style-&gt;dict, BAD_CAST prop, -1);
5455         xmlFree(prop);
5456         prop = NULL;
5457         if (URI != NULL)
5458         ret-&gt;nameURI = xmlDictLookup(style-&gt;dict, BAD_CAST URI, -1);
5459         else
5460         ret-&gt;nameURI = NULL;
5461     }
5462     }
5463 
5464     /*
5465      * parse the content and register the pattern
5466      */
5467     xsltParseTemplateContent(style, template);
5468     ret-&gt;elem = template;
5469     ret-&gt;content = template-&gt;children;
5470     xsltAddTemplate(style, ret, ret-&gt;mode, ret-&gt;modeURI);
5471 
5472 error:
5473     return;
5474 }
5475 
5476 #endif /* else XSLT_REFACTORED */
5477 
5478 #ifdef XSLT_REFACTORED
5479 
5480 /**
5481  * xsltIncludeComp:
<a name="10" id="anc10"></a><span class="line-modified">5482  * @cctxt: the compilation contenxt</span>
5483  * @node:  the xsl:include node
5484  *
5485  * Process the xslt include node on the source node
5486  */
5487 static xsltStyleItemIncludePtr
5488 xsltCompileXSLTIncludeElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node) {
5489     xsltStyleItemIncludePtr item;
5490 
5491     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
5492     return(NULL);
5493 
5494     node-&gt;psvi = NULL;
5495     item = (xsltStyleItemIncludePtr) xmlMalloc(sizeof(xsltStyleItemInclude));
5496     if (item == NULL) {
5497     xsltTransformError(NULL, cctxt-&gt;style, node,
5498         &quot;xsltIncludeComp : malloc failed\n&quot;);
5499     cctxt-&gt;style-&gt;errors++;
5500     return(NULL);
5501     }
5502     memset(item, 0, sizeof(xsltStyleItemInclude));
5503 
5504     node-&gt;psvi = item;
5505     item-&gt;inst = node;
5506     item-&gt;type = XSLT_FUNC_INCLUDE;
5507 
5508     item-&gt;next = cctxt-&gt;style-&gt;preComps;
5509     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
5510 
5511     return(item);
5512 }
5513 
5514 /**
5515  * xsltParseFindTopLevelElem:
5516  */
5517 static int
5518 xsltParseFindTopLevelElem(xsltCompilerCtxtPtr cctxt,
5519                   xmlNodePtr cur,
5520                   const xmlChar *name,
5521                   const xmlChar *namespaceURI,
5522                   int breakOnOtherElem,
5523                   xmlNodePtr *resultNode)
5524 {
5525     if (name == NULL)
5526     return(-1);
5527 
5528     *resultNode = NULL;
5529     while (cur != NULL) {
5530     if (cur-&gt;type == XML_ELEMENT_NODE) {
5531         if ((cur-&gt;ns != NULL) &amp;&amp; (cur-&gt;name != NULL)) {
5532         if ((*(cur-&gt;name) == *name) &amp;&amp;
5533             xmlStrEqual(cur-&gt;name, name) &amp;&amp;
5534             xmlStrEqual(cur-&gt;ns-&gt;href, namespaceURI))
5535         {
5536             *resultNode = cur;
5537             return(1);
5538         }
5539         }
5540         if (breakOnOtherElem)
5541         break;
5542     }
5543     cur = cur-&gt;next;
5544     }
5545     *resultNode = cur;
5546     return(0);
5547 }
5548 
5549 static int
5550 xsltParseTopLevelXSLTElem(xsltCompilerCtxtPtr cctxt,
5551               xmlNodePtr node,
5552               xsltStyleType type)
5553 {
5554     int ret = 0;
5555 
5556     /*
5557     * TODO: The reason why this function exists:
5558     *  due to historical reasons some of the
5559     *  top-level declarations are processed by functions
5560     *  in other files. Since we need still to set
5561     *  up the node-info and generate information like
5562     *  in-scope namespaces, this is a wrapper around
5563     *  those old parsing functions.
5564     */
5565     xsltCompilerNodePush(cctxt, node);
5566     if (node-&gt;nsDef != NULL)
5567     cctxt-&gt;inode-&gt;inScopeNs =
5568         xsltCompilerBuildInScopeNsList(cctxt, node);
5569     cctxt-&gt;inode-&gt;type = type;
5570 
5571     switch (type) {
5572     case XSLT_FUNC_INCLUDE:
5573         {
5574         int oldIsInclude;
5575 
5576         if (xsltCompileXSLTIncludeElem(cctxt, node) == NULL)
5577             goto exit;
5578         /*
5579         * Mark this stylesheet tree as being currently included.
5580         */
5581         oldIsInclude = cctxt-&gt;isInclude;
5582         cctxt-&gt;isInclude = 1;
5583 
5584         if (xsltParseStylesheetInclude(cctxt-&gt;style, node) != 0) {
5585             cctxt-&gt;style-&gt;errors++;
5586         }
5587         cctxt-&gt;isInclude = oldIsInclude;
5588         }
5589         break;
5590     case XSLT_FUNC_PARAM:
5591         xsltStylePreCompute(cctxt-&gt;style, node);
5592         xsltParseGlobalParam(cctxt-&gt;style, node);
5593         break;
5594     case XSLT_FUNC_VARIABLE:
5595         xsltStylePreCompute(cctxt-&gt;style, node);
5596         xsltParseGlobalVariable(cctxt-&gt;style, node);
5597         break;
5598     case XSLT_FUNC_ATTRSET:
5599         xsltParseStylesheetAttributeSet(cctxt-&gt;style, node);
5600         break;
5601     default:
5602         xsltTransformError(NULL, cctxt-&gt;style, node,
5603         &quot;Internal error: (xsltParseTopLevelXSLTElem) &quot;
5604         &quot;Cannot handle this top-level declaration.\n&quot;);
5605         cctxt-&gt;style-&gt;errors++;
5606         ret = -1;
5607     }
5608 
5609 exit:
5610     xsltCompilerNodePop(cctxt, node);
5611 
5612     return(ret);
5613 }
5614 
5615 #if 0
5616 static int
5617 xsltParseRemoveWhitespace(xmlNodePtr node)
5618 {
5619     if ((node == NULL) || (node-&gt;children == NULL))
5620     return(0);
5621     else {
5622     xmlNodePtr delNode = NULL, child = node-&gt;children;
5623 
5624     do {
5625         if (delNode) {
5626         xmlUnlinkNode(delNode);
5627         xmlFreeNode(delNode);
5628         delNode = NULL;
5629         }
5630         if (((child-&gt;type == XML_TEXT_NODE) ||
5631          (child-&gt;type == XML_CDATA_SECTION_NODE)) &amp;&amp;
5632         (IS_BLANK_NODE(child)))
5633         delNode = child;
5634         child = child-&gt;next;
5635     } while (child != NULL);
5636     if (delNode) {
5637         xmlUnlinkNode(delNode);
5638         xmlFreeNode(delNode);
5639         delNode = NULL;
5640     }
5641     }
5642     return(0);
5643 }
5644 #endif
5645 
5646 static int
5647 xsltParseXSLTStylesheetElemCore(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
5648 {
5649 #ifdef WITH_XSLT_DEBUG_PARSING
5650     int templates = 0;
5651 #endif
5652     xmlNodePtr cur, start = NULL;
5653     xsltStylesheetPtr style;
5654 
5655     if ((cctxt == NULL) || (node == NULL) ||
5656     (node-&gt;type != XML_ELEMENT_NODE))
5657     return(-1);
5658 
5659     style = cctxt-&gt;style;
5660     /*
5661     * At this stage all import declarations of all stylesheet modules
5662     * with the same stylesheet level have been processed.
5663     * Now we can safely parse the rest of the declarations.
5664     */
5665     if (IS_XSLT_ELEM_FAST(node) &amp;&amp; IS_XSLT_NAME(node, &quot;include&quot;))
5666     {
5667     xsltDocumentPtr include;
5668     /*
5669     * URGENT TODO: Make this work with simplified stylesheets!
5670     *   I.e., when we won&#39;t find an xsl:stylesheet element.
5671     */
5672     /*
5673     * This is as include declaration.
5674     */
5675     include = ((xsltStyleItemIncludePtr) node-&gt;psvi)-&gt;include;
5676     if (include == NULL) {
5677         /* TODO: raise error? */
5678         return(-1);
5679     }
5680     /*
5681     * TODO: Actually an xsl:include should locate an embedded
5682     *  stylesheet as well; so the document-element won&#39;t always
5683     *  be the element where the actual stylesheet is rooted at.
5684     *  But such embedded stylesheets are not supported by Libxslt yet.
5685     */
5686     node = xmlDocGetRootElement(include-&gt;doc);
5687     if (node == NULL) {
5688         return(-1);
5689     }
5690     }
5691 
5692     if (node-&gt;children == NULL)
5693     return(0);
5694     /*
5695     * Push the xsl:stylesheet/xsl:transform element.
5696     */
5697     xsltCompilerNodePush(cctxt, node);
5698     cctxt-&gt;inode-&gt;isRoot = 1;
5699     cctxt-&gt;inode-&gt;nsChanged = 0;
5700     /*
5701     * Start with the naked dummy info for literal result elements.
5702     */
5703     cctxt-&gt;inode-&gt;litResElemInfo = cctxt-&gt;inodeList-&gt;litResElemInfo;
5704 
5705     /*
5706     * In every case, we need to have
5707     * the in-scope namespaces of the element, where the
5708     * stylesheet is rooted at, regardless if it&#39;s an XSLT
5709     * instruction or a literal result instruction (or if
5710     * this is an embedded stylesheet).
5711     */
5712     cctxt-&gt;inode-&gt;inScopeNs =
5713     xsltCompilerBuildInScopeNsList(cctxt, node);
5714 
5715     /*
5716     * Process attributes of xsl:stylesheet/xsl:transform.
5717     * --------------------------------------------------
5718     * Allowed are:
5719     *  id = id
5720     *  extension-element-prefixes = tokens
5721     *  exclude-result-prefixes = tokens
5722     *  version = number (mandatory)
5723     */
5724     if (xsltParseAttrXSLTVersion(cctxt, node,
5725     XSLT_ELEMENT_CATEGORY_XSLT) == 0)
5726     {
5727     /*
5728     * Attribute &quot;version&quot;.
5729     * XSLT 1.0: &quot;An xsl:stylesheet element *must* have a version
5730     *  attribute, indicating the version of XSLT that the
5731     *  stylesheet requires&quot;.
5732     * The root element of a simplified stylesheet must also have
5733     * this attribute.
5734     */
5735 #ifdef XSLT_REFACTORED_MANDATORY_VERSION
5736     if (isXsltElem)
5737         xsltTransformError(NULL, cctxt-&gt;style, node,
5738         &quot;The attribute &#39;version&#39; is missing.\n&quot;);
5739     cctxt-&gt;style-&gt;errors++;
5740 #else
5741     /* OLD behaviour. */
5742     xsltTransformError(NULL, cctxt-&gt;style, node,
5743         &quot;xsl:version is missing: document may not be a stylesheet\n&quot;);
5744     cctxt-&gt;style-&gt;warnings++;
5745 #endif
5746     }
5747     /*
5748     * The namespaces declared by the attributes
5749     *  &quot;extension-element-prefixes&quot; and
5750     *  &quot;exclude-result-prefixes&quot; are local to *this*
5751     *  stylesheet tree; i.e., they are *not* visible to
5752     *  other stylesheet-modules, whether imported or included.
5753     *
5754     * Attribute &quot;extension-element-prefixes&quot;.
5755     */
5756     cctxt-&gt;inode-&gt;extElemNs =
5757     xsltParseExtElemPrefixes(cctxt, node, NULL,
5758         XSLT_ELEMENT_CATEGORY_XSLT);
5759     /*
5760     * Attribute &quot;exclude-result-prefixes&quot;.
5761     */
5762     cctxt-&gt;inode-&gt;exclResultNs =
5763     xsltParseExclResultPrefixes(cctxt, node, NULL,
5764         XSLT_ELEMENT_CATEGORY_XSLT);
5765     /*
5766     * Create/reuse info for the literal result element.
5767     */
5768     if (cctxt-&gt;inode-&gt;nsChanged)
5769     xsltLREInfoCreate(cctxt, node, 0);
5770     /*
5771     * Processed top-level elements:
5772     * ----------------------------
5773     *  xsl:variable, xsl:param (QName, in-scope ns,
5774     *    expression (vars allowed))
5775     *  xsl:attribute-set (QName, in-scope ns)
5776     *  xsl:strip-space, xsl:preserve-space (XPath NameTests,
5777     *    in-scope ns)
5778     *    I *think* global scope, merge with includes
5779     *  xsl:output (QName, in-scope ns)
5780     *  xsl:key (QName, in-scope ns, pattern,
5781     *    expression (vars *not* allowed))
5782     *  xsl:decimal-format (QName, needs in-scope ns)
5783     *  xsl:namespace-alias (in-scope ns)
5784     *    global scope, merge with includes
5785     *  xsl:template (last, QName, pattern)
5786     *
5787     * (whitespace-only text-nodes have *not* been removed
5788     *  yet; this will be done in xsltParseSequenceConstructor)
5789     *
5790     * Report misplaced child-nodes first.
5791     */
5792     cur = node-&gt;children;
5793     while (cur != NULL) {
5794     if (cur-&gt;type == XML_TEXT_NODE) {
5795         xsltTransformError(NULL, style, cur,
5796         &quot;Misplaced text node (content: &#39;%s&#39;).\n&quot;,
5797         (cur-&gt;content != NULL) ? cur-&gt;content : BAD_CAST &quot;&quot;);
5798         style-&gt;errors++;
5799     } else if (cur-&gt;type != XML_ELEMENT_NODE) {
5800         xsltTransformError(NULL, style, cur, &quot;Misplaced node.\n&quot;);
5801         style-&gt;errors++;
5802     }
5803     cur = cur-&gt;next;
5804     }
5805     /*
5806     * Skip xsl:import elements; they have been processed
5807     * already.
5808     */
5809     cur = node-&gt;children;
5810     while ((cur != NULL) &amp;&amp; xsltParseFindTopLevelElem(cctxt, cur,
5811         BAD_CAST &quot;import&quot;, XSLT_NAMESPACE, 1, &amp;cur) == 1)
5812     cur = cur-&gt;next;
5813     if (cur == NULL)
5814     goto exit;
5815 
5816     start = cur;
5817     /*
5818     * Process all top-level xsl:param elements.
5819     */
5820     while ((cur != NULL) &amp;&amp;
5821     xsltParseFindTopLevelElem(cctxt, cur,
5822     BAD_CAST &quot;param&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
5823     {
5824     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_PARAM);
5825     cur = cur-&gt;next;
5826     }
5827     /*
5828     * Process all top-level xsl:variable elements.
5829     */
5830     cur = start;
5831     while ((cur != NULL) &amp;&amp;
5832     xsltParseFindTopLevelElem(cctxt, cur,
5833     BAD_CAST &quot;variable&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
5834     {
5835     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_VARIABLE);
5836     cur = cur-&gt;next;
5837     }
5838     /*
5839     * Process all the rest of top-level elements.
5840     */
5841     cur = start;
5842     while (cur != NULL) {
5843     /*
5844     * Process element nodes.
5845     */
5846     if (cur-&gt;type == XML_ELEMENT_NODE) {
5847         if (cur-&gt;ns == NULL) {
5848         xsltTransformError(NULL, style, cur,
5849             &quot;Unexpected top-level element in no namespace.\n&quot;);
5850         style-&gt;errors++;
5851         cur = cur-&gt;next;
5852         continue;
5853         }
5854         /*
5855         * Process all XSLT elements.
5856         */
5857         if (IS_XSLT_ELEM_FAST(cur)) {
5858         /*
5859         * xsl:import is only allowed at the beginning.
5860         */
5861         if (IS_XSLT_NAME(cur, &quot;import&quot;)) {
5862             xsltTransformError(NULL, style, cur,
5863             &quot;Misplaced xsl:import element.\n&quot;);
5864             style-&gt;errors++;
5865             cur = cur-&gt;next;
5866             continue;
5867         }
5868         /*
5869         * TODO: Change the return type of the parsing functions
5870         *  to int.
5871         */
5872         if (IS_XSLT_NAME(cur, &quot;template&quot;)) {
5873 #ifdef WITH_XSLT_DEBUG_PARSING
5874             templates++;
5875 #endif
5876             /*
5877             * TODO: Is the position of xsl:template in the
5878             *  tree significant? If not it would be easier to
5879             *  parse them at a later stage.
5880             */
5881             xsltParseXSLTTemplate(cctxt, cur);
5882         } else if (IS_XSLT_NAME(cur, &quot;variable&quot;)) {
5883             /* NOP; done already */
5884         } else if (IS_XSLT_NAME(cur, &quot;param&quot;)) {
5885             /* NOP; done already */
5886         } else if (IS_XSLT_NAME(cur, &quot;include&quot;)) {
5887             if (cur-&gt;psvi != NULL)
5888             xsltParseXSLTStylesheetElemCore(cctxt, cur);
5889             else {
5890             xsltTransformError(NULL, style, cur,
5891                 &quot;Internal error: &quot;
5892                 &quot;(xsltParseXSLTStylesheetElemCore) &quot;
5893                 &quot;The xsl:include element was not compiled.\n&quot;);
5894             style-&gt;errors++;
5895             }
5896         } else if (IS_XSLT_NAME(cur, &quot;strip-space&quot;)) {
5897             /* No node info needed. */
5898             xsltParseStylesheetStripSpace(style, cur);
5899         } else if (IS_XSLT_NAME(cur, &quot;preserve-space&quot;)) {
5900             /* No node info needed. */
5901             xsltParseStylesheetPreserveSpace(style, cur);
5902         } else if (IS_XSLT_NAME(cur, &quot;output&quot;)) {
5903             /* No node-info needed. */
5904             xsltParseStylesheetOutput(style, cur);
5905         } else if (IS_XSLT_NAME(cur, &quot;key&quot;)) {
5906             /* TODO: node-info needed for expressions ? */
5907             xsltParseStylesheetKey(style, cur);
5908         } else if (IS_XSLT_NAME(cur, &quot;decimal-format&quot;)) {
5909             /* No node-info needed. */
5910             xsltParseStylesheetDecimalFormat(style, cur);
5911         } else if (IS_XSLT_NAME(cur, &quot;attribute-set&quot;)) {
5912             xsltParseTopLevelXSLTElem(cctxt, cur,
5913             XSLT_FUNC_ATTRSET);
5914         } else if (IS_XSLT_NAME(cur, &quot;namespace-alias&quot;)) {
5915             /* NOP; done already */
5916         } else {
5917             if (cctxt-&gt;inode-&gt;forwardsCompat) {
5918             /*
5919             * Forwards-compatible mode:
5920             *
5921             * XSLT-1: &quot;if it is a top-level element and
5922             *  XSLT 1.0 does not allow such elements as top-level
5923             *  elements, then the element must be ignored along
5924             *  with its content;&quot;
5925             */
5926             /*
5927             * TODO: I don&#39;t think we should generate a warning.
5928             */
5929             xsltTransformError(NULL, style, cur,
5930                 &quot;Forwards-compatible mode: Ignoring unknown XSLT &quot;
5931                 &quot;element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5932             style-&gt;warnings++;
5933             } else {
5934             xsltTransformError(NULL, style, cur,
5935                 &quot;Unknown XSLT element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5936             style-&gt;errors++;
5937             }
5938         }
5939         } else {
5940         xsltTopLevelFunction function;
5941 
5942         /*
5943         * Process non-XSLT elements, which are in a
5944         *  non-NULL namespace.
5945         */
5946         /*
5947         * QUESTION: What does xsltExtModuleTopLevelLookup()
5948         *  do exactly?
5949         */
5950         function = xsltExtModuleTopLevelLookup(cur-&gt;name,
5951             cur-&gt;ns-&gt;href);
5952         if (function != NULL)
5953             function(style, cur);
5954 #ifdef WITH_XSLT_DEBUG_PARSING
5955         xsltGenericDebug(xsltGenericDebugContext,
5956             &quot;xsltParseXSLTStylesheetElemCore : User-defined &quot;
5957             &quot;data element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5958 #endif
5959         }
5960     }
5961     cur = cur-&gt;next;
5962     }
5963 
5964 exit:
5965 
5966 #ifdef WITH_XSLT_DEBUG_PARSING
5967     xsltGenericDebug(xsltGenericDebugContext,
5968     &quot;### END of parsing top-level elements of doc &#39;%s&#39;.\n&quot;,
5969     node-&gt;doc-&gt;URL);
5970     xsltGenericDebug(xsltGenericDebugContext,
5971     &quot;### Templates: %d\n&quot;, templates);
5972 #ifdef XSLT_REFACTORED
5973     xsltGenericDebug(xsltGenericDebugContext,
5974     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
5975     xsltGenericDebug(xsltGenericDebugContext,
5976     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
5977 #endif /* XSLT_REFACTORED */
5978 #endif /* WITH_XSLT_DEBUG_PARSING */
5979 
5980     xsltCompilerNodePop(cctxt, node);
5981     return(0);
5982 }
5983 
5984 /**
5985  * xsltParseXSLTStylesheet:
5986  * @cctxt: the compiler context
5987  * @node: the xsl:stylesheet/xsl:transform element-node
5988  *
5989  * Parses the xsl:stylesheet and xsl:transform element.
5990  *
5991  * &lt;xsl:stylesheet
5992  *  id = id
5993  *  extension-element-prefixes = tokens
5994  *  exclude-result-prefixes = tokens
5995  *  version = number&gt;
5996  *  &lt;!-- Content: (xsl:import*, top-level-elements) --&gt;
5997  * &lt;/xsl:stylesheet&gt;
5998  *
5999  * BIG TODO: The xsl:include stuff.
6000  *
6001  * Called by xsltParseStylesheetTree()
6002  *
6003  * Returns 0 on success, a positive result on errors and
6004  *         -1 on API or internal errors.
6005  */
6006 static int
6007 xsltParseXSLTStylesheetElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
6008 {
6009     xmlNodePtr cur, start;
6010 
6011     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
6012     return(-1);
6013 
6014     if (node-&gt;children == NULL)
6015     goto exit;
6016 
6017     /*
6018     * Process top-level elements:
6019     *  xsl:import (must be first)
6020     *  xsl:include (this is just a pre-processing)
6021     */
6022     cur = node-&gt;children;
6023     /*
6024     * Process xsl:import elements.
6025     * XSLT 1.0: &quot;The xsl:import element children must precede all
6026     *  other element children of an xsl:stylesheet element,
6027     *  including any xsl:include element children.&quot;
6028     */
6029     while ((cur != NULL) &amp;&amp;
6030     xsltParseFindTopLevelElem(cctxt, cur,
6031         BAD_CAST &quot;import&quot;, XSLT_NAMESPACE, 1, &amp;cur) == 1)
6032     {
6033     if (xsltParseStylesheetImport(cctxt-&gt;style, cur) != 0) {
6034         cctxt-&gt;style-&gt;errors++;
6035     }
6036     cur = cur-&gt;next;
6037     }
6038     if (cur == NULL)
6039     goto exit;
6040     start = cur;
6041     /*
6042     * Pre-process all xsl:include elements.
6043     */
6044     cur = start;
6045     while ((cur != NULL) &amp;&amp;
6046     xsltParseFindTopLevelElem(cctxt, cur,
6047         BAD_CAST &quot;include&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
6048     {
6049     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_INCLUDE);
6050     cur = cur-&gt;next;
6051     }
6052     /*
6053     * Pre-process all xsl:namespace-alias elements.
6054     * URGENT TODO: This won&#39;t work correctly: the order of included
6055     *  aliases and aliases defined here is significant.
6056     */
6057     cur = start;
6058     while ((cur != NULL) &amp;&amp;
6059     xsltParseFindTopLevelElem(cctxt, cur,
6060         BAD_CAST &quot;namespace-alias&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
6061     {
6062     xsltNamespaceAlias(cctxt-&gt;style, cur);
6063     cur = cur-&gt;next;
6064     }
6065 
6066     if (cctxt-&gt;isInclude) {
6067     /*
6068     * If this stylesheet is intended for inclusion, then
6069     * we will process only imports and includes.
6070     */
6071     goto exit;
6072     }
6073     /*
6074     * Now parse the rest of the top-level elements.
6075     */
6076     xsltParseXSLTStylesheetElemCore(cctxt, node);
6077 exit:
6078 
6079     return(0);
6080 }
6081 
6082 #else /* XSLT_REFACTORED */
6083 
6084 /**
6085  * xsltParseStylesheetTop:
6086  * @style:  the XSLT stylesheet
6087  * @top:  the top level &quot;stylesheet&quot; or &quot;transform&quot; element
6088  *
6089  * scan the top level elements of an XSL stylesheet
6090  */
6091 static void
6092 xsltParseStylesheetTop(xsltStylesheetPtr style, xmlNodePtr top) {
6093     xmlNodePtr cur;
6094     xmlChar *prop;
6095 #ifdef WITH_XSLT_DEBUG_PARSING
6096     int templates = 0;
6097 #endif
6098 
6099     if ((top == NULL) || (top-&gt;type != XML_ELEMENT_NODE))
6100     return;
6101 
6102     prop = xmlGetNsProp(top, (const xmlChar *)&quot;version&quot;, NULL);
6103     if (prop == NULL) {
6104     xsltTransformError(NULL, style, top,
6105         &quot;xsl:version is missing: document may not be a stylesheet\n&quot;);
6106     if (style != NULL) style-&gt;warnings++;
6107     } else {
6108     if ((!xmlStrEqual(prop, (const xmlChar *)&quot;1.0&quot;)) &amp;&amp;
6109             (!xmlStrEqual(prop, (const xmlChar *)&quot;1.1&quot;))) {
6110         xsltTransformError(NULL, style, top,
6111         &quot;xsl:version: only 1.1 features are supported\n&quot;);
6112         if (style != NULL) {
6113                 style-&gt;forwards_compatible = 1;
6114                 style-&gt;warnings++;
6115             }
6116     }
6117     xmlFree(prop);
6118     }
6119 
6120     /*
6121      * process xsl:import elements
6122      */
6123     cur = top-&gt;children;
6124     while (cur != NULL) {
6125         if (IS_BLANK_NODE(cur)) {
6126             cur = cur-&gt;next;
6127             continue;
6128         }
6129         if (IS_XSLT_ELEM(cur) &amp;&amp; IS_XSLT_NAME(cur, &quot;import&quot;)) {
6130             if (xsltParseStylesheetImport(style, cur) != 0)
6131                 if (style != NULL) style-&gt;errors++;
6132         } else
6133             break;
6134         cur = cur-&gt;next;
6135     }
6136 
6137     /*
6138      * process other top-level elements
6139      */
6140     while (cur != NULL) {
6141     if (IS_BLANK_NODE(cur)) {
6142         cur = cur-&gt;next;
6143         continue;
6144     }
6145     if (cur-&gt;type == XML_TEXT_NODE) {
6146         if (cur-&gt;content != NULL) {
6147         xsltTransformError(NULL, style, cur,
6148             &quot;misplaced text node: &#39;%s&#39;\n&quot;, cur-&gt;content);
6149         }
6150         if (style != NULL) style-&gt;errors++;
6151             cur = cur-&gt;next;
6152         continue;
6153     }
6154     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (cur-&gt;ns == NULL)) {
6155         xsltGenericError(xsltGenericErrorContext,
6156              &quot;Found a top-level element %s with null namespace URI\n&quot;,
6157              cur-&gt;name);
6158         if (style != NULL) style-&gt;errors++;
6159         cur = cur-&gt;next;
6160         continue;
6161     }
6162     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (!(IS_XSLT_ELEM(cur)))) {
6163         xsltTopLevelFunction function;
6164 
6165         function = xsltExtModuleTopLevelLookup(cur-&gt;name,
6166                            cur-&gt;ns-&gt;href);
6167         if (function != NULL)
6168         function(style, cur);
6169 
6170 #ifdef WITH_XSLT_DEBUG_PARSING
6171         xsltGenericDebug(xsltGenericDebugContext,
6172             &quot;xsltParseStylesheetTop : found foreign element %s\n&quot;,
6173             cur-&gt;name);
6174 #endif
6175             cur = cur-&gt;next;
6176         continue;
6177     }
6178     if (IS_XSLT_NAME(cur, &quot;import&quot;)) {
6179         xsltTransformError(NULL, style, cur,
6180             &quot;xsltParseStylesheetTop: ignoring misplaced import element\n&quot;);
6181         if (style != NULL) style-&gt;errors++;
6182         } else if (IS_XSLT_NAME(cur, &quot;include&quot;)) {
6183         if (xsltParseStylesheetInclude(style, cur) != 0)
6184         if (style != NULL) style-&gt;errors++;
6185         } else if (IS_XSLT_NAME(cur, &quot;strip-space&quot;)) {
6186         xsltParseStylesheetStripSpace(style, cur);
6187         } else if (IS_XSLT_NAME(cur, &quot;preserve-space&quot;)) {
6188         xsltParseStylesheetPreserveSpace(style, cur);
6189         } else if (IS_XSLT_NAME(cur, &quot;output&quot;)) {
6190         xsltParseStylesheetOutput(style, cur);
6191         } else if (IS_XSLT_NAME(cur, &quot;key&quot;)) {
6192         xsltParseStylesheetKey(style, cur);
6193         } else if (IS_XSLT_NAME(cur, &quot;decimal-format&quot;)) {
6194         xsltParseStylesheetDecimalFormat(style, cur);
6195         } else if (IS_XSLT_NAME(cur, &quot;attribute-set&quot;)) {
6196         xsltParseStylesheetAttributeSet(style, cur);
6197         } else if (IS_XSLT_NAME(cur, &quot;variable&quot;)) {
6198         xsltParseGlobalVariable(style, cur);
6199         } else if (IS_XSLT_NAME(cur, &quot;param&quot;)) {
6200         xsltParseGlobalParam(style, cur);
6201         } else if (IS_XSLT_NAME(cur, &quot;template&quot;)) {
6202 #ifdef WITH_XSLT_DEBUG_PARSING
6203         templates++;
6204 #endif
6205         xsltParseStylesheetTemplate(style, cur);
6206         } else if (IS_XSLT_NAME(cur, &quot;namespace-alias&quot;)) {
6207         xsltNamespaceAlias(style, cur);
6208     } else {
6209             if ((style != NULL) &amp;&amp; (style-&gt;forwards_compatible == 0)) {
6210             xsltTransformError(NULL, style, cur,
6211             &quot;xsltParseStylesheetTop: unknown %s element\n&quot;,
6212             cur-&gt;name);
6213             if (style != NULL) style-&gt;errors++;
6214         }
6215     }
6216     cur = cur-&gt;next;
6217     }
6218 #ifdef WITH_XSLT_DEBUG_PARSING
6219     xsltGenericDebug(xsltGenericDebugContext,
6220             &quot;parsed %d templates\n&quot;, templates);
6221 #endif
6222 }
6223 
6224 #endif /* else of XSLT_REFACTORED */
6225 
6226 #ifdef XSLT_REFACTORED
6227 /**
6228  * xsltParseSimplifiedStylesheetTree:
6229  *
6230  * @style: the stylesheet (TODO: Change this to the compiler context)
6231  * @doc: the document containing the stylesheet.
6232  * @node: the node where the stylesheet is rooted at
6233  *
6234  * Returns 0 in case of success, a positive result if an error occurred
6235  *         and -1 on API and internal errors.
6236  */
6237 static int
6238 xsltParseSimplifiedStylesheetTree(xsltCompilerCtxtPtr cctxt,
6239                   xmlDocPtr doc,
6240                   xmlNodePtr node)
6241 {
6242     xsltTemplatePtr templ;
6243 
6244     if ((cctxt == NULL) || (node == NULL))
6245     return(-1);
6246 
6247     if (xsltParseAttrXSLTVersion(cctxt, node, 0) == XSLT_ELEMENT_CATEGORY_LRE)
6248     {
6249     /*
6250     * TODO: Adjust report, since this might be an
6251     * embedded stylesheet.
6252     */
6253     xsltTransformError(NULL, cctxt-&gt;style, node,
6254         &quot;The attribute &#39;xsl:version&#39; is missing; cannot identify &quot;
6255         &quot;this document as an XSLT stylesheet document.\n&quot;);
6256     cctxt-&gt;style-&gt;errors++;
6257     return(1);
6258     }
6259 
6260 #ifdef WITH_XSLT_DEBUG_PARSING
6261     xsltGenericDebug(xsltGenericDebugContext,
6262     &quot;xsltParseSimplifiedStylesheetTree: document is stylesheet\n&quot;);
6263 #endif
6264 
6265     /*
6266     * Create and link the template
6267     */
6268     templ = xsltNewTemplate();
6269     if (templ == NULL) {
6270     return(-1);
6271     }
6272     templ-&gt;next = cctxt-&gt;style-&gt;templates;
6273     cctxt-&gt;style-&gt;templates = templ;
6274     templ-&gt;match = xmlStrdup(BAD_CAST &quot;/&quot;);
6275 
6276     /*
6277     * Note that we push the document-node in this special case.
6278     */
6279     xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6280     /*
6281     * In every case, we need to have
6282     * the in-scope namespaces of the element, where the
6283     * stylesheet is rooted at, regardless if it&#39;s an XSLT
6284     * instruction or a literal result instruction (or if
6285     * this is an embedded stylesheet).
6286     */
6287     cctxt-&gt;inode-&gt;inScopeNs =
6288     xsltCompilerBuildInScopeNsList(cctxt, node);
6289     /*
6290     * Parse the content and register the match-pattern.
6291     */
6292     xsltParseSequenceConstructor(cctxt, node);
6293     xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6294 
6295     templ-&gt;elem = (xmlNodePtr) doc;
6296     templ-&gt;content = node;
6297     xsltAddTemplate(cctxt-&gt;style, templ, NULL, NULL);
6298     cctxt-&gt;style-&gt;literal_result = 1;
6299     return(0);
6300 }
6301 
6302 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
6303 /**
6304  * xsltRestoreDocumentNamespaces:
6305  * @ns: map of namespaces
6306  * @doc: the document
6307  *
6308  * Restore the namespaces for the document
6309  *
6310  * Returns 0 in case of success, -1 in case of failure
6311  */
6312 int
6313 xsltRestoreDocumentNamespaces(xsltNsMapPtr ns, xmlDocPtr doc)
6314 {
6315     if (doc == NULL)
6316     return(-1);
6317     /*
6318     * Revert the changes we have applied to the namespace-URIs of
6319     * ns-decls.
6320     */
6321     while (ns != NULL) {
6322     if ((ns-&gt;doc == doc) &amp;&amp; (ns-&gt;ns != NULL)) {
6323         ns-&gt;ns-&gt;href = ns-&gt;origNsName;
6324         ns-&gt;origNsName = NULL;
6325         ns-&gt;ns = NULL;
6326     }
6327     ns = ns-&gt;next;
6328     }
6329     return(0);
6330 }
6331 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
6332 
6333 /**
6334  * xsltParseStylesheetProcess:
6335  * @style:  the XSLT stylesheet (the current stylesheet-level)
6336  * @doc:  and xmlDoc parsed XML
6337  *
6338  * Parses an XSLT stylesheet, adding the associated structures.
6339  * Called by:
6340  *  xsltParseStylesheetImportedDoc() (xslt.c)
6341  *  xsltParseStylesheetInclude() (imports.c)
6342  *
6343  * Returns the value of the @style parameter if everything
6344  * went right, NULL if something went amiss.
6345  */
6346 xsltStylesheetPtr
6347 xsltParseStylesheetProcess(xsltStylesheetPtr style, xmlDocPtr doc)
6348 {
6349     xsltCompilerCtxtPtr cctxt;
6350     xmlNodePtr cur;
6351     int oldIsSimplifiedStylesheet;
6352 
6353     xsltInitGlobals();
6354 
6355     if ((style == NULL) || (doc == NULL))
6356     return(NULL);
6357 
6358     cctxt = XSLT_CCTXT(style);
6359 
6360     cur = xmlDocGetRootElement(doc);
6361     if (cur == NULL) {
6362     xsltTransformError(NULL, style, (xmlNodePtr) doc,
6363         &quot;xsltParseStylesheetProcess : empty stylesheet\n&quot;);
6364     return(NULL);
6365     }
6366     oldIsSimplifiedStylesheet = cctxt-&gt;simplified;
6367 
6368     if ((IS_XSLT_ELEM(cur)) &amp;&amp;
6369     ((IS_XSLT_NAME(cur, &quot;stylesheet&quot;)) ||
6370      (IS_XSLT_NAME(cur, &quot;transform&quot;)))) {
6371 #ifdef WITH_XSLT_DEBUG_PARSING
6372     xsltGenericDebug(xsltGenericDebugContext,
6373         &quot;xsltParseStylesheetProcess : found stylesheet\n&quot;);
6374 #endif
6375     cctxt-&gt;simplified = 0;
6376     style-&gt;literal_result = 0;
6377     } else {
6378     cctxt-&gt;simplified = 1;
6379     style-&gt;literal_result = 1;
6380     }
6381     /*
6382     * Pre-process the stylesheet if not already done before.
6383     *  This will remove PIs and comments, merge adjacent
6384     *  text nodes, internalize strings, etc.
6385     */
6386     if (! style-&gt;nopreproc)
6387     xsltParsePreprocessStylesheetTree(cctxt, cur);
6388     /*
6389     * Parse and compile the stylesheet.
6390     */
6391     if (style-&gt;literal_result == 0) {
6392     if (xsltParseXSLTStylesheetElem(cctxt, cur) != 0)
6393         return(NULL);
6394     } else {
6395     if (xsltParseSimplifiedStylesheetTree(cctxt, doc, cur) != 0)
6396         return(NULL);
6397     }
6398 
6399     cctxt-&gt;simplified = oldIsSimplifiedStylesheet;
6400 
6401     return(style);
6402 }
6403 
6404 #else /* XSLT_REFACTORED */
6405 
6406 /**
6407  * xsltParseStylesheetProcess:
6408  * @ret:  the XSLT stylesheet (the current stylesheet-level)
6409  * @doc:  and xmlDoc parsed XML
6410  *
6411  * Parses an XSLT stylesheet, adding the associated structures.
6412  * Called by:
6413  *  xsltParseStylesheetImportedDoc() (xslt.c)
6414  *  xsltParseStylesheetInclude() (imports.c)
6415  *
6416  * Returns the value of the @style parameter if everything
6417  * went right, NULL if something went amiss.
6418  */
6419 xsltStylesheetPtr
6420 xsltParseStylesheetProcess(xsltStylesheetPtr ret, xmlDocPtr doc) {
6421     xmlNodePtr cur;
6422 
6423     xsltInitGlobals();
6424 
6425     if (doc == NULL)
6426     return(NULL);
6427     if (ret == NULL)
6428     return(ret);
6429 
6430     /*
6431      * First steps, remove blank nodes,
6432      * locate the xsl:stylesheet element and the
6433      * namespace declaration.
6434      */
6435     cur = xmlDocGetRootElement(doc);
6436     if (cur == NULL) {
6437     xsltTransformError(NULL, ret, (xmlNodePtr) doc,
6438         &quot;xsltParseStylesheetProcess : empty stylesheet\n&quot;);
6439     return(NULL);
6440     }
6441 
6442     if ((IS_XSLT_ELEM(cur)) &amp;&amp;
6443     ((IS_XSLT_NAME(cur, &quot;stylesheet&quot;)) ||
6444      (IS_XSLT_NAME(cur, &quot;transform&quot;)))) {
6445 #ifdef WITH_XSLT_DEBUG_PARSING
6446     xsltGenericDebug(xsltGenericDebugContext,
6447         &quot;xsltParseStylesheetProcess : found stylesheet\n&quot;);
6448 #endif
6449     ret-&gt;literal_result = 0;
6450     xsltParseStylesheetExcludePrefix(ret, cur, 1);
6451     xsltParseStylesheetExtPrefix(ret, cur, 1);
6452     } else {
6453     xsltParseStylesheetExcludePrefix(ret, cur, 0);
6454     xsltParseStylesheetExtPrefix(ret, cur, 0);
6455     ret-&gt;literal_result = 1;
6456     }
6457     if (!ret-&gt;nopreproc) {
6458     xsltPreprocessStylesheet(ret, cur);
6459     }
6460     if (ret-&gt;literal_result == 0) {
6461     xsltParseStylesheetTop(ret, cur);
6462     } else {
6463     xmlChar *prop;
6464     xsltTemplatePtr template;
6465 
6466     /*
6467      * the document itself might be the template, check xsl:version
6468      */
6469     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;version&quot;, XSLT_NAMESPACE);
6470     if (prop == NULL) {
6471         xsltTransformError(NULL, ret, cur,
6472         &quot;xsltParseStylesheetProcess : document is not a stylesheet\n&quot;);
6473         return(NULL);
6474     }
6475 
6476 #ifdef WITH_XSLT_DEBUG_PARSING
6477         xsltGenericDebug(xsltGenericDebugContext,
6478         &quot;xsltParseStylesheetProcess : document is stylesheet\n&quot;);
6479 #endif
6480 
6481     if ((!xmlStrEqual(prop, (const xmlChar *)&quot;1.0&quot;)) &amp;&amp;
6482             (!xmlStrEqual(prop, (const xmlChar *)&quot;1.1&quot;))) {
6483         xsltTransformError(NULL, ret, cur,
6484         &quot;xsl:version: only 1.1 features are supported\n&quot;);
6485             ret-&gt;forwards_compatible = 1;
6486         ret-&gt;warnings++;
6487     }
6488     xmlFree(prop);
6489 
6490     /*
6491      * Create and link the template
6492      */
6493     template = xsltNewTemplate();
6494     if (template == NULL) {
6495         return(NULL);
6496     }
6497     template-&gt;next = ret-&gt;templates;
6498     ret-&gt;templates = template;
6499     template-&gt;match = xmlStrdup((const xmlChar *)&quot;/&quot;);
6500 
6501     /*
6502      * parse the content and register the pattern
6503      */
6504     xsltParseTemplateContent(ret, (xmlNodePtr) doc);
6505     template-&gt;elem = (xmlNodePtr) doc;
6506     template-&gt;content = doc-&gt;children;
6507     xsltAddTemplate(ret, template, NULL, NULL);
6508     ret-&gt;literal_result = 1;
6509     }
6510 
6511     return(ret);
6512 }
6513 
6514 #endif /* else of XSLT_REFACTORED */
6515 
6516 /**
6517  * xsltParseStylesheetImportedDoc:
6518  * @doc:  an xmlDoc parsed XML
6519  * @parentStyle: pointer to the parent stylesheet (if it exists)
6520  *
6521  * parse an XSLT stylesheet building the associated structures
6522  * except the processing not needed for imported documents.
6523  *
6524  * Returns a new XSLT stylesheet structure.
6525  */
6526 
6527 xsltStylesheetPtr
6528 xsltParseStylesheetImportedDoc(xmlDocPtr doc,
6529                    xsltStylesheetPtr parentStyle) {
6530     xsltStylesheetPtr retStyle;
6531 
6532     if (doc == NULL)
6533     return(NULL);
6534 
<a name="11" id="anc11"></a><span class="line-modified">6535     retStyle = xsltNewStylesheet();</span>
6536     if (retStyle == NULL)
6537     return(NULL);
<a name="12" id="anc12"></a><span class="line-modified">6538     /*</span>
<span class="line-modified">6539     * Set the importing stylesheet module; also used to detect recursion.</span>
<span class="line-modified">6540     */</span>
<span class="line-modified">6541     retStyle-&gt;parent = parentStyle;</span>



















6542     /*
6543     * Adjust the string dict.
6544     */
6545     if (doc-&gt;dict != NULL) {
<a name="13" id="anc13"></a><span class="line-modified">6546         xmlDictFree(retStyle-&gt;dict);</span>
<span class="line-modified">6547     retStyle-&gt;dict = doc-&gt;dict;</span>
6548 #ifdef WITH_XSLT_DEBUG
6549         xsltGenericDebug(xsltGenericDebugContext,
6550         &quot;reusing dictionary from %s for stylesheet\n&quot;,
6551         doc-&gt;URL);
6552 #endif
<a name="14" id="anc14"></a><span class="line-modified">6553     xmlDictReference(retStyle-&gt;dict);</span>
6554     }
6555 
6556     /*
6557     * TODO: Eliminate xsltGatherNamespaces(); we must not restrict
6558     *  the stylesheet to containt distinct namespace prefixes.
6559     */
<a name="15" id="anc15"></a><span class="line-modified">6560     xsltGatherNamespaces(retStyle);</span>
6561 
6562 #ifdef XSLT_REFACTORED
6563     {
6564     xsltCompilerCtxtPtr cctxt;
6565     xsltStylesheetPtr oldCurSheet;
6566 
<a name="16" id="anc16"></a><span class="line-modified">6567     if (parentStyle == NULL) {</span>
6568         xsltPrincipalStylesheetDataPtr principalData;
6569         /*
<a name="17" id="anc17"></a><span class="line-removed">6570         * Principal stylesheet</span>
<span class="line-removed">6571         * --------------------</span>
<span class="line-removed">6572         */</span>
<span class="line-removed">6573         retStyle-&gt;principal = retStyle;</span>
<span class="line-removed">6574         /*</span>
6575         * Create extra data for the principal stylesheet.
6576         */
6577         principalData = xsltNewPrincipalStylesheetData();
6578         if (principalData == NULL) {
<a name="18" id="anc18"></a><span class="line-modified">6579         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6580         return(NULL);</span>
6581         }
<a name="19" id="anc19"></a><span class="line-modified">6582         retStyle-&gt;principalData = principalData;</span>
6583         /*
6584         * Create the compilation context
6585         * ------------------------------
6586         * (only once; for the principal stylesheet).
6587         * This is currently the only function where the
6588         * compilation context is created.
6589         */
<a name="20" id="anc20"></a><span class="line-modified">6590         cctxt = xsltCompilationCtxtCreate(retStyle);</span>
6591         if (cctxt == NULL) {
<a name="21" id="anc21"></a><span class="line-modified">6592         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6593         return(NULL);</span>
6594         }
<a name="22" id="anc22"></a><span class="line-modified">6595         retStyle-&gt;compCtxt = (void *) cctxt;</span>
<span class="line-modified">6596         cctxt-&gt;style = retStyle;</span>
<span class="line-modified">6597         cctxt-&gt;dict = retStyle-&gt;dict;</span>
6598         cctxt-&gt;psData = principalData;
6599         /*
6600         * Push initial dummy node info.
6601         */
6602         cctxt-&gt;depth = -1;
6603         xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6604     } else {
6605         /*
6606         * Imported stylesheet.
6607         */
<a name="23" id="anc23"></a><span class="line-modified">6608         retStyle-&gt;principal = parentStyle-&gt;principal;</span>
<span class="line-modified">6609         cctxt = parentStyle-&gt;compCtxt;</span>
<span class="line-removed">6610         retStyle-&gt;compCtxt = cctxt;</span>
6611     }
6612     /*
6613     * Save the old and set the current stylesheet structure in the
6614     * compilation context.
6615     */
6616     oldCurSheet = cctxt-&gt;style;
<a name="24" id="anc24"></a><span class="line-modified">6617     cctxt-&gt;style = retStyle;</span>
6618 
<a name="25" id="anc25"></a><span class="line-modified">6619     retStyle-&gt;doc = doc;</span>
<span class="line-modified">6620     xsltParseStylesheetProcess(retStyle, doc);</span>
6621 
6622     cctxt-&gt;style = oldCurSheet;
<a name="26" id="anc26"></a><span class="line-modified">6623     if (parentStyle == NULL) {</span>
6624         /*
6625         * Pop the initial dummy node info.
6626         */
6627         xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6628     } else {
6629         /*
6630         * Clear the compilation context of imported
6631         * stylesheets.
6632         * TODO: really?
6633         */
<a name="27" id="anc27"></a><span class="line-modified">6634         /* retStyle-&gt;compCtxt = NULL; */</span>
6635     }
<a name="28" id="anc28"></a><span class="line-modified">6636     /*</span>
<span class="line-removed">6637     * Free the stylesheet if there were errors.</span>
<span class="line-removed">6638     */</span>
<span class="line-removed">6639     if (retStyle != NULL) {</span>
<span class="line-removed">6640         if (retStyle-&gt;errors != 0) {</span>
6641 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
<a name="29" id="anc29"></a><span class="line-modified">6642         /*</span>
<span class="line-modified">6643         * Restore all changes made to namespace URIs of ns-decls.</span>
<span class="line-modified">6644         */</span>
<span class="line-modified">6645         if (cctxt-&gt;psData-&gt;nsMap)</span>
<span class="line-modified">6646             xsltRestoreDocumentNamespaces(cctxt-&gt;psData-&gt;nsMap, doc);</span>
<span class="line-modified">6647 #endif</span>
<span class="line-removed">6648         /*</span>
<span class="line-removed">6649         * Detach the doc from the stylesheet; otherwise the doc</span>
<span class="line-removed">6650         * will be freed in xsltFreeStylesheet().</span>
<span class="line-removed">6651         */</span>
<span class="line-removed">6652         retStyle-&gt;doc = NULL;</span>
<span class="line-removed">6653         /*</span>
<span class="line-removed">6654         * Cleanup the doc if its the main stylesheet.</span>
<span class="line-removed">6655         */</span>
<span class="line-removed">6656         if (parentStyle == NULL) {</span>
<span class="line-removed">6657             xsltCleanupStylesheetTree(doc, xmlDocGetRootElement(doc));</span>
<span class="line-removed">6658             if (retStyle-&gt;compCtxt != NULL) {</span>
<span class="line-removed">6659             xsltCompilationCtxtFree(retStyle-&gt;compCtxt);</span>
<span class="line-removed">6660             retStyle-&gt;compCtxt = NULL;</span>
<span class="line-removed">6661             }</span>
6662         }
<a name="30" id="anc30"></a>
6663 
<a name="31" id="anc31"></a><span class="line-modified">6664         xsltFreeStylesheet(retStyle);</span>
<span class="line-modified">6665         retStyle = NULL;</span>

6666         }
6667     }
<a name="32" id="anc32"></a><span class="line-removed">6668     }</span>
6669 
6670 #else /* XSLT_REFACTORED */
6671     /*
6672     * Old behaviour.
6673     */
<a name="33" id="anc33"></a><span class="line-modified">6674     retStyle-&gt;doc = doc;</span>
<span class="line-modified">6675     if (xsltParseStylesheetProcess(retStyle, doc) == NULL) {</span>
<span class="line-modified">6676         retStyle-&gt;doc = NULL;</span>
<span class="line-modified">6677         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6678         retStyle = NULL;</span>
<span class="line-removed">6679     }</span>
<span class="line-removed">6680     if (retStyle != NULL) {</span>
<span class="line-removed">6681     if (retStyle-&gt;errors != 0) {</span>
<span class="line-removed">6682         retStyle-&gt;doc = NULL;</span>
<span class="line-removed">6683         if (parentStyle == NULL)</span>
<span class="line-removed">6684         xsltCleanupStylesheetTree(doc,</span>
<span class="line-removed">6685             xmlDocGetRootElement(doc));</span>
<span class="line-removed">6686         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6687         retStyle = NULL;</span>
<span class="line-removed">6688     }</span>
6689     }
6690 #endif /* else of XSLT_REFACTORED */
6691 
<a name="34" id="anc34"></a><span class="line-modified">6692     return(retStyle);</span>

















6693 }
6694 
6695 /**
6696  * xsltParseStylesheetDoc:
6697  * @doc:  and xmlDoc parsed XML
6698  *
6699  * parse an XSLT stylesheet, building the associated structures.  doc
6700  * is kept as a reference within the returned stylesheet, so changes
6701  * to doc after the parsing will be reflected when the stylesheet
6702  * is applied, and the doc is automatically freed when the
6703  * stylesheet is closed.
6704  *
6705  * Returns a new XSLT stylesheet structure.
6706  */
6707 
6708 xsltStylesheetPtr
6709 xsltParseStylesheetDoc(xmlDocPtr doc) {
<a name="35" id="anc35"></a><span class="line-removed">6710     xsltStylesheetPtr ret;</span>
<span class="line-removed">6711 </span>
6712     xsltInitGlobals();
6713 
<a name="36" id="anc36"></a><span class="line-modified">6714     ret = xsltParseStylesheetImportedDoc(doc, NULL);</span>
<span class="line-removed">6715     if (ret == NULL)</span>
<span class="line-removed">6716     return(NULL);</span>
<span class="line-removed">6717 </span>
<span class="line-removed">6718     xsltResolveStylesheetAttributeSet(ret);</span>
<span class="line-removed">6719 #ifdef XSLT_REFACTORED</span>
<span class="line-removed">6720     /*</span>
<span class="line-removed">6721     * Free the compilation context.</span>
<span class="line-removed">6722     * TODO: Check if it&#39;s better to move this cleanup to</span>
<span class="line-removed">6723     *   xsltParseStylesheetImportedDoc().</span>
<span class="line-removed">6724     */</span>
<span class="line-removed">6725     if (ret-&gt;compCtxt != NULL) {</span>
<span class="line-removed">6726     xsltCompilationCtxtFree(XSLT_CCTXT(ret));</span>
<span class="line-removed">6727     ret-&gt;compCtxt = NULL;</span>
<span class="line-removed">6728     }</span>
<span class="line-removed">6729 #endif</span>
<span class="line-removed">6730     return(ret);</span>
6731 }
6732 
6733 /**
6734  * xsltParseStylesheetFile:
6735  * @filename:  the filename/URL to the stylesheet
6736  *
6737  * Load and parse an XSLT stylesheet
6738  *
6739  * Returns a new XSLT stylesheet structure.
6740  */
6741 
6742 xsltStylesheetPtr
6743 xsltParseStylesheetFile(const xmlChar* filename) {
6744     xsltSecurityPrefsPtr sec;
6745     xsltStylesheetPtr ret;
6746     xmlDocPtr doc;
6747 
6748     xsltInitGlobals();
6749 
6750     if (filename == NULL)
6751     return(NULL);
6752 
6753 #ifdef WITH_XSLT_DEBUG_PARSING
6754     xsltGenericDebug(xsltGenericDebugContext,
6755         &quot;xsltParseStylesheetFile : parse %s\n&quot;, filename);
6756 #endif
6757 
6758     /*
6759      * Security framework check
6760      */
6761     sec = xsltGetDefaultSecurityPrefs();
6762     if (sec != NULL) {
6763     int res;
6764 
6765     res = xsltCheckRead(sec, NULL, filename);
6766     if (res &lt;= 0) {
6767             if (res == 0)
6768                 xsltTransformError(NULL, NULL, NULL,
6769                      &quot;xsltParseStylesheetFile: read rights for %s denied\n&quot;,
6770                                  filename);
6771         return(NULL);
6772     }
6773     }
6774 
6775     doc = xsltDocDefaultLoader(filename, NULL, XSLT_PARSE_OPTIONS,
6776                                NULL, XSLT_LOAD_START);
6777     if (doc == NULL) {
6778     xsltTransformError(NULL, NULL, NULL,
6779         &quot;xsltParseStylesheetFile : cannot parse %s\n&quot;, filename);
6780     return(NULL);
6781     }
6782     ret = xsltParseStylesheetDoc(doc);
6783     if (ret == NULL) {
6784     xmlFreeDoc(doc);
6785     return(NULL);
6786     }
6787 
6788     return(ret);
6789 }
6790 
6791 /************************************************************************
6792  *                                  *
6793  *          Handling of Stylesheet PI           *
6794  *                                  *
6795  ************************************************************************/
6796 
6797 #define CUR (*cur)
6798 #define SKIP(val) cur += (val)
6799 #define NXT(val) cur[(val)]
6800 #define SKIP_BLANKS                     \
6801     while (IS_BLANK(CUR)) NEXT
6802 #define NEXT ((*cur) ?  cur++ : cur)
6803 
6804 /**
6805  * xsltParseStylesheetPI:
6806  * @value: the value of the PI
6807  *
6808  * This function checks that the type is text/xml and extracts
6809  * the URI-Reference for the stylesheet
6810  *
6811  * Returns the URI-Reference for the stylesheet or NULL (it need to
6812  *         be freed by the caller)
6813  */
6814 static xmlChar *
6815 xsltParseStylesheetPI(const xmlChar *value) {
6816     const xmlChar *cur;
6817     const xmlChar *start;
6818     xmlChar *val;
6819     xmlChar tmp;
6820     xmlChar *href = NULL;
6821     int isXml = 0;
6822 
6823     if (value == NULL)
6824     return(NULL);
6825 
6826     cur = value;
6827     while (CUR != 0) {
6828     SKIP_BLANKS;
6829     if ((CUR == &#39;t&#39;) &amp;&amp; (NXT(1) == &#39;y&#39;) &amp;&amp; (NXT(2) == &#39;p&#39;) &amp;&amp;
6830         (NXT(3) == &#39;e&#39;)) {
6831         SKIP(4);
6832         SKIP_BLANKS;
6833         if (CUR != &#39;=&#39;)
6834         continue;
6835         NEXT;
6836         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;))
6837         continue;
6838         tmp = CUR;
6839         NEXT;
6840         start = cur;
6841         while ((CUR != 0) &amp;&amp; (CUR != tmp))
6842         NEXT;
6843         if (CUR != tmp)
6844         continue;
6845         val = xmlStrndup(start, cur - start);
6846         NEXT;
6847         if (val == NULL)
6848         return(NULL);
6849         if ((xmlStrcasecmp(val, BAD_CAST &quot;text/xml&quot;)) &amp;&amp;
6850         (xmlStrcasecmp(val, BAD_CAST &quot;text/xsl&quot;))) {
6851                 xmlFree(val);
6852         break;
6853         }
6854         isXml = 1;
6855         xmlFree(val);
6856     } else if ((CUR == &#39;h&#39;) &amp;&amp; (NXT(1) == &#39;r&#39;) &amp;&amp; (NXT(2) == &#39;e&#39;) &amp;&amp;
6857         (NXT(3) == &#39;f&#39;)) {
6858         SKIP(4);
6859         SKIP_BLANKS;
6860         if (CUR != &#39;=&#39;)
6861         continue;
6862         NEXT;
6863         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;))
6864         continue;
6865         tmp = CUR;
6866         NEXT;
6867         start = cur;
6868         while ((CUR != 0) &amp;&amp; (CUR != tmp))
6869         NEXT;
6870         if (CUR != tmp)
6871         continue;
6872         if (href == NULL)
6873         href = xmlStrndup(start, cur - start);
6874         NEXT;
6875     } else {
6876         while ((CUR != 0) &amp;&amp; (!IS_BLANK(CUR)))
6877         NEXT;
6878     }
6879 
6880     }
6881 
6882     if (!isXml) {
6883     if (href != NULL)
6884         xmlFree(href);
6885     href = NULL;
6886     }
6887     return(href);
6888 }
6889 
6890 /**
6891  * xsltLoadStylesheetPI:
6892  * @doc:  a document to process
6893  *
6894  * This function tries to locate the stylesheet PI in the given document
6895  * If found, and if contained within the document, it will extract
6896  * that subtree to build the stylesheet to process @doc (doc itself will
6897  * be modified). If found but referencing an external document it will
6898  * attempt to load it and generate a stylesheet from it. In both cases,
6899  * the resulting stylesheet and the document need to be freed once the
6900  * transformation is done.
6901  *
6902  * Returns a new XSLT stylesheet structure or NULL if not found.
6903  */
6904 xsltStylesheetPtr
6905 xsltLoadStylesheetPI(xmlDocPtr doc) {
6906     xmlNodePtr child;
6907     xsltStylesheetPtr ret = NULL;
6908     xmlChar *href = NULL;
6909     xmlURIPtr URI;
6910 
6911     xsltInitGlobals();
6912 
6913     if (doc == NULL)
6914     return(NULL);
6915 
6916     /*
6917      * Find the text/xml stylesheet PI id any before the root
6918      */
6919     child = doc-&gt;children;
6920     while ((child != NULL) &amp;&amp; (child-&gt;type != XML_ELEMENT_NODE)) {
6921     if ((child-&gt;type == XML_PI_NODE) &amp;&amp;
6922         (xmlStrEqual(child-&gt;name, BAD_CAST &quot;xml-stylesheet&quot;))) {
6923         href = xsltParseStylesheetPI(child-&gt;content);
6924         if (href != NULL)
6925         break;
6926     }
6927     child = child-&gt;next;
6928     }
6929 
6930     /*
6931      * If found check the href to select processing
6932      */
6933     if (href != NULL) {
6934 #ifdef WITH_XSLT_DEBUG_PARSING
6935     xsltGenericDebug(xsltGenericDebugContext,
6936         &quot;xsltLoadStylesheetPI : found PI href=%s\n&quot;, href);
6937 #endif
6938     URI = xmlParseURI((const char *) href);
6939     if (URI == NULL) {
6940         xsltTransformError(NULL, NULL, child,
6941             &quot;xml-stylesheet : href %s is not valid\n&quot;, href);
6942         xmlFree(href);
6943         return(NULL);
6944     }
6945     if ((URI-&gt;fragment != NULL) &amp;&amp; (URI-&gt;scheme == NULL) &amp;&amp;
6946             (URI-&gt;opaque == NULL) &amp;&amp; (URI-&gt;authority == NULL) &amp;&amp;
6947             (URI-&gt;server == NULL) &amp;&amp; (URI-&gt;user == NULL) &amp;&amp;
6948             (URI-&gt;path == NULL) &amp;&amp; (URI-&gt;query == NULL)) {
6949         xmlAttrPtr ID;
6950 
6951 #ifdef WITH_XSLT_DEBUG_PARSING
6952         xsltGenericDebug(xsltGenericDebugContext,
6953             &quot;xsltLoadStylesheetPI : Reference to ID %s\n&quot;, href);
6954 #endif
6955         if (URI-&gt;fragment[0] == &#39;#&#39;)
6956         ID = xmlGetID(doc, (const xmlChar *) &amp;(URI-&gt;fragment[1]));
6957         else
6958         ID = xmlGetID(doc, (const xmlChar *) URI-&gt;fragment);
6959         if (ID == NULL) {
6960         xsltTransformError(NULL, NULL, child,
6961             &quot;xml-stylesheet : no ID %s found\n&quot;, URI-&gt;fragment);
6962         } else {
6963         xmlDocPtr fake;
6964         xmlNodePtr subtree, newtree;
6965         xmlNsPtr ns;
6966 
6967 #ifdef WITH_XSLT_DEBUG
6968         xsltGenericDebug(xsltGenericDebugContext,
6969             &quot;creating new document from %s for embedded stylesheet\n&quot;,
6970             doc-&gt;URL);
6971 #endif
6972         /*
6973          * move the subtree in a new document passed to
6974          * the stylesheet analyzer
6975          */
6976         subtree = ID-&gt;parent;
6977         fake = xmlNewDoc(NULL);
6978         if (fake != NULL) {
6979             /*
6980             * Should the dictionary still be shared even though
6981             * the nodes are being copied rather than moved?
6982             */
6983             fake-&gt;dict = doc-&gt;dict;
6984             xmlDictReference(doc-&gt;dict);
6985 #ifdef WITH_XSLT_DEBUG
6986             xsltGenericDebug(xsltGenericDebugContext,
6987             &quot;reusing dictionary from %s for embedded stylesheet\n&quot;,
6988             doc-&gt;URL);
6989 #endif
6990 
6991             newtree = xmlDocCopyNode(subtree, fake, 1);
6992 
6993             fake-&gt;URL = xmlNodeGetBase(doc, subtree-&gt;parent);
6994 #ifdef WITH_XSLT_DEBUG
6995             xsltGenericDebug(xsltGenericDebugContext,
6996             &quot;set base URI for embedded stylesheet as %s\n&quot;,
6997             fake-&gt;URL);
6998 #endif
6999 
7000             /*
7001             * Add all namespaces in scope of embedded stylesheet to
7002             * root element of newly created stylesheet document
7003             */
7004             while ((subtree = subtree-&gt;parent) != (xmlNodePtr)doc) {
7005             for (ns = subtree-&gt;ns; ns; ns = ns-&gt;next) {
7006                 xmlNewNs(newtree,  ns-&gt;href, ns-&gt;prefix);
7007             }
7008             }
7009 
7010             xmlAddChild((xmlNodePtr)fake, newtree);
7011             ret = xsltParseStylesheetDoc(fake);
7012             if (ret == NULL)
7013             xmlFreeDoc(fake);
7014         }
7015         }
7016     } else {
7017         xmlChar *URL, *base;
7018 
7019         /*
7020          * Reference to an external stylesheet
7021          */
7022 
7023         base = xmlNodeGetBase(doc, (xmlNodePtr) doc);
7024         URL = xmlBuildURI(href, base);
7025         if (URL != NULL) {
7026 #ifdef WITH_XSLT_DEBUG_PARSING
7027         xsltGenericDebug(xsltGenericDebugContext,
7028             &quot;xsltLoadStylesheetPI : fetching %s\n&quot;, URL);
7029 #endif
7030         ret = xsltParseStylesheetFile(URL);
7031         xmlFree(URL);
7032         } else {
7033 #ifdef WITH_XSLT_DEBUG_PARSING
7034         xsltGenericDebug(xsltGenericDebugContext,
7035             &quot;xsltLoadStylesheetPI : fetching %s\n&quot;, href);
7036 #endif
7037         ret = xsltParseStylesheetFile(href);
7038         }
7039         if (base != NULL)
7040         xmlFree(base);
7041     }
7042     xmlFreeURI(URI);
7043     xmlFree(href);
7044     }
7045     return(ret);
7046 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>