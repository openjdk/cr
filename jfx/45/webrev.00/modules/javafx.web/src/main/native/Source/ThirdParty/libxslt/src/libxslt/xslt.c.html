<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xslt.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * xslt.c: Implemetation of an XSL Transformation 1.0 engine
   3  *
   4  * Reference:
   5  *   XSLT specification
   6  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   7  *
   8  *   Associating Style Sheets with XML documents
   9  *   http://www.w3.org/1999/06/REC-xml-stylesheet-19990629
  10  *
  11  * See Copyright for the status of this software.
  12  *
  13  * daniel@veillard.com
  14  */
  15 
  16 #define IN_LIBXSLT
  17 #include &quot;libxslt.h&quot;
  18 
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parser.h&gt;
  23 #include &lt;libxml/tree.h&gt;
  24 #include &lt;libxml/valid.h&gt;
  25 #include &lt;libxml/hash.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/xmlerror.h&gt;
  28 #include &lt;libxml/parserInternals.h&gt;
  29 #include &lt;libxml/xpathInternals.h&gt;
  30 #include &lt;libxml/xpath.h&gt;
  31 #include &quot;xslt.h&quot;
  32 #include &quot;xsltInternals.h&quot;
  33 #include &quot;pattern.h&quot;
  34 #include &quot;variables.h&quot;
  35 #include &quot;namespaces.h&quot;
  36 #include &quot;attributes.h&quot;
  37 #include &quot;xsltutils.h&quot;
  38 #include &quot;imports.h&quot;
  39 #include &quot;keys.h&quot;
  40 #include &quot;documents.h&quot;
  41 #include &quot;extensions.h&quot;
  42 #include &quot;preproc.h&quot;
  43 #include &quot;extra.h&quot;
  44 #include &quot;security.h&quot;
  45 #include &quot;xsltlocale.h&quot;
  46 
  47 #ifdef WITH_XSLT_DEBUG
  48 #define WITH_XSLT_DEBUG_PARSING
  49 /* #define WITH_XSLT_DEBUG_BLANKS */
  50 #endif
  51 
  52 const char *xsltEngineVersion = LIBXSLT_VERSION_STRING LIBXSLT_VERSION_EXTRA;
  53 const int xsltLibxsltVersion = LIBXSLT_VERSION;
  54 const int xsltLibxmlVersion = LIBXML_VERSION;
  55 
  56 #ifdef XSLT_REFACTORED
  57 
  58 const xmlChar *xsltConstNamespaceNameXSLT = (const xmlChar *) XSLT_NAMESPACE;
  59 
  60 #define XSLT_ELEMENT_CATEGORY_XSLT 0
  61 #define XSLT_ELEMENT_CATEGORY_EXTENSION 1
  62 #define XSLT_ELEMENT_CATEGORY_LRE 2
  63 
  64 /*
  65 * xsltLiteralResultMarker:
  66 * Marker for Literal result elements, in order to avoid multiple attempts
  67 * to recognize such elements in the stylesheet&#39;s tree.
  68 * This marker is set on node-&gt;psvi during the initial traversal
  69 * of a stylesheet&#39;s node tree.
  70 *
  71 const xmlChar *xsltLiteralResultMarker =
  72     (const xmlChar *) &quot;Literal Result Element&quot;;
  73 */
  74 
  75 /*
  76 * xsltXSLTTextMarker:
  77 * Marker for xsl:text elements. Used to recognize xsl:text elements
  78 * for post-processing of the stylesheet&#39;s tree, where those
  79 * elements are removed from the tree.
  80 */
  81 const xmlChar *xsltXSLTTextMarker = (const xmlChar *) &quot;XSLT Text Element&quot;;
  82 
  83 /*
  84 * xsltXSLTAttrMarker:
  85 * Marker for XSLT attribute on Literal Result Elements.
  86 */
  87 const xmlChar *xsltXSLTAttrMarker = (const xmlChar *) &quot;LRE XSLT Attr&quot;;
  88 
  89 #endif
  90 
  91 #ifdef XSLT_LOCALE_WINAPI
  92 extern xmlRMutexPtr xsltLocaleMutex;
  93 #endif
  94 /*
  95  * Harmless but avoiding a problem when compiling against a
  96  * libxml &lt;= 2.3.11 without LIBXML_DEBUG_ENABLED
  97  */
  98 #ifndef LIBXML_DEBUG_ENABLED
  99 double xmlXPathStringEvalNumber(const xmlChar *str);
 100 #endif
 101 /*
 102  * Useful macros
 103  */
 104 
 105 #ifdef  IS_BLANK
 106 #undef  IS_BLANK
 107 #endif
 108 #define IS_BLANK(c) (((c) == 0x20) || ((c) == 0x09) || ((c) == 0xA) ||  \
 109                      ((c) == 0x0D))
 110 
 111 #ifdef  IS_BLANK_NODE
 112 #undef  IS_BLANK_NODE
 113 #endif
 114 #define IS_BLANK_NODE(n)                        \
 115     (((n)-&gt;type == XML_TEXT_NODE) &amp;&amp; (xsltIsBlank((n)-&gt;content)))
 116 
 117 /**
 118  * xsltParseContentError:
 119  *
 120  * @style: the stylesheet
 121  * @node: the node where the error occured
 122  *
 123  * Compile-time error function.
 124  */
 125 static void
 126 xsltParseContentError(xsltStylesheetPtr style,
 127                xmlNodePtr node)
 128 {
 129     if ((style == NULL) || (node == NULL))
 130     return;
 131 
 132     if (IS_XSLT_ELEM(node))
 133     xsltTransformError(NULL, style, node,
 134         &quot;The XSLT-element &#39;%s&#39; is not allowed at this position.\n&quot;,
 135         node-&gt;name);
 136     else
 137     xsltTransformError(NULL, style, node,
 138         &quot;The element &#39;%s&#39; is not allowed at this position.\n&quot;,
 139         node-&gt;name);
 140     style-&gt;errors++;
 141 }
 142 
 143 #ifdef XSLT_REFACTORED
 144 #else
 145 /**
 146  * exclPrefixPush:
 147  * @style: the transformation stylesheet
 148  * @value:  the excluded namespace name to push on the stack
 149  *
 150  * Push an excluded namespace name on the stack
 151  *
 152  * Returns the new index in the stack or -1 if already present or
 153  * in case of error
 154  */
 155 static int
 156 exclPrefixPush(xsltStylesheetPtr style, xmlChar * value)
 157 {
 158     int i;
 159 
 160     if (style-&gt;exclPrefixMax == 0) {
 161         style-&gt;exclPrefixMax = 4;
 162         style-&gt;exclPrefixTab =
 163             (xmlChar * *)xmlMalloc(style-&gt;exclPrefixMax *
 164                                    sizeof(style-&gt;exclPrefixTab[0]));
 165         if (style-&gt;exclPrefixTab == NULL) {
 166             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 167             return (-1);
 168         }
 169     }
 170     /* do not push duplicates */
 171     for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
 172         if (xmlStrEqual(style-&gt;exclPrefixTab[i], value))
 173         return(-1);
 174     }
 175     if (style-&gt;exclPrefixNr &gt;= style-&gt;exclPrefixMax) {
 176         style-&gt;exclPrefixMax *= 2;
 177         style-&gt;exclPrefixTab =
 178             (xmlChar * *)xmlRealloc(style-&gt;exclPrefixTab,
 179                                     style-&gt;exclPrefixMax *
 180                                     sizeof(style-&gt;exclPrefixTab[0]));
 181         if (style-&gt;exclPrefixTab == NULL) {
 182             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 183             return (-1);
 184         }
 185     }
 186     style-&gt;exclPrefixTab[style-&gt;exclPrefixNr] = value;
 187     style-&gt;exclPrefix = value;
 188     return (style-&gt;exclPrefixNr++);
 189 }
 190 /**
 191  * exclPrefixPop:
 192  * @style: the transformation stylesheet
 193  *
 194  * Pop an excluded prefix value from the stack
 195  *
 196  * Returns the stored excluded prefix value
 197  */
 198 static xmlChar *
 199 exclPrefixPop(xsltStylesheetPtr style)
 200 {
 201     xmlChar *ret;
 202 
 203     if (style-&gt;exclPrefixNr &lt;= 0)
 204         return (0);
 205     style-&gt;exclPrefixNr--;
 206     if (style-&gt;exclPrefixNr &gt; 0)
 207         style-&gt;exclPrefix = style-&gt;exclPrefixTab[style-&gt;exclPrefixNr - 1];
 208     else
 209         style-&gt;exclPrefix = NULL;
 210     ret = style-&gt;exclPrefixTab[style-&gt;exclPrefixNr];
 211     style-&gt;exclPrefixTab[style-&gt;exclPrefixNr] = 0;
 212     return (ret);
 213 }
 214 #endif
 215 
 216 /************************************************************************
 217  *                                  *
 218  *          Helper functions                *
 219  *                                  *
 220  ************************************************************************/
 221 
 222 static int initialized = 0;
 223 /**
 224  * xsltInit:
 225  *
 226  * Initializes the processor (e.g. registers built-in extensions,
 227  * etc.)
 228  */
 229 void
 230 xsltInit (void) {
 231     if (initialized == 0) {
 232     initialized = 1;
 233 #ifdef XSLT_LOCALE_WINAPI
 234     xsltLocaleMutex = xmlNewRMutex();
 235 #endif
 236         xsltRegisterAllExtras();
 237     }
 238 }
 239 
 240 /**
 241  * xsltUninit:
 242  *
 243  * Uninitializes the processor.
 244  */
 245 void
 246 xsltUninit (void) {
 247 #ifdef XSLT_LOCALE_WINAPI
 248     xmlFreeRMutex(xsltLocaleMutex);
 249     xsltLocaleMutex = NULL;
 250 #endif
 251     initialized = 0;
 252 }
 253 
 254 /**
 255  * xsltIsBlank:
 256  * @str:  a string
 257  *
 258  * Check if a string is ignorable
 259  *
 260  * Returns 1 if the string is NULL or made of blanks chars, 0 otherwise
 261  */
 262 int
 263 xsltIsBlank(xmlChar *str) {
 264     if (str == NULL)
 265     return(1);
 266     while (*str != 0) {
 267     if (!(IS_BLANK(*str))) return(0);
 268     str++;
 269     }
 270     return(1);
 271 }
 272 
 273 /************************************************************************
 274  *                                  *
 275  *      Routines to handle XSLT data structures         *
 276  *                                  *
 277  ************************************************************************/
 278 static xsltDecimalFormatPtr
 279 xsltNewDecimalFormat(const xmlChar *nsUri, xmlChar *name)
 280 {
 281     xsltDecimalFormatPtr self;
 282     /* UTF-8 for 0x2030 */
 283     static const xmlChar permille[4] = {0xe2, 0x80, 0xb0, 0};
 284 
 285     self = xmlMalloc(sizeof(xsltDecimalFormat));
 286     if (self != NULL) {
 287     self-&gt;next = NULL;
 288         self-&gt;nsUri = nsUri;
 289     self-&gt;name = name;
 290 
 291     /* Default values */
 292     self-&gt;digit = xmlStrdup(BAD_CAST(&quot;#&quot;));
 293     self-&gt;patternSeparator = xmlStrdup(BAD_CAST(&quot;;&quot;));
 294     self-&gt;decimalPoint = xmlStrdup(BAD_CAST(&quot;.&quot;));
 295     self-&gt;grouping = xmlStrdup(BAD_CAST(&quot;,&quot;));
 296     self-&gt;percent = xmlStrdup(BAD_CAST(&quot;%&quot;));
 297     self-&gt;permille = xmlStrdup(BAD_CAST(permille));
 298     self-&gt;zeroDigit = xmlStrdup(BAD_CAST(&quot;0&quot;));
 299     self-&gt;minusSign = xmlStrdup(BAD_CAST(&quot;-&quot;));
 300     self-&gt;infinity = xmlStrdup(BAD_CAST(&quot;Infinity&quot;));
 301     self-&gt;noNumber = xmlStrdup(BAD_CAST(&quot;NaN&quot;));
 302     }
 303     return self;
 304 }
 305 
 306 static void
 307 xsltFreeDecimalFormat(xsltDecimalFormatPtr self)
 308 {
 309     if (self != NULL) {
 310     if (self-&gt;digit)
 311         xmlFree(self-&gt;digit);
 312     if (self-&gt;patternSeparator)
 313         xmlFree(self-&gt;patternSeparator);
 314     if (self-&gt;decimalPoint)
 315         xmlFree(self-&gt;decimalPoint);
 316     if (self-&gt;grouping)
 317         xmlFree(self-&gt;grouping);
 318     if (self-&gt;percent)
 319         xmlFree(self-&gt;percent);
 320     if (self-&gt;permille)
 321         xmlFree(self-&gt;permille);
 322     if (self-&gt;zeroDigit)
 323         xmlFree(self-&gt;zeroDigit);
 324     if (self-&gt;minusSign)
 325         xmlFree(self-&gt;minusSign);
 326     if (self-&gt;infinity)
 327         xmlFree(self-&gt;infinity);
 328     if (self-&gt;noNumber)
 329         xmlFree(self-&gt;noNumber);
 330     if (self-&gt;name)
 331         xmlFree(self-&gt;name);
 332     xmlFree(self);
 333     }
 334 }
 335 
 336 static void
 337 xsltFreeDecimalFormatList(xsltStylesheetPtr self)
 338 {
 339     xsltDecimalFormatPtr iter;
 340     xsltDecimalFormatPtr tmp;
 341 
 342     if (self == NULL)
 343     return;
 344 
 345     iter = self-&gt;decimalFormat;
 346     while (iter != NULL) {
 347     tmp = iter-&gt;next;
 348     xsltFreeDecimalFormat(iter);
 349     iter = tmp;
 350     }
 351 }
 352 
 353 /**
 354  * xsltDecimalFormatGetByName:
 355  * @style: the XSLT stylesheet
 356  * @name: the decimal-format name to find
 357  *
 358  * Find decimal-format by name
 359  *
 360  * Returns the xsltDecimalFormatPtr
 361  */
 362 xsltDecimalFormatPtr
 363 xsltDecimalFormatGetByName(xsltStylesheetPtr style, xmlChar *name)
 364 {
 365     xsltDecimalFormatPtr result = NULL;
 366 
 367     if (name == NULL)
 368     return style-&gt;decimalFormat;
 369 
 370     while (style != NULL) {
 371     for (result = style-&gt;decimalFormat-&gt;next;
 372          result != NULL;
 373          result = result-&gt;next) {
 374         if ((result-&gt;nsUri == NULL) &amp;&amp; xmlStrEqual(name, result-&gt;name))
 375         return result;
 376     }
 377     style = xsltNextImport(style);
 378     }
 379     return result;
 380 }
 381 
 382 /**
 383  * xsltDecimalFormatGetByQName:
 384  * @style: the XSLT stylesheet
 385  * @nsUri: the namespace URI of the QName
 386  * @name: the local part of the QName
 387  *
 388  * Find decimal-format by QName
 389  *
 390  * Returns the xsltDecimalFormatPtr
 391  */
 392 xsltDecimalFormatPtr
 393 xsltDecimalFormatGetByQName(xsltStylesheetPtr style, const xmlChar *nsUri,
 394                             const xmlChar *name)
 395 {
 396     xsltDecimalFormatPtr result = NULL;
 397 
 398     if (name == NULL)
 399     return style-&gt;decimalFormat;
 400 
 401     while (style != NULL) {
 402     for (result = style-&gt;decimalFormat-&gt;next;
 403          result != NULL;
 404          result = result-&gt;next) {
 405         if (xmlStrEqual(nsUri, result-&gt;nsUri) &amp;&amp;
 406                 xmlStrEqual(name, result-&gt;name))
 407         return result;
 408     }
 409     style = xsltNextImport(style);
 410     }
 411     return result;
 412 }
 413 
 414 
 415 /**
 416  * xsltNewTemplate:
 417  *
 418  * Create a new XSLT Template
 419  *
 420  * Returns the newly allocated xsltTemplatePtr or NULL in case of error
 421  */
 422 static xsltTemplatePtr
 423 xsltNewTemplate(void) {
 424     xsltTemplatePtr cur;
 425 
 426     cur = (xsltTemplatePtr) xmlMalloc(sizeof(xsltTemplate));
 427     if (cur == NULL) {
 428     xsltTransformError(NULL, NULL, NULL,
 429         &quot;xsltNewTemplate : malloc failed\n&quot;);
 430     return(NULL);
 431     }
 432     memset(cur, 0, sizeof(xsltTemplate));
 433     cur-&gt;priority = XSLT_PAT_NO_PRIORITY;
 434     return(cur);
 435 }
 436 
 437 /**
 438  * xsltFreeTemplate:
 439  * @template:  an XSLT template
 440  *
 441  * Free up the memory allocated by @template
 442  */
 443 static void
 444 xsltFreeTemplate(xsltTemplatePtr template) {
 445     if (template == NULL)
 446     return;
 447     if (template-&gt;match) xmlFree(template-&gt;match);
 448 /*
 449 *   NOTE: @name and @nameURI are put into the string dict now.
 450 *   if (template-&gt;name) xmlFree(template-&gt;name);
 451 *   if (template-&gt;nameURI) xmlFree(template-&gt;nameURI);
 452 */
 453 /*
 454     if (template-&gt;mode) xmlFree(template-&gt;mode);
 455     if (template-&gt;modeURI) xmlFree(template-&gt;modeURI);
 456  */
 457     if (template-&gt;inheritedNs) xmlFree(template-&gt;inheritedNs);
 458 
 459     /* free profiling data */
 460     if (template-&gt;templCalledTab) xmlFree(template-&gt;templCalledTab);
 461     if (template-&gt;templCountTab) xmlFree(template-&gt;templCountTab);
 462 
 463     memset(template, -1, sizeof(xsltTemplate));
 464     xmlFree(template);
 465 }
 466 
 467 /**
 468  * xsltFreeTemplateList:
 469  * @template:  an XSLT template list
 470  *
 471  * Free up the memory allocated by all the elements of @template
 472  */
 473 static void
 474 xsltFreeTemplateList(xsltTemplatePtr template) {
 475     xsltTemplatePtr cur;
 476 
 477     while (template != NULL) {
 478     cur = template;
 479     template = template-&gt;next;
 480     xsltFreeTemplate(cur);
 481     }
 482 }
 483 
 484 #ifdef XSLT_REFACTORED
 485 
 486 static void
 487 xsltFreeNsAliasList(xsltNsAliasPtr item)
 488 {
 489     xsltNsAliasPtr tmp;
 490 
 491     while (item) {
 492     tmp = item;
 493     item = item-&gt;next;
 494     xmlFree(tmp);
 495     }
 496     return;
 497 }
 498 
 499 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 500 static void
 501 xsltFreeNamespaceMap(xsltNsMapPtr item)
 502 {
 503     xsltNsMapPtr tmp;
 504 
 505     while (item) {
 506     tmp = item;
 507     item = item-&gt;next;
 508     xmlFree(tmp);
 509     }
 510     return;
 511 }
 512 
 513 static xsltNsMapPtr
 514 xsltNewNamespaceMapItem(xsltCompilerCtxtPtr cctxt,
 515             xmlDocPtr doc,
 516             xmlNsPtr ns,
 517             xmlNodePtr elem)
 518 {
 519     xsltNsMapPtr ret;
 520 
 521     if ((cctxt == NULL) || (doc == NULL) || (ns == NULL))
 522     return(NULL);
 523 
 524     ret = (xsltNsMapPtr) xmlMalloc(sizeof(xsltNsMap));
 525     if (ret == NULL) {
 526     xsltTransformError(NULL, cctxt-&gt;style, elem,
 527         &quot;Internal error: (xsltNewNamespaceMapItem) &quot;
 528         &quot;memory allocation failed.\n&quot;);
 529     return(NULL);
 530     }
 531     memset(ret, 0, sizeof(xsltNsMap));
 532     ret-&gt;doc = doc;
 533     ret-&gt;ns = ns;
 534     ret-&gt;origNsName = ns-&gt;href;
 535     /*
 536     * Store the item at current stylesheet-level.
 537     */
 538     if (cctxt-&gt;psData-&gt;nsMap != NULL)
 539     ret-&gt;next = cctxt-&gt;psData-&gt;nsMap;
 540     cctxt-&gt;psData-&gt;nsMap = ret;
 541 
 542     return(ret);
 543 }
 544 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
 545 
 546 /**
 547  * xsltCompilerVarInfoFree:
 548  * @cctxt: the compilation context
 549  *
 550  * Frees the list of information for vars/params.
 551  */
 552 static void
 553 xsltCompilerVarInfoFree(xsltCompilerCtxtPtr cctxt)
 554 {
 555     xsltVarInfoPtr ivar = cctxt-&gt;ivars, ivartmp;
 556 
 557     while (ivar) {
 558     ivartmp = ivar;
 559     ivar = ivar-&gt;next;
 560     xmlFree(ivartmp);
 561     }
 562 }
 563 
 564 /**
 565  * xsltCompilerCtxtFree:
 566  *
 567  * Free an XSLT compiler context.
 568  */
 569 static void
 570 xsltCompilationCtxtFree(xsltCompilerCtxtPtr cctxt)
 571 {
 572     if (cctxt == NULL)
 573     return;
 574 #ifdef WITH_XSLT_DEBUG_PARSING
 575     xsltGenericDebug(xsltGenericDebugContext,
 576     &quot;Freeing compilation context\n&quot;);
 577     xsltGenericDebug(xsltGenericDebugContext,
 578     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
 579     xsltGenericDebug(xsltGenericDebugContext,
 580     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
 581 #endif
 582     /*
 583     * Free node-infos.
 584     */
 585     if (cctxt-&gt;inodeList != NULL) {
 586     xsltCompilerNodeInfoPtr tmp, cur = cctxt-&gt;inodeList;
 587     while (cur != NULL) {
 588         tmp = cur;
 589         cur = cur-&gt;next;
 590         xmlFree(tmp);
 591     }
 592     }
 593     if (cctxt-&gt;tmpList != NULL)
 594     xsltPointerListFree(cctxt-&gt;tmpList);
 595     if (cctxt-&gt;nsAliases != NULL)
 596     xsltFreeNsAliasList(cctxt-&gt;nsAliases);
 597 
 598     if (cctxt-&gt;ivars)
 599     xsltCompilerVarInfoFree(cctxt);
 600 
 601     xmlFree(cctxt);
 602 }
 603 
 604 /**
 605  * xsltCompilerCreate:
 606  *
 607  * Creates an XSLT compiler context.
 608  *
 609  * Returns the pointer to the created xsltCompilerCtxt or
 610  *         NULL in case of an internal error.
 611  */
 612 static xsltCompilerCtxtPtr
 613 xsltCompilationCtxtCreate(xsltStylesheetPtr style) {
 614     xsltCompilerCtxtPtr ret;
 615 
 616     ret = (xsltCompilerCtxtPtr) xmlMalloc(sizeof(xsltCompilerCtxt));
 617     if (ret == NULL) {
 618     xsltTransformError(NULL, style, NULL,
 619         &quot;xsltCompilerCreate: allocation of compiler &quot;
 620         &quot;context failed.\n&quot;);
 621     return(NULL);
 622     }
 623     memset(ret, 0, sizeof(xsltCompilerCtxt));
 624 
 625     ret-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
 626     ret-&gt;tmpList = xsltPointerListCreate(20);
 627     if (ret-&gt;tmpList == NULL) {
 628     goto internal_err;
 629     }
 630 
 631     return(ret);
 632 
 633 internal_err:
 634     xsltCompilationCtxtFree(ret);
 635     return(NULL);
 636 }
 637 
 638 static void
 639 xsltLREEffectiveNsNodesFree(xsltEffectiveNsPtr first)
 640 {
 641     xsltEffectiveNsPtr tmp;
 642 
 643     while (first != NULL) {
 644     tmp = first;
 645     first = first-&gt;nextInStore;
 646     xmlFree(tmp);
 647     }
 648 }
 649 
 650 static void
 651 xsltFreePrincipalStylesheetData(xsltPrincipalStylesheetDataPtr data)
 652 {
 653     if (data == NULL)
 654     return;
 655 
 656     if (data-&gt;inScopeNamespaces != NULL) {
 657     int i;
 658     xsltNsListContainerPtr nsi;
 659     xsltPointerListPtr list =
 660         (xsltPointerListPtr) data-&gt;inScopeNamespaces;
 661 
 662     for (i = 0; i &lt; list-&gt;number; i++) {
 663         /*
 664         * REVISIT TODO: Free info of in-scope namespaces.
 665         */
 666         nsi = (xsltNsListContainerPtr) list-&gt;items[i];
 667         if (nsi-&gt;list != NULL)
 668         xmlFree(nsi-&gt;list);
 669         xmlFree(nsi);
 670     }
 671     xsltPointerListFree(list);
 672     data-&gt;inScopeNamespaces = NULL;
 673     }
 674 
 675     if (data-&gt;exclResultNamespaces != NULL) {
 676     int i;
 677     xsltPointerListPtr list = (xsltPointerListPtr)
 678         data-&gt;exclResultNamespaces;
 679 
 680     for (i = 0; i &lt; list-&gt;number; i++)
 681         xsltPointerListFree((xsltPointerListPtr) list-&gt;items[i]);
 682 
 683     xsltPointerListFree(list);
 684     data-&gt;exclResultNamespaces = NULL;
 685     }
 686 
 687     if (data-&gt;extElemNamespaces != NULL) {
 688     xsltPointerListPtr list = (xsltPointerListPtr)
 689         data-&gt;extElemNamespaces;
 690     int i;
 691 
 692     for (i = 0; i &lt; list-&gt;number; i++)
 693         xsltPointerListFree((xsltPointerListPtr) list-&gt;items[i]);
 694 
 695     xsltPointerListFree(list);
 696     data-&gt;extElemNamespaces = NULL;
 697     }
 698     if (data-&gt;effectiveNs) {
 699     xsltLREEffectiveNsNodesFree(data-&gt;effectiveNs);
 700     data-&gt;effectiveNs = NULL;
 701     }
 702 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 703     xsltFreeNamespaceMap(data-&gt;nsMap);
 704 #endif
 705     xmlFree(data);
 706 }
 707 
 708 static xsltPrincipalStylesheetDataPtr
 709 xsltNewPrincipalStylesheetData(void)
 710 {
 711     xsltPrincipalStylesheetDataPtr ret;
 712 
 713     ret = (xsltPrincipalStylesheetDataPtr)
 714     xmlMalloc(sizeof(xsltPrincipalStylesheetData));
 715     if (ret == NULL) {
 716     xsltTransformError(NULL, NULL, NULL,
 717         &quot;xsltNewPrincipalStylesheetData: memory allocation failed.\n&quot;);
 718     return(NULL);
 719     }
 720     memset(ret, 0, sizeof(xsltPrincipalStylesheetData));
 721 
 722     /*
 723     * Global list of in-scope namespaces.
 724     */
 725     ret-&gt;inScopeNamespaces = xsltPointerListCreate(-1);
 726     if (ret-&gt;inScopeNamespaces == NULL)
 727     goto internal_err;
 728     /*
 729     * Global list of excluded result ns-decls.
 730     */
 731     ret-&gt;exclResultNamespaces = xsltPointerListCreate(-1);
 732     if (ret-&gt;exclResultNamespaces == NULL)
 733     goto internal_err;
 734     /*
 735     * Global list of extension instruction namespace names.
 736     */
 737     ret-&gt;extElemNamespaces = xsltPointerListCreate(-1);
 738     if (ret-&gt;extElemNamespaces == NULL)
 739     goto internal_err;
 740 
 741     return(ret);
 742 
 743 internal_err:
 744 
 745     return(NULL);
 746 }
 747 
 748 #endif
 749 
 750 /**
 751  * xsltNewStylesheetInternal:
 752  * @parent:  the parent stylesheet or NULL
 753  *
 754  * Create a new XSLT Stylesheet
 755  *
 756  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error
 757  */
 758 static xsltStylesheetPtr
 759 xsltNewStylesheetInternal(xsltStylesheetPtr parent) {
 760     xsltStylesheetPtr ret = NULL;
 761 
 762     ret = (xsltStylesheetPtr) xmlMalloc(sizeof(xsltStylesheet));
 763     if (ret == NULL) {
 764     xsltTransformError(NULL, NULL, NULL,
 765         &quot;xsltNewStylesheet : malloc failed\n&quot;);
 766     goto internal_err;
 767     }
 768     memset(ret, 0, sizeof(xsltStylesheet));
 769 
 770     ret-&gt;parent = parent;
 771     ret-&gt;omitXmlDeclaration = -1;
 772     ret-&gt;standalone = -1;
 773     ret-&gt;decimalFormat = xsltNewDecimalFormat(NULL, NULL);
 774     ret-&gt;indent = -1;
 775     ret-&gt;errors = 0;
 776     ret-&gt;warnings = 0;
 777     ret-&gt;exclPrefixNr = 0;
 778     ret-&gt;exclPrefixMax = 0;
 779     ret-&gt;exclPrefixTab = NULL;
 780     ret-&gt;extInfos = NULL;
 781     ret-&gt;extrasNr = 0;
 782     ret-&gt;internalized = 1;
 783     ret-&gt;literal_result = 0;
 784     ret-&gt;forwards_compatible = 0;
 785     ret-&gt;dict = xmlDictCreate();
 786 #ifdef WITH_XSLT_DEBUG
 787     xsltGenericDebug(xsltGenericDebugContext,
 788     &quot;creating dictionary for stylesheet\n&quot;);
 789 #endif
 790 
 791     if (parent == NULL) {
 792         ret-&gt;principal = ret;
 793 
 794         ret-&gt;xpathCtxt = xmlXPathNewContext(NULL);
 795         if (ret-&gt;xpathCtxt == NULL) {
 796             xsltTransformError(NULL, NULL, NULL,
 797                     &quot;xsltNewStylesheet: xmlXPathNewContext failed\n&quot;);
 798             goto internal_err;
 799         }
 800         if (xmlXPathContextSetCache(ret-&gt;xpathCtxt, 1, -1, 0) == -1)
 801             goto internal_err;
 802     } else {
 803         ret-&gt;principal = parent-&gt;principal;
 804     }
 805 
 806     xsltInit();
 807 
 808     return(ret);
 809 
 810 internal_err:
 811     if (ret != NULL)
 812     xsltFreeStylesheet(ret);
 813     return(NULL);
 814 }
 815 
 816 /**
 817  * xsltNewStylesheet:
 818  *
 819  * Create a new XSLT Stylesheet
 820  *
 821  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error
 822  */
 823 xsltStylesheetPtr
 824 xsltNewStylesheet(void) {
 825     return xsltNewStylesheetInternal(NULL);
 826 }
 827 
 828 /**
 829  * xsltAllocateExtra:
 830  * @style:  an XSLT stylesheet
 831  *
 832  * Allocate an extra runtime information slot statically while compiling
 833  * the stylesheet and return its number
 834  *
 835  * Returns the number of the slot
 836  */
 837 int
 838 xsltAllocateExtra(xsltStylesheetPtr style)
 839 {
 840     return(style-&gt;extrasNr++);
 841 }
 842 
 843 /**
 844  * xsltAllocateExtraCtxt:
 845  * @ctxt:  an XSLT transformation context
 846  *
 847  * Allocate an extra runtime information slot at run-time
 848  * and return its number
 849  * This make sure there is a slot ready in the transformation context
 850  *
 851  * Returns the number of the slot
 852  */
 853 int
 854 xsltAllocateExtraCtxt(xsltTransformContextPtr ctxt)
 855 {
 856     if (ctxt-&gt;extrasNr &gt;= ctxt-&gt;extrasMax) {
 857     int i;
 858     if (ctxt-&gt;extrasNr == 0) {
 859         ctxt-&gt;extrasMax = 20;
 860         ctxt-&gt;extras = (xsltRuntimeExtraPtr)
 861         xmlMalloc(ctxt-&gt;extrasMax * sizeof(xsltRuntimeExtra));
 862         if (ctxt-&gt;extras == NULL) {
 863         xsltTransformError(ctxt, NULL, NULL,
 864             &quot;xsltAllocateExtraCtxt: out of memory\n&quot;);
 865         return(0);
 866         }
 867         for (i = 0;i &lt; ctxt-&gt;extrasMax;i++) {
 868         ctxt-&gt;extras[i].info = NULL;
 869         ctxt-&gt;extras[i].deallocate = NULL;
 870         ctxt-&gt;extras[i].val.ptr = NULL;
 871         }
 872 
 873     } else {
 874         xsltRuntimeExtraPtr tmp;
 875 
 876         ctxt-&gt;extrasMax += 100;
 877         tmp = (xsltRuntimeExtraPtr) xmlRealloc(ctxt-&gt;extras,
 878                     ctxt-&gt;extrasMax * sizeof(xsltRuntimeExtra));
 879         if (tmp == NULL) {
 880         xsltTransformError(ctxt, NULL, NULL,
 881             &quot;xsltAllocateExtraCtxt: out of memory\n&quot;);
 882         return(0);
 883         }
 884         ctxt-&gt;extras = tmp;
 885         for (i = ctxt-&gt;extrasNr;i &lt; ctxt-&gt;extrasMax;i++) {
 886         ctxt-&gt;extras[i].info = NULL;
 887         ctxt-&gt;extras[i].deallocate = NULL;
 888         ctxt-&gt;extras[i].val.ptr = NULL;
 889         }
 890     }
 891     }
 892     return(ctxt-&gt;extrasNr++);
 893 }
 894 
 895 /**
 896  * xsltFreeStylesheetList:
 897  * @style:  an XSLT stylesheet list
 898  *
 899  * Free up the memory allocated by the list @style
 900  */
 901 static void
 902 xsltFreeStylesheetList(xsltStylesheetPtr style) {
 903     xsltStylesheetPtr next;
 904 
 905     while (style != NULL) {
 906     next = style-&gt;next;
 907     xsltFreeStylesheet(style);
 908     style = next;
 909     }
 910 }
 911 
 912 /**
 913  * xsltCleanupStylesheetTree:
 914  *
 915  * @doc: the document-node
 916  * @node: the element where the stylesheet is rooted at
 917  *
 918  * Actually @node need not be the document-element, but
 919  * currently Libxslt does not support embedded stylesheets.
 920  *
 921  * Returns 0 if OK, -1 on API or internal errors.
 922  */
 923 static int
 924 xsltCleanupStylesheetTree(xmlDocPtr doc ATTRIBUTE_UNUSED,
 925               xmlNodePtr rootElem ATTRIBUTE_UNUSED)
 926 {
 927 #if 0 /* TODO: Currently disabled, since probably not needed. */
 928     xmlNodePtr cur;
 929 
 930     if ((doc == NULL) || (rootElem == NULL) ||
 931     (rootElem-&gt;type != XML_ELEMENT_NODE) ||
 932     (doc != rootElem-&gt;doc))
 933     return(-1);
 934 
 935     /*
 936     * Cleanup was suggested by Aleksey Sanin:
 937     * Clear the PSVI field to avoid problems if the
 938     * node-tree of the stylesheet is intended to be used for
 939     * further processing by the user (e.g. for compiling it
 940     * once again - although not recommended).
 941     */
 942 
 943     cur = rootElem;
 944     while (cur != NULL) {
 945     if (cur-&gt;type == XML_ELEMENT_NODE) {
 946         /*
 947         * Clear the PSVI field.
 948         */
 949         cur-&gt;psvi = NULL;
 950         if (cur-&gt;children) {
 951         cur = cur-&gt;children;
 952         continue;
 953         }
 954     }
 955 
 956 leave_node:
 957     if (cur == rootElem)
 958         break;
 959     if (cur-&gt;next != NULL)
 960         cur = cur-&gt;next;
 961     else {
 962         cur = cur-&gt;parent;
 963         if (cur == NULL)
 964         break;
 965         goto leave_node;
 966     }
 967     }
 968 #endif /* #if 0 */
 969     return(0);
 970 }
 971 
 972 /**
 973  * xsltFreeStylesheet:
 974  * @style:  an XSLT stylesheet
 975  *
 976  * Free up the memory allocated by @style
 977  */
 978 void
 979 xsltFreeStylesheet(xsltStylesheetPtr style)
 980 {
 981     if (style == NULL)
 982         return;
 983 
 984 #ifdef XSLT_REFACTORED
 985     /*
 986     * Start with a cleanup of the main stylesheet&#39;s doc.
 987     */
 988     if ((style-&gt;principal == style) &amp;&amp; (style-&gt;doc))
 989     xsltCleanupStylesheetTree(style-&gt;doc,
 990         xmlDocGetRootElement(style-&gt;doc));
 991 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 992     /*
 993     * Restore changed ns-decls before freeing the document.
 994     */
 995     if ((style-&gt;doc != NULL) &amp;&amp;
 996     XSLT_HAS_INTERNAL_NSMAP(style))
 997     {
 998     xsltRestoreDocumentNamespaces(XSLT_GET_INTERNAL_NSMAP(style),
 999         style-&gt;doc);
1000     }
1001 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
1002 #else
1003     /*
1004     * Start with a cleanup of the main stylesheet&#39;s doc.
1005     */
1006     if ((style-&gt;parent == NULL) &amp;&amp; (style-&gt;doc))
1007     xsltCleanupStylesheetTree(style-&gt;doc,
1008         xmlDocGetRootElement(style-&gt;doc));
1009 #endif /* XSLT_REFACTORED */
1010 
1011     xsltFreeKeys(style);
1012     xsltFreeExts(style);
1013     xsltFreeTemplateHashes(style);
1014     xsltFreeDecimalFormatList(style);
1015     xsltFreeTemplateList(style-&gt;templates);
1016     xsltFreeAttributeSetsHashes(style);
1017     xsltFreeNamespaceAliasHashes(style);
1018     xsltFreeStylePreComps(style);
1019     /*
1020     * Free documents of all included stylsheet modules of this
1021     * stylesheet level.
1022     */
1023     xsltFreeStyleDocuments(style);
1024     /*
1025     * TODO: Best time to shutdown extension stuff?
1026     */
1027     xsltShutdownExts(style);
1028 
1029     if (style-&gt;variables != NULL)
1030         xsltFreeStackElemList(style-&gt;variables);
1031     if (style-&gt;cdataSection != NULL)
1032         xmlHashFree(style-&gt;cdataSection, NULL);
1033     if (style-&gt;stripSpaces != NULL)
1034         xmlHashFree(style-&gt;stripSpaces, NULL);
1035     if (style-&gt;nsHash != NULL)
1036         xmlHashFree(style-&gt;nsHash, NULL);
1037     if (style-&gt;exclPrefixTab != NULL)
1038         xmlFree(style-&gt;exclPrefixTab);
1039     if (style-&gt;method != NULL)
1040         xmlFree(style-&gt;method);
1041     if (style-&gt;methodURI != NULL)
1042         xmlFree(style-&gt;methodURI);
1043     if (style-&gt;version != NULL)
1044         xmlFree(style-&gt;version);
1045     if (style-&gt;encoding != NULL)
1046         xmlFree(style-&gt;encoding);
1047     if (style-&gt;doctypePublic != NULL)
1048         xmlFree(style-&gt;doctypePublic);
1049     if (style-&gt;doctypeSystem != NULL)
1050         xmlFree(style-&gt;doctypeSystem);
1051     if (style-&gt;mediaType != NULL)
1052         xmlFree(style-&gt;mediaType);
1053     if (style-&gt;attVTs)
1054         xsltFreeAVTList(style-&gt;attVTs);
1055     if (style-&gt;imports != NULL)
1056         xsltFreeStylesheetList(style-&gt;imports);
1057 
1058 #ifdef XSLT_REFACTORED
1059     /*
1060     * If this is the principal stylesheet, then
1061     * free its internal data.
1062     */
1063     if (style-&gt;principal == style) {
1064     if (style-&gt;principalData) {
1065         xsltFreePrincipalStylesheetData(style-&gt;principalData);
1066         style-&gt;principalData = NULL;
1067     }
1068     }
1069 #endif
1070     /*
1071     * Better to free the main document of this stylesheet level
1072     * at the end - so here.
1073     */
1074     if (style-&gt;doc != NULL) {
1075         xmlFreeDoc(style-&gt;doc);
1076     }
1077 
1078 #ifdef WITH_XSLT_DEBUG
1079     xsltGenericDebug(xsltGenericDebugContext,
1080                      &quot;freeing dictionary from stylesheet\n&quot;);
1081 #endif
1082     xmlDictFree(style-&gt;dict);
1083 
1084     if (style-&gt;xpathCtxt != NULL)
1085     xmlXPathFreeContext(style-&gt;xpathCtxt);
1086 
1087     memset(style, -1, sizeof(xsltStylesheet));
1088     xmlFree(style);
1089 }
1090 
1091 /************************************************************************
1092  *                                  *
1093  *      Parsing of an XSLT Stylesheet               *
1094  *                                  *
1095  ************************************************************************/
1096 
1097 #ifdef XSLT_REFACTORED
1098     /*
1099     * This is now performed in an optimized way in xsltParseXSLTTemplate.
1100     */
1101 #else
1102 /**
1103  * xsltGetInheritedNsList:
1104  * @style:  the stylesheet
1105  * @template: the template
1106  * @node:  the current node
1107  *
1108  * Search all the namespace applying to a given element except the ones
1109  * from excluded output prefixes currently in scope. Initialize the
1110  * template inheritedNs list with it.
1111  *
1112  * Returns the number of entries found
1113  */
1114 static int
1115 xsltGetInheritedNsList(xsltStylesheetPtr style,
1116                    xsltTemplatePtr template,
1117                    xmlNodePtr node)
1118 {
1119     xmlNsPtr cur;
1120     xmlNsPtr *ret = NULL;
1121     int nbns = 0;
1122     int maxns = 10;
1123     int i;
1124 
1125     if ((style == NULL) || (template == NULL) || (node == NULL) ||
1126     (template-&gt;inheritedNsNr != 0) || (template-&gt;inheritedNs != NULL))
1127     return(0);
1128     while (node != NULL) {
1129         if (node-&gt;type == XML_ELEMENT_NODE) {
1130             cur = node-&gt;nsDef;
1131             while (cur != NULL) {
1132         if (xmlStrEqual(cur-&gt;href, XSLT_NAMESPACE))
1133             goto skip_ns;
1134 
1135         if ((cur-&gt;prefix != NULL) &amp;&amp;
1136             (xsltCheckExtPrefix(style, cur-&gt;prefix)))
1137             goto skip_ns;
1138         /*
1139         * Check if this namespace was excluded.
1140         * Note that at this point only the exclusions defined
1141         * on the topmost stylesheet element are in the exclusion-list.
1142         */
1143         for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
1144             if (xmlStrEqual(cur-&gt;href, style-&gt;exclPrefixTab[i]))
1145             goto skip_ns;
1146         }
1147                 if (ret == NULL) {
1148                     ret =
1149                         (xmlNsPtr *) xmlMalloc((maxns + 1) *
1150                                                sizeof(xmlNsPtr));
1151                     if (ret == NULL) {
1152                         xmlGenericError(xmlGenericErrorContext,
1153                                         &quot;xsltGetInheritedNsList : out of memory!\n&quot;);
1154                         return(0);
1155                     }
1156                     ret[nbns] = NULL;
1157                 }
1158         /*
1159         * Skip shadowed namespace bindings.
1160         */
1161                 for (i = 0; i &lt; nbns; i++) {
1162                     if ((cur-&gt;prefix == ret[i]-&gt;prefix) ||
1163                         (xmlStrEqual(cur-&gt;prefix, ret[i]-&gt;prefix)))
1164                         break;
1165                 }
1166                 if (i &gt;= nbns) {
1167                     if (nbns &gt;= maxns) {
1168                         maxns *= 2;
1169                         ret = (xmlNsPtr *) xmlRealloc(ret,
1170                                                       (maxns +
1171                                                        1) *
1172                                                       sizeof(xmlNsPtr));
1173                         if (ret == NULL) {
1174                             xmlGenericError(xmlGenericErrorContext,
1175                                             &quot;xsltGetInheritedNsList : realloc failed!\n&quot;);
1176                             return(0);
1177                         }
1178                     }
1179                     ret[nbns++] = cur;
1180                     ret[nbns] = NULL;
1181                 }
1182 skip_ns:
1183                 cur = cur-&gt;next;
1184             }
1185         }
1186         node = node-&gt;parent;
1187     }
1188     if (nbns != 0) {
1189 #ifdef WITH_XSLT_DEBUG_PARSING
1190         xsltGenericDebug(xsltGenericDebugContext,
1191                          &quot;template has %d inherited namespaces\n&quot;, nbns);
1192 #endif
1193     template-&gt;inheritedNsNr = nbns;
1194     template-&gt;inheritedNs = ret;
1195     }
1196     return (nbns);
1197 }
1198 #endif /* else of XSLT_REFACTORED */
1199 
1200 /**
1201  * xsltParseStylesheetOutput:
1202  * @style:  the XSLT stylesheet
1203  * @cur:  the &quot;output&quot; element
1204  *
1205  * parse an XSLT stylesheet output element and record
1206  * information related to the stylesheet output
1207  */
1208 
1209 void
1210 xsltParseStylesheetOutput(xsltStylesheetPtr style, xmlNodePtr cur)
1211 {
1212     xmlChar *elements,
1213      *prop;
1214     xmlChar *element,
1215      *end;
1216 
1217     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1218         return;
1219 
1220     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;version&quot;, NULL);
1221     if (prop != NULL) {
1222         if (style-&gt;version != NULL)
1223             xmlFree(style-&gt;version);
1224         style-&gt;version = prop;
1225     }
1226 
1227     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;encoding&quot;, NULL);
1228     if (prop != NULL) {
1229         if (style-&gt;encoding != NULL)
1230             xmlFree(style-&gt;encoding);
1231         style-&gt;encoding = prop;
1232     }
1233 
1234     /* relaxed to support xt:document
1235     * TODO KB: What does &quot;relaxed to support xt:document&quot; mean?
1236     */
1237     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;method&quot;, NULL);
1238     if (prop != NULL) {
1239         const xmlChar *URI;
1240 
1241         if (style-&gt;method != NULL)
1242             xmlFree(style-&gt;method);
1243         style-&gt;method = NULL;
1244         if (style-&gt;methodURI != NULL)
1245             xmlFree(style-&gt;methodURI);
1246         style-&gt;methodURI = NULL;
1247 
1248     /*
1249     * TODO: Don&#39;t use xsltGetQNameURI().
1250     */
1251     URI = xsltGetQNameURI(cur, &amp;prop);
1252     if (prop == NULL) {
1253         if (style != NULL) style-&gt;errors++;
1254     } else if (URI == NULL) {
1255             if ((xmlStrEqual(prop, (const xmlChar *) &quot;xml&quot;)) ||
1256                 (xmlStrEqual(prop, (const xmlChar *) &quot;html&quot;)) ||
1257                 (xmlStrEqual(prop, (const xmlChar *) &quot;text&quot;))) {
1258                 style-&gt;method = prop;
1259             } else {
1260         xsltTransformError(NULL, style, cur,
1261                                  &quot;invalid value for method: %s\n&quot;, prop);
1262                 if (style != NULL) style-&gt;warnings++;
1263                 xmlFree(prop);
1264             }
1265     } else {
1266         style-&gt;method = prop;
1267         style-&gt;methodURI = xmlStrdup(URI);
1268     }
1269     }
1270 
1271     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;doctype-system&quot;, NULL);
1272     if (prop != NULL) {
1273         if (style-&gt;doctypeSystem != NULL)
1274             xmlFree(style-&gt;doctypeSystem);
1275         style-&gt;doctypeSystem = prop;
1276     }
1277 
1278     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;doctype-public&quot;, NULL);
1279     if (prop != NULL) {
1280         if (style-&gt;doctypePublic != NULL)
1281             xmlFree(style-&gt;doctypePublic);
1282         style-&gt;doctypePublic = prop;
1283     }
1284 
1285     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;standalone&quot;, NULL);
1286     if (prop != NULL) {
1287         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1288             style-&gt;standalone = 1;
1289         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1290             style-&gt;standalone = 0;
1291         } else {
1292         xsltTransformError(NULL, style, cur,
1293                              &quot;invalid value for standalone: %s\n&quot;, prop);
1294             style-&gt;errors++;
1295         }
1296         xmlFree(prop);
1297     }
1298 
1299     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;indent&quot;, NULL);
1300     if (prop != NULL) {
1301         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1302             style-&gt;indent = 1;
1303         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1304             style-&gt;indent = 0;
1305         } else {
1306         xsltTransformError(NULL, style, cur,
1307                              &quot;invalid value for indent: %s\n&quot;, prop);
1308             style-&gt;errors++;
1309         }
1310         xmlFree(prop);
1311     }
1312 
1313     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;omit-xml-declaration&quot;, NULL);
1314     if (prop != NULL) {
1315         if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
1316             style-&gt;omitXmlDeclaration = 1;
1317         } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
1318             style-&gt;omitXmlDeclaration = 0;
1319         } else {
1320         xsltTransformError(NULL, style, cur,
1321                              &quot;invalid value for omit-xml-declaration: %s\n&quot;,
1322                              prop);
1323             style-&gt;errors++;
1324         }
1325         xmlFree(prop);
1326     }
1327 
1328     elements = xmlGetNsProp(cur, (const xmlChar *) &quot;cdata-section-elements&quot;,
1329     NULL);
1330     if (elements != NULL) {
1331         if (style-&gt;cdataSection == NULL)
1332             style-&gt;cdataSection = xmlHashCreate(10);
1333         if (style-&gt;cdataSection == NULL)
1334             return;
1335 
1336         element = elements;
1337         while (*element != 0) {
1338             while (IS_BLANK(*element))
1339                 element++;
1340             if (*element == 0)
1341                 break;
1342             end = element;
1343             while ((*end != 0) &amp;&amp; (!IS_BLANK(*end)))
1344                 end++;
1345             element = xmlStrndup(element, end - element);
1346             if (element) {
1347 #ifdef WITH_XSLT_DEBUG_PARSING
1348                 xsltGenericDebug(xsltGenericDebugContext,
1349                                  &quot;add cdata section output element %s\n&quot;,
1350                                  element);
1351 #endif
1352         if (xmlValidateQName(BAD_CAST element, 0) != 0) {
1353             xsltTransformError(NULL, style, cur,
1354             &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;
1355             &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);
1356             xmlFree(element);
1357             style-&gt;errors++;
1358         } else {
1359             const xmlChar *URI;
1360 
1361             /*
1362             * TODO: Don&#39;t use xsltGetQNameURI().
1363             */
1364             URI = xsltGetQNameURI(cur, &amp;element);
1365             if (element == NULL) {
1366             /*
1367             * TODO: We&#39;ll report additionally an error
1368             *  via the stylesheet&#39;s error handling.
1369             */
1370             xsltTransformError(NULL, style, cur,
1371                 &quot;Attribute &#39;cdata-section-elements&#39;: &quot;
1372                 &quot;Not a valid QName.\n&quot;);
1373             style-&gt;errors++;
1374             } else {
1375             xmlNsPtr ns;
1376 
1377             /*
1378             * XSLT-1.0 &quot;Each QName is expanded into an
1379             *  expanded-name using the namespace declarations in
1380             *  effect on the xsl:output element in which the QName
1381             *  occurs; if there is a default namespace, it is used
1382             *  for QNames that do not have a prefix&quot;
1383             * NOTE: Fix of bug #339570.
1384             */
1385             if (URI == NULL) {
1386                 ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1387                 if (ns != NULL)
1388                 URI = ns-&gt;href;
1389             }
1390             xmlHashAddEntry2(style-&gt;cdataSection, element, URI,
1391                 (void *) &quot;cdata&quot;);
1392             xmlFree(element);
1393             }
1394         }
1395             }
1396             element = end;
1397         }
1398         xmlFree(elements);
1399     }
1400 
1401     prop = xmlGetNsProp(cur, (const xmlChar *) &quot;media-type&quot;, NULL);
1402     if (prop != NULL) {
1403     if (style-&gt;mediaType)
1404         xmlFree(style-&gt;mediaType);
1405     style-&gt;mediaType = prop;
1406     }
1407     if (cur-&gt;children != NULL) {
1408     xsltParseContentError(style, cur-&gt;children);
1409     }
1410 }
1411 
1412 /**
1413  * xsltParseStylesheetDecimalFormat:
1414  * @style:  the XSLT stylesheet
1415  * @cur:  the &quot;decimal-format&quot; element
1416  *
1417  * &lt;!-- Category: top-level-element --&gt;
1418  * &lt;xsl:decimal-format
1419  *   name = qname, decimal-separator = char, grouping-separator = char,
1420  *   infinity = string, minus-sign = char, NaN = string, percent = char
1421  *   per-mille = char, zero-digit = char, digit = char,
1422  * pattern-separator = char /&gt;
1423  *
1424  * parse an XSLT stylesheet decimal-format element and
1425  * and record the formatting characteristics
1426  */
1427 static void
1428 xsltParseStylesheetDecimalFormat(xsltStylesheetPtr style, xmlNodePtr cur)
1429 {
1430     xmlChar *prop;
1431     xsltDecimalFormatPtr format;
1432     xsltDecimalFormatPtr iter;
1433 
1434     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1435     return;
1436 
1437     format = style-&gt;decimalFormat;
1438 
1439     prop = xmlGetNsProp(cur, BAD_CAST(&quot;name&quot;), NULL);
1440     if (prop != NULL) {
1441         const xmlChar *nsUri;
1442 
1443         if (xmlValidateQName(prop, 0) != 0) {
1444             xsltTransformError(NULL, style, cur,
1445                 &quot;xsl:decimal-format: Invalid QName &#39;%s&#39;.\n&quot;, prop);
1446         style-&gt;warnings++;
1447             xmlFree(prop);
1448             return;
1449         }
1450         /*
1451         * TODO: Don&#39;t use xsltGetQNameURI().
1452         */
1453         nsUri = xsltGetQNameURI(cur, &amp;prop);
1454         if (prop == NULL) {
1455         style-&gt;warnings++;
1456             return;
1457         }
1458     format = xsltDecimalFormatGetByQName(style, nsUri, prop);
1459     if (format != NULL) {
1460         xsltTransformError(NULL, style, cur,
1461      &quot;xsltParseStylestyleDecimalFormat: %s already exists\n&quot;, prop);
1462         style-&gt;warnings++;
1463             xmlFree(prop);
1464         return;
1465     }
1466     format = xsltNewDecimalFormat(nsUri, prop);
1467     if (format == NULL) {
1468         xsltTransformError(NULL, style, cur,
1469      &quot;xsltParseStylestyleDecimalFormat: failed creating new decimal-format\n&quot;);
1470         style-&gt;errors++;
1471             xmlFree(prop);
1472         return;
1473     }
1474     /* Append new decimal-format structure */
1475     for (iter = style-&gt;decimalFormat; iter-&gt;next; iter = iter-&gt;next)
1476         ;
1477     if (iter)
1478         iter-&gt;next = format;
1479     }
1480 
1481     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;decimal-separator&quot;, NULL);
1482     if (prop != NULL) {
1483     if (format-&gt;decimalPoint != NULL) xmlFree(format-&gt;decimalPoint);
1484     format-&gt;decimalPoint  = prop;
1485     }
1486 
1487     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;grouping-separator&quot;, NULL);
1488     if (prop != NULL) {
1489     if (format-&gt;grouping != NULL) xmlFree(format-&gt;grouping);
1490     format-&gt;grouping  = prop;
1491     }
1492 
1493     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;infinity&quot;, NULL);
1494     if (prop != NULL) {
1495     if (format-&gt;infinity != NULL) xmlFree(format-&gt;infinity);
1496     format-&gt;infinity  = prop;
1497     }
1498 
1499     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;minus-sign&quot;, NULL);
1500     if (prop != NULL) {
1501     if (format-&gt;minusSign != NULL) xmlFree(format-&gt;minusSign);
1502     format-&gt;minusSign  = prop;
1503     }
1504 
1505     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;NaN&quot;, NULL);
1506     if (prop != NULL) {
1507     if (format-&gt;noNumber != NULL) xmlFree(format-&gt;noNumber);
1508     format-&gt;noNumber  = prop;
1509     }
1510 
1511     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;percent&quot;, NULL);
1512     if (prop != NULL) {
1513     if (format-&gt;percent != NULL) xmlFree(format-&gt;percent);
1514     format-&gt;percent  = prop;
1515     }
1516 
1517     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;per-mille&quot;, NULL);
1518     if (prop != NULL) {
1519     if (format-&gt;permille != NULL) xmlFree(format-&gt;permille);
1520     format-&gt;permille  = prop;
1521     }
1522 
1523     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;zero-digit&quot;, NULL);
1524     if (prop != NULL) {
1525     if (format-&gt;zeroDigit != NULL) xmlFree(format-&gt;zeroDigit);
1526     format-&gt;zeroDigit  = prop;
1527     }
1528 
1529     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;digit&quot;, NULL);
1530     if (prop != NULL) {
1531     if (format-&gt;digit != NULL) xmlFree(format-&gt;digit);
1532     format-&gt;digit  = prop;
1533     }
1534 
1535     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;pattern-separator&quot;, NULL);
1536     if (prop != NULL) {
1537     if (format-&gt;patternSeparator != NULL) xmlFree(format-&gt;patternSeparator);
1538     format-&gt;patternSeparator  = prop;
1539     }
1540     if (cur-&gt;children != NULL) {
1541     xsltParseContentError(style, cur-&gt;children);
1542     }
1543 }
1544 
1545 /**
1546  * xsltParseStylesheetPreserveSpace:
1547  * @style:  the XSLT stylesheet
1548  * @cur:  the &quot;preserve-space&quot; element
1549  *
1550  * parse an XSLT stylesheet preserve-space element and record
1551  * elements needing preserving
1552  */
1553 
1554 static void
1555 xsltParseStylesheetPreserveSpace(xsltStylesheetPtr style, xmlNodePtr cur) {
1556     xmlChar *elements;
1557     xmlChar *element, *end;
1558 
1559     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1560     return;
1561 
1562     elements = xmlGetNsProp(cur, (const xmlChar *)&quot;elements&quot;, NULL);
1563     if (elements == NULL) {
1564     xsltTransformError(NULL, style, cur,
1565         &quot;xsltParseStylesheetPreserveSpace: missing elements attribute\n&quot;);
1566     if (style != NULL) style-&gt;warnings++;
1567     return;
1568     }
1569 
1570     if (style-&gt;stripSpaces == NULL)
1571     style-&gt;stripSpaces = xmlHashCreate(10);
1572     if (style-&gt;stripSpaces == NULL)
1573     return;
1574 
1575     element = elements;
1576     while (*element != 0) {
1577     while (IS_BLANK(*element)) element++;
1578     if (*element == 0)
1579         break;
1580         end = element;
1581     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1582     element = xmlStrndup(element, end - element);
1583     if (element) {
1584 #ifdef WITH_XSLT_DEBUG_PARSING
1585         xsltGenericDebug(xsltGenericDebugContext,
1586         &quot;add preserved space element %s\n&quot;, element);
1587 #endif
1588         if (xmlStrEqual(element, (const xmlChar *)&quot;*&quot;)) {
1589         style-&gt;stripAll = -1;
1590         } else {
1591         const xmlChar *URI;
1592 
1593         /*
1594         * TODO: Don&#39;t use xsltGetQNameURI().
1595         */
1596                 URI = xsltGetQNameURI(cur, &amp;element);
1597 
1598         xmlHashAddEntry2(style-&gt;stripSpaces, element, URI,
1599                 (xmlChar *) &quot;preserve&quot;);
1600         }
1601         xmlFree(element);
1602     }
1603     element = end;
1604     }
1605     xmlFree(elements);
1606     if (cur-&gt;children != NULL) {
1607     xsltParseContentError(style, cur-&gt;children);
1608     }
1609 }
1610 
1611 #ifdef XSLT_REFACTORED
1612 #else
1613 /**
1614  * xsltParseStylesheetExtPrefix:
1615  * @style:  the XSLT stylesheet
1616  * @template:  the &quot;extension-element-prefixes&quot; prefix
1617  *
1618  * parse an XSLT stylesheet&#39;s &quot;extension-element-prefix&quot; attribute value
1619  * and register the namespaces of extension instruction.
1620  * SPEC &quot;A namespace is designated as an extension namespace by using
1621  *   an extension-element-prefixes attribute on:
1622  *   1) an xsl:stylesheet element
1623  *   2) an xsl:extension-element-prefixes attribute on a
1624  *      literal result element
1625  *   3) an extension instruction.&quot;
1626  */
1627 static void
1628 xsltParseStylesheetExtPrefix(xsltStylesheetPtr style, xmlNodePtr cur,
1629                  int isXsltElem) {
1630     xmlChar *prefixes;
1631     xmlChar *prefix, *end;
1632 
1633     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1634     return;
1635 
1636     if (isXsltElem) {
1637     /* For xsl:stylesheet/xsl:transform. */
1638     prefixes = xmlGetNsProp(cur,
1639         (const xmlChar *)&quot;extension-element-prefixes&quot;, NULL);
1640     } else {
1641     /* For literal result elements and extension instructions. */
1642     prefixes = xmlGetNsProp(cur,
1643         (const xmlChar *)&quot;extension-element-prefixes&quot;, XSLT_NAMESPACE);
1644     }
1645     if (prefixes == NULL) {
1646     return;
1647     }
1648 
1649     prefix = prefixes;
1650     while (*prefix != 0) {
1651     while (IS_BLANK(*prefix)) prefix++;
1652     if (*prefix == 0)
1653         break;
1654         end = prefix;
1655     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1656     prefix = xmlStrndup(prefix, end - prefix);
1657     if (prefix) {
1658         xmlNsPtr ns;
1659 
1660         if (xmlStrEqual(prefix, (const xmlChar *)&quot;#default&quot;))
1661         ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1662         else
1663         ns = xmlSearchNs(style-&gt;doc, cur, prefix);
1664         if (ns == NULL) {
1665         xsltTransformError(NULL, style, cur,
1666         &quot;xsl:extension-element-prefix : undefined namespace %s\n&quot;,
1667                              prefix);
1668         if (style != NULL) style-&gt;warnings++;
1669         } else {
1670 #ifdef WITH_XSLT_DEBUG_PARSING
1671         xsltGenericDebug(xsltGenericDebugContext,
1672             &quot;add extension prefix %s\n&quot;, prefix);
1673 #endif
1674         xsltRegisterExtPrefix(style, prefix, ns-&gt;href);
1675         }
1676         xmlFree(prefix);
1677     }
1678     prefix = end;
1679     }
1680     xmlFree(prefixes);
1681 }
1682 #endif /* else of XSLT_REFACTORED */
1683 
1684 /**
1685  * xsltParseStylesheetStripSpace:
1686  * @style:  the XSLT stylesheet
1687  * @cur:  the &quot;strip-space&quot; element
1688  *
1689  * parse an XSLT stylesheet&#39;s strip-space element and record
1690  * the elements needing stripping
1691  */
1692 
1693 static void
1694 xsltParseStylesheetStripSpace(xsltStylesheetPtr style, xmlNodePtr cur) {
1695     xmlChar *elements;
1696     xmlChar *element, *end;
1697 
1698     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1699     return;
1700 
1701     elements = xmlGetNsProp(cur, (const xmlChar *)&quot;elements&quot;, NULL);
1702     if (elements == NULL) {
1703     xsltTransformError(NULL, style, cur,
1704         &quot;xsltParseStylesheetStripSpace: missing elements attribute\n&quot;);
1705     if (style != NULL) style-&gt;warnings++;
1706     return;
1707     }
1708 
1709     if (style-&gt;stripSpaces == NULL)
1710     style-&gt;stripSpaces = xmlHashCreate(10);
1711     if (style-&gt;stripSpaces == NULL)
1712     return;
1713 
1714     element = elements;
1715     while (*element != 0) {
1716     while (IS_BLANK(*element)) element++;
1717     if (*element == 0)
1718         break;
1719         end = element;
1720     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1721     element = xmlStrndup(element, end - element);
1722     if (element) {
1723 #ifdef WITH_XSLT_DEBUG_PARSING
1724         xsltGenericDebug(xsltGenericDebugContext,
1725         &quot;add stripped space element %s\n&quot;, element);
1726 #endif
1727         if (xmlStrEqual(element, (const xmlChar *)&quot;*&quot;)) {
1728         style-&gt;stripAll = 1;
1729         } else {
1730         const xmlChar *URI;
1731 
1732         /*
1733         * TODO: Don&#39;t use xsltGetQNameURI().
1734         */
1735                 URI = xsltGetQNameURI(cur, &amp;element);
1736 
1737         xmlHashAddEntry2(style-&gt;stripSpaces, element, URI,
1738                     (xmlChar *) &quot;strip&quot;);
1739         }
1740         xmlFree(element);
1741     }
1742     element = end;
1743     }
1744     xmlFree(elements);
1745     if (cur-&gt;children != NULL) {
1746     xsltParseContentError(style, cur-&gt;children);
1747     }
1748 }
1749 
1750 #ifdef XSLT_REFACTORED
1751 #else
1752 /**
1753  * xsltParseStylesheetExcludePrefix:
1754  * @style:  the XSLT stylesheet
1755  * @cur:  the current point in the stylesheet
1756  *
1757  * parse an XSLT stylesheet exclude prefix and record
1758  * namespaces needing stripping
1759  *
1760  * Returns the number of Excluded prefixes added at that level
1761  */
1762 
1763 static int
1764 xsltParseStylesheetExcludePrefix(xsltStylesheetPtr style, xmlNodePtr cur,
1765                  int isXsltElem)
1766 {
1767     int nb = 0;
1768     xmlChar *prefixes;
1769     xmlChar *prefix, *end;
1770 
1771     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1772     return(0);
1773 
1774     if (isXsltElem)
1775     prefixes = xmlGetNsProp(cur,
1776         (const xmlChar *)&quot;exclude-result-prefixes&quot;, NULL);
1777     else
1778     prefixes = xmlGetNsProp(cur,
1779         (const xmlChar *)&quot;exclude-result-prefixes&quot;, XSLT_NAMESPACE);
1780 
1781     if (prefixes == NULL) {
1782     return(0);
1783     }
1784 
1785     prefix = prefixes;
1786     while (*prefix != 0) {
1787     while (IS_BLANK(*prefix)) prefix++;
1788     if (*prefix == 0)
1789         break;
1790         end = prefix;
1791     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
1792     prefix = xmlStrndup(prefix, end - prefix);
1793     if (prefix) {
1794         xmlNsPtr ns;
1795 
1796         if (xmlStrEqual(prefix, (const xmlChar *)&quot;#default&quot;))
1797         ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1798         else
1799         ns = xmlSearchNs(style-&gt;doc, cur, prefix);
1800         if (ns == NULL) {
1801         xsltTransformError(NULL, style, cur,
1802         &quot;xsl:exclude-result-prefixes : undefined namespace %s\n&quot;,
1803                              prefix);
1804         if (style != NULL) style-&gt;warnings++;
1805         } else {
1806         if (exclPrefixPush(style, (xmlChar *) ns-&gt;href) &gt;= 0) {
1807 #ifdef WITH_XSLT_DEBUG_PARSING
1808             xsltGenericDebug(xsltGenericDebugContext,
1809             &quot;exclude result prefix %s\n&quot;, prefix);
1810 #endif
1811             nb++;
1812         }
1813         }
1814         xmlFree(prefix);
1815     }
1816     prefix = end;
1817     }
1818     xmlFree(prefixes);
1819     return(nb);
1820 }
1821 #endif /* else of XSLT_REFACTORED */
1822 
1823 #ifdef XSLT_REFACTORED
1824 
1825 /*
1826 * xsltTreeEnsureXMLDecl:
1827 * @doc: the doc
1828 *
1829 * BIG NOTE:
1830 *  This was copy&amp;pasted from Libxml2&#39;s xmlTreeEnsureXMLDecl() in &quot;tree.c&quot;.
1831 * Ensures that there is an XML namespace declaration on the doc.
1832 *
1833 * Returns the XML ns-struct or NULL on API and internal errors.
1834 */
1835 static xmlNsPtr
1836 xsltTreeEnsureXMLDecl(xmlDocPtr doc)
1837 {
1838     if (doc == NULL)
1839     return (NULL);
1840     if (doc-&gt;oldNs != NULL)
1841     return (doc-&gt;oldNs);
1842     {
1843     xmlNsPtr ns;
1844     ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
1845     if (ns == NULL) {
1846         xmlGenericError(xmlGenericErrorContext,
1847         &quot;xsltTreeEnsureXMLDecl: Failed to allocate &quot;
1848         &quot;the XML namespace.\n&quot;);
1849         return (NULL);
1850     }
1851     memset(ns, 0, sizeof(xmlNs));
1852     ns-&gt;type = XML_LOCAL_NAMESPACE;
1853     /*
1854     * URGENT TODO: revisit this.
1855     */
1856 #ifdef LIBXML_NAMESPACE_DICT
1857     if (doc-&gt;dict)
1858         ns-&gt;href = xmlDictLookup(doc-&gt;dict, XML_XML_NAMESPACE, -1);
1859     else
1860         ns-&gt;href = xmlStrdup(XML_XML_NAMESPACE);
1861 #else
1862     ns-&gt;href = xmlStrdup(XML_XML_NAMESPACE);
1863 #endif
1864     ns-&gt;prefix = xmlStrdup((const xmlChar *)&quot;xml&quot;);
1865     doc-&gt;oldNs = ns;
1866     return (ns);
1867     }
1868 }
1869 
1870 /*
1871 * xsltTreeAcquireStoredNs:
1872 * @doc: the doc
1873 * @nsName: the namespace name
1874 * @prefix: the prefix
1875 *
1876 * BIG NOTE:
1877 *  This was copy&amp;pasted from Libxml2&#39;s xmlDOMWrapStoreNs() in &quot;tree.c&quot;.
1878 * Creates or reuses an xmlNs struct on doc-&gt;oldNs with
1879 * the given prefix and namespace name.
1880 *
1881 * Returns the aquired ns struct or NULL in case of an API
1882 *         or internal error.
1883 */
1884 static xmlNsPtr
1885 xsltTreeAcquireStoredNs(xmlDocPtr doc,
1886             const xmlChar *nsName,
1887             const xmlChar *prefix)
1888 {
1889     xmlNsPtr ns;
1890 
1891     if (doc == NULL)
1892     return (NULL);
1893     if (doc-&gt;oldNs != NULL)
1894     ns = doc-&gt;oldNs;
1895     else
1896     ns = xsltTreeEnsureXMLDecl(doc);
1897     if (ns == NULL)
1898     return (NULL);
1899     if (ns-&gt;next != NULL) {
1900     /* Reuse. */
1901     ns = ns-&gt;next;
1902     while (ns != NULL) {
1903         if ((ns-&gt;prefix == NULL) != (prefix == NULL)) {
1904         /* NOP */
1905         } else if (prefix == NULL) {
1906         if (xmlStrEqual(ns-&gt;href, nsName))
1907             return (ns);
1908         } else {
1909         if ((ns-&gt;prefix[0] == prefix[0]) &amp;&amp;
1910              xmlStrEqual(ns-&gt;prefix, prefix) &amp;&amp;
1911              xmlStrEqual(ns-&gt;href, nsName))
1912             return (ns);
1913 
1914         }
1915         if (ns-&gt;next == NULL)
1916         break;
1917         ns = ns-&gt;next;
1918     }
1919     }
1920     /* Create. */
1921     ns-&gt;next = xmlNewNs(NULL, nsName, prefix);
1922     return (ns-&gt;next);
1923 }
1924 
1925 /**
1926  * xsltLREBuildEffectiveNs:
1927  *
1928  * Apply ns-aliasing on the namespace of the given @elem and
1929  * its attributes.
1930  */
1931 static int
1932 xsltLREBuildEffectiveNs(xsltCompilerCtxtPtr cctxt,
1933             xmlNodePtr elem)
1934 {
1935     xmlNsPtr ns;
1936     xsltNsAliasPtr alias;
1937 
1938     if ((cctxt == NULL) || (elem == NULL))
1939     return(-1);
1940     if ((cctxt-&gt;nsAliases == NULL) || (! cctxt-&gt;hasNsAliases))
1941     return(0);
1942 
1943     alias = cctxt-&gt;nsAliases;
1944     while (alias != NULL) {
1945     if ( /* If both namespaces are NULL... */
1946         ( (elem-&gt;ns == NULL) &amp;&amp;
1947         ((alias-&gt;literalNs == NULL) ||
1948         (alias-&gt;literalNs-&gt;href == NULL)) ) ||
1949         /* ... or both namespace are equal */
1950         ( (elem-&gt;ns != NULL) &amp;&amp;
1951         (alias-&gt;literalNs != NULL) &amp;&amp;
1952         xmlStrEqual(elem-&gt;ns-&gt;href, alias-&gt;literalNs-&gt;href) ) )
1953     {
1954         if ((alias-&gt;targetNs != NULL) &amp;&amp;
1955         (alias-&gt;targetNs-&gt;href != NULL))
1956         {
1957         /*
1958         * Convert namespace.
1959         */
1960         if (elem-&gt;doc == alias-&gt;docOfTargetNs) {
1961             /*
1962             * This is the nice case: same docs.
1963             * This will eventually assign a ns-decl which
1964             * is shadowed, but this has no negative effect on
1965             * the generation of the result tree.
1966             */
1967             elem-&gt;ns = alias-&gt;targetNs;
1968         } else {
1969             /*
1970             * This target xmlNs originates from a different
1971             * stylesheet tree. Try to locate it in the
1972             * in-scope namespaces.
1973             * OPTIMIZE TODO: Use the compiler-node-info inScopeNs.
1974             */
1975             ns = xmlSearchNs(elem-&gt;doc, elem,
1976             alias-&gt;targetNs-&gt;prefix);
1977             /*
1978             * If no matching ns-decl found, then assign a
1979             * ns-decl stored in xmlDoc.
1980             */
1981             if ((ns == NULL) ||
1982             (! xmlStrEqual(ns-&gt;href, alias-&gt;targetNs-&gt;href)))
1983             {
1984             /*
1985             * BIG NOTE: The use of xsltTreeAcquireStoredNs()
1986             *  is not very efficient, but currently I don&#39;t
1987             *  see an other way of *safely* changing a node&#39;s
1988             *  namespace, since the xmlNs struct in
1989             *  alias-&gt;targetNs might come from an other
1990             *  stylesheet tree. So we need to anchor it in the
1991             *  current document, without adding it to the tree,
1992             *  which would otherwise change the in-scope-ns
1993             *  semantic of the tree.
1994             */
1995             ns = xsltTreeAcquireStoredNs(elem-&gt;doc,
1996                 alias-&gt;targetNs-&gt;href,
1997                 alias-&gt;targetNs-&gt;prefix);
1998 
1999             if (ns == NULL) {
2000                 xsltTransformError(NULL, cctxt-&gt;style, elem,
2001                 &quot;Internal error in &quot;
2002                 &quot;xsltLREBuildEffectiveNs(): &quot;
2003                 &quot;failed to acquire a stored &quot;
2004                 &quot;ns-declaration.\n&quot;);
2005                 cctxt-&gt;style-&gt;errors++;
2006                 return(-1);
2007 
2008             }
2009             }
2010             elem-&gt;ns = ns;
2011         }
2012         } else {
2013         /*
2014         * Move into or leave in the NULL namespace.
2015         */
2016         elem-&gt;ns = NULL;
2017         }
2018         break;
2019     }
2020     alias = alias-&gt;next;
2021     }
2022     /*
2023     * Same with attributes of literal result elements.
2024     */
2025     if (elem-&gt;properties != NULL) {
2026     xmlAttrPtr attr = elem-&gt;properties;
2027 
2028     while (attr != NULL) {
2029         if (attr-&gt;ns == NULL) {
2030         attr = attr-&gt;next;
2031         continue;
2032         }
2033         alias = cctxt-&gt;nsAliases;
2034         while (alias != NULL) {
2035         if ( /* If both namespaces are NULL... */
2036             ( (elem-&gt;ns == NULL) &amp;&amp;
2037             ((alias-&gt;literalNs == NULL) ||
2038             (alias-&gt;literalNs-&gt;href == NULL)) ) ||
2039             /* ... or both namespace are equal */
2040             ( (elem-&gt;ns != NULL) &amp;&amp;
2041             (alias-&gt;literalNs != NULL) &amp;&amp;
2042             xmlStrEqual(elem-&gt;ns-&gt;href, alias-&gt;literalNs-&gt;href) ) )
2043         {
2044             if ((alias-&gt;targetNs != NULL) &amp;&amp;
2045             (alias-&gt;targetNs-&gt;href != NULL))
2046             {
2047             if (elem-&gt;doc == alias-&gt;docOfTargetNs) {
2048                 elem-&gt;ns = alias-&gt;targetNs;
2049             } else {
2050                 ns = xmlSearchNs(elem-&gt;doc, elem,
2051                 alias-&gt;targetNs-&gt;prefix);
2052                 if ((ns == NULL) ||
2053                 (! xmlStrEqual(ns-&gt;href, alias-&gt;targetNs-&gt;href)))
2054                 {
2055                 ns = xsltTreeAcquireStoredNs(elem-&gt;doc,
2056                     alias-&gt;targetNs-&gt;href,
2057                     alias-&gt;targetNs-&gt;prefix);
2058 
2059                 if (ns == NULL) {
2060                     xsltTransformError(NULL, cctxt-&gt;style, elem,
2061                     &quot;Internal error in &quot;
2062                     &quot;xsltLREBuildEffectiveNs(): &quot;
2063                     &quot;failed to acquire a stored &quot;
2064                     &quot;ns-declaration.\n&quot;);
2065                     cctxt-&gt;style-&gt;errors++;
2066                     return(-1);
2067 
2068                 }
2069                 }
2070                 elem-&gt;ns = ns;
2071             }
2072             } else {
2073             /*
2074             * Move into or leave in the NULL namespace.
2075             */
2076             elem-&gt;ns = NULL;
2077             }
2078             break;
2079         }
2080         alias = alias-&gt;next;
2081         }
2082 
2083         attr = attr-&gt;next;
2084     }
2085     }
2086     return(0);
2087 }
2088 
2089 /**
2090  * xsltLREBuildEffectiveNsNodes:
2091  *
2092  * Computes the effective namespaces nodes for a literal result
2093  * element.
2094  * @effectiveNs is the set of effective ns-nodes
2095  *  on the literal result element, which will be added to the result
2096  *  element if not already existing in the result tree.
2097  *  This means that excluded namespaces (via exclude-result-prefixes,
2098  *  extension-element-prefixes and the XSLT namespace) not added
2099  *  to the set.
2100  *  Namespace-aliasing was applied on the @effectiveNs.
2101  */
2102 static int
2103 xsltLREBuildEffectiveNsNodes(xsltCompilerCtxtPtr cctxt,
2104                  xsltStyleItemLRElementInfoPtr item,
2105                  xmlNodePtr elem,
2106                  int isLRE)
2107 {
2108     xmlNsPtr ns, tmpns;
2109     xsltEffectiveNsPtr effNs, lastEffNs = NULL;
2110     int i, j, holdByElem;
2111     xsltPointerListPtr extElemNs = cctxt-&gt;inode-&gt;extElemNs;
2112     xsltPointerListPtr exclResultNs = cctxt-&gt;inode-&gt;exclResultNs;
2113 
2114     if ((cctxt == NULL) || (cctxt-&gt;inode == NULL) || (elem == NULL) ||
2115     (item == NULL) || (item-&gt;effectiveNs != NULL))
2116     return(-1);
2117 
2118     if (item-&gt;inScopeNs == NULL)
2119     return(0);
2120 
2121     extElemNs = cctxt-&gt;inode-&gt;extElemNs;
2122     exclResultNs = cctxt-&gt;inode-&gt;exclResultNs;
2123 
2124     for (i = 0; i &lt; item-&gt;inScopeNs-&gt;totalNumber; i++) {
2125     ns = item-&gt;inScopeNs-&gt;list[i];
2126     /*
2127     * Skip namespaces designated as excluded namespaces
2128     * -------------------------------------------------
2129     *
2130     * XSLT-20 TODO: In XSLT 2.0 we need to keep namespaces
2131     *  which are target namespaces of namespace-aliases
2132     *  regardless if designated as excluded.
2133     *
2134     * Exclude the XSLT namespace.
2135     */
2136     if (xmlStrEqual(ns-&gt;href, XSLT_NAMESPACE))
2137         goto skip_ns;
2138 
2139     /*
2140     * Apply namespace aliasing
2141     * ------------------------
2142     *
2143     * SPEC XSLT 2.0
2144     *  &quot;- A namespace node whose string value is a literal namespace
2145     *     URI is not copied to the result tree.
2146     *   - A namespace node whose string value is a target namespace URI
2147     *     is copied to the result tree, whether or not the URI
2148     *     identifies an excluded namespace.&quot;
2149     *
2150     * NOTE: The ns-aliasing machanism is non-cascading.
2151     *  (checked with Saxon, Xalan and MSXML .NET).
2152     * URGENT TODO: is style-&gt;nsAliases the effective list of
2153     *  ns-aliases, or do we need to lookup the whole
2154     *  import-tree?
2155     * TODO: Get rid of import-tree lookup.
2156     */
2157     if (cctxt-&gt;hasNsAliases) {
2158         xsltNsAliasPtr alias;
2159         /*
2160         * First check for being a target namespace.
2161         */
2162         alias = cctxt-&gt;nsAliases;
2163         do {
2164         /*
2165         * TODO: Is xmlns=&quot;&quot; handled already?
2166         */
2167         if ((alias-&gt;targetNs != NULL) &amp;&amp;
2168             (xmlStrEqual(alias-&gt;targetNs-&gt;href, ns-&gt;href)))
2169         {
2170             /*
2171             * Recognized as a target namespace; use it regardless
2172             * if excluded otherwise.
2173             */
2174             goto add_effective_ns;
2175         }
2176         alias = alias-&gt;next;
2177         } while (alias != NULL);
2178 
2179         alias = cctxt-&gt;nsAliases;
2180         do {
2181         /*
2182         * TODO: Is xmlns=&quot;&quot; handled already?
2183         */
2184         if ((alias-&gt;literalNs != NULL) &amp;&amp;
2185             (xmlStrEqual(alias-&gt;literalNs-&gt;href, ns-&gt;href)))
2186         {
2187             /*
2188             * Recognized as an namespace alias; do not use it.
2189             */
2190             goto skip_ns;
2191         }
2192         alias = alias-&gt;next;
2193         } while (alias != NULL);
2194     }
2195 
2196     /*
2197     * Exclude excluded result namespaces.
2198     */
2199     if (exclResultNs) {
2200         for (j = 0; j &lt; exclResultNs-&gt;number; j++)
2201         if (xmlStrEqual(ns-&gt;href, BAD_CAST exclResultNs-&gt;items[j]))
2202             goto skip_ns;
2203     }
2204     /*
2205     * Exclude extension-element namespaces.
2206     */
2207     if (extElemNs) {
2208         for (j = 0; j &lt; extElemNs-&gt;number; j++)
2209         if (xmlStrEqual(ns-&gt;href, BAD_CAST extElemNs-&gt;items[j]))
2210             goto skip_ns;
2211     }
2212 
2213 add_effective_ns:
2214     /*
2215     * OPTIMIZE TODO: This information may not be needed.
2216     */
2217     if (isLRE &amp;&amp; (elem-&gt;nsDef != NULL)) {
2218         holdByElem = 0;
2219         tmpns = elem-&gt;nsDef;
2220         do {
2221         if (tmpns == ns) {
2222             holdByElem = 1;
2223             break;
2224         }
2225         tmpns = tmpns-&gt;next;
2226         } while (tmpns != NULL);
2227     } else
2228         holdByElem = 0;
2229 
2230 
2231     /*
2232     * Add the effective namespace declaration.
2233     */
2234     effNs = (xsltEffectiveNsPtr) xmlMalloc(sizeof(xsltEffectiveNs));
2235     if (effNs == NULL) {
2236         xsltTransformError(NULL, cctxt-&gt;style, elem,
2237         &quot;Internal error in xsltLREBuildEffectiveNs(): &quot;
2238         &quot;failed to allocate memory.\n&quot;);
2239         cctxt-&gt;style-&gt;errors++;
2240         return(-1);
2241     }
2242     if (cctxt-&gt;psData-&gt;effectiveNs == NULL) {
2243         cctxt-&gt;psData-&gt;effectiveNs = effNs;
2244         effNs-&gt;nextInStore = NULL;
2245     } else {
2246         effNs-&gt;nextInStore = cctxt-&gt;psData-&gt;effectiveNs;
2247         cctxt-&gt;psData-&gt;effectiveNs = effNs;
2248     }
2249 
2250     effNs-&gt;next = NULL;
2251     effNs-&gt;prefix = ns-&gt;prefix;
2252     effNs-&gt;nsName = ns-&gt;href;
2253     effNs-&gt;holdByElem = holdByElem;
2254 
2255     if (lastEffNs == NULL)
2256         item-&gt;effectiveNs = effNs;
2257     else
2258         lastEffNs-&gt;next = effNs;
2259     lastEffNs = effNs;
2260 
2261 skip_ns:
2262     {}
2263     }
2264     return(0);
2265 }
2266 
2267 
2268 /**
2269  * xsltLREInfoCreate:
2270  *
2271  * @isLRE: indicates if the given @elem is a literal result element
2272  *
2273  * Creates a new info for a literal result element.
2274  */
2275 static int
2276 xsltLREInfoCreate(xsltCompilerCtxtPtr cctxt,
2277           xmlNodePtr elem,
2278           int isLRE)
2279 {
2280     xsltStyleItemLRElementInfoPtr item;
2281 
2282     if ((cctxt == NULL) || (cctxt-&gt;inode == NULL))
2283     return(-1);
2284 
2285     item = (xsltStyleItemLRElementInfoPtr)
2286     xmlMalloc(sizeof(xsltStyleItemLRElementInfo));
2287     if (item == NULL) {
2288     xsltTransformError(NULL, cctxt-&gt;style, NULL,
2289         &quot;Internal error in xsltLREInfoCreate(): &quot;
2290         &quot;memory allocation failed.\n&quot;);
2291     cctxt-&gt;style-&gt;errors++;
2292     return(-1);
2293     }
2294     memset(item, 0, sizeof(xsltStyleItemLRElementInfo));
2295     item-&gt;type = XSLT_FUNC_LITERAL_RESULT_ELEMENT;
2296     /*
2297     * Store it in the stylesheet.
2298     */
2299     item-&gt;next = cctxt-&gt;style-&gt;preComps;
2300     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
2301     /*
2302     * @inScopeNs are used for execution of XPath expressions
2303     *  in AVTs.
2304     */
2305     item-&gt;inScopeNs = cctxt-&gt;inode-&gt;inScopeNs;
2306 
2307     if (elem)
2308     xsltLREBuildEffectiveNsNodes(cctxt, item, elem, isLRE);
2309 
2310     cctxt-&gt;inode-&gt;litResElemInfo = item;
2311     cctxt-&gt;inode-&gt;nsChanged = 0;
2312     cctxt-&gt;maxLREs++;
2313     return(0);
2314 }
2315 
2316 /**
2317  * xsltCompilerVarInfoPush:
2318  * @cctxt: the compilation context
2319  *
2320  * Pushes a new var/param info onto the stack.
2321  *
2322  * Returns the acquired variable info.
2323  */
2324 static xsltVarInfoPtr
2325 xsltCompilerVarInfoPush(xsltCompilerCtxtPtr cctxt,
2326                   xmlNodePtr inst,
2327                   const xmlChar *name,
2328                   const xmlChar *nsName)
2329 {
2330     xsltVarInfoPtr ivar;
2331 
2332     if ((cctxt-&gt;ivar != NULL) &amp;&amp; (cctxt-&gt;ivar-&gt;next != NULL)) {
2333     ivar = cctxt-&gt;ivar-&gt;next;
2334     } else if ((cctxt-&gt;ivar == NULL) &amp;&amp; (cctxt-&gt;ivars != NULL)) {
2335     ivar = cctxt-&gt;ivars;
2336     } else {
2337     ivar = (xsltVarInfoPtr) xmlMalloc(sizeof(xsltVarInfo));
2338     if (ivar == NULL) {
2339         xsltTransformError(NULL, cctxt-&gt;style, inst,
2340         &quot;xsltParseInScopeVarPush: xmlMalloc() failed!\n&quot;);
2341         cctxt-&gt;style-&gt;errors++;
2342         return(NULL);
2343     }
2344     /* memset(retVar, 0, sizeof(xsltInScopeVar)); */
2345     if (cctxt-&gt;ivars == NULL) {
2346         cctxt-&gt;ivars = ivar;
2347         ivar-&gt;prev = NULL;
2348     } else {
2349         cctxt-&gt;ivar-&gt;next = ivar;
2350         ivar-&gt;prev = cctxt-&gt;ivar;
2351     }
2352     cctxt-&gt;ivar = ivar;
2353     ivar-&gt;next = NULL;
2354     }
2355     ivar-&gt;depth = cctxt-&gt;depth;
2356     ivar-&gt;name = name;
2357     ivar-&gt;nsName = nsName;
2358     return(ivar);
2359 }
2360 
2361 /**
2362  * xsltCompilerVarInfoPop:
2363  * @cctxt: the compilation context
2364  *
2365  * Pops all var/param infos from the stack, which
2366  * have the current depth.
2367  */
2368 static void
2369 xsltCompilerVarInfoPop(xsltCompilerCtxtPtr cctxt)
2370 {
2371 
2372     while ((cctxt-&gt;ivar != NULL) &amp;&amp;
2373     (cctxt-&gt;ivar-&gt;depth &gt; cctxt-&gt;depth))
2374     {
2375     cctxt-&gt;ivar = cctxt-&gt;ivar-&gt;prev;
2376     }
2377 }
2378 
2379 /*
2380 * xsltCompilerNodePush:
2381 *
2382 * @cctxt: the compilation context
2383 * @node: the node to be pushed (this can also be the doc-node)
2384 *
2385 *
2386 *
2387 * Returns the current node info structure or
2388 *         NULL in case of an internal error.
2389 */
2390 static xsltCompilerNodeInfoPtr
2391 xsltCompilerNodePush(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2392 {
2393     xsltCompilerNodeInfoPtr inode, iprev;
2394 
2395     if ((cctxt-&gt;inode != NULL) &amp;&amp; (cctxt-&gt;inode-&gt;next != NULL)) {
2396     inode = cctxt-&gt;inode-&gt;next;
2397     } else if ((cctxt-&gt;inode == NULL) &amp;&amp; (cctxt-&gt;inodeList != NULL)) {
2398     inode = cctxt-&gt;inodeList;
2399     } else {
2400     /*
2401     * Create a new node-info.
2402     */
2403     inode = (xsltCompilerNodeInfoPtr)
2404         xmlMalloc(sizeof(xsltCompilerNodeInfo));
2405     if (inode == NULL) {
2406         xsltTransformError(NULL, cctxt-&gt;style, NULL,
2407         &quot;xsltCompilerNodePush: malloc failed.\n&quot;);
2408         return(NULL);
2409     }
2410     memset(inode, 0, sizeof(xsltCompilerNodeInfo));
2411     if (cctxt-&gt;inodeList == NULL)
2412         cctxt-&gt;inodeList = inode;
2413     else {
2414         cctxt-&gt;inodeLast-&gt;next = inode;
2415         inode-&gt;prev = cctxt-&gt;inodeLast;
2416     }
2417     cctxt-&gt;inodeLast = inode;
2418     cctxt-&gt;maxNodeInfos++;
2419     if (cctxt-&gt;inode == NULL) {
2420         cctxt-&gt;inode = inode;
2421         /*
2422         * Create an initial literal result element info for
2423         * the root of the stylesheet.
2424         */
2425         xsltLREInfoCreate(cctxt, NULL, 0);
2426     }
2427     }
2428     cctxt-&gt;depth++;
2429     cctxt-&gt;inode = inode;
2430     /*
2431     * REVISIT TODO: Keep the reset always complete.
2432     * NOTE: Be carefull with the @node, since it might be
2433     *  a doc-node.
2434     */
2435     inode-&gt;node = node;
2436     inode-&gt;depth = cctxt-&gt;depth;
2437     inode-&gt;templ = NULL;
2438     inode-&gt;category = XSLT_ELEMENT_CATEGORY_XSLT;
2439     inode-&gt;type = 0;
2440     inode-&gt;item = NULL;
2441     inode-&gt;curChildType = 0;
2442     inode-&gt;extContentHandled = 0;
2443     inode-&gt;isRoot = 0;
2444 
2445     if (inode-&gt;prev != NULL) {
2446     iprev = inode-&gt;prev;
2447     /*
2448     * Inherit the following information:
2449     * ---------------------------------
2450     *
2451     * In-scope namespaces
2452     */
2453     inode-&gt;inScopeNs = iprev-&gt;inScopeNs;
2454     /*
2455     * Info for literal result elements
2456     */
2457     inode-&gt;litResElemInfo = iprev-&gt;litResElemInfo;
2458     inode-&gt;nsChanged = iprev-&gt;nsChanged;
2459     /*
2460     * Excluded result namespaces
2461     */
2462     inode-&gt;exclResultNs = iprev-&gt;exclResultNs;
2463     /*
2464     * Extension instruction namespaces
2465     */
2466     inode-&gt;extElemNs = iprev-&gt;extElemNs;
2467     /*
2468     * Whitespace preservation
2469     */
2470     inode-&gt;preserveWhitespace = iprev-&gt;preserveWhitespace;
2471     /*
2472     * Forwards-compatible mode
2473     */
2474     inode-&gt;forwardsCompat = iprev-&gt;forwardsCompat;
2475     } else {
2476     inode-&gt;inScopeNs = NULL;
2477     inode-&gt;exclResultNs = NULL;
2478     inode-&gt;extElemNs = NULL;
2479     inode-&gt;preserveWhitespace = 0;
2480     inode-&gt;forwardsCompat = 0;
2481     }
2482 
2483     return(inode);
2484 }
2485 
2486 /*
2487 * xsltCompilerNodePop:
2488 *
2489 * @cctxt: the compilation context
2490 * @node: the node to be pushed (this can also be the doc-node)
2491 *
2492 * Pops the current node info.
2493 */
2494 static void
2495 xsltCompilerNodePop(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2496 {
2497     if (cctxt-&gt;inode == NULL) {
2498     xmlGenericError(xmlGenericErrorContext,
2499         &quot;xsltCompilerNodePop: Top-node mismatch.\n&quot;);
2500     return;
2501     }
2502     /*
2503     * NOTE: Be carefull with the @node, since it might be
2504     *  a doc-node.
2505     */
2506     if (cctxt-&gt;inode-&gt;node != node) {
2507     xmlGenericError(xmlGenericErrorContext,
2508     &quot;xsltCompilerNodePop: Node mismatch.\n&quot;);
2509     goto mismatch;
2510     }
2511     if (cctxt-&gt;inode-&gt;depth != cctxt-&gt;depth) {
2512     xmlGenericError(xmlGenericErrorContext,
2513     &quot;xsltCompilerNodePop: Depth mismatch.\n&quot;);
2514     goto mismatch;
2515     }
2516     cctxt-&gt;depth--;
2517     /*
2518     * Pop information of variables.
2519     */
2520     if ((cctxt-&gt;ivar) &amp;&amp; (cctxt-&gt;ivar-&gt;depth &gt; cctxt-&gt;depth))
2521     xsltCompilerVarInfoPop(cctxt);
2522 
2523     cctxt-&gt;inode = cctxt-&gt;inode-&gt;prev;
2524     if (cctxt-&gt;inode != NULL)
2525     cctxt-&gt;inode-&gt;curChildType = 0;
2526     return;
2527 
2528 mismatch:
2529     {
2530     const xmlChar *nsName = NULL, *name = NULL;
2531     const xmlChar *infnsName = NULL, *infname = NULL;
2532 
2533     if (node) {
2534         if (node-&gt;type == XML_ELEMENT_NODE) {
2535         name = node-&gt;name;
2536         if (node-&gt;ns != NULL)
2537             nsName = node-&gt;ns-&gt;href;
2538         else
2539             nsName = BAD_CAST &quot;&quot;;
2540         } else {
2541         name = BAD_CAST &quot;#document&quot;;
2542         nsName = BAD_CAST &quot;&quot;;
2543         }
2544     } else
2545         name = BAD_CAST &quot;Not given&quot;;
2546 
2547     if (cctxt-&gt;inode-&gt;node) {
2548         if (node-&gt;type == XML_ELEMENT_NODE) {
2549         infname = cctxt-&gt;inode-&gt;node-&gt;name;
2550         if (cctxt-&gt;inode-&gt;node-&gt;ns != NULL)
2551             infnsName = cctxt-&gt;inode-&gt;node-&gt;ns-&gt;href;
2552         else
2553             infnsName = BAD_CAST &quot;&quot;;
2554         } else {
2555         infname = BAD_CAST &quot;#document&quot;;
2556         infnsName = BAD_CAST &quot;&quot;;
2557         }
2558     } else
2559         infname = BAD_CAST &quot;Not given&quot;;
2560 
2561 
2562     xmlGenericError(xmlGenericErrorContext,
2563         &quot;xsltCompilerNodePop: Given   : &#39;%s&#39; URI &#39;%s&#39;\n&quot;,
2564         name, nsName);
2565     xmlGenericError(xmlGenericErrorContext,
2566         &quot;xsltCompilerNodePop: Expected: &#39;%s&#39; URI &#39;%s&#39;\n&quot;,
2567         infname, infnsName);
2568     }
2569 }
2570 
2571 /*
2572 * xsltCompilerBuildInScopeNsList:
2573 *
2574 * Create and store the list of in-scope namespaces for the given
2575 * node in the stylesheet. If there are no changes in the in-scope
2576 * namespaces then the last ns-info of the ancestor axis will be returned.
2577 * Compilation-time only.
2578 *
2579 * Returns the ns-info or NULL if there are no namespaces in scope.
2580 */
2581 static xsltNsListContainerPtr
2582 xsltCompilerBuildInScopeNsList(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
2583 {
2584     xsltNsListContainerPtr nsi = NULL;
2585     xmlNsPtr *list = NULL, ns;
2586     int i, maxns = 5;
2587     /*
2588     * Create a new ns-list for this position in the node-tree.
2589     * xmlGetNsList() will return NULL, if there are no ns-decls in the
2590     * tree. Note that the ns-decl for the XML namespace is not added
2591     * to the resulting list; the XPath module handles the XML namespace
2592     * internally.
2593     */
2594     while (node != NULL) {
2595         if (node-&gt;type == XML_ELEMENT_NODE) {
2596             ns = node-&gt;nsDef;
2597             while (ns != NULL) {
2598                 if (nsi == NULL) {
2599             nsi = (xsltNsListContainerPtr)
2600             xmlMalloc(sizeof(xsltNsListContainer));
2601             if (nsi == NULL) {
2602             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2603                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2604                 &quot;malloc failed!\n&quot;);
2605             goto internal_err;
2606             }
2607             memset(nsi, 0, sizeof(xsltNsListContainer));
2608                     nsi-&gt;list =
2609                         (xmlNsPtr *) xmlMalloc(maxns * sizeof(xmlNsPtr));
2610                     if (nsi-&gt;list == NULL) {
2611             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2612                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2613                 &quot;malloc failed!\n&quot;);
2614             goto internal_err;
2615                     }
2616                     nsi-&gt;list[0] = NULL;
2617                 }
2618         /*
2619         * Skip shadowed namespace bindings.
2620         */
2621                 for (i = 0; i &lt; nsi-&gt;totalNumber; i++) {
2622                     if ((ns-&gt;prefix == nsi-&gt;list[i]-&gt;prefix) ||
2623                         (xmlStrEqual(ns-&gt;prefix, nsi-&gt;list[i]-&gt;prefix)))
2624             break;
2625                 }
2626                 if (i &gt;= nsi-&gt;totalNumber) {
2627                     if (nsi-&gt;totalNumber +1 &gt;= maxns) {
2628                         maxns *= 2;
2629             nsi-&gt;list =
2630                 (xmlNsPtr *) xmlRealloc(nsi-&gt;list,
2631                 maxns * sizeof(xmlNsPtr));
2632                         if (nsi-&gt;list == NULL) {
2633                             xsltTransformError(NULL, cctxt-&gt;style, NULL,
2634                 &quot;xsltCompilerBuildInScopeNsList: &quot;
2635                 &quot;realloc failed!\n&quot;);
2636                 goto internal_err;
2637                         }
2638                     }
2639                     nsi-&gt;list[nsi-&gt;totalNumber++] = ns;
2640                     nsi-&gt;list[nsi-&gt;totalNumber] = NULL;
2641                 }
2642 
2643                 ns = ns-&gt;next;
2644             }
2645         }
2646         node = node-&gt;parent;
2647     }
2648     if (nsi == NULL)
2649     return(NULL);
2650     /*
2651     * Move the default namespace to last position.
2652     */
2653     nsi-&gt;xpathNumber = nsi-&gt;totalNumber;
2654     for (i = 0; i &lt; nsi-&gt;totalNumber; i++) {
2655     if (nsi-&gt;list[i]-&gt;prefix == NULL) {
2656         ns = nsi-&gt;list[i];
2657         nsi-&gt;list[i] = nsi-&gt;list[nsi-&gt;totalNumber-1];
2658         nsi-&gt;list[nsi-&gt;totalNumber-1] = ns;
2659         nsi-&gt;xpathNumber--;
2660         break;
2661     }
2662     }
2663     /*
2664     * Store the ns-list in the stylesheet.
2665     */
2666     if (xsltPointerListAddSize(
2667     (xsltPointerListPtr)cctxt-&gt;psData-&gt;inScopeNamespaces,
2668     (void *) nsi, 5) == -1)
2669     {
2670     xmlFree(nsi);
2671     nsi = NULL;
2672     xsltTransformError(NULL, cctxt-&gt;style, NULL,
2673         &quot;xsltCompilerBuildInScopeNsList: failed to add ns-info.\n&quot;);
2674     goto internal_err;
2675     }
2676     /*
2677     * Notify of change in status wrt namespaces.
2678     */
2679     if (cctxt-&gt;inode != NULL)
2680     cctxt-&gt;inode-&gt;nsChanged = 1;
2681 
2682     return(nsi);
2683 
2684 internal_err:
2685     if (list != NULL)
2686     xmlFree(list);
2687     cctxt-&gt;style-&gt;errors++;
2688     return(NULL);
2689 }
2690 
2691 static int
2692 xsltParseNsPrefixList(xsltCompilerCtxtPtr cctxt,
2693               xsltPointerListPtr list,
2694               xmlNodePtr node,
2695               const xmlChar *value)
2696 {
2697     xmlChar *cur, *end;
2698     xmlNsPtr ns;
2699 
2700     if ((cctxt == NULL) || (value == NULL) || (list == NULL))
2701     return(-1);
2702 
2703     list-&gt;number = 0;
2704 
2705     cur = (xmlChar *) value;
2706     while (*cur != 0) {
2707     while (IS_BLANK(*cur)) cur++;
2708     if (*cur == 0)
2709         break;
2710     end = cur;
2711     while ((*end != 0) &amp;&amp; (!IS_BLANK(*end))) end++;
2712     cur = xmlStrndup(cur, end - cur);
2713     if (cur == NULL) {
2714         cur = end;
2715         continue;
2716     }
2717     /*
2718     * TODO: Export and use xmlSearchNsByPrefixStrict()
2719     *   in Libxml2, tree.c, since xmlSearchNs() is in most
2720     *   cases not efficient and in some cases not correct.
2721     *
2722     * XSLT-2 TODO: XSLT 2.0 allows an additional &quot;#all&quot; value.
2723     */
2724     if ((cur[0] == &#39;#&#39;) &amp;&amp;
2725         xmlStrEqual(cur, (const xmlChar *)&quot;#default&quot;))
2726         ns = xmlSearchNs(cctxt-&gt;style-&gt;doc, node, NULL);
2727     else
2728         ns = xmlSearchNs(cctxt-&gt;style-&gt;doc, node, cur);
2729 
2730     if (ns == NULL) {
2731         /*
2732         * TODO: Better to report the attr-node, otherwise
2733         *  the user won&#39;t know which attribute was invalid.
2734         */
2735         xsltTransformError(NULL, cctxt-&gt;style, node,
2736         &quot;No namespace binding in scope for prefix &#39;%s&#39;.\n&quot;, cur);
2737         /*
2738         * XSLT-1.0: &quot;It is an error if there is no namespace
2739         *  bound to the prefix on the element bearing the
2740         *  exclude-result-prefixes or xsl:exclude-result-prefixes
2741         *  attribute.&quot;
2742         */
2743         cctxt-&gt;style-&gt;errors++;
2744     } else {
2745 #ifdef WITH_XSLT_DEBUG_PARSING
2746         xsltGenericDebug(xsltGenericDebugContext,
2747         &quot;resolved prefix &#39;%s&#39;\n&quot;, cur);
2748 #endif
2749         /*
2750         * Note that we put the namespace name into the dict.
2751         */
2752         if (xsltPointerListAddSize(list,
2753         (void *) xmlDictLookup(cctxt-&gt;style-&gt;dict,
2754         ns-&gt;href, -1), 5) == -1)
2755         {
2756         xmlFree(cur);
2757         goto internal_err;
2758         }
2759     }
2760     xmlFree(cur);
2761 
2762     cur = end;
2763     }
2764     return(0);
2765 
2766 internal_err:
2767     cctxt-&gt;style-&gt;errors++;
2768     return(-1);
2769 }
2770 
2771 /**
2772  * xsltCompilerUtilsCreateMergedList:
2773  * @dest: the destination list (optional)
2774  * @first: the first list
2775  * @second: the second list (optional)
2776  *
2777  * Appends the content of @second to @first into @destination.
2778  * If @destination is NULL a new list will be created.
2779  *
2780  * Returns the merged list of items or NULL if there&#39;s nothing to merge.
2781  */
2782 static xsltPointerListPtr
2783 xsltCompilerUtilsCreateMergedList(xsltPointerListPtr first,
2784                 xsltPointerListPtr second)
2785 {
2786     xsltPointerListPtr ret;
2787     size_t num;
2788 
2789     if (first)
2790     num = first-&gt;number;
2791     else
2792     num = 0;
2793     if (second)
2794     num += second-&gt;number;
2795     if (num == 0)
2796     return(NULL);
2797     ret = xsltPointerListCreate(num);
2798     if (ret == NULL)
2799     return(NULL);
2800     /*
2801     * Copy contents.
2802     */
2803     if ((first != NULL) &amp;&amp;  (first-&gt;number != 0)) {
2804     memcpy(ret-&gt;items, first-&gt;items,
2805         first-&gt;number * sizeof(void *));
2806     if ((second != NULL) &amp;&amp; (second-&gt;number != 0))
2807         memcpy(ret-&gt;items + first-&gt;number, second-&gt;items,
2808         second-&gt;number * sizeof(void *));
2809     } else if ((second != NULL) &amp;&amp; (second-&gt;number != 0))
2810     memcpy(ret-&gt;items, (void *) second-&gt;items,
2811         second-&gt;number * sizeof(void *));
2812     ret-&gt;number = num;
2813     return(ret);
2814 }
2815 
2816 /*
2817 * xsltParseExclResultPrefixes:
2818 *
2819 * Create and store the list of in-scope namespaces for the given
2820 * node in the stylesheet. If there are no changes in the in-scope
2821 * namespaces then the last ns-info of the ancestor axis will be returned.
2822 * Compilation-time only.
2823 *
2824 * Returns the ns-info or NULL if there are no namespaces in scope.
2825 */
2826 static xsltPointerListPtr
2827 xsltParseExclResultPrefixes(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
2828                 xsltPointerListPtr def,
2829                 int instrCategory)
2830 {
2831     xsltPointerListPtr list = NULL;
2832     xmlChar *value;
2833     xmlAttrPtr attr;
2834 
2835     if ((cctxt == NULL) || (node == NULL))
2836     return(NULL);
2837 
2838     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
2839     attr = xmlHasNsProp(node, BAD_CAST &quot;exclude-result-prefixes&quot;, NULL);
2840     else
2841     attr = xmlHasNsProp(node, BAD_CAST &quot;exclude-result-prefixes&quot;,
2842         XSLT_NAMESPACE);
2843     if (attr == NULL)
2844     return(def);
2845 
2846     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
2847     /*
2848     * Mark the XSLT attr.
2849     */
2850     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
2851     }
2852 
2853     if ((attr-&gt;children != NULL) &amp;&amp;
2854     (attr-&gt;children-&gt;content != NULL))
2855     value = attr-&gt;children-&gt;content;
2856     else {
2857     xsltTransformError(NULL, cctxt-&gt;style, node,
2858         &quot;Attribute &#39;exclude-result-prefixes&#39;: Invalid value.\n&quot;);
2859     cctxt-&gt;style-&gt;errors++;
2860     return(def);
2861     }
2862 
2863     if (xsltParseNsPrefixList(cctxt, cctxt-&gt;tmpList, node,
2864     BAD_CAST value) != 0)
2865     goto exit;
2866     if (cctxt-&gt;tmpList-&gt;number == 0)
2867     goto exit;
2868     /*
2869     * Merge the list with the inherited list.
2870     */
2871     list = xsltCompilerUtilsCreateMergedList(def, cctxt-&gt;tmpList);
2872     if (list == NULL)
2873     goto exit;
2874     /*
2875     * Store the list in the stylesheet/compiler context.
2876     */
2877     if (xsltPointerListAddSize(
2878     cctxt-&gt;psData-&gt;exclResultNamespaces, list, 5) == -1)
2879     {
2880     xsltPointerListFree(list);
2881     list = NULL;
2882     goto exit;
2883     }
2884     /*
2885     * Notify of change in status wrt namespaces.
2886     */
2887     if (cctxt-&gt;inode != NULL)
2888     cctxt-&gt;inode-&gt;nsChanged = 1;
2889 
2890 exit:
2891     if (list != NULL)
2892     return(list);
2893     else
2894     return(def);
2895 }
2896 
2897 /*
2898 * xsltParseExtElemPrefixes:
2899 *
2900 * Create and store the list of in-scope namespaces for the given
2901 * node in the stylesheet. If there are no changes in the in-scope
2902 * namespaces then the last ns-info of the ancestor axis will be returned.
2903 * Compilation-time only.
2904 *
2905 * Returns the ns-info or NULL if there are no namespaces in scope.
2906 */
2907 static xsltPointerListPtr
2908 xsltParseExtElemPrefixes(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
2909              xsltPointerListPtr def,
2910              int instrCategory)
2911 {
2912     xsltPointerListPtr list = NULL;
2913     xmlAttrPtr attr;
2914     xmlChar *value;
2915     int i;
2916 
2917     if ((cctxt == NULL) || (node == NULL))
2918     return(NULL);
2919 
2920     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
2921     attr = xmlHasNsProp(node, BAD_CAST &quot;extension-element-prefixes&quot;, NULL);
2922     else
2923     attr = xmlHasNsProp(node, BAD_CAST &quot;extension-element-prefixes&quot;,
2924         XSLT_NAMESPACE);
2925     if (attr == NULL)
2926     return(def);
2927 
2928     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
2929     /*
2930     * Mark the XSLT attr.
2931     */
2932     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
2933     }
2934 
2935     if ((attr-&gt;children != NULL) &amp;&amp;
2936     (attr-&gt;children-&gt;content != NULL))
2937     value = attr-&gt;children-&gt;content;
2938     else {
2939     xsltTransformError(NULL, cctxt-&gt;style, node,
2940         &quot;Attribute &#39;extension-element-prefixes&#39;: Invalid value.\n&quot;);
2941     cctxt-&gt;style-&gt;errors++;
2942     return(def);
2943     }
2944 
2945 
2946     if (xsltParseNsPrefixList(cctxt, cctxt-&gt;tmpList, node,
2947     BAD_CAST value) != 0)
2948     goto exit;
2949 
2950     if (cctxt-&gt;tmpList-&gt;number == 0)
2951     goto exit;
2952     /*
2953     * REVISIT: Register the extension namespaces.
2954     */
2955     for (i = 0; i &lt; cctxt-&gt;tmpList-&gt;number; i++)
2956     xsltRegisterExtPrefix(cctxt-&gt;style, NULL,
2957     BAD_CAST cctxt-&gt;tmpList-&gt;items[i]);
2958     /*
2959     * Merge the list with the inherited list.
2960     */
2961     list = xsltCompilerUtilsCreateMergedList(def, cctxt-&gt;tmpList);
2962     if (list == NULL)
2963     goto exit;
2964     /*
2965     * Store the list in the stylesheet.
2966     */
2967     if (xsltPointerListAddSize(
2968     cctxt-&gt;psData-&gt;extElemNamespaces, list, 5) == -1)
2969     {
2970     xsltPointerListFree(list);
2971     list = NULL;
2972     goto exit;
2973     }
2974     /*
2975     * Notify of change in status wrt namespaces.
2976     */
2977     if (cctxt-&gt;inode != NULL)
2978     cctxt-&gt;inode-&gt;nsChanged = 1;
2979 
2980 exit:
2981     if (list != NULL)
2982     return(list);
2983     else
2984     return(def);
2985 }
2986 
2987 /*
2988 * xsltParseAttrXSLTVersion:
2989 *
2990 * @cctxt: the compilation context
2991 * @node: the element-node
2992 * @isXsltElem: whether this is an XSLT element
2993 *
2994 * Parses the attribute xsl:version.
2995 *
2996 * Returns 1 if there was such an attribute, 0 if not and
2997 *         -1 if an internal or API error occured.
2998 */
2999 static int
3000 xsltParseAttrXSLTVersion(xsltCompilerCtxtPtr cctxt, xmlNodePtr node,
3001              int instrCategory)
3002 {
3003     xmlChar *value;
3004     xmlAttrPtr attr;
3005 
3006     if ((cctxt == NULL) || (node == NULL))
3007     return(-1);
3008 
3009     if (instrCategory == XSLT_ELEMENT_CATEGORY_XSLT)
3010     attr = xmlHasNsProp(node, BAD_CAST &quot;version&quot;, NULL);
3011     else
3012     attr = xmlHasNsProp(node, BAD_CAST &quot;version&quot;, XSLT_NAMESPACE);
3013 
3014     if (attr == NULL)
3015     return(0);
3016 
3017     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
3018 
3019     if ((attr-&gt;children != NULL) &amp;&amp;
3020     (attr-&gt;children-&gt;content != NULL))
3021     value = attr-&gt;children-&gt;content;
3022     else {
3023     xsltTransformError(NULL, cctxt-&gt;style, node,
3024         &quot;Attribute &#39;version&#39;: Invalid value.\n&quot;);
3025     cctxt-&gt;style-&gt;errors++;
3026     return(1);
3027     }
3028 
3029     if (! xmlStrEqual(value, (const xmlChar *)&quot;1.0&quot;)) {
3030     cctxt-&gt;inode-&gt;forwardsCompat = 1;
3031     /*
3032     * TODO: To what extent do we support the
3033     *  forwards-compatible mode?
3034     */
3035     /*
3036     * Report this only once per compilation episode.
3037     */
3038     if (! cctxt-&gt;hasForwardsCompat) {
3039         cctxt-&gt;hasForwardsCompat = 1;
3040         cctxt-&gt;errSeverity = XSLT_ERROR_SEVERITY_WARNING;
3041         xsltTransformError(NULL, cctxt-&gt;style, node,
3042         &quot;Warning: the attribute xsl:version specifies a value &quot;
3043         &quot;different from &#39;1.0&#39;. Switching to forwards-compatible &quot;
3044         &quot;mode. Only features of XSLT 1.0 are supported by this &quot;
3045         &quot;processor.\n&quot;);
3046         cctxt-&gt;style-&gt;warnings++;
3047         cctxt-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
3048     }
3049     } else {
3050     cctxt-&gt;inode-&gt;forwardsCompat = 0;
3051     }
3052 
3053     if (attr &amp;&amp; (instrCategory == XSLT_ELEMENT_CATEGORY_LRE)) {
3054     /*
3055     * Set a marker on XSLT attributes.
3056     */
3057     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
3058     }
3059     return(1);
3060 }
3061 
3062 static int
3063 xsltParsePreprocessStylesheetTree(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
3064 {
3065     xmlNodePtr deleteNode, cur, txt, textNode = NULL;
3066     xmlDocPtr doc;
3067     xsltStylesheetPtr style;
3068     int internalize = 0, findSpaceAttr;
3069     int xsltStylesheetElemDepth;
3070     xmlAttrPtr attr;
3071     xmlChar *value;
3072     const xmlChar *name, *nsNameXSLT = NULL;
3073     int strictWhitespace, inXSLText = 0;
3074 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3075     xsltNsMapPtr nsMapItem;
3076 #endif
3077 
3078     if ((cctxt == NULL) || (cctxt-&gt;style == NULL) ||
3079     (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
3080         return(-1);
3081 
3082     doc = node-&gt;doc;
3083     if (doc == NULL)
3084     goto internal_err;
3085 
3086     style = cctxt-&gt;style;
3087     if ((style-&gt;dict != NULL) &amp;&amp; (doc-&gt;dict == style-&gt;dict))
3088     internalize = 1;
3089     else
3090         style-&gt;internalized = 0;
3091 
3092     /*
3093     * Init value of xml:space. Since this might be an embedded
3094     * stylesheet, this is needed to be performed on the element
3095     * where the stylesheet is rooted at, taking xml:space of
3096     * ancestors into account.
3097     */
3098     if (! cctxt-&gt;simplified)
3099     xsltStylesheetElemDepth = cctxt-&gt;depth +1;
3100     else
3101     xsltStylesheetElemDepth = 0;
3102 
3103     if (xmlNodeGetSpacePreserve(node) != 1)
3104     cctxt-&gt;inode-&gt;preserveWhitespace = 0;
3105     else
3106     cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3107 
3108     /*
3109     * Eval if we should keep the old incorrect behaviour.
3110     */
3111     strictWhitespace = (cctxt-&gt;strict != 0) ? 1 : 0;
3112 
3113     nsNameXSLT = xsltConstNamespaceNameXSLT;
3114 
3115     deleteNode = NULL;
3116     cur = node;
3117     while (cur != NULL) {
3118     if (deleteNode != NULL) {
3119 
3120 #ifdef WITH_XSLT_DEBUG_BLANKS
3121         xsltGenericDebug(xsltGenericDebugContext,
3122          &quot;xsltParsePreprocessStylesheetTree: removing node\n&quot;);
3123 #endif
3124         xmlUnlinkNode(deleteNode);
3125         xmlFreeNode(deleteNode);
3126         deleteNode = NULL;
3127     }
3128     if (cur-&gt;type == XML_ELEMENT_NODE) {
3129 
3130         /*
3131         * Clear the PSVI field.
3132         */
3133         cur-&gt;psvi = NULL;
3134 
3135         xsltCompilerNodePush(cctxt, cur);
3136 
3137         inXSLText = 0;
3138         textNode = NULL;
3139         findSpaceAttr = 1;
3140         cctxt-&gt;inode-&gt;stripWhitespace = 0;
3141         /*
3142         * TODO: I&#39;d love to use a string pointer comparison here :-/
3143         */
3144         if (IS_XSLT_ELEM(cur)) {
3145 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3146         if (cur-&gt;ns-&gt;href != nsNameXSLT) {
3147             nsMapItem = xsltNewNamespaceMapItem(cctxt,
3148             doc, cur-&gt;ns, cur);
3149             if (nsMapItem == NULL)
3150             goto internal_err;
3151             cur-&gt;ns-&gt;href = nsNameXSLT;
3152         }
3153 #endif
3154 
3155         if (cur-&gt;name == NULL)
3156             goto process_attributes;
3157         /*
3158         * Mark the XSLT element for later recognition.
3159         * TODO: Using the marker is still too dangerous, since if
3160         *   the parsing mechanism leaves out an XSLT element, then
3161         *   this might hit the transformation-mechanism, which
3162         *   will break if it doesn&#39;t expect such a marker.
3163         */
3164         /* cur-&gt;psvi = (void *) xsltXSLTElemMarker; */
3165 
3166         /*
3167         * XSLT 2.0: &quot;Any whitespace text node whose parent is
3168         * one of the following elements is removed from the &quot;
3169         * tree, regardless of any xml:space attributes:...&quot;
3170         * xsl:apply-imports,
3171         * xsl:apply-templates,
3172         * xsl:attribute-set,
3173         * xsl:call-template,
3174         * xsl:choose,
3175         * xsl:stylesheet, xsl:transform.
3176         * XSLT 2.0: xsl:analyze-string,
3177         *           xsl:character-map,
3178         *           xsl:next-match
3179         *
3180         * TODO: I&#39;d love to use a string pointer comparison here :-/
3181         */
3182         name = cur-&gt;name;
3183         switch (*name) {
3184             case &#39;t&#39;:
3185             if ((name[0] == &#39;t&#39;) &amp;&amp; (name[1] == &#39;e&#39;) &amp;&amp;
3186                 (name[2] == &#39;x&#39;) &amp;&amp; (name[3] == &#39;t&#39;) &amp;&amp;
3187                 (name[4] == 0))
3188             {
3189                 /*
3190                 * Process the xsl:text element.
3191                 * ----------------------------
3192                 * Mark it for later recognition.
3193                 */
3194                 cur-&gt;psvi = (void *) xsltXSLTTextMarker;
3195                 /*
3196                 * For stylesheets, the set of
3197                 * whitespace-preserving element names
3198                 * consists of just xsl:text.
3199                 */
3200                 findSpaceAttr = 0;
3201                 cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3202                 inXSLText = 1;
3203             }
3204             break;
3205             case &#39;c&#39;:
3206             if (xmlStrEqual(name, BAD_CAST &quot;choose&quot;) ||
3207                 xmlStrEqual(name, BAD_CAST &quot;call-template&quot;))
3208                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3209             break;
3210             case &#39;a&#39;:
3211             if (xmlStrEqual(name, BAD_CAST &quot;apply-templates&quot;) ||
3212                 xmlStrEqual(name, BAD_CAST &quot;apply-imports&quot;) ||
3213                 xmlStrEqual(name, BAD_CAST &quot;attribute-set&quot;))
3214 
3215                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3216             break;
3217             default:
3218             if (xsltStylesheetElemDepth == cctxt-&gt;depth) {
3219                 /*
3220                 * This is a xsl:stylesheet/xsl:transform.
3221                 */
3222                 cctxt-&gt;inode-&gt;stripWhitespace = 1;
3223                 break;
3224             }
3225 
3226             if ((cur-&gt;prev != NULL) &amp;&amp;
3227                 (cur-&gt;prev-&gt;type == XML_TEXT_NODE))
3228             {
3229                 /*
3230                 * XSLT 2.0 : &quot;Any whitespace text node whose
3231                 *  following-sibling node is an xsl:param or
3232                 *  xsl:sort element is removed from the tree,
3233                 *  regardless of any xml:space attributes.&quot;
3234                 */
3235                 if (((*name == &#39;p&#39;) || (*name == &#39;s&#39;)) &amp;&amp;
3236                 (xmlStrEqual(name, BAD_CAST &quot;param&quot;) ||
3237                  xmlStrEqual(name, BAD_CAST &quot;sort&quot;)))
3238                 {
3239                 do {
3240                     if (IS_BLANK_NODE(cur-&gt;prev)) {
3241                     txt = cur-&gt;prev;
3242                     xmlUnlinkNode(txt);
3243                     xmlFreeNode(txt);
3244                     } else {
3245                     /*
3246                     * This will result in a content
3247                     * error, when hitting the parsing
3248                     * functions.
3249                     */
3250                     break;
3251                     }
3252                 } while (cur-&gt;prev);
3253                 }
3254             }
3255             break;
3256         }
3257         }
3258 
3259 process_attributes:
3260         /*
3261         * Process attributes.
3262         * ------------------
3263         */
3264         if (cur-&gt;properties != NULL) {
3265         if (cur-&gt;children == NULL)
3266             findSpaceAttr = 0;
3267         attr = cur-&gt;properties;
3268         do {
3269 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
3270             if ((attr-&gt;ns) &amp;&amp; (attr-&gt;ns-&gt;href != nsNameXSLT) &amp;&amp;
3271             xmlStrEqual(attr-&gt;ns-&gt;href, nsNameXSLT))
3272             {
3273             nsMapItem = xsltNewNamespaceMapItem(cctxt,
3274                 doc, attr-&gt;ns, cur);
3275             if (nsMapItem == NULL)
3276                 goto internal_err;
3277             attr-&gt;ns-&gt;href = nsNameXSLT;
3278             }
3279 #endif
3280             if (internalize) {
3281             /*
3282             * Internalize the attribute&#39;s value; the goal is to
3283             * speed up operations and minimize used space by
3284             * compiled stylesheets.
3285             */
3286             txt = attr-&gt;children;
3287             /*
3288             * NOTE that this assumes only one
3289             *  text-node in the attribute&#39;s content.
3290             */
3291             if ((txt != NULL) &amp;&amp; (txt-&gt;content != NULL) &amp;&amp;
3292                 (!xmlDictOwns(style-&gt;dict, txt-&gt;content)))
3293             {
3294                 value = (xmlChar *) xmlDictLookup(style-&gt;dict,
3295                 txt-&gt;content, -1);
3296                 xmlNodeSetContent(txt, NULL);
3297                 txt-&gt;content = value;
3298             }
3299             }
3300             /*
3301             * Process xml:space attributes.
3302             * ----------------------------
3303             */
3304             if ((findSpaceAttr != 0) &amp;&amp;
3305             (attr-&gt;ns != NULL) &amp;&amp;
3306             (attr-&gt;name != NULL) &amp;&amp;
3307             (attr-&gt;name[0] == &#39;s&#39;) &amp;&amp;
3308             (attr-&gt;ns-&gt;prefix != NULL) &amp;&amp;
3309             (attr-&gt;ns-&gt;prefix[0] == &#39;x&#39;) &amp;&amp;
3310             (attr-&gt;ns-&gt;prefix[1] == &#39;m&#39;) &amp;&amp;
3311             (attr-&gt;ns-&gt;prefix[2] == &#39;l&#39;) &amp;&amp;
3312             (attr-&gt;ns-&gt;prefix[3] == 0))
3313             {
3314             value = xmlGetNsProp(cur, BAD_CAST &quot;space&quot;,
3315                 XML_XML_NAMESPACE);
3316             if (value != NULL) {
3317                 if (xmlStrEqual(value, BAD_CAST &quot;preserve&quot;)) {
3318                 cctxt-&gt;inode-&gt;preserveWhitespace = 1;
3319                 } else if (xmlStrEqual(value, BAD_CAST &quot;default&quot;)) {
3320                 cctxt-&gt;inode-&gt;preserveWhitespace = 0;
3321                 } else {
3322                 /* Invalid value for xml:space. */
3323                 xsltTransformError(NULL, style, cur,
3324                     &quot;Attribute xml:space: Invalid value.\n&quot;);
3325                 cctxt-&gt;style-&gt;warnings++;
3326                 }
3327                 findSpaceAttr = 0;
3328                 xmlFree(value);
3329             }
3330 
3331             }
3332             attr = attr-&gt;next;
3333         } while (attr != NULL);
3334         }
3335         /*
3336         * We&#39;ll descend into the children of element nodes only.
3337         */
3338         if (cur-&gt;children != NULL) {
3339         cur = cur-&gt;children;
3340         continue;
3341         }
3342     } else if ((cur-&gt;type == XML_TEXT_NODE) ||
3343         (cur-&gt;type == XML_CDATA_SECTION_NODE))
3344     {
3345         /*
3346         * Merge adjacent text/CDATA-section-nodes
3347         * ---------------------------------------
3348         * In order to avoid breaking of existing stylesheets,
3349         * if the old behaviour is wanted (strictWhitespace == 0),
3350         * then we *won&#39;t* merge adjacent text-nodes
3351         * (except in xsl:text); this will ensure that whitespace-only
3352         * text nodes are (incorrectly) not stripped in some cases.
3353         *
3354         * Example:               : &lt;foo&gt;  &lt;!-- bar --&gt;zoo&lt;/foo&gt;
3355         * Corrent (strict) result: &lt;foo&gt;  zoo&lt;/foo&gt;
3356         * Incorrect (old) result : &lt;foo&gt;zoo&lt;/foo&gt;
3357         *
3358         * NOTE that we *will* merge adjacent text-nodes if
3359         * they are in xsl:text.
3360         * Example, the following:
3361         * &lt;xsl:text&gt;  &lt;!-- bar --&gt;zoo&lt;xsl:text&gt;
3362         * will result in both cases in:
3363         * &lt;xsl:text&gt;  zoo&lt;xsl:text&gt;
3364         */
3365         cur-&gt;type = XML_TEXT_NODE;
3366         if ((strictWhitespace != 0) || (inXSLText != 0)) {
3367         /*
3368         * New behaviour; merge nodes.
3369         */
3370         if (textNode == NULL)
3371             textNode = cur;
3372         else {
3373             if (cur-&gt;content != NULL)
3374             xmlNodeAddContent(textNode, cur-&gt;content);
3375             deleteNode = cur;
3376         }
3377         if ((cur-&gt;next == NULL) ||
3378             (cur-&gt;next-&gt;type == XML_ELEMENT_NODE))
3379             goto end_of_text;
3380         else
3381             goto next_sibling;
3382         } else {
3383         /*
3384         * Old behaviour.
3385         */
3386         if (textNode == NULL)
3387             textNode = cur;
3388         goto end_of_text;
3389         }
3390     } else if ((cur-&gt;type == XML_COMMENT_NODE) ||
3391         (cur-&gt;type == XML_PI_NODE))
3392     {
3393         /*
3394         * Remove processing instructions and comments.
3395         */
3396         deleteNode = cur;
3397         if ((cur-&gt;next == NULL) ||
3398         (cur-&gt;next-&gt;type == XML_ELEMENT_NODE))
3399         goto end_of_text;
3400         else
3401         goto next_sibling;
3402     } else {
3403         textNode = NULL;
3404         /*
3405         * Invalid node-type for this data-model.
3406         */
3407         xsltTransformError(NULL, style, cur,
3408         &quot;Invalid type of node for the XSLT data model.\n&quot;);
3409         cctxt-&gt;style-&gt;errors++;
3410         goto next_sibling;
3411     }
3412 
3413 end_of_text:
3414     if (textNode) {
3415         value = textNode-&gt;content;
3416         /*
3417         * At this point all adjacent text/CDATA-section nodes
3418         * have been merged.
3419         *
3420         * Strip whitespace-only text-nodes.
3421         * (cctxt-&gt;inode-&gt;stripWhitespace)
3422         */
3423         if ((value == NULL) || (*value == 0) ||
3424         (((cctxt-&gt;inode-&gt;stripWhitespace) ||
3425           (! cctxt-&gt;inode-&gt;preserveWhitespace)) &amp;&amp;
3426          IS_BLANK(*value) &amp;&amp;
3427          xsltIsBlank(value)))
3428         {
3429         if (textNode != cur) {
3430             xmlUnlinkNode(textNode);
3431             xmlFreeNode(textNode);
3432         } else
3433             deleteNode = textNode;
3434         textNode = NULL;
3435         goto next_sibling;
3436         }
3437         /*
3438         * Convert CDATA-section nodes to text-nodes.
3439         * TODO: Can this produce problems?
3440         */
3441         if (textNode-&gt;type != XML_TEXT_NODE) {
3442         textNode-&gt;type = XML_TEXT_NODE;
3443         textNode-&gt;name = xmlStringText;
3444         }
3445         if (internalize &amp;&amp;
3446         (textNode-&gt;content != NULL) &amp;&amp;
3447         (!xmlDictOwns(style-&gt;dict, textNode-&gt;content)))
3448         {
3449         /*
3450         * Internalize the string.
3451         */
3452         value = (xmlChar *) xmlDictLookup(style-&gt;dict,
3453             textNode-&gt;content, -1);
3454         xmlNodeSetContent(textNode, NULL);
3455         textNode-&gt;content = value;
3456         }
3457         textNode = NULL;
3458         /*
3459         * Note that &quot;disable-output-escaping&quot; of the xsl:text
3460         * element will be applied at a later level, when
3461         * XSLT elements are processed.
3462         */
3463     }
3464 
3465 next_sibling:
3466     if (cur-&gt;type == XML_ELEMENT_NODE) {
3467         xsltCompilerNodePop(cctxt, cur);
3468     }
3469     if (cur == node)
3470         break;
3471     if (cur-&gt;next != NULL) {
3472         cur = cur-&gt;next;
3473     } else {
3474         cur = cur-&gt;parent;
3475         inXSLText = 0;
3476         goto next_sibling;
3477     };
3478     }
3479     if (deleteNode != NULL) {
3480 #ifdef WITH_XSLT_DEBUG_PARSING
3481     xsltGenericDebug(xsltGenericDebugContext,
3482      &quot;xsltParsePreprocessStylesheetTree: removing node\n&quot;);
3483 #endif
3484     xmlUnlinkNode(deleteNode);
3485     xmlFreeNode(deleteNode);
3486     }
3487     return(0);
3488 
3489 internal_err:
3490     return(-1);
3491 }
3492 
3493 #endif /* XSLT_REFACTORED */
3494 
3495 #ifdef XSLT_REFACTORED
3496 #else
3497 static void
3498 xsltPreprocessStylesheet(xsltStylesheetPtr style, xmlNodePtr cur)
3499 {
3500     xmlNodePtr deleteNode, styleelem;
3501     int internalize = 0;
3502 
3503     if ((style == NULL) || (cur == NULL))
3504         return;
3505 
3506     if ((cur-&gt;doc != NULL) &amp;&amp; (style-&gt;dict != NULL) &amp;&amp;
3507         (cur-&gt;doc-&gt;dict == style-&gt;dict))
3508     internalize = 1;
3509     else
3510         style-&gt;internalized = 0;
3511 
3512     if ((cur != NULL) &amp;&amp; (IS_XSLT_ELEM(cur)) &amp;&amp;
3513         (IS_XSLT_NAME(cur, &quot;stylesheet&quot;))) {
3514     styleelem = cur;
3515     } else {
3516         styleelem = NULL;
3517     }
3518 
3519     /*
3520      * This content comes from the stylesheet
3521      * For stylesheets, the set of whitespace-preserving
3522      * element names consists of just xsl:text.
3523      */
3524     deleteNode = NULL;
3525     while (cur != NULL) {
3526     if (deleteNode != NULL) {
3527 #ifdef WITH_XSLT_DEBUG_BLANKS
3528         xsltGenericDebug(xsltGenericDebugContext,
3529          &quot;xsltPreprocessStylesheet: removing ignorable blank node\n&quot;);
3530 #endif
3531         xmlUnlinkNode(deleteNode);
3532         xmlFreeNode(deleteNode);
3533         deleteNode = NULL;
3534     }
3535     if (cur-&gt;type == XML_ELEMENT_NODE) {
3536         int exclPrefixes;
3537         /*
3538          * Internalize attributes values.
3539          */
3540         if ((internalize) &amp;&amp; (cur-&gt;properties != NULL)) {
3541             xmlAttrPtr attr = cur-&gt;properties;
3542         xmlNodePtr txt;
3543 
3544         while (attr != NULL) {
3545             txt = attr-&gt;children;
3546             if ((txt != NULL) &amp;&amp; (txt-&gt;type == XML_TEXT_NODE) &amp;&amp;
3547                 (txt-&gt;content != NULL) &amp;&amp;
3548             (!xmlDictOwns(style-&gt;dict, txt-&gt;content)))
3549             {
3550             xmlChar *tmp;
3551 
3552             /*
3553              * internalize the text string, goal is to speed
3554              * up operations and minimize used space by compiled
3555              * stylesheets.
3556              */
3557             tmp = (xmlChar *) xmlDictLookup(style-&gt;dict,
3558                                             txt-&gt;content, -1);
3559             if (tmp != txt-&gt;content) {
3560                 xmlNodeSetContent(txt, NULL);
3561                 txt-&gt;content = tmp;
3562             }
3563             }
3564             attr = attr-&gt;next;
3565         }
3566         }
3567         if (IS_XSLT_ELEM(cur)) {
3568         exclPrefixes = 0;
3569         if (IS_XSLT_NAME(cur, &quot;text&quot;)) {
3570             for (;exclPrefixes &gt; 0;exclPrefixes--)
3571             exclPrefixPop(style);
3572             goto skip_children;
3573         }
3574         } else {
3575         exclPrefixes = xsltParseStylesheetExcludePrefix(style, cur, 0);
3576         }
3577 
3578         if ((cur-&gt;nsDef != NULL) &amp;&amp; (style-&gt;exclPrefixNr &gt; 0)) {
3579         xmlNsPtr ns = cur-&gt;nsDef, prev = NULL, next;
3580         xmlNodePtr root = NULL;
3581         int i, moved;
3582 
3583         root = xmlDocGetRootElement(cur-&gt;doc);
3584         if ((root != NULL) &amp;&amp; (root != cur)) {
3585             while (ns != NULL) {
3586             moved = 0;
3587             next = ns-&gt;next;
3588             for (i = 0;i &lt; style-&gt;exclPrefixNr;i++) {
3589                 if ((ns-&gt;prefix != NULL) &amp;&amp;
3590                     (xmlStrEqual(ns-&gt;href,
3591                          style-&gt;exclPrefixTab[i]))) {
3592                 /*
3593                  * Move the namespace definition on the root
3594                  * element to avoid duplicating it without
3595                  * loosing it.
3596                  */
3597                 if (prev == NULL) {
3598                     cur-&gt;nsDef = ns-&gt;next;
3599                 } else {
3600                     prev-&gt;next = ns-&gt;next;
3601                 }
3602                 ns-&gt;next = root-&gt;nsDef;
3603                 root-&gt;nsDef = ns;
3604                 moved = 1;
3605                 break;
3606                 }
3607             }
3608             if (moved == 0)
3609                 prev = ns;
3610             ns = next;
3611             }
3612         }
3613         }
3614         /*
3615          * If we have prefixes locally, recurse and pop them up when
3616          * going back
3617          */
3618         if (exclPrefixes &gt; 0) {
3619         xsltPreprocessStylesheet(style, cur-&gt;children);
3620         for (;exclPrefixes &gt; 0;exclPrefixes--)
3621             exclPrefixPop(style);
3622         goto skip_children;
3623         }
3624     } else if (cur-&gt;type == XML_TEXT_NODE) {
3625         if (IS_BLANK_NODE(cur)) {
3626         if (xmlNodeGetSpacePreserve(cur-&gt;parent) != 1) {
3627             deleteNode = cur;
3628         }
3629         } else if ((cur-&gt;content != NULL) &amp;&amp; (internalize) &amp;&amp;
3630                    (!xmlDictOwns(style-&gt;dict, cur-&gt;content))) {
3631         xmlChar *tmp;
3632 
3633         /*
3634          * internalize the text string, goal is to speed
3635          * up operations and minimize used space by compiled
3636          * stylesheets.
3637          */
3638         tmp = (xmlChar *) xmlDictLookup(style-&gt;dict, cur-&gt;content, -1);
3639         xmlNodeSetContent(cur, NULL);
3640         cur-&gt;content = tmp;
3641         }
3642     } else if ((cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3643            (cur-&gt;type != XML_CDATA_SECTION_NODE)) {
3644         deleteNode = cur;
3645         goto skip_children;
3646     }
3647 
3648     /*
3649      * Skip to next node. In case of a namespaced element children of
3650      * the stylesheet and not in the XSLT namespace and not an extension
3651      * element, ignore its content.
3652      */
3653     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
3654         (styleelem != NULL) &amp;&amp; (cur-&gt;parent == styleelem) &amp;&amp;
3655         (!xmlStrEqual(cur-&gt;ns-&gt;href, XSLT_NAMESPACE)) &amp;&amp;
3656         (!xsltCheckExtURI(style, cur-&gt;ns-&gt;href))) {
3657         goto skip_children;
3658     } else if (cur-&gt;children != NULL) {
3659         if ((cur-&gt;children-&gt;type != XML_ENTITY_DECL) &amp;&amp;
3660         (cur-&gt;children-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
3661         (cur-&gt;children-&gt;type != XML_ENTITY_NODE)) {
3662         cur = cur-&gt;children;
3663         continue;
3664         }
3665     }
3666 
3667 skip_children:
3668     if (cur-&gt;next != NULL) {
3669         cur = cur-&gt;next;
3670         continue;
3671     }
3672     do {
3673 
3674         cur = cur-&gt;parent;
3675         if (cur == NULL)
3676         break;
3677         if (cur == (xmlNodePtr) style-&gt;doc) {
3678         cur = NULL;
3679         break;
3680         }
3681         if (cur-&gt;next != NULL) {
3682         cur = cur-&gt;next;
3683         break;
3684         }
3685     } while (cur != NULL);
3686     }
3687     if (deleteNode != NULL) {
3688 #ifdef WITH_XSLT_DEBUG_PARSING
3689     xsltGenericDebug(xsltGenericDebugContext,
3690      &quot;xsltPreprocessStylesheet: removing ignorable blank node\n&quot;);
3691 #endif
3692     xmlUnlinkNode(deleteNode);
3693     xmlFreeNode(deleteNode);
3694     }
3695 }
3696 #endif /* end of else XSLT_REFACTORED */
3697 
3698 /**
3699  * xsltGatherNamespaces:
3700  * @style:  the XSLT stylesheet
3701  *
3702  * Browse the stylesheet and build the namspace hash table which
3703  * will be used for XPath interpretation. If needed do a bit of normalization
3704  */
3705 
3706 static void
3707 xsltGatherNamespaces(xsltStylesheetPtr style) {
3708     xmlNodePtr cur;
3709     const xmlChar *URI;
3710 
3711     if (style == NULL)
3712         return;
3713     /*
3714      * TODO: basically if the stylesheet uses the same prefix for different
3715      *       patterns, well they may be in problem, hopefully they will get
3716      *       a warning first.
3717      */
3718     /*
3719     * TODO: Eliminate the use of the hash for XPath expressions.
3720     *   An expression should be evaluated in the context of the in-scope
3721     *   namespaces; eliminate the restriction of an XML document to contain
3722     *   no duplicate prefixes for different namespace names.
3723     *
3724     */
3725     cur = xmlDocGetRootElement(style-&gt;doc);
3726     while (cur != NULL) {
3727     if (cur-&gt;type == XML_ELEMENT_NODE) {
3728         xmlNsPtr ns = cur-&gt;nsDef;
3729         while (ns != NULL) {
3730         if (ns-&gt;prefix != NULL) {
3731             if (style-&gt;nsHash == NULL) {
3732             style-&gt;nsHash = xmlHashCreate(10);
3733             if (style-&gt;nsHash == NULL) {
3734                 xsltTransformError(NULL, style, cur,
3735          &quot;xsltGatherNamespaces: failed to create hash table\n&quot;);
3736                 style-&gt;errors++;
3737                 return;
3738             }
3739             }
3740             URI = xmlHashLookup(style-&gt;nsHash, ns-&gt;prefix);
3741             if ((URI != NULL) &amp;&amp; (!xmlStrEqual(URI, ns-&gt;href))) {
3742             xsltTransformError(NULL, style, cur,
3743          &quot;Namespaces prefix %s used for multiple namespaces\n&quot;,ns-&gt;prefix);
3744             style-&gt;warnings++;
3745             } else if (URI == NULL) {
3746             xmlHashUpdateEntry(style-&gt;nsHash, ns-&gt;prefix,
3747                 (void *) ns-&gt;href, NULL);
3748 
3749 #ifdef WITH_XSLT_DEBUG_PARSING
3750             xsltGenericDebug(xsltGenericDebugContext,
3751          &quot;Added namespace: %s mapped to %s\n&quot;, ns-&gt;prefix, ns-&gt;href);
3752 #endif
3753             }
3754         }
3755         ns = ns-&gt;next;
3756         }
3757     }
3758 
3759     /*
3760      * Skip to next node
3761      */
3762     if (cur-&gt;children != NULL) {
3763         if (cur-&gt;children-&gt;type != XML_ENTITY_DECL) {
3764         cur = cur-&gt;children;
3765         continue;
3766         }
3767     }
3768     if (cur-&gt;next != NULL) {
3769         cur = cur-&gt;next;
3770         continue;
3771     }
3772 
3773     do {
3774         cur = cur-&gt;parent;
3775         if (cur == NULL)
3776         break;
3777         if (cur == (xmlNodePtr) style-&gt;doc) {
3778         cur = NULL;
3779         break;
3780         }
3781         if (cur-&gt;next != NULL) {
3782         cur = cur-&gt;next;
3783         break;
3784         }
3785     } while (cur != NULL);
3786     }
3787 }
3788 
3789 #ifdef XSLT_REFACTORED
3790 
3791 static xsltStyleType
3792 xsltGetXSLTElementTypeByNode(xsltCompilerCtxtPtr cctxt,
3793                  xmlNodePtr node)
3794 {
3795     if ((node == NULL) || (node-&gt;type != XML_ELEMENT_NODE) ||
3796     (node-&gt;name == NULL))
3797     return(0);
3798 
3799     if (node-&gt;name[0] == &#39;a&#39;) {
3800     if (IS_XSLT_NAME(node, &quot;apply-templates&quot;))
3801         return(XSLT_FUNC_APPLYTEMPLATES);
3802     else if (IS_XSLT_NAME(node, &quot;attribute&quot;))
3803         return(XSLT_FUNC_ATTRIBUTE);
3804     else if (IS_XSLT_NAME(node, &quot;apply-imports&quot;))
3805         return(XSLT_FUNC_APPLYIMPORTS);
3806     else if (IS_XSLT_NAME(node, &quot;attribute-set&quot;))
3807         return(0);
3808 
3809     } else if (node-&gt;name[0] == &#39;c&#39;) {
3810     if (IS_XSLT_NAME(node, &quot;choose&quot;))
3811         return(XSLT_FUNC_CHOOSE);
3812     else if (IS_XSLT_NAME(node, &quot;copy&quot;))
3813         return(XSLT_FUNC_COPY);
3814     else if (IS_XSLT_NAME(node, &quot;copy-of&quot;))
3815         return(XSLT_FUNC_COPYOF);
3816     else if (IS_XSLT_NAME(node, &quot;call-template&quot;))
3817         return(XSLT_FUNC_CALLTEMPLATE);
3818     else if (IS_XSLT_NAME(node, &quot;comment&quot;))
3819         return(XSLT_FUNC_COMMENT);
3820 
3821     } else if (node-&gt;name[0] == &#39;d&#39;) {
3822     if (IS_XSLT_NAME(node, &quot;document&quot;))
3823         return(XSLT_FUNC_DOCUMENT);
3824     else if (IS_XSLT_NAME(node, &quot;decimal-format&quot;))
3825         return(0);
3826 
3827     } else if (node-&gt;name[0] == &#39;e&#39;) {
3828     if (IS_XSLT_NAME(node, &quot;element&quot;))
3829         return(XSLT_FUNC_ELEMENT);
3830 
3831     } else if (node-&gt;name[0] == &#39;f&#39;) {
3832     if (IS_XSLT_NAME(node, &quot;for-each&quot;))
3833         return(XSLT_FUNC_FOREACH);
3834     else if (IS_XSLT_NAME(node, &quot;fallback&quot;))
3835         return(XSLT_FUNC_FALLBACK);
3836 
3837     } else if (*(node-&gt;name) == &#39;i&#39;) {
3838     if (IS_XSLT_NAME(node, &quot;if&quot;))
3839         return(XSLT_FUNC_IF);
3840     else if (IS_XSLT_NAME(node, &quot;include&quot;))
3841         return(0);
3842     else if (IS_XSLT_NAME(node, &quot;import&quot;))
3843         return(0);
3844 
3845     } else if (*(node-&gt;name) == &#39;k&#39;) {
3846     if (IS_XSLT_NAME(node, &quot;key&quot;))
3847         return(0);
3848 
3849     } else if (*(node-&gt;name) == &#39;m&#39;) {
3850     if (IS_XSLT_NAME(node, &quot;message&quot;))
3851         return(XSLT_FUNC_MESSAGE);
3852 
3853     } else if (*(node-&gt;name) == &#39;n&#39;) {
3854     if (IS_XSLT_NAME(node, &quot;number&quot;))
3855         return(XSLT_FUNC_NUMBER);
3856     else if (IS_XSLT_NAME(node, &quot;namespace-alias&quot;))
3857         return(0);
3858 
3859     } else if (*(node-&gt;name) == &#39;o&#39;) {
3860     if (IS_XSLT_NAME(node, &quot;otherwise&quot;))
3861         return(XSLT_FUNC_OTHERWISE);
3862     else if (IS_XSLT_NAME(node, &quot;output&quot;))
3863         return(0);
3864 
3865     } else if (*(node-&gt;name) == &#39;p&#39;) {
3866     if (IS_XSLT_NAME(node, &quot;param&quot;))
3867         return(XSLT_FUNC_PARAM);
3868     else if (IS_XSLT_NAME(node, &quot;processing-instruction&quot;))
3869         return(XSLT_FUNC_PI);
3870     else if (IS_XSLT_NAME(node, &quot;preserve-space&quot;))
3871         return(0);
3872 
3873     } else if (*(node-&gt;name) == &#39;s&#39;) {
3874     if (IS_XSLT_NAME(node, &quot;sort&quot;))
3875         return(XSLT_FUNC_SORT);
3876     else if (IS_XSLT_NAME(node, &quot;strip-space&quot;))
3877         return(0);
3878     else if (IS_XSLT_NAME(node, &quot;stylesheet&quot;))
3879         return(0);
3880 
3881     } else if (node-&gt;name[0] == &#39;t&#39;) {
3882     if (IS_XSLT_NAME(node, &quot;text&quot;))
3883         return(XSLT_FUNC_TEXT);
3884     else if (IS_XSLT_NAME(node, &quot;template&quot;))
3885         return(0);
3886     else if (IS_XSLT_NAME(node, &quot;transform&quot;))
3887         return(0);
3888 
3889     } else if (*(node-&gt;name) == &#39;v&#39;) {
3890     if (IS_XSLT_NAME(node, &quot;value-of&quot;))
3891         return(XSLT_FUNC_VALUEOF);
3892     else if (IS_XSLT_NAME(node, &quot;variable&quot;))
3893         return(XSLT_FUNC_VARIABLE);
3894 
3895     } else if (*(node-&gt;name) == &#39;w&#39;) {
3896     if (IS_XSLT_NAME(node, &quot;when&quot;))
3897         return(XSLT_FUNC_WHEN);
3898     if (IS_XSLT_NAME(node, &quot;with-param&quot;))
3899         return(XSLT_FUNC_WITHPARAM);
3900     }
3901     return(0);
3902 }
3903 
3904 /**
3905  * xsltParseAnyXSLTElem:
3906  *
3907  * @cctxt: the compilation context
3908  * @elem: the element node of the XSLT instruction
3909  *
3910  * Parses, validates the content models and compiles XSLT instructions.
3911  *
3912  * Returns 0 if everything&#39;s fine;
3913  *         -1 on API or internal errors.
3914  */
3915 int
3916 xsltParseAnyXSLTElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr elem)
3917 {
3918     if ((cctxt == NULL) || (elem == NULL) ||
3919     (elem-&gt;type != XML_ELEMENT_NODE))
3920     return(-1);
3921 
3922     elem-&gt;psvi = NULL;
3923 
3924     if (! (IS_XSLT_ELEM_FAST(elem)))
3925     return(-1);
3926     /*
3927     * Detection of handled content of extension instructions.
3928     */
3929     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
3930     cctxt-&gt;inode-&gt;extContentHandled = 1;
3931     }
3932 
3933     xsltCompilerNodePush(cctxt, elem);
3934     /*
3935     * URGENT TODO: Find a way to speed up this annoying redundant
3936     *  textual node-name and namespace comparison.
3937     */
3938     if (cctxt-&gt;inode-&gt;prev-&gt;curChildType != 0)
3939     cctxt-&gt;inode-&gt;type = cctxt-&gt;inode-&gt;prev-&gt;curChildType;
3940     else
3941     cctxt-&gt;inode-&gt;type = xsltGetXSLTElementTypeByNode(cctxt, elem);
3942     /*
3943     * Update the in-scope namespaces if needed.
3944     */
3945     if (elem-&gt;nsDef != NULL)
3946     cctxt-&gt;inode-&gt;inScopeNs =
3947         xsltCompilerBuildInScopeNsList(cctxt, elem);
3948     /*
3949     * xsltStylePreCompute():
3950     *  This will compile the information found on the current
3951     *  element&#39;s attributes. NOTE that this won&#39;t process the
3952     *  children of the instruction.
3953     */
3954     xsltStylePreCompute(cctxt-&gt;style, elem);
3955     /*
3956     * TODO: How to react on errors in xsltStylePreCompute() ?
3957     */
3958 
3959     /*
3960     * Validate the content model of the XSLT-element.
3961     */
3962     switch (cctxt-&gt;inode-&gt;type) {
3963     case XSLT_FUNC_APPLYIMPORTS:
3964         /* EMPTY */
3965         goto empty_content;
3966     case XSLT_FUNC_APPLYTEMPLATES:
3967         /* &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt; */
3968         goto apply_templates;
3969     case XSLT_FUNC_ATTRIBUTE:
3970         /* &lt;!-- Content: template --&gt; */
3971         goto sequence_constructor;
3972     case XSLT_FUNC_CALLTEMPLATE:
3973         /* &lt;!-- Content: xsl:with-param* --&gt; */
3974         goto call_template;
3975     case XSLT_FUNC_CHOOSE:
3976         /* &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt; */
3977         goto choose;
3978     case XSLT_FUNC_COMMENT:
3979         /* &lt;!-- Content: template --&gt; */
3980         goto sequence_constructor;
3981     case XSLT_FUNC_COPY:
3982         /* &lt;!-- Content: template --&gt; */
3983         goto sequence_constructor;
3984     case XSLT_FUNC_COPYOF:
3985         /* EMPTY */
3986         goto empty_content;
3987     case XSLT_FUNC_DOCUMENT: /* Extra one */
3988         /* ?? template ?? */
3989         goto sequence_constructor;
3990     case XSLT_FUNC_ELEMENT:
3991         /* &lt;!-- Content: template --&gt; */
3992         goto sequence_constructor;
3993     case XSLT_FUNC_FALLBACK:
3994         /* &lt;!-- Content: template --&gt; */
3995         goto sequence_constructor;
3996     case XSLT_FUNC_FOREACH:
3997         /* &lt;!-- Content: (xsl:sort*, template) --&gt; */
3998         goto for_each;
3999     case XSLT_FUNC_IF:
4000         /* &lt;!-- Content: template --&gt; */
4001         goto sequence_constructor;
4002     case XSLT_FUNC_OTHERWISE:
4003         /* &lt;!-- Content: template --&gt; */
4004         goto sequence_constructor;
4005     case XSLT_FUNC_MESSAGE:
4006         /* &lt;!-- Content: template --&gt; */
4007         goto sequence_constructor;
4008     case XSLT_FUNC_NUMBER:
4009         /* EMPTY */
4010         goto empty_content;
4011     case XSLT_FUNC_PARAM:
4012         /*
4013         * Check for redefinition.
4014         */
4015         if ((elem-&gt;psvi != NULL) &amp;&amp; (cctxt-&gt;ivar != NULL)) {
4016         xsltVarInfoPtr ivar = cctxt-&gt;ivar;
4017 
4018         do {
4019             if ((ivar-&gt;name ==
4020              ((xsltStyleItemParamPtr) elem-&gt;psvi)-&gt;name) &amp;&amp;
4021             (ivar-&gt;nsName ==
4022              ((xsltStyleItemParamPtr) elem-&gt;psvi)-&gt;ns))
4023             {
4024             elem-&gt;psvi = NULL;
4025             xsltTransformError(NULL, cctxt-&gt;style, elem,
4026                 &quot;Redefinition of variable or parameter &#39;%s&#39;.\n&quot;,
4027                 ivar-&gt;name);
4028             cctxt-&gt;style-&gt;errors++;
4029             goto error;
4030             }
4031             ivar = ivar-&gt;prev;
4032         } while (ivar != NULL);
4033         }
4034         /*  &lt;!-- Content: template --&gt; */
4035         goto sequence_constructor;
4036     case XSLT_FUNC_PI:
4037         /*  &lt;!-- Content: template --&gt; */
4038         goto sequence_constructor;
4039     case XSLT_FUNC_SORT:
4040         /* EMPTY */
4041         goto empty_content;
4042     case XSLT_FUNC_TEXT:
4043         /* &lt;!-- Content: #PCDATA --&gt; */
4044         goto text;
4045     case XSLT_FUNC_VALUEOF:
4046         /* EMPTY */
4047         goto empty_content;
4048     case XSLT_FUNC_VARIABLE:
4049         /*
4050         * Check for redefinition.
4051         */
4052         if ((elem-&gt;psvi != NULL) &amp;&amp; (cctxt-&gt;ivar != NULL)) {
4053         xsltVarInfoPtr ivar = cctxt-&gt;ivar;
4054 
4055         do {
4056             if ((ivar-&gt;name ==
4057              ((xsltStyleItemVariablePtr) elem-&gt;psvi)-&gt;name) &amp;&amp;
4058             (ivar-&gt;nsName ==
4059              ((xsltStyleItemVariablePtr) elem-&gt;psvi)-&gt;ns))
4060             {
4061             elem-&gt;psvi = NULL;
4062             xsltTransformError(NULL, cctxt-&gt;style, elem,
4063                 &quot;Redefinition of variable or parameter &#39;%s&#39;.\n&quot;,
4064                 ivar-&gt;name);
4065             cctxt-&gt;style-&gt;errors++;
4066             goto error;
4067             }
4068             ivar = ivar-&gt;prev;
4069         } while (ivar != NULL);
4070         }
4071         /* &lt;!-- Content: template --&gt; */
4072         goto sequence_constructor;
4073     case XSLT_FUNC_WHEN:
4074         /* &lt;!-- Content: template --&gt; */
4075         goto sequence_constructor;
4076     case XSLT_FUNC_WITHPARAM:
4077         /* &lt;!-- Content: template --&gt; */
4078         goto sequence_constructor;
4079     default:
4080 #ifdef WITH_XSLT_DEBUG_PARSING
4081         xsltGenericDebug(xsltGenericDebugContext,
4082         &quot;xsltParseXSLTNode: Unhandled XSLT element &#39;%s&#39;.\n&quot;,
4083         elem-&gt;name);
4084 #endif
4085         xsltTransformError(NULL, cctxt-&gt;style, elem,
4086         &quot;xsltParseXSLTNode: Internal error; &quot;
4087         &quot;unhandled XSLT element &#39;%s&#39;.\n&quot;, elem-&gt;name);
4088         cctxt-&gt;style-&gt;errors++;
4089         goto internal_err;
4090     }
4091 
4092 apply_templates:
4093     /* &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt; */
4094     if (elem-&gt;children != NULL) {
4095     xmlNodePtr child = elem-&gt;children;
4096     do {
4097         if (child-&gt;type == XML_ELEMENT_NODE) {
4098         if (IS_XSLT_ELEM_FAST(child)) {
4099             if (xmlStrEqual(child-&gt;name, BAD_CAST &quot;with-param&quot;)) {
4100             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WITHPARAM;
4101             xsltParseAnyXSLTElem(cctxt, child);
4102             } else if (xmlStrEqual(child-&gt;name, BAD_CAST &quot;sort&quot;)) {
4103             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_SORT;
4104             xsltParseAnyXSLTElem(cctxt, child);
4105             } else
4106             xsltParseContentError(cctxt-&gt;style, child);
4107         } else
4108             xsltParseContentError(cctxt-&gt;style, child);
4109         }
4110         child = child-&gt;next;
4111     } while (child != NULL);
4112     }
4113     goto exit;
4114 
4115 call_template:
4116     /* &lt;!-- Content: xsl:with-param* --&gt; */
4117     if (elem-&gt;children != NULL) {
4118     xmlNodePtr child = elem-&gt;children;
4119     do {
4120         if (child-&gt;type == XML_ELEMENT_NODE) {
4121         if (IS_XSLT_ELEM_FAST(child)) {
4122             xsltStyleType type;
4123 
4124             type = xsltGetXSLTElementTypeByNode(cctxt, child);
4125             if (type == XSLT_FUNC_WITHPARAM) {
4126             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WITHPARAM;
4127             xsltParseAnyXSLTElem(cctxt, child);
4128             } else {
4129             xsltParseContentError(cctxt-&gt;style, child);
4130             }
4131         } else
4132             xsltParseContentError(cctxt-&gt;style, child);
4133         }
4134         child = child-&gt;next;
4135     } while (child != NULL);
4136     }
4137     goto exit;
4138 
4139 text:
4140     if (elem-&gt;children != NULL) {
4141     xmlNodePtr child = elem-&gt;children;
4142     do {
4143         if ((child-&gt;type != XML_TEXT_NODE) &amp;&amp;
4144         (child-&gt;type != XML_CDATA_SECTION_NODE))
4145         {
4146         xsltTransformError(NULL, cctxt-&gt;style, elem,
4147             &quot;The XSLT &#39;text&#39; element must have only character &quot;
4148             &quot;data as content.\n&quot;);
4149         }
4150         child = child-&gt;next;
4151     } while (child != NULL);
4152     }
4153     goto exit;
4154 
4155 empty_content:
4156     if (elem-&gt;children != NULL) {
4157     xmlNodePtr child = elem-&gt;children;
4158     /*
4159     * Relaxed behaviour: we will allow whitespace-only text-nodes.
4160     */
4161     do {
4162         if (((child-&gt;type != XML_TEXT_NODE) &amp;&amp;
4163          (child-&gt;type != XML_CDATA_SECTION_NODE)) ||
4164         (! IS_BLANK_NODE(child)))
4165         {
4166         xsltTransformError(NULL, cctxt-&gt;style, elem,
4167             &quot;This XSLT element must have no content.\n&quot;);
4168         cctxt-&gt;style-&gt;errors++;
4169         break;
4170         }
4171         child = child-&gt;next;
4172     } while (child != NULL);
4173     }
4174     goto exit;
4175 
4176 choose:
4177     /* &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt; */
4178     /*
4179     * TODO: text-nodes in between are *not* allowed in XSLT 1.0.
4180     *   The old behaviour did not check this.
4181     * NOTE: In XSLT 2.0 they are stripped beforehand
4182     *  if whitespace-only (regardless of xml:space).
4183     */
4184     if (elem-&gt;children != NULL) {
4185     xmlNodePtr child = elem-&gt;children;
4186     int nbWhen = 0, nbOtherwise = 0, err = 0;
4187     do {
4188         if (child-&gt;type == XML_ELEMENT_NODE) {
4189         if (IS_XSLT_ELEM_FAST(child)) {
4190             xsltStyleType type;
4191 
4192             type = xsltGetXSLTElementTypeByNode(cctxt, child);
4193             if (type == XSLT_FUNC_WHEN) {
4194             nbWhen++;
4195             if (nbOtherwise) {
4196                 xsltParseContentError(cctxt-&gt;style, child);
4197                 err = 1;
4198                 break;
4199             }
4200             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_WHEN;
4201             xsltParseAnyXSLTElem(cctxt, child);
4202             } else if (type == XSLT_FUNC_OTHERWISE) {
4203             if (! nbWhen) {
4204                 xsltParseContentError(cctxt-&gt;style, child);
4205                 err = 1;
4206                 break;
4207             }
4208             if (nbOtherwise) {
4209                 xsltTransformError(NULL, cctxt-&gt;style, elem,
4210                 &quot;The XSLT &#39;choose&#39; element must not contain &quot;
4211                 &quot;more than one XSLT &#39;otherwise&#39; element.\n&quot;);
4212                 cctxt-&gt;style-&gt;errors++;
4213                 err = 1;
4214                 break;
4215             }
4216             nbOtherwise++;
4217             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_OTHERWISE;
4218             xsltParseAnyXSLTElem(cctxt, child);
4219             } else
4220             xsltParseContentError(cctxt-&gt;style, child);
4221         } else
4222             xsltParseContentError(cctxt-&gt;style, child);
4223         }
4224         /*
4225         else
4226             xsltParseContentError(cctxt, child);
4227         */
4228         child = child-&gt;next;
4229     } while (child != NULL);
4230     if ((! err) &amp;&amp; (! nbWhen)) {
4231         xsltTransformError(NULL, cctxt-&gt;style, elem,
4232         &quot;The XSLT element &#39;choose&#39; must contain at least one &quot;
4233         &quot;XSLT element &#39;when&#39;.\n&quot;);
4234         cctxt-&gt;style-&gt;errors++;
4235     }
4236     }
4237     goto exit;
4238 
4239 for_each:
4240     /* &lt;!-- Content: (xsl:sort*, template) --&gt; */
4241     /*
4242     * NOTE: Text-nodes before xsl:sort are *not* allowed in XSLT 1.0.
4243     *   The old behaviour did not allow this, but it catched this
4244     *   only at transformation-time.
4245     *   In XSLT 2.0 they are stripped beforehand if whitespace-only
4246     *   (regardless of xml:space).
4247     */
4248     if (elem-&gt;children != NULL) {
4249     xmlNodePtr child = elem-&gt;children;
4250     /*
4251     * Parse xsl:sort first.
4252     */
4253     do {
4254         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4255         IS_XSLT_ELEM_FAST(child))
4256         {
4257         if (xsltGetXSLTElementTypeByNode(cctxt, child) ==
4258             XSLT_FUNC_SORT)
4259         {
4260             cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_SORT;
4261             xsltParseAnyXSLTElem(cctxt, child);
4262         } else
4263             break;
4264         } else
4265         break;
4266         child = child-&gt;next;
4267     } while (child != NULL);
4268     /*
4269     * Parse the sequece constructor.
4270     */
4271     if (child != NULL)
4272         xsltParseSequenceConstructor(cctxt, child);
4273     }
4274     goto exit;
4275 
4276 sequence_constructor:
4277     /*
4278     * Parse the sequence constructor.
4279     */
4280     if (elem-&gt;children != NULL)
4281     xsltParseSequenceConstructor(cctxt, elem-&gt;children);
4282 
4283     /*
4284     * Register information for vars/params. Only needed if there
4285     * are any following siblings.
4286     */
4287     if ((elem-&gt;next != NULL) &amp;&amp;
4288     ((cctxt-&gt;inode-&gt;type == XSLT_FUNC_VARIABLE) ||
4289      (cctxt-&gt;inode-&gt;type == XSLT_FUNC_PARAM)))
4290     {
4291     if ((elem-&gt;psvi != NULL) &amp;&amp;
4292         (((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;name))
4293     {
4294         xsltCompilerVarInfoPush(cctxt, elem,
4295         ((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;name,
4296         ((xsltStyleBasicItemVariablePtr) elem-&gt;psvi)-&gt;ns);
4297     }
4298     }
4299 
4300 error:
4301 exit:
4302     xsltCompilerNodePop(cctxt, elem);
4303     return(0);
4304 
4305 internal_err:
4306     xsltCompilerNodePop(cctxt, elem);
4307     return(-1);
4308 }
4309 
4310 /**
4311  * xsltForwardsCompatUnkownItemCreate:
4312  *
4313  * @cctxt: the compilation context
4314  *
4315  * Creates a compiled representation of the unknown
4316  * XSLT instruction.
4317  *
4318  * Returns the compiled representation.
4319  */
4320 static xsltStyleItemUknownPtr
4321 xsltForwardsCompatUnkownItemCreate(xsltCompilerCtxtPtr cctxt)
4322 {
4323     xsltStyleItemUknownPtr item;
4324 
4325     item = (xsltStyleItemUknownPtr) xmlMalloc(sizeof(xsltStyleItemUknown));
4326     if (item == NULL) {
4327     xsltTransformError(NULL, cctxt-&gt;style, NULL,
4328         &quot;Internal error in xsltForwardsCompatUnkownItemCreate(): &quot;
4329         &quot;Failed to allocate memory.\n&quot;);
4330     cctxt-&gt;style-&gt;errors++;
4331     return(NULL);
4332     }
4333     memset(item, 0, sizeof(xsltStyleItemUknown));
4334     item-&gt;type = XSLT_FUNC_UNKOWN_FORWARDS_COMPAT;
4335     /*
4336     * Store it in the stylesheet.
4337     */
4338     item-&gt;next = cctxt-&gt;style-&gt;preComps;
4339     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
4340     return(item);
4341 }
4342 
4343 /**
4344  * xsltParseUnknownXSLTElem:
4345  *
4346  * @cctxt: the compilation context
4347  * @node: the element of the unknown XSLT instruction
4348  *
4349  * Parses an unknown XSLT element.
4350  * If forwards compatible mode is enabled this will allow
4351  * such an unknown XSLT and; otherwise it is rejected.
4352  *
4353  * Returns 1 in the unknown XSLT instruction is rejected,
4354  *         0 if everything&#39;s fine and
4355  *         -1 on API or internal errors.
4356  */
4357 static int
4358 xsltParseUnknownXSLTElem(xsltCompilerCtxtPtr cctxt,
4359                 xmlNodePtr node)
4360 {
4361     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
4362     return(-1);
4363 
4364     /*
4365     * Detection of handled content of extension instructions.
4366     */
4367     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4368     cctxt-&gt;inode-&gt;extContentHandled = 1;
4369     }
4370     if (cctxt-&gt;inode-&gt;forwardsCompat == 0) {
4371     /*
4372     * We are not in forwards-compatible mode, so raise an error.
4373     */
4374     xsltTransformError(NULL, cctxt-&gt;style, node,
4375         &quot;Unknown XSLT element &#39;%s&#39;.\n&quot;, node-&gt;name);
4376     cctxt-&gt;style-&gt;errors++;
4377     return(1);
4378     }
4379     /*
4380     * Forwards-compatible mode.
4381     * ------------------------
4382     *
4383     * Parse/compile xsl:fallback elements.
4384     *
4385     * QUESTION: Do we have to raise an error if there&#39;s no xsl:fallback?
4386     * ANSWER: No, since in the stylesheet the fallback behaviour might
4387     *  also be provided by using the XSLT function &quot;element-available&quot;.
4388     */
4389     if (cctxt-&gt;unknownItem == NULL) {
4390     /*
4391     * Create a singleton for all unknown XSLT instructions.
4392     */
4393     cctxt-&gt;unknownItem = xsltForwardsCompatUnkownItemCreate(cctxt);
4394     if (cctxt-&gt;unknownItem == NULL) {
4395         node-&gt;psvi = NULL;
4396         return(-1);
4397     }
4398     }
4399     node-&gt;psvi = cctxt-&gt;unknownItem;
4400     if (node-&gt;children == NULL)
4401     return(0);
4402     else {
4403     xmlNodePtr child = node-&gt;children;
4404 
4405     xsltCompilerNodePush(cctxt, node);
4406     /*
4407     * Update the in-scope namespaces if needed.
4408     */
4409     if (node-&gt;nsDef != NULL)
4410         cctxt-&gt;inode-&gt;inScopeNs =
4411         xsltCompilerBuildInScopeNsList(cctxt, node);
4412     /*
4413     * Parse all xsl:fallback children.
4414     */
4415     do {
4416         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4417         IS_XSLT_ELEM_FAST(child) &amp;&amp;
4418         IS_XSLT_NAME(child, &quot;fallback&quot;))
4419         {
4420         cctxt-&gt;inode-&gt;curChildType = XSLT_FUNC_FALLBACK;
4421         xsltParseAnyXSLTElem(cctxt, child);
4422         }
4423         child = child-&gt;next;
4424     } while (child != NULL);
4425 
4426     xsltCompilerNodePop(cctxt, node);
4427     }
4428     return(0);
4429 }
4430 
4431 /**
4432  * xsltParseSequenceConstructor:
4433  *
4434  * @cctxt: the compilation context
4435  * @cur: the start-node of the content to be parsed
4436  *
4437  * Parses a &quot;template&quot; content (or &quot;sequence constructor&quot; in XSLT 2.0 terms).
4438  * This will additionally remove xsl:text elements from the tree.
4439  */
4440 void
4441 xsltParseSequenceConstructor(xsltCompilerCtxtPtr cctxt, xmlNodePtr cur)
4442 {
4443     xsltStyleType type;
4444     xmlNodePtr deleteNode = NULL;
4445 
4446     if (cctxt == NULL) {
4447     xmlGenericError(xmlGenericErrorContext,
4448         &quot;xsltParseSequenceConstructor: Bad arguments\n&quot;);
4449     cctxt-&gt;style-&gt;errors++;
4450     return;
4451     }
4452     /*
4453     * Detection of handled content of extension instructions.
4454     */
4455     if (cctxt-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4456     cctxt-&gt;inode-&gt;extContentHandled = 1;
4457     }
4458     if ((cur == NULL) || (cur-&gt;type == XML_NAMESPACE_DECL))
4459     return;
4460     /*
4461     * This is the content reffered to as a &quot;template&quot;.
4462     * E.g. an xsl:element has such content model:
4463     * &lt;xsl:element
4464     *   name = { qname }
4465     *   namespace = { uri-reference }
4466     *   use-attribute-sets = qnames&gt;
4467     * &lt;!-- Content: template --&gt;
4468     *
4469     * NOTE that in XSLT-2 the term &quot;template&quot; was abandoned due to
4470     *  confusion with xsl:template and the term &quot;sequence constructor&quot;
4471     *  was introduced instead.
4472     *
4473     * The following XSLT-instructions are allowed to appear:
4474     *  xsl:apply-templates, xsl:call-template, xsl:apply-imports,
4475     *  xsl:for-each, xsl:value-of, xsl:copy-of, xsl:number,
4476     *  xsl:choose, xsl:if, xsl:text, xsl:copy, xsl:variable,
4477     *  xsl:message, xsl:fallback,
4478     *  xsl:processing-instruction, xsl:comment, xsl:element
4479     *  xsl:attribute.
4480     * Additional allowed content:
4481     * 1) extension instructions
4482     * 2) literal result elements
4483     * 3) PCDATA
4484     *
4485     * NOTE that this content model does *not* allow xsl:param.
4486     */
4487     while (cur != NULL) {
4488     if (deleteNode != NULL) {
4489 #ifdef WITH_XSLT_DEBUG_BLANKS
4490         xsltGenericDebug(xsltGenericDebugContext,
4491          &quot;xsltParseSequenceConstructor: removing xsl:text element\n&quot;);
4492 #endif
4493         xmlUnlinkNode(deleteNode);
4494         xmlFreeNode(deleteNode);
4495         deleteNode = NULL;
4496     }
4497     if (cur-&gt;type == XML_ELEMENT_NODE) {
4498 
4499         if (cur-&gt;psvi == xsltXSLTTextMarker) {
4500         /*
4501         * xsl:text elements
4502         * --------------------------------------------------------
4503         */
4504         xmlNodePtr tmp;
4505 
4506         cur-&gt;psvi = NULL;
4507         /*
4508         * Mark the xsl:text element for later deletion.
4509         */
4510         deleteNode = cur;
4511         /*
4512         * Validate content.
4513         */
4514         tmp = cur-&gt;children;
4515         if (tmp) {
4516             /*
4517             * We don&#39;t expect more than one text-node in the
4518             * content, since we already merged adjacent
4519             * text/CDATA-nodes and eliminated PI/comment-nodes.
4520             */
4521             if ((tmp-&gt;type == XML_TEXT_NODE) ||
4522             (tmp-&gt;next == NULL))
4523             {
4524             /*
4525             * Leave the contained text-node in the tree.
4526             */
4527             xmlUnlinkNode(tmp);
4528             xmlAddPrevSibling(cur, tmp);
4529             } else {
4530             tmp = NULL;
4531             xsltTransformError(NULL, cctxt-&gt;style, cur,
4532                 &quot;Element &#39;xsl:text&#39;: Invalid type &quot;
4533                 &quot;of node found in content.\n&quot;);
4534             cctxt-&gt;style-&gt;errors++;
4535             }
4536         }
4537         if (cur-&gt;properties) {
4538             xmlAttrPtr attr;
4539             /*
4540             * TODO: We need to report errors for
4541             *  invalid attrs.
4542             */
4543             attr = cur-&gt;properties;
4544             do {
4545             if ((attr-&gt;ns == NULL) &amp;&amp;
4546                 (attr-&gt;name != NULL) &amp;&amp;
4547                 (attr-&gt;name[0] == &#39;d&#39;) &amp;&amp;
4548                 xmlStrEqual(attr-&gt;name,
4549                 BAD_CAST &quot;disable-output-escaping&quot;))
4550             {
4551                 /*
4552                 * Attr &quot;disable-output-escaping&quot;.
4553                 * XSLT-2: This attribute is deprecated.
4554                 */
4555                 if ((attr-&gt;children != NULL) &amp;&amp;
4556                 xmlStrEqual(attr-&gt;children-&gt;content,
4557                 BAD_CAST &quot;yes&quot;))
4558                 {
4559                 /*
4560                 * Disable output escaping for this
4561                 * text node.
4562                 */
4563                 if (tmp)
4564                     tmp-&gt;name = xmlStringTextNoenc;
4565                 } else if ((attr-&gt;children == NULL) ||
4566                 (attr-&gt;children-&gt;content == NULL) ||
4567                 (!xmlStrEqual(attr-&gt;children-&gt;content,
4568                 BAD_CAST &quot;no&quot;)))
4569                 {
4570                 xsltTransformError(NULL, cctxt-&gt;style,
4571                     cur,
4572                     &quot;Attribute &#39;disable-output-escaping&#39;: &quot;
4573                     &quot;Invalid value. Expected is &quot;
4574                     &quot;&#39;yes&#39; or &#39;no&#39;.\n&quot;);
4575                 cctxt-&gt;style-&gt;errors++;
4576                 }
4577                 break;
4578             }
4579             attr = attr-&gt;next;
4580             } while (attr != NULL);
4581         }
4582         } else if (IS_XSLT_ELEM_FAST(cur)) {
4583         /*
4584         * TODO: Using the XSLT-marker is still not stable yet.
4585         */
4586         /* if (cur-&gt;psvi == xsltXSLTElemMarker) { */
4587         /*
4588         * XSLT instructions
4589         * --------------------------------------------------------
4590         */
4591         cur-&gt;psvi = NULL;
4592         type = xsltGetXSLTElementTypeByNode(cctxt, cur);
4593         switch (type) {
4594             case XSLT_FUNC_APPLYIMPORTS:
4595             case XSLT_FUNC_APPLYTEMPLATES:
4596             case XSLT_FUNC_ATTRIBUTE:
4597             case XSLT_FUNC_CALLTEMPLATE:
4598             case XSLT_FUNC_CHOOSE:
4599             case XSLT_FUNC_COMMENT:
4600             case XSLT_FUNC_COPY:
4601             case XSLT_FUNC_COPYOF:
4602             case XSLT_FUNC_DOCUMENT: /* Extra one */
4603             case XSLT_FUNC_ELEMENT:
4604             case XSLT_FUNC_FALLBACK:
4605             case XSLT_FUNC_FOREACH:
4606             case XSLT_FUNC_IF:
4607             case XSLT_FUNC_MESSAGE:
4608             case XSLT_FUNC_NUMBER:
4609             case XSLT_FUNC_PI:
4610             case XSLT_FUNC_TEXT:
4611             case XSLT_FUNC_VALUEOF:
4612             case XSLT_FUNC_VARIABLE:
4613             /*
4614             * Parse the XSLT element.
4615             */
4616             cctxt-&gt;inode-&gt;curChildType = type;
4617             xsltParseAnyXSLTElem(cctxt, cur);
4618             break;
4619             default:
4620             xsltParseUnknownXSLTElem(cctxt, cur);
4621             cur = cur-&gt;next;
4622             continue;
4623         }
4624         } else {
4625         /*
4626         * Non-XSLT elements
4627         * -----------------
4628         */
4629         xsltCompilerNodePush(cctxt, cur);
4630         /*
4631         * Update the in-scope namespaces if needed.
4632         */
4633         if (cur-&gt;nsDef != NULL)
4634             cctxt-&gt;inode-&gt;inScopeNs =
4635             xsltCompilerBuildInScopeNsList(cctxt, cur);
4636         /*
4637         * The current element is either a literal result element
4638         * or an extension instruction.
4639         *
4640         * Process attr &quot;xsl:extension-element-prefixes&quot;.
4641         * FUTURE TODO: IIRC in XSLT 2.0 this attribute must be
4642         * processed by the implementor of the extension function;
4643         * i.e., it won&#39;t be handled by the XSLT processor.
4644         */
4645         /* SPEC 1.0:
4646         *   &quot;exclude-result-prefixes&quot; is only allowed on literal
4647         *   result elements and &quot;xsl:exclude-result-prefixes&quot;
4648         *   on xsl:stylesheet/xsl:transform.
4649         * SPEC 2.0:
4650         *   &quot;There are a number of standard attributes
4651         *   that may appear on any XSLT element: specifically
4652         *   version, exclude-result-prefixes,
4653         *   extension-element-prefixes, xpath-default-namespace,
4654         *   default-collation, and use-when.&quot;
4655         *
4656         * SPEC 2.0:
4657         *   For literal result elements:
4658         *   &quot;xsl:version, xsl:exclude-result-prefixes,
4659         *    xsl:extension-element-prefixes,
4660         *    xsl:xpath-default-namespace,
4661         *    xsl:default-collation, or xsl:use-when.&quot;
4662         */
4663         if (cur-&gt;properties)
4664             cctxt-&gt;inode-&gt;extElemNs =
4665             xsltParseExtElemPrefixes(cctxt,
4666                 cur, cctxt-&gt;inode-&gt;extElemNs,
4667                 XSLT_ELEMENT_CATEGORY_LRE);
4668         /*
4669         * Eval if we have an extension instruction here.
4670         */
4671         if ((cur-&gt;ns != NULL) &amp;&amp;
4672             (cctxt-&gt;inode-&gt;extElemNs != NULL) &amp;&amp;
4673             (xsltCheckExtPrefix(cctxt-&gt;style, cur-&gt;ns-&gt;href) == 1))
4674         {
4675             /*
4676             * Extension instructions
4677             * ----------------------------------------------------
4678             * Mark the node information.
4679             */
4680             cctxt-&gt;inode-&gt;category = XSLT_ELEMENT_CATEGORY_EXTENSION;
4681             cctxt-&gt;inode-&gt;extContentHandled = 0;
4682             if (cur-&gt;psvi != NULL) {
4683             cur-&gt;psvi = NULL;
4684             /*
4685             * TODO: Temporary sanity check.
4686             */
4687             xsltTransformError(NULL, cctxt-&gt;style, cur,
4688                 &quot;Internal error in xsltParseSequenceConstructor(): &quot;
4689                 &quot;Occupied PSVI field.\n&quot;);
4690             cctxt-&gt;style-&gt;errors++;
4691             cur = cur-&gt;next;
4692             continue;
4693             }
4694             cur-&gt;psvi = (void *)
4695             xsltPreComputeExtModuleElement(cctxt-&gt;style, cur);
4696 
4697             if (cur-&gt;psvi == NULL) {
4698             /*
4699             * OLD COMMENT: &quot;Unknown element, maybe registered
4700             *  at the context level. Mark it for later
4701             *  recognition.&quot;
4702             * QUESTION: What does the xsltExtMarker mean?
4703             *  ANSWER: It is used in
4704             *   xsltApplySequenceConstructor() at
4705             *   transformation-time to look out for extension
4706             *   registered in the transformation context.
4707             */
4708             cur-&gt;psvi = (void *) xsltExtMarker;
4709             }
4710             /*
4711             * BIG NOTE: Now the ugly part. In previous versions
4712             *  of Libxslt (until 1.1.16), all the content of an
4713             *  extension instruction was processed and compiled without
4714             *  the need of the extension-author to explicitely call
4715             *  such a processing;.We now need to mimic this old
4716             *  behaviour in order to avoid breaking old code
4717             *  on the extension-author&#39;s side.
4718             * The mechanism:
4719             *  1) If the author does *not* set the
4720             *    compile-time-flag @extContentHandled, then we&#39;ll
4721             *    parse the content assuming that it&#39;s a &quot;template&quot;
4722             *    (or &quot;sequence constructor in XSLT 2.0 terms).
4723             *    NOTE: If the extension is registered at
4724             *    transformation-time only, then there&#39;s no way of
4725             *    knowing that content shall be valid, and we&#39;ll
4726             *    process the content the same way.
4727             *  2) If the author *does* set the flag, then we&#39;ll assume
4728             *   that the author has handled the parsing him/herself
4729             *   (e.g. called xsltParseSequenceConstructor(), etc.
4730             *   explicitely in his/her code).
4731             */
4732             if ((cur-&gt;children != NULL) &amp;&amp;
4733             (cctxt-&gt;inode-&gt;extContentHandled == 0))
4734             {
4735             /*
4736             * Default parsing of the content using the
4737             * sequence-constructor model.
4738             */
4739             xsltParseSequenceConstructor(cctxt, cur-&gt;children);
4740             }
4741         } else {
4742             /*
4743             * Literal result element
4744             * ----------------------------------------------------
4745             * Allowed XSLT attributes:
4746             *  xsl:extension-element-prefixes CDATA #IMPLIED
4747             *  xsl:exclude-result-prefixes CDATA #IMPLIED
4748             *  TODO: xsl:use-attribute-sets %qnames; #IMPLIED
4749             *  xsl:version NMTOKEN #IMPLIED
4750             */
4751             cur-&gt;psvi = NULL;
4752             cctxt-&gt;inode-&gt;category = XSLT_ELEMENT_CATEGORY_LRE;
4753             if (cur-&gt;properties != NULL) {
4754             xmlAttrPtr attr = cur-&gt;properties;
4755             /*
4756             * Attribute &quot;xsl:exclude-result-prefixes&quot;.
4757             */
4758             cctxt-&gt;inode-&gt;exclResultNs =
4759                 xsltParseExclResultPrefixes(cctxt, cur,
4760                 cctxt-&gt;inode-&gt;exclResultNs,
4761                 XSLT_ELEMENT_CATEGORY_LRE);
4762             /*
4763             * Attribute &quot;xsl:version&quot;.
4764             */
4765             xsltParseAttrXSLTVersion(cctxt, cur,
4766                 XSLT_ELEMENT_CATEGORY_LRE);
4767             /*
4768             * Report invalid XSLT attributes.
4769             * For XSLT 1.0 only xsl:use-attribute-sets is allowed
4770             * next to xsl:version, xsl:exclude-result-prefixes and
4771             * xsl:extension-element-prefixes.
4772             *
4773             * Mark all XSLT attributes, in order to skip such
4774             * attributes when instantiating the LRE.
4775             */
4776             do {
4777                 if ((attr-&gt;psvi != xsltXSLTAttrMarker) &amp;&amp;
4778                 IS_XSLT_ATTR_FAST(attr))
4779                 {
4780                 if (! xmlStrEqual(attr-&gt;name,
4781                     BAD_CAST &quot;use-attribute-sets&quot;))
4782                 {
4783                     xsltTransformError(NULL, cctxt-&gt;style,
4784                     cur,
4785                     &quot;Unknown XSLT attribute &#39;%s&#39;.\n&quot;,
4786                     attr-&gt;name);
4787                     cctxt-&gt;style-&gt;errors++;
4788                 } else {
4789                     /*
4790                     * XSLT attr marker.
4791                     */
4792                     attr-&gt;psvi = (void *) xsltXSLTAttrMarker;
4793                 }
4794                 }
4795                 attr = attr-&gt;next;
4796             } while (attr != NULL);
4797             }
4798             /*
4799             * Create/reuse info for the literal result element.
4800             */
4801             if (cctxt-&gt;inode-&gt;nsChanged)
4802             xsltLREInfoCreate(cctxt, cur, 1);
4803             cur-&gt;psvi = cctxt-&gt;inode-&gt;litResElemInfo;
4804             /*
4805             * Apply ns-aliasing on the element and on its attributes.
4806             */
4807             if (cctxt-&gt;hasNsAliases)
4808             xsltLREBuildEffectiveNs(cctxt, cur);
4809             /*
4810             * Compile attribute value templates (AVT).
4811             */
4812             if (cur-&gt;properties) {
4813             xmlAttrPtr attr = cur-&gt;properties;
4814 
4815             while (attr != NULL) {
4816                 xsltCompileAttr(cctxt-&gt;style, attr);
4817                 attr = attr-&gt;next;
4818             }
4819             }
4820             /*
4821             * Parse the content, which is defined to be a &quot;template&quot;
4822             * (or &quot;sequence constructor&quot; in XSLT 2.0 terms).
4823             */
4824             if (cur-&gt;children != NULL) {
4825             xsltParseSequenceConstructor(cctxt, cur-&gt;children);
4826             }
4827         }
4828         /*
4829         * Leave the non-XSLT element.
4830         */
4831         xsltCompilerNodePop(cctxt, cur);
4832         }
4833     }
4834     cur = cur-&gt;next;
4835     }
4836     if (deleteNode != NULL) {
4837 #ifdef WITH_XSLT_DEBUG_BLANKS
4838     xsltGenericDebug(xsltGenericDebugContext,
4839         &quot;xsltParseSequenceConstructor: removing xsl:text element\n&quot;);
4840 #endif
4841     xmlUnlinkNode(deleteNode);
4842     xmlFreeNode(deleteNode);
4843     deleteNode = NULL;
4844     }
4845 }
4846 
4847 /**
4848  * xsltParseTemplateContent:
4849  * @style:  the XSLT stylesheet
4850  * @templ:  the node containing the content to be parsed
4851  *
4852  * Parses and compiles the content-model of an xsl:template element.
4853  * Note that this is *not* the &quot;template&quot; content model (or &quot;sequence
4854  *  constructor&quot; in XSLT 2.0); it it allows addional xsl:param
4855  *  elements as immediate children of @templ.
4856  *
4857  * Called by:
4858  *   exsltFuncFunctionComp() (EXSLT, functions.c)
4859  *   So this is intended to be called from extension functions.
4860  */
4861 void
4862 xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {
4863     if ((style == NULL) || (templ == NULL) ||
4864         (templ-&gt;type == XML_NAMESPACE_DECL))
4865     return;
4866 
4867     /*
4868     * Detection of handled content of extension instructions.
4869     */
4870     if (XSLT_CCTXT(style)-&gt;inode-&gt;category == XSLT_ELEMENT_CATEGORY_EXTENSION) {
4871     XSLT_CCTXT(style)-&gt;inode-&gt;extContentHandled = 1;
4872     }
4873 
4874     if (templ-&gt;children != NULL) {
4875     xmlNodePtr child = templ-&gt;children;
4876     /*
4877     * Process xsl:param elements, which can only occur as the
4878     * immediate children of xsl:template (well, and of any
4879     * user-defined extension instruction if needed).
4880     */
4881     do {
4882         if ((child-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4883         IS_XSLT_ELEM_FAST(child) &amp;&amp;
4884         IS_XSLT_NAME(child, &quot;param&quot;))
4885         {
4886         XSLT_CCTXT(style)-&gt;inode-&gt;curChildType = XSLT_FUNC_PARAM;
4887         xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);
4888         } else
4889         break;
4890         child = child-&gt;next;
4891     } while (child != NULL);
4892     /*
4893     * Parse the content and register the pattern.
4894     */
4895     xsltParseSequenceConstructor(XSLT_CCTXT(style), child);
4896     }
4897 }
4898 
4899 #else /* XSLT_REFACTORED */
4900 
4901 /**
4902  * xsltParseTemplateContent:
4903  * @style:  the XSLT stylesheet
4904  * @templ:  the container node (can be a document for literal results)
4905  *
4906  * parse a template content-model
4907  * Clean-up the template content from unwanted ignorable blank nodes
4908  * and process xslt:text
4909  */
4910 void
4911 xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {
4912     xmlNodePtr cur, delete;
4913 
4914     if ((style == NULL) || (templ == NULL) ||
4915         (templ-&gt;type == XML_NAMESPACE_DECL)) return;
4916 
4917     /*
4918      * This content comes from the stylesheet
4919      * For stylesheets, the set of whitespace-preserving
4920      * element names consists of just xsl:text.
4921      */
4922     cur = templ-&gt;children;
4923     delete = NULL;
4924     while (cur != NULL) {
4925     if (delete != NULL) {
4926 #ifdef WITH_XSLT_DEBUG_BLANKS
4927         xsltGenericDebug(xsltGenericDebugContext,
4928          &quot;xsltParseTemplateContent: removing text\n&quot;);
4929 #endif
4930         xmlUnlinkNode(delete);
4931         xmlFreeNode(delete);
4932         delete = NULL;
4933     }
4934     if (IS_XSLT_ELEM(cur)) {
4935             xsltStylePreCompute(style, cur);
4936 
4937         if (IS_XSLT_NAME(cur, &quot;text&quot;)) {
4938         /*
4939         * TODO: Processing of xsl:text should be moved to
4940         *   xsltPreprocessStylesheet(), since otherwise this
4941         *   will be performed for every multiply included
4942         *   stylesheet; i.e. this here is not skipped with
4943         *   the use of the style-&gt;nopreproc flag.
4944         */
4945         if (cur-&gt;children != NULL) {
4946             xmlChar *prop;
4947             xmlNodePtr text = cur-&gt;children, next;
4948             int noesc = 0;
4949 
4950             prop = xmlGetNsProp(cur,
4951             (const xmlChar *)&quot;disable-output-escaping&quot;,
4952             NULL);
4953             if (prop != NULL) {
4954 #ifdef WITH_XSLT_DEBUG_PARSING
4955             xsltGenericDebug(xsltGenericDebugContext,
4956                  &quot;Disable escaping: %s\n&quot;, text-&gt;content);
4957 #endif
4958             if (xmlStrEqual(prop, (const xmlChar *)&quot;yes&quot;)) {
4959                 noesc = 1;
4960             } else if (!xmlStrEqual(prop,
4961                         (const xmlChar *)&quot;no&quot;)){
4962                 xsltTransformError(NULL, style, cur,
4963          &quot;xsl:text: disable-output-escaping allows only yes or no\n&quot;);
4964                 style-&gt;warnings++;
4965 
4966             }
4967             xmlFree(prop);
4968             }
4969 
4970             while (text != NULL) {
4971             if (text-&gt;type == XML_COMMENT_NODE) {
4972                 text = text-&gt;next;
4973                 continue;
4974             }
4975             if ((text-&gt;type != XML_TEXT_NODE) &amp;&amp;
4976                  (text-&gt;type != XML_CDATA_SECTION_NODE)) {
4977                 xsltTransformError(NULL, style, cur,
4978          &quot;xsltParseTemplateContent: xslt:text content problem\n&quot;);
4979                 style-&gt;errors++;
4980                 break;
4981             }
4982             if ((noesc) &amp;&amp; (text-&gt;type != XML_CDATA_SECTION_NODE))
4983                 text-&gt;name = xmlStringTextNoenc;
4984             text = text-&gt;next;
4985             }
4986 
4987             /*
4988              * replace xsl:text by the list of childs
4989              */
4990             if (text == NULL) {
4991             text = cur-&gt;children;
4992             while (text != NULL) {
4993                 if ((style-&gt;internalized) &amp;&amp;
4994                     (text-&gt;content != NULL) &amp;&amp;
4995                     (!xmlDictOwns(style-&gt;dict, text-&gt;content))) {
4996 
4997                 /*
4998                  * internalize the text string
4999                  */
5000                 if (text-&gt;doc-&gt;dict != NULL) {
5001                     const xmlChar *tmp;
5002 
5003                     tmp = xmlDictLookup(text-&gt;doc-&gt;dict,
5004                                         text-&gt;content, -1);
5005                     if (tmp != text-&gt;content) {
5006                         xmlNodeSetContent(text, NULL);
5007                     text-&gt;content = (xmlChar *) tmp;
5008                     }
5009                 }
5010                 }
5011 
5012                 next = text-&gt;next;
5013                 xmlUnlinkNode(text);
5014                 xmlAddPrevSibling(cur, text);
5015                 text = next;
5016             }
5017             }
5018         }
5019         delete = cur;
5020         goto skip_children;
5021         }
5022     }
5023     else if ((cur-&gt;ns != NULL) &amp;&amp; (style-&gt;nsDefs != NULL) &amp;&amp;
5024         (xsltCheckExtPrefix(style, cur-&gt;ns-&gt;prefix)))
5025     {
5026         /*
5027          * okay this is an extension element compile it too
5028          */
5029         xsltStylePreCompute(style, cur);
5030     }
5031     else if (cur-&gt;type == XML_ELEMENT_NODE)
5032     {
5033         /*
5034          * This is an element which will be output as part of the
5035          * template exectution, precompile AVT if found.
5036          */
5037         if ((cur-&gt;ns == NULL) &amp;&amp; (style-&gt;defaultAlias != NULL)) {
5038         cur-&gt;ns = xmlSearchNsByHref(cur-&gt;doc, cur,
5039             style-&gt;defaultAlias);
5040         }
5041         if (cur-&gt;properties != NULL) {
5042             xmlAttrPtr attr = cur-&gt;properties;
5043 
5044         while (attr != NULL) {
5045             xsltCompileAttr(style, attr);
5046             attr = attr-&gt;next;
5047         }
5048         }
5049     }
5050     /*
5051      * Skip to next node
5052      */
5053     if (cur-&gt;children != NULL) {
5054         if (cur-&gt;children-&gt;type != XML_ENTITY_DECL) {
5055         cur = cur-&gt;children;
5056         continue;
5057         }
5058     }
5059 skip_children:
5060     if (cur-&gt;next != NULL) {
5061         cur = cur-&gt;next;
5062         continue;
5063     }
5064 
5065     do {
5066         cur = cur-&gt;parent;
5067         if (cur == NULL)
5068         break;
5069         if (cur == templ) {
5070         cur = NULL;
5071         break;
5072         }
5073         if (cur-&gt;next != NULL) {
5074         cur = cur-&gt;next;
5075         break;
5076         }
5077     } while (cur != NULL);
5078     }
5079     if (delete != NULL) {
5080 #ifdef WITH_XSLT_DEBUG_PARSING
5081     xsltGenericDebug(xsltGenericDebugContext,
5082      &quot;xsltParseTemplateContent: removing text\n&quot;);
5083 #endif
5084     xmlUnlinkNode(delete);
5085     xmlFreeNode(delete);
5086     delete = NULL;
5087     }
5088 
5089     /*
5090      * Skip the first params
5091      */
5092     cur = templ-&gt;children;
5093     while (cur != NULL) {
5094     if ((IS_XSLT_ELEM(cur)) &amp;&amp; (!(IS_XSLT_NAME(cur, &quot;param&quot;))))
5095         break;
5096     cur = cur-&gt;next;
5097     }
5098 
5099     /*
5100      * Browse the remainder of the template
5101      */
5102     while (cur != NULL) {
5103     if ((IS_XSLT_ELEM(cur)) &amp;&amp; (IS_XSLT_NAME(cur, &quot;param&quot;))) {
5104         xmlNodePtr param = cur;
5105 
5106         xsltTransformError(NULL, style, cur,
5107         &quot;xsltParseTemplateContent: ignoring misplaced param element\n&quot;);
5108         if (style != NULL) style-&gt;warnings++;
5109             cur = cur-&gt;next;
5110         xmlUnlinkNode(param);
5111         xmlFreeNode(param);
5112     } else
5113         break;
5114     }
5115 }
5116 
5117 #endif /* else XSLT_REFACTORED */
5118 
5119 /**
5120  * xsltParseStylesheetKey:
5121  * @style:  the XSLT stylesheet
5122  * @key:  the &quot;key&quot; element
5123  *
5124  * &lt;!-- Category: top-level-element --&gt;
5125  * &lt;xsl:key name = qname, match = pattern, use = expression /&gt;
5126  *
5127  * parse an XSLT stylesheet key definition and register it
5128  */
5129 
5130 static void
5131 xsltParseStylesheetKey(xsltStylesheetPtr style, xmlNodePtr key) {
5132     xmlChar *prop = NULL;
5133     xmlChar *use = NULL;
5134     xmlChar *match = NULL;
5135     xmlChar *name = NULL;
5136     xmlChar *nameURI = NULL;
5137 
5138     if ((style == NULL) || (key == NULL) || (key-&gt;type != XML_ELEMENT_NODE))
5139     return;
5140 
5141     /*
5142      * Get arguments
5143      */
5144     prop = xmlGetNsProp(key, (const xmlChar *)&quot;name&quot;, NULL);
5145     if (prop != NULL) {
5146         const xmlChar *URI;
5147 
5148     /*
5149     * TODO: Don&#39;t use xsltGetQNameURI().
5150     */
5151     URI = xsltGetQNameURI(key, &amp;prop);
5152     if (prop == NULL) {
5153         if (style != NULL) style-&gt;errors++;
5154         goto error;
5155     } else {
5156         name = prop;
5157         if (URI != NULL)
5158         nameURI = xmlStrdup(URI);
5159     }
5160 #ifdef WITH_XSLT_DEBUG_PARSING
5161     xsltGenericDebug(xsltGenericDebugContext,
5162          &quot;xsltParseStylesheetKey: name %s\n&quot;, name);
5163 #endif
5164     } else {
5165     xsltTransformError(NULL, style, key,
5166         &quot;xsl:key : error missing name\n&quot;);
5167     if (style != NULL) style-&gt;errors++;
5168     goto error;
5169     }
5170 
5171     match = xmlGetNsProp(key, (const xmlChar *)&quot;match&quot;, NULL);
5172     if (match == NULL) {
5173     xsltTransformError(NULL, style, key,
5174         &quot;xsl:key : error missing match\n&quot;);
5175     if (style != NULL) style-&gt;errors++;
5176     goto error;
5177     }
5178 
5179     use = xmlGetNsProp(key, (const xmlChar *)&quot;use&quot;, NULL);
5180     if (use == NULL) {
5181     xsltTransformError(NULL, style, key,
5182         &quot;xsl:key : error missing use\n&quot;);
5183     if (style != NULL) style-&gt;errors++;
5184     goto error;
5185     }
5186 
5187     /*
5188      * register the keys
5189      */
5190     xsltAddKey(style, name, nameURI, match, use, key);
5191 
5192 
5193 error:
5194     if (use != NULL)
5195     xmlFree(use);
5196     if (match != NULL)
5197     xmlFree(match);
5198     if (name != NULL)
5199     xmlFree(name);
5200     if (nameURI != NULL)
5201     xmlFree(nameURI);
5202 
5203     if (key-&gt;children != NULL) {
5204     xsltParseContentError(style, key-&gt;children);
5205     }
5206 }
5207 
5208 #ifdef XSLT_REFACTORED
5209 /**
5210  * xsltParseXSLTTemplate:
5211  * @style:  the XSLT stylesheet
5212  * @template:  the &quot;template&quot; element
5213  *
5214  * parse an XSLT stylesheet template building the associated structures
5215  * TODO: Is @style ever expected to be NULL?
5216  *
5217  * Called from:
5218  *   xsltParseXSLTStylesheet()
5219  *   xsltParseStylesheetTop()
5220  */
5221 
5222 static void
5223 xsltParseXSLTTemplate(xsltCompilerCtxtPtr cctxt, xmlNodePtr templNode) {
5224     xsltTemplatePtr templ;
5225     xmlChar *prop;
5226     double  priority;
5227 
5228     if ((cctxt == NULL) || (templNode == NULL) ||
5229         (templNode-&gt;type != XML_ELEMENT_NODE))
5230     return;
5231 
5232     /*
5233      * Create and link the structure
5234      */
5235     templ = xsltNewTemplate();
5236     if (templ == NULL)
5237     return;
5238 
5239     xsltCompilerNodePush(cctxt, templNode);
5240     if (templNode-&gt;nsDef != NULL)
5241     cctxt-&gt;inode-&gt;inScopeNs =
5242         xsltCompilerBuildInScopeNsList(cctxt, templNode);
5243 
5244     templ-&gt;next = cctxt-&gt;style-&gt;templates;
5245     cctxt-&gt;style-&gt;templates = templ;
5246     templ-&gt;style = cctxt-&gt;style;
5247 
5248     /*
5249     * Attribute &quot;mode&quot;.
5250     */
5251     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;mode&quot;, NULL);
5252     if (prop != NULL) {
5253         const xmlChar *modeURI;
5254 
5255     /*
5256     * TODO: We need a standardized function for extraction
5257     *  of namespace names and local names from QNames.
5258     *  Don&#39;t use xsltGetQNameURI() as it cannot channe
5259     *  reports through the context.
5260     */
5261     modeURI = xsltGetQNameURI(templNode, &amp;prop);
5262     if (prop == NULL) {
5263         cctxt-&gt;style-&gt;errors++;
5264         goto error;
5265     }
5266     templ-&gt;mode = xmlDictLookup(cctxt-&gt;style-&gt;dict, prop, -1);
5267     xmlFree(prop);
5268     prop = NULL;
5269     if (xmlValidateNCName(templ-&gt;mode, 0)) {
5270         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5271         &quot;xsl:template: Attribute &#39;mode&#39;: The local part &#39;%s&#39; &quot;
5272         &quot;of the value is not a valid NCName.\n&quot;, templ-&gt;name);
5273         cctxt-&gt;style-&gt;errors++;
5274         goto error;
5275     }
5276     if (modeURI != NULL)
5277         templ-&gt;modeURI = xmlDictLookup(cctxt-&gt;style-&gt;dict, modeURI, -1);
5278 #ifdef WITH_XSLT_DEBUG_PARSING
5279     xsltGenericDebug(xsltGenericDebugContext,
5280          &quot;xsltParseXSLTTemplate: mode %s\n&quot;, templ-&gt;mode);
5281 #endif
5282     }
5283     /*
5284     * Attribute &quot;match&quot;.
5285     */
5286     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;match&quot;, NULL);
5287     if (prop != NULL) {
5288     templ-&gt;match  = prop;
5289     prop = NULL;
5290     }
5291     /*
5292     * Attribute &quot;priority&quot;.
5293     */
5294     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;priority&quot;, NULL);
5295     if (prop != NULL) {
5296     priority = xmlXPathStringEvalNumber(prop);
5297     templ-&gt;priority = (float) priority;
5298     xmlFree(prop);
5299     prop = NULL;
5300     }
5301     /*
5302     * Attribute &quot;name&quot;.
5303     */
5304     prop = xmlGetNsProp(templNode, (const xmlChar *)&quot;name&quot;, NULL);
5305     if (prop != NULL) {
5306         const xmlChar *nameURI;
5307     xsltTemplatePtr curTempl;
5308 
5309     /*
5310     * TODO: Don&#39;t use xsltGetQNameURI().
5311     */
5312     nameURI = xsltGetQNameURI(templNode, &amp;prop);
5313     if (prop == NULL) {
5314         cctxt-&gt;style-&gt;errors++;
5315         goto error;
5316     }
5317     templ-&gt;name = xmlDictLookup(cctxt-&gt;style-&gt;dict, prop, -1);
5318     xmlFree(prop);
5319     prop = NULL;
5320     if (xmlValidateNCName(templ-&gt;name, 0)) {
5321         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5322         &quot;xsl:template: Attribute &#39;name&#39;: The local part &#39;%s&#39; of &quot;
5323         &quot;the value is not a valid NCName.\n&quot;, templ-&gt;name);
5324         cctxt-&gt;style-&gt;errors++;
5325         goto error;
5326     }
5327     if (nameURI != NULL)
5328         templ-&gt;nameURI = xmlDictLookup(cctxt-&gt;style-&gt;dict, nameURI, -1);
5329     curTempl = templ-&gt;next;
5330     while (curTempl != NULL) {
5331         if ((nameURI != NULL &amp;&amp; xmlStrEqual(curTempl-&gt;name, templ-&gt;name) &amp;&amp;
5332         xmlStrEqual(curTempl-&gt;nameURI, nameURI) ) ||
5333         (nameURI == NULL &amp;&amp; curTempl-&gt;nameURI == NULL &amp;&amp;
5334         xmlStrEqual(curTempl-&gt;name, templ-&gt;name)))
5335         {
5336         xsltTransformError(NULL, cctxt-&gt;style, templNode,
5337             &quot;xsl:template: error duplicate name &#39;%s&#39;\n&quot;, templ-&gt;name);
5338         cctxt-&gt;style-&gt;errors++;
5339         goto error;
5340         }
5341         curTempl = curTempl-&gt;next;
5342     }
5343     }
5344     if (templNode-&gt;children != NULL) {
5345     xsltParseTemplateContent(cctxt-&gt;style, templNode);
5346     /*
5347     * MAYBE TODO: Custom behaviour: In order to stay compatible with
5348     * Xalan and MSXML(.NET), we could allow whitespace
5349     * to appear before an xml:param element; this whitespace
5350     * will additionally become part of the &quot;template&quot;.
5351     * NOTE that this is totally deviates from the spec, but
5352     * is the de facto behaviour of Xalan and MSXML(.NET).
5353     * Personally I wouldn&#39;t allow this, since if we have:
5354     * &lt;xsl:template ...xml:space=&quot;preserve&quot;&gt;
5355     *   &lt;xsl:param name=&quot;foo&quot;/&gt;
5356     *   &lt;xsl:param name=&quot;bar&quot;/&gt;
5357     *   &lt;xsl:param name=&quot;zoo&quot;/&gt;
5358     * ... the whitespace between every xsl:param would be
5359     * added to the result tree.
5360     */
5361     }
5362 
5363     templ-&gt;elem = templNode;
5364     templ-&gt;content = templNode-&gt;children;
5365     xsltAddTemplate(cctxt-&gt;style, templ, templ-&gt;mode, templ-&gt;modeURI);
5366 
5367 error:
5368     xsltCompilerNodePop(cctxt, templNode);
5369     return;
5370 }
5371 
5372 #else /* XSLT_REFACTORED */
5373 
5374 /**
5375  * xsltParseStylesheetTemplate:
5376  * @style:  the XSLT stylesheet
5377  * @template:  the &quot;template&quot; element
5378  *
5379  * parse an XSLT stylesheet template building the associated structures
5380  */
5381 
5382 static void
5383 xsltParseStylesheetTemplate(xsltStylesheetPtr style, xmlNodePtr template) {
5384     xsltTemplatePtr ret;
5385     xmlChar *prop;
5386     xmlChar *mode = NULL;
5387     xmlChar *modeURI = NULL;
5388     double  priority;
5389 
5390     if ((style == NULL) || (template == NULL) ||
5391         (template-&gt;type != XML_ELEMENT_NODE))
5392     return;
5393 
5394     /*
5395      * Create and link the structure
5396      */
5397     ret = xsltNewTemplate();
5398     if (ret == NULL)
5399     return;
5400     ret-&gt;next = style-&gt;templates;
5401     style-&gt;templates = ret;
5402     ret-&gt;style = style;
5403 
5404     /*
5405      * Get inherited namespaces
5406      */
5407     /*
5408     * TODO: Apply the optimized in-scope-namespace mechanism
5409     *   as for the other XSLT instructions.
5410     */
5411     xsltGetInheritedNsList(style, ret, template);
5412 
5413     /*
5414      * Get arguments
5415      */
5416     prop = xmlGetNsProp(template, (const xmlChar *)&quot;mode&quot;, NULL);
5417     if (prop != NULL) {
5418         const xmlChar *URI;
5419 
5420     /*
5421     * TODO: Don&#39;t use xsltGetQNameURI().
5422     */
5423     URI = xsltGetQNameURI(template, &amp;prop);
5424     if (prop == NULL) {
5425         if (style != NULL) style-&gt;errors++;
5426         goto error;
5427     } else {
5428         mode = prop;
5429         if (URI != NULL)
5430         modeURI = xmlStrdup(URI);
5431     }
5432     ret-&gt;mode = xmlDictLookup(style-&gt;dict, mode, -1);
5433     ret-&gt;modeURI = xmlDictLookup(style-&gt;dict, modeURI, -1);
5434 #ifdef WITH_XSLT_DEBUG_PARSING
5435     xsltGenericDebug(xsltGenericDebugContext,
5436          &quot;xsltParseStylesheetTemplate: mode %s\n&quot;, mode);
5437 #endif
5438         if (mode != NULL) xmlFree(mode);
5439     if (modeURI != NULL) xmlFree(modeURI);
5440     }
5441     prop = xmlGetNsProp(template, (const xmlChar *)&quot;match&quot;, NULL);
5442     if (prop != NULL) {
5443     if (ret-&gt;match != NULL) xmlFree(ret-&gt;match);
5444     ret-&gt;match  = prop;
5445     }
5446 
5447     prop = xmlGetNsProp(template, (const xmlChar *)&quot;priority&quot;, NULL);
5448     if (prop != NULL) {
5449     priority = xmlXPathStringEvalNumber(prop);
5450     ret-&gt;priority = (float) priority;
5451     xmlFree(prop);
5452     }
5453 
5454     prop = xmlGetNsProp(template, (const xmlChar *)&quot;name&quot;, NULL);
5455     if (prop != NULL) {
5456         const xmlChar *URI;
5457 
5458     /*
5459     * TODO: Don&#39;t use xsltGetQNameURI().
5460     */
5461     URI = xsltGetQNameURI(template, &amp;prop);
5462     if (prop == NULL) {
5463         if (style != NULL) style-&gt;errors++;
5464         goto error;
5465     } else {
5466         if (xmlValidateNCName(prop,0)) {
5467             xsltTransformError(NULL, style, template,
5468                 &quot;xsl:template : error invalid name &#39;%s&#39;\n&quot;, prop);
5469         if (style != NULL) style-&gt;errors++;
5470                 xmlFree(prop);
5471         goto error;
5472         }
5473         ret-&gt;name = xmlDictLookup(style-&gt;dict, BAD_CAST prop, -1);
5474         xmlFree(prop);
5475         prop = NULL;
5476         if (URI != NULL)
5477         ret-&gt;nameURI = xmlDictLookup(style-&gt;dict, BAD_CAST URI, -1);
5478         else
5479         ret-&gt;nameURI = NULL;
5480     }
5481     }
5482 
5483     /*
5484      * parse the content and register the pattern
5485      */
5486     xsltParseTemplateContent(style, template);
5487     ret-&gt;elem = template;
5488     ret-&gt;content = template-&gt;children;
5489     xsltAddTemplate(style, ret, ret-&gt;mode, ret-&gt;modeURI);
5490 
5491 error:
5492     return;
5493 }
5494 
5495 #endif /* else XSLT_REFACTORED */
5496 
5497 #ifdef XSLT_REFACTORED
5498 
5499 /**
5500  * xsltIncludeComp:
5501  * @cctxt: the compilation context
5502  * @node:  the xsl:include node
5503  *
5504  * Process the xslt include node on the source node
5505  */
5506 static xsltStyleItemIncludePtr
5507 xsltCompileXSLTIncludeElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node) {
5508     xsltStyleItemIncludePtr item;
5509 
5510     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
5511     return(NULL);
5512 
5513     node-&gt;psvi = NULL;
5514     item = (xsltStyleItemIncludePtr) xmlMalloc(sizeof(xsltStyleItemInclude));
5515     if (item == NULL) {
5516     xsltTransformError(NULL, cctxt-&gt;style, node,
5517         &quot;xsltIncludeComp : malloc failed\n&quot;);
5518     cctxt-&gt;style-&gt;errors++;
5519     return(NULL);
5520     }
5521     memset(item, 0, sizeof(xsltStyleItemInclude));
5522 
5523     node-&gt;psvi = item;
5524     item-&gt;inst = node;
5525     item-&gt;type = XSLT_FUNC_INCLUDE;
5526 
5527     item-&gt;next = cctxt-&gt;style-&gt;preComps;
5528     cctxt-&gt;style-&gt;preComps = (xsltElemPreCompPtr) item;
5529 
5530     return(item);
5531 }
5532 
5533 /**
5534  * xsltParseFindTopLevelElem:
5535  */
5536 static int
5537 xsltParseFindTopLevelElem(xsltCompilerCtxtPtr cctxt,
5538                   xmlNodePtr cur,
5539                   const xmlChar *name,
5540                   const xmlChar *namespaceURI,
5541                   int breakOnOtherElem,
5542                   xmlNodePtr *resultNode)
5543 {
5544     if (name == NULL)
5545     return(-1);
5546 
5547     *resultNode = NULL;
5548     while (cur != NULL) {
5549     if (cur-&gt;type == XML_ELEMENT_NODE) {
5550         if ((cur-&gt;ns != NULL) &amp;&amp; (cur-&gt;name != NULL)) {
5551         if ((*(cur-&gt;name) == *name) &amp;&amp;
5552             xmlStrEqual(cur-&gt;name, name) &amp;&amp;
5553             xmlStrEqual(cur-&gt;ns-&gt;href, namespaceURI))
5554         {
5555             *resultNode = cur;
5556             return(1);
5557         }
5558         }
5559         if (breakOnOtherElem)
5560         break;
5561     }
5562     cur = cur-&gt;next;
5563     }
5564     *resultNode = cur;
5565     return(0);
5566 }
5567 
5568 static int
5569 xsltParseTopLevelXSLTElem(xsltCompilerCtxtPtr cctxt,
5570               xmlNodePtr node,
5571               xsltStyleType type)
5572 {
5573     int ret = 0;
5574 
5575     /*
5576     * TODO: The reason why this function exists:
5577     *  due to historical reasons some of the
5578     *  top-level declarations are processed by functions
5579     *  in other files. Since we need still to set
5580     *  up the node-info and generate information like
5581     *  in-scope namespaces, this is a wrapper around
5582     *  those old parsing functions.
5583     */
5584     xsltCompilerNodePush(cctxt, node);
5585     if (node-&gt;nsDef != NULL)
5586     cctxt-&gt;inode-&gt;inScopeNs =
5587         xsltCompilerBuildInScopeNsList(cctxt, node);
5588     cctxt-&gt;inode-&gt;type = type;
5589 
5590     switch (type) {
5591     case XSLT_FUNC_INCLUDE:
5592         {
5593         int oldIsInclude;
5594 
5595         if (xsltCompileXSLTIncludeElem(cctxt, node) == NULL)
5596             goto exit;
5597         /*
5598         * Mark this stylesheet tree as being currently included.
5599         */
5600         oldIsInclude = cctxt-&gt;isInclude;
5601         cctxt-&gt;isInclude = 1;
5602 
5603         if (xsltParseStylesheetInclude(cctxt-&gt;style, node) != 0) {
5604             cctxt-&gt;style-&gt;errors++;
5605         }
5606         cctxt-&gt;isInclude = oldIsInclude;
5607         }
5608         break;
5609     case XSLT_FUNC_PARAM:
5610         xsltStylePreCompute(cctxt-&gt;style, node);
5611         xsltParseGlobalParam(cctxt-&gt;style, node);
5612         break;
5613     case XSLT_FUNC_VARIABLE:
5614         xsltStylePreCompute(cctxt-&gt;style, node);
5615         xsltParseGlobalVariable(cctxt-&gt;style, node);
5616         break;
5617     case XSLT_FUNC_ATTRSET:
5618         xsltParseStylesheetAttributeSet(cctxt-&gt;style, node);
5619         break;
5620     default:
5621         xsltTransformError(NULL, cctxt-&gt;style, node,
5622         &quot;Internal error: (xsltParseTopLevelXSLTElem) &quot;
5623         &quot;Cannot handle this top-level declaration.\n&quot;);
5624         cctxt-&gt;style-&gt;errors++;
5625         ret = -1;
5626     }
5627 
5628 exit:
5629     xsltCompilerNodePop(cctxt, node);
5630 
5631     return(ret);
5632 }
5633 
5634 #if 0
5635 static int
5636 xsltParseRemoveWhitespace(xmlNodePtr node)
5637 {
5638     if ((node == NULL) || (node-&gt;children == NULL))
5639     return(0);
5640     else {
5641     xmlNodePtr delNode = NULL, child = node-&gt;children;
5642 
5643     do {
5644         if (delNode) {
5645         xmlUnlinkNode(delNode);
5646         xmlFreeNode(delNode);
5647         delNode = NULL;
5648         }
5649         if (((child-&gt;type == XML_TEXT_NODE) ||
5650          (child-&gt;type == XML_CDATA_SECTION_NODE)) &amp;&amp;
5651         (IS_BLANK_NODE(child)))
5652         delNode = child;
5653         child = child-&gt;next;
5654     } while (child != NULL);
5655     if (delNode) {
5656         xmlUnlinkNode(delNode);
5657         xmlFreeNode(delNode);
5658         delNode = NULL;
5659     }
5660     }
5661     return(0);
5662 }
5663 #endif
5664 
5665 static int
5666 xsltParseXSLTStylesheetElemCore(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
5667 {
5668 #ifdef WITH_XSLT_DEBUG_PARSING
5669     int templates = 0;
5670 #endif
5671     xmlNodePtr cur, start = NULL;
5672     xsltStylesheetPtr style;
5673 
5674     if ((cctxt == NULL) || (node == NULL) ||
5675     (node-&gt;type != XML_ELEMENT_NODE))
5676     return(-1);
5677 
5678     style = cctxt-&gt;style;
5679     /*
5680     * At this stage all import declarations of all stylesheet modules
5681     * with the same stylesheet level have been processed.
5682     * Now we can safely parse the rest of the declarations.
5683     */
5684     if (IS_XSLT_ELEM_FAST(node) &amp;&amp; IS_XSLT_NAME(node, &quot;include&quot;))
5685     {
5686     xsltDocumentPtr include;
5687     /*
5688     * URGENT TODO: Make this work with simplified stylesheets!
5689     *   I.e., when we won&#39;t find an xsl:stylesheet element.
5690     */
5691     /*
5692     * This is as include declaration.
5693     */
5694     include = ((xsltStyleItemIncludePtr) node-&gt;psvi)-&gt;include;
5695     if (include == NULL) {
5696         /* TODO: raise error? */
5697         return(-1);
5698     }
5699     /*
5700     * TODO: Actually an xsl:include should locate an embedded
5701     *  stylesheet as well; so the document-element won&#39;t always
5702     *  be the element where the actual stylesheet is rooted at.
5703     *  But such embedded stylesheets are not supported by Libxslt yet.
5704     */
5705     node = xmlDocGetRootElement(include-&gt;doc);
5706     if (node == NULL) {
5707         return(-1);
5708     }
5709     }
5710 
5711     if (node-&gt;children == NULL)
5712     return(0);
5713     /*
5714     * Push the xsl:stylesheet/xsl:transform element.
5715     */
5716     xsltCompilerNodePush(cctxt, node);
5717     cctxt-&gt;inode-&gt;isRoot = 1;
5718     cctxt-&gt;inode-&gt;nsChanged = 0;
5719     /*
5720     * Start with the naked dummy info for literal result elements.
5721     */
5722     cctxt-&gt;inode-&gt;litResElemInfo = cctxt-&gt;inodeList-&gt;litResElemInfo;
5723 
5724     /*
5725     * In every case, we need to have
5726     * the in-scope namespaces of the element, where the
5727     * stylesheet is rooted at, regardless if it&#39;s an XSLT
5728     * instruction or a literal result instruction (or if
5729     * this is an embedded stylesheet).
5730     */
5731     cctxt-&gt;inode-&gt;inScopeNs =
5732     xsltCompilerBuildInScopeNsList(cctxt, node);
5733 
5734     /*
5735     * Process attributes of xsl:stylesheet/xsl:transform.
5736     * --------------------------------------------------
5737     * Allowed are:
5738     *  id = id
5739     *  extension-element-prefixes = tokens
5740     *  exclude-result-prefixes = tokens
5741     *  version = number (mandatory)
5742     */
5743     if (xsltParseAttrXSLTVersion(cctxt, node,
5744     XSLT_ELEMENT_CATEGORY_XSLT) == 0)
5745     {
5746     /*
5747     * Attribute &quot;version&quot;.
5748     * XSLT 1.0: &quot;An xsl:stylesheet element *must* have a version
5749     *  attribute, indicating the version of XSLT that the
5750     *  stylesheet requires&quot;.
5751     * The root element of a simplified stylesheet must also have
5752     * this attribute.
5753     */
5754 #ifdef XSLT_REFACTORED_MANDATORY_VERSION
5755     if (isXsltElem)
5756         xsltTransformError(NULL, cctxt-&gt;style, node,
5757         &quot;The attribute &#39;version&#39; is missing.\n&quot;);
5758     cctxt-&gt;style-&gt;errors++;
5759 #else
5760     /* OLD behaviour. */
5761     xsltTransformError(NULL, cctxt-&gt;style, node,
5762         &quot;xsl:version is missing: document may not be a stylesheet\n&quot;);
5763     cctxt-&gt;style-&gt;warnings++;
5764 #endif
5765     }
5766     /*
5767     * The namespaces declared by the attributes
5768     *  &quot;extension-element-prefixes&quot; and
5769     *  &quot;exclude-result-prefixes&quot; are local to *this*
5770     *  stylesheet tree; i.e., they are *not* visible to
5771     *  other stylesheet-modules, whether imported or included.
5772     *
5773     * Attribute &quot;extension-element-prefixes&quot;.
5774     */
5775     cctxt-&gt;inode-&gt;extElemNs =
5776     xsltParseExtElemPrefixes(cctxt, node, NULL,
5777         XSLT_ELEMENT_CATEGORY_XSLT);
5778     /*
5779     * Attribute &quot;exclude-result-prefixes&quot;.
5780     */
5781     cctxt-&gt;inode-&gt;exclResultNs =
5782     xsltParseExclResultPrefixes(cctxt, node, NULL,
5783         XSLT_ELEMENT_CATEGORY_XSLT);
5784     /*
5785     * Create/reuse info for the literal result element.
5786     */
5787     if (cctxt-&gt;inode-&gt;nsChanged)
5788     xsltLREInfoCreate(cctxt, node, 0);
5789     /*
5790     * Processed top-level elements:
5791     * ----------------------------
5792     *  xsl:variable, xsl:param (QName, in-scope ns,
5793     *    expression (vars allowed))
5794     *  xsl:attribute-set (QName, in-scope ns)
5795     *  xsl:strip-space, xsl:preserve-space (XPath NameTests,
5796     *    in-scope ns)
5797     *    I *think* global scope, merge with includes
5798     *  xsl:output (QName, in-scope ns)
5799     *  xsl:key (QName, in-scope ns, pattern,
5800     *    expression (vars *not* allowed))
5801     *  xsl:decimal-format (QName, needs in-scope ns)
5802     *  xsl:namespace-alias (in-scope ns)
5803     *    global scope, merge with includes
5804     *  xsl:template (last, QName, pattern)
5805     *
5806     * (whitespace-only text-nodes have *not* been removed
5807     *  yet; this will be done in xsltParseSequenceConstructor)
5808     *
5809     * Report misplaced child-nodes first.
5810     */
5811     cur = node-&gt;children;
5812     while (cur != NULL) {
5813     if (cur-&gt;type == XML_TEXT_NODE) {
5814         xsltTransformError(NULL, style, cur,
5815         &quot;Misplaced text node (content: &#39;%s&#39;).\n&quot;,
5816         (cur-&gt;content != NULL) ? cur-&gt;content : BAD_CAST &quot;&quot;);
5817         style-&gt;errors++;
5818     } else if (cur-&gt;type != XML_ELEMENT_NODE) {
5819         xsltTransformError(NULL, style, cur, &quot;Misplaced node.\n&quot;);
5820         style-&gt;errors++;
5821     }
5822     cur = cur-&gt;next;
5823     }
5824     /*
5825     * Skip xsl:import elements; they have been processed
5826     * already.
5827     */
5828     cur = node-&gt;children;
5829     while ((cur != NULL) &amp;&amp; xsltParseFindTopLevelElem(cctxt, cur,
5830         BAD_CAST &quot;import&quot;, XSLT_NAMESPACE, 1, &amp;cur) == 1)
5831     cur = cur-&gt;next;
5832     if (cur == NULL)
5833     goto exit;
5834 
5835     start = cur;
5836     /*
5837     * Process all top-level xsl:param elements.
5838     */
5839     while ((cur != NULL) &amp;&amp;
5840     xsltParseFindTopLevelElem(cctxt, cur,
5841     BAD_CAST &quot;param&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
5842     {
5843     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_PARAM);
5844     cur = cur-&gt;next;
5845     }
5846     /*
5847     * Process all top-level xsl:variable elements.
5848     */
5849     cur = start;
5850     while ((cur != NULL) &amp;&amp;
5851     xsltParseFindTopLevelElem(cctxt, cur,
5852     BAD_CAST &quot;variable&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
5853     {
5854     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_VARIABLE);
5855     cur = cur-&gt;next;
5856     }
5857     /*
5858     * Process all the rest of top-level elements.
5859     */
5860     cur = start;
5861     while (cur != NULL) {
5862     /*
5863     * Process element nodes.
5864     */
5865     if (cur-&gt;type == XML_ELEMENT_NODE) {
5866         if (cur-&gt;ns == NULL) {
5867         xsltTransformError(NULL, style, cur,
5868             &quot;Unexpected top-level element in no namespace.\n&quot;);
5869         style-&gt;errors++;
5870         cur = cur-&gt;next;
5871         continue;
5872         }
5873         /*
5874         * Process all XSLT elements.
5875         */
5876         if (IS_XSLT_ELEM_FAST(cur)) {
5877         /*
5878         * xsl:import is only allowed at the beginning.
5879         */
5880         if (IS_XSLT_NAME(cur, &quot;import&quot;)) {
5881             xsltTransformError(NULL, style, cur,
5882             &quot;Misplaced xsl:import element.\n&quot;);
5883             style-&gt;errors++;
5884             cur = cur-&gt;next;
5885             continue;
5886         }
5887         /*
5888         * TODO: Change the return type of the parsing functions
5889         *  to int.
5890         */
5891         if (IS_XSLT_NAME(cur, &quot;template&quot;)) {
5892 #ifdef WITH_XSLT_DEBUG_PARSING
5893             templates++;
5894 #endif
5895             /*
5896             * TODO: Is the position of xsl:template in the
5897             *  tree significant? If not it would be easier to
5898             *  parse them at a later stage.
5899             */
5900             xsltParseXSLTTemplate(cctxt, cur);
5901         } else if (IS_XSLT_NAME(cur, &quot;variable&quot;)) {
5902             /* NOP; done already */
5903         } else if (IS_XSLT_NAME(cur, &quot;param&quot;)) {
5904             /* NOP; done already */
5905         } else if (IS_XSLT_NAME(cur, &quot;include&quot;)) {
5906             if (cur-&gt;psvi != NULL)
5907             xsltParseXSLTStylesheetElemCore(cctxt, cur);
5908             else {
5909             xsltTransformError(NULL, style, cur,
5910                 &quot;Internal error: &quot;
5911                 &quot;(xsltParseXSLTStylesheetElemCore) &quot;
5912                 &quot;The xsl:include element was not compiled.\n&quot;);
5913             style-&gt;errors++;
5914             }
5915         } else if (IS_XSLT_NAME(cur, &quot;strip-space&quot;)) {
5916             /* No node info needed. */
5917             xsltParseStylesheetStripSpace(style, cur);
5918         } else if (IS_XSLT_NAME(cur, &quot;preserve-space&quot;)) {
5919             /* No node info needed. */
5920             xsltParseStylesheetPreserveSpace(style, cur);
5921         } else if (IS_XSLT_NAME(cur, &quot;output&quot;)) {
5922             /* No node-info needed. */
5923             xsltParseStylesheetOutput(style, cur);
5924         } else if (IS_XSLT_NAME(cur, &quot;key&quot;)) {
5925             /* TODO: node-info needed for expressions ? */
5926             xsltParseStylesheetKey(style, cur);
5927         } else if (IS_XSLT_NAME(cur, &quot;decimal-format&quot;)) {
5928             /* No node-info needed. */
5929             xsltParseStylesheetDecimalFormat(style, cur);
5930         } else if (IS_XSLT_NAME(cur, &quot;attribute-set&quot;)) {
5931             xsltParseTopLevelXSLTElem(cctxt, cur,
5932             XSLT_FUNC_ATTRSET);
5933         } else if (IS_XSLT_NAME(cur, &quot;namespace-alias&quot;)) {
5934             /* NOP; done already */
5935         } else {
5936             if (cctxt-&gt;inode-&gt;forwardsCompat) {
5937             /*
5938             * Forwards-compatible mode:
5939             *
5940             * XSLT-1: &quot;if it is a top-level element and
5941             *  XSLT 1.0 does not allow such elements as top-level
5942             *  elements, then the element must be ignored along
5943             *  with its content;&quot;
5944             */
5945             /*
5946             * TODO: I don&#39;t think we should generate a warning.
5947             */
5948             xsltTransformError(NULL, style, cur,
5949                 &quot;Forwards-compatible mode: Ignoring unknown XSLT &quot;
5950                 &quot;element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5951             style-&gt;warnings++;
5952             } else {
5953             xsltTransformError(NULL, style, cur,
5954                 &quot;Unknown XSLT element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5955             style-&gt;errors++;
5956             }
5957         }
5958         } else {
5959         xsltTopLevelFunction function;
5960 
5961         /*
5962         * Process non-XSLT elements, which are in a
5963         *  non-NULL namespace.
5964         */
5965         /*
5966         * QUESTION: What does xsltExtModuleTopLevelLookup()
5967         *  do exactly?
5968         */
5969         function = xsltExtModuleTopLevelLookup(cur-&gt;name,
5970             cur-&gt;ns-&gt;href);
5971         if (function != NULL)
5972             function(style, cur);
5973 #ifdef WITH_XSLT_DEBUG_PARSING
5974         xsltGenericDebug(xsltGenericDebugContext,
5975             &quot;xsltParseXSLTStylesheetElemCore : User-defined &quot;
5976             &quot;data element &#39;%s&#39;.\n&quot;, cur-&gt;name);
5977 #endif
5978         }
5979     }
5980     cur = cur-&gt;next;
5981     }
5982 
5983 exit:
5984 
5985 #ifdef WITH_XSLT_DEBUG_PARSING
5986     xsltGenericDebug(xsltGenericDebugContext,
5987     &quot;### END of parsing top-level elements of doc &#39;%s&#39;.\n&quot;,
5988     node-&gt;doc-&gt;URL);
5989     xsltGenericDebug(xsltGenericDebugContext,
5990     &quot;### Templates: %d\n&quot;, templates);
5991 #ifdef XSLT_REFACTORED
5992     xsltGenericDebug(xsltGenericDebugContext,
5993     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
5994     xsltGenericDebug(xsltGenericDebugContext,
5995     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
5996 #endif /* XSLT_REFACTORED */
5997 #endif /* WITH_XSLT_DEBUG_PARSING */
5998 
5999     xsltCompilerNodePop(cctxt, node);
6000     return(0);
6001 }
6002 
6003 /**
6004  * xsltParseXSLTStylesheet:
6005  * @cctxt: the compiler context
6006  * @node: the xsl:stylesheet/xsl:transform element-node
6007  *
6008  * Parses the xsl:stylesheet and xsl:transform element.
6009  *
6010  * &lt;xsl:stylesheet
6011  *  id = id
6012  *  extension-element-prefixes = tokens
6013  *  exclude-result-prefixes = tokens
6014  *  version = number&gt;
6015  *  &lt;!-- Content: (xsl:import*, top-level-elements) --&gt;
6016  * &lt;/xsl:stylesheet&gt;
6017  *
6018  * BIG TODO: The xsl:include stuff.
6019  *
6020  * Called by xsltParseStylesheetTree()
6021  *
6022  * Returns 0 on success, a positive result on errors and
6023  *         -1 on API or internal errors.
6024  */
6025 static int
6026 xsltParseXSLTStylesheetElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node)
6027 {
6028     xmlNodePtr cur, start;
6029 
6030     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
6031     return(-1);
6032 
6033     if (node-&gt;children == NULL)
6034     goto exit;
6035 
6036     /*
6037     * Process top-level elements:
6038     *  xsl:import (must be first)
6039     *  xsl:include (this is just a pre-processing)
6040     */
6041     cur = node-&gt;children;
6042     /*
6043     * Process xsl:import elements.
6044     * XSLT 1.0: &quot;The xsl:import element children must precede all
6045     *  other element children of an xsl:stylesheet element,
6046     *  including any xsl:include element children.&quot;
6047     */
6048     while ((cur != NULL) &amp;&amp;
6049     xsltParseFindTopLevelElem(cctxt, cur,
6050         BAD_CAST &quot;import&quot;, XSLT_NAMESPACE, 1, &amp;cur) == 1)
6051     {
6052     if (xsltParseStylesheetImport(cctxt-&gt;style, cur) != 0) {
6053         cctxt-&gt;style-&gt;errors++;
6054     }
6055     cur = cur-&gt;next;
6056     }
6057     if (cur == NULL)
6058     goto exit;
6059     start = cur;
6060     /*
6061     * Pre-process all xsl:include elements.
6062     */
6063     cur = start;
6064     while ((cur != NULL) &amp;&amp;
6065     xsltParseFindTopLevelElem(cctxt, cur,
6066         BAD_CAST &quot;include&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
6067     {
6068     xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_INCLUDE);
6069     cur = cur-&gt;next;
6070     }
6071     /*
6072     * Pre-process all xsl:namespace-alias elements.
6073     * URGENT TODO: This won&#39;t work correctly: the order of included
6074     *  aliases and aliases defined here is significant.
6075     */
6076     cur = start;
6077     while ((cur != NULL) &amp;&amp;
6078     xsltParseFindTopLevelElem(cctxt, cur,
6079         BAD_CAST &quot;namespace-alias&quot;, XSLT_NAMESPACE, 0, &amp;cur) == 1)
6080     {
6081     xsltNamespaceAlias(cctxt-&gt;style, cur);
6082     cur = cur-&gt;next;
6083     }
6084 
6085     if (cctxt-&gt;isInclude) {
6086     /*
6087     * If this stylesheet is intended for inclusion, then
6088     * we will process only imports and includes.
6089     */
6090     goto exit;
6091     }
6092     /*
6093     * Now parse the rest of the top-level elements.
6094     */
6095     xsltParseXSLTStylesheetElemCore(cctxt, node);
6096 exit:
6097 
6098     return(0);
6099 }
6100 
6101 #else /* XSLT_REFACTORED */
6102 
6103 /**
6104  * xsltParseStylesheetTop:
6105  * @style:  the XSLT stylesheet
6106  * @top:  the top level &quot;stylesheet&quot; or &quot;transform&quot; element
6107  *
6108  * scan the top level elements of an XSL stylesheet
6109  */
6110 static void
6111 xsltParseStylesheetTop(xsltStylesheetPtr style, xmlNodePtr top) {
6112     xmlNodePtr cur;
6113     xmlChar *prop;
6114 #ifdef WITH_XSLT_DEBUG_PARSING
6115     int templates = 0;
6116 #endif
6117 
6118     if ((top == NULL) || (top-&gt;type != XML_ELEMENT_NODE))
6119     return;
6120 
6121     prop = xmlGetNsProp(top, (const xmlChar *)&quot;version&quot;, NULL);
6122     if (prop == NULL) {
6123     xsltTransformError(NULL, style, top,
6124         &quot;xsl:version is missing: document may not be a stylesheet\n&quot;);
6125     if (style != NULL) style-&gt;warnings++;
6126     } else {
6127     if ((!xmlStrEqual(prop, (const xmlChar *)&quot;1.0&quot;)) &amp;&amp;
6128             (!xmlStrEqual(prop, (const xmlChar *)&quot;1.1&quot;))) {
6129         xsltTransformError(NULL, style, top,
6130         &quot;xsl:version: only 1.1 features are supported\n&quot;);
6131         if (style != NULL) {
6132                 style-&gt;forwards_compatible = 1;
6133                 style-&gt;warnings++;
6134             }
6135     }
6136     xmlFree(prop);
6137     }
6138 
6139     /*
6140      * process xsl:import elements
6141      */
6142     cur = top-&gt;children;
6143     while (cur != NULL) {
6144         if (IS_BLANK_NODE(cur)) {
6145             cur = cur-&gt;next;
6146             continue;
6147         }
6148         if (IS_XSLT_ELEM(cur) &amp;&amp; IS_XSLT_NAME(cur, &quot;import&quot;)) {
6149             if (xsltParseStylesheetImport(style, cur) != 0)
6150                 if (style != NULL) style-&gt;errors++;
6151         } else
6152             break;
6153         cur = cur-&gt;next;
6154     }
6155 
6156     /*
6157      * process other top-level elements
6158      */
6159     while (cur != NULL) {
6160     if (IS_BLANK_NODE(cur)) {
6161         cur = cur-&gt;next;
6162         continue;
6163     }
6164     if (cur-&gt;type == XML_TEXT_NODE) {
6165         if (cur-&gt;content != NULL) {
6166         xsltTransformError(NULL, style, cur,
6167             &quot;misplaced text node: &#39;%s&#39;\n&quot;, cur-&gt;content);
6168         }
6169         if (style != NULL) style-&gt;errors++;
6170             cur = cur-&gt;next;
6171         continue;
6172     }
6173     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (cur-&gt;ns == NULL)) {
6174         xsltGenericError(xsltGenericErrorContext,
6175              &quot;Found a top-level element %s with null namespace URI\n&quot;,
6176              cur-&gt;name);
6177         if (style != NULL) style-&gt;errors++;
6178         cur = cur-&gt;next;
6179         continue;
6180     }
6181     if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (!(IS_XSLT_ELEM(cur)))) {
6182         xsltTopLevelFunction function;
6183 
6184         function = xsltExtModuleTopLevelLookup(cur-&gt;name,
6185                            cur-&gt;ns-&gt;href);
6186         if (function != NULL)
6187         function(style, cur);
6188 
6189 #ifdef WITH_XSLT_DEBUG_PARSING
6190         xsltGenericDebug(xsltGenericDebugContext,
6191             &quot;xsltParseStylesheetTop : found foreign element %s\n&quot;,
6192             cur-&gt;name);
6193 #endif
6194             cur = cur-&gt;next;
6195         continue;
6196     }
6197     if (IS_XSLT_NAME(cur, &quot;import&quot;)) {
6198         xsltTransformError(NULL, style, cur,
6199             &quot;xsltParseStylesheetTop: ignoring misplaced import element\n&quot;);
6200         if (style != NULL) style-&gt;errors++;
6201         } else if (IS_XSLT_NAME(cur, &quot;include&quot;)) {
6202         if (xsltParseStylesheetInclude(style, cur) != 0)
6203         if (style != NULL) style-&gt;errors++;
6204         } else if (IS_XSLT_NAME(cur, &quot;strip-space&quot;)) {
6205         xsltParseStylesheetStripSpace(style, cur);
6206         } else if (IS_XSLT_NAME(cur, &quot;preserve-space&quot;)) {
6207         xsltParseStylesheetPreserveSpace(style, cur);
6208         } else if (IS_XSLT_NAME(cur, &quot;output&quot;)) {
6209         xsltParseStylesheetOutput(style, cur);
6210         } else if (IS_XSLT_NAME(cur, &quot;key&quot;)) {
6211         xsltParseStylesheetKey(style, cur);
6212         } else if (IS_XSLT_NAME(cur, &quot;decimal-format&quot;)) {
6213         xsltParseStylesheetDecimalFormat(style, cur);
6214         } else if (IS_XSLT_NAME(cur, &quot;attribute-set&quot;)) {
6215         xsltParseStylesheetAttributeSet(style, cur);
6216         } else if (IS_XSLT_NAME(cur, &quot;variable&quot;)) {
6217         xsltParseGlobalVariable(style, cur);
6218         } else if (IS_XSLT_NAME(cur, &quot;param&quot;)) {
6219         xsltParseGlobalParam(style, cur);
6220         } else if (IS_XSLT_NAME(cur, &quot;template&quot;)) {
6221 #ifdef WITH_XSLT_DEBUG_PARSING
6222         templates++;
6223 #endif
6224         xsltParseStylesheetTemplate(style, cur);
6225         } else if (IS_XSLT_NAME(cur, &quot;namespace-alias&quot;)) {
6226         xsltNamespaceAlias(style, cur);
6227     } else {
6228             if ((style != NULL) &amp;&amp; (style-&gt;forwards_compatible == 0)) {
6229             xsltTransformError(NULL, style, cur,
6230             &quot;xsltParseStylesheetTop: unknown %s element\n&quot;,
6231             cur-&gt;name);
6232             if (style != NULL) style-&gt;errors++;
6233         }
6234     }
6235     cur = cur-&gt;next;
6236     }
6237 #ifdef WITH_XSLT_DEBUG_PARSING
6238     xsltGenericDebug(xsltGenericDebugContext,
6239             &quot;parsed %d templates\n&quot;, templates);
6240 #endif
6241 }
6242 
6243 #endif /* else of XSLT_REFACTORED */
6244 
6245 #ifdef XSLT_REFACTORED
6246 /**
6247  * xsltParseSimplifiedStylesheetTree:
6248  *
6249  * @style: the stylesheet (TODO: Change this to the compiler context)
6250  * @doc: the document containing the stylesheet.
6251  * @node: the node where the stylesheet is rooted at
6252  *
6253  * Returns 0 in case of success, a positive result if an error occurred
6254  *         and -1 on API and internal errors.
6255  */
6256 static int
6257 xsltParseSimplifiedStylesheetTree(xsltCompilerCtxtPtr cctxt,
6258                   xmlDocPtr doc,
6259                   xmlNodePtr node)
6260 {
6261     xsltTemplatePtr templ;
6262 
6263     if ((cctxt == NULL) || (node == NULL))
6264     return(-1);
6265 
6266     if (xsltParseAttrXSLTVersion(cctxt, node, 0) == XSLT_ELEMENT_CATEGORY_LRE)
6267     {
6268     /*
6269     * TODO: Adjust report, since this might be an
6270     * embedded stylesheet.
6271     */
6272     xsltTransformError(NULL, cctxt-&gt;style, node,
6273         &quot;The attribute &#39;xsl:version&#39; is missing; cannot identify &quot;
6274         &quot;this document as an XSLT stylesheet document.\n&quot;);
6275     cctxt-&gt;style-&gt;errors++;
6276     return(1);
6277     }
6278 
6279 #ifdef WITH_XSLT_DEBUG_PARSING
6280     xsltGenericDebug(xsltGenericDebugContext,
6281     &quot;xsltParseSimplifiedStylesheetTree: document is stylesheet\n&quot;);
6282 #endif
6283 
6284     /*
6285     * Create and link the template
6286     */
6287     templ = xsltNewTemplate();
6288     if (templ == NULL) {
6289     return(-1);
6290     }
6291     templ-&gt;next = cctxt-&gt;style-&gt;templates;
6292     cctxt-&gt;style-&gt;templates = templ;
6293     templ-&gt;match = xmlStrdup(BAD_CAST &quot;/&quot;);
6294 
6295     /*
6296     * Note that we push the document-node in this special case.
6297     */
6298     xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6299     /*
6300     * In every case, we need to have
6301     * the in-scope namespaces of the element, where the
6302     * stylesheet is rooted at, regardless if it&#39;s an XSLT
6303     * instruction or a literal result instruction (or if
6304     * this is an embedded stylesheet).
6305     */
6306     cctxt-&gt;inode-&gt;inScopeNs =
6307     xsltCompilerBuildInScopeNsList(cctxt, node);
6308     /*
6309     * Parse the content and register the match-pattern.
6310     */
6311     xsltParseSequenceConstructor(cctxt, node);
6312     xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6313 
6314     templ-&gt;elem = (xmlNodePtr) doc;
6315     templ-&gt;content = node;
6316     xsltAddTemplate(cctxt-&gt;style, templ, NULL, NULL);
6317     cctxt-&gt;style-&gt;literal_result = 1;
6318     return(0);
6319 }
6320 
6321 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
6322 /**
6323  * xsltRestoreDocumentNamespaces:
6324  * @ns: map of namespaces
6325  * @doc: the document
6326  *
6327  * Restore the namespaces for the document
6328  *
6329  * Returns 0 in case of success, -1 in case of failure
6330  */
6331 int
6332 xsltRestoreDocumentNamespaces(xsltNsMapPtr ns, xmlDocPtr doc)
6333 {
6334     if (doc == NULL)
6335     return(-1);
6336     /*
6337     * Revert the changes we have applied to the namespace-URIs of
6338     * ns-decls.
6339     */
6340     while (ns != NULL) {
6341     if ((ns-&gt;doc == doc) &amp;&amp; (ns-&gt;ns != NULL)) {
6342         ns-&gt;ns-&gt;href = ns-&gt;origNsName;
6343         ns-&gt;origNsName = NULL;
6344         ns-&gt;ns = NULL;
6345     }
6346     ns = ns-&gt;next;
6347     }
6348     return(0);
6349 }
6350 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
6351 
6352 /**
6353  * xsltParseStylesheetProcess:
6354  * @style:  the XSLT stylesheet (the current stylesheet-level)
6355  * @doc:  and xmlDoc parsed XML
6356  *
6357  * Parses an XSLT stylesheet, adding the associated structures.
6358  * Called by:
6359  *  xsltParseStylesheetImportedDoc() (xslt.c)
6360  *  xsltParseStylesheetInclude() (imports.c)
6361  *
6362  * Returns the value of the @style parameter if everything
6363  * went right, NULL if something went amiss.
6364  */
6365 xsltStylesheetPtr
6366 xsltParseStylesheetProcess(xsltStylesheetPtr style, xmlDocPtr doc)
6367 {
6368     xsltCompilerCtxtPtr cctxt;
6369     xmlNodePtr cur;
6370     int oldIsSimplifiedStylesheet;
6371 
6372     xsltInitGlobals();
6373 
6374     if ((style == NULL) || (doc == NULL))
6375     return(NULL);
6376 
6377     cctxt = XSLT_CCTXT(style);
6378 
6379     cur = xmlDocGetRootElement(doc);
6380     if (cur == NULL) {
6381     xsltTransformError(NULL, style, (xmlNodePtr) doc,
6382         &quot;xsltParseStylesheetProcess : empty stylesheet\n&quot;);
6383     return(NULL);
6384     }
6385     oldIsSimplifiedStylesheet = cctxt-&gt;simplified;
6386 
6387     if ((IS_XSLT_ELEM(cur)) &amp;&amp;
6388     ((IS_XSLT_NAME(cur, &quot;stylesheet&quot;)) ||
6389      (IS_XSLT_NAME(cur, &quot;transform&quot;)))) {
6390 #ifdef WITH_XSLT_DEBUG_PARSING
6391     xsltGenericDebug(xsltGenericDebugContext,
6392         &quot;xsltParseStylesheetProcess : found stylesheet\n&quot;);
6393 #endif
6394     cctxt-&gt;simplified = 0;
6395     style-&gt;literal_result = 0;
6396     } else {
6397     cctxt-&gt;simplified = 1;
6398     style-&gt;literal_result = 1;
6399     }
6400     /*
6401     * Pre-process the stylesheet if not already done before.
6402     *  This will remove PIs and comments, merge adjacent
6403     *  text nodes, internalize strings, etc.
6404     */
6405     if (! style-&gt;nopreproc)
6406     xsltParsePreprocessStylesheetTree(cctxt, cur);
6407     /*
6408     * Parse and compile the stylesheet.
6409     */
6410     if (style-&gt;literal_result == 0) {
6411     if (xsltParseXSLTStylesheetElem(cctxt, cur) != 0)
6412         return(NULL);
6413     } else {
6414     if (xsltParseSimplifiedStylesheetTree(cctxt, doc, cur) != 0)
6415         return(NULL);
6416     }
6417 
6418     cctxt-&gt;simplified = oldIsSimplifiedStylesheet;
6419 
6420     return(style);
6421 }
6422 
6423 #else /* XSLT_REFACTORED */
6424 
6425 /**
6426  * xsltParseStylesheetProcess:
6427  * @ret:  the XSLT stylesheet (the current stylesheet-level)
6428  * @doc:  and xmlDoc parsed XML
6429  *
6430  * Parses an XSLT stylesheet, adding the associated structures.
6431  * Called by:
6432  *  xsltParseStylesheetImportedDoc() (xslt.c)
6433  *  xsltParseStylesheetInclude() (imports.c)
6434  *
6435  * Returns the value of the @style parameter if everything
6436  * went right, NULL if something went amiss.
6437  */
6438 xsltStylesheetPtr
6439 xsltParseStylesheetProcess(xsltStylesheetPtr ret, xmlDocPtr doc) {
6440     xmlNodePtr cur;
6441 
6442     xsltInitGlobals();
6443 
6444     if (doc == NULL)
6445     return(NULL);
6446     if (ret == NULL)
6447     return(ret);
6448 
6449     /*
6450      * First steps, remove blank nodes,
6451      * locate the xsl:stylesheet element and the
6452      * namespace declaration.
6453      */
6454     cur = xmlDocGetRootElement(doc);
6455     if (cur == NULL) {
6456     xsltTransformError(NULL, ret, (xmlNodePtr) doc,
6457         &quot;xsltParseStylesheetProcess : empty stylesheet\n&quot;);
6458     return(NULL);
6459     }
6460 
6461     if ((IS_XSLT_ELEM(cur)) &amp;&amp;
6462     ((IS_XSLT_NAME(cur, &quot;stylesheet&quot;)) ||
6463      (IS_XSLT_NAME(cur, &quot;transform&quot;)))) {
6464 #ifdef WITH_XSLT_DEBUG_PARSING
6465     xsltGenericDebug(xsltGenericDebugContext,
6466         &quot;xsltParseStylesheetProcess : found stylesheet\n&quot;);
6467 #endif
6468     ret-&gt;literal_result = 0;
6469     xsltParseStylesheetExcludePrefix(ret, cur, 1);
6470     xsltParseStylesheetExtPrefix(ret, cur, 1);
6471     } else {
6472     xsltParseStylesheetExcludePrefix(ret, cur, 0);
6473     xsltParseStylesheetExtPrefix(ret, cur, 0);
6474     ret-&gt;literal_result = 1;
6475     }
6476     if (!ret-&gt;nopreproc) {
6477     xsltPreprocessStylesheet(ret, cur);
6478     }
6479     if (ret-&gt;literal_result == 0) {
6480     xsltParseStylesheetTop(ret, cur);
6481     } else {
6482     xmlChar *prop;
6483     xsltTemplatePtr template;
6484 
6485     /*
6486      * the document itself might be the template, check xsl:version
6487      */
6488     prop = xmlGetNsProp(cur, (const xmlChar *)&quot;version&quot;, XSLT_NAMESPACE);
6489     if (prop == NULL) {
6490         xsltTransformError(NULL, ret, cur,
6491         &quot;xsltParseStylesheetProcess : document is not a stylesheet\n&quot;);
6492         return(NULL);
6493     }
6494 
6495 #ifdef WITH_XSLT_DEBUG_PARSING
6496         xsltGenericDebug(xsltGenericDebugContext,
6497         &quot;xsltParseStylesheetProcess : document is stylesheet\n&quot;);
6498 #endif
6499 
6500     if ((!xmlStrEqual(prop, (const xmlChar *)&quot;1.0&quot;)) &amp;&amp;
6501             (!xmlStrEqual(prop, (const xmlChar *)&quot;1.1&quot;))) {
6502         xsltTransformError(NULL, ret, cur,
6503         &quot;xsl:version: only 1.1 features are supported\n&quot;);
6504             ret-&gt;forwards_compatible = 1;
6505         ret-&gt;warnings++;
6506     }
6507     xmlFree(prop);
6508 
6509     /*
6510      * Create and link the template
6511      */
6512     template = xsltNewTemplate();
6513     if (template == NULL) {
6514         return(NULL);
6515     }
6516     template-&gt;next = ret-&gt;templates;
6517     ret-&gt;templates = template;
6518     template-&gt;match = xmlStrdup((const xmlChar *)&quot;/&quot;);
6519 
6520     /*
6521      * parse the content and register the pattern
6522      */
6523     xsltParseTemplateContent(ret, (xmlNodePtr) doc);
6524     template-&gt;elem = (xmlNodePtr) doc;
6525     template-&gt;content = doc-&gt;children;
6526     xsltAddTemplate(ret, template, NULL, NULL);
6527     ret-&gt;literal_result = 1;
6528     }
6529 
6530     return(ret);
6531 }
6532 
6533 #endif /* else of XSLT_REFACTORED */
6534 
6535 /**
6536  * xsltParseStylesheetImportedDoc:
6537  * @doc:  an xmlDoc parsed XML
6538  * @parentStyle: pointer to the parent stylesheet (if it exists)
6539  *
6540  * parse an XSLT stylesheet building the associated structures
6541  * except the processing not needed for imported documents.
6542  *
6543  * Returns a new XSLT stylesheet structure.
6544  */
6545 
6546 xsltStylesheetPtr
6547 xsltParseStylesheetImportedDoc(xmlDocPtr doc,
6548                    xsltStylesheetPtr parentStyle) {
6549     xsltStylesheetPtr retStyle;
6550 
6551     if (doc == NULL)
6552     return(NULL);
6553 
6554     retStyle = xsltNewStylesheetInternal(parentStyle);
6555     if (retStyle == NULL)
6556     return(NULL);
6557 
6558     if (xsltParseStylesheetUser(retStyle, doc) != 0) {
6559         xsltFreeStylesheet(retStyle);
6560         return(NULL);
6561     }
6562 
6563     return(retStyle);
6564 }
6565 
6566 /**
6567  * xsltParseStylesheetUser:
6568  * @style: pointer to the stylesheet
6569  * @doc:  an xmlDoc parsed XML
6570  *
6571  * Parse an XSLT stylesheet with a user-provided stylesheet struct.
6572  *
6573  * Returns 0 if successful, -1 in case of error.
6574  */
6575 int
6576 xsltParseStylesheetUser(xsltStylesheetPtr style, xmlDocPtr doc) {
6577     if ((style == NULL) || (doc == NULL))
6578     return(-1);
6579 
6580     /*
6581     * Adjust the string dict.
6582     */
6583     if (doc-&gt;dict != NULL) {
6584         xmlDictFree(style-&gt;dict);
6585     style-&gt;dict = doc-&gt;dict;
6586 #ifdef WITH_XSLT_DEBUG
6587         xsltGenericDebug(xsltGenericDebugContext,
6588         &quot;reusing dictionary from %s for stylesheet\n&quot;,
6589         doc-&gt;URL);
6590 #endif
6591     xmlDictReference(style-&gt;dict);
6592     }
6593 
6594     /*
6595     * TODO: Eliminate xsltGatherNamespaces(); we must not restrict
6596     *  the stylesheet to containt distinct namespace prefixes.
6597     */
6598     xsltGatherNamespaces(style);
6599 
6600 #ifdef XSLT_REFACTORED
6601     {
6602     xsltCompilerCtxtPtr cctxt;
6603     xsltStylesheetPtr oldCurSheet;
6604 
6605     if (style-&gt;parent == NULL) {
6606         xsltPrincipalStylesheetDataPtr principalData;
6607         /*
6608         * Create extra data for the principal stylesheet.
6609         */
6610         principalData = xsltNewPrincipalStylesheetData();
6611         if (principalData == NULL) {
6612         return(-1);
6613         }
6614         style-&gt;principalData = principalData;
6615         /*
6616         * Create the compilation context
6617         * ------------------------------
6618         * (only once; for the principal stylesheet).
6619         * This is currently the only function where the
6620         * compilation context is created.
6621         */
6622         cctxt = xsltCompilationCtxtCreate(style);
6623         if (cctxt == NULL) {
6624         return(-1);
6625         }
6626         style-&gt;compCtxt = (void *) cctxt;
6627         cctxt-&gt;style = style;
6628         cctxt-&gt;dict = style-&gt;dict;
6629         cctxt-&gt;psData = principalData;
6630         /*
6631         * Push initial dummy node info.
6632         */
6633         cctxt-&gt;depth = -1;
6634         xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6635     } else {
6636         /*
6637         * Imported stylesheet.
6638         */
6639         cctxt = style-&gt;parent-&gt;compCtxt;
6640         style-&gt;compCtxt = cctxt;
6641     }
6642     /*
6643     * Save the old and set the current stylesheet structure in the
6644     * compilation context.
6645     */
6646     oldCurSheet = cctxt-&gt;style;
6647     cctxt-&gt;style = style;
6648 
6649     style-&gt;doc = doc;
6650     xsltParseStylesheetProcess(style, doc);
6651 
6652     cctxt-&gt;style = oldCurSheet;
6653     if (style-&gt;parent == NULL) {
6654         /*
6655         * Pop the initial dummy node info.
6656         */
6657         xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6658     } else {
6659         /*
6660         * Clear the compilation context of imported
6661         * stylesheets.
6662         * TODO: really?
6663         */
6664         /* style-&gt;compCtxt = NULL; */
6665     }
6666 
6667 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
6668         if (style-&gt;errors != 0) {
6669             /*
6670             * Restore all changes made to namespace URIs of ns-decls.
6671             */
6672             if (cctxt-&gt;psData-&gt;nsMap)
6673                 xsltRestoreDocumentNamespaces(cctxt-&gt;psData-&gt;nsMap, doc);
6674         }
6675 #endif
6676 
6677         if (style-&gt;parent == NULL) {
6678             xsltCompilationCtxtFree(style-&gt;compCtxt);
6679             style-&gt;compCtxt = NULL;
6680         }
6681     }
6682 
6683 #else /* XSLT_REFACTORED */
6684     /*
6685     * Old behaviour.
6686     */
6687     style-&gt;doc = doc;
6688     if (xsltParseStylesheetProcess(style, doc) == NULL) {
6689         style-&gt;doc = NULL;
6690         return(-1);
6691     }
6692 #endif /* else of XSLT_REFACTORED */
6693 
6694     if (style-&gt;errors != 0) {
6695         /*
6696         * Detach the doc from the stylesheet; otherwise the doc
6697         * will be freed in xsltFreeStylesheet().
6698         */
6699         style-&gt;doc = NULL;
6700         /*
6701         * Cleanup the doc if its the main stylesheet.
6702         */
6703         if (style-&gt;parent == NULL)
6704             xsltCleanupStylesheetTree(doc, xmlDocGetRootElement(doc));
6705         return(-1);
6706     }
6707 
6708     if (style-&gt;parent == NULL)
6709         xsltResolveStylesheetAttributeSet(style);
6710 
6711     return(0);
6712 }
6713 
6714 /**
6715  * xsltParseStylesheetDoc:
6716  * @doc:  and xmlDoc parsed XML
6717  *
6718  * parse an XSLT stylesheet, building the associated structures.  doc
6719  * is kept as a reference within the returned stylesheet, so changes
6720  * to doc after the parsing will be reflected when the stylesheet
6721  * is applied, and the doc is automatically freed when the
6722  * stylesheet is closed.
6723  *
6724  * Returns a new XSLT stylesheet structure.
6725  */
6726 
6727 xsltStylesheetPtr
6728 xsltParseStylesheetDoc(xmlDocPtr doc) {
6729     xsltInitGlobals();
6730 
6731     return(xsltParseStylesheetImportedDoc(doc, NULL));
6732 }
6733 
6734 /**
6735  * xsltParseStylesheetFile:
6736  * @filename:  the filename/URL to the stylesheet
6737  *
6738  * Load and parse an XSLT stylesheet
6739  *
6740  * Returns a new XSLT stylesheet structure.
6741  */
6742 
6743 xsltStylesheetPtr
6744 xsltParseStylesheetFile(const xmlChar* filename) {
6745     xsltSecurityPrefsPtr sec;
6746     xsltStylesheetPtr ret;
6747     xmlDocPtr doc;
6748 
6749     xsltInitGlobals();
6750 
6751     if (filename == NULL)
6752     return(NULL);
6753 
6754 #ifdef WITH_XSLT_DEBUG_PARSING
6755     xsltGenericDebug(xsltGenericDebugContext,
6756         &quot;xsltParseStylesheetFile : parse %s\n&quot;, filename);
6757 #endif
6758 
6759     /*
6760      * Security framework check
6761      */
6762     sec = xsltGetDefaultSecurityPrefs();
6763     if (sec != NULL) {
6764     int res;
6765 
6766     res = xsltCheckRead(sec, NULL, filename);
6767     if (res &lt;= 0) {
6768             if (res == 0)
6769                 xsltTransformError(NULL, NULL, NULL,
6770                      &quot;xsltParseStylesheetFile: read rights for %s denied\n&quot;,
6771                                  filename);
6772         return(NULL);
6773     }
6774     }
6775 
6776     doc = xsltDocDefaultLoader(filename, NULL, XSLT_PARSE_OPTIONS,
6777                                NULL, XSLT_LOAD_START);
6778     if (doc == NULL) {
6779     xsltTransformError(NULL, NULL, NULL,
6780         &quot;xsltParseStylesheetFile : cannot parse %s\n&quot;, filename);
6781     return(NULL);
6782     }
6783     ret = xsltParseStylesheetDoc(doc);
6784     if (ret == NULL) {
6785     xmlFreeDoc(doc);
6786     return(NULL);
6787     }
6788 
6789     return(ret);
6790 }
6791 
6792 /************************************************************************
6793  *                                  *
6794  *          Handling of Stylesheet PI           *
6795  *                                  *
6796  ************************************************************************/
6797 
6798 #define CUR (*cur)
6799 #define SKIP(val) cur += (val)
6800 #define NXT(val) cur[(val)]
6801 #define SKIP_BLANKS                     \
6802     while (IS_BLANK(CUR)) NEXT
6803 #define NEXT ((*cur) ?  cur++ : cur)
6804 
6805 /**
6806  * xsltParseStylesheetPI:
6807  * @value: the value of the PI
6808  *
6809  * This function checks that the type is text/xml and extracts
6810  * the URI-Reference for the stylesheet
6811  *
6812  * Returns the URI-Reference for the stylesheet or NULL (it need to
6813  *         be freed by the caller)
6814  */
6815 static xmlChar *
6816 xsltParseStylesheetPI(const xmlChar *value) {
6817     const xmlChar *cur;
6818     const xmlChar *start;
6819     xmlChar *val;
6820     xmlChar tmp;
6821     xmlChar *href = NULL;
6822     int isXml = 0;
6823 
6824     if (value == NULL)
6825     return(NULL);
6826 
6827     cur = value;
6828     while (CUR != 0) {
6829     SKIP_BLANKS;
6830     if ((CUR == &#39;t&#39;) &amp;&amp; (NXT(1) == &#39;y&#39;) &amp;&amp; (NXT(2) == &#39;p&#39;) &amp;&amp;
6831         (NXT(3) == &#39;e&#39;)) {
6832         SKIP(4);
6833         SKIP_BLANKS;
6834         if (CUR != &#39;=&#39;)
6835         continue;
6836         NEXT;
6837         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;))
6838         continue;
6839         tmp = CUR;
6840         NEXT;
6841         start = cur;
6842         while ((CUR != 0) &amp;&amp; (CUR != tmp))
6843         NEXT;
6844         if (CUR != tmp)
6845         continue;
6846         val = xmlStrndup(start, cur - start);
6847         NEXT;
6848         if (val == NULL)
6849         return(NULL);
6850         if ((xmlStrcasecmp(val, BAD_CAST &quot;text/xml&quot;)) &amp;&amp;
6851         (xmlStrcasecmp(val, BAD_CAST &quot;text/xsl&quot;))) {
6852                 xmlFree(val);
6853         break;
6854         }
6855         isXml = 1;
6856         xmlFree(val);
6857     } else if ((CUR == &#39;h&#39;) &amp;&amp; (NXT(1) == &#39;r&#39;) &amp;&amp; (NXT(2) == &#39;e&#39;) &amp;&amp;
6858         (NXT(3) == &#39;f&#39;)) {
6859         SKIP(4);
6860         SKIP_BLANKS;
6861         if (CUR != &#39;=&#39;)
6862         continue;
6863         NEXT;
6864         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;))
6865         continue;
6866         tmp = CUR;
6867         NEXT;
6868         start = cur;
6869         while ((CUR != 0) &amp;&amp; (CUR != tmp))
6870         NEXT;
6871         if (CUR != tmp)
6872         continue;
6873         if (href == NULL)
6874         href = xmlStrndup(start, cur - start);
6875         NEXT;
6876     } else {
6877         while ((CUR != 0) &amp;&amp; (!IS_BLANK(CUR)))
6878         NEXT;
6879     }
6880 
6881     }
6882 
6883     if (!isXml) {
6884     if (href != NULL)
6885         xmlFree(href);
6886     href = NULL;
6887     }
6888     return(href);
6889 }
6890 
6891 /**
6892  * xsltLoadStylesheetPI:
6893  * @doc:  a document to process
6894  *
6895  * This function tries to locate the stylesheet PI in the given document
6896  * If found, and if contained within the document, it will extract
6897  * that subtree to build the stylesheet to process @doc (doc itself will
6898  * be modified). If found but referencing an external document it will
6899  * attempt to load it and generate a stylesheet from it. In both cases,
6900  * the resulting stylesheet and the document need to be freed once the
6901  * transformation is done.
6902  *
6903  * Returns a new XSLT stylesheet structure or NULL if not found.
6904  */
6905 xsltStylesheetPtr
6906 xsltLoadStylesheetPI(xmlDocPtr doc) {
6907     xmlNodePtr child;
6908     xsltStylesheetPtr ret = NULL;
6909     xmlChar *href = NULL;
6910     xmlURIPtr URI;
6911 
6912     xsltInitGlobals();
6913 
6914     if (doc == NULL)
6915     return(NULL);
6916 
6917     /*
6918      * Find the text/xml stylesheet PI id any before the root
6919      */
6920     child = doc-&gt;children;
6921     while ((child != NULL) &amp;&amp; (child-&gt;type != XML_ELEMENT_NODE)) {
6922     if ((child-&gt;type == XML_PI_NODE) &amp;&amp;
6923         (xmlStrEqual(child-&gt;name, BAD_CAST &quot;xml-stylesheet&quot;))) {
6924         href = xsltParseStylesheetPI(child-&gt;content);
6925         if (href != NULL)
6926         break;
6927     }
6928     child = child-&gt;next;
6929     }
6930 
6931     /*
6932      * If found check the href to select processing
6933      */
6934     if (href != NULL) {
6935 #ifdef WITH_XSLT_DEBUG_PARSING
6936     xsltGenericDebug(xsltGenericDebugContext,
6937         &quot;xsltLoadStylesheetPI : found PI href=%s\n&quot;, href);
6938 #endif
6939     URI = xmlParseURI((const char *) href);
6940     if (URI == NULL) {
6941         xsltTransformError(NULL, NULL, child,
6942             &quot;xml-stylesheet : href %s is not valid\n&quot;, href);
6943         xmlFree(href);
6944         return(NULL);
6945     }
6946     if ((URI-&gt;fragment != NULL) &amp;&amp; (URI-&gt;scheme == NULL) &amp;&amp;
6947             (URI-&gt;opaque == NULL) &amp;&amp; (URI-&gt;authority == NULL) &amp;&amp;
6948             (URI-&gt;server == NULL) &amp;&amp; (URI-&gt;user == NULL) &amp;&amp;
6949             (URI-&gt;path == NULL) &amp;&amp; (URI-&gt;query == NULL)) {
6950         xmlAttrPtr ID;
6951 
6952 #ifdef WITH_XSLT_DEBUG_PARSING
6953         xsltGenericDebug(xsltGenericDebugContext,
6954             &quot;xsltLoadStylesheetPI : Reference to ID %s\n&quot;, href);
6955 #endif
6956         if (URI-&gt;fragment[0] == &#39;#&#39;)
6957         ID = xmlGetID(doc, (const xmlChar *) &amp;(URI-&gt;fragment[1]));
6958         else
6959         ID = xmlGetID(doc, (const xmlChar *) URI-&gt;fragment);
6960         if (ID == NULL) {
6961         xsltTransformError(NULL, NULL, child,
6962             &quot;xml-stylesheet : no ID %s found\n&quot;, URI-&gt;fragment);
6963         } else {
6964         xmlDocPtr fake;
6965         xmlNodePtr subtree, newtree;
6966         xmlNsPtr ns;
6967 
6968 #ifdef WITH_XSLT_DEBUG
6969         xsltGenericDebug(xsltGenericDebugContext,
6970             &quot;creating new document from %s for embedded stylesheet\n&quot;,
6971             doc-&gt;URL);
6972 #endif
6973         /*
6974          * move the subtree in a new document passed to
6975          * the stylesheet analyzer
6976          */
6977         subtree = ID-&gt;parent;
6978         fake = xmlNewDoc(NULL);
6979         if (fake != NULL) {
6980             /*
6981             * Should the dictionary still be shared even though
6982             * the nodes are being copied rather than moved?
6983             */
6984             fake-&gt;dict = doc-&gt;dict;
6985             xmlDictReference(doc-&gt;dict);
6986 #ifdef WITH_XSLT_DEBUG
6987             xsltGenericDebug(xsltGenericDebugContext,
6988             &quot;reusing dictionary from %s for embedded stylesheet\n&quot;,
6989             doc-&gt;URL);
6990 #endif
6991 
6992             newtree = xmlDocCopyNode(subtree, fake, 1);
6993 
6994             fake-&gt;URL = xmlNodeGetBase(doc, subtree-&gt;parent);
6995 #ifdef WITH_XSLT_DEBUG
6996             xsltGenericDebug(xsltGenericDebugContext,
6997             &quot;set base URI for embedded stylesheet as %s\n&quot;,
6998             fake-&gt;URL);
6999 #endif
7000 
7001             /*
7002             * Add all namespaces in scope of embedded stylesheet to
7003             * root element of newly created stylesheet document
7004             */
7005             while ((subtree = subtree-&gt;parent) != (xmlNodePtr)doc) {
7006             for (ns = subtree-&gt;ns; ns; ns = ns-&gt;next) {
7007                 xmlNewNs(newtree,  ns-&gt;href, ns-&gt;prefix);
7008             }
7009             }
7010 
7011             xmlAddChild((xmlNodePtr)fake, newtree);
7012             ret = xsltParseStylesheetDoc(fake);
7013             if (ret == NULL)
7014             xmlFreeDoc(fake);
7015         }
7016         }
7017     } else {
7018         xmlChar *URL, *base;
7019 
7020         /*
7021          * Reference to an external stylesheet
7022          */
7023 
7024         base = xmlNodeGetBase(doc, (xmlNodePtr) doc);
7025         URL = xmlBuildURI(href, base);
7026         if (URL != NULL) {
7027 #ifdef WITH_XSLT_DEBUG_PARSING
7028         xsltGenericDebug(xsltGenericDebugContext,
7029             &quot;xsltLoadStylesheetPI : fetching %s\n&quot;, URL);
7030 #endif
7031         ret = xsltParseStylesheetFile(URL);
7032         xmlFree(URL);
7033         } else {
7034 #ifdef WITH_XSLT_DEBUG_PARSING
7035         xsltGenericDebug(xsltGenericDebugContext,
7036             &quot;xsltLoadStylesheetPI : fetching %s\n&quot;, href);
7037 #endif
7038         ret = xsltParseStylesheetFile(href);
7039         }
7040         if (base != NULL)
7041         xmlFree(base);
7042     }
7043     xmlFreeURI(URI);
7044     xmlFree(href);
7045     }
7046     return(ret);
7047 }
    </pre>
  </body>
</html>