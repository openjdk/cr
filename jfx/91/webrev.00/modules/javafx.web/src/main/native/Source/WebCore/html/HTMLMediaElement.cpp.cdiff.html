<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMarqueeElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,13 ***</span>
<span class="line-new-header">--- 34,15 ---</span>
  #include &quot;Blob.h&quot;
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;CSSValueKeywords.h&quot;
  #include &quot;ChromeClient.h&quot;
  #include &quot;CommonVM.h&quot;
<span class="line-added">+ #include &quot;ContentRuleListResults.h&quot;</span>
  #include &quot;ContentSecurityPolicy.h&quot;
  #include &quot;ContentType.h&quot;
  #include &quot;CookieJar.h&quot;
<span class="line-added">+ #include &quot;CustomHeaderFields.h&quot;</span>
  #include &quot;DeprecatedGlobalSettings.h&quot;
  #include &quot;DiagnosticLoggingClient.h&quot;
  #include &quot;DiagnosticLoggingKeys.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;DocumentLoader.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,10 ***</span>
<span class="line-new-header">--- 50,11 ---</span>
  #include &quot;EventNames.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;FrameView.h&quot;
<span class="line-added">+ #include &quot;FullscreenManager.h&quot;</span>
  #include &quot;HTMLParserIdioms.h&quot;
  #include &quot;HTMLSourceElement.h&quot;
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;JSDOMException.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,12 ***</span>
  #include &quot;NetworkingContext.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PageGroup.h&quot;
  #include &quot;PlatformMediaSessionManager.h&quot;
  #include &quot;ProgressTracker.h&quot;
<span class="line-removed">- #include &quot;PublicSuffix.h&quot;</span>
  #include &quot;Quirks.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderVideo.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;ResourceLoadInfo.h&quot;
<span class="line-new-header">--- 74,12 ---</span>
  #include &quot;NetworkingContext.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PageGroup.h&quot;
  #include &quot;PlatformMediaSessionManager.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;Quirks.h&quot;
<span class="line-added">+ #include &quot;RegistrableDomain.h&quot;</span>
  #include &quot;RenderLayerCompositor.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderVideo.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;ResourceLoadInfo.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,11 ***</span>
  #endif
  
  #if ENABLE(MEDIA_STREAM)
  #include &quot;DOMURL.h&quot;
  #include &quot;MediaStream.h&quot;
<span class="line-removed">- #include &quot;MediaStreamRegistry.h&quot;</span>
  #endif
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
  #include &quot;WebKitMediaKeyNeededEvent.h&quot;
  #include &quot;WebKitMediaKeys.h&quot;
<span class="line-new-header">--- 142,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,10 ***</span>
<span class="line-new-header">--- 311,11 ---</span>
  
  private:
      HTMLMediaElement&amp; m_element;
  };
  
<span class="line-added">+ #endif</span>
  
  struct HTMLMediaElement::TrackGroup {
      enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
  
      TrackGroup(GroupKind kind)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,11 ***</span>
      RefPtr&lt;TextTrack&gt; visibleTrack;
      RefPtr&lt;TextTrack&gt; defaultTrack;
      GroupKind kind;
      bool hasSrcLang { false };
  };
<span class="line-removed">- #endif</span>
  
  HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
  {
      static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
      return elements;
<span class="line-new-header">--- 327,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,18 ***</span>
      // Even if this video is not a candidate, if it is visible to the user and large enough
      // to be main content, it poses a risk for being confused with main content.
      return true;
  }
  
<span class="line-removed">- #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed">- static uint64_t nextLogIdentifier()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static uint64_t logIdentifier = cryptographicallyRandomNumber();</span>
<span class="line-removed">-     return ++logIdentifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
      : HTMLElement(tagName, document)
      , ActiveDOMObject(document)
      , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
      , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
<span class="line-new-header">--- 416,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,11 ***</span>
      , m_closedCaptionsVisible(false)
      , m_webkitLegacyClosedCaptionOverride(false)
      , m_completelyLoaded(false)
      , m_havePreparedToPlay(false)
      , m_parsingInProgress(createdByParser)
<span class="line-removed">-     , m_shouldBufferData(true)</span>
      , m_elementIsHidden(document.hidden())
      , m_creatingControls(false)
      , m_receivedLayoutSizeChanged(false)
      , m_hasEverNotifiedAboutPlaying(false)
      , m_hasEverHadAudio(false)
<span class="line-new-header">--- 447,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,11 ***</span>
      , m_haveVisibleTextTrack(false)
      , m_processingPreferenceChange(false)
  #endif
  #if !RELEASE_LOG_DISABLED
      , m_logger(&amp;document.logger())
<span class="line-modified">!     , m_logIdentifier(nextLogIdentifier())</span>
  #endif
  {
      allMediaElements().add(this);
  
      ALWAYS_LOG(LOGIDENTIFIER);
<span class="line-new-header">--- 465,11 ---</span>
      , m_haveVisibleTextTrack(false)
      , m_processingPreferenceChange(false)
  #endif
  #if !RELEASE_LOG_DISABLED
      , m_logger(&amp;document.logger())
<span class="line-modified">!     , m_logIdentifier(uniqueLogIdentifier())</span>
  #endif
  {
      allMediaElements().add(this);
  
      ALWAYS_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,11 ***</span>
      InspectorInstrumentation::addEventListenersToNode(*this);
  }
  
  void HTMLMediaElement::finishInitialization()
  {
<span class="line-modified">!     m_mediaSession = std::make_unique&lt;MediaElementSession&gt;(*this);</span>
  
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
<span class="line-new-header">--- 479,11 ---</span>
      InspectorInstrumentation::addEventListenersToNode(*this);
  }
  
  void HTMLMediaElement::finishInitialization()
  {
<span class="line-modified">!     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);</span>
  
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,36 ***</span>
      }
  
      m_mediaSession = nullptr;
      schedulePlaybackControlsManagerUpdate();
  }
<span class="line-removed">- </span>
<span class="line-removed">- static bool needsAutoplayPlayPauseEventsQuirk(const Document&amp; document)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* page = document.page();</span>
<span class="line-removed">-     if (!page || !page-&gt;settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed">-     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::SynthesizedPauseEvents);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
  {
<span class="line-removed">-     auto allSessions = PlatformMediaSessionManager::sharedManager().currentSessionsMatching([] (const PlatformMediaSession&amp; session) {</span>
<span class="line-removed">-         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- </span>
      Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
      bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<span class="line-modified">!     for (auto&amp; session : allSessions) {</span>
<span class="line-modified">!         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(*session), purpose);</span>
          if (mediaElementSessionInfo.canShowControlsManager)
              candidateSessions.append(mediaElementSessionInfo);
          else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
              atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<span class="line-modified">!     }</span>
  
      if (!candidateSessions.size())
          return nullptr;
  
      std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
<span class="line-new-header">--- 652,23 ---</span>
      }
  
      m_mediaSession = nullptr;
      schedulePlaybackControlsManagerUpdate();
  }
  RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
  {
      Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
      bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<span class="line-modified">!     PlatformMediaSessionManager::sharedManager().forEachMatchingSession([](auto&amp; session) {</span>
<span class="line-modified">!         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-added">+     }, [&amp;](auto&amp; session) {</span>
<span class="line-added">+         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);</span>
          if (mediaElementSessionInfo.canShowControlsManager)
              candidateSessions.append(mediaElementSessionInfo);
          else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
              atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<span class="line-modified">!     });</span>
  
      if (!candidateSessions.size())
          return nullptr;
  
      std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 821,11 ***</span>
  bool HTMLMediaElement::isMouseFocusable() const
  {
      return false;
  }
  
<span class="line-modified">! void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>
  {
      if (name == srcAttr) {
          // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
          // Location of the Media Resource
          // 12 February 2017
<span class="line-new-header">--- 801,16 ---</span>
  bool HTMLMediaElement::isMouseFocusable() const
  {
      return false;
  }
  
<span class="line-modified">! bool HTMLMediaElement::isInteractiveContent() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return controls();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
  {
      if (name == srcAttr) {
          // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
          // Location of the Media Resource
          // 12 February 2017
</pre>
<hr />
<pre>
<span class="line-old-header">*** 855,11 ***</span>
  
      } else if (name == mediagroupAttr)
          setMediaGroup(value);
      else if (name == autoplayAttr) {
          if (processingUserGestureForMedia())
<span class="line-modified">!             removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
      } else if (name == titleAttr) {
          if (m_mediaSession)
              m_mediaSession-&gt;clientCharacteristicsChanged();
      }
      else
<span class="line-new-header">--- 840,11 ---</span>
  
      } else if (name == mediagroupAttr)
          setMediaGroup(value);
      else if (name == autoplayAttr) {
          if (processingUserGestureForMedia())
<span class="line-modified">!             removeBehaviorRestrictionsAfterFirstUserGesture();</span>
      } else if (name == titleAttr) {
          if (m_mediaSession)
              m_mediaSession-&gt;clientCharacteristicsChanged();
      }
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1027,11 ***</span>
  {
      m_hasEverHadAudio |= hasAudio();
      m_hasEverHadVideo |= hasVideo();
  }
  
<span class="line-modified">! void HTMLMediaElement::scheduleEvent(const AtomicString&amp; eventName)</span>
  {
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
  
      // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
      // will trigger an ASSERT if this element has been marked for deletion.
<span class="line-new-header">--- 1012,11 ---</span>
  {
      m_hasEverHadAudio |= hasAudio();
      m_hasEverHadVideo |= hasVideo();
  }
  
<span class="line-modified">! void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)</span>
  {
      auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
  
      // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
      // will trigger an ASSERT if this element has been marked for deletion.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1103,12 ***</span>
  }
  
  void HTMLMediaElement::checkPlaybackTargetCompatablity()
  {
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
          m_failedToPlayToWirelessTarget = true;
          m_player-&gt;setShouldPlayToPlaybackTarget(false);
      }
  #endif
  }
<span class="line-new-header">--- 1088,15 ---</span>
  }
  
  void HTMLMediaElement::checkPlaybackTargetCompatablity()
  {
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added">+     auto logSiteIdentifier = LOGIDENTIFIER;</span>
<span class="line-added">+     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);</span>
      if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<span class="line-modified">!         UNUSED_PARAM(logSiteIdentifier);</span>
<span class="line-added">+         INFO_LOG(logSiteIdentifier, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
          m_failedToPlayToWirelessTarget = true;
          m_player-&gt;setShouldPlayToPlaybackTarget(false);
      }
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,11 ***</span>
      INFO_LOG(LOGIDENTIFIER);
      m_mediaProvider = WTFMove(mediaProvider);
      prepareForLoad();
  }
  
<span class="line-modified">! void HTMLMediaElement::setCrossOrigin(const AtomicString&amp; value)</span>
  {
      setAttributeWithoutSynchronization(crossoriginAttr, value);
  }
  
  String HTMLMediaElement::crossOrigin() const
<span class="line-new-header">--- 1123,11 ---</span>
      INFO_LOG(LOGIDENTIFIER);
      m_mediaProvider = WTFMove(mediaProvider);
      prepareForLoad();
  }
  
<span class="line-modified">! void HTMLMediaElement::setCrossOrigin(const AtomString&amp; value)</span>
  {
      setAttributeWithoutSynchronization(crossoriginAttr, value);
  }
  
  String HTMLMediaElement::crossOrigin() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,11 ***</span>
          case MediaPlayer::IsSupported:
              canPlay = &quot;probably&quot;_s;
              break;
      }
  
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER, &quot;[&quot;, mimeType, &quot;] -&gt; &quot;, canPlay);</span>
  
      return canPlay;
  }
  
  double HTMLMediaElement::getStartDate() const
<span class="line-new-header">--- 1161,11 ---</span>
          case MediaPlayer::IsSupported:
              canPlay = &quot;probably&quot;_s;
              break;
      }
  
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);</span>
  
      return canPlay;
  }
  
  double HTMLMediaElement::getStartDate() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,13 ***</span>
  {
      Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
  
      INFO_LOG(LOGIDENTIFIER);
  
<span class="line-removed">-     if (processingUserGestureForMedia())</span>
<span class="line-removed">-         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
<span class="line-removed">- </span>
      prepareForLoad();
      m_resourceSelectionTaskQueue.enqueueTask([this] {
          prepareToPlay();
      });
  }
<span class="line-new-header">--- 1179,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1206,11 ***</span>
  {
      // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
      // The Media Element Load Algorithm
      // 12 February 2017
  
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER);</span>
  
      // 1 - Abort any already-running instance of the resource selection algorithm for this element.
      // Perform the cleanup required for the resource load algorithm to run.
      stopPeriodicTimers();
      m_resourceSelectionTaskQueue.cancelAllTasks();
<span class="line-new-header">--- 1191,14 ---</span>
  {
      // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
      // The Media Element Load Algorithm
      // 12 February 2017
  
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, &quot;gesture = &quot;, processingUserGestureForMedia());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (processingUserGestureForMedia())</span>
<span class="line-added">+         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
  
      // 1 - Abort any already-running instance of the resource selection algorithm for this element.
      // Perform the cleanup required for the resource load algorithm to run.
      stopPeriodicTimers();
      m_resourceSelectionTaskQueue.cancelAllTasks();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1256,14 ***</span>
          // 6.3 - If the media elementâ€™s assigned media provider object is a MediaSource object, then detach it.
  #if ENABLE(MEDIA_SOURCE)
          detachMediaSource();
  #endif
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
          // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
          forgetResourceSpecificTracks();
<span class="line-removed">- #endif</span>
  
          // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
          m_readyState = HAVE_NOTHING;
          m_readyStateMaximum = HAVE_NOTHING;
  
<span class="line-new-header">--- 1244,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1513,11 ***</span>
  
  void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
  {
      ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
  
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, initialURL, contentType.raw(), keySystem);</span>
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame) {
          mediaLoadingFailed(MediaPlayer::FormatError);
          return;
<span class="line-new-header">--- 1499,11 ---</span>
  
  void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
  {
      ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
  
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);</span>
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame) {
          mediaLoadingFailed(MediaPlayer::FormatError);
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1535,11 ***</span>
          return;
      }
  
  #if ENABLE(CONTENT_EXTENSIONS)
      if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<span class="line-modified">!         if (page-&gt;userContentProvider().processContentExtensionRulesForLoad(url, ResourceType::Media, *documentLoader).blockedLoad) {</span>
              mediaLoadingFailed(MediaPlayer::FormatError);
              return;
          }
      }
  #endif
<span class="line-new-header">--- 1521,11 ---</span>
          return;
      }
  
  #if ENABLE(CONTENT_EXTENSIONS)
      if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<span class="line-modified">!         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {</span>
              mediaLoadingFailed(MediaPlayer::FormatError);
              return;
          }
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1567,11 ***</span>
      // cache is an internal detail not exposed through the media element API.
      m_currentSrc = url;
  
      if (resource) {
          url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;will load &quot;, url, &quot; from app cache&quot;);</span>
      }
  
      INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
  
      startProgressEventTimer();
<span class="line-new-header">--- 1553,11 ---</span>
      // cache is an internal detail not exposed through the media element API.
      m_currentSrc = url;
  
      if (resource) {
          url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);</span>
      }
  
      INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
  
      startProgressEventTimer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1609,22 ***</span>
              m_mediaSource = nullptr;
              mediaLoadingFailed(MediaPlayer::FormatError);
          }
      }
  #endif
<span class="line-removed">- </span>
  #if ENABLE(MEDIA_STREAM)
<span class="line-modified">!     if (!loadAttempted) {</span>
<span class="line-modified">!         if (!m_mediaStreamSrcObject &amp;&amp; url.protocolIs(mediaStreamBlobProtocol))</span>
<span class="line-modified">!             m_mediaStreamSrcObject = MediaStreamRegistry::shared().lookUp(url);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (m_mediaStreamSrcObject) {</span>
<span class="line-removed">-             loadAttempted = true;</span>
<span class="line-removed">-             ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-removed">-             if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-removed">-                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
<span class="line-removed">-         }</span>
      }
  #endif
  
      if (!loadAttempted &amp;&amp; m_blob) {
          loadAttempted = true;
<span class="line-new-header">--- 1595,16 ---</span>
              m_mediaSource = nullptr;
              mediaLoadingFailed(MediaPlayer::FormatError);
          }
      }
  #endif
  #if ENABLE(MEDIA_STREAM)
<span class="line-modified">!     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {</span>
<span class="line-modified">!         loadAttempted = true;</span>
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-modified">!         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-modified">!             mediaLoadingFailed(MediaPlayer::FormatError);</span>
      }
  #endif
  
      if (!loadAttempted &amp;&amp; m_blob) {
          loadAttempted = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1782,13 ***</span>
      if (nextInterestingTime.isValid() &amp;&amp; m_player) {
          m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
              if (!weakThis)
                  return;
  
<span class="line-modified">!             auto currentMediaTime = weakThis-&gt;currentMediaTime();</span>
<span class="line-modified">!             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime:&quot;, currentMediaTime);</span>
<span class="line-modified">!             weakThis-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
          }, nextInterestingTime);
      }
  
      if (!activeSetChanged)
          return;
<span class="line-new-header">--- 1762,13 ---</span>
      if (nextInterestingTime.isValid() &amp;&amp; m_player) {
          m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
              if (!weakThis)
                  return;
  
<span class="line-modified">!             auto currentMediaTime = this-&gt;currentMediaTime();</span>
<span class="line-modified">!             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);</span>
<span class="line-modified">!             this-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
          }, nextInterestingTime);
      }
  
      if (!activeSetChanged)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1966,11 ***</span>
  void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
  {
      if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
          m_audioTracks-&gt;scheduleChangeEvent();
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  }
  
  void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
  {
      bool trackIsLoaded = true;
<span class="line-new-header">--- 1946,11 ---</span>
  void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
  {
      if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
          m_audioTracks-&gt;scheduleChangeEvent();
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  }
  
  void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
  {
      bool trackIsLoaded = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2113,13 ***</span>
          return false;
      }
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame || !document().securityOrigin().canDisplay(url)) {
<span class="line-modified">!         if (actionIfInvalid == Complain)</span>
              FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
              ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
          return false;
      }
  
      if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
          ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
<span class="line-new-header">--- 2093,14 ---</span>
          return false;
      }
  
      RefPtr&lt;Frame&gt; frame = document().frame();
      if (!frame || !document().securityOrigin().canDisplay(url)) {
<span class="line-modified">!         if (actionIfInvalid == Complain) {</span>
              FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
              ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
<span class="line-added">+         }</span>
          return false;
      }
  
      if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
          ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2173,14 ***</span>
  
      // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
      // MEDIA_ERR_SRC_NOT_SUPPORTED.
      m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
      // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
      forgetResourceSpecificTracks();
<span class="line-removed">- #endif</span>
  
      // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
      m_networkState = NETWORK_NO_SOURCE;
  
      // 7 - Queue a task to fire a simple event named error at the media element.
<span class="line-new-header">--- 2154,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2310,14 ***</span>
          else
              INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
  
          // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
          // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
          forgetResourceSpecificTracks();
<span class="line-removed">- #endif</span>
  
          if (havePotentialSourceChild()) {
              INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
              scheduleNextSourceChild();
          } else {
<span class="line-new-header">--- 2289,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2409,27 ***</span>
      endProcessingMediaPlayerCallback();
  }
  
  SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
  {
<span class="line-modified">!     if (isAutoplaying()</span>
<span class="line-modified">!         &amp;&amp; mediaSession().autoplayPermitted()</span>
<span class="line-modified">!         &amp;&amp; paused()</span>
<span class="line-modified">!         &amp;&amp; autoplay()</span>
<span class="line-modified">!         &amp;&amp; !pausedForUserInteraction()</span>
<span class="line-modified">!         &amp;&amp; !document().isSandboxed(SandboxAutomaticFeatures)</span>
<span class="line-modified">!         &amp;&amp; m_readyState == HAVE_ENOUGH_DATA)</span>
<span class="line-modified">!         return mediaSession().playbackPermitted();</span>
  
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, &quot;page consent required&quot;);</span>
<span class="line-modified">!     return MediaPlaybackDenialReason::PageConsentRequired;</span>
  }
  
  void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
  {
<span class="line-modified">!     auto&amp; document = this-&gt;document();</span>
<span class="line-removed">-     if (!needsAutoplayPlayPauseEventsQuirk(document) &amp;&amp; !needsAutoplayPlayPauseEventsQuirk(document.topDocument()))</span>
          return;
  
      ALWAYS_LOG(LOGIDENTIFIER);
      scheduleEvent(eventNames().playingEvent);
      scheduleEvent(eventNames().pauseEvent);
<span class="line-new-header">--- 2386,53 ---</span>
      endProcessingMediaPlayerCallback();
  }
  
  SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
  {
<span class="line-modified">!     if (m_readyState != HAVE_ENOUGH_DATA) {</span>
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);</span>
<span class="line-modified">!         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (!isAutoplaying()) {</span>
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);</span>
<span class="line-modified">!         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     if (!mediaSession().autoplayPermitted()) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);</span>
<span class="line-added">+         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!paused()) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;!paused&quot;);</span>
<span class="line-added">+         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!autoplay()) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;!autoplay&quot;);</span>
<span class="line-added">+         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (pausedForUserInteraction()) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;pausedForUserInteraction&quot;);</span>
<span class="line-added">+         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (document().isSandboxed(SandboxAutomaticFeatures)) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;isSandboxed&quot;);</span>
<span class="line-added">+         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto permitted = mediaSession().playbackPermitted();</span>
<span class="line-modified">! #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">+     if (!permitted)</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, permitted.value());</span>
<span class="line-added">+     else</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;can transition!&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return permitted;</span>
  }
  
  void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
  {
<span class="line-modified">!     if (!document().quirks().needsAutoplayPlayPauseEvents())</span>
          return;
  
      ALWAYS_LOG(LOGIDENTIFIER);
      scheduleEvent(eventNames().playingEvent);
      scheduleEvent(eventNames().pauseEvent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3027,11 ***</span>
      }
      m_lastSeekTime = time;
  
      // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
      // the script. The remainder of these steps must be run asynchronously.
<span class="line-modified">!     m_pendingSeek = std::make_unique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
      if (fromDOM) {
          INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
          m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
      } else
          seekTask();
<span class="line-new-header">--- 3030,11 ---</span>
      }
      m_lastSeekTime = time;
  
      // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
      // the script. The remainder of these steps must be run asynchronously.
<span class="line-modified">!     m_pendingSeek = makeUnique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
      if (fromDOM) {
          INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
          m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
      } else
          seekTask();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3069,14 ***</span>
      // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
      // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
      // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
      // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
      // fire a &#39;seeked&#39; event.
<span class="line-modified">!     if (willLog(WTFLogLevelDebug)) {</span>
          MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
          if (time != mediaTime)
<span class="line-modified">!             DEBUG_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
      }
  
      time = m_player-&gt;mediaTimeForTimeValue(time);
  
      // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
<span class="line-new-header">--- 3072,14 ---</span>
      // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
      // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
      // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
      // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
      // fire a &#39;seeked&#39; event.
<span class="line-modified">!     if (willLog(WTFLogLevel::Debug)) {</span>
          MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
          if (time != mediaTime)
<span class="line-modified">!             INFO_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
      }
  
      time = m_player-&gt;mediaTimeForTimeValue(time);
  
      // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3099,11 ***</span>
      if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
          noSeekRequired = false;
  #endif
  
      if (noSeekRequired) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;seek to &quot;, time, &quot; ignored&quot;);</span>
          if (time == now) {
              scheduleEvent(eventNames().seekingEvent);
              scheduleTimeupdateEvent(false);
              scheduleEvent(eventNames().seekedEvent);
          }
<span class="line-new-header">--- 3102,11 ---</span>
      if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
          noSeekRequired = false;
  #endif
  
      if (noSeekRequired) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;ignored seek to &quot;, time);</span>
          if (time == now) {
              scheduleEvent(eventNames().seekingEvent);
              scheduleTimeupdateEvent(false);
              scheduleEvent(eventNames().seekedEvent);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3507,11 ***</span>
          promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
          return;
      }
  
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
  
      m_pendingPlayPromises.append(WTFMove(promise));
      playInternal();
  }
  
<span class="line-new-header">--- 3510,11 ---</span>
          promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
          return;
      }
  
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
  
      m_pendingPlayPromises.append(WTFMove(promise));
      playInternal();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3524,31 ***</span>
          if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
              setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
          return;
      }
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
  
      playInternal();
  }
  
  void HTMLMediaElement::playInternal()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
      if (isSuspended()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
          return;
      }
  
      if (!document().hasBrowsingContext()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
          return;
      }
  
      if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
          return;
      }
  
      // 4.8.10.9. Playing the media resource
      if (!m_player || m_networkState == NETWORK_EMPTY)
<span class="line-new-header">--- 3527,31 ---</span>
          if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
              setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
          return;
      }
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
  
      playInternal();
  }
  
  void HTMLMediaElement::playInternal()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
      if (isSuspended()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
          return;
      }
  
      if (!document().hasBrowsingContext()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
          return;
      }
  
      if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
          return;
      }
  
      // 4.8.10.9. Playing the media resource
      if (!m_player || m_networkState == NETWORK_EMPTY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3561,11 ***</span>
          m_mediaController-&gt;bringElementUpToSpeed(*this);
  
      if (m_paused) {
          m_paused = false;
          invalidateCachedTime();
<span class="line-modified">!         m_playbackStartedTime = currentMediaTime().toDouble();</span>
          scheduleEvent(eventNames().playEvent);
  
  #if ENABLE(MEDIA_SESSION)
          // 6.3 Activating a media session from a media element
          // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
<span class="line-new-header">--- 3564,16 ---</span>
          m_mediaController-&gt;bringElementUpToSpeed(*this);
  
      if (m_paused) {
          m_paused = false;
          invalidateCachedTime();
<span class="line-modified">! </span>
<span class="line-added">+         // This avoids the first timeUpdated event after playback starts, when currentTime is still</span>
<span class="line-added">+         // the same as it was when the video was paused (and the time hasn&#39;t changed yet).</span>
<span class="line-added">+         m_lastTimeUpdateEventMovieTime = currentMediaTime();</span>
<span class="line-added">+         m_playbackStartedTime = m_lastTimeUpdateEventMovieTime.toDouble();</span>
<span class="line-added">+ </span>
          scheduleEvent(eventNames().playEvent);
  
  #if ENABLE(MEDIA_SESSION)
          // 6.3 Activating a media session from a media element
          // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3620,32 ***</span>
  
      if (!m_mediaSession-&gt;playbackPermitted())
          return;
  
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
      pauseInternal();
  }
  
  
  void HTMLMediaElement::pauseInternal()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
      if (isSuspended()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
          return;
      }
  
      if (!document().hasBrowsingContext()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
          return;
      }
  
      if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
          return;
      }
  
      // 4.8.10.9. Playing the media resource
      if (!m_player || m_networkState == NETWORK_EMPTY) {
<span class="line-new-header">--- 3628,32 ---</span>
  
      if (!m_mediaSession-&gt;playbackPermitted())
          return;
  
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
      pauseInternal();
  }
  
  
  void HTMLMediaElement::pauseInternal()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
  
      if (isSuspended()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
          return;
      }
  
      if (!document().hasBrowsingContext()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
          return;
      }
  
      if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
          return;
      }
  
      // 4.8.10.9. Playing the media resource
      if (!m_player || m_networkState == NETWORK_EMPTY) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3691,14 ***</span>
  bool HTMLMediaElement::loop() const
  {
      return hasAttributeWithoutSynchronization(loopAttr);
  }
  
<span class="line-modified">! void HTMLMediaElement::setLoop(bool b)</span>
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">!     setBooleanAttribute(loopAttr, b);</span>
  }
  
  bool HTMLMediaElement::controls() const
  {
      RefPtr&lt;Frame&gt; frame = document().frame();
<span class="line-new-header">--- 3699,14 ---</span>
  bool HTMLMediaElement::loop() const
  {
      return hasAttributeWithoutSynchronization(loopAttr);
  }
  
<span class="line-modified">! void HTMLMediaElement::setLoop(bool loop)</span>
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, loop);</span>
<span class="line-modified">!     setBooleanAttribute(loopAttr, loop);</span>
  }
  
  bool HTMLMediaElement::controls() const
  {
      RefPtr&lt;Frame&gt; frame = document().frame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3708,14 ***</span>
          return true;
  
      return hasAttributeWithoutSynchronization(controlsAttr);
  }
  
<span class="line-modified">! void HTMLMediaElement::setControls(bool b)</span>
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">!     setBooleanAttribute(controlsAttr, b);</span>
  }
  
  double HTMLMediaElement::volume() const
  {
      return m_volume;
<span class="line-new-header">--- 3716,14 ---</span>
          return true;
  
      return hasAttributeWithoutSynchronization(controlsAttr);
  }
  
<span class="line-modified">! void HTMLMediaElement::setControls(bool controls)</span>
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, controls);</span>
<span class="line-modified">!     setBooleanAttribute(controlsAttr, controls);</span>
  }
  
  double HTMLMediaElement::volume() const
  {
      return m_volume;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3726,27 ***</span>
      INFO_LOG(LOGIDENTIFIER, volume);
  
      if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
          return Exception { IndexSizeError };
  
<span class="line-removed">- #if !PLATFORM(IOS_FAMILY)</span>
      if (m_volume == volume)
          return { };
  
      if (volume &amp;&amp; processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
      m_volume = volume;
      m_volumeInitialized = true;
      updateVolume();
      scheduleEvent(eventNames().volumechangeEvent);
  
      if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
          pauseInternal();
          setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
      }
  #endif
      return { };
  }
  
  bool HTMLMediaElement::muted() const
  {
<span class="line-new-header">--- 3734,39 ---</span>
      INFO_LOG(LOGIDENTIFIER, volume);
  
      if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
          return Exception { IndexSizeError };
  
      if (m_volume == volume)
          return { };
  
<span class="line-added">+ #if !PLATFORM(IOS_FAMILY)</span>
      if (volume &amp;&amp; processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
      m_volume = volume;
      m_volumeInitialized = true;
      updateVolume();
      scheduleEvent(eventNames().volumechangeEvent);
  
      if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
          pauseInternal();
          setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
      }
<span class="line-added">+ #else</span>
<span class="line-added">+     auto oldVolume = m_volume;</span>
<span class="line-added">+     m_volume = volume;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_volumeRevertTaskQueue.hasPendingTask())</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_volumeRevertTaskQueue.scheduleTask([this, oldVolume] {</span>
<span class="line-added">+         m_volume = oldVolume;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
  #endif
<span class="line-added">+ </span>
      return { };
  }
  
  bool HTMLMediaElement::muted() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3758,11 ***</span>
      INFO_LOG(LOGIDENTIFIER, muted);
  
      bool mutedStateChanged = m_muted != muted;
      if (mutedStateChanged || !m_explicitlyMuted) {
          if (processingUserGestureForMedia()) {
<span class="line-modified">!             removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
              if (hasAudio() &amp;&amp; muted)
                  userDidInterfereWithAutoplay();
          }
  
<span class="line-new-header">--- 3778,11 ---</span>
      INFO_LOG(LOGIDENTIFIER, muted);
  
      bool mutedStateChanged = m_muted != muted;
      if (mutedStateChanged || !m_explicitlyMuted) {
          if (processingUserGestureForMedia()) {
<span class="line-modified">!             removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
  
              if (hasAudio() &amp;&amp; muted)
                  userDidInterfereWithAutoplay();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4235,11 ***</span>
      removeTextTrack(textTrack);
  
      m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
  }
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
  void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
  {
      ASSERT(group.tracks.size());
  
      Page* page = document().page();
<span class="line-new-header">--- 4255,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4348,11 ***</span>
              m_webkitLegacyClosedCaptionOverride = true;
      }
  
      m_processingPreferenceChange = false;
  }
<span class="line-modified">! #endif</span>
  static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
  {
      JSC::VM&amp; vm = globalObject.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
<span class="line-new-header">--- 4367,11 ---</span>
              m_webkitLegacyClosedCaptionOverride = true;
      }
  
      m_processingPreferenceChange = false;
  }
<span class="line-modified">! </span>
  static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
  {
      JSC::VM&amp; vm = globalObject.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4360,19 ***</span>
      // Retrieve the controller through the JS object graph
      JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
      if (!mediaJSWrapperObject)
          return JSC::jsNull();
  
<span class="line-modified">!     JSC::Identifier controlsHost = JSC::Identifier::fromString(&amp;vm, &quot;controlsHost&quot;);</span>
      JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
      if (!controlsHostJSWrapperObject)
          return JSC::jsNull();
  
<span class="line-modified">!     JSC::Identifier controllerID = JSC::Identifier::fromString(&amp;vm, &quot;controller&quot;);</span>
      JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      return controllerJSWrapper;
  }
<span class="line-new-header">--- 4379,19 ---</span>
      // Retrieve the controller through the JS object graph
      JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
      if (!mediaJSWrapperObject)
          return JSC::jsNull();
  
<span class="line-modified">!     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
      JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
      if (!controlsHostJSWrapperObject)
          return JSC::jsNull();
  
<span class="line-modified">!     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
      JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
      RETURN_IF_EXCEPTION(scope, JSC::jsNull());
  
      return controllerJSWrapper;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4431,11 ***</span>
          // Name: updateCaptionContainer
          // Parameters:
          //     None
          // Return value:
          //     None
<span class="line-modified">!         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;updateCaptionContainer&quot;));</span>
          auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
          if (!methodObject)
              return false;
  
          JSC::CallData callData;
<span class="line-new-header">--- 4450,11 ---</span>
          // Name: updateCaptionContainer
          // Parameters:
          //     None
          // Return value:
          //     None
<span class="line-modified">!         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
          auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
          if (!methodObject)
              return false;
  
          JSC::CallData callData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4629,11 ***</span>
  URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
  {
      UNUSED_PARAM(keySystem);
  
      // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<span class="line-modified">!     bool shouldLog = willLog(WTFLogLevelDebug) &amp;&amp; actionIfInvalid != DoNothing;</span>
      if (shouldLog)
          INFO_LOG(LOGIDENTIFIER);
  
      if (!m_nextChildNodeToConsider) {
          if (shouldLog)
<span class="line-new-header">--- 4648,11 ---</span>
  URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
  {
      UNUSED_PARAM(keySystem);
  
      // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<span class="line-modified">!     bool shouldLog = willLog(WTFLogLevel::Debug) &amp;&amp; actionIfInvalid != DoNothing;</span>
      if (shouldLog)
          INFO_LOG(LOGIDENTIFIER);
  
      if (!m_nextChildNodeToConsider) {
          if (shouldLog)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4728,11 ***</span>
      return URL();
  }
  
  void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
  {
<span class="line-modified">!     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
          URL url = source.getNonEmptyURLAttribute(srcAttr);
          INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
      }
  
      if (!document().hasBrowsingContext()) {
<span class="line-new-header">--- 4747,11 ---</span>
      return URL();
  }
  
  void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
  {
<span class="line-modified">!     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
          URL url = source.getNonEmptyURLAttribute(srcAttr);
          INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
      }
  
      if (!document().hasBrowsingContext()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4780,11 ***</span>
      scheduleNextSourceChild();
  }
  
  void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
  {
<span class="line-modified">!     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
          URL url = source.getNonEmptyURLAttribute(srcAttr);
          INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
      }
  
      if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
<span class="line-new-header">--- 4799,11 ---</span>
      scheduleNextSourceChild();
  }
  
  void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
  {
<span class="line-modified">!     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
          URL url = source.getNonEmptyURLAttribute(srcAttr);
          INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
      }
  
      if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4796,11 ***</span>
      } else if (&amp;source == m_currentSourceNode) {
          // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
          // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
          // inserted in a video or audio element will have no effect.
          m_currentSourceNode = nullptr;
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode set to 0&quot;);</span>
      }
  }
  
  void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
  {
<span class="line-new-header">--- 4815,11 ---</span>
      } else if (&amp;source == m_currentSourceNode) {
          // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
          // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
          // inserted in a video or audio element will have no effect.
          m_currentSourceNode = nullptr;
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);</span>
      }
  }
  
  void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5359,26 ***</span>
          scheduleEvent(eventNames().volumechangeEvent);
      }
  #else
      // Avoid recursion when the player reports volume changes.
      if (!processingMediaPlayerCallback()) {
<span class="line-modified">!         Page* page = document().page();</span>
<span class="line-modified">!         double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-removed">-         bool shouldMute = effectiveMuted();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (m_mediaController) {</span>
<span class="line-removed">-             volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-removed">-             shouldMute = m_mediaController-&gt;muted() || (page &amp;&amp; page-&gt;isAudioMuted());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(MEDIA_SESSION)</span>
<span class="line-removed">-         if (m_shouldDuck)</span>
<span class="line-removed">-             volumeMultiplier *= 0.25;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-         m_player-&gt;setMuted(shouldMute);</span>
<span class="line-removed">-         m_player-&gt;setVolume(m_volume * volumeMultiplier);</span>
      }
  
  #if ENABLE(MEDIA_SESSION)
      document().updateIsPlayingMedia(m_elementID);
  #else
<span class="line-new-header">--- 5378,12 ---</span>
          scheduleEvent(eventNames().volumechangeEvent);
      }
  #else
      // Avoid recursion when the player reports volume changes.
      if (!processingMediaPlayerCallback()) {
<span class="line-modified">!         m_player-&gt;setMuted(effectiveMuted());</span>
<span class="line-modified">!         m_player-&gt;setVolume(effectiveVolume());</span>
      }
  
  #if ENABLE(MEDIA_SESSION)
      document().updateIsPlayingMedia(m_elementID);
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5442,14 ***</span>
          invalidateCachedTime();
  
          if (playerPaused) {
              m_mediaSession-&gt;clientWillBeginPlayback();
  
<span class="line-modified">!             // Set rate, muted before calling play in case they were set before the media engine was setup.</span>
<span class="line-modified">!             // The media engine should just stash the rate and muted values since it isn&#39;t already playing.</span>
              m_player-&gt;setRate(requestedPlaybackRate());
              m_player-&gt;setMuted(effectiveMuted());
  
              if (m_firstTimePlaying) {
                  // Log that a media element was played.
                  if (auto* page = document().page())
                      page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
<span class="line-new-header">--- 5447,15 ---</span>
          invalidateCachedTime();
  
          if (playerPaused) {
              m_mediaSession-&gt;clientWillBeginPlayback();
  
<span class="line-modified">!             // Set rate, muted and volume before calling play in case they were set before the media engine was set up.</span>
<span class="line-modified">!             // The media engine should just stash the rate, muted and volume values since it isn&#39;t already playing.</span>
              m_player-&gt;setRate(requestedPlaybackRate());
              m_player-&gt;setMuted(effectiveMuted());
<span class="line-added">+             m_player-&gt;setVolume(effectiveVolume());</span>
  
              if (m_firstTimePlaying) {
                  // Log that a media element was played.
                  if (auto* page = document().page())
                      page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5532,10 ***</span>
<span class="line-new-header">--- 5538,13 ---</span>
      m_configureTextTracksTask.cancelTask();
      m_checkPlaybackTargetCompatablityTask.cancelTask();
      m_updateMediaStateTask.cancelTask();
      m_mediaEngineUpdatedTask.cancelTask();
      m_updatePlayStateTask.cancelTask();
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     m_volumeRevertTaskQueue.cancelTask();</span>
<span class="line-added">+ #endif</span>
  }
  
  void HTMLMediaElement::userCancelledLoad()
  {
      INFO_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5710,10 ***</span>
<span class="line-new-header">--- 5719,13 ---</span>
      m_visibilityChangeTaskQueue.close();
  #if ENABLE(ENCRYPTED_MEDIA)
      m_encryptedMediaQueue.close();
  #endif
      m_asyncEventQueue.close();
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     m_volumeRevertTaskQueue.close();</span>
<span class="line-added">+ #endif</span>
  }
  
  void HTMLMediaElement::contextDestroyed()
  {
      closeTaskQueues();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5748,11 ***</span>
  
      switch (reason) {
      case ReasonForSuspension::PageCache:
          stopWithoutDestroyingMediaPlayer();
          m_asyncEventQueue.suspend();
<span class="line-modified">!         setShouldBufferData(false);</span>
          m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
          break;
      case ReasonForSuspension::PageWillBeSuspended:
      case ReasonForSuspension::JavaScriptDebuggerPaused:
      case ReasonForSuspension::WillDeferLoading:
<span class="line-new-header">--- 5760,11 ---</span>
  
      switch (reason) {
      case ReasonForSuspension::PageCache:
          stopWithoutDestroyingMediaPlayer();
          m_asyncEventQueue.suspend();
<span class="line-modified">!         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);</span>
          m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
          break;
      case ReasonForSuspension::PageWillBeSuspended:
      case ReasonForSuspension::JavaScriptDebuggerPaused:
      case ReasonForSuspension::WillDeferLoading:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5767,18 ***</span>
  
      setInActiveDocument(true);
  
      m_asyncEventQueue.resume();
  
<span class="line-removed">-     setShouldBufferData(true);</span>
<span class="line-removed">- </span>
      if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
          document().addMediaCanStartListener(*this);
      else
          setPausedInternal(false);
  
      m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
  
      if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
          // Restart the load if it was aborted in the middle by moving the document to the page cache.
          // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
          //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
<span class="line-new-header">--- 5779,17 ---</span>
  
      setInActiveDocument(true);
  
      m_asyncEventQueue.resume();
  
      if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
          document().addMediaCanStartListener(*this);
      else
          setPausedInternal(false);
  
      m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
<span class="line-added">+     m_mediaSession-&gt;updateBufferingPolicy();</span>
  
      if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
          // Restart the load if it was aborted in the middle by moving the document to the page cache.
          // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
          //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5849,11 ***</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
  void HTMLMediaElement::webkitShowPlaybackTargetPicker()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
      m_mediaSession-&gt;showPlaybackTargetPicker();
  }
  
  void HTMLMediaElement::wirelessRoutesAvailableDidChange()
  {
<span class="line-new-header">--- 5860,11 ---</span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
  void HTMLMediaElement::webkitShowPlaybackTargetPicker()
  {
      ALWAYS_LOG(LOGIDENTIFIER);
      if (processingUserGestureForMedia())
<span class="line-modified">!         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
      m_mediaSession-&gt;showPlaybackTargetPicker();
  }
  
  void HTMLMediaElement::wirelessRoutesAvailableDidChange()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5886,16 ***</span>
      });
  }
  
  void HTMLMediaElement::dispatchEvent(Event&amp; event)
  {
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER, &quot;dispatching &#39;&quot;, event.type(), &quot;&#39;&quot;);</span>
  
      HTMLElement::dispatchEvent(event);
  }
  
<span class="line-modified">! bool HTMLMediaElement::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::addEventListener(eventType, WTFMove(listener), options);
  
      bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
<span class="line-new-header">--- 5897,19 ---</span>
      });
  }
  
  void HTMLMediaElement::dispatchEvent(Event&amp; event)
  {
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER, event.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)</span>
<span class="line-added">+         document().userActivatedMediaFinishedPlaying();</span>
  
      HTMLElement::dispatchEvent(event);
  }
  
<span class="line-modified">! bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::addEventListener(eventType, WTFMove(listener), options);
  
      bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5911,11 ***</span>
  
      enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
      return true;
  }
  
<span class="line-modified">! bool HTMLMediaElement::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::removeEventListener(eventType, listener, options);
  
      if (!Node::removeEventListener(eventType, listener, options))
<span class="line-new-header">--- 5925,11 ---</span>
  
      enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
      return true;
  }
  
<span class="line-modified">! bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
  {
      if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
          return Node::removeEventListener(eventType, listener, options);
  
      if (!Node::removeEventListener(eventType, listener, options))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5991,21 ***</span>
  {
      if (m_videoFullscreenMode != VideoFullscreenModeNone)
          return true;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
          return true;
  #endif
  
      return false;
  }
  
  bool HTMLMediaElement::isStandardFullscreen() const
  {
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
          return true;
  #endif
  
      return m_videoFullscreenMode == VideoFullscreenModeStandard;
  }
<span class="line-new-header">--- 6005,21 ---</span>
  {
      if (m_videoFullscreenMode != VideoFullscreenModeNone)
          return true;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
          return true;
  #endif
  
      return false;
  }
  
  bool HTMLMediaElement::isStandardFullscreen() const
  {
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
          return true;
  #endif
  
      return m_videoFullscreenMode == VideoFullscreenModeStandard;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6029,11 ***</span>
      m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
      m_waitingToEnterFullscreen = true;
  
  #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
      if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<span class="line-modified">!         document().requestFullScreenForElement(this, Document::ExemptIFrameAllowFullScreenRequirement);</span>
          return;
      }
  #endif
  
      m_fullscreenTaskQueue.enqueueTask([this, mode] {
<span class="line-new-header">--- 6043,11 ---</span>
      m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
      m_waitingToEnterFullscreen = true;
  
  #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
      if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<span class="line-modified">!         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);</span>
          return;
      }
  #endif
  
      m_fullscreenTaskQueue.enqueueTask([this, mode] {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6066,13 ***</span>
      INFO_LOG(LOGIDENTIFIER);
  
      m_waitingToEnterFullscreen = false;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().settings().fullScreenEnabled() &amp;&amp; document().webkitCurrentFullScreenElement() == this) {</span>
<span class="line-modified">!         if (document().webkitIsFullScreen())</span>
<span class="line-modified">!             document().webkitCancelFullScreen();</span>
  
          if (m_videoFullscreenMode == VideoFullscreenModeStandard)
              return;
      }
  #endif
<span class="line-new-header">--- 6080,13 ---</span>
      INFO_LOG(LOGIDENTIFIER);
  
      m_waitingToEnterFullscreen = false;
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {</span>
<span class="line-modified">!         if (document().fullscreenManager().isFullscreen())</span>
<span class="line-modified">!             document().fullscreenManager().cancelFullscreen();</span>
  
          if (m_videoFullscreenMode == VideoFullscreenModeStandard)
              return;
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6110,11 ***</span>
          if (m_videoFullscreenStandby)
              document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
          else
              document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
          scheduleEvent(eventNames().webkitendfullscreenEvent);
<span class="line-removed">-         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);</span>
      }
  }
  
  WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
  {
<span class="line-new-header">--- 6124,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6425,17 ***</span>
  void HTMLMediaElement::resetMediaEngines()
  {
      MediaPlayer::resetMediaEngines();
  }
  
<span class="line-modified">! void HTMLMediaElement::privateBrowsingStateDidChange()</span>
  {
      if (!m_player)
          return;
  
<span class="line-modified">!     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();</span>
<span class="line-removed">-     m_player-&gt;setPrivateBrowsingMode(privateMode);</span>
  }
  
  MediaControls* HTMLMediaElement::mediaControls() const
  {
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
<span class="line-new-header">--- 6438,16 ---</span>
  void HTMLMediaElement::resetMediaEngines()
  {
      MediaPlayer::resetMediaEngines();
  }
  
<span class="line-modified">! void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)</span>
  {
      if (!m_player)
          return;
  
<span class="line-modified">!     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());</span>
  }
  
  MediaControls* HTMLMediaElement::mediaControls() const
  {
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6674,11 ***</span>
      if (m_isPlayingToWirelessTarget)
          setIsPlayingToWirelessTarget(false);
  #endif
  
      m_player = MediaPlayer::create(*this);
<span class="line-modified">!     m_player-&gt;setShouldBufferData(m_shouldBufferData);</span>
      schedulePlaybackControlsManagerUpdate();
  
  #if ENABLE(WEB_AUDIO)
      if (m_audioSourceNode) {
          // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
<span class="line-new-header">--- 6686,11 ---</span>
      if (m_isPlayingToWirelessTarget)
          setIsPlayingToWirelessTarget(false);
  #endif
  
      m_player = MediaPlayer::create(*this);
<span class="line-modified">!     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);</span>
      schedulePlaybackControlsManagerUpdate();
  
  #if ENABLE(WEB_AUDIO)
      if (m_audioSourceNode) {
          // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6892,11 ***</span>
      // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
      if (m_isPlayingToWirelessTarget)
          return SleepType::System;
  #endif
  
<span class="line-modified">!     bool shouldBeAbleToSleep = !hasVideo() || !hasAudio();</span>
  #if ENABLE(MEDIA_STREAM)
      // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
      // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
      shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
  #endif
<span class="line-new-header">--- 6904,14 ---</span>
      // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
      if (m_isPlayingToWirelessTarget)
          return SleepType::System;
  #endif
  
<span class="line-modified">!     if (PlatformMediaSessionManager::sharedManager().processIsSuspended())</span>
<span class="line-added">+         return SleepType::None;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool shouldBeAbleToSleep = mediaType() != PlatformMediaSession::VideoAudio;</span>
  #if ENABLE(MEDIA_STREAM)
      // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
      // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
      shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7079,11 ***</span>
  {
      auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
  
      m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
  
<span class="line-modified">!     return WTFMove(mediaResourceLoader);</span>
  }
  
  const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
  {
      return m_lastMediaResourceLoaderForTesting.get();
<span class="line-new-header">--- 7094,11 ---</span>
  {
      auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
  
      m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
  
<span class="line-modified">!     return mediaResourceLoader;</span>
  }
  
  const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
  {
      return m_lastMediaResourceLoaderForTesting.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7111,14 ***</span>
      return emptyString();
  }
  
  Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
  {
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
      if (Page* page = document().page())
          return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<span class="line-removed">- #endif</span>
      return Vector&lt;String&gt;();
  }
  
  #if PLATFORM(IOS_FAMILY)
  String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
<span class="line-new-header">--- 7126,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7180,11 ***</span>
  
      document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
  }
  #endif
  
<span class="line-modified">! void HTMLMediaElement::removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
  {
      MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
          (MediaElementSession::RequireUserGestureForLoad
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
          | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
<span class="line-new-header">--- 7193,11 ---</span>
  
      document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
  }
  #endif
  
<span class="line-modified">! void HTMLMediaElement::removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
  {
      MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
          (MediaElementSession::RequireUserGestureForLoad
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
          | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7195,10 ***</span>
<span class="line-new-header">--- 7208,12 ---</span>
          | MediaElementSession::RequireUserGestureForFullscreen
          | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
          | MediaElementSession::InvisibleAutoplayNotPermitted
          | MediaElementSession::RequireUserGestureToControlControlsManager);
  
<span class="line-added">+     m_removedBehaviorRestrictionsAfterFirstUserGesture = true;</span>
<span class="line-added">+ </span>
      m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
      document().topDocument().noteUserInteractionWithMediaElement();
  }
  
  void HTMLMediaElement::updateRateChangeRestrictions()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7244,11 ***</span>
      return *m_isolatedWorld;
  }
  
  bool HTMLMediaElement::ensureMediaControlsInjectedScript()
  {
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER);</span>
  
      Page* page = document().page();
      if (!page)
          return false;
  
<span class="line-new-header">--- 7259,11 ---</span>
      return *m_isolatedWorld;
  }
  
  bool HTMLMediaElement::ensureMediaControlsInjectedScript()
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER);</span>
  
      Page* page = document().page();
      if (!page)
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7258,11 ***</span>
  
      return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
          if (functionValue.isFunction(vm))
              return true;
  
  #ifndef NDEBUG
          // Setting a scriptURL allows the source to be debuggable in the inspector.
<span class="line-new-header">--- 7273,11 ---</span>
  
      return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isFunction(vm))
              return true;
  
  #ifndef NDEBUG
          // Setting a scriptURL allows the source to be debuggable in the inspector.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7310,19 ***</span>
          JSC::PutPropertySlot propertySlot(controllerValue);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
          if (!controllerObject)
              return false;
  
<span class="line-modified">!         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(&amp;exec, propertyName), propertyValue, propertySlot);</span>
  
          return true;
      });
  }
  
  void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
  {
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER);</span>
  
      if (!ensureMediaControlsInjectedScript())
          return;
  
      setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
<span class="line-new-header">--- 7325,19 ---</span>
          JSC::PutPropertySlot propertySlot(controllerValue);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
          if (!controllerObject)
              return false;
  
<span class="line-modified">!         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
  
          return true;
      });
  }
  
  void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER);</span>
  
      if (!ensureMediaControlsInjectedScript())
          return;
  
      setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7336,11 ***</span>
          //     2. This object (and HTMLMediaElement).
          //     3. The MediaControlsHost object.
          // Return value:
          //     A reference to the created media controller instance.
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
          if (functionValue.isUndefinedOrNull())
              return false;
  
          if (!m_mediaControlsHost)
              m_mediaControlsHost = MediaControlsHost::create(this);
<span class="line-new-header">--- 7351,11 ---</span>
          //     2. This object (and HTMLMediaElement).
          //     3. The MediaControlsHost object.
          // Return value:
          //     A reference to the created media controller instance.
  
<span class="line-modified">!         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
          if (functionValue.isUndefinedOrNull())
              return false;
  
          if (!m_mediaControlsHost)
              m_mediaControlsHost = MediaControlsHost::create(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7368,25 ***</span>
              return false;
  
          // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
          auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
          scope.assertNoException();
<span class="line-modified">!         auto controlsHost = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controlsHost&quot;);</span>
  
          ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
  
<span class="line-modified">!         mediaJSWrapperObject-&gt;putDirect(exec.vm(), controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
  
          auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
          if (!mediaControlsHostJSWrapperObject)
              return false;
  
<span class="line-modified">!         auto controller = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controller&quot;);</span>
  
          ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
  
<span class="line-modified">!         mediaControlsHostJSWrapperObject-&gt;putDirect(exec.vm(), controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
  
          updatePageScaleFactorJSProperty();
          updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
  
          if (UNLIKELY(scope.exception()))
<span class="line-new-header">--- 7383,25 ---</span>
              return false;
  
          // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
          auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
          scope.assertNoException();
<span class="line-modified">!         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
  
          ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
  
<span class="line-modified">!         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
  
          auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
          if (!mediaControlsHostJSWrapperObject)
              return false;
  
<span class="line-modified">!         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
  
          ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
  
<span class="line-modified">!         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
  
          updatePageScaleFactorJSProperty();
          updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
  
          if (UNLIKELY(scope.exception()))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7396,14 ***</span>
      });
  }
  
  void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
  {
<span class="line-modified">!     DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, dependsOnPageScale);</span>
  
      if (document().settings().mediaControlsScaleWithPageZoom()) {
<span class="line-modified">!         DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, &quot;forced to false by Settings value&quot;);</span>
          m_mediaControlsDependOnPageScaleFactor = false;
          return;
      }
  
      if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
<span class="line-new-header">--- 7411,14 ---</span>
      });
  }
  
  void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);</span>
  
      if (document().settings().mediaControlsScaleWithPageZoom()) {
<span class="line-modified">!         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);</span>
          m_mediaControlsDependOnPageScaleFactor = false;
          return;
      }
  
      if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7422,20 ***</span>
      // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
      // stopped/suspended the object.
      if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
          return;
  
      setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          auto controllerValue = controllerJSValue(exec, globalObject, *this);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;handlePresentationModeChange&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
          auto* function = functionValue.toObject(&amp;exec);
          scope.assertNoException();
<span class="line-new-header">--- 7437,23 ---</span>
      // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
      // stopped/suspended the object.
      if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
          return;
  
<span class="line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
          auto&amp; vm = globalObject.vm();
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          auto controllerValue = controllerJSValue(exec, globalObject, *this);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
          auto* function = functionValue.toObject(&amp;exec);
          scope.assertNoException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7474,11 ***</span>
          auto controllerValue = controllerJSValue(exec, globalObject, *this);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;getCurrentControlsStatus&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
          auto* function = functionValue.toObject(&amp;exec);
          scope.assertNoException();
<span class="line-new-header">--- 7492,11 ---</span>
          auto controllerValue = controllerJSValue(exec, globalObject, *this);
          auto* controllerObject = controllerValue.toObject(&amp;exec);
  
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
          if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
              return false;
  
          auto* function = functionValue.toObject(&amp;exec);
          scope.assertNoException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7621,17 ***</span>
      title = m_currentSrc.host().toString();
  #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
      if (!title.isEmpty())
          title = decodeHostName(title);
  #endif
<span class="line-removed">- #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
      if (!title.isEmpty()) {
<span class="line-modified">!         auto domain = topPrivatelyControlledDomain(title);</span>
          if (!domain.isEmpty())
<span class="line-modified">!             title = domain;</span>
      }
<span class="line-removed">- #endif</span>
  
      return title;
  }
  
  uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
<span class="line-new-header">--- 7639,15 ---</span>
      title = m_currentSrc.host().toString();
  #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
      if (!title.isEmpty())
          title = decodeHostName(title);
  #endif
      if (!title.isEmpty()) {
<span class="line-modified">!         auto domain = RegistrableDomain { m_currentSrc };</span>
          if (!domain.isEmpty())
<span class="line-modified">!             title = domain.string();</span>
      }
  
      return title;
  }
  
  uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7674,31 ***</span>
      default:
          { } // Do nothing
      }
  }
  
<span class="line-removed">- static bool needsSeekingSupportQuirk(Document&amp; document)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto host = document.topDocument().url().host();</span>
<span class="line-removed">-     return equalLettersIgnoringASCIICase(host, &quot;netflix.com&quot;) || host.endsWithIgnoringASCIICase(&quot;.netflix.com&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool HTMLMediaElement::supportsSeeking() const
  {
<span class="line-modified">!     return !needsSeekingSupportQuirk(document()) &amp;&amp; !isLiveStream();</span>
  }
  
  bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
  {
      if (type == PlatformMediaSession::EnteringBackground) {
          if (isPlayingToExternalTarget()) {
              INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
              return true;
          }
          if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
              return true;
  #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
          if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
              return true;
<span class="line-new-header">--- 7690,26 ---</span>
      default:
          { } // Do nothing
      }
  }
  
  bool HTMLMediaElement::supportsSeeking() const
  {
<span class="line-modified">!     return !document().quirks().needsSeekingSupportDisabled() &amp;&amp; !isLiveStream();</span>
  }
  
  bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
  {
      if (type == PlatformMediaSession::EnteringBackground) {
          if (isPlayingToExternalTarget()) {
              INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
              return true;
          }
<span class="line-added">+         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">+             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
          if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
              return true;
  #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
          if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7706,18 ***</span>
<span class="line-new-header">--- 7717,28 ---</span>
      } else if (type == PlatformMediaSession::SuspendedUnderLock) {
          if (isPlayingToExternalTarget()) {
              INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
              return true;
          }
<span class="line-added">+         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">+             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
      }
      return false;
  }
  
  bool HTMLMediaElement::processingUserGestureForMedia() const
  {
      return document().processingUserGestureForMedia();
  }
<span class="line-added">+ </span>
<span class="line-added">+ void HTMLMediaElement::processIsSuspendedChanged()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     updateSleepDisabling();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
  
  void HTMLMediaElement::scheduleUpdateMediaState()
  {
      if (m_updateMediaStateTask.hasPendingTask())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7842,16 ***</span>
          if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
              userDidInterfereWithAutoplay();
      }
  }
  
  bool HTMLMediaElement::effectiveMuted() const
  {
<span class="line-modified">!     return muted() || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
  }
  
<span class="line-modified">! bool HTMLMediaElement::doesHaveAttribute(const AtomicString&amp; attribute, AtomicString* value) const</span>
  {
      QualifiedName attributeName(nullAtom(), attribute, nullAtom());
  
      auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
      if (elementValue.isNull())
<span class="line-new-header">--- 7863,30 ---</span>
          if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
              userDidInterfereWithAutoplay();
      }
  }
  
<span class="line-added">+ double HTMLMediaElement::effectiveVolume() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* page = document().page();</span>
<span class="line-added">+     double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-added">+     if (m_mediaController)</span>
<span class="line-added">+         volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-added">+ #if ENABLE(MEDIA_SESSION)</span>
<span class="line-added">+     if (m_shouldDuck)</span>
<span class="line-added">+         volumeMultiplier *= 0.25;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return m_volume * volumeMultiplier;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool HTMLMediaElement::effectiveMuted() const
  {
<span class="line-modified">!     return muted() || (m_mediaController &amp;&amp; m_mediaController-&gt;muted()) || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
  }
  
<span class="line-modified">! bool HTMLMediaElement::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const</span>
  {
      QualifiedName attributeName(nullAtom(), attribute, nullAtom());
  
      auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
      if (elementValue.isNull())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7864,38 ***</span>
          *value = elementValue;
  
      return true;
  }
  
<span class="line-modified">! void HTMLMediaElement::setShouldBufferData(bool shouldBuffer)</span>
  {
<span class="line-modified">!     if (shouldBuffer == m_shouldBufferData)</span>
          return;
  
<span class="line-modified">!     m_shouldBufferData = shouldBuffer;</span>
      if (m_player)
<span class="line-modified">!         m_player-&gt;setShouldBufferData(shouldBuffer);</span>
  }
  
  void HTMLMediaElement::purgeBufferedDataIfPossible()
  {
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">!     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;dataBufferingPermitted())</span>
          return;
  
      if (isPlayingToExternalTarget()) {
          INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
          return;
      }
  
<span class="line-modified">!     // This is called to relieve memory pressure. Turning off buffering causes the media playback</span>
<span class="line-removed">-     // daemon to release memory associated with queued-up video frames.</span>
<span class="line-removed">-     // We turn it back on right away, but new frames won&#39;t get loaded unless playback is resumed.</span>
<span class="line-removed">-     INFO_LOG(LOGIDENTIFIER, &quot;toggling data buffering&quot;);</span>
<span class="line-removed">-     setShouldBufferData(false);</span>
<span class="line-removed">-     setShouldBufferData(true);</span>
<span class="line-removed">- #endif</span>
  }
  
  bool HTMLMediaElement::canSaveMediaData() const
  {
      if (m_player)
<span class="line-new-header">--- 7899,35 ---</span>
          *value = elementValue;
  
      return true;
  }
  
<span class="line-modified">! void HTMLMediaElement::setBufferingPolicy(BufferingPolicy policy)</span>
  {
<span class="line-modified">!     if (policy == m_bufferingPolicy)</span>
          return;
  
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER, policy);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_bufferingPolicy = policy;</span>
      if (m_player)
<span class="line-modified">!         m_player-&gt;setBufferingPolicy(policy);</span>
  }
  
  void HTMLMediaElement::purgeBufferedDataIfPossible()
  {
<span class="line-modified">!     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)</span>
          return;
  
      if (isPlayingToExternalTarget()) {
          INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
          return;
      }
  
<span class="line-modified">!     setBufferingPolicy(BufferingPolicy::PurgeResources);</span>
  }
  
  bool HTMLMediaElement::canSaveMediaData() const
  {
      if (m_player)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8113,8 ***</span>
<span class="line-new-header">--- 8145,22 ---</span>
  
      m_inActiveDocument = inActiveDocument;
      m_mediaSession-&gt;inActiveDocumentChanged();
  }
  
<span class="line-added">+ HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_bufferingPolicy;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool HTMLMediaElement::hasMediaStreamSource() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">+     return hasMediaStreamSrcObject();</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  }
  
  #endif
</pre>
<center><a href="HTMLMarqueeElement.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>