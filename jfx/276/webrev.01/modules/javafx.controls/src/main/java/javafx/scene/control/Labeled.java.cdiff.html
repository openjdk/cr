<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../javafx.base/src/main/java/javafx/collections/ObservableSet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
   * questions.
   */
  
  package javafx.scene.control;
  
<span class="line-removed">- </span>
  import com.sun.javafx.css.StyleManager;
  import com.sun.javafx.scene.NodeHelper;
  import javafx.css.converter.BooleanConverter;
  import javafx.css.converter.EnumConverter;
  import javafx.css.converter.InsetsConverter;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  import javafx.css.StyleableDoubleProperty;
  import javafx.css.StyleableObjectProperty;
  import javafx.css.StyleableProperty;
  import javafx.css.StyleableStringProperty;
  
<span class="line-removed">- </span>
  /**
   * A Labeled {@link Control} is one which has as part of its user interface
   * a textual content associated with it. For example, a {@link Button} displays
   * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
   * other controls.
<span class="line-new-header">--- 65,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
<span class="line-new-header">--- 131,13 ---</span>
       * Properties                                                              *
       *                                                                         *
       **************************************************************************/
      /**
       * The text to display in the label. The text may be null.
<span class="line-added">+      *</span>
       * @return the text to display in the label
<span class="line-added">+      * @defaultValue {@code &quot;&quot;} (empty string}</span>
       */
      public final StringProperty textProperty() {
          if (text == null) {
              text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,11 ***</span>
<span class="line-new-header">--- 148,13 ---</span>
      public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
  
      /**
       * Specifies how the text and graphic within the Labeled should be
       * aligned when there is empty space within the Labeled.
<span class="line-added">+      *</span>
       * @return the alignment within this labeled
<span class="line-added">+      * @defaultValue {@code Pos.CENTER_LEFT}</span>
       */
      public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
          if (alignment == null) {
              alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,11 ***</span>
<span class="line-new-header">--- 182,13 ---</span>
  
      /**
       * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
       * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
       * only affects multiple lines of text relative to the text bounds.
<span class="line-added">+      *</span>
       * @return the alignment of lines of text within this labeled
<span class="line-added">+      * @defaultValue {@code TextAlignment.LEFT}</span>
       */
      public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
          if (textAlignment == null) {
              textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,11 ***</span>
<span class="line-new-header">--- 215,13 ---</span>
      public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
  
      /**
       * Specifies the behavior to use if the text of the {@code Labeled}
       * exceeds the available space for rendering the text.
<span class="line-added">+      *</span>
       * @return the overrun behavior if the text exceeds the available space
<span class="line-added">+      * @defaultValue {@code OverrunStyle.ELLIPSIS}</span>
       */
      public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
          if (textOverrun == null) {
              textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,10 ***</span>
<span class="line-new-header">--- 264,11 ---</span>
       *
       * @return the ellipsis property on the string to display for the ellipsis
       * when text is truncated
       * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
       * @since JavaFX 2.2
<span class="line-added">+      * @defaultValue {@code &quot;...&quot;}</span>
       */
      public final StringProperty ellipsisStringProperty() {
          if (ellipsisString == null) {
              ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
                  @Override public Object getBean() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,11 ***</span>
<span class="line-new-header">--- 292,13 ---</span>
  
  
      /**
       * If a run of text exceeds the width of the Labeled, then this variable
       * indicates whether the text should wrap onto another line.
<span class="line-added">+      *</span>
       * @return the wrap property if a run of text exceeds the width of the Labeled
<span class="line-added">+      * @defaultValue {@code false}</span>
       */
      public final BooleanProperty wrapTextProperty() {
          if (wrapText == null) {
              wrapText = new StyleableBooleanProperty() {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,11 ***</span>
<span class="line-new-header">--- 335,13 ---</span>
      /**
       * The default font to use for text in the Labeled. If the Label&#39;s text is
       * rich text then this font may or may not be used depending on the font
       * information embedded in the rich text, but in any case where a default
       * font is required, this font will be used.
<span class="line-added">+      *</span>
       * @return the default font to use for text in this labeled
<span class="line-added">+      * @defaultValue {@link Font#getDefault()}</span>
       */
      public final ObjectProperty&lt;Font&gt; fontProperty() {
  
          if (font == null) {
              font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,12 ***</span>
      /**
       * An optional icon for the Labeled. This can be positioned relative to the
       * text by using {@link #setContentDisplay}.  The node specified for this
       * variable cannot appear elsewhere in the scene graph, otherwise
       * the {@code IllegalArgumentException} is thrown.  See the class
<span class="line-modified">!      * description of {@link javafx.scene.Node Node} for more detail.</span>
       * @return the optional icon for this labeled
       */
      public final ObjectProperty&lt;Node&gt; graphicProperty() {
          if (graphic == null) {
              graphic = new StyleableObjectProperty&lt;Node&gt;() {
  
<span class="line-new-header">--- 412,14 ---</span>
      /**
       * An optional icon for the Labeled. This can be positioned relative to the
       * text by using {@link #setContentDisplay}.  The node specified for this
       * variable cannot appear elsewhere in the scene graph, otherwise
       * the {@code IllegalArgumentException} is thrown.  See the class
<span class="line-modified">!      * description of {@link Node} for more detail.</span>
<span class="line-added">+      *</span>
       * @return the optional icon for this labeled
<span class="line-added">+      * @defaultValue {@code null}</span>
       */
      public final ObjectProperty&lt;Node&gt; graphicProperty() {
          if (graphic == null) {
              graphic = new StyleableObjectProperty&lt;Node&gt;() {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,11 ***</span>
<span class="line-new-header">--- 573,13 ---</span>
          return imageUrl;
      }
  
      /**
       * Whether all text should be underlined.
<span class="line-added">+      *</span>
       * @return the underline property of all text in this labeled
<span class="line-added">+      * @defaultValue {@code false}</span>
       */
      public final BooleanProperty underlineProperty() {
          if (underline == null) {
              underline = new StyleableBooleanProperty(false) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,12 ***</span>
<span class="line-new-header">--- 605,14 ---</span>
      public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
      public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
  
      /**
       * Specifies the space in pixel between lines.
<span class="line-added">+      *</span>
       * @return the line spacing property between lines in this labeled
       * @since JavaFX 8.0
<span class="line-added">+      * @defaultValue 0</span>
       */
      public final DoubleProperty lineSpacingProperty() {
          if (lineSpacing == null) {
              lineSpacing = new StyleableDoubleProperty(0) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,11 ***</span>
<span class="line-new-header">--- 638,13 ---</span>
      public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
      public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
  
      /**
       * Specifies the positioning of the graphic relative to the text.
<span class="line-added">+      *</span>
       * @return content display property of this labeled
<span class="line-added">+      * @defaultValue {@code ContentDisplay.LEFT}</span>
       */
      public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
          if (contentDisplay == null) {
              contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 655,11 ***</span>
       * The padding around the Labeled&#39;s text and graphic content.
       * By default labelPadding is Insets.EMPTY and cannot be set to null.
       * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
       *
       * This property can only be set from CSS.
<span class="line-modified">!      * @return  the label padding property of this labeled</span>
       */
      public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
          return labelPaddingPropertyImpl();
      }
      private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
<span class="line-new-header">--- 674,13 ---</span>
       * The padding around the Labeled&#39;s text and graphic content.
       * By default labelPadding is Insets.EMPTY and cannot be set to null.
       * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
       *
       * This property can only be set from CSS.
<span class="line-modified">!      *</span>
<span class="line-added">+      * @return the label padding property of this labeled</span>
<span class="line-added">+      * @defaultValue {@code Insets.EMPTY}</span>
       */
      public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
          return labelPaddingPropertyImpl();
      }
      private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 700,11 ***</span>
<span class="line-new-header">--- 721,13 ---</span>
      private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
      public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
  
      /**
       * The amount of space between the graphic and text
<span class="line-added">+      *</span>
       * @return the graphics text gap property of this labeled
<span class="line-added">+      * @defaultValue 4</span>
       */
      public final DoubleProperty graphicTextGapProperty() {
          if (graphicTextGap == null) {
              graphicTextGap = new StyleableDoubleProperty(4) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,10 ***</span>
<span class="line-new-header">--- 754,12 ---</span>
      public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
  
  
      /**
       * The {@link Paint} used to fill the text.
<span class="line-added">+      *</span>
<span class="line-added">+      * @defaultValue {@code Color.BLACK}</span>
       */
      private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
  
      public final void setTextFill(Paint value) {
          textFillProperty().set(value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,14 ***</span>
       * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
       * When a mnemonic is detected the key combination will
       * be determined based on the succeeding character, and the mnemonic
       * added.
       *
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-removed">-      * The default value for Labeled is false, but it</span>
<span class="line-removed">-      * is enabled by default on some Controls.</span>
<span class="line-removed">-      * &lt;/p&gt;</span>
       */
      private BooleanProperty mnemonicParsing;
      public final void setMnemonicParsing(boolean value) {
          mnemonicParsingProperty().set(value);
      }
<span class="line-new-header">--- 799,11 ---</span>
       * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
       * When a mnemonic is detected the key combination will
       * be determined based on the succeeding character, and the mnemonic
       * added.
       *
<span class="line-modified">!      * @defaultValue {@code false}; {@code true} for some Controls.</span>
       */
      private BooleanProperty mnemonicParsing;
      public final void setMnemonicParsing(boolean value) {
          mnemonicParsingProperty().set(value);
      }
</pre>
<center><a href="../../../../../../../javafx.base/src/main/java/javafx/collections/ObservableSet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>