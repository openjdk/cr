<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.css.StyleManager;
  29 import com.sun.javafx.scene.NodeHelper;
  30 import javafx.css.converter.BooleanConverter;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.InsetsConverter;
  33 import javafx.css.converter.PaintConverter;
  34 import javafx.css.converter.SizeConverter;
  35 import javafx.css.converter.StringConverter;
  36 
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.List;
  40 
  41 import javafx.beans.property.BooleanProperty;
  42 import javafx.beans.property.DoubleProperty;
  43 import javafx.beans.property.ObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectProperty;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.WritableValue;
  49 import javafx.geometry.Insets;
  50 import javafx.geometry.Orientation;
  51 import javafx.geometry.Pos;
  52 import javafx.scene.Node;
  53 import javafx.scene.image.Image;
  54 import javafx.scene.image.ImageView;
  55 import javafx.scene.paint.Color;
  56 import javafx.scene.paint.Paint;
  57 import javafx.scene.text.Font;
  58 import javafx.scene.text.TextAlignment;
  59 import javafx.beans.DefaultProperty;
  60 import javafx.css.CssMetaData;
  61 import javafx.css.FontCssMetaData;
  62 import javafx.css.StyleOrigin;
  63 import javafx.css.Styleable;
  64 import javafx.css.StyleableBooleanProperty;
  65 import javafx.css.StyleableDoubleProperty;
  66 import javafx.css.StyleableObjectProperty;
  67 import javafx.css.StyleableProperty;
  68 import javafx.css.StyleableStringProperty;
  69 
  70 /**
  71  * A Labeled {@link Control} is one which has as part of its user interface
  72  * a textual content associated with it. For example, a {@link Button} displays
  73  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  74  * other controls.
  75  * &lt;p&gt;
  76  * Labeled is also a convenient base class from which to extend when building
  77  * new Controls which, as part of their UI, display read-only textual content.
  78  * &lt;/p&gt;
  79  *
  80  * &lt;p&gt;Example of how to place a graphic above the text:
  81  * &lt;pre&gt;&lt;code&gt;
  82  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  83  *  ImageView imageView = new ImageView();
  84  *  imageView.setImage(image);
  85  *  Label label = new Label(&quot;text&quot;, imageView);
  86  *  label.setContentDisplay(ContentDisplay.TOP);
  87  * &lt;/code&gt;&lt;/pre&gt;
  88  *
  89  * @see Button
  90  * @see Label
  91  * @see ToggleButton
  92  * @since JavaFX 2.0
  93  */
  94 @DefaultProperty(&quot;text&quot;)
  95 public abstract class Labeled extends Control {
  96 
  97     private final static String DEFAULT_ELLIPSIS_STRING = &quot;...&quot;;
  98 
  99 
 100     /***************************************************************************
 101      *                                                                         *
 102      * Constructors                                                            *
 103      *                                                                         *
 104      **************************************************************************/
 105 
 106     /**
 107      * Creates a Label with no text and graphic
 108      */
 109     public Labeled() { }
 110 
 111     /**
 112      * Creates a Label with text
 113      * @param text The text for the label.
 114      */
 115     public Labeled(String text) {
 116         setText(text);
 117     }
 118 
 119     /**
 120      * Creates a Label with text and a graphic
 121      * @param text The text for the label.
 122      * @param graphic The graphic for the label.
 123      */
 124     public Labeled(String text, Node graphic) {
 125         setText(text);
 126         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 127     }
 128 
 129     /***************************************************************************
 130      *                                                                         *
 131      * Properties                                                              *
 132      *                                                                         *
 133      **************************************************************************/
 134     /**
 135      * The text to display in the label. The text may be null.
 136      *
 137      * @return the text to display in the label
 138      * @defaultValue {@code &quot;&quot;} (empty string}
 139      */
 140     public final StringProperty textProperty() {
 141         if (text == null) {
 142             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 143         }
 144         return text;
 145     }
 146     private StringProperty text;
 147     public final void setText(String value) { textProperty().setValue(value); }
 148     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 149 
 150     /**
 151      * Specifies how the text and graphic within the Labeled should be
 152      * aligned when there is empty space within the Labeled.
 153      *
 154      * @return the alignment within this labeled
 155      * @defaultValue {@code Pos.CENTER_LEFT}
 156      */
 157     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 158         if (alignment == null) {
 159             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 160 
 161                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 162                     return StyleableProperties.ALIGNMENT;
 163                 }
 164 
 165                 @Override
 166                 public Object getBean() {
 167                     return Labeled.this;
 168                 }
 169 
 170                 @Override
 171                 public String getName() {
 172                     return &quot;alignment&quot;;
 173                 }
 174             };
 175         }
 176         return alignment;
 177     }
 178     private ObjectProperty&lt;Pos&gt; alignment;
 179     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 180     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 181 
 182 
 183     /**
 184      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 185      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 186      * only affects multiple lines of text relative to the text bounds.
 187      *
 188      * @return the alignment of lines of text within this labeled
 189      * @defaultValue {@code TextAlignment.LEFT}
 190      */
 191     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 192         if (textAlignment == null) {
 193             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 194 
 195                 @Override
 196                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 197                     return StyleableProperties.TEXT_ALIGNMENT;
 198                 }
 199 
 200                 @Override
 201                 public Object getBean() {
 202                     return Labeled.this;
 203                 }
 204 
 205                 @Override
 206                 public String getName() {
 207                     return &quot;textAlignment&quot;;
 208                 }
 209             };
 210         }
 211         return textAlignment;
 212     }
 213     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 214     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 215     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 216 
 217     /**
 218      * Specifies the behavior to use if the text of the {@code Labeled}
 219      * exceeds the available space for rendering the text.
 220      *
 221      * @return the overrun behavior if the text exceeds the available space
 222      * @defaultValue {@code OverrunStyle.ELLIPSIS}
 223      */
 224     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 225         if (textOverrun == null) {
 226             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 227 
 228                 @Override
 229                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 230                     return StyleableProperties.TEXT_OVERRUN;
 231                 }
 232 
 233                 @Override
 234                 public Object getBean() {
 235                     return Labeled.this;
 236                 }
 237 
 238                 @Override
 239                 public String getName() {
 240                     return &quot;textOverrun&quot;;
 241                 }
 242             };
 243         }
 244         return textOverrun;
 245     }
 246     private ObjectProperty&lt;OverrunStyle&gt; textOverrun;
 247     public final void setTextOverrun(OverrunStyle value) { textOverrunProperty().setValue(value); }
 248     public final OverrunStyle getTextOverrun() { return textOverrun == null ? OverrunStyle.ELLIPSIS : textOverrun.getValue(); }
 249 
 250     /**
 251      * Specifies the string to display for the ellipsis when text is truncated.
 252      *
 253      * &lt;table&gt;
 254      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 255      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 256      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 257      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 258      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 259      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 260      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 261      * &lt;/table&gt;
 262      *
 263      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 264      *
 265      * @return the ellipsis property on the string to display for the ellipsis
 266      * when text is truncated
 267      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
 268      * @since JavaFX 2.2
 269      * @defaultValue {@code &quot;...&quot;}
 270      */
 271     public final StringProperty ellipsisStringProperty() {
 272         if (ellipsisString == null) {
 273             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 274                 @Override public Object getBean() {
 275                     return Labeled.this;
 276                 }
 277 
 278                 @Override public String getName() {
 279                     return &quot;ellipsisString&quot;;
 280                 }
 281 
 282                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 283                     return StyleableProperties.ELLIPSIS_STRING;
 284                 }
 285             };
 286         }
 287         return ellipsisString;
 288     }
 289     private StringProperty ellipsisString;
 290     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 291     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 292 
 293 
 294     /**
 295      * If a run of text exceeds the width of the Labeled, then this variable
 296      * indicates whether the text should wrap onto another line.
 297      *
 298      * @return the wrap property if a run of text exceeds the width of the Labeled
 299      * @defaultValue {@code false}
 300      */
 301     public final BooleanProperty wrapTextProperty() {
 302         if (wrapText == null) {
 303             wrapText = new StyleableBooleanProperty() {
 304 
 305                 @Override
 306                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 307                     return StyleableProperties.WRAP_TEXT;
 308                 }
 309 
 310                 @Override
 311                 public Object getBean() {
 312                     return Labeled.this;
 313                 }
 314 
 315                 @Override
 316                 public String getName() {
 317                     return &quot;wrapText&quot;;
 318                 }
 319             };
 320         }
 321         return wrapText;
 322     }
 323     private BooleanProperty wrapText;
 324     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 325     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 326 
 327     /**
 328      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 329      * @return orientation of width/height dependency or null if there is none
 330      */
 331     @Override public Orientation getContentBias() {
 332         return isWrapText()? Orientation.HORIZONTAL : null;
 333     }
 334 
 335     /**
 336      * The default font to use for text in the Labeled. If the Label&#39;s text is
 337      * rich text then this font may or may not be used depending on the font
 338      * information embedded in the rich text, but in any case where a default
 339      * font is required, this font will be used.
 340      *
 341      * @return the default font to use for text in this labeled
 342      * @defaultValue {@link Font#getDefault()}
 343      */
 344     public final ObjectProperty&lt;Font&gt; fontProperty() {
 345 
 346         if (font == null) {
 347             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 348 
 349                 private boolean fontSetByCss = false;
 350 
 351                 @Override
 352                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 353 
 354                     //
 355                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 356                     //
 357                     try {
 358                         // super.applyStyle calls set which might throw if value is bound.
 359                         // Have to make sure fontSetByCss is reset.
 360                         fontSetByCss = true;
 361                         super.applyStyle(newOrigin, value);
 362                     } catch(Exception e) {
 363                         throw e;
 364                     } finally {
 365                         fontSetByCss = false;
 366                     }
 367                 }
 368 
 369                 @Override
 370                 public void set(Font value) {
 371 
 372                     final Font oldValue = get();
 373                     if (value != null ? !value.equals(oldValue) : oldValue != null) {
 374                         super.set(value);
 375                     }
 376 
 377                 }
 378 
 379                 @Override
 380                 protected void invalidated() {
 381                     // RT-20727 - if font is changed by calling setFont, then
 382                     // css might need to be reapplied since font size affects
 383                     // calculated values for styles with relative values
 384                     if(fontSetByCss == false) {
 385                         NodeHelper.reapplyCSS(Labeled.this);
 386                     }
 387                 }
 388 
 389                 @Override
 390                 public CssMetaData&lt;Labeled,Font&gt; getCssMetaData() {
 391                     return StyleableProperties.FONT;
 392                 }
 393 
 394                 @Override
 395                 public Object getBean() {
 396                     return Labeled.this;
 397                 }
 398 
 399                 @Override
 400                 public String getName() {
 401                     return &quot;font&quot;;
 402                 }
 403             };
 404         }
 405         return font;
 406     }
 407     private ObjectProperty&lt;Font&gt; font;
 408     public final void setFont(Font value) { fontProperty().setValue(value); }
 409     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 410 
 411 
 412     /**
 413      * An optional icon for the Labeled. This can be positioned relative to the
 414      * text by using {@link #setContentDisplay}.  The node specified for this
 415      * variable cannot appear elsewhere in the scene graph, otherwise
 416      * the {@code IllegalArgumentException} is thrown.  See the class
 417      * description of {@link Node} for more detail.
 418      *
 419      * @return the optional icon for this labeled
 420      * @defaultValue {@code null}
 421      */
 422     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 423         if (graphic == null) {
 424             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 425 
 426                 // The graphic is styleable by css, but it is the
 427                 // imageUrlProperty that handles the style value.
 428                 @Override
 429                 public CssMetaData getCssMetaData() {
 430                     return StyleableProperties.GRAPHIC;
 431                 }
 432 
 433                 @Override
 434                 public Object getBean() {
 435                     return Labeled.this;
 436                 }
 437 
 438                 @Override
 439                 public String getName() {
 440                     return &quot;graphic&quot;;
 441                 }
 442             };
 443         }
 444         return graphic;
 445     }
 446     private ObjectProperty&lt;Node&gt; graphic;
 447     public final void setGraphic(Node value) {
 448         graphicProperty().setValue(value);
 449     }
 450     public final Node getGraphic() { return graphic == null ? null : graphic.getValue(); }
 451 
 452     private StyleableStringProperty imageUrl = null;
 453     /**
 454      * The imageUrl property is set from CSS and then the graphic property is
 455      * set from the invalidated method. This ensures that the same image isn&#39;t
 456      * reloaded.
 457      */
 458     private StyleableStringProperty imageUrlProperty() {
 459         if (imageUrl == null) {
 460             imageUrl = new StyleableStringProperty() {
 461 
 462                 //
 463                 // If imageUrlProperty is invalidated, this is the origin of the style that
 464                 // triggered the invalidation. This is used in the invaildated() method where the
 465                 // value of super.getStyleOrigin() is not valid until after the call to set(v) returns,
 466                 // by which time invalidated will have been called.
 467                 // This value is initialized to USER in case someone calls set on the imageUrlProperty, which
 468                 // is possible:
 469                 //     CssMetaData metaData = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
 470                 //     StyleableProperty prop = metaData.getStyleableProperty(labeled);
 471                 //     prop.set(someUrl);
 472                 //
 473                 // TODO: Note that prop != labeled, which violates the contract between StyleableProperty and CssMetaData.
 474                 //
 475                 StyleOrigin origin = StyleOrigin.USER;
 476 
 477                 @Override
 478                 public void applyStyle(StyleOrigin origin, String v) {
 479 
 480                     this.origin = origin;
 481 
 482                     // Don&#39;t want applyStyle to throw an exception which would leave this.origin set to the wrong value
 483                     if (graphic == null || graphic.isBound() == false) super.applyStyle(origin, v);
 484 
 485                     // Origin is only valid for this invocation of applyStyle, so reset it to USER in case someone calls set.
 486                     this.origin = StyleOrigin.USER;
 487                 }
 488 
 489                 @Override
 490                 protected void invalidated() {
 491 
 492                     // need to call super.get() here since get() is overridden to return the graphicProperty&#39;s value
 493                     final String url = super.get();
 494 
 495                     if (url == null) {
 496                         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, null);
 497                     } else {
 498                         // RT-34466 - if graphic&#39;s url is the same as this property&#39;s value, then don&#39;t overwrite.
 499                         final Node graphicNode = Labeled.this.getGraphic();
 500                         if (graphicNode instanceof ImageView) {
 501                             final ImageView imageView = (ImageView)graphicNode;
 502                             final Image image = imageView.getImage();
 503                             if (image != null) {
 504                                 final String imageViewUrl = image.getUrl();
 505                                 if (url.equals(imageViewUrl)) return;
 506                             }
 507 
 508                         }
 509 
 510                         final Image img = StyleManager.getInstance().getCachedImage(url);
 511 
 512                         if (img != null) {
 513                             //
 514                             // Note that it is tempting to try to re-use existing ImageView simply by setting
 515                             // the image on the current ImageView, if there is one. This would effectively change
 516                             // the image, but not the ImageView which means that no graphicProperty listeners would
 517                             // be notified. This is probably not what we want.
 518                             //
 519 
 520                             //
 521                             // Have to call applyStyle on graphicProperty so that the graphicProperty&#39;s
 522                             // origin matches the imageUrlProperty&#39;s origin.
 523                             //
 524                             ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, new ImageView(img));
 525                         }
 526                     }
 527                 }
 528 
 529                 @Override
 530                 public String get() {
 531 
 532                     //
 533                     // The value of the imageUrlProperty is that of the graphicProperty.
 534                     // Return the value in a way that doesn&#39;t expand the graphicProperty.
 535                     //
 536                     final Node graphic = getGraphic();
 537                     if (graphic instanceof ImageView) {
 538                         final Image image = ((ImageView)graphic).getImage();
 539                         if (image != null) {
 540                             return image.getUrl();
 541                         }
 542                     }
 543                     return null;
 544                 }
 545 
 546                 @Override
 547                 public StyleOrigin getStyleOrigin() {
 548 
 549                     //
 550                     // The origin of the imageUrlProperty is that of the graphicProperty.
 551                     // Return the origin in a way that doesn&#39;t expand the graphicProperty.
 552                     //
 553                     return graphic != null ? ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphic).getStyleOrigin() : null;
 554                 }
 555 
 556                 @Override
 557                 public Object getBean() {
 558                     return Labeled.this;
 559                 }
 560 
 561                 @Override
 562                 public String getName() {
 563                     return &quot;imageUrl&quot;;
 564                 }
 565 
 566                 @Override
 567                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 568                     return StyleableProperties.GRAPHIC;
 569                 }
 570 
 571             };
 572         }
 573         return imageUrl;
 574     }
 575 
 576     /**
 577      * Whether all text should be underlined.
 578      *
 579      * @return the underline property of all text in this labeled
 580      * @defaultValue {@code false}
 581      */
 582     public final BooleanProperty underlineProperty() {
 583         if (underline == null) {
 584             underline = new StyleableBooleanProperty(false) {
 585 
 586                 @Override
 587                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 588                     return StyleableProperties.UNDERLINE;
 589                 }
 590 
 591                 @Override
 592                 public Object getBean() {
 593                     return Labeled.this;
 594                 }
 595 
 596                 @Override
 597                 public String getName() {
 598                     return &quot;underline&quot;;
 599                 }
 600             };
 601         }
 602         return underline;
 603     }
 604     private BooleanProperty underline;
 605     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 606     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 607 
 608     /**
 609      * Specifies the space in pixel between lines.
 610      *
 611      * @return the line spacing property between lines in this labeled
 612      * @since JavaFX 8.0
 613      * @defaultValue 0
 614      */
 615     public final DoubleProperty lineSpacingProperty() {
 616         if (lineSpacing == null) {
 617             lineSpacing = new StyleableDoubleProperty(0) {
 618 
 619                 @Override
 620                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 621                     return StyleableProperties.LINE_SPACING;
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Labeled.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;lineSpacing&quot;;
 632                 }
 633             };
 634         }
 635         return lineSpacing;
 636     }
 637     private DoubleProperty lineSpacing;
 638     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 639     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 640 
 641     /**
 642      * Specifies the positioning of the graphic relative to the text.
 643      *
 644      * @return content display property of this labeled
 645      * @defaultValue {@code ContentDisplay.LEFT}
 646      */
 647     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 648         if (contentDisplay == null) {
 649             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 650 
 651                 @Override
 652                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 653                     return StyleableProperties.CONTENT_DISPLAY;
 654                 }
 655 
 656                 @Override
 657                 public Object getBean() {
 658                     return Labeled.this;
 659                 }
 660 
 661                 @Override
 662                 public String getName() {
 663                     return &quot;contentDisplay&quot;;
 664                 }
 665             };
 666         }
 667         return contentDisplay;
 668     }
 669     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 670     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 671     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 672 
 673     /**
 674      * The padding around the Labeled&#39;s text and graphic content.
 675      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 676      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 677      *
 678      * This property can only be set from CSS.
 679      *
 680      * @return the label padding property of this labeled
 681      * @defaultValue {@code Insets.EMPTY}
 682      */
 683     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 684         return labelPaddingPropertyImpl();
 685     }
 686     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 687         if (labelPadding == null) {
 688             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 689                 private Insets lastValidValue = Insets.EMPTY;
 690 
 691                 @Override
 692                 public void invalidated() {
 693                     final Insets newValue = get();
 694                     if (newValue == null) {
 695                         set(lastValidValue);
 696                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 697                     }
 698                     lastValidValue = newValue;
 699                     requestLayout();
 700                 }
 701 
 702                 @Override
 703                 public CssMetaData&lt;Labeled,Insets&gt; getCssMetaData() {
 704                     return StyleableProperties.LABEL_PADDING;
 705                 }
 706 
 707                 @Override
 708                 public Object getBean() {
 709                     return Labeled.this;
 710                 }
 711 
 712                 @Override
 713                 public String getName() {
 714                     return &quot;labelPadding&quot;;
 715                 }
 716             };
 717         }
 718         return labelPadding;
 719     }
 720     private ObjectProperty&lt;Insets&gt; labelPadding;
 721     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 722     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 723 
 724     /**
 725      * The amount of space between the graphic and text
 726      *
 727      * @return the graphics text gap property of this labeled
 728      * @defaultValue 4
 729      */
 730     public final DoubleProperty graphicTextGapProperty() {
 731         if (graphicTextGap == null) {
 732             graphicTextGap = new StyleableDoubleProperty(4) {
 733 
 734                 @Override
 735                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 736                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 737                 }
 738 
 739                 @Override
 740                 public Object getBean() {
 741                     return Labeled.this;
 742                 }
 743 
 744                 @Override
 745                 public String getName() {
 746                     return &quot;graphicTextGap&quot;;
 747                 }
 748             };
 749         }
 750         return graphicTextGap;
 751     }
 752     private DoubleProperty graphicTextGap;
 753     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 754     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 755 
 756 
 757     /**
 758      * The {@link Paint} used to fill the text.
 759      *
 760      * @defaultValue {@code Color.BLACK}
 761      */
 762     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 763 
 764     public final void setTextFill(Paint value) {
 765         textFillProperty().set(value);
 766     }
 767 
 768     public final Paint getTextFill() {
 769         return textFill == null ? Color.BLACK : textFill.get();
 770     }
 771 
 772     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 773         if (textFill == null) {
 774             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 775 
 776                 @Override
 777                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 778                     return StyleableProperties.TEXT_FILL;
 779                 }
 780 
 781                 @Override
 782                 public Object getBean() {
 783                     return Labeled.this;
 784                 }
 785 
 786                 @Override
 787                 public String getName() {
 788                     return &quot;textFill&quot;;
 789                 }
 790             };
 791         }
 792         return textFill;
 793     }
 794 
 795 
 796     /**
 797      * MnemonicParsing property to enable/disable text parsing.
 798      * If this is set to true, then the Label text will be
 799      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 800      * When a mnemonic is detected the key combination will
 801      * be determined based on the succeeding character, and the mnemonic
 802      * added.
 803      *
 804      * @defaultValue {@code false}; {@code true} for some Controls.
 805      */
 806     private BooleanProperty mnemonicParsing;
 807     public final void setMnemonicParsing(boolean value) {
 808         mnemonicParsingProperty().set(value);
 809     }
 810     public final boolean isMnemonicParsing() {
 811         return mnemonicParsing == null ? false : mnemonicParsing.get();
 812     }
 813     public final BooleanProperty mnemonicParsingProperty() {
 814         if (mnemonicParsing == null) {
 815             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 816         }
 817         return mnemonicParsing;
 818     }
 819 
 820     //    /**
 821     //     * This is the symbol that is searched for in the text and used as
 822     //     * a mnemonic. You can change what symbol is used. Using the symbol
 823     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 824     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
 825     //     * &quot;e&quot; as the mnemonic. If &quot;H__ello World&quot; is used, then no mnemonic
 826     //     * will be used and the text will be rendered as &quot;H_ello World&quot;.
 827     //     * TODO: Have i18n review this part of the API to confirm proper
 828     //     * externalization will work as expected
 829     //     */
 830 
 831     @Override public String toString() {
 832         StringBuilder builder =
 833             new StringBuilder(super.toString())
 834                 .append(&quot;&#39;&quot;).append(getText()).append(&quot;&#39;&quot;);
 835         return builder.toString();
 836     }
 837 
 838     /***************************************************************************
 839      *                                                                         *
 840      * Stylesheet Handling                                                     *
 841      *                                                                         *
 842      **************************************************************************/
 843 
 844     /**
 845      * Returns the initial alignment state of this control, for use
 846      * by the JavaFX CSS engine to correctly set its initial value. This method
 847      * is overridden to use Pos.CENTER_LEFT initially.
 848      *
 849      * @return the initial alignment state of this control
 850      * @since 9
 851      */
 852     protected Pos getInitialAlignment() {
 853         return Pos.CENTER_LEFT;
 854     }
 855 
 856     private static class StyleableProperties {
 857         private static final FontCssMetaData&lt;Labeled&gt; FONT =
 858             new FontCssMetaData&lt;Labeled&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
 859 
 860             @Override
 861             public boolean isSettable(Labeled n) {
 862                 return n.font == null || !n.font.isBound();
 863             }
 864 
 865             @Override
 866             public StyleableProperty&lt;Font&gt; getStyleableProperty(Labeled n) {
 867                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
 868             }
 869         };
 870 
 871         private static final CssMetaData&lt;Labeled,Pos&gt; ALIGNMENT =
 872                 new CssMetaData&lt;Labeled,Pos&gt;(&quot;-fx-alignment&quot;,
 873                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.CENTER_LEFT ) {
 874 
 875             @Override
 876             public boolean isSettable(Labeled n) {
 877                 return n.alignment == null || !n.alignment.isBound();
 878             }
 879 
 880             @Override
 881             public StyleableProperty&lt;Pos&gt; getStyleableProperty(Labeled n) {
 882                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)n.alignmentProperty();
 883             }
 884 
 885             @Override
 886             public Pos getInitialValue(Labeled n) {
 887                 return n.getInitialAlignment();
 888             }
 889         };
 890 
 891         private static final CssMetaData&lt;Labeled,TextAlignment&gt; TEXT_ALIGNMENT =
 892                 new CssMetaData&lt;Labeled,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
 893                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
 894                 TextAlignment.LEFT) {
 895 
 896             @Override
 897             public boolean isSettable(Labeled n) {
 898                 return n.textAlignment == null || !n.textAlignment.isBound();
 899             }
 900 
 901             @Override
 902             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Labeled n) {
 903                 return (StyleableProperty&lt;TextAlignment&gt;)(WritableValue&lt;TextAlignment&gt;)n.textAlignmentProperty();
 904             }
 905         };
 906 
 907         private static final CssMetaData&lt;Labeled,Paint&gt; TEXT_FILL =
 908                 new CssMetaData&lt;Labeled,Paint&gt;(&quot;-fx-text-fill&quot;,
 909                 PaintConverter.getInstance(), Color.BLACK) {
 910 
 911             @Override
 912             public boolean isSettable(Labeled n) {
 913                 return n.textFill == null || !n.textFill.isBound();
 914             }
 915 
 916             @Override
 917             public StyleableProperty&lt;Paint&gt; getStyleableProperty(Labeled n) {
 918                 return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)n.textFillProperty();
 919             }
 920         };
 921 
 922         private static final CssMetaData&lt;Labeled,OverrunStyle&gt; TEXT_OVERRUN =
 923                 new CssMetaData&lt;Labeled,OverrunStyle&gt;(&quot;-fx-text-overrun&quot;,
 924                 new EnumConverter&lt;OverrunStyle&gt;(OverrunStyle.class),
 925                 OverrunStyle.ELLIPSIS) {
 926 
 927             @Override
 928             public boolean isSettable(Labeled n) {
 929                 return n.textOverrun == null || !n.textOverrun.isBound();
 930             }
 931 
 932             @Override
 933             public StyleableProperty&lt;OverrunStyle&gt; getStyleableProperty(Labeled n) {
 934                 return (StyleableProperty&lt;OverrunStyle&gt;)(WritableValue&lt;OverrunStyle&gt;)n.textOverrunProperty();
 935             }
 936         };
 937 
 938         private static final CssMetaData&lt;Labeled,String&gt; ELLIPSIS_STRING =
 939                 new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-ellipsis-string&quot;,
 940                 StringConverter.getInstance(), DEFAULT_ELLIPSIS_STRING) {
 941 
 942             @Override public boolean isSettable(Labeled n) {
 943                 return n.ellipsisString == null || !n.ellipsisString.isBound();
 944             }
 945 
 946             @Override public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 947                 return (StyleableProperty&lt;String&gt;)(WritableValue&lt;String&gt;)n.ellipsisStringProperty();
 948             }
 949         };
 950 
 951         private static final CssMetaData&lt;Labeled,Boolean&gt; WRAP_TEXT =
 952                 new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-wrap-text&quot;,
 953                 BooleanConverter.getInstance(), false) {
 954 
 955             @Override
 956             public boolean isSettable(Labeled n) {
 957                 return n.wrapText == null || !n.wrapText.isBound();
 958             }
 959 
 960             @Override
 961             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 962                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.wrapTextProperty();
 963             }
 964         };
 965 
 966         private static final CssMetaData&lt;Labeled,String&gt; GRAPHIC =
 967             new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-graphic&quot;,
 968                 StringConverter.getInstance()) {
 969 
 970             @Override
 971             public boolean isSettable(Labeled n) {
 972                 // Note that we care about the graphic, not imageUrl
 973                 return n.graphic == null || !n.graphic.isBound();
 974             }
 975 
 976             @Override
 977             public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 978                 return n.imageUrlProperty();
 979             }
 980         };
 981 
 982         private static final CssMetaData&lt;Labeled,Boolean&gt; UNDERLINE =
 983             new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-underline&quot;,
 984                 BooleanConverter.getInstance(), Boolean.FALSE) {
 985 
 986             @Override
 987             public boolean isSettable(Labeled n) {
 988                 return n.underline == null || !n.underline.isBound();
 989             }
 990 
 991             @Override
 992             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 993                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.underlineProperty();
 994             }
 995         };
 996 
 997         private static final CssMetaData&lt;Labeled,Number&gt; LINE_SPACING =
 998             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-line-spacing&quot;,
 999                 SizeConverter.getInstance(), 0) {
1000 
1001             @Override
1002             public boolean isSettable(Labeled n) {
1003                 return n.lineSpacing == null || !n.lineSpacing.isBound();
1004             }
1005 
1006             @Override
1007             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
1008                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.lineSpacingProperty();
1009             }
1010         };
1011 
1012         private static final CssMetaData&lt;Labeled,ContentDisplay&gt; CONTENT_DISPLAY =
1013             new CssMetaData&lt;Labeled,ContentDisplay&gt;(&quot;-fx-content-display&quot;,
1014                 new EnumConverter&lt;ContentDisplay&gt;(ContentDisplay.class),
1015                 ContentDisplay.LEFT) {
1016 
1017             @Override
1018             public boolean isSettable(Labeled n) {
1019                 return n.contentDisplay == null || !n.contentDisplay.isBound();
1020             }
1021 
1022             @Override
1023             public StyleableProperty&lt;ContentDisplay&gt; getStyleableProperty(Labeled n) {
1024                 return (StyleableProperty&lt;ContentDisplay&gt;)(WritableValue&lt;ContentDisplay&gt;)n.contentDisplayProperty();
1025             }
1026         };
1027 
1028         private static final CssMetaData&lt;Labeled,Insets&gt; LABEL_PADDING =
1029             new CssMetaData&lt;Labeled,Insets&gt;(&quot;-fx-label-padding&quot;,
1030                 InsetsConverter.getInstance(), Insets.EMPTY) {
1031 
1032             @Override
1033             public boolean isSettable(Labeled n) {
1034                 return n.labelPadding == null || !n.labelPadding.isBound();
1035             }
1036 
1037             @Override
1038             public StyleableProperty&lt;Insets&gt; getStyleableProperty(Labeled n) {
1039                 return (StyleableProperty&lt;Insets&gt;)(WritableValue&lt;Insets&gt;)n.labelPaddingPropertyImpl();
1040             }
1041         };
1042 
1043         private static final CssMetaData&lt;Labeled,Number&gt; GRAPHIC_TEXT_GAP =
1044             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-graphic-text-gap&quot;,
1045                 SizeConverter.getInstance(), 4.0) {
1046 
1047             @Override
1048             public boolean isSettable(Labeled n) {
1049                 return n.graphicTextGap == null || !n.graphicTextGap.isBound();
1050             }
1051 
1052             @Override
1053             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
1054                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.graphicTextGapProperty();
1055             }
1056         };
1057 
1058         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1059         static {
1060             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1061                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1062             Collections.addAll(styleables,
1063                 FONT,
1064                 ALIGNMENT,
1065                 TEXT_ALIGNMENT,
1066                 TEXT_FILL,
1067                 TEXT_OVERRUN,
1068                 ELLIPSIS_STRING,
1069                 WRAP_TEXT,
1070                 GRAPHIC,
1071                 UNDERLINE,
1072                 LINE_SPACING,
1073                 CONTENT_DISPLAY,
1074                 LABEL_PADDING,
1075                 GRAPHIC_TEXT_GAP
1076             );
1077             STYLEABLES = Collections.unmodifiableList(styleables);
1078         }
1079     }
1080 
1081     /**
1082      * @return The CssMetaData associated with this class, which may include the
1083      * CssMetaData of its superclasses.
1084      * @since JavaFX 8.0
1085      */
1086     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1087         return StyleableProperties.STYLEABLES;
1088     }
1089 
1090     /**
1091      * {@inheritDoc}
1092      * @since JavaFX 8.0
1093      */
1094     @Override
1095     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1096         return getClassCssMetaData();
1097     }
1098  }
    </pre>
  </body>
</html>