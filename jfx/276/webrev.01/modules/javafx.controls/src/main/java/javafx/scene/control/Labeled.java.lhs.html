<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
<a name="1" id="anc1"></a><span class="line-removed">  28 </span>
  29 import com.sun.javafx.css.StyleManager;
  30 import com.sun.javafx.scene.NodeHelper;
  31 import javafx.css.converter.BooleanConverter;
  32 import javafx.css.converter.EnumConverter;
  33 import javafx.css.converter.InsetsConverter;
  34 import javafx.css.converter.PaintConverter;
  35 import javafx.css.converter.SizeConverter;
  36 import javafx.css.converter.StringConverter;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.List;
  41 
  42 import javafx.beans.property.BooleanProperty;
  43 import javafx.beans.property.DoubleProperty;
  44 import javafx.beans.property.ObjectProperty;
  45 import javafx.beans.property.ReadOnlyObjectProperty;
  46 import javafx.beans.property.SimpleBooleanProperty;
  47 import javafx.beans.property.SimpleStringProperty;
  48 import javafx.beans.property.StringProperty;
  49 import javafx.beans.value.WritableValue;
  50 import javafx.geometry.Insets;
  51 import javafx.geometry.Orientation;
  52 import javafx.geometry.Pos;
  53 import javafx.scene.Node;
  54 import javafx.scene.image.Image;
  55 import javafx.scene.image.ImageView;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.text.Font;
  59 import javafx.scene.text.TextAlignment;
  60 import javafx.beans.DefaultProperty;
  61 import javafx.css.CssMetaData;
  62 import javafx.css.FontCssMetaData;
  63 import javafx.css.StyleOrigin;
  64 import javafx.css.Styleable;
  65 import javafx.css.StyleableBooleanProperty;
  66 import javafx.css.StyleableDoubleProperty;
  67 import javafx.css.StyleableObjectProperty;
  68 import javafx.css.StyleableProperty;
  69 import javafx.css.StyleableStringProperty;
  70 
<a name="2" id="anc2"></a><span class="line-removed">  71 </span>
  72 /**
  73  * A Labeled {@link Control} is one which has as part of its user interface
  74  * a textual content associated with it. For example, a {@link Button} displays
  75  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  76  * other controls.
  77  * &lt;p&gt;
  78  * Labeled is also a convenient base class from which to extend when building
  79  * new Controls which, as part of their UI, display read-only textual content.
  80  * &lt;/p&gt;
  81  *
  82  * &lt;p&gt;Example of how to place a graphic above the text:
  83  * &lt;pre&gt;&lt;code&gt;
  84  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  85  *  ImageView imageView = new ImageView();
  86  *  imageView.setImage(image);
  87  *  Label label = new Label(&quot;text&quot;, imageView);
  88  *  label.setContentDisplay(ContentDisplay.TOP);
  89  * &lt;/code&gt;&lt;/pre&gt;
  90  *
  91  * @see Button
  92  * @see Label
  93  * @see ToggleButton
  94  * @since JavaFX 2.0
  95  */
  96 @DefaultProperty(&quot;text&quot;)
  97 public abstract class Labeled extends Control {
  98 
  99     private final static String DEFAULT_ELLIPSIS_STRING = &quot;...&quot;;
 100 
 101 
 102     /***************************************************************************
 103      *                                                                         *
 104      * Constructors                                                            *
 105      *                                                                         *
 106      **************************************************************************/
 107 
 108     /**
 109      * Creates a Label with no text and graphic
 110      */
 111     public Labeled() { }
 112 
 113     /**
 114      * Creates a Label with text
 115      * @param text The text for the label.
 116      */
 117     public Labeled(String text) {
 118         setText(text);
 119     }
 120 
 121     /**
 122      * Creates a Label with text and a graphic
 123      * @param text The text for the label.
 124      * @param graphic The graphic for the label.
 125      */
 126     public Labeled(String text, Node graphic) {
 127         setText(text);
 128         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 129     }
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Properties                                                              *
 134      *                                                                         *
 135      **************************************************************************/
 136     /**
 137      * The text to display in the label. The text may be null.
<a name="3" id="anc3"></a>
 138      * @return the text to display in the label
<a name="4" id="anc4"></a>
 139      */
 140     public final StringProperty textProperty() {
 141         if (text == null) {
 142             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 143         }
 144         return text;
 145     }
 146     private StringProperty text;
 147     public final void setText(String value) { textProperty().setValue(value); }
 148     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 149 
 150     /**
 151      * Specifies how the text and graphic within the Labeled should be
 152      * aligned when there is empty space within the Labeled.
<a name="5" id="anc5"></a>
 153      * @return the alignment within this labeled
<a name="6" id="anc6"></a>
 154      */
 155     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 156         if (alignment == null) {
 157             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 158 
 159                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 160                     return StyleableProperties.ALIGNMENT;
 161                 }
 162 
 163                 @Override
 164                 public Object getBean() {
 165                     return Labeled.this;
 166                 }
 167 
 168                 @Override
 169                 public String getName() {
 170                     return &quot;alignment&quot;;
 171                 }
 172             };
 173         }
 174         return alignment;
 175     }
 176     private ObjectProperty&lt;Pos&gt; alignment;
 177     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 178     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 179 
 180 
 181     /**
 182      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 183      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 184      * only affects multiple lines of text relative to the text bounds.
<a name="7" id="anc7"></a>
 185      * @return the alignment of lines of text within this labeled
<a name="8" id="anc8"></a>
 186      */
 187     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 188         if (textAlignment == null) {
 189             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 190 
 191                 @Override
 192                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 193                     return StyleableProperties.TEXT_ALIGNMENT;
 194                 }
 195 
 196                 @Override
 197                 public Object getBean() {
 198                     return Labeled.this;
 199                 }
 200 
 201                 @Override
 202                 public String getName() {
 203                     return &quot;textAlignment&quot;;
 204                 }
 205             };
 206         }
 207         return textAlignment;
 208     }
 209     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 210     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 211     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 212 
 213     /**
 214      * Specifies the behavior to use if the text of the {@code Labeled}
 215      * exceeds the available space for rendering the text.
<a name="9" id="anc9"></a>
 216      * @return the overrun behavior if the text exceeds the available space
<a name="10" id="anc10"></a>
 217      */
 218     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 219         if (textOverrun == null) {
 220             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 221 
 222                 @Override
 223                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 224                     return StyleableProperties.TEXT_OVERRUN;
 225                 }
 226 
 227                 @Override
 228                 public Object getBean() {
 229                     return Labeled.this;
 230                 }
 231 
 232                 @Override
 233                 public String getName() {
 234                     return &quot;textOverrun&quot;;
 235                 }
 236             };
 237         }
 238         return textOverrun;
 239     }
 240     private ObjectProperty&lt;OverrunStyle&gt; textOverrun;
 241     public final void setTextOverrun(OverrunStyle value) { textOverrunProperty().setValue(value); }
 242     public final OverrunStyle getTextOverrun() { return textOverrun == null ? OverrunStyle.ELLIPSIS : textOverrun.getValue(); }
 243 
 244     /**
 245      * Specifies the string to display for the ellipsis when text is truncated.
 246      *
 247      * &lt;table&gt;
 248      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 249      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 250      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 251      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 252      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 253      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 254      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 255      * &lt;/table&gt;
 256      *
 257      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 258      *
 259      * @return the ellipsis property on the string to display for the ellipsis
 260      * when text is truncated
 261      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
 262      * @since JavaFX 2.2
<a name="11" id="anc11"></a>
 263      */
 264     public final StringProperty ellipsisStringProperty() {
 265         if (ellipsisString == null) {
 266             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 267                 @Override public Object getBean() {
 268                     return Labeled.this;
 269                 }
 270 
 271                 @Override public String getName() {
 272                     return &quot;ellipsisString&quot;;
 273                 }
 274 
 275                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 276                     return StyleableProperties.ELLIPSIS_STRING;
 277                 }
 278             };
 279         }
 280         return ellipsisString;
 281     }
 282     private StringProperty ellipsisString;
 283     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 284     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 285 
 286 
 287     /**
 288      * If a run of text exceeds the width of the Labeled, then this variable
 289      * indicates whether the text should wrap onto another line.
<a name="12" id="anc12"></a>
 290      * @return the wrap property if a run of text exceeds the width of the Labeled
<a name="13" id="anc13"></a>
 291      */
 292     public final BooleanProperty wrapTextProperty() {
 293         if (wrapText == null) {
 294             wrapText = new StyleableBooleanProperty() {
 295 
 296                 @Override
 297                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 298                     return StyleableProperties.WRAP_TEXT;
 299                 }
 300 
 301                 @Override
 302                 public Object getBean() {
 303                     return Labeled.this;
 304                 }
 305 
 306                 @Override
 307                 public String getName() {
 308                     return &quot;wrapText&quot;;
 309                 }
 310             };
 311         }
 312         return wrapText;
 313     }
 314     private BooleanProperty wrapText;
 315     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 316     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 317 
 318     /**
 319      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 320      * @return orientation of width/height dependency or null if there is none
 321      */
 322     @Override public Orientation getContentBias() {
 323         return isWrapText()? Orientation.HORIZONTAL : null;
 324     }
 325 
 326     /**
 327      * The default font to use for text in the Labeled. If the Label&#39;s text is
 328      * rich text then this font may or may not be used depending on the font
 329      * information embedded in the rich text, but in any case where a default
 330      * font is required, this font will be used.
<a name="14" id="anc14"></a>
 331      * @return the default font to use for text in this labeled
<a name="15" id="anc15"></a>
 332      */
 333     public final ObjectProperty&lt;Font&gt; fontProperty() {
 334 
 335         if (font == null) {
 336             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 337 
 338                 private boolean fontSetByCss = false;
 339 
 340                 @Override
 341                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 342 
 343                     //
 344                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 345                     //
 346                     try {
 347                         // super.applyStyle calls set which might throw if value is bound.
 348                         // Have to make sure fontSetByCss is reset.
 349                         fontSetByCss = true;
 350                         super.applyStyle(newOrigin, value);
 351                     } catch(Exception e) {
 352                         throw e;
 353                     } finally {
 354                         fontSetByCss = false;
 355                     }
 356                 }
 357 
 358                 @Override
 359                 public void set(Font value) {
 360 
 361                     final Font oldValue = get();
 362                     if (value != null ? !value.equals(oldValue) : oldValue != null) {
 363                         super.set(value);
 364                     }
 365 
 366                 }
 367 
 368                 @Override
 369                 protected void invalidated() {
 370                     // RT-20727 - if font is changed by calling setFont, then
 371                     // css might need to be reapplied since font size affects
 372                     // calculated values for styles with relative values
 373                     if(fontSetByCss == false) {
 374                         NodeHelper.reapplyCSS(Labeled.this);
 375                     }
 376                 }
 377 
 378                 @Override
 379                 public CssMetaData&lt;Labeled,Font&gt; getCssMetaData() {
 380                     return StyleableProperties.FONT;
 381                 }
 382 
 383                 @Override
 384                 public Object getBean() {
 385                     return Labeled.this;
 386                 }
 387 
 388                 @Override
 389                 public String getName() {
 390                     return &quot;font&quot;;
 391                 }
 392             };
 393         }
 394         return font;
 395     }
 396     private ObjectProperty&lt;Font&gt; font;
 397     public final void setFont(Font value) { fontProperty().setValue(value); }
 398     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 399 
 400 
 401     /**
 402      * An optional icon for the Labeled. This can be positioned relative to the
 403      * text by using {@link #setContentDisplay}.  The node specified for this
 404      * variable cannot appear elsewhere in the scene graph, otherwise
 405      * the {@code IllegalArgumentException} is thrown.  See the class
<a name="16" id="anc16"></a><span class="line-modified"> 406      * description of {@link javafx.scene.Node Node} for more detail.</span>

 407      * @return the optional icon for this labeled
<a name="17" id="anc17"></a>
 408      */
 409     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 410         if (graphic == null) {
 411             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 412 
 413                 // The graphic is styleable by css, but it is the
 414                 // imageUrlProperty that handles the style value.
 415                 @Override
 416                 public CssMetaData getCssMetaData() {
 417                     return StyleableProperties.GRAPHIC;
 418                 }
 419 
 420                 @Override
 421                 public Object getBean() {
 422                     return Labeled.this;
 423                 }
 424 
 425                 @Override
 426                 public String getName() {
 427                     return &quot;graphic&quot;;
 428                 }
 429             };
 430         }
 431         return graphic;
 432     }
 433     private ObjectProperty&lt;Node&gt; graphic;
 434     public final void setGraphic(Node value) {
 435         graphicProperty().setValue(value);
 436     }
 437     public final Node getGraphic() { return graphic == null ? null : graphic.getValue(); }
 438 
 439     private StyleableStringProperty imageUrl = null;
 440     /**
 441      * The imageUrl property is set from CSS and then the graphic property is
 442      * set from the invalidated method. This ensures that the same image isn&#39;t
 443      * reloaded.
 444      */
 445     private StyleableStringProperty imageUrlProperty() {
 446         if (imageUrl == null) {
 447             imageUrl = new StyleableStringProperty() {
 448 
 449                 //
 450                 // If imageUrlProperty is invalidated, this is the origin of the style that
 451                 // triggered the invalidation. This is used in the invaildated() method where the
 452                 // value of super.getStyleOrigin() is not valid until after the call to set(v) returns,
 453                 // by which time invalidated will have been called.
 454                 // This value is initialized to USER in case someone calls set on the imageUrlProperty, which
 455                 // is possible:
 456                 //     CssMetaData metaData = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
 457                 //     StyleableProperty prop = metaData.getStyleableProperty(labeled);
 458                 //     prop.set(someUrl);
 459                 //
 460                 // TODO: Note that prop != labeled, which violates the contract between StyleableProperty and CssMetaData.
 461                 //
 462                 StyleOrigin origin = StyleOrigin.USER;
 463 
 464                 @Override
 465                 public void applyStyle(StyleOrigin origin, String v) {
 466 
 467                     this.origin = origin;
 468 
 469                     // Don&#39;t want applyStyle to throw an exception which would leave this.origin set to the wrong value
 470                     if (graphic == null || graphic.isBound() == false) super.applyStyle(origin, v);
 471 
 472                     // Origin is only valid for this invocation of applyStyle, so reset it to USER in case someone calls set.
 473                     this.origin = StyleOrigin.USER;
 474                 }
 475 
 476                 @Override
 477                 protected void invalidated() {
 478 
 479                     // need to call super.get() here since get() is overridden to return the graphicProperty&#39;s value
 480                     final String url = super.get();
 481 
 482                     if (url == null) {
 483                         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, null);
 484                     } else {
 485                         // RT-34466 - if graphic&#39;s url is the same as this property&#39;s value, then don&#39;t overwrite.
 486                         final Node graphicNode = Labeled.this.getGraphic();
 487                         if (graphicNode instanceof ImageView) {
 488                             final ImageView imageView = (ImageView)graphicNode;
 489                             final Image image = imageView.getImage();
 490                             if (image != null) {
 491                                 final String imageViewUrl = image.getUrl();
 492                                 if (url.equals(imageViewUrl)) return;
 493                             }
 494 
 495                         }
 496 
 497                         final Image img = StyleManager.getInstance().getCachedImage(url);
 498 
 499                         if (img != null) {
 500                             //
 501                             // Note that it is tempting to try to re-use existing ImageView simply by setting
 502                             // the image on the current ImageView, if there is one. This would effectively change
 503                             // the image, but not the ImageView which means that no graphicProperty listeners would
 504                             // be notified. This is probably not what we want.
 505                             //
 506 
 507                             //
 508                             // Have to call applyStyle on graphicProperty so that the graphicProperty&#39;s
 509                             // origin matches the imageUrlProperty&#39;s origin.
 510                             //
 511                             ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, new ImageView(img));
 512                         }
 513                     }
 514                 }
 515 
 516                 @Override
 517                 public String get() {
 518 
 519                     //
 520                     // The value of the imageUrlProperty is that of the graphicProperty.
 521                     // Return the value in a way that doesn&#39;t expand the graphicProperty.
 522                     //
 523                     final Node graphic = getGraphic();
 524                     if (graphic instanceof ImageView) {
 525                         final Image image = ((ImageView)graphic).getImage();
 526                         if (image != null) {
 527                             return image.getUrl();
 528                         }
 529                     }
 530                     return null;
 531                 }
 532 
 533                 @Override
 534                 public StyleOrigin getStyleOrigin() {
 535 
 536                     //
 537                     // The origin of the imageUrlProperty is that of the graphicProperty.
 538                     // Return the origin in a way that doesn&#39;t expand the graphicProperty.
 539                     //
 540                     return graphic != null ? ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphic).getStyleOrigin() : null;
 541                 }
 542 
 543                 @Override
 544                 public Object getBean() {
 545                     return Labeled.this;
 546                 }
 547 
 548                 @Override
 549                 public String getName() {
 550                     return &quot;imageUrl&quot;;
 551                 }
 552 
 553                 @Override
 554                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 555                     return StyleableProperties.GRAPHIC;
 556                 }
 557 
 558             };
 559         }
 560         return imageUrl;
 561     }
 562 
 563     /**
 564      * Whether all text should be underlined.
<a name="18" id="anc18"></a>
 565      * @return the underline property of all text in this labeled
<a name="19" id="anc19"></a>
 566      */
 567     public final BooleanProperty underlineProperty() {
 568         if (underline == null) {
 569             underline = new StyleableBooleanProperty(false) {
 570 
 571                 @Override
 572                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 573                     return StyleableProperties.UNDERLINE;
 574                 }
 575 
 576                 @Override
 577                 public Object getBean() {
 578                     return Labeled.this;
 579                 }
 580 
 581                 @Override
 582                 public String getName() {
 583                     return &quot;underline&quot;;
 584                 }
 585             };
 586         }
 587         return underline;
 588     }
 589     private BooleanProperty underline;
 590     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 591     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 592 
 593     /**
 594      * Specifies the space in pixel between lines.
<a name="20" id="anc20"></a>
 595      * @return the line spacing property between lines in this labeled
 596      * @since JavaFX 8.0
<a name="21" id="anc21"></a>
 597      */
 598     public final DoubleProperty lineSpacingProperty() {
 599         if (lineSpacing == null) {
 600             lineSpacing = new StyleableDoubleProperty(0) {
 601 
 602                 @Override
 603                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 604                     return StyleableProperties.LINE_SPACING;
 605                 }
 606 
 607                 @Override
 608                 public Object getBean() {
 609                     return Labeled.this;
 610                 }
 611 
 612                 @Override
 613                 public String getName() {
 614                     return &quot;lineSpacing&quot;;
 615                 }
 616             };
 617         }
 618         return lineSpacing;
 619     }
 620     private DoubleProperty lineSpacing;
 621     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 622     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 623 
 624     /**
 625      * Specifies the positioning of the graphic relative to the text.
<a name="22" id="anc22"></a>
 626      * @return content display property of this labeled
<a name="23" id="anc23"></a>
 627      */
 628     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 629         if (contentDisplay == null) {
 630             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 631 
 632                 @Override
 633                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 634                     return StyleableProperties.CONTENT_DISPLAY;
 635                 }
 636 
 637                 @Override
 638                 public Object getBean() {
 639                     return Labeled.this;
 640                 }
 641 
 642                 @Override
 643                 public String getName() {
 644                     return &quot;contentDisplay&quot;;
 645                 }
 646             };
 647         }
 648         return contentDisplay;
 649     }
 650     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 651     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 652     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 653 
 654     /**
 655      * The padding around the Labeled&#39;s text and graphic content.
 656      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 657      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 658      *
 659      * This property can only be set from CSS.
<a name="24" id="anc24"></a><span class="line-modified"> 660      * @return  the label padding property of this labeled</span>


 661      */
 662     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 663         return labelPaddingPropertyImpl();
 664     }
 665     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 666         if (labelPadding == null) {
 667             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 668                 private Insets lastValidValue = Insets.EMPTY;
 669 
 670                 @Override
 671                 public void invalidated() {
 672                     final Insets newValue = get();
 673                     if (newValue == null) {
 674                         set(lastValidValue);
 675                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 676                     }
 677                     lastValidValue = newValue;
 678                     requestLayout();
 679                 }
 680 
 681                 @Override
 682                 public CssMetaData&lt;Labeled,Insets&gt; getCssMetaData() {
 683                     return StyleableProperties.LABEL_PADDING;
 684                 }
 685 
 686                 @Override
 687                 public Object getBean() {
 688                     return Labeled.this;
 689                 }
 690 
 691                 @Override
 692                 public String getName() {
 693                     return &quot;labelPadding&quot;;
 694                 }
 695             };
 696         }
 697         return labelPadding;
 698     }
 699     private ObjectProperty&lt;Insets&gt; labelPadding;
 700     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 701     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 702 
 703     /**
 704      * The amount of space between the graphic and text
<a name="25" id="anc25"></a>
 705      * @return the graphics text gap property of this labeled
<a name="26" id="anc26"></a>
 706      */
 707     public final DoubleProperty graphicTextGapProperty() {
 708         if (graphicTextGap == null) {
 709             graphicTextGap = new StyleableDoubleProperty(4) {
 710 
 711                 @Override
 712                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 713                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 714                 }
 715 
 716                 @Override
 717                 public Object getBean() {
 718                     return Labeled.this;
 719                 }
 720 
 721                 @Override
 722                 public String getName() {
 723                     return &quot;graphicTextGap&quot;;
 724                 }
 725             };
 726         }
 727         return graphicTextGap;
 728     }
 729     private DoubleProperty graphicTextGap;
 730     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 731     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 732 
 733 
 734     /**
 735      * The {@link Paint} used to fill the text.
<a name="27" id="anc27"></a>

 736      */
 737     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 738 
 739     public final void setTextFill(Paint value) {
 740         textFillProperty().set(value);
 741     }
 742 
 743     public final Paint getTextFill() {
 744         return textFill == null ? Color.BLACK : textFill.get();
 745     }
 746 
 747     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 748         if (textFill == null) {
 749             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 750 
 751                 @Override
 752                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 753                     return StyleableProperties.TEXT_FILL;
 754                 }
 755 
 756                 @Override
 757                 public Object getBean() {
 758                     return Labeled.this;
 759                 }
 760 
 761                 @Override
 762                 public String getName() {
 763                     return &quot;textFill&quot;;
 764                 }
 765             };
 766         }
 767         return textFill;
 768     }
 769 
 770 
 771     /**
 772      * MnemonicParsing property to enable/disable text parsing.
 773      * If this is set to true, then the Label text will be
 774      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 775      * When a mnemonic is detected the key combination will
 776      * be determined based on the succeeding character, and the mnemonic
 777      * added.
 778      *
<a name="28" id="anc28"></a><span class="line-modified"> 779      * &lt;p&gt;</span>
<span class="line-removed"> 780      * The default value for Labeled is false, but it</span>
<span class="line-removed"> 781      * is enabled by default on some Controls.</span>
<span class="line-removed"> 782      * &lt;/p&gt;</span>
 783      */
 784     private BooleanProperty mnemonicParsing;
 785     public final void setMnemonicParsing(boolean value) {
 786         mnemonicParsingProperty().set(value);
 787     }
 788     public final boolean isMnemonicParsing() {
 789         return mnemonicParsing == null ? false : mnemonicParsing.get();
 790     }
 791     public final BooleanProperty mnemonicParsingProperty() {
 792         if (mnemonicParsing == null) {
 793             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 794         }
 795         return mnemonicParsing;
 796     }
 797 
 798     //    /**
 799     //     * This is the symbol that is searched for in the text and used as
 800     //     * a mnemonic. You can change what symbol is used. Using the symbol
 801     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 802     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
 803     //     * &quot;e&quot; as the mnemonic. If &quot;H__ello World&quot; is used, then no mnemonic
 804     //     * will be used and the text will be rendered as &quot;H_ello World&quot;.
 805     //     * TODO: Have i18n review this part of the API to confirm proper
 806     //     * externalization will work as expected
 807     //     */
 808 
 809     @Override public String toString() {
 810         StringBuilder builder =
 811             new StringBuilder(super.toString())
 812                 .append(&quot;&#39;&quot;).append(getText()).append(&quot;&#39;&quot;);
 813         return builder.toString();
 814     }
 815 
 816     /***************************************************************************
 817      *                                                                         *
 818      * Stylesheet Handling                                                     *
 819      *                                                                         *
 820      **************************************************************************/
 821 
 822     /**
 823      * Returns the initial alignment state of this control, for use
 824      * by the JavaFX CSS engine to correctly set its initial value. This method
 825      * is overridden to use Pos.CENTER_LEFT initially.
 826      *
 827      * @return the initial alignment state of this control
 828      * @since 9
 829      */
 830     protected Pos getInitialAlignment() {
 831         return Pos.CENTER_LEFT;
 832     }
 833 
 834     private static class StyleableProperties {
 835         private static final FontCssMetaData&lt;Labeled&gt; FONT =
 836             new FontCssMetaData&lt;Labeled&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
 837 
 838             @Override
 839             public boolean isSettable(Labeled n) {
 840                 return n.font == null || !n.font.isBound();
 841             }
 842 
 843             @Override
 844             public StyleableProperty&lt;Font&gt; getStyleableProperty(Labeled n) {
 845                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
 846             }
 847         };
 848 
 849         private static final CssMetaData&lt;Labeled,Pos&gt; ALIGNMENT =
 850                 new CssMetaData&lt;Labeled,Pos&gt;(&quot;-fx-alignment&quot;,
 851                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.CENTER_LEFT ) {
 852 
 853             @Override
 854             public boolean isSettable(Labeled n) {
 855                 return n.alignment == null || !n.alignment.isBound();
 856             }
 857 
 858             @Override
 859             public StyleableProperty&lt;Pos&gt; getStyleableProperty(Labeled n) {
 860                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)n.alignmentProperty();
 861             }
 862 
 863             @Override
 864             public Pos getInitialValue(Labeled n) {
 865                 return n.getInitialAlignment();
 866             }
 867         };
 868 
 869         private static final CssMetaData&lt;Labeled,TextAlignment&gt; TEXT_ALIGNMENT =
 870                 new CssMetaData&lt;Labeled,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
 871                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
 872                 TextAlignment.LEFT) {
 873 
 874             @Override
 875             public boolean isSettable(Labeled n) {
 876                 return n.textAlignment == null || !n.textAlignment.isBound();
 877             }
 878 
 879             @Override
 880             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Labeled n) {
 881                 return (StyleableProperty&lt;TextAlignment&gt;)(WritableValue&lt;TextAlignment&gt;)n.textAlignmentProperty();
 882             }
 883         };
 884 
 885         private static final CssMetaData&lt;Labeled,Paint&gt; TEXT_FILL =
 886                 new CssMetaData&lt;Labeled,Paint&gt;(&quot;-fx-text-fill&quot;,
 887                 PaintConverter.getInstance(), Color.BLACK) {
 888 
 889             @Override
 890             public boolean isSettable(Labeled n) {
 891                 return n.textFill == null || !n.textFill.isBound();
 892             }
 893 
 894             @Override
 895             public StyleableProperty&lt;Paint&gt; getStyleableProperty(Labeled n) {
 896                 return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)n.textFillProperty();
 897             }
 898         };
 899 
 900         private static final CssMetaData&lt;Labeled,OverrunStyle&gt; TEXT_OVERRUN =
 901                 new CssMetaData&lt;Labeled,OverrunStyle&gt;(&quot;-fx-text-overrun&quot;,
 902                 new EnumConverter&lt;OverrunStyle&gt;(OverrunStyle.class),
 903                 OverrunStyle.ELLIPSIS) {
 904 
 905             @Override
 906             public boolean isSettable(Labeled n) {
 907                 return n.textOverrun == null || !n.textOverrun.isBound();
 908             }
 909 
 910             @Override
 911             public StyleableProperty&lt;OverrunStyle&gt; getStyleableProperty(Labeled n) {
 912                 return (StyleableProperty&lt;OverrunStyle&gt;)(WritableValue&lt;OverrunStyle&gt;)n.textOverrunProperty();
 913             }
 914         };
 915 
 916         private static final CssMetaData&lt;Labeled,String&gt; ELLIPSIS_STRING =
 917                 new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-ellipsis-string&quot;,
 918                 StringConverter.getInstance(), DEFAULT_ELLIPSIS_STRING) {
 919 
 920             @Override public boolean isSettable(Labeled n) {
 921                 return n.ellipsisString == null || !n.ellipsisString.isBound();
 922             }
 923 
 924             @Override public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 925                 return (StyleableProperty&lt;String&gt;)(WritableValue&lt;String&gt;)n.ellipsisStringProperty();
 926             }
 927         };
 928 
 929         private static final CssMetaData&lt;Labeled,Boolean&gt; WRAP_TEXT =
 930                 new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-wrap-text&quot;,
 931                 BooleanConverter.getInstance(), false) {
 932 
 933             @Override
 934             public boolean isSettable(Labeled n) {
 935                 return n.wrapText == null || !n.wrapText.isBound();
 936             }
 937 
 938             @Override
 939             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 940                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.wrapTextProperty();
 941             }
 942         };
 943 
 944         private static final CssMetaData&lt;Labeled,String&gt; GRAPHIC =
 945             new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-graphic&quot;,
 946                 StringConverter.getInstance()) {
 947 
 948             @Override
 949             public boolean isSettable(Labeled n) {
 950                 // Note that we care about the graphic, not imageUrl
 951                 return n.graphic == null || !n.graphic.isBound();
 952             }
 953 
 954             @Override
 955             public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 956                 return n.imageUrlProperty();
 957             }
 958         };
 959 
 960         private static final CssMetaData&lt;Labeled,Boolean&gt; UNDERLINE =
 961             new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-underline&quot;,
 962                 BooleanConverter.getInstance(), Boolean.FALSE) {
 963 
 964             @Override
 965             public boolean isSettable(Labeled n) {
 966                 return n.underline == null || !n.underline.isBound();
 967             }
 968 
 969             @Override
 970             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 971                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.underlineProperty();
 972             }
 973         };
 974 
 975         private static final CssMetaData&lt;Labeled,Number&gt; LINE_SPACING =
 976             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-line-spacing&quot;,
 977                 SizeConverter.getInstance(), 0) {
 978 
 979             @Override
 980             public boolean isSettable(Labeled n) {
 981                 return n.lineSpacing == null || !n.lineSpacing.isBound();
 982             }
 983 
 984             @Override
 985             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
 986                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.lineSpacingProperty();
 987             }
 988         };
 989 
 990         private static final CssMetaData&lt;Labeled,ContentDisplay&gt; CONTENT_DISPLAY =
 991             new CssMetaData&lt;Labeled,ContentDisplay&gt;(&quot;-fx-content-display&quot;,
 992                 new EnumConverter&lt;ContentDisplay&gt;(ContentDisplay.class),
 993                 ContentDisplay.LEFT) {
 994 
 995             @Override
 996             public boolean isSettable(Labeled n) {
 997                 return n.contentDisplay == null || !n.contentDisplay.isBound();
 998             }
 999 
1000             @Override
1001             public StyleableProperty&lt;ContentDisplay&gt; getStyleableProperty(Labeled n) {
1002                 return (StyleableProperty&lt;ContentDisplay&gt;)(WritableValue&lt;ContentDisplay&gt;)n.contentDisplayProperty();
1003             }
1004         };
1005 
1006         private static final CssMetaData&lt;Labeled,Insets&gt; LABEL_PADDING =
1007             new CssMetaData&lt;Labeled,Insets&gt;(&quot;-fx-label-padding&quot;,
1008                 InsetsConverter.getInstance(), Insets.EMPTY) {
1009 
1010             @Override
1011             public boolean isSettable(Labeled n) {
1012                 return n.labelPadding == null || !n.labelPadding.isBound();
1013             }
1014 
1015             @Override
1016             public StyleableProperty&lt;Insets&gt; getStyleableProperty(Labeled n) {
1017                 return (StyleableProperty&lt;Insets&gt;)(WritableValue&lt;Insets&gt;)n.labelPaddingPropertyImpl();
1018             }
1019         };
1020 
1021         private static final CssMetaData&lt;Labeled,Number&gt; GRAPHIC_TEXT_GAP =
1022             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-graphic-text-gap&quot;,
1023                 SizeConverter.getInstance(), 4.0) {
1024 
1025             @Override
1026             public boolean isSettable(Labeled n) {
1027                 return n.graphicTextGap == null || !n.graphicTextGap.isBound();
1028             }
1029 
1030             @Override
1031             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
1032                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.graphicTextGapProperty();
1033             }
1034         };
1035 
1036         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1037         static {
1038             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1039                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1040             Collections.addAll(styleables,
1041                 FONT,
1042                 ALIGNMENT,
1043                 TEXT_ALIGNMENT,
1044                 TEXT_FILL,
1045                 TEXT_OVERRUN,
1046                 ELLIPSIS_STRING,
1047                 WRAP_TEXT,
1048                 GRAPHIC,
1049                 UNDERLINE,
1050                 LINE_SPACING,
1051                 CONTENT_DISPLAY,
1052                 LABEL_PADDING,
1053                 GRAPHIC_TEXT_GAP
1054             );
1055             STYLEABLES = Collections.unmodifiableList(styleables);
1056         }
1057     }
1058 
1059     /**
1060      * @return The CssMetaData associated with this class, which may include the
1061      * CssMetaData of its superclasses.
1062      * @since JavaFX 8.0
1063      */
1064     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1065         return StyleableProperties.STYLEABLES;
1066     }
1067 
1068     /**
1069      * {@inheritDoc}
1070      * @since JavaFX 8.0
1071      */
1072     @Override
1073     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1074         return getClassCssMetaData();
1075     }
1076  }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>