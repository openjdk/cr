<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/test/java/test/javafx/scene/control/ListViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.VirtualScrollBar;
  29 import com.sun.javafx.scene.control.behavior.ListCellBehavior;
  30 import com.sun.javafx.tk.Toolkit;
  31 import java.lang.ref.WeakReference;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.List;
  36 import java.util.ListIterator;
  37 import java.util.NoSuchElementException;
  38 import javafx.application.Platform;
  39 import javafx.beans.binding.Bindings;
  40 import javafx.beans.property.ObjectProperty;
  41 import javafx.beans.property.ReadOnlyBooleanWrapper;
  42 import javafx.beans.property.SimpleObjectProperty;
  43 import javafx.collections.FXCollections;
  44 import javafx.collections.ListChangeListener;
  45 import javafx.collections.ObservableList;
  46 import javafx.collections.transformation.SortedList;
  47 import javafx.scene.control.Button;
  48 import javafx.scene.control.FocusModel;
  49 import javafx.scene.control.IndexedCell;
  50 import javafx.scene.control.ListCell;
  51 import javafx.scene.control.ListCellShim;
  52 import javafx.scene.control.ListView;
  53 import javafx.scene.control.ListViewShim;
  54 import javafx.scene.control.MultipleSelectionModel;
  55 import javafx.scene.control.SelectionMode;
  56 import javafx.scene.control.SelectionModel;
  57 import javafx.scene.control.TextField;
  58 import javafx.scene.control.cell.CheckBoxListCell;
  59 import javafx.scene.control.cell.ComboBoxListCell;
  60 import javafx.scene.control.cell.TextFieldListCell;
  61 import javafx.scene.image.ImageView;
  62 import javafx.scene.input.KeyCode;
  63 import javafx.scene.layout.VBox;
  64 import javafx.scene.paint.Color;
  65 import javafx.scene.shape.Rectangle;
  66 import javafx.util.Callback;
  67 import static org.junit.Assert.assertArrayEquals;
  68 import static org.junit.Assert.assertEquals;
  69 import static org.junit.Assert.assertFalse;
  70 import static org.junit.Assert.assertNotNull;
  71 import static org.junit.Assert.assertNull;
  72 import static org.junit.Assert.assertSame;
  73 import static org.junit.Assert.assertTrue;
  74 import static org.junit.Assert.fail;
  75 import org.junit.Before;
  76 import org.junit.Test;
  77 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  78 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  79 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  80 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  81 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  82 import test.com.sun.javafx.scene.control.test.Person;
  83 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  84 
  85 public class ListViewTest {
  86     private ListView&lt;String&gt; listView;
  87     private MultipleSelectionModel&lt;String&gt; sm;
  88     private FocusModel&lt;String&gt; fm;
  89 
  90     @Before public void setup() {
  91         listView = new ListView&lt;&gt;();
  92         sm = listView.getSelectionModel();
  93         fm = listView.getFocusModel();
  94     }
  95 
  96 
  97     /*********************************************************************
  98      * Tests for the constructors                                        *
  99      ********************************************************************/
 100 
 101     @Test public void noArgConstructorSetsTheStyleClass() {
 102         assertStyleClassContains(listView, &quot;list-view&quot;);
 103     }
 104 
 105     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 106         assertNotNull(sm);
 107     }
 108 
 109     @Test public void noArgConstructorSetsNonNullItems() {
 110         assertNotNull(listView.getItems());
 111     }
 112 
 113     @Test public void noArgConstructor_selectedItemIsNull() {
 114         assertNull(sm.getSelectedItem());
 115     }
 116 
 117     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 118         assertEquals(-1, sm.getSelectedIndex());
 119     }
 120 
 121     @Test public void singleArgConstructorSetsTheStyleClass() {
 122         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 123         assertStyleClassContains(b2, &quot;list-view&quot;);
 124     }
 125 
 126     @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 127         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.&lt;String&gt;observableArrayList(&quot;Hi&quot;));
 128         assertNotNull(b2.getSelectionModel());
 129     }
 130 
 131     @Test public void singleArgConstructorAllowsNullItems() {
 132         final ListView&lt;String&gt; b2 = new ListView&lt;String&gt;(null);
 133         assertNull(b2.getItems());
 134     }
 135 
 136     @Test public void singleArgConstructorTakesItems() {
 137         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 138         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(items);
 139         assertSame(items, b2.getItems());
 140     }
 141 
 142     @Test public void singleArgConstructor_selectedItemIsNull() {
 143         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 144         assertNull(b2.getSelectionModel().getSelectedItem());
 145     }
 146 
 147     @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 148         final ListView&lt;String&gt; b2 = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 149         assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 150     }
 151 
 152     /*********************************************************************
 153      * Tests for selection model                                         *
 154      ********************************************************************/
 155 
 156     @Test public void selectionModelCanBeNull() {
 157         listView.setSelectionModel(null);
 158         assertNull(listView.getSelectionModel());
 159     }
 160 
 161     @Test public void selectionModelCanBeBound() {
 162         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 163         ObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt; other = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;String&gt;&gt;(sm);
 164         listView.selectionModelProperty().bind(other);
 165         assertSame(sm, sm);
 166     }
 167 
 168     @Test public void selectionModelCanBeChanged() {
 169         MultipleSelectionModel&lt;String&gt; sm = ListViewShim.&lt;String&gt;getListViewBitSetSelectionModel(listView);
 170         listView.setSelectionModel(sm);
 171         assertSame(sm, sm);
 172     }
 173 
 174     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
 175         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 176         sm.select(randomString);
 177         assertEquals(-1, sm.getSelectedIndex());
 178         assertSame(randomString, sm.getSelectedItem());
 179     }
 180 
 181     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
 182         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 183         final String randomString = new String(&quot;I AM A CRAZY RANDOM STRING&quot;);
 184         sm.select(randomString);
 185         assertEquals(-1, sm.getSelectedIndex());
 186         assertSame(randomString, sm.getSelectedItem());
 187     }
 188 
 189     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
 190         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 191         sm.select(&quot;Orange&quot;);
 192         assertEquals(1, sm.getSelectedIndex());
 193         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 194     }
 195 
 196     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
 197         sm.select(&quot;Orange&quot;);
 198         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 199         assertEquals(1, sm.getSelectedIndex());
 200         assertSame(&quot;Orange&quot;, sm.getSelectedItem());
 201     }
 202 
 203     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
 204         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 205         sm.select(0);
 206         listView.getItems().clear();
 207         assertEquals(-1, sm.getSelectedIndex());
 208         assertEquals(null, sm.getSelectedItem());
 209     }
 210 
 211     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
 212         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 213         sm.select(2);
 214         listView.getItems().clear();
 215         assertEquals(-1, sm.getSelectedIndex());
 216         assertEquals(null, sm.getSelectedItem());
 217     }
 218 
 219     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
 220         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 221         sm.select(2);
 222         listView.getItems().clear();
 223         assertNull(sm.getSelectedItem());
 224         assertEquals(-1, sm.getSelectedIndex());
 225 
 226         listView.getItems().addAll(&quot;Kiwifruit&quot;, &quot;Mandarin&quot;, &quot;Pineapple&quot;);
 227         sm.select(2);
 228         assertEquals(&quot;Pineapple&quot;, sm.getSelectedItem());
 229     }
 230 
 231     @Test public void ensureSelectionShiftsDownWhenOneNewItemIsAdded() {
 232         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 233         sm.select(1);
 234         assertEquals(1, sm.getSelectedIndex());
 235         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 236 
 237         listView.getItems().add(0, &quot;Kiwifruit&quot;);
 238         assertEquals(2, sm.getSelectedIndex());
 239         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 240     }
 241 
 242     @Test public void ensureSelectionShiftsDownWhenMultipleNewItemAreAdded() {
 243         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 244         sm.select(1);
 245         assertEquals(1, sm.getSelectedIndex());
 246         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 247 
 248         listView.getItems().addAll(0, Arrays.asList(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Mandarin&quot;));
 249         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 250         assertEquals(4, sm.getSelectedIndex());
 251     }
 252 
 253     @Test public void ensureSelectionShiftsUpWhenOneItemIsRemoved() {
 254         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 255         sm.select(1);
 256         assertEquals(1, sm.getSelectedIndex());
 257         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 258 
 259         listView.getItems().remove(&quot;Apple&quot;);
 260         assertEquals(0, sm.getSelectedIndex());
 261         assertEquals(&quot;Orange&quot;, sm.getSelectedItem());
 262     }
 263 
 264     @Test public void ensureSelectionShiftsUpWheMultipleItemsAreRemoved() {
 265         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 266         sm.select(2);
 267         assertEquals(2, sm.getSelectedIndex());
 268         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 269 
 270         listView.getItems().removeAll(Arrays.asList(&quot;Apple&quot;, &quot;Orange&quot;));
 271         assertEquals(0, sm.getSelectedIndex());
 272         assertEquals(&quot;Banana&quot;, sm.getSelectedItem());
 273     }
 274 
 275     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
 276         listView.setItems(FXCollections.observableArrayList(&quot;Item 1&quot;));
 277         sm.select(0);
 278         assertEquals(&quot;Item 1&quot;, sm.getSelectedItem());
 279 
 280         listView.setItems(FXCollections.observableArrayList(&quot;Item 2&quot;));
 281         assertEquals(-1, sm.getSelectedIndex());
 282         assertNull(sm.getSelectedItem());
 283         assertEquals(0, fm.getFocusedIndex());
 284         assertEquals(&quot;Item 2&quot;, fm.getFocusedItem());
 285     }
 286 
 287     @Test public void test_rt15793() {
 288         // ListView selectedIndex is 0 although the items list is empty
 289         final ListView lv = new ListView();
 290         final ObservableList list = FXCollections.observableArrayList();
 291         lv.setItems(list);
 292         list.add(&quot;toto&quot;);
 293         lv.getSelectionModel().select(0);
 294         assertEquals(0, lv.getSelectionModel().getSelectedIndex());
 295         list.remove(0);
 296         assertEquals(-1, lv.getSelectionModel().getSelectedIndex());
 297     }
 298 
 299     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 300         final ListView lv = new ListView();
 301         FocusModel fm = lv.getFocusModel();
 302         lv.getItems().add(&quot;row1&quot;);
 303         fm.focus(0);
 304         assertTrue(fm.isFocused(0));
 305 
 306         lv.getItems().add(0, &quot;row0&quot;);
 307         assertTrue(fm.isFocused(1));
 308     }
 309 
 310     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 311         final ListView lv = new ListView();
 312         FocusModel fm = lv.getFocusModel();
 313         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 314         fm.focus(1);
 315         assertTrue(fm.isFocused(1));
 316         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 317 
 318         lv.getItems().add(1, &quot;row0&quot;);
 319         assertTrue(fm.isFocused(2));
 320         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 321         assertFalse(fm.isFocused(1));
 322     }
 323 
 324     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 325         final ListView lv = new ListView();
 326         FocusModel fm = lv.getFocusModel();
 327         lv.getItems().addAll(&quot;row1&quot;);
 328         fm.focus(0);
 329         assertTrue(fm.isFocused(0));
 330         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 331 
 332         lv.getItems().add(1, &quot;row2&quot;);
 333         assertTrue(fm.isFocused(0));
 334         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 335         assertFalse(fm.isFocused(1));
 336     }
 337 
 338     @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 339         final ListView lv = new ListView();
 340         FocusModel fm = lv.getFocusModel();
 341         lv.getItems().add(&quot;row1&quot;);
 342         fm.focus(0);
 343         assertTrue(fm.isFocused(0));
 344 
 345         lv.getItems().remove(&quot;row1&quot;);
 346         assertTrue(fm.getFocusedIndex() == -1);
 347         assertNull(fm.getFocusedItem());
 348     }
 349 
 350     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 351         final ListView lv = new ListView();
 352         FocusModel fm = lv.getFocusModel();
 353         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 354         fm.focus(1);
 355         assertTrue(fm.isFocused(1));
 356         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 357 
 358         lv.getItems().remove(&quot;row1&quot;);
 359         assertTrue(fm.isFocused(0));
 360         assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 361     }
 362 
 363     @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 364         final ListView lv = new ListView();
 365         FocusModel fm = lv.getFocusModel();
 366         lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 367         fm.focus(0);
 368         assertTrue(fm.isFocused(0));
 369         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 370 
 371         lv.getItems().remove(&quot;row2&quot;);
 372         assertTrue(fm.isFocused(0));
 373         assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 374     }
 375 
 376     @Test public void test_rt18385() {
 377         listView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 378         sm.select(1);
 379         listView.getItems().add(&quot;Another Row&quot;);
 380         assertEquals(1, sm.getSelectedIndices().size());
 381         assertEquals(1, sm.getSelectedItems().size());
 382     }
 383 
 384     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsFalse() {
 385         listView.setEditable(false);
 386         listView.edit(1);
 387         assertEquals(-1, listView.getEditingIndex());
 388     }
 389 
 390     @Test public void test_rt18339_onlyEditWhenListViewIsEditable_editableIsTrue() {
 391         listView.setEditable(true);
 392         listView.edit(1);
 393         assertEquals(1, listView.getEditingIndex());
 394     }
 395 
 396     @Test public void test_rt14451() {
 397         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 398         sm.setSelectionMode(SelectionMode.MULTIPLE);
 399         sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
 400         assertEquals(2, sm.getSelectedIndices().size());
 401     }
 402 
 403     private int rt_18969_hitCount = 0;
 404     @Test public void test_rt18969() {
 405         rt_18969_hitCount = 0;
 406         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 407         listView.setItems(emptyModel);
 408         assertTrue(listView.getItems().isEmpty());
 409 
 410         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 411             rt_18969_hitCount++;
 412         });
 413 
 414         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 415         mod.add(System.currentTimeMillis()+&quot;&quot;);
 416         listView.getItems().setAll(mod);
 417 
 418         sm.select(0);
 419         assertTrue(sm.isSelected(0));
 420         assertEquals(1, rt_18969_hitCount);
 421 
 422         // sleep for 100ms so that the currentTimeMillis is guaranteed to be
 423         // a different value than the first one
 424         try {
 425             Thread.sleep(100);
 426         } catch (InterruptedException ex) {
 427             ex.printStackTrace();
 428         }
 429 
 430         // the list is totally changing (it is being cleared), so we should
 431         // be nulling out the selection model state
 432         mod = FXCollections.observableArrayList();
 433         mod.add(System.currentTimeMillis()+&quot;&quot;);
 434         listView.getItems().setAll(mod);
 435 
 436         // it should be two, as there is no null event in between (although there
 437         // used to be, so the test used to be for three hits)
 438         assertEquals(2, rt_18969_hitCount);
 439     }
 440 
 441     @Test public void test_rt21586() {
 442         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 443         listView.getSelectionModel().select(1);
 444         assertEquals(1, listView.getSelectionModel().getSelectedIndex());
 445         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 446 
 447         listView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
 448         assertEquals(-1, listView.getSelectionModel().getSelectedIndex());
 449         assertNull(listView.getSelectionModel().getSelectedItem());
 450     }
 451 
 452     @Test public void test_rt27820_1() {
 453         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 454         listView.getSelectionModel().select(0);
 455         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 456         assertEquals(&quot;Apple&quot;, listView.getSelectionModel().getSelectedItem());
 457 
 458         listView.getItems().clear();
 459         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 460         assertNull(listView.getSelectionModel().getSelectedItem());
 461     }
 462 
 463     @Test public void test_rt27820_2() {
 464         listView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;);
 465         listView.getSelectionModel().select(1);
 466         assertEquals(1, listView.getSelectionModel().getSelectedItems().size());
 467         assertEquals(&quot;Orange&quot;, listView.getSelectionModel().getSelectedItem());
 468 
 469         listView.getItems().clear();
 470         assertEquals(0, listView.getSelectionModel().getSelectedItems().size());
 471         assertNull(listView.getSelectionModel().getSelectedItem());
 472     }
 473 
 474     @Test public void test_rt28534() {
 475         ListView&lt;Person&gt; list = new ListView&lt;Person&gt;();
 476         list.setItems(FXCollections.observableArrayList(
 477                 new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;),
 478                 new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;),
 479                 new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;),
 480                 new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 481                 new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 482 
 483         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 5); // rows 0 - 5 should be filled
 484         VirtualFlowTestUtils.assertRowsEmpty(list, 5, -1); // rows 5+ should be empty
 485 
 486         // now we replace the data and expect the cells that have no data
 487         // to be empty
 488         list.setItems(FXCollections.observableArrayList(
 489                 new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;),
 490                 new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
 491 
 492         VirtualFlowTestUtils.assertRowsNotEmpty(list, 0, 2); // rows 0 - 2 should be filled
 493         VirtualFlowTestUtils.assertRowsEmpty(list, 2, -1); // rows 2+ should be empty
 494     }
 495 
 496     @Test public void test_rt22463() {
 497         final ListView&lt;RT_22463_Person&gt; list = new ListView&lt;RT_22463_Person&gt;();
 498 
 499         // before the change things display fine
 500         RT_22463_Person p1 = new RT_22463_Person();
 501         p1.setId(1l);
 502         p1.setName(&quot;name1&quot;);
 503         RT_22463_Person p2 = new RT_22463_Person();
 504         p2.setId(2l);
 505         p2.setName(&quot;name2&quot;);
 506         list.setItems(FXCollections.observableArrayList(p1, p2));
 507         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;name1&quot;);
 508         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;name2&quot;);
 509 
 510         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
 511         // change - but the items list is cleared so the cells should update
 512         RT_22463_Person new_p1 = new RT_22463_Person();
 513         new_p1.setId(1l);
 514         new_p1.setName(&quot;updated name1&quot;);
 515         RT_22463_Person new_p2 = new RT_22463_Person();
 516         new_p2.setId(2l);
 517         new_p2.setName(&quot;updated name2&quot;);
 518         list.getItems().clear();
 519         list.setItems(FXCollections.observableArrayList(new_p1, new_p2));
 520         VirtualFlowTestUtils.assertCellTextEquals(list, 0, &quot;updated name1&quot;);
 521         VirtualFlowTestUtils.assertCellTextEquals(list, 1, &quot;updated name2&quot;);
 522     }
 523 
 524     @Test public void test_rt28637() {
 525         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;);
 526 
 527         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 528         listView.setItems(items);
 529 
 530         listView.getSelectionModel().select(0);
 531         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItem());
 532         assertEquals(&quot;String1&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 533         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 534 
 535         items.remove(listView.getSelectionModel().getSelectedItem());
 536         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItem());
 537         assertEquals(&quot;String2&quot;, listView.getSelectionModel().getSelectedItems().get(0));
 538         assertEquals(0, listView.getSelectionModel().getSelectedIndex());
 539     }
 540 
 541     @Test public void test_rt28819_1() {
 542         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 543 
 544         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 545         listView.setItems(emptyModel);
 546         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 547 
 548         ObservableList&lt;String&gt; mod = FXCollections.observableArrayList();
 549         String value = System.currentTimeMillis()+&quot;&quot;;
 550         mod.add(value);
 551         listView.setItems(mod);
 552         VirtualFlowTestUtils.assertCellCount(listView, 1);
 553         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value);
 554     }
 555 
 556     @Test public void test_rt28819_2() {
 557         ObservableList&lt;String&gt; emptyModel = FXCollections.observableArrayList();
 558 
 559         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 560         listView.setItems(emptyModel);
 561         VirtualFlowTestUtils.assertRowsEmpty(listView, 0, 5);
 562 
 563         ObservableList&lt;String&gt; mod1 = FXCollections.observableArrayList();
 564         String value1 = System.currentTimeMillis()+&quot;&quot;;
 565         mod1.add(value1);
 566         listView.getItems().setAll(mod1);
 567         VirtualFlowTestUtils.assertCellCount(listView, 1);
 568         VirtualFlowTestUtils.assertCellTextEquals(listView, 0, value1);
 569     }
 570 
 571     @Test public void test_rt29390() {
 572         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(
 573                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 574                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 575                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;,
 576                 &quot;String1&quot;, &quot;String2&quot;, &quot;String3&quot;, &quot;String4&quot;
 577         );
 578 
 579         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 580         listView.setMaxHeight(50);
 581         listView.setPrefHeight(50);
 582 
 583         // we want the vertical scrollbar
 584         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(listView);
 585 
 586         assertNotNull(scrollBar);
 587         assertTrue(scrollBar.isVisible());
 588         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
 589         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
 590 
 591         // this next test is likely to be brittle, but we&#39;ll see...If it is the
 592         // cause of failure then it can be commented out
 593         assertEquals(0.125, scrollBar.getVisibleAmount(), 0.0);
 594     }
 595 
 596     @Test public void test_rt30400() {
 597         // create a listview that&#39;ll render cells using the check box cell factory
 598         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;String1&quot;);
 599         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(items);
 600         listView.setMinHeight(100);
 601         listView.setPrefHeight(100);
 602         listView.setCellFactory(CheckBoxListCell.forListView(param -&gt; new ReadOnlyBooleanWrapper(true)));
 603 
 604         // because only the first row has data, all other rows should be
 605         // empty (and not contain check boxes - we just check the first four here)
 606         VirtualFlowTestUtils.assertRowsNotEmpty(listView, 0, 1);
 607         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(listView, 0));
 608         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 1));
 609         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 2));
 610         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(listView, 3));
 611     }
 612 
 613     @Test public void test_rt29420() {
 614         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 615 
 616         VBox vbox = new VBox(listView);
 617         StageLoader sl = new StageLoader(vbox);
 618 
 619         // the initial width of a ListView should be the golden rectangle where
 620         // the height is hardcoded to be 400
 621         final double initialWidth = listView.prefWidth(-1);
 622         assertEquals(400 * 0.618033987, initialWidth, 0.00);
 623 
 624         // add in some items, and re-measure - seeing as the items are narrow,
 625         // the width shouldn&#39;t change
 626         listView.getItems().addAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);
 627         Toolkit.getToolkit().firePulse();
 628         final double withContentWidth = listView.prefWidth(-1);
 629         assertEquals(initialWidth, withContentWidth, 0.00);
 630 
 631         // remove the items - and the width should remain the same
 632         listView.getItems().clear();
 633         Toolkit.getToolkit().firePulse();
 634         final double afterEmptiedWidth = listView.prefWidth(-1);
 635         assertEquals(initialWidth, afterEmptiedWidth, 0.00);
 636 
 637         sl.dispose();
 638     }
 639 
 640     @Test public void test_rt31165() {
 641         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 642         final ObservableList data = FXCollections.observableArrayList();
 643         for (int i = 0; i &lt; 18; i++) {
 644             data.add(&quot;&quot;+i);
 645         }
 646 
 647         final ListView listView = new ListView(data);
 648         listView.setPrefSize(200, 250);
 649         listView.setEditable(true);
 650         listView.setCellFactory(ComboBoxListCell.forListView(names));
 651 
 652         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 1);
 653         assertEquals(&quot;1&quot;, cell.getText());
 654         assertFalse(cell.isEditing());
 655 
 656         listView.edit(1);
 657 
 658         assertEquals(1, listView.getEditingIndex());
 659         assertTrue(cell.isEditing());
 660 
 661         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 662         Toolkit.getToolkit().firePulse();
 663 
 664         assertEquals(1, listView.getEditingIndex());
 665         assertTrue(cell.isEditing());
 666     }
 667 
 668     @Test public void test_rt31471() {
 669         final ObservableList names = FXCollections.observableArrayList(&quot;Adam&quot;, &quot;Alex&quot;, &quot;Alfred&quot;, &quot;Albert&quot;);
 670         final ListView listView = new ListView(names);
 671 
 672         IndexedCell cell = VirtualFlowTestUtils.getCell(listView, 0);
 673         assertEquals(&quot;Adam&quot;, cell.getItem());
 674 
 675         listView.setFixedCellSize(50);
 676 
 677         VirtualFlowTestUtils.getVirtualFlow(listView).requestLayout();
 678         Toolkit.getToolkit().firePulse();
 679 
 680         assertEquals(&quot;Adam&quot;, cell.getItem());
 681         assertEquals(50, cell.getHeight(), 0.00);
 682     }
 683 
 684     private int rt_31200_count = 0;
 685     @Test public void test_rt_31200() {
 686         final ListView listView = new ListView();
 687         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 688             @Override
 689             public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 690                 return new ListCellShim&lt;String&gt;() {
 691                     ImageView view = new ImageView();
 692                     { setGraphic(view); };
 693 
 694                     @Override
 695                     public void updateItem(String item, boolean empty) {
 696                         if (getItem() == null ? item == null : getItem().equals(item)) {
 697                             rt_31200_count++;
 698                         }
 699                         super.updateItem(item, empty);
 700                         if (item == null || empty) {
 701                             view.setImage(null);
 702                             setText(null);
 703                         } else {
 704                             setText(item);
 705                         }
 706                     }
 707                 };
 708             }
 709         });
 710         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 711 
 712         StageLoader sl = new StageLoader(listView);
 713 
 714         assertEquals(24, rt_31200_count);
 715 
 716         // resize the stage
 717         sl.getStage().setHeight(250);
 718         Toolkit.getToolkit().firePulse();
 719         sl.getStage().setHeight(50);
 720         Toolkit.getToolkit().firePulse();
 721         assertEquals(24, rt_31200_count);
 722 
 723         sl.dispose();
 724     }
 725 
 726     @Test public void test_rt_30484() {
 727         final ListView listView = new ListView();
 728         listView.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 729             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 730                 return new ListCellShim&lt;String&gt;() {
 731                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
 732                     { setGraphic(graphic); };
 733 
 734                     @Override public void updateItem(String item, boolean empty) {
 735                         super.updateItem(item, empty);
 736                         if (item == null || empty) {
 737                             graphic.setVisible(false);
 738                             setText(null);
 739                         } else {
 740                             graphic.setVisible(true);
 741                             setText(item);
 742                         }
 743                     }
 744                 };
 745             }
 746         });
 747 
 748         // First two rows have content, so the graphic should show.
 749         // All other rows have no content, so graphic should not show.
 750         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;);
 751 
 752         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 0);
 753         VirtualFlowTestUtils.assertGraphicIsVisible(listView, 1);
 754         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 2);
 755         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 3);
 756         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 4);
 757         VirtualFlowTestUtils.assertGraphicIsNotVisible(listView, 5);
 758     }
 759 
 760     private int rt_29650_start_count = 0;
 761     private int rt_29650_commit_count = 0;
 762     private int rt_29650_cancel_count = 0;
 763     @Test public void test_rt_29650() {
 764         listView.setOnEditStart(t -&gt; {
 765             rt_29650_start_count++;
 766         });
 767         listView.setOnEditCommit(t -&gt; {
 768             rt_29650_commit_count++;
 769         });
 770         listView.setOnEditCancel(t -&gt; {
 771             rt_29650_cancel_count++;
 772         });
 773 
 774         listView.getItems().setAll(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);
 775         listView.setEditable(true);
 776         listView.setCellFactory(TextFieldListCell.forListView());
 777 
 778         StageLoader sl = new StageLoader(listView);
 779 
 780         listView.edit(0);
 781 
 782         Toolkit.getToolkit().firePulse();
 783 
 784         ListCell rootCell = (ListCell) VirtualFlowTestUtils.getCell(listView, 0);
 785         TextField textField = (TextField) rootCell.getGraphic();
 786         textField.setText(&quot;Testing!&quot;);
 787         KeyEventFirer keyboard = new KeyEventFirer(textField);
 788         keyboard.doKeyPress(KeyCode.ENTER);
 789 
 790         // TODO should the following assert be enabled?
 791 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
 792         assertEquals(1, rt_29650_start_count);
 793         assertEquals(1, rt_29650_commit_count);
 794         assertEquals(0, rt_29650_cancel_count);
 795 
 796         sl.dispose();
 797     }
 798 
 799     @Test public void test_rt35039() {
 800         final List&lt;String&gt; data = new ArrayList&lt;&gt;();
 801         data.add(&quot;aabbaa&quot;);
 802         data.add(&quot;bbc&quot;);
 803 
 804         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
 805         listView.setItems(FXCollections.observableArrayList(data));
 806 
 807         StageLoader sl = new StageLoader(listView);
 808 
 809         // selection starts off on row -1
 810         assertNull(listView.getSelectionModel().getSelectedItem());
 811 
 812         // select &quot;bbc&quot; and ensure everything is set to that
 813         listView.getSelectionModel().select(1);
 814         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 815 
 816         // change the items list - but retain the same content. We expect
 817         // that &quot;bbc&quot; remains selected as it is still in the list
 818         listView.setItems(FXCollections.observableArrayList(data));
 819         assertEquals(&quot;bbc&quot;, listView.getSelectionModel().getSelectedItem());
 820 
 821         sl.dispose();
 822     }
 823 
 824     @Test public void test_rt35857() {
 825         ObservableList&lt;String&gt; fxList = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
 826         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;(fxList);
 827 
 828         listView.getSelectionModel().select(0);
 829 
 830         ObservableList&lt;String&gt; selectedItems = listView.getSelectionModel().getSelectedItems();
 831         assertEquals(1, selectedItems.size());
 832         assertEquals(&quot;A&quot;, selectedItems.get(0));
 833 
 834         listView.getItems().removeAll(selectedItems);
 835         assertEquals(2, fxList.size());
 836         assertEquals(&quot;B&quot;, fxList.get(0));
 837         assertEquals(&quot;C&quot;, fxList.get(1));
 838     }
 839 
 840     private int rt_35889_cancel_count = 0;
 841     @Test public void test_rt35889() {
 842         final ListView&lt;String&gt; textFieldListView = new ListView&lt;String&gt;();
 843         textFieldListView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 844         textFieldListView.setEditable(true);
 845         textFieldListView.setCellFactory(TextFieldListCell.forListView());
 846         textFieldListView.setOnEditCancel(t -&gt; {
 847             rt_35889_cancel_count++;
 848             System.out.println(&quot;On Edit Cancel: &quot; + t);
 849         });
 850 
 851         ListCell cell0 = (ListCell) VirtualFlowTestUtils.getCell(textFieldListView, 0);
 852         assertNull(cell0.getGraphic());
 853         assertEquals(&quot;A&quot;, cell0.getText());
 854 
 855         textFieldListView.edit(0);
 856         TextField textField = (TextField) cell0.getGraphic();
 857         assertNotNull(textField);
 858 
 859         assertEquals(0, rt_35889_cancel_count);
 860 
 861         textField.setText(&quot;Z&quot;);
 862         KeyEventFirer keyboard = new KeyEventFirer(textField);
 863         keyboard.doKeyPress(KeyCode.ENTER);
 864 
 865         assertEquals(0, rt_35889_cancel_count);
 866     }
 867 
 868     @Test public void test_rt25679() {
 869         Button focusBtn = new Button(&quot;Focus here&quot;);
 870 
 871         final ListView&lt;String&gt; listView = new ListView&lt;String&gt;();
 872         SelectionModel sm = listView.getSelectionModel();
 873         listView.setItems(FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
 874 
 875         VBox vbox = new VBox(focusBtn, listView);
 876 
 877         StageLoader sl = new StageLoader(vbox);
 878         sl.getStage().requestFocus();
 879         focusBtn.requestFocus();
 880         Toolkit.getToolkit().firePulse();
 881 
 882         // test initial state
 883         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
 884         assertTrue(focusBtn.isFocused());
 885         assertEquals(-1, sm.getSelectedIndex());
 886         assertNull(sm.getSelectedItem());
 887 
 888         // move focus to the listview
 889         listView.requestFocus();
 890 
 891         // ensure that there is a selection (where previously there was not one)
 892         assertEquals(sl.getStage().getScene().getFocusOwner(), listView);
 893         assertTrue(listView.isFocused());
 894         assertEquals(-1, sm.getSelectedIndex());
 895         assertNull(sm.getSelectedItem());
 896 
 897         sl.dispose();
 898     }
 899 
 900     private int rt_37061_index_counter = 0;
 901     private int rt_37061_item_counter = 0;
 902     @Test public void test_rt_37061() {
 903         ListView&lt;Integer&gt; tv = new ListView&lt;&gt;();
 904         tv.getItems().add(1);
 905         tv.getSelectionModel().select(0);
 906 
 907         // note we add the listeners after the selection is made, so the counters
 908         // at this point are still both at zero.
 909         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
 910             rt_37061_index_counter++;
 911         });
 912 
 913         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
 914             rt_37061_item_counter++;
 915         });
 916 
 917         // add a new item. This does not impact the selected index or selected item
 918         // so the counters should remain at zero.
 919         tv.getItems().add(2);
 920         assertEquals(0, rt_37061_index_counter);
 921         assertEquals(0, rt_37061_item_counter);
 922     }
 923 
 924     private int rt_37538_count = 0;
 925     @Test public void test_rt_37538_noCNextCall() {
 926         test_rt_37538(false, false);
 927     }
 928 
 929     @Test public void test_rt_37538_callCNextOnce() {
 930         test_rt_37538(true, false);
 931     }
 932 
 933     @Test public void test_rt_37538_callCNextInLoop() {
 934         test_rt_37538(false, true);
 935     }
 936 
 937     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
 938         ListView&lt;Integer&gt; list = new ListView&lt;&gt;();
 939         for ( int i = 1; i &lt;= 50; i++ ) {
 940             list.getItems().add(i);
 941         }
 942 
 943         list.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends Integer&gt; c) -&gt; {
 944             if (callCNextOnce) {
 945                 c.next();
 946             } else if (callCNextInLoop) {
 947                 while (c.next()) {
 948                     // no-op
 949                 }
 950             }
 951 
 952             if (rt_37538_count &gt;= 1) {
 953                 Thread.dumpStack();
 954                 fail(&quot;This method should only be called once&quot;);
 955             }
 956 
 957             rt_37538_count++;
 958         });
 959 
 960         StageLoader sl = new StageLoader(list);
 961         assertEquals(0, rt_37538_count);
 962         list.getSelectionModel().select(0);
 963         assertEquals(1, rt_37538_count);
 964         sl.dispose();
 965     }
 966 
 967     @Test
 968     public void test_rt_35395_fixedCellSize() {
 969         test_rt_35395(true);
 970     }
 971 
 972     @Test
 973     public void test_rt_35395_notFixedCellSize() {
 974         test_rt_35395(false);
 975     }
 976 
 977     private int rt_35395_counter;
 978 
 979     private void test_rt_35395(boolean useFixedCellSize) {
 980         rt_35395_counter = 0;
 981 
 982         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
 983         for (int i = 0; i &lt; 20; ++i) {
 984             items.addAll(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;);
 985         }
 986 
 987         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
 988         if (useFixedCellSize) {
 989             listView.setFixedCellSize(24);
 990         }
 991         listView.setCellFactory(lv -&gt; new ListCellShim&lt;String&gt;() {
 992             @Override
 993             public void updateItem(String color, boolean empty) {
 994                 rt_35395_counter += 1;
 995                 super.updateItem(color, empty);
 996                 setText(null);
 997                 if (empty) {
 998                     setGraphic(null);
 999                 } else {
1000                     Rectangle rect = new Rectangle(16, 16);
1001                     rect.setStyle(&quot;-fx-fill: &quot; + color);
1002                     setGraphic(rect);
1003                 }
1004             }
1005         });
1006 
1007         StageLoader sl = new StageLoader(listView);
1008 
1009         Platform.runLater(() -&gt; {
1010             rt_35395_counter = 0;
1011             items.set(10, &quot;yellow&quot;);
1012             Platform.runLater(() -&gt; {
1013                 Toolkit.getToolkit().firePulse();
1014                 assertEquals(1, rt_35395_counter);
1015                 rt_35395_counter = 0;
1016                 items.set(30, &quot;yellow&quot;);
1017                 Platform.runLater(() -&gt; {
1018                     Toolkit.getToolkit().firePulse();
1019                     assertEquals(0, rt_35395_counter);
1020                     rt_35395_counter = 0;
1021                     items.remove(12);
1022                     Platform.runLater(() -&gt; {
1023                         Toolkit.getToolkit().firePulse();
1024                         assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1025                         rt_35395_counter = 0;
1026                         items.add(12, &quot;yellow&quot;);
1027                         Platform.runLater(() -&gt; {
1028                             Toolkit.getToolkit().firePulse();
1029                             assertEquals(useFixedCellSize ? 39 : 45, rt_35395_counter);
1030                             rt_35395_counter = 0;
1031                             listView.scrollTo(5);
1032                             Platform.runLater(() -&gt; {
1033                                 Toolkit.getToolkit().firePulse();
1034                                 assertEquals(5, rt_35395_counter);
1035                                 rt_35395_counter = 0;
1036                                 listView.scrollTo(55);
1037                                 Platform.runLater(() -&gt; {
1038                                     Toolkit.getToolkit().firePulse();
1039                                     assertEquals(useFixedCellSize ? 17 : 53, rt_35395_counter);
1040                                     sl.dispose();
1041                                 });
1042                             });
1043                         });
1044                     });
1045                 });
1046             });
1047         });
1048     }
1049 
1050     @Test public void test_rt_37632() {
1051         final ObservableList&lt;String&gt; listOne = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
1052         final ObservableList&lt;String&gt; listTwo = FXCollections.observableArrayList(&quot;C&quot;);
1053 
1054         final ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1055         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1056         listView.setItems(listOne);
1057         listView.getSelectionModel().selectFirst();
1058 
1059         assertEquals(0, sm.getSelectedIndex());
1060         assertEquals(&quot;A&quot;, sm.getSelectedItem());
1061         assertEquals(1, sm.getSelectedIndices().size());
1062         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1063         assertEquals(1, sm.getSelectedItems().size());
1064         assertEquals(&quot;A&quot;, sm.getSelectedItems().get(0));
1065 
1066         listView.setItems(listTwo);
1067 
1068         assertEquals(-1, sm.getSelectedIndex());
1069         assertNull(sm.getSelectedItem());
1070         assertEquals(0, sm.getSelectedIndices().size());
1071         assertEquals(0, sm.getSelectedItems().size());
1072     }
1073 
1074     private int rt_37853_cancelCount;
1075     private int rt_37853_commitCount;
1076     @Test public void test_rt_37853() {
1077         listView.setCellFactory(TextFieldListCell.forListView());
1078         listView.setEditable(true);
1079 
1080         for (int i = 0; i &lt; 10; i++) {
1081             listView.getItems().add(&quot;&quot; + i);
1082         }
1083 
1084         StageLoader sl = new StageLoader(listView);
1085 
1086         listView.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
1087         listView.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
1088 
1089         assertEquals(0, rt_37853_cancelCount);
1090         assertEquals(0, rt_37853_commitCount);
1091 
1092         listView.edit(1);
1093         assertNotNull(listView.getEditingIndex());
1094 
1095         listView.getItems().clear();
1096         assertEquals(1, rt_37853_cancelCount);
1097         assertEquals(0, rt_37853_commitCount);
1098 
1099         sl.dispose();
1100     }
1101 
1102     @Test public void test_rt_38787_remove_b() {
1103         // selection moves to &quot;a&quot;
1104         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;);
1105     }
1106 
1107     @Test public void test_rt_38787_remove_b_c() {
1108         // selection moves to &quot;a&quot;
1109         test_rt_38787(&quot;a&quot;, 0, &quot;b&quot;, &quot;c&quot;);
1110     }
1111 
1112     @Test public void test_rt_38787_remove_c_d() {
1113         // selection moves to &quot;b&quot;
1114         test_rt_38787(&quot;b&quot;, 1, &quot;c&quot;, &quot;d&quot;);
1115     }
1116 
1117     @Test public void test_rt_38787_remove_a() {
1118         // selection moves to &quot;b&quot;, now in index 0
1119         test_rt_38787(&quot;b&quot;, 0, &quot;a&quot;);
1120     }
1121 
1122     @Test public void test_rt_38787_remove_z() {
1123         // selection shouldn&#39;t move as &#39;z&#39; doesn&#39;t exist
1124         test_rt_38787(&quot;b&quot;, 1, &quot;z&quot;);
1125     }
1126 
1127     private void test_rt_38787(String expectedItem, int expectedIndex, String... itemsToRemove) {
1128         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1129         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1130 
1131         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1132         sm.select(&quot;b&quot;);
1133 
1134         // test pre-conditions
1135         assertEquals(1, sm.getSelectedIndex());
1136         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1137         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1138         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1139         assertFalse(sm.isSelected(0));
1140         assertTrue(sm.isSelected(1));
1141         assertFalse(sm.isSelected(2));
1142 
1143         // removing items
1144         stringListView.getItems().removeAll(itemsToRemove);
1145 
1146         // testing against expectations
1147         assertEquals(expectedIndex, sm.getSelectedIndex());
1148         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
1149         assertEquals(expectedItem, sm.getSelectedItem());
1150         assertEquals(expectedItem, sm.getSelectedItems().get(0));
1151     }
1152 
1153     private int rt_38341_indices_count = 0;
1154     private int rt_38341_items_count = 0;
1155     @Test public void test_rt_38341() {
1156         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1157         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
1158 
1159         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1160         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
1161         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; rt_38341_items_count++);
1162 
1163         assertEquals(0, rt_38341_indices_count);
1164         assertEquals(0, rt_38341_items_count);
1165 
1166         // expand the first child of root, and select it (note: root isn&#39;t visible)
1167         sm.select(1);
1168         assertEquals(1, sm.getSelectedIndex());
1169         assertEquals(1, sm.getSelectedIndices().size());
1170         assertEquals(1, (int)sm.getSelectedIndices().get(0));
1171         assertEquals(1, sm.getSelectedItems().size());
1172         assertEquals(&quot;b&quot;, sm.getSelectedItem());
1173         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(0));
1174 
1175         assertEquals(1, rt_38341_indices_count);
1176         assertEquals(1, rt_38341_items_count);
1177 
1178         // now delete it
1179         stringListView.getItems().remove(1);
1180 
1181         // selection should move to the childs parent in index 0
1182         assertEquals(0, sm.getSelectedIndex());
1183         assertEquals(1, sm.getSelectedIndices().size());
1184         assertEquals(0, (int)sm.getSelectedIndices().get(0));
1185         assertEquals(1, sm.getSelectedItems().size());
1186         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1187         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1188 
1189         // we also expect there to be an event in the selection model for
1190         // selected indices and selected items
1191         assertEquals(sm.getSelectedIndices() +&quot;&quot;, 2, rt_38341_indices_count);
1192         assertEquals(2, rt_38341_items_count);
1193     }
1194 
1195     @Test public void test_rt_39132() {
1196         ObservableList items = FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
1197         ListView listView = new ListView&lt;&gt;();
1198         listView.setItems(items);
1199 
1200         MultipleSelectionModel sm = listView.getSelectionModel();
1201         sm.select(0);
1202 
1203         assertEquals(0, sm.getSelectedIndex());
1204         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1205 
1206         items.add(0, &quot;new item&quot;);
1207         assertEquals(1, sm.getSelectedIndex());
1208         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1209     }
1210 
1211     private int rt_38943_index_count = 0;
1212     private int rt_38943_item_count = 0;
1213     @Test public void test_rt_38943() {
1214         ListView&lt;String&gt; listView = new ListView&lt;&gt;(FXCollections.observableArrayList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));
1215 
1216         MultipleSelectionModel sm = listView.getSelectionModel();
1217 
1218         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
1219         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
1220 
1221         assertEquals(-1, sm.getSelectedIndex());
1222         assertNull(sm.getSelectedItem());
1223         assertEquals(0, rt_38943_index_count);
1224         assertEquals(0, rt_38943_item_count);
1225 
1226         sm.select(0);
1227         assertEquals(0, sm.getSelectedIndex());
1228         assertEquals(&quot;one&quot;, sm.getSelectedItem());
1229         assertEquals(1, rt_38943_index_count);
1230         assertEquals(1, rt_38943_item_count);
1231 
1232         sm.clearSelection(0);
1233         assertEquals(-1, sm.getSelectedIndex());
1234         assertNull(sm.getSelectedItem());
1235         assertEquals(2, rt_38943_index_count);
1236         assertEquals(2, rt_38943_item_count);
1237     }
1238 
1239     @Test public void test_rt_38884() {
1240         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1241         ObservableList&lt;String&gt; items = listView.getItems();
1242 
1243         listView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends String&gt; c) -&gt; {
1244             while (c.next()) {
1245                 if (c.wasRemoved()) {
1246                     assertTrue(c.getRemovedSize() &gt; 0);
1247 
1248                     List&lt;? extends String&gt; removed = c.getRemoved();
1249                     String removedItem = null;
1250                     try {
1251                         removedItem = removed.get(0);
1252                     } catch (Exception e) {
1253                         fail();
1254                     }
1255 
1256                     assertEquals(&quot;foo&quot;, removedItem);
1257                 }
1258             }
1259         });
1260 
1261         items.add(&quot;foo&quot;);
1262         listView.getSelectionModel().select(0);
1263         items.clear();
1264     }
1265 
1266     private int rt_37360_add_count = 0;
1267     private int rt_37360_remove_count = 0;
1268     @Test public void test_rt_37360() {
1269         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1270         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1271 
1272         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1273         sm.setSelectionMode(SelectionMode.MULTIPLE);
1274         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) c -&gt; {
1275             while (c.next()) {
1276                 if (c.wasAdded()) {
1277                     rt_37360_add_count += c.getAddedSize();
1278                 }
1279                 if (c.wasRemoved()) {
1280                     rt_37360_remove_count += c.getRemovedSize();
1281                 }
1282             }
1283         });
1284 
1285         assertEquals(0, sm.getSelectedItems().size());
1286         assertEquals(0, rt_37360_add_count);
1287         assertEquals(0, rt_37360_remove_count);
1288 
1289         sm.select(0);
1290         assertEquals(1, sm.getSelectedItems().size());
1291         assertEquals(1, rt_37360_add_count);
1292         assertEquals(0, rt_37360_remove_count);
1293 
1294         sm.select(1);
1295         assertEquals(2, sm.getSelectedItems().size());
1296         assertEquals(2, rt_37360_add_count);
1297         assertEquals(0, rt_37360_remove_count);
1298 
1299         sm.clearAndSelect(1);
1300         assertEquals(1, sm.getSelectedItems().size());
1301         assertEquals(2, rt_37360_add_count);
1302         assertEquals(1, rt_37360_remove_count);
1303     }
1304 
1305     @Test public void test_rt_38491() {
1306         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1307         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;);
1308 
1309         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1310         sm.setSelectionMode(SelectionMode.MULTIPLE);
1311 
1312         FocusModel&lt;String&gt; fm = stringListView.getFocusModel();
1313 
1314         // click on row 0
1315         VirtualFlowTestUtils.clickOnRow(stringListView, 0);
1316         assertTrue(sm.isSelected(0));
1317         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1318         assertTrue(fm.isFocused(0));
1319         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1320         assertEquals(0, fm.getFocusedIndex());
1321 
1322         int anchor = ListCellBehavior.getAnchor(stringListView, -1);
1323         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1324         assertEquals(0, anchor);
1325 
1326         // now add a new item at row 0. This has the effect of pushing down
1327         // the selected item into row 1.
1328         stringListView.getItems().add(0, &quot;z&quot;);
1329 
1330         // The first bug was that selection and focus were not moving down to
1331         // be on row 1, so we test that now
1332         assertFalse(sm.isSelected(0));
1333         assertFalse(fm.isFocused(0));
1334         assertTrue(sm.isSelected(1));
1335         assertEquals(&quot;a&quot;, sm.getSelectedItem());
1336         assertTrue(fm.isFocused(1));
1337         assertEquals(&quot;a&quot;, fm.getFocusedItem());
1338         assertEquals(1, fm.getFocusedIndex());
1339 
1340         // The second bug was that the anchor was not being pushed down as well
1341         // (when it should).
1342         anchor = ListCellBehavior.getAnchor(stringListView, -1);
1343         assertTrue(ListCellBehavior.hasNonDefaultAnchor(stringListView));
1344         assertEquals(1, anchor);
1345     }
1346 
1347     private final ObservableList&lt;String&gt; rt_39256_list = FXCollections.observableArrayList();
1348     @Test public void test_rt_39256() {
1349         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1350         stringListView.getItems().addAll(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1351 
1352         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1353         sm.setSelectionMode(SelectionMode.MULTIPLE);
1354 
1355 //        rt_39256_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1356 //            while (change.next()) {
1357 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
1358 //            }
1359 //        });
1360 
1361         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
1362 
1363         assertEquals(0, sm.getSelectedItems().size());
1364         assertEquals(0, rt_39256_list.size());
1365 
1366         sm.selectAll();
1367         assertEquals(4, sm.getSelectedItems().size());
1368         assertEquals(4, rt_39256_list.size());
1369 
1370         sm.selectAll();
1371         assertEquals(4, sm.getSelectedItems().size());
1372         assertEquals(4, rt_39256_list.size());
1373 
1374         sm.selectAll();
1375         assertEquals(4, sm.getSelectedItems().size());
1376         assertEquals(4, rt_39256_list.size());
1377     }
1378 
1379     private final ObservableList&lt;String&gt; rt_39482_list = FXCollections.observableArrayList();
1380     @Test public void test_rt_39482() {
1381         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1382         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1383 
1384         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1385         sm.setSelectionMode(SelectionMode.MULTIPLE);
1386 
1387         sm.getSelectedItems().addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1388             while (change.next()) {
1389                 System.out.println(&quot;sm.getSelectedItems(): &quot; + change.getList());
1390             }
1391         });
1392 
1393         rt_39482_list.addListener((ListChangeListener&lt;String&gt;) change -&gt; {
1394             while (change.next()) {
1395                 System.out.println(&quot;rt_39482_list: &quot; + change.getList());
1396             }
1397         });
1398 
1399         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
1400 
1401         assertEquals(0, sm.getSelectedItems().size());
1402         assertEquals(0, rt_39482_list.size());
1403 
1404         test_rt_39482_selectRow(&quot;a&quot;, sm, 0);
1405         test_rt_39482_selectRow(&quot;b&quot;, sm, 1);
1406         test_rt_39482_selectRow(&quot;c&quot;, sm, 2);
1407         test_rt_39482_selectRow(&quot;d&quot;, sm, 3);
1408     }
1409 
1410     private void test_rt_39482_selectRow(String expectedString,
1411                                          MultipleSelectionModel&lt;String&gt; sm,
1412                                          int rowToSelect) {
1413         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
1414         sm.selectAll();
1415         assertEquals(4, sm.getSelectedIndices().size());
1416         assertEquals(4, sm.getSelectedItems().size());
1417         assertEquals(4, rt_39482_list.size());
1418 
1419         sm.clearAndSelect(rowToSelect);
1420         assertEquals(1, sm.getSelectedIndices().size());
1421         assertEquals(1, sm.getSelectedItems().size());
1422         assertEquals(expectedString, sm.getSelectedItem());
1423         assertEquals(expectedString, rt_39482_list.get(0));
1424         assertEquals(1, rt_39482_list.size());
1425     }
1426 
1427     @Test public void test_rt_39559_useSM_selectAll() {
1428         test_rt_39559(true);
1429     }
1430 
1431     @Test public void test_rt_39559_useKeyboard_selectAll() {
1432         test_rt_39559(false);
1433     }
1434 
1435     private void test_rt_39559(boolean useSMSelectAll) {
1436         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1437         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1438 
1439         MultipleSelectionModel&lt;String&gt; sm = stringListView.getSelectionModel();
1440         sm.setSelectionMode(SelectionMode.MULTIPLE);
1441 
1442         StageLoader sl = new StageLoader(stringListView);
1443         KeyEventFirer keyboard = new KeyEventFirer(stringListView);
1444 
1445         assertEquals(0, sm.getSelectedItems().size());
1446 
1447         sm.clearAndSelect(0);
1448 
1449         if (useSMSelectAll) {
1450             sm.selectAll();
1451         } else {
1452             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
1453         }
1454 
1455         assertEquals(4, sm.getSelectedItems().size());
1456         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1457 
1458         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
1459 
1460         assertEquals(0, (int) ListCellBehavior.getAnchor(stringListView, -1));
1461         assertEquals(2, sm.getSelectedItems().size());
1462         assertEquals(&quot;a&quot;, sm.getSelectedItems().get(0));
1463         assertEquals(&quot;b&quot;, sm.getSelectedItems().get(1));
1464 
1465         sl.dispose();
1466     }
1467 
1468     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
1469         // select and then remove the &#39;a&#39; item, selection and focus should both
1470         // stay at the first row, now &#39;b&#39;
1471         test_rt_16068(0, 0, 0);
1472     }
1473 
1474     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
1475         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
1476         test_rt_16068(0, 2, 0);
1477     }
1478 
1479     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
1480         // select and then remove the &#39;b&#39; item, selection and focus should both
1481         // move up one row to the &#39;a&#39; item
1482         test_rt_16068(1, 1, 0);
1483     }
1484 
1485     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
1486         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
1487         test_rt_16068(1, 2, 1);
1488     }
1489 
1490     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
1491         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
1492         // one row, remaining on &#39;b&#39;
1493         test_rt_16068(1, 0, 0);
1494     }
1495 
1496     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
1497         // select and then remove the &#39;d&#39; item, selection and focus should both
1498         // move up one row to the &#39;c&#39; item
1499         test_rt_16068(3, 3, 2);
1500     }
1501 
1502     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
1503         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
1504         // one row, remaining on &#39;d&#39;
1505         test_rt_16068(3, 0, 2);
1506     }
1507 
1508     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
1509         ListView&lt;String&gt; stringListView = new ListView&lt;&gt;();
1510         stringListView.getItems().addAll(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
1511 
1512         MultipleSelectionModel&lt;?&gt; sm = stringListView.getSelectionModel();
1513         FocusModel&lt;?&gt; fm = stringListView.getFocusModel();
1514 
1515         sm.select(indexToSelect);
1516         assertEquals(indexToSelect, sm.getSelectedIndex());
1517         assertEquals(stringListView.getItems().get(indexToSelect), sm.getSelectedItem());
1518         assertEquals(indexToSelect, fm.getFocusedIndex());
1519         assertEquals(stringListView.getItems().get(indexToSelect), fm.getFocusedItem());
1520 
1521         stringListView.getItems().remove(indexToRemove);
1522         assertEquals(expectedIndex, sm.getSelectedIndex());
1523         assertEquals(stringListView.getItems().get(expectedIndex), sm.getSelectedItem());
1524         assertEquals(expectedIndex, fm.getFocusedIndex());
1525         assertEquals(stringListView.getItems().get(expectedIndex), fm.getFocusedItem());
1526     }
1527 
1528     @Test public void test_rt_22599() {
1529         ObservableList&lt;RT22599_DataType&gt; initialData = FXCollections.observableArrayList(
1530                 new RT22599_DataType(1, &quot;row1&quot;),
1531                 new RT22599_DataType(2, &quot;row2&quot;),
1532                 new RT22599_DataType(3, &quot;row3&quot;)
1533         );
1534 
1535         ListView&lt;RT22599_DataType&gt; listView = new ListView&lt;&gt;();
1536         listView.setItems(initialData);
1537 
1538         StageLoader sl = new StageLoader(listView);
1539 
1540         // testing initial state
1541         assertNotNull(listView.getSkin());
1542         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1543         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(listView, 1).getText());
1544         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(listView, 2).getText());
1545 
1546         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
1547         // Because &#39;set&#39; is called, the control should update to the new content
1548         // without any user interaction
1549         RT22599_DataType data;
1550         initialData.set(0, data = new RT22599_DataType(0, &quot;row1a&quot;));
1551         Toolkit.getToolkit().firePulse();
1552         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1553 
1554         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
1555         // Because there is no associated property, this won&#39;t be observed, so
1556         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
1557         data.text = &quot;row1b&quot;;
1558         Toolkit.getToolkit().firePulse();
1559         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1560 
1561         // call refresh() to force a refresh of all visible cells
1562         listView.refresh();
1563         Toolkit.getToolkit().firePulse();
1564         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(listView, 0).getText());
1565 
1566         sl.dispose();
1567     }
1568 
1569     private static class RT22599_DataType {
1570         public int id = 0;
1571         public String text = &quot;&quot;;
1572 
1573         public RT22599_DataType(int id, String text) {
1574             this.id = id;
1575             this.text = text;
1576         }
1577 
1578         @Override public String toString() {
1579             return text;
1580         }
1581 
1582         @Override public boolean equals(Object obj) {
1583             if (obj == null) return false;
1584             return id == ((RT22599_DataType)obj).id;
1585         }
1586     }
1587 
1588     private int rt_39966_count = 0;
1589     @Test public void test_rt_39966() {
1590         ObservableList&lt;String&gt; list = FXCollections.observableArrayList(&quot;Hello World&quot;);
1591         ListView&lt;String&gt; listView = new ListView&lt;&gt;(list);
1592 
1593         StageLoader sl = new StageLoader(listView);
1594 
1595         // initially there is no selection
1596         assertTrue(listView.getSelectionModel().isEmpty());
1597 
1598         listView.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
1599             if (rt_39966_count == 0) {
1600                 rt_39966_count++;
1601                 assertFalse(listView.getSelectionModel().isEmpty());
1602             } else {
1603                 assertTrue(listView.getSelectionModel().isEmpty());
1604             }
1605         });
1606 
1607         // our assertion two lines down always succeeds. What fails is our
1608         // assertion above within the listener.
1609         listView.getSelectionModel().select(0);
1610         assertFalse(listView.getSelectionModel().isEmpty());
1611 
1612         list.remove(0);
1613         assertTrue(listView.getSelectionModel().isEmpty());
1614 
1615         sl.dispose();
1616     }
1617 
1618     /**
1619      * Bullet 1: selected index must be updated
1620      * Corner case: last selected. Fails for core
1621      */
1622     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
1623         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1624         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1625         SelectionModel sm = listView.getSelectionModel();
1626 
1627         int last = items.size() - 1;
1628 
1629         // selecting item &quot;5&quot;
1630         sm.select(last);
1631 
1632         // disjoint remove of 2 elements above the last selected
1633         // Removing &quot;1&quot; and &quot;3&quot;
1634         items.removeAll(items.get(1), items.get(3));
1635 
1636         // selection should move up two places such that it remains on item &quot;5&quot;,
1637         // but in index (last - 2).
1638         int expected = last - 2;
1639         assertEquals(&quot;5&quot;, sm.getSelectedItem());
1640         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
1641     }
1642 
1643     /**
1644      * Variant of 1: if selectedIndex is not updated,
1645      * the old index is no longer valid
1646      * for accessing the items.
1647      */
1648     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
1649         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1650         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1651         SelectionModel sm = listView.getSelectionModel();
1652 
1653         int last = items.size() - 1;
1654 
1655         // selecting item &quot;5&quot;
1656         sm.select(last);
1657 
1658         // disjoint remove of 2 elements above the last selected
1659         items.removeAll(items.get(1), items.get(3));
1660         int selected = sm.getSelectedIndex();
1661         if (selected &gt; -1) {
1662             items.get(selected);
1663         }
1664     }
1665 
1666     /**
1667      * Bullet 2: selectedIndex notification count
1668      *
1669      * Note that we don&#39;t use the corner case of having the last index selected
1670      * (which fails already on updating the index)
1671      */
1672     private int rt_40012_count = 0;
1673     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
1674         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1675         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1676         SelectionModel sm = listView.getSelectionModel();
1677 
1678         int last = items.size() - 2;
1679         sm.select(last);
1680         assertEquals(last, sm.getSelectedIndex());
1681 
1682         rt_40012_count = 0;
1683         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
1684 
1685         // disjoint remove of 2 elements above the last selected
1686         items.removeAll(items.get(1), items.get(3));
1687         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
1688         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
1689     }
1690 
1691     /**
1692      * Bullet 3: unchanged selectedItem must not fire change
1693      */
1694     @Test
1695     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
1696         ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
1697         ListView&lt;String&gt; listView = new ListView&lt;&gt;(items);
1698         SelectionModel sm = listView.getSelectionModel();
1699 
1700         int last = items.size() - 2;
1701         Object lastItem = items.get(last);
1702         sm.select(last);
1703         assertEquals(lastItem, sm.getSelectedItem());
1704 
1705         rt_40012_count = 0;
1706         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
1707 
1708         // disjoint remove of 2 elements above the last selected
1709         items.removeAll(items.get(1), items.get(3));
1710         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
1711         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
1712     }
1713 
1714     @Test public void test_rt_40185() {
1715         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
1716         final ArrayList&lt;Integer&gt; expected = new ArrayList&lt;&gt;();
1717         Collections.addAll(expected, 1, 2);
1718 
1719         lv.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1720         lv.getSelectionModel().getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1721             while (change.next()) {
1722                 if (change.wasRemoved()) {
1723                     assertEquals(expected, change.getRemoved());
1724                 }
1725             }
1726         });
1727 
1728         lv.getItems().addAll(&quot;-0-&quot;,&quot;-1-&quot;,&quot;-2-&quot;);
1729         lv.getSelectionModel().selectIndices(1, 2);
1730         lv.getSelectionModel().clearSelection();
1731     }
1732 
1733     /**
1734      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
1735      */
1736     private int rt_40212_count = 0;
1737     @Test public void test_rt_40212() {
1738         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1739         for (int i = 0; i &lt; 10; i++) {
1740             lv.getItems().add(i);
1741         }
1742 
1743         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1744         sm.setSelectionMode(SelectionMode.MULTIPLE);
1745 
1746         sm.selectRange(3, 5);
1747         int selected = sm.getSelectedIndex();
1748 
1749         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
1750             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
1751             while(change.next()) {
1752                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
1753 
1754                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
1755                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
1756             }
1757         });
1758 
1759         sm.clearAndSelect(selected);
1760     }
1761 
1762     @Test public void test_rt_40280() {
1763         final ListView&lt;String&gt; view = new ListView&lt;&gt;();
1764         StageLoader sl = new StageLoader(view);
1765         view.getFocusModel().getFocusedIndex();
1766         sl.dispose();
1767     }
1768 
1769     /**
1770      * Test list change of selectedIndices on setIndices. Fails for core ..
1771      */
1772     @Test public void test_rt_40263() {
1773         final ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1774         for (int i = 0; i &lt; 10; i++) {
1775             lv.getItems().add(i);
1776         }
1777 
1778         MultipleSelectionModel&lt;Integer&gt; sm = lv.getSelectionModel();
1779         sm.setSelectionMode(SelectionMode.MULTIPLE);
1780 
1781         int[] indices = new int[]{2, 5, 7};
1782         ListChangeListener&lt;Integer&gt; l = c -&gt; {
1783             // firstly, we expect only one change
1784             int subChanges = 0;
1785             while(c.next()) {
1786                 subChanges++;
1787             }
1788             assertEquals(1, subChanges);
1789 
1790             // secondly, we expect the added size to be three, as that is the
1791             // number of items selected
1792             c.reset();
1793             c.next();
1794             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
1795             assertEquals(indices.length, c.getAddedSize());
1796             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
1797         };
1798         sm.getSelectedIndices().addListener(l);
1799         sm.selectIndices(indices[0], indices);
1800     }
1801 
1802     @Test public void test_jdk8141124() {
1803         ListView&lt;String&gt; listView = new ListView&lt;&gt;();
1804         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1805         SortedList&lt;String&gt; sortedItems = new SortedList&lt;&gt;(items);
1806         sortedItems.setComparator(String::compareTo);
1807         listView.setItems(sortedItems);
1808 
1809         MultipleSelectionModel&lt;String&gt; sm = listView.getSelectionModel();
1810 
1811         items.add(&quot;2&quot;);
1812         listView.getSelectionModel().selectFirst();
1813         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1814         assertEquals(0, sm.getSelectedIndex());
1815         assertEquals(0, (int) sm.getSelectedIndices().get(0));
1816         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1817 
1818         items.addAll(&quot;1&quot;, &quot;3&quot;);
1819         assertEquals(&quot;2&quot;, sm.getSelectedItem());
1820         assertEquals(1, sm.getSelectedIndex());
1821         assertEquals(1, (int) sm.getSelectedIndices().get(0));
1822         assertEquals(&quot;2&quot;, sm.getSelectedItems().get(0));
1823     }
1824 
1825     @Test public void test_jdk_8143594() {
1826         MultipleSelectionModel model = listView.getSelectionModel();
1827         model.setSelectionMode(SelectionMode.MULTIPLE);
1828 
1829         listView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, null);
1830 
1831         model.select(0);
1832         model.clearAndSelect(2);
1833         model.clearAndSelect(0);
1834         model.clearAndSelect(2);
1835     }
1836 
1837     @Test public void test_jdk_8145887_selectedIndices_ListIterator() {
1838         int selectIndices[] = { 4, 7, 9 };
1839         ListView&lt;Integer&gt; lv = new ListView&lt;&gt;();
1840         for (int i = 0; i &lt; 10; ++i) {
1841             lv.getItems().add(i);
1842         }
1843 
1844         MultipleSelectionModel msm = lv.getSelectionModel();
1845         msm.setSelectionMode(SelectionMode.MULTIPLE);
1846         for (int i = 0 ; i &lt; selectIndices.length; ++i) {
1847             msm.select(selectIndices[i]);
1848         }
1849 
1850         ListIterator iter = lv.getSelectionModel().getSelectedIndices().listIterator();
1851 
1852         // Step 1. Initial values
1853         assertEquals(0, iter.nextIndex());
1854         assertEquals(-1, iter.previousIndex());
1855         assertEquals(true, iter.hasNext());
1856         assertEquals(false, iter.hasPrevious());
1857 
1858         // Step 2. Iterate forward.
1859         assertEquals(4, iter.next());
1860         assertEquals(1, iter.nextIndex());
1861         assertEquals(0, iter.previousIndex());
1862         assertEquals(true, iter.hasNext());
1863         assertEquals(true, iter.hasPrevious());
1864 
1865         // Step 3. Iterate forward.
1866         // Values would be at similar state of Step 2.
1867         assertEquals(7, iter.next());
1868 
1869         // Step 4. Iterate forward to Last element.
1870         assertEquals(9, iter.next());
1871         assertEquals(3, iter.nextIndex());
1872         assertEquals(2, iter.previousIndex());
1873         assertEquals(false, iter.hasNext());
1874         assertEquals(true, iter.hasPrevious());
1875 
1876         // Step 5. Verify NoSuchElementException by next()
1877         try {
1878             iter.next();
1879         } catch (Exception e) {
1880             assert(e instanceof NoSuchElementException);
1881         }
1882 
1883         // Step 6. Iterate backward to Last element.
1884         assertEquals(9, iter.previous());
1885         assertEquals(2, iter.nextIndex());
1886         assertEquals(1, iter.previousIndex());
1887         assertEquals(true, iter.hasNext());
1888         assertEquals(true, iter.hasPrevious());
1889 
1890         // Step 7. Iterate forward to Last element.
1891         assertEquals(9, iter.next());
1892         assertEquals(3, iter.nextIndex());
1893         assertEquals(2, iter.previousIndex());
1894         assertEquals(false, iter.hasNext());
1895         assertEquals(true, iter.hasPrevious());
1896 
1897         // Step 8. Iterate forward to last element.
1898         // Values would be at Same state of Step 2.
1899         assertEquals(9, iter.previous());
1900 
1901         // Step 9. Iterate backward.
1902         assertEquals(7, iter.previous());
1903         assertEquals(1, iter.nextIndex());
1904         assertEquals(0, iter.previousIndex());
1905         assertEquals(true, iter.hasNext());
1906         assertEquals(true, iter.hasPrevious());
1907 
1908         // Step 10. Iterate back to first element.
1909         assertEquals(4, iter.previous());
1910         assertEquals(0, iter.nextIndex());
1911         assertEquals(-1, iter.previousIndex());
1912         assertEquals(true, iter.hasNext());
1913         assertEquals(false, iter.hasPrevious());
1914 
1915         // Step 11. Verify NoSuchElementException by previous()
1916         try {
1917             iter.previous();
1918         } catch (Exception e) {
1919             assert(e instanceof NoSuchElementException);
1920         }
1921     }
1922 
1923     @Test public void testListEditStartOnCellStandalone_JDK8187432() {
1924         ListView&lt;String&gt; control = new ListView&lt;&gt;(FXCollections
1925                 .observableArrayList(&quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot;, &quot;Item4&quot;));
1926         control.setEditable(true);
1927         control.setCellFactory(TextFieldListCell.forListView());
1928         StageLoader sl = new StageLoader(control);
1929         int editIndex = 2;
1930 
1931         IndexedCell cell = VirtualFlowTestUtils.getCell(control, editIndex);
1932         ObjectProperty&lt;ListView.EditEvent&gt; editEvent = new SimpleObjectProperty&lt;&gt;();
1933         control.addEventHandler(ListView.editStartEvent(), e -&gt; editEvent.set(e));
1934 
1935         // start edit on cell
1936         cell.startEdit();
1937 
1938         // test cell state
1939         assertTrue(cell.isEditing());
1940         assertEquals(editIndex, cell.getIndex());
1941 
1942         // test editEvent
1943         assertNotNull(editEvent.get());
1944         assertEquals(&quot;type is startEdit&quot;,
1945                      ListView.editStartEvent(), editEvent.get().getEventType());
1946         assertEquals(&quot;index on start event&quot;,
1947                      editIndex, editEvent.get().getIndex());
1948 
1949         sl.dispose();
1950     }
1951 
1952     @Test
1953     public void testEventIndicesOnSelectRange() {
1954         ObservableList&lt;String&gt; listItems = FXCollections.observableArrayList(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
1955         final ListView&lt;String&gt; lv = new ListView&lt;&gt;();
1956         lv.setItems(listItems);
1957         MultipleSelectionModel&lt;String&gt; sm = lv.getSelectionModel();
1958 
1959         int selected = 1;
1960         sm.setSelectionMode(SelectionMode.MULTIPLE);
1961         sm.select(selected);
1962         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) ch -&gt; {
1963             if (ch.next()) {
1964                 assertEquals(&quot;Two items should be selected.&quot;, 2, ch.getList().size());
1965                 assertEquals(&quot;Selection range should be from index 1 &quot;, 1, ch.getFrom());
1966                 assertEquals(&quot;Selection range should be till index 2 &quot;, 2, ch.getTo());
1967             } else {
1968                 fail(&quot;Change event is expected when selection is changed.&quot;);
1969             }
1970         });
1971         int focus = lv.getFocusModel().getFocusedIndex();
1972         assertEquals(&quot;Selected item should be focused.&quot;, selected, focus);
1973         // Select the next element
1974         sm.selectRange(selected, focus + 2);
1975         assertEquals(&quot;Two items should be selected.&quot;, 2, sm.getSelectedIndices().size());
1976         assertEquals(&quot;List item at index 1 should be selected&quot;, 1, (int) sm.getSelectedIndices().get(0));
1977         assertEquals(&quot;List item at index 2 should be selected&quot;, 2, (int) sm.getSelectedIndices().get(1));
1978     }
1979 
1980     @Test
1981     public void testListViewLeak() {
1982         ObservableList&lt;String&gt; items = FXCollections.observableArrayList();
1983         WeakReference&lt;ListView&lt;String&gt;&gt; listViewRef = new WeakReference&lt;&gt;(new ListView&lt;&gt;(items));
1984         attemptGC(listViewRef, 10);
1985         assertNull(&quot;ListView has a leak.&quot;, listViewRef.get());
1986     }
1987 
1988     private void attemptGC(WeakReference&lt;ListView&lt;String&gt;&gt; weakRef, int n) {
1989         for (int i = 0; i &lt; n; i++) {
1990             System.gc();
1991             System.runFinalization();
1992 
1993             if (weakRef.get() == null) {
1994                 break;
1995             }
1996             try {
1997                 Thread.sleep(50);
1998             } catch (InterruptedException e) {
1999                 fail(&quot;InterruptedException occurred during Thread.sleep()&quot;);
2000             }
2001         }
2002     }
2003 }
    </pre>
  </body>
</html>