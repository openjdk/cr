<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/glist.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;glist.h&quot;
  32 #include &quot;gslice.h&quot;
  33 #include &quot;gmessages.h&quot;
  34 
  35 #include &quot;gtestutils.h&quot;
  36 
  37 /**
  38  * SECTION:linked_lists_double
  39  * @title: Doubly-Linked Lists
  40  * @short_description: linked lists that can be iterated over in both directions
  41  *
  42  * The #GList structure and its associated functions provide a standard
  43  * doubly-linked list data structure.
  44  *
  45  * Each element in the list contains a piece of data, together with
  46  * pointers which link to the previous and next elements in the list.
  47  * Using these pointers it is possible to move through the list in both
  48  * directions (unlike the singly-linked [GSList][glib-Singly-Linked-Lists],
  49  * which only allows movement through the list in the forward direction).
  50  *
  51  * The double linked list does not keep track of the number of items
  52  * and does not keep track of both the start and end of the list. If
  53  * you want fast access to both the start and the end of the list,
  54  * and/or the number of items in the list, use a
  55  * [GQueue][glib-Double-ended-Queues] instead.
  56  *
  57  * The data contained in each element can be either integer values, by
  58  * using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],
  59  * or simply pointers to any type of data.
  60  *
  61  * List elements are allocated from the [slice allocator][glib-Memory-Slices],
  62  * which is more efficient than allocating elements individually.
  63  *
  64  * Note that most of the #GList functions expect to be passed a pointer
  65  * to the first element in the list. The functions which insert
  66  * elements return the new start of the list, which may have changed.
  67  *
  68  * There is no function to create a #GList. %NULL is considered to be
  69  * a valid, empty list so you simply set a #GList* to %NULL to initialize
  70  * it.
  71  *
  72  * To add elements, use g_list_append(), g_list_prepend(),
  73  * g_list_insert() and g_list_insert_sorted().
  74  *
  75  * To visit all elements in the list, use a loop over the list:
  76  * |[&lt;!-- language=&quot;C&quot; --&gt;
  77  * GList *l;
  78  * for (l = list; l != NULL; l = l-&gt;next)
  79  *   {
  80  *     // do something with l-&gt;data
  81  *   }
  82  * ]|
  83  *
  84  * To call a function for each element in the list, use g_list_foreach().
  85  *
  86  * To loop over the list and modify it (e.g. remove a certain element)
  87  * a while loop is more appropriate, for example:
  88  * |[&lt;!-- language=&quot;C&quot; --&gt;
  89  * GList *l = list;
  90  * while (l != NULL)
  91  *   {
  92  *     GList *next = l-&gt;next;
  93  *     if (should_be_removed (l))
  94  *       {
  95  *         // possibly free l-&gt;data
  96  *         list = g_list_delete_link (list, l);
  97  *       }
  98  *     l = next;
  99  *   }
 100  * ]|
 101  *
 102  * To remove elements, use g_list_remove().
 103  *
 104  * To navigate in a list, use g_list_first(), g_list_last(),
 105  * g_list_next(), g_list_previous().
 106  *
 107  * To find elements in the list use g_list_nth(), g_list_nth_data(),
 108  * g_list_find() and g_list_find_custom().
 109  *
 110  * To find the index of an element use g_list_position() and
 111  * g_list_index().
 112  *
 113  * To free the entire list, use g_list_free() or g_list_free_full().
 114  */
 115 
 116 /**
 117  * GList:
 118  * @data: holds the element&#39;s data, which can be a pointer to any kind
 119  *        of data, or any integer value using the
 120  *        [Type Conversion Macros][glib-Type-Conversion-Macros]
 121  * @next: contains the link to the next element in the list
 122  * @prev: contains the link to the previous element in the list
 123  *
 124  * The #GList struct is used for each element in a doubly-linked list.
 125  **/
 126 
 127 /**
 128  * g_list_previous:
 129  * @list: an element in a #GList
 130  *
 131  * A convenience macro to get the previous element in a #GList.
 132  * Note that it is considered perfectly acceptable to access
 133  * @list-&gt;prev directly.
 134  *
 135  * Returns: the previous element, or %NULL if there are no previous
 136  *          elements
 137  **/
 138 
 139 /**
 140  * g_list_next:
 141  * @list: an element in a #GList
 142  *
 143  * A convenience macro to get the next element in a #GList.
 144  * Note that it is considered perfectly acceptable to access
 145  * @list-&gt;next directly.
 146  *
 147  * Returns: the next element, or %NULL if there are no more elements
 148  **/
 149 
 150 #define _g_list_alloc()         g_slice_new (GList)
 151 #define _g_list_alloc0()        g_slice_new0 (GList)
 152 #define _g_list_free1(list)     g_slice_free (GList, list)
 153 
 154 /**
 155  * g_list_alloc:
 156  *
 157  * Allocates space for one #GList element. It is called by
 158  * g_list_append(), g_list_prepend(), g_list_insert() and
 159  * g_list_insert_sorted() and so is rarely used on its own.
 160  *
 161  * Returns: a pointer to the newly-allocated #GList element
 162  **/
 163 GList *
 164 g_list_alloc (void)
 165 {
 166   return _g_list_alloc0 ();
 167 }
 168 
 169 /**
 170  * g_list_free:
 171  * @list: a #GList
 172  *
 173  * Frees all of the memory used by a #GList.
 174  * The freed elements are returned to the slice allocator.
 175  *
 176  * If list elements contain dynamically-allocated memory, you should
 177  * either use g_list_free_full() or free them manually first.
 178  */
 179 void
 180 g_list_free (GList *list)
 181 {
 182   g_slice_free_chain (GList, list, next);
 183 }
 184 
 185 /**
 186  * g_list_free_1:
 187  * @list: a #GList element
 188  *
 189  * Frees one #GList element, but does not update links from the next and
 190  * previous elements in the list, so you should not call this function on an
 191  * element that is currently part of a list.
 192  *
 193  * It is usually used after g_list_remove_link().
 194  */
 195 /**
 196  * g_list_free1:
 197  *
 198  * Another name for g_list_free_1().
 199  **/
 200 void
 201 g_list_free_1 (GList *list)
 202 {
 203   _g_list_free1 (list);
 204 }
 205 
 206 /**
 207  * g_list_free_full:
 208  * @list: a pointer to a #GList
 209  * @free_func: the function to be called to free each element&#39;s data
 210  *
 211  * Convenience method, which frees all the memory used by a #GList,
 212  * and calls @free_func on every element&#39;s data.
 213  *
 214  * @free_func must not modify the list (eg, by removing the freed
 215  * element from it).
 216  *
 217  * Since: 2.28
 218  */
 219 void
 220 g_list_free_full (GList          *list,
 221                   GDestroyNotify  free_func)
 222 {
 223   g_list_foreach (list, (GFunc) free_func, NULL);
 224   g_list_free (list);
 225 }
 226 
 227 /**
 228  * g_list_append:
 229  * @list: a pointer to a #GList
 230  * @data: the data for the new element
 231  *
 232  * Adds a new element on to the end of the list.
 233  *
 234  * Note that the return value is the new start of the list,
 235  * if @list was empty; make sure you store the new value.
 236  *
 237  * g_list_append() has to traverse the entire list to find the end,
 238  * which is inefficient when adding multiple elements. A common idiom
 239  * to avoid the inefficiency is to use g_list_prepend() and reverse
 240  * the list with g_list_reverse() when all elements have been added.
 241  *
 242  * |[&lt;!-- language=&quot;C&quot; --&gt;
 243  * // Notice that these are initialized to the empty list.
 244  * GList *string_list = NULL, *number_list = NULL;
 245  *
 246  * // This is a list of strings.
 247  * string_list = g_list_append (string_list, &quot;first&quot;);
 248  * string_list = g_list_append (string_list, &quot;second&quot;);
 249  *
 250  * // This is a list of integers.
 251  * number_list = g_list_append (number_list, GINT_TO_POINTER (27));
 252  * number_list = g_list_append (number_list, GINT_TO_POINTER (14));
 253  * ]|
 254  *
 255  * Returns: either @list or the new start of the #GList if @list was %NULL
 256  */
 257 GList *
 258 g_list_append (GList    *list,
 259                gpointer  data)
 260 {
 261   GList *new_list;
 262   GList *last;
 263 
 264   new_list = _g_list_alloc ();
 265 #ifdef GSTREAMER_LITE
 266   if (new_list == NULL) {
 267     return NULL;
 268   }
 269 #endif // GSTREAMER_LITE
 270   new_list-&gt;data = data;
 271   new_list-&gt;next = NULL;
 272 
 273   if (list)
 274     {
 275       last = g_list_last (list);
 276       /* g_assert (last != NULL); */
 277       last-&gt;next = new_list;
 278       new_list-&gt;prev = last;
 279 
 280       return list;
 281     }
 282   else
 283     {
 284       new_list-&gt;prev = NULL;
 285       return new_list;
 286     }
 287 }
 288 
 289 /**
 290  * g_list_prepend:
 291  * @list: a pointer to a #GList, this must point to the top of the list
 292  * @data: the data for the new element
 293  *
 294  * Prepends a new element on to the start of the list.
 295  *
 296  * Note that the return value is the new start of the list,
 297  * which will have changed, so make sure you store the new value.
 298  *
 299  * |[&lt;!-- language=&quot;C&quot; --&gt;
 300  * // Notice that it is initialized to the empty list.
 301  * GList *list = NULL;
 302  *
 303  * list = g_list_prepend (list, &quot;last&quot;);
 304  * list = g_list_prepend (list, &quot;first&quot;);
 305  * ]|
 306  *
 307  * Do not use this function to prepend a new element to a different
 308  * element than the start of the list. Use g_list_insert_before() instead.
 309  *
 310  * Returns: a pointer to the newly prepended element, which is the new
 311  *     start of the #GList
 312  */
 313 GList *
 314 g_list_prepend (GList    *list,
 315                 gpointer  data)
 316 {
 317   GList *new_list;
 318 
 319   new_list = _g_list_alloc ();
 320 #ifdef GSTREAMER_LITE
 321   if (new_list == NULL) {
 322     return NULL;
 323   }
 324 #endif // GSTREAMER_LITE
 325   new_list-&gt;data = data;
 326   new_list-&gt;next = list;
 327 
 328   if (list)
 329     {
 330       new_list-&gt;prev = list-&gt;prev;
 331       if (list-&gt;prev)
 332         list-&gt;prev-&gt;next = new_list;
 333       list-&gt;prev = new_list;
 334     }
 335   else
 336     new_list-&gt;prev = NULL;
 337 
 338   return new_list;
 339 }
 340 
 341 /**
 342  * g_list_insert:
 343  * @list: a pointer to a #GList, this must point to the top of the list
 344  * @data: the data for the new element
 345  * @position: the position to insert the element. If this is
 346  *     negative, or is larger than the number of elements in the
 347  *     list, the new element is added on to the end of the list.
 348  *
 349  * Inserts a new element into the list at the given position.
 350  *
 351  * Returns: the (possibly changed) start of the #GList
 352  */
 353 GList *
 354 g_list_insert (GList    *list,
 355                gpointer  data,
 356                gint      position)
 357 {
 358   GList *new_list;
 359   GList *tmp_list;
 360 
 361   if (position &lt; 0)
 362     return g_list_append (list, data);
 363   else if (position == 0)
 364     return g_list_prepend (list, data);
 365 
 366   tmp_list = g_list_nth (list, position);
 367   if (!tmp_list)
 368     return g_list_append (list, data);
 369 
 370   new_list = _g_list_alloc ();
 371 #ifdef GSTREAMER_LITE
 372   if (new_list == NULL) {
 373     return NULL;
 374   }
 375 #endif // GSTREAMER_LITE
 376   new_list-&gt;data = data;
 377   new_list-&gt;prev = tmp_list-&gt;prev;
 378   tmp_list-&gt;prev-&gt;next = new_list;
 379   new_list-&gt;next = tmp_list;
 380   tmp_list-&gt;prev = new_list;
 381 
 382   return list;
 383 }
 384 
<a name="1" id="anc1"></a>

























































 385 /**
 386  * g_list_insert_before:
 387  * @list: a pointer to a #GList, this must point to the top of the list
 388  * @sibling: the list element before which the new element
 389  *     is inserted or %NULL to insert at the end of the list
 390  * @data: the data for the new element
 391  *
 392  * Inserts a new element into the list before the given position.
 393  *
 394  * Returns: the (possibly changed) start of the #GList
 395  */
 396 GList *
 397 g_list_insert_before (GList    *list,
 398                       GList    *sibling,
 399                       gpointer  data)
 400 {
<a name="2" id="anc2"></a><span class="line-modified"> 401   if (!list)</span>
 402     {
 403       list = g_list_alloc ();
 404       list-&gt;data = data;
 405       g_return_val_if_fail (sibling == NULL, list);
 406       return list;
 407     }
<a name="3" id="anc3"></a><span class="line-modified"> 408   else if (sibling)</span>
 409     {
 410       GList *node;
 411 
 412       node = _g_list_alloc ();
 413 #ifdef GSTREAMER_LITE
 414       if (node == NULL) {
 415         return NULL;
 416       }
 417 #endif // GSTREAMER_LITE
 418       node-&gt;data = data;
 419       node-&gt;prev = sibling-&gt;prev;
 420       node-&gt;next = sibling;
 421       sibling-&gt;prev = node;
<a name="4" id="anc4"></a><span class="line-modified"> 422       if (node-&gt;prev)</span>
 423         {
 424           node-&gt;prev-&gt;next = node;
 425           return list;
 426         }
 427       else
 428         {
 429           g_return_val_if_fail (sibling == list, node);
 430           return node;
 431         }
 432     }
 433   else
 434     {
 435       GList *last;
 436 
<a name="5" id="anc5"></a><span class="line-modified"> 437       last = list;</span>
<span class="line-removed"> 438       while (last-&gt;next)</span>
<span class="line-removed"> 439         last = last-&gt;next;</span>
 440 
 441       last-&gt;next = _g_list_alloc ();
 442 #ifdef GSTREAMER_LITE
 443       if (last-&gt;next == NULL) {
 444         return NULL;
 445       }
 446 #endif // GSTREAMER_LITE
 447       last-&gt;next-&gt;data = data;
 448       last-&gt;next-&gt;prev = last;
 449       last-&gt;next-&gt;next = NULL;
 450 
 451       return list;
 452     }
 453 }
 454 
 455 /**
 456  * g_list_concat:
 457  * @list1: a #GList, this must point to the top of the list
 458  * @list2: the #GList to add to the end of the first #GList,
 459  *     this must point  to the top of the list
 460  *
 461  * Adds the second #GList onto the end of the first #GList.
 462  * Note that the elements of the second #GList are not copied.
 463  * They are used directly.
 464  *
 465  * This function is for example used to move an element in the list.
 466  * The following example moves an element to the top of the list:
 467  * |[&lt;!-- language=&quot;C&quot; --&gt;
 468  * list = g_list_remove_link (list, llink);
 469  * list = g_list_concat (llink, list);
 470  * ]|
 471  *
 472  * Returns: the start of the new #GList, which equals @list1 if not %NULL
 473  */
 474 GList *
 475 g_list_concat (GList *list1,
 476                GList *list2)
 477 {
 478   GList *tmp_list;
 479 
 480   if (list2)
 481     {
 482       tmp_list = g_list_last (list1);
 483       if (tmp_list)
 484         tmp_list-&gt;next = list2;
 485       else
 486         list1 = list2;
 487       list2-&gt;prev = tmp_list;
 488     }
 489 
 490   return list1;
 491 }
 492 
 493 static inline GList *
 494 _g_list_remove_link (GList *list,
 495                      GList *link)
 496 {
 497   if (link == NULL)
 498     return list;
 499 
 500   if (link-&gt;prev)
 501     {
 502       if (link-&gt;prev-&gt;next == link)
 503         link-&gt;prev-&gt;next = link-&gt;next;
 504       else
 505         g_warning (&quot;corrupted double-linked list detected&quot;);
 506     }
 507   if (link-&gt;next)
 508     {
 509       if (link-&gt;next-&gt;prev == link)
 510         link-&gt;next-&gt;prev = link-&gt;prev;
 511       else
 512         g_warning (&quot;corrupted double-linked list detected&quot;);
 513     }
 514 
 515   if (link == list)
 516     list = list-&gt;next;
 517 
 518   link-&gt;next = NULL;
 519   link-&gt;prev = NULL;
 520 
 521   return list;
 522 }
 523 
 524 /**
 525  * g_list_remove:
 526  * @list: a #GList, this must point to the top of the list
 527  * @data: the data of the element to remove
 528  *
 529  * Removes an element from a #GList.
 530  * If two elements contain the same data, only the first is removed.
 531  * If none of the elements contain the data, the #GList is unchanged.
 532  *
 533  * Returns: the (possibly changed) start of the #GList
 534  */
 535 GList *
 536 g_list_remove (GList         *list,
 537                gconstpointer  data)
 538 {
 539   GList *tmp;
 540 
 541   tmp = list;
 542   while (tmp)
 543     {
 544       if (tmp-&gt;data != data)
 545         tmp = tmp-&gt;next;
 546       else
 547         {
 548           list = _g_list_remove_link (list, tmp);
 549           _g_list_free1 (tmp);
 550 
 551           break;
 552         }
 553     }
 554   return list;
 555 }
 556 
 557 /**
 558  * g_list_remove_all:
 559  * @list: a #GList, this must point to the top of the list
 560  * @data: data to remove
 561  *
 562  * Removes all list nodes with data equal to @data.
 563  * Returns the new head of the list. Contrast with
 564  * g_list_remove() which removes only the first node
 565  * matching the given data.
 566  *
 567  * Returns: the (possibly changed) start of the #GList
 568  */
 569 GList *
 570 g_list_remove_all (GList         *list,
 571                    gconstpointer  data)
 572 {
 573   GList *tmp = list;
 574 
 575   while (tmp)
 576     {
 577       if (tmp-&gt;data != data)
 578         tmp = tmp-&gt;next;
 579       else
 580         {
 581           GList *next = tmp-&gt;next;
 582 
 583           if (tmp-&gt;prev)
 584             tmp-&gt;prev-&gt;next = next;
 585           else
 586             list = next;
 587           if (next)
 588             next-&gt;prev = tmp-&gt;prev;
 589 
 590           _g_list_free1 (tmp);
 591           tmp = next;
 592         }
 593     }
 594   return list;
 595 }
 596 
 597 /**
 598  * g_list_remove_link:
 599  * @list: a #GList, this must point to the top of the list
 600  * @llink: an element in the #GList
 601  *
 602  * Removes an element from a #GList, without freeing the element.
 603  * The removed element&#39;s prev and next links are set to %NULL, so
 604  * that it becomes a self-contained list with one element.
 605  *
 606  * This function is for example used to move an element in the list
 607  * (see the example for g_list_concat()) or to remove an element in
 608  * the list before freeing its data:
 609  * |[&lt;!-- language=&quot;C&quot; --&gt;
 610  * list = g_list_remove_link (list, llink);
 611  * free_some_data_that_may_access_the_list_again (llink-&gt;data);
 612  * g_list_free (llink);
 613  * ]|
 614  *
 615  * Returns: the (possibly changed) start of the #GList
 616  */
 617 GList *
 618 g_list_remove_link (GList *list,
 619                     GList *llink)
 620 {
 621   return _g_list_remove_link (list, llink);
 622 }
 623 
 624 /**
 625  * g_list_delete_link:
 626  * @list: a #GList, this must point to the top of the list
 627  * @link_: node to delete from @list
 628  *
 629  * Removes the node link_ from the list and frees it.
 630  * Compare this to g_list_remove_link() which removes the node
 631  * without freeing it.
 632  *
 633  * Returns: the (possibly changed) start of the #GList
 634  */
 635 GList *
 636 g_list_delete_link (GList *list,
 637                     GList *link_)
 638 {
 639   list = _g_list_remove_link (list, link_);
 640   _g_list_free1 (link_);
 641 
 642   return list;
 643 }
 644 
 645 /**
 646  * g_list_copy:
 647  * @list: a #GList, this must point to the top of the list
 648  *
 649  * Copies a #GList.
 650  *
 651  * Note that this is a &quot;shallow&quot; copy. If the list elements
 652  * consist of pointers to data, the pointers are copied but
 653  * the actual data is not. See g_list_copy_deep() if you need
 654  * to copy the data as well.
 655  *
 656  * Returns: the start of the new list that holds the same data as @list
 657  */
 658 GList *
 659 g_list_copy (GList *list)
 660 {
 661   return g_list_copy_deep (list, NULL, NULL);
 662 }
 663 
 664 /**
 665  * g_list_copy_deep:
 666  * @list: a #GList, this must point to the top of the list
 667  * @func: a copy function used to copy every element in the list
 668  * @user_data: user data passed to the copy function @func, or %NULL
 669  *
 670  * Makes a full (deep) copy of a #GList.
 671  *
 672  * In contrast with g_list_copy(), this function uses @func to make
 673  * a copy of each list element, in addition to copying the list
 674  * container itself.
 675  *
 676  * @func, as a #GCopyFunc, takes two arguments, the data to be copied
 677  * and a @user_data pointer. On common processor architectures, it&#39;s safe to
 678  * pass %NULL as @user_data if the copy function takes only one argument. You
<a name="6" id="anc6"></a><span class="line-modified"> 679  * may get compiler warnings from this though if compiling with GCCâ€™s</span>
 680  * `-Wcast-function-type` warning.
 681  *
 682  * For instance, if @list holds a list of GObjects, you can do:
 683  * |[&lt;!-- language=&quot;C&quot; --&gt;
 684  * another_list = g_list_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
 685  * ]|
 686  *
 687  * And, to entirely free the new list, you could do:
 688  * |[&lt;!-- language=&quot;C&quot; --&gt;
 689  * g_list_free_full (another_list, g_object_unref);
 690  * ]|
 691  *
 692  * Returns: the start of the new list that holds a full copy of @list,
 693  *     use g_list_free_full() to free it
 694  *
 695  * Since: 2.34
 696  */
 697 GList *
 698 g_list_copy_deep (GList     *list,
 699                   GCopyFunc  func,
 700                   gpointer   user_data)
 701 {
 702   GList *new_list = NULL;
 703 
 704   if (list)
 705     {
 706       GList *last;
 707 
 708       new_list = _g_list_alloc ();
<a name="7" id="anc7"></a><span class="line-modified"> 709  #ifdef GSTREAMER_LITE</span>
 710       if (new_list == NULL) {
 711         return NULL;
 712       }
<a name="8" id="anc8"></a><span class="line-modified"> 713  #endif // GSTREAMER_LITE</span>
 714       if (func)
 715         new_list-&gt;data = func (list-&gt;data, user_data);
 716       else
 717         new_list-&gt;data = list-&gt;data;
 718       new_list-&gt;prev = NULL;
 719       last = new_list;
 720       list = list-&gt;next;
 721       while (list)
 722         {
 723           last-&gt;next = _g_list_alloc ();
 724 #ifdef GSTREAMER_LITE
 725           if (last-&gt;next == NULL) {
 726             return NULL;
 727           }
 728 #endif // GSTREAMER_LITE
 729           last-&gt;next-&gt;prev = last;
 730           last = last-&gt;next;
 731           if (func)
 732             last-&gt;data = func (list-&gt;data, user_data);
 733           else
 734             last-&gt;data = list-&gt;data;
 735           list = list-&gt;next;
 736         }
 737       last-&gt;next = NULL;
 738     }
 739 
 740   return new_list;
 741 }
 742 
 743 /**
 744  * g_list_reverse:
 745  * @list: a #GList, this must point to the top of the list
 746  *
 747  * Reverses a #GList.
 748  * It simply switches the next and prev pointers of each element.
 749  *
 750  * Returns: the start of the reversed #GList
 751  */
 752 GList *
 753 g_list_reverse (GList *list)
 754 {
 755   GList *last;
 756 
 757   last = NULL;
 758   while (list)
 759     {
 760       last = list;
 761       list = last-&gt;next;
 762       last-&gt;next = last-&gt;prev;
 763       last-&gt;prev = list;
 764     }
 765 
 766   return last;
 767 }
 768 
 769 /**
 770  * g_list_nth:
 771  * @list: a #GList, this must point to the top of the list
 772  * @n: the position of the element, counting from 0
 773  *
 774  * Gets the element at the given position in a #GList.
 775  *
 776  * This iterates over the list until it reaches the @n-th position. If you
 777  * intend to iterate over every element, it is better to use a for-loop as
 778  * described in the #GList introduction.
 779  *
 780  * Returns: the element, or %NULL if the position is off
 781  *     the end of the #GList
 782  */
 783 GList *
 784 g_list_nth (GList *list,
 785             guint  n)
 786 {
 787   while ((n-- &gt; 0) &amp;&amp; list)
 788     list = list-&gt;next;
 789 
 790   return list;
 791 }
 792 
 793 /**
 794  * g_list_nth_prev:
 795  * @list: a #GList
 796  * @n: the position of the element, counting from 0
 797  *
 798  * Gets the element @n places before @list.
 799  *
 800  * Returns: the element, or %NULL if the position is
 801  *     off the end of the #GList
 802  */
 803 GList *
 804 g_list_nth_prev (GList *list,
 805                  guint  n)
 806 {
 807   while ((n-- &gt; 0) &amp;&amp; list)
 808     list = list-&gt;prev;
 809 
 810   return list;
 811 }
 812 
 813 /**
 814  * g_list_nth_data:
 815  * @list: a #GList, this must point to the top of the list
 816  * @n: the position of the element
 817  *
 818  * Gets the data of the element at the given position.
 819  *
 820  * This iterates over the list until it reaches the @n-th position. If you
 821  * intend to iterate over every element, it is better to use a for-loop as
 822  * described in the #GList introduction.
 823  *
 824  * Returns: the element&#39;s data, or %NULL if the position
 825  *     is off the end of the #GList
 826  */
 827 gpointer
 828 g_list_nth_data (GList *list,
 829                  guint  n)
 830 {
 831   while ((n-- &gt; 0) &amp;&amp; list)
 832     list = list-&gt;next;
 833 
 834   return list ? list-&gt;data : NULL;
 835 }
 836 
 837 /**
 838  * g_list_find:
 839  * @list: a #GList, this must point to the top of the list
 840  * @data: the element data to find
 841  *
 842  * Finds the element in a #GList which contains the given data.
 843  *
 844  * Returns: the found #GList element, or %NULL if it is not found
 845  */
 846 GList *
 847 g_list_find (GList         *list,
 848              gconstpointer  data)
 849 {
 850   while (list)
 851     {
 852       if (list-&gt;data == data)
 853         break;
 854       list = list-&gt;next;
 855     }
 856 
 857   return list;
 858 }
 859 
 860 /**
 861  * g_list_find_custom:
 862  * @list: a #GList, this must point to the top of the list
 863  * @data: user data passed to the function
 864  * @func: the function to call for each element.
 865  *     It should return 0 when the desired element is found
 866  *
 867  * Finds an element in a #GList, using a supplied function to
 868  * find the desired element. It iterates over the list, calling
 869  * the given function which should return 0 when the desired
 870  * element is found. The function takes two #gconstpointer arguments,
 871  * the #GList element&#39;s data as the first argument and the
 872  * given user data.
 873  *
 874  * Returns: the found #GList element, or %NULL if it is not found
 875  */
 876 GList *
 877 g_list_find_custom (GList         *list,
 878                     gconstpointer  data,
 879                     GCompareFunc   func)
 880 {
 881   g_return_val_if_fail (func != NULL, list);
 882 
 883   while (list)
 884     {
 885       if (! func (list-&gt;data, data))
 886         return list;
 887       list = list-&gt;next;
 888     }
 889 
 890   return NULL;
 891 }
 892 
 893 /**
 894  * g_list_position:
 895  * @list: a #GList, this must point to the top of the list
 896  * @llink: an element in the #GList
 897  *
 898  * Gets the position of the given element
 899  * in the #GList (starting from 0).
 900  *
 901  * Returns: the position of the element in the #GList,
 902  *     or -1 if the element is not found
 903  */
 904 gint
 905 g_list_position (GList *list,
 906                  GList *llink)
 907 {
 908   gint i;
 909 
 910   i = 0;
 911   while (list)
 912     {
 913       if (list == llink)
 914         return i;
 915       i++;
 916       list = list-&gt;next;
 917     }
 918 
 919   return -1;
 920 }
 921 
 922 /**
 923  * g_list_index:
 924  * @list: a #GList, this must point to the top of the list
 925  * @data: the data to find
 926  *
 927  * Gets the position of the element containing
 928  * the given data (starting from 0).
 929  *
 930  * Returns: the index of the element containing the data,
 931  *     or -1 if the data is not found
 932  */
 933 gint
 934 g_list_index (GList         *list,
 935               gconstpointer  data)
 936 {
 937   gint i;
 938 
 939   i = 0;
 940   while (list)
 941     {
 942       if (list-&gt;data == data)
 943         return i;
 944       i++;
 945       list = list-&gt;next;
 946     }
 947 
 948   return -1;
 949 }
 950 
 951 /**
 952  * g_list_last:
 953  * @list: any #GList element
 954  *
 955  * Gets the last element in a #GList.
 956  *
 957  * Returns: the last element in the #GList,
 958  *     or %NULL if the #GList has no elements
 959  */
 960 GList *
 961 g_list_last (GList *list)
 962 {
 963   if (list)
 964     {
 965       while (list-&gt;next)
 966         list = list-&gt;next;
 967     }
 968 
 969   return list;
 970 }
 971 
 972 /**
 973  * g_list_first:
 974  * @list: any #GList element
 975  *
 976  * Gets the first element in a #GList.
 977  *
 978  * Returns: the first element in the #GList,
 979  *     or %NULL if the #GList has no elements
 980  */
 981 GList *
 982 g_list_first (GList *list)
 983 {
 984   if (list)
 985     {
 986       while (list-&gt;prev)
 987         list = list-&gt;prev;
 988     }
 989 
 990   return list;
 991 }
 992 
 993 /**
 994  * g_list_length:
 995  * @list: a #GList, this must point to the top of the list
 996  *
 997  * Gets the number of elements in a #GList.
 998  *
 999  * This function iterates over the whole list to count its elements.
1000  * Use a #GQueue instead of a GList if you regularly need the number
1001  * of items. To check whether the list is non-empty, it is faster to check
1002  * @list against %NULL.
1003  *
1004  * Returns: the number of elements in the #GList
1005  */
1006 guint
1007 g_list_length (GList *list)
1008 {
1009   guint length;
1010 
1011   length = 0;
1012   while (list)
1013     {
1014       length++;
1015       list = list-&gt;next;
1016     }
1017 
1018   return length;
1019 }
1020 
1021 /**
1022  * g_list_foreach:
1023  * @list: a #GList, this must point to the top of the list
1024  * @func: the function to call with each element&#39;s data
1025  * @user_data: user data to pass to the function
1026  *
1027  * Calls a function for each element of a #GList.
1028  *
1029  * It is safe for @func to remove the element from @list, but it must
1030  * not modify any part of the list after that element.
1031  */
1032 /**
1033  * GFunc:
1034  * @data: the element&#39;s data
1035  * @user_data: user data passed to g_list_foreach() or g_slist_foreach()
1036  *
1037  * Specifies the type of functions passed to g_list_foreach() and
1038  * g_slist_foreach().
1039  */
1040 void
1041 g_list_foreach (GList    *list,
1042                 GFunc     func,
1043                 gpointer  user_data)
1044 {
1045   while (list)
1046     {
1047       GList *next = list-&gt;next;
1048       (*func) (list-&gt;data, user_data);
1049       list = next;
1050     }
1051 }
1052 
1053 static GList*
1054 g_list_insert_sorted_real (GList    *list,
1055                            gpointer  data,
1056                            GFunc     func,
1057                            gpointer  user_data)
1058 {
1059   GList *tmp_list = list;
1060   GList *new_list;
1061   gint cmp;
1062 
1063   g_return_val_if_fail (func != NULL, list);
1064 
1065   if (!list)
1066     {
1067       new_list = _g_list_alloc0 ();
1068       new_list-&gt;data = data;
1069       return new_list;
1070     }
1071 
1072   cmp = ((GCompareDataFunc) func) (data, tmp_list-&gt;data, user_data);
1073 
1074   while ((tmp_list-&gt;next) &amp;&amp; (cmp &gt; 0))
1075     {
1076       tmp_list = tmp_list-&gt;next;
1077 
1078       cmp = ((GCompareDataFunc) func) (data, tmp_list-&gt;data, user_data);
1079     }
1080 
1081   new_list = _g_list_alloc0 ();
1082   new_list-&gt;data = data;
1083 
1084   if ((!tmp_list-&gt;next) &amp;&amp; (cmp &gt; 0))
1085     {
1086       tmp_list-&gt;next = new_list;
1087       new_list-&gt;prev = tmp_list;
1088       return list;
1089     }
1090 
1091   if (tmp_list-&gt;prev)
1092     {
1093       tmp_list-&gt;prev-&gt;next = new_list;
1094       new_list-&gt;prev = tmp_list-&gt;prev;
1095     }
1096   new_list-&gt;next = tmp_list;
1097   tmp_list-&gt;prev = new_list;
1098 
1099   if (tmp_list == list)
1100     return new_list;
1101   else
1102     return list;
1103 }
1104 
1105 /**
1106  * g_list_insert_sorted:
1107  * @list: a pointer to a #GList, this must point to the top of the
1108  *     already sorted list
1109  * @data: the data for the new element
1110  * @func: the function to compare elements in the list. It should
1111  *     return a number &gt; 0 if the first parameter comes after the
1112  *     second parameter in the sort order.
1113  *
1114  * Inserts a new element into the list, using the given comparison
1115  * function to determine its position.
1116  *
1117  * If you are adding many new elements to a list, and the number of
1118  * new elements is much larger than the length of the list, use
1119  * g_list_prepend() to add the new items and sort the list afterwards
1120  * with g_list_sort().
1121  *
1122  * Returns: the (possibly changed) start of the #GList
1123  */
1124 GList *
1125 g_list_insert_sorted (GList        *list,
1126                       gpointer      data,
1127                       GCompareFunc  func)
1128 {
1129   return g_list_insert_sorted_real (list, data, (GFunc) func, NULL);
1130 }
1131 
1132 /**
1133  * g_list_insert_sorted_with_data:
1134  * @list: a pointer to a #GList, this must point to the top of the
1135  *     already sorted list
1136  * @data: the data for the new element
1137  * @func: the function to compare elements in the list. It should
1138  *     return a number &gt; 0 if the first parameter  comes after the
1139  *     second parameter in the sort order.
1140  * @user_data: user data to pass to comparison function
1141  *
1142  * Inserts a new element into the list, using the given comparison
1143  * function to determine its position.
1144  *
1145  * If you are adding many new elements to a list, and the number of
1146  * new elements is much larger than the length of the list, use
1147  * g_list_prepend() to add the new items and sort the list afterwards
1148  * with g_list_sort().
1149  *
1150  * Returns: the (possibly changed) start of the #GList
1151  *
1152  * Since: 2.10
1153  */
1154 GList *
1155 g_list_insert_sorted_with_data (GList            *list,
1156                                 gpointer          data,
1157                                 GCompareDataFunc  func,
1158                                 gpointer          user_data)
1159 {
1160   return g_list_insert_sorted_real (list, data, (GFunc) func, user_data);
1161 }
1162 
1163 static GList *
1164 g_list_sort_merge (GList     *l1,
1165                    GList     *l2,
1166                    GFunc     compare_func,
1167                    gpointer  user_data)
1168 {
1169   GList list, *l, *lprev;
1170   gint cmp;
1171 
1172   l = &amp;list;
1173   lprev = NULL;
1174 
1175   while (l1 &amp;&amp; l2)
1176     {
1177       cmp = ((GCompareDataFunc) compare_func) (l1-&gt;data, l2-&gt;data, user_data);
1178 
1179       if (cmp &lt;= 0)
1180         {
1181           l-&gt;next = l1;
1182           l1 = l1-&gt;next;
1183         }
1184       else
1185         {
1186           l-&gt;next = l2;
1187           l2 = l2-&gt;next;
1188         }
1189       l = l-&gt;next;
1190       l-&gt;prev = lprev;
1191       lprev = l;
1192     }
1193   l-&gt;next = l1 ? l1 : l2;
1194   l-&gt;next-&gt;prev = l;
1195 
1196   return list.next;
1197 }
1198 
1199 static GList *
1200 g_list_sort_real (GList    *list,
1201                   GFunc     compare_func,
1202                   gpointer  user_data)
1203 {
1204   GList *l1, *l2;
1205 
1206   if (!list)
1207     return NULL;
1208   if (!list-&gt;next)
1209     return list;
1210 
1211   l1 = list;
1212   l2 = list-&gt;next;
1213 
1214   while ((l2 = l2-&gt;next) != NULL)
1215     {
1216       if ((l2 = l2-&gt;next) == NULL)
1217         break;
1218       l1 = l1-&gt;next;
1219     }
1220   l2 = l1-&gt;next;
1221   l1-&gt;next = NULL;
1222 
1223   return g_list_sort_merge (g_list_sort_real (list, compare_func, user_data),
1224                             g_list_sort_real (l2, compare_func, user_data),
1225                             compare_func,
1226                             user_data);
1227 }
1228 
1229 /**
1230  * g_list_sort:
1231  * @list: a #GList, this must point to the top of the list
1232  * @compare_func: the comparison function used to sort the #GList.
1233  *     This function is passed the data from 2 elements of the #GList
1234  *     and should return 0 if they are equal, a negative value if the
1235  *     first element comes before the second, or a positive value if
1236  *     the first element comes after the second.
1237  *
1238  * Sorts a #GList using the given comparison function. The algorithm
1239  * used is a stable sort.
1240  *
1241  * Returns: the (possibly changed) start of the #GList
1242  */
1243 /**
1244  * GCompareFunc:
1245  * @a: a value
1246  * @b: a value to compare with
1247  *
1248  * Specifies the type of a comparison function used to compare two
1249  * values.  The function should return a negative integer if the first
1250  * value comes before the second, 0 if they are equal, or a positive
1251  * integer if the first value comes after the second.
1252  *
1253  * Returns: negative value if @a &lt; @b; zero if @a = @b; positive
1254  *          value if @a &gt; @b
1255  */
1256 GList *
1257 g_list_sort (GList        *list,
1258              GCompareFunc  compare_func)
1259 {
1260   return g_list_sort_real (list, (GFunc) compare_func, NULL);
1261 }
1262 
1263 /**
1264  * g_list_sort_with_data:
1265  * @list: a #GList, this must point to the top of the list
1266  * @compare_func: comparison function
1267  * @user_data: user data to pass to comparison function
1268  *
1269  * Like g_list_sort(), but the comparison function accepts
1270  * a user data argument.
1271  *
1272  * Returns: the (possibly changed) start of the #GList
1273  */
1274 /**
1275  * GCompareDataFunc:
1276  * @a: a value
1277  * @b: a value to compare with
1278  * @user_data: user data
1279  *
1280  * Specifies the type of a comparison function used to compare two
1281  * values.  The function should return a negative integer if the first
1282  * value comes before the second, 0 if they are equal, or a positive
1283  * integer if the first value comes after the second.
1284  *
1285  * Returns: negative value if @a &lt; @b; zero if @a = @b; positive
1286  *          value if @a &gt; @b
1287  */
1288 GList *
1289 g_list_sort_with_data (GList            *list,
1290                        GCompareDataFunc  compare_func,
1291                        gpointer          user_data)
1292 {
1293   return g_list_sort_real (list, (GFunc) compare_func, user_data);
1294 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>