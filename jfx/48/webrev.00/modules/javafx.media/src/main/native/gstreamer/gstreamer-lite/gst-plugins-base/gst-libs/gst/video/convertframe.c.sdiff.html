<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/convertframe.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tag/tag.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideodecoder.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/convertframe.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /* Small helper element for format conversion
  2  * Copyright (C) 2005 Tim-Philipp Müller &lt;tim centricular net&gt;
  3  * Copyright (C) 2010 Brandon Lewis &lt;brandon.lewis@collabora.co.uk&gt;
  4  * Copyright (C) 2010 Edward Hervey &lt;edward.hervey@collabora.co.uk&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */



 21 
 22 #include &lt;string.h&gt;
 23 #include &quot;video.h&quot;
 24 
 25 static gboolean
 26 caps_are_raw (const GstCaps * caps)
 27 {
 28   guint i, len;
 29 
 30   len = gst_caps_get_size (caps);
 31 
 32   for (i = 0; i &lt; len; i++) {
 33     GstStructure *st = gst_caps_get_structure (caps, i);
 34     if (gst_structure_has_name (st, &quot;video/x-raw&quot;))
 35       return TRUE;
 36   }
 37 
 38   return FALSE;
 39 }
 40 
</pre>
<hr />
<pre>
300 {
301   GstMessage *msg;
302   GstBuffer *buf;
303   GstSample *result = NULL;
304   GError *err = NULL;
305   GstBus *bus;
306   GstCaps *from_caps, *to_caps_copy = NULL;
307   GstFlowReturn ret;
308   GstElement *pipeline, *src, *sink;
309   guint i, n;
310 
311   g_return_val_if_fail (sample != NULL, NULL);
312   g_return_val_if_fail (to_caps != NULL, NULL);
313 
314   buf = gst_sample_get_buffer (sample);
315   g_return_val_if_fail (buf != NULL, NULL);
316 
317   from_caps = gst_sample_get_caps (sample);
318   g_return_val_if_fail (from_caps != NULL, NULL);
319 
<span class="line-removed">320 </span>
321   to_caps_copy = gst_caps_new_empty ();
322   n = gst_caps_get_size (to_caps);
323   for (i = 0; i &lt; n; i++) {
324     GstStructure *s = gst_caps_get_structure (to_caps, i);
325 
326     s = gst_structure_copy (s);
327     gst_structure_remove_field (s, &quot;framerate&quot;);
328     gst_caps_append_structure (to_caps_copy, s);
329   }
330 
331   pipeline =
332       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,
333       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;err);
334   if (!pipeline)
335     goto no_pipeline;
336 
337   /* now set the pipeline to the paused state, after we push the buffer into
338    * appsrc, this should preroll the converted buffer in appsink */
339   GST_DEBUG (&quot;running conversion pipeline to caps %&quot; GST_PTR_FORMAT,
340       to_caps_copy);
<span class="line-modified">341   gst_element_set_state (pipeline, GST_STATE_PAUSED);</span>


342 
343   /* feed buffer in appsrc */
344   GST_DEBUG (&quot;feeding buffer %p, size %&quot; G_GSIZE_FORMAT &quot;, caps %&quot;
345       GST_PTR_FORMAT, buf, gst_buffer_get_size (buf), from_caps);
346   g_signal_emit_by_name (src, &quot;push-buffer&quot;, buf, &amp;ret);
347 
348   /* now see what happens. We either got an error somewhere or the pipeline
349    * prerolled */
350   bus = gst_element_get_bus (pipeline);
351   msg = gst_bus_timed_pop_filtered (bus,
352       timeout, GST_MESSAGE_ERROR | GST_MESSAGE_ASYNC_DONE);
353 
354   if (msg) {
355     switch (GST_MESSAGE_TYPE (msg)) {
356       case GST_MESSAGE_ASYNC_DONE:
357       {
358         /* we&#39;re prerolled, get the frame from appsink */
359         g_signal_emit_by_name (sink, &quot;pull-preroll&quot;, &amp;result);
360 
361         if (result) {
</pre>
<hr />
<pre>
384         g_return_val_if_reached (NULL);
385       }
386     }
387     gst_message_unref (msg);
388   } else {
389     GST_ERROR (&quot;Could not convert video frame: timeout during conversion&quot;);
390     if (error)
391       *error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
392           &quot;Could not convert video frame: timeout during conversion&quot;);
393   }
394 
395   gst_element_set_state (pipeline, GST_STATE_NULL);
396   gst_object_unref (bus);
397   gst_object_unref (pipeline);
398   gst_caps_unref (to_caps_copy);
399 
400   return result;
401 
402   /* ERRORS */
403 no_pipeline:

404   {
405     gst_caps_unref (to_caps_copy);
406 
407     if (error)
408       *error = err;
409     else
410       g_error_free (err);
411 
412     return NULL;
413   }
414 }
415 
416 typedef struct
417 {

418   GMutex mutex;
419   GstElement *pipeline;
420   GstVideoConvertSampleCallback callback;
421   gpointer user_data;
422   GDestroyNotify destroy_notify;
423   GMainContext *context;
424   GstSample *sample;
<span class="line-removed">425   //GstBuffer *buffer;</span>
426   GSource *timeout_source;
427   gboolean finished;




428 } GstVideoConvertSampleContext;
429 
<span class="line-modified">430 typedef struct</span>

431 {
<span class="line-modified">432   GstVideoConvertSampleCallback callback;</span>
<span class="line-removed">433   GstSample *sample;</span>
<span class="line-removed">434   //GstBuffer *buffer;</span>
<span class="line-removed">435   GError *error;</span>
<span class="line-removed">436   gpointer user_data;</span>
<span class="line-removed">437   GDestroyNotify destroy_notify;</span>
438 
<span class="line-modified">439   GstVideoConvertSampleContext *context;</span>
<span class="line-modified">440 } GstVideoConvertSampleCallbackContext;</span>
441 
442 static void
<span class="line-modified">443 gst_video_convert_frame_context_free (GstVideoConvertSampleContext * ctx)</span>
444 {
<span class="line-modified">445   /* Wait until all users of the mutex are done */</span>
<span class="line-modified">446   g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="line-modified">447   g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
448   g_mutex_clear (&amp;ctx-&gt;mutex);
449   if (ctx-&gt;timeout_source)
450     g_source_destroy (ctx-&gt;timeout_source);
<span class="line-removed">451   //if (ctx-&gt;buffer)</span>
<span class="line-removed">452   //  gst_buffer_unref (ctx-&gt;buffer);</span>
453   if (ctx-&gt;sample)
454     gst_sample_unref (ctx-&gt;sample);



455   g_main_context_unref (ctx-&gt;context);
456 
<span class="line-modified">457   gst_element_set_state (ctx-&gt;pipeline, GST_STATE_NULL);</span>
<span class="line-modified">458   gst_object_unref (ctx-&gt;pipeline);</span>

459 
460   g_slice_free (GstVideoConvertSampleContext, ctx);
461 }
462 
<span class="line-removed">463 static void</span>
<span class="line-removed">464     gst_video_convert_frame_callback_context_free</span>
<span class="line-removed">465     (GstVideoConvertSampleCallbackContext * ctx)</span>
<span class="line-removed">466 {</span>
<span class="line-removed">467   if (ctx-&gt;context)</span>
<span class="line-removed">468     gst_video_convert_frame_context_free (ctx-&gt;context);</span>
<span class="line-removed">469   g_slice_free (GstVideoConvertSampleCallbackContext, ctx);</span>
<span class="line-removed">470 }</span>
<span class="line-removed">471 </span>
472 static gboolean
<span class="line-modified">473 convert_frame_dispatch_callback (GstVideoConvertSampleCallbackContext * ctx)</span>
474 {
<span class="line-modified">475   ctx-&gt;callback (ctx-&gt;sample, ctx-&gt;error, ctx-&gt;user_data);</span>











476 
477   if (ctx-&gt;destroy_notify)
478     ctx-&gt;destroy_notify (ctx-&gt;user_data);
479 
480   return FALSE;
481 }
482 






483 static void
484 convert_frame_finish (GstVideoConvertSampleContext * context,
485     GstSample * sample, GError * error)
486 {
487   GSource *source;
<span class="line-modified">488   GstVideoConvertSampleCallbackContext *ctx;</span>






489 
490   if (context-&gt;timeout_source)
491     g_source_destroy (context-&gt;timeout_source);
492   context-&gt;timeout_source = NULL;
493 
<span class="line-removed">494   ctx = g_slice_new (GstVideoConvertSampleCallbackContext);</span>
<span class="line-removed">495   ctx-&gt;callback = context-&gt;callback;</span>
<span class="line-removed">496   ctx-&gt;user_data = context-&gt;user_data;</span>
<span class="line-removed">497   ctx-&gt;destroy_notify = context-&gt;destroy_notify;</span>
<span class="line-removed">498   ctx-&gt;sample = sample;</span>
<span class="line-removed">499   //ctx-&gt;buffer = buffer;</span>
<span class="line-removed">500   ctx-&gt;error = error;</span>
<span class="line-removed">501   ctx-&gt;context = context;</span>
<span class="line-removed">502 </span>
503   source = g_timeout_source_new (0);
504   g_source_set_callback (source,
<span class="line-modified">505       (GSourceFunc) convert_frame_dispatch_callback, ctx,</span>
<span class="line-modified">506       (GDestroyNotify) gst_video_convert_frame_callback_context_free);</span>

507   g_source_attach (source, context-&gt;context);
508   g_source_unref (source);
509 
<span class="line-modified">510   context-&gt;finished = TRUE;</span>














511 }
512 
513 static gboolean
514 convert_frame_timeout_callback (GstVideoConvertSampleContext * context)
515 {
516   GError *error;
517 
518   g_mutex_lock (&amp;context-&gt;mutex);
519 
520   if (context-&gt;finished)
521     goto done;
522 
523   GST_ERROR (&quot;Could not convert video frame: timeout&quot;);
524 
525   error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
526       &quot;Could not convert video frame: timeout&quot;);
527 
528   convert_frame_finish (context, NULL, error);
529 
530 done:
</pre>
<hr />
<pre>
576 
577   g_mutex_lock (&amp;context-&gt;mutex);
578 
579   if (context-&gt;finished)
580     goto done;
581 
582   buffer = gst_sample_get_buffer (context-&gt;sample);
583   g_signal_emit_by_name (src, &quot;push-buffer&quot;, buffer, &amp;ret);
584   gst_sample_unref (context-&gt;sample);
585   context-&gt;sample = NULL;
586 
587   if (ret != GST_FLOW_OK) {
588     GST_ERROR (&quot;Could not push video frame: %s&quot;, gst_flow_get_name (ret));
589 
590     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
591         &quot;Could not push video frame: %s&quot;, gst_flow_get_name (ret));
592 
593     convert_frame_finish (context, NULL, error);
594   }
595 
<span class="line-removed">596   g_signal_handlers_disconnect_by_func (src, convert_frame_need_data_callback,</span>
<span class="line-removed">597       context);</span>
<span class="line-removed">598 </span>
599 done:
600   g_mutex_unlock (&amp;context-&gt;mutex);



601 }
602 
603 static GstFlowReturn
604 convert_frame_new_preroll_callback (GstElement * sink,
605     GstVideoConvertSampleContext * context)
606 {
607   GstSample *sample = NULL;
608   GError *error = NULL;
609 
610   g_mutex_lock (&amp;context-&gt;mutex);
611 
612   if (context-&gt;finished)
613     goto done;
614 
615   g_signal_emit_by_name (sink, &quot;pull-preroll&quot;, &amp;sample);
616 
617   if (!sample) {
618     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
619         &quot;Could not get converted video sample&quot;);
620   }
621   convert_frame_finish (context, sample, error);
622 
<span class="line-removed">623   g_signal_handlers_disconnect_by_func (sink, convert_frame_need_data_callback,</span>
<span class="line-removed">624       context);</span>
<span class="line-removed">625 </span>
626 done:
627   g_mutex_unlock (&amp;context-&gt;mutex);
628 



629   return GST_FLOW_OK;
630 }
631 
632 /**
633  * gst_video_convert_sample_async:
634  * @sample: a #GstSample
635  * @to_caps: the #GstCaps to convert to
636  * @timeout: the maximum amount of time allowed for the processing.
637  * @callback: %GstVideoConvertSampleCallback that will be called after conversion.
638  * @user_data: extra data that will be passed to the @callback
639  * @destroy_notify: %GDestroyNotify to be called after @user_data is not needed anymore
640  *
641  * Converts a raw video buffer into the specified output caps.
642  *
643  * The output caps can be any raw video formats or any image formats (jpeg, png, ...).
644  *
645  * The width, height and pixel-aspect-ratio can also be specified in the output caps.
646  *
647  * @callback will be called after conversion, when an error occured or if conversion didn&#39;t
648  * finish after @timeout. @callback will always be called from the thread default
</pre>
<hr />
<pre>
676 
677   from_caps = gst_sample_get_caps (sample);
678   g_return_if_fail (from_caps != NULL);
679   g_return_if_fail (callback != NULL);
680 
681   context = g_main_context_get_thread_default ();
682 
683   if (!context)
684     context = g_main_context_default ();
685 
686   to_caps_copy = gst_caps_new_empty ();
687   n = gst_caps_get_size (to_caps);
688   for (i = 0; i &lt; n; i++) {
689     GstStructure *s = gst_caps_get_structure (to_caps, i);
690 
691     s = gst_structure_copy (s);
692     gst_structure_remove_field (s, &quot;framerate&quot;);
693     gst_caps_append_structure (to_caps_copy, s);
694   }
695 
<span class="line-modified">696   pipeline =</span>
<span class="line-modified">697       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,</span>
<span class="line-modified">698       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;error);</span>
<span class="line-removed">699   if (!pipeline)</span>
<span class="line-removed">700     goto no_pipeline;</span>
<span class="line-removed">701 </span>
<span class="line-removed">702   bus = gst_element_get_bus (pipeline);</span>
<span class="line-removed">703 </span>
704   ctx = g_slice_new0 (GstVideoConvertSampleContext);

705   g_mutex_init (&amp;ctx-&gt;mutex);
<span class="line-removed">706   //ctx-&gt;buffer = gst_buffer_ref (buf);</span>
707   ctx-&gt;sample = gst_sample_ref (sample);
708   ctx-&gt;callback = callback;
709   ctx-&gt;user_data = user_data;
710   ctx-&gt;destroy_notify = destroy_notify;
711   ctx-&gt;context = g_main_context_ref (context);
712   ctx-&gt;finished = FALSE;






713   ctx-&gt;pipeline = pipeline;
714 


715   if (timeout != GST_CLOCK_TIME_NONE) {
716     ctx-&gt;timeout_source = g_timeout_source_new (timeout / GST_MSECOND);
717     g_source_set_callback (ctx-&gt;timeout_source,
<span class="line-modified">718         (GSourceFunc) convert_frame_timeout_callback, ctx, NULL);</span>


719     g_source_attach (ctx-&gt;timeout_source, context);
720   }
721 
<span class="line-modified">722   g_signal_connect (src, &quot;need-data&quot;,</span>
<span class="line-modified">723       G_CALLBACK (convert_frame_need_data_callback), ctx);</span>
<span class="line-modified">724   g_signal_connect (sink, &quot;new-preroll&quot;,</span>
<span class="line-modified">725       G_CALLBACK (convert_frame_new_preroll_callback), ctx);</span>




726 
727   source = gst_bus_create_watch (bus);
728   g_source_set_callback (source, (GSourceFunc) convert_frame_bus_callback,
<span class="line-modified">729       ctx, NULL);</span>

730   g_source_attach (source, context);
731   g_source_unref (source);

732 
<span class="line-modified">733   gst_element_set_state (pipeline, GST_STATE_PLAYING);</span>


734 
<span class="line-removed">735   gst_object_unref (bus);</span>
736   gst_caps_unref (to_caps_copy);
737 


738   return;
739   /* ERRORS */
740 no_pipeline:
741   {
<span class="line-modified">742     GstVideoConvertSampleCallbackContext *ctx;</span>
<span class="line-modified">743     GSource *source;</span>




744 




745     gst_caps_unref (to_caps_copy);
746 
<span class="line-modified">747     ctx = g_slice_new0 (GstVideoConvertSampleCallbackContext);</span>
<span class="line-modified">748     ctx-&gt;callback = callback;</span>
<span class="line-modified">749     ctx-&gt;user_data = user_data;</span>
<span class="line-modified">750     ctx-&gt;destroy_notify = destroy_notify;</span>
<span class="line-modified">751     ctx-&gt;sample = NULL;</span>
<span class="line-modified">752     ctx-&gt;error = error;</span>
<span class="line-modified">753 </span>
<span class="line-modified">754     source = g_timeout_source_new (0);</span>
<span class="line-modified">755     g_source_set_callback (source,</span>
<span class="line-removed">756         (GSourceFunc) convert_frame_dispatch_callback, ctx,</span>
<span class="line-removed">757         (GDestroyNotify) gst_video_convert_frame_callback_context_free);</span>
<span class="line-removed">758     g_source_attach (source, context);</span>
<span class="line-removed">759     g_source_unref (source);</span>
760   }
761 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /* Small helper element for format conversion
  2  * Copyright (C) 2005 Tim-Philipp Müller &lt;tim centricular net&gt;
  3  * Copyright (C) 2010 Brandon Lewis &lt;brandon.lewis@collabora.co.uk&gt;
  4  * Copyright (C) 2010 Edward Hervey &lt;edward.hervey@collabora.co.uk&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
<span class="line-added"> 21 #ifdef HAVE_CONFIG_H</span>
<span class="line-added"> 22 #include &quot;config.h&quot;</span>
<span class="line-added"> 23 #endif</span>
 24 
 25 #include &lt;string.h&gt;
 26 #include &quot;video.h&quot;
 27 
 28 static gboolean
 29 caps_are_raw (const GstCaps * caps)
 30 {
 31   guint i, len;
 32 
 33   len = gst_caps_get_size (caps);
 34 
 35   for (i = 0; i &lt; len; i++) {
 36     GstStructure *st = gst_caps_get_structure (caps, i);
 37     if (gst_structure_has_name (st, &quot;video/x-raw&quot;))
 38       return TRUE;
 39   }
 40 
 41   return FALSE;
 42 }
 43 
</pre>
<hr />
<pre>
303 {
304   GstMessage *msg;
305   GstBuffer *buf;
306   GstSample *result = NULL;
307   GError *err = NULL;
308   GstBus *bus;
309   GstCaps *from_caps, *to_caps_copy = NULL;
310   GstFlowReturn ret;
311   GstElement *pipeline, *src, *sink;
312   guint i, n;
313 
314   g_return_val_if_fail (sample != NULL, NULL);
315   g_return_val_if_fail (to_caps != NULL, NULL);
316 
317   buf = gst_sample_get_buffer (sample);
318   g_return_val_if_fail (buf != NULL, NULL);
319 
320   from_caps = gst_sample_get_caps (sample);
321   g_return_val_if_fail (from_caps != NULL, NULL);
322 

323   to_caps_copy = gst_caps_new_empty ();
324   n = gst_caps_get_size (to_caps);
325   for (i = 0; i &lt; n; i++) {
326     GstStructure *s = gst_caps_get_structure (to_caps, i);
327 
328     s = gst_structure_copy (s);
329     gst_structure_remove_field (s, &quot;framerate&quot;);
330     gst_caps_append_structure (to_caps_copy, s);
331   }
332 
333   pipeline =
334       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,
335       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;err);
336   if (!pipeline)
337     goto no_pipeline;
338 
339   /* now set the pipeline to the paused state, after we push the buffer into
340    * appsrc, this should preroll the converted buffer in appsink */
341   GST_DEBUG (&quot;running conversion pipeline to caps %&quot; GST_PTR_FORMAT,
342       to_caps_copy);
<span class="line-modified">343   if (gst_element_set_state (pipeline,</span>
<span class="line-added">344           GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE)</span>
<span class="line-added">345     goto state_change_failed;</span>
346 
347   /* feed buffer in appsrc */
348   GST_DEBUG (&quot;feeding buffer %p, size %&quot; G_GSIZE_FORMAT &quot;, caps %&quot;
349       GST_PTR_FORMAT, buf, gst_buffer_get_size (buf), from_caps);
350   g_signal_emit_by_name (src, &quot;push-buffer&quot;, buf, &amp;ret);
351 
352   /* now see what happens. We either got an error somewhere or the pipeline
353    * prerolled */
354   bus = gst_element_get_bus (pipeline);
355   msg = gst_bus_timed_pop_filtered (bus,
356       timeout, GST_MESSAGE_ERROR | GST_MESSAGE_ASYNC_DONE);
357 
358   if (msg) {
359     switch (GST_MESSAGE_TYPE (msg)) {
360       case GST_MESSAGE_ASYNC_DONE:
361       {
362         /* we&#39;re prerolled, get the frame from appsink */
363         g_signal_emit_by_name (sink, &quot;pull-preroll&quot;, &amp;result);
364 
365         if (result) {
</pre>
<hr />
<pre>
388         g_return_val_if_reached (NULL);
389       }
390     }
391     gst_message_unref (msg);
392   } else {
393     GST_ERROR (&quot;Could not convert video frame: timeout during conversion&quot;);
394     if (error)
395       *error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
396           &quot;Could not convert video frame: timeout during conversion&quot;);
397   }
398 
399   gst_element_set_state (pipeline, GST_STATE_NULL);
400   gst_object_unref (bus);
401   gst_object_unref (pipeline);
402   gst_caps_unref (to_caps_copy);
403 
404   return result;
405 
406   /* ERRORS */
407 no_pipeline:
<span class="line-added">408 state_change_failed:</span>
409   {
410     gst_caps_unref (to_caps_copy);
411 
412     if (error)
413       *error = err;
414     else
415       g_error_free (err);
416 
417     return NULL;
418   }
419 }
420 
421 typedef struct
422 {
<span class="line-added">423   gint ref_count;</span>
424   GMutex mutex;
425   GstElement *pipeline;
426   GstVideoConvertSampleCallback callback;
427   gpointer user_data;
428   GDestroyNotify destroy_notify;
429   GMainContext *context;
430   GstSample *sample;

431   GSource *timeout_source;
432   gboolean finished;
<span class="line-added">433 </span>
<span class="line-added">434   /* Results */</span>
<span class="line-added">435   GstSample *converted_sample;</span>
<span class="line-added">436   GError *error;</span>
437 } GstVideoConvertSampleContext;
438 
<span class="line-modified">439 static GstVideoConvertSampleContext *</span>
<span class="line-added">440 gst_video_convert_frame_context_ref (GstVideoConvertSampleContext * ctx)</span>
441 {
<span class="line-modified">442   g_atomic_int_inc (&amp;ctx-&gt;ref_count);</span>





443 
<span class="line-modified">444   return ctx;</span>
<span class="line-modified">445 }</span>
446 
447 static void
<span class="line-modified">448 gst_video_convert_frame_context_unref (GstVideoConvertSampleContext * ctx)</span>
449 {
<span class="line-modified">450   if (!g_atomic_int_dec_and_test (&amp;ctx-&gt;ref_count))</span>
<span class="line-modified">451     return;</span>
<span class="line-modified">452 </span>
453   g_mutex_clear (&amp;ctx-&gt;mutex);
454   if (ctx-&gt;timeout_source)
455     g_source_destroy (ctx-&gt;timeout_source);


456   if (ctx-&gt;sample)
457     gst_sample_unref (ctx-&gt;sample);
<span class="line-added">458   if (ctx-&gt;converted_sample)</span>
<span class="line-added">459     gst_sample_unref (ctx-&gt;converted_sample);</span>
<span class="line-added">460   g_clear_error (&amp;ctx-&gt;error);</span>
461   g_main_context_unref (ctx-&gt;context);
462 
<span class="line-modified">463   /* The pipeline was already destroyed in finish() earlier and we</span>
<span class="line-modified">464    * must not end up here without finish() being called */</span>
<span class="line-added">465   g_warn_if_fail (ctx-&gt;pipeline == NULL);</span>
466 
467   g_slice_free (GstVideoConvertSampleContext, ctx);
468 }
469 









470 static gboolean
<span class="line-modified">471 convert_frame_dispatch_callback (GstVideoConvertSampleContext * ctx)</span>
472 {
<span class="line-modified">473   GstSample *sample;</span>
<span class="line-added">474   GError *error;</span>
<span class="line-added">475 </span>
<span class="line-added">476   g_return_val_if_fail (ctx-&gt;converted_sample != NULL</span>
<span class="line-added">477       || ctx-&gt;error != NULL, FALSE);</span>
<span class="line-added">478 </span>
<span class="line-added">479   sample = ctx-&gt;converted_sample;</span>
<span class="line-added">480   error = ctx-&gt;error;</span>
<span class="line-added">481   ctx-&gt;converted_sample = NULL;</span>
<span class="line-added">482   ctx-&gt;error = NULL;</span>
<span class="line-added">483 </span>
<span class="line-added">484   ctx-&gt;callback (sample, error, ctx-&gt;user_data);</span>
485 
486   if (ctx-&gt;destroy_notify)
487     ctx-&gt;destroy_notify (ctx-&gt;user_data);
488 
489   return FALSE;
490 }
491 
<span class="line-added">492 static void</span>
<span class="line-added">493 convert_frame_stop_pipeline (GstElement * element, gpointer user_data)</span>
<span class="line-added">494 {</span>
<span class="line-added">495   gst_element_set_state (element, GST_STATE_NULL);</span>
<span class="line-added">496 }</span>
<span class="line-added">497 </span>
498 static void
499 convert_frame_finish (GstVideoConvertSampleContext * context,
500     GstSample * sample, GError * error)
501 {
502   GSource *source;
<span class="line-modified">503 </span>
<span class="line-added">504   g_return_if_fail (!context-&gt;finished);</span>
<span class="line-added">505   g_return_if_fail (sample != NULL || error != NULL);</span>
<span class="line-added">506 </span>
<span class="line-added">507   context-&gt;finished = TRUE;</span>
<span class="line-added">508   context-&gt;converted_sample = sample;</span>
<span class="line-added">509   context-&gt;error = error;</span>
510 
511   if (context-&gt;timeout_source)
512     g_source_destroy (context-&gt;timeout_source);
513   context-&gt;timeout_source = NULL;
514 









515   source = g_timeout_source_new (0);
516   g_source_set_callback (source,
<span class="line-modified">517       (GSourceFunc) convert_frame_dispatch_callback,</span>
<span class="line-modified">518       gst_video_convert_frame_context_ref (context),</span>
<span class="line-added">519       (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
520   g_source_attach (source, context-&gt;context);
521   g_source_unref (source);
522 
<span class="line-modified">523   /* Asynchronously stop the pipeline here: this will set its</span>
<span class="line-added">524    * state to NULL and get rid of its last reference, which in turn</span>
<span class="line-added">525    * will get rid of all remaining references to our context and free</span>
<span class="line-added">526    * it too. We can&#39;t do this directly here as we might be called from</span>
<span class="line-added">527    * a streaming thread.</span>
<span class="line-added">528    *</span>
<span class="line-added">529    * We don&#39;t use the main loop here because the user might shut down it</span>
<span class="line-added">530    * immediately after getting the result of the conversion above.</span>
<span class="line-added">531    */</span>
<span class="line-added">532   if (context-&gt;pipeline) {</span>
<span class="line-added">533     gst_element_call_async (context-&gt;pipeline, convert_frame_stop_pipeline,</span>
<span class="line-added">534         NULL, NULL);</span>
<span class="line-added">535     gst_object_unref (context-&gt;pipeline);</span>
<span class="line-added">536     context-&gt;pipeline = NULL;</span>
<span class="line-added">537   }</span>
538 }
539 
540 static gboolean
541 convert_frame_timeout_callback (GstVideoConvertSampleContext * context)
542 {
543   GError *error;
544 
545   g_mutex_lock (&amp;context-&gt;mutex);
546 
547   if (context-&gt;finished)
548     goto done;
549 
550   GST_ERROR (&quot;Could not convert video frame: timeout&quot;);
551 
552   error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
553       &quot;Could not convert video frame: timeout&quot;);
554 
555   convert_frame_finish (context, NULL, error);
556 
557 done:
</pre>
<hr />
<pre>
603 
604   g_mutex_lock (&amp;context-&gt;mutex);
605 
606   if (context-&gt;finished)
607     goto done;
608 
609   buffer = gst_sample_get_buffer (context-&gt;sample);
610   g_signal_emit_by_name (src, &quot;push-buffer&quot;, buffer, &amp;ret);
611   gst_sample_unref (context-&gt;sample);
612   context-&gt;sample = NULL;
613 
614   if (ret != GST_FLOW_OK) {
615     GST_ERROR (&quot;Could not push video frame: %s&quot;, gst_flow_get_name (ret));
616 
617     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
618         &quot;Could not push video frame: %s&quot;, gst_flow_get_name (ret));
619 
620     convert_frame_finish (context, NULL, error);
621   }
622 



623 done:
624   g_mutex_unlock (&amp;context-&gt;mutex);
<span class="line-added">625 </span>
<span class="line-added">626   g_signal_handlers_disconnect_by_func (src, convert_frame_need_data_callback,</span>
<span class="line-added">627       context);</span>
628 }
629 
630 static GstFlowReturn
631 convert_frame_new_preroll_callback (GstElement * sink,
632     GstVideoConvertSampleContext * context)
633 {
634   GstSample *sample = NULL;
635   GError *error = NULL;
636 
637   g_mutex_lock (&amp;context-&gt;mutex);
638 
639   if (context-&gt;finished)
640     goto done;
641 
642   g_signal_emit_by_name (sink, &quot;pull-preroll&quot;, &amp;sample);
643 
644   if (!sample) {
645     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
646         &quot;Could not get converted video sample&quot;);
647   }
648   convert_frame_finish (context, sample, error);
649 



650 done:
651   g_mutex_unlock (&amp;context-&gt;mutex);
652 
<span class="line-added">653   g_signal_handlers_disconnect_by_func (sink, convert_frame_need_data_callback,</span>
<span class="line-added">654       context);</span>
<span class="line-added">655 </span>
656   return GST_FLOW_OK;
657 }
658 
659 /**
660  * gst_video_convert_sample_async:
661  * @sample: a #GstSample
662  * @to_caps: the #GstCaps to convert to
663  * @timeout: the maximum amount of time allowed for the processing.
664  * @callback: %GstVideoConvertSampleCallback that will be called after conversion.
665  * @user_data: extra data that will be passed to the @callback
666  * @destroy_notify: %GDestroyNotify to be called after @user_data is not needed anymore
667  *
668  * Converts a raw video buffer into the specified output caps.
669  *
670  * The output caps can be any raw video formats or any image formats (jpeg, png, ...).
671  *
672  * The width, height and pixel-aspect-ratio can also be specified in the output caps.
673  *
674  * @callback will be called after conversion, when an error occured or if conversion didn&#39;t
675  * finish after @timeout. @callback will always be called from the thread default
</pre>
<hr />
<pre>
703 
704   from_caps = gst_sample_get_caps (sample);
705   g_return_if_fail (from_caps != NULL);
706   g_return_if_fail (callback != NULL);
707 
708   context = g_main_context_get_thread_default ();
709 
710   if (!context)
711     context = g_main_context_default ();
712 
713   to_caps_copy = gst_caps_new_empty ();
714   n = gst_caps_get_size (to_caps);
715   for (i = 0; i &lt; n; i++) {
716     GstStructure *s = gst_caps_get_structure (to_caps, i);
717 
718     s = gst_structure_copy (s);
719     gst_structure_remove_field (s, &quot;framerate&quot;);
720     gst_caps_append_structure (to_caps_copy, s);
721   }
722 
<span class="line-modified">723   /* There&#39;s a reference cycle between the context and the pipeline, which is</span>
<span class="line-modified">724    * broken up once the finish() is called on the context. At latest when the</span>
<span class="line-modified">725    * timeout triggers the context will be freed */</span>





726   ctx = g_slice_new0 (GstVideoConvertSampleContext);
<span class="line-added">727   ctx-&gt;ref_count = 1;</span>
728   g_mutex_init (&amp;ctx-&gt;mutex);

729   ctx-&gt;sample = gst_sample_ref (sample);
730   ctx-&gt;callback = callback;
731   ctx-&gt;user_data = user_data;
732   ctx-&gt;destroy_notify = destroy_notify;
733   ctx-&gt;context = g_main_context_ref (context);
734   ctx-&gt;finished = FALSE;
<span class="line-added">735 </span>
<span class="line-added">736   pipeline =</span>
<span class="line-added">737       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,</span>
<span class="line-added">738       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;error);</span>
<span class="line-added">739   if (!pipeline)</span>
<span class="line-added">740     goto no_pipeline;</span>
741   ctx-&gt;pipeline = pipeline;
742 
<span class="line-added">743   bus = gst_element_get_bus (pipeline);</span>
<span class="line-added">744 </span>
745   if (timeout != GST_CLOCK_TIME_NONE) {
746     ctx-&gt;timeout_source = g_timeout_source_new (timeout / GST_MSECOND);
747     g_source_set_callback (ctx-&gt;timeout_source,
<span class="line-modified">748         (GSourceFunc) convert_frame_timeout_callback,</span>
<span class="line-added">749         gst_video_convert_frame_context_ref (ctx),</span>
<span class="line-added">750         (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
751     g_source_attach (ctx-&gt;timeout_source, context);
752   }
753 
<span class="line-modified">754   g_signal_connect_data (src, &quot;need-data&quot;,</span>
<span class="line-modified">755       G_CALLBACK (convert_frame_need_data_callback),</span>
<span class="line-modified">756       gst_video_convert_frame_context_ref (ctx),</span>
<span class="line-modified">757       (GClosureNotify) gst_video_convert_frame_context_unref, 0);</span>
<span class="line-added">758   g_signal_connect_data (sink, &quot;new-preroll&quot;,</span>
<span class="line-added">759       G_CALLBACK (convert_frame_new_preroll_callback),</span>
<span class="line-added">760       gst_video_convert_frame_context_ref (ctx),</span>
<span class="line-added">761       (GClosureNotify) gst_video_convert_frame_context_unref, 0);</span>
762 
763   source = gst_bus_create_watch (bus);
764   g_source_set_callback (source, (GSourceFunc) convert_frame_bus_callback,
<span class="line-modified">765       gst_video_convert_frame_context_ref (ctx),</span>
<span class="line-added">766       (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
767   g_source_attach (source, context);
768   g_source_unref (source);
<span class="line-added">769   gst_object_unref (bus);</span>
770 
<span class="line-modified">771   if (gst_element_set_state (pipeline,</span>
<span class="line-added">772           GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE)</span>
<span class="line-added">773     goto state_change_failed;</span>
774 

775   gst_caps_unref (to_caps_copy);
776 
<span class="line-added">777   gst_video_convert_frame_context_unref (ctx);</span>
<span class="line-added">778 </span>
779   return;
780   /* ERRORS */
781 no_pipeline:
782   {
<span class="line-modified">783     gst_caps_unref (to_caps_copy);</span>
<span class="line-modified">784 </span>
<span class="line-added">785     g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="line-added">786     convert_frame_finish (ctx, NULL, error);</span>
<span class="line-added">787     g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
<span class="line-added">788     gst_video_convert_frame_context_unref (ctx);</span>
789 
<span class="line-added">790     return;</span>
<span class="line-added">791   }</span>
<span class="line-added">792 state_change_failed:</span>
<span class="line-added">793   {</span>
794     gst_caps_unref (to_caps_copy);
795 
<span class="line-modified">796     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_STATE_CHANGE,</span>
<span class="line-modified">797         &quot;failed to change state to PLAYING&quot;);</span>
<span class="line-modified">798 </span>
<span class="line-modified">799     g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="line-modified">800     convert_frame_finish (ctx, NULL, error);</span>
<span class="line-modified">801     g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
<span class="line-modified">802     gst_video_convert_frame_context_unref (ctx);</span>
<span class="line-modified">803 </span>
<span class="line-modified">804     return;</span>




805   }
806 }
</pre>
</td>
</tr>
</table>
<center><a href="../tag/tag.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideodecoder.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>