<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleAdjuster.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012, 2013 Google Inc. All rights reserved.
 12  * Copyright (C) 2014 Igalia S.L.
 13  *
 14  * This library is free software; you can redistribute it and/or
 15  * modify it under the terms of the GNU Library General Public
 16  * License as published by the Free Software Foundation; either
 17  * version 2 of the License, or (at your option) any later version.
 18  *
 19  * This library is distributed in the hope that it will be useful,
 20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 22  * Library General Public License for more details.
 23  *
 24  * You should have received a copy of the GNU Library General Public License
 25  * along with this library; see the file COPYING.LIB.  If not, write to
 26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 27  * Boston, MA 02110-1301, USA.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;StyleAdjuster.h&quot;
 32 
 33 #include &quot;AnimationBase.h&quot;
 34 #include &quot;CSSFontSelector.h&quot;
 35 #include &quot;Element.h&quot;
 36 #include &quot;FrameView.h&quot;
 37 #include &quot;HTMLInputElement.h&quot;
 38 #include &quot;HTMLMarqueeElement.h&quot;
 39 #include &quot;HTMLNames.h&quot;
 40 #include &quot;HTMLSlotElement.h&quot;
 41 #include &quot;HTMLTableElement.h&quot;
 42 #include &quot;HTMLTextAreaElement.h&quot;
 43 #include &quot;MathMLElement.h&quot;
 44 #include &quot;Page.h&quot;
 45 #include &quot;Quirks.h&quot;
 46 #include &quot;RenderBox.h&quot;
 47 #include &quot;RenderStyle.h&quot;
 48 #include &quot;RenderTheme.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;SVGDocument.h&quot;
 51 #include &quot;SVGElement.h&quot;
 52 #include &quot;SVGNames.h&quot;
 53 #include &quot;SVGURIReference.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;Text.h&quot;
 56 
 57 namespace WebCore {
 58 namespace Style {
 59 
 60 using namespace HTMLNames;
 61 
 62 Adjuster::Adjuster(const Document&amp; document, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle, const Element* element)
 63     : m_document(document)
 64     , m_parentStyle(parentStyle)
 65     , m_parentBoxStyle(parentBoxStyle ? *parentBoxStyle : m_parentStyle)
 66     , m_element(element)
 67 {
 68 }
 69 
 70 static void addIntrinsicMargins(RenderStyle&amp; style)
 71 {
 72     // Intrinsic margin value.
 73     const int intrinsicMargin = clampToInteger(2 * style.effectiveZoom());
 74 
 75     // FIXME: Using width/height alone and not also dealing with min-width/max-width is flawed.
 76     // FIXME: Using &quot;hasQuirk&quot; to decide the margin wasn&#39;t set is kind of lame.
 77     if (style.width().isIntrinsicOrAuto()) {
 78         if (style.marginLeft().hasQuirk())
 79             style.setMarginLeft(Length(intrinsicMargin, Fixed));
 80         if (style.marginRight().hasQuirk())
 81             style.setMarginRight(Length(intrinsicMargin, Fixed));
 82     }
 83 
 84     if (style.height().isAuto()) {
 85         if (style.marginTop().hasQuirk())
 86             style.setMarginTop(Length(intrinsicMargin, Fixed));
 87         if (style.marginBottom().hasQuirk())
 88             style.setMarginBottom(Length(intrinsicMargin, Fixed));
 89     }
 90 }
 91 
 92 static DisplayType equivalentBlockDisplay(const RenderStyle&amp; style, const Document&amp; document)
 93 {
 94     switch (auto display = style.display()) {
 95     case DisplayType::Block:
 96     case DisplayType::Table:
 97     case DisplayType::Box:
 98     case DisplayType::Flex:
 99     case DisplayType::WebKitFlex:
100     case DisplayType::Grid:
101     case DisplayType::FlowRoot:
102         return display;
103 
104     case DisplayType::ListItem:
105         // It is a WinIE bug that floated list items lose their bullets, so we&#39;ll emulate the quirk, but only in quirks mode.
106         if (document.inQuirksMode() &amp;&amp; style.isFloating())
107             return DisplayType::Block;
108         return display;
109     case DisplayType::InlineTable:
110         return DisplayType::Table;
111     case DisplayType::InlineBox:
112         return DisplayType::Box;
113     case DisplayType::InlineFlex:
114     case DisplayType::WebKitInlineFlex:
115         return DisplayType::Flex;
116     case DisplayType::InlineGrid:
117         return DisplayType::Grid;
118 
119     case DisplayType::Inline:
120     case DisplayType::InlineBlock:
121     case DisplayType::TableRowGroup:
122     case DisplayType::TableHeaderGroup:
123     case DisplayType::TableFooterGroup:
124     case DisplayType::TableRow:
125     case DisplayType::TableColumnGroup:
126     case DisplayType::TableColumn:
127     case DisplayType::TableCell:
128     case DisplayType::TableCaption:
129         return DisplayType::Block;
130     case DisplayType::Contents:
131         ASSERT_NOT_REACHED();
132         return DisplayType::Contents;
133     case DisplayType::None:
134         ASSERT_NOT_REACHED();
135         return DisplayType::None;
136     }
137     ASSERT_NOT_REACHED();
138     return DisplayType::Block;
139 }
140 
141 static inline bool isAtShadowBoundary(const Element&amp; element)
142 {
143     auto* parentNode = element.parentNode();
144     return parentNode &amp;&amp; parentNode-&gt;isShadowRoot();
145 }
146 
147 // CSS requires text-decoration to be reset at each DOM element for tables,
148 // inline blocks, inline tables, shadow DOM crossings, floating elements,
149 // and absolute or relatively positioned elements.
150 static bool doesNotInheritTextDecoration(const RenderStyle&amp; style, const Element* element)
151 {
152     return style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
153         || style.display() == DisplayType::InlineBlock || style.display() == DisplayType::InlineBox || (element &amp;&amp; isAtShadowBoundary(*element))
154         || style.isFloating() || style.hasOutOfFlowPosition();
155 }
156 
157 #if ENABLE(OVERFLOW_SCROLLING_TOUCH) || ENABLE(POINTER_EVENTS)
158 static bool isScrollableOverflow(Overflow overflow)
159 {
160     return overflow == Overflow::Scroll || overflow == Overflow::Auto;
161 }
162 #endif
163 
164 #if ENABLE(POINTER_EVENTS)
165 static OptionSet&lt;TouchAction&gt; computeEffectiveTouchActions(const RenderStyle&amp; style, OptionSet&lt;TouchAction&gt; effectiveTouchActions)
166 {
167     // https://w3c.github.io/pointerevents/#determining-supported-touch-behavior
168     // &quot;A touch behavior is supported if it conforms to the touch-action property of each element between
169     // the hit tested element and its nearest ancestor with the default touch behavior (including both the
170     // hit tested element and the element with the default touch behavior).&quot;
171 
172     bool hasDefaultTouchBehavior = isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY());
173     if (hasDefaultTouchBehavior)
174         effectiveTouchActions = RenderStyle::initialTouchActions();
175 
176     auto touchActions = style.touchActions();
177     if (touchActions == RenderStyle::initialTouchActions())
178         return effectiveTouchActions;
179 
180     if (effectiveTouchActions.contains(TouchAction::None))
181         return { TouchAction::None };
182 
183     if (effectiveTouchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))
184         return touchActions;
185 
186     if (touchActions.containsAny({ TouchAction::Auto, TouchAction::Manipulation }))
187         return effectiveTouchActions;
188 
189     auto sharedTouchActions = effectiveTouchActions &amp; touchActions;
190     if (sharedTouchActions.isEmpty())
191         return { TouchAction::None };
192 
193     return sharedTouchActions;
194 }
195 #endif
196 
197 void Adjuster::adjust(RenderStyle&amp; style, const RenderStyle* userAgentAppearanceStyle) const
198 {
199     // Cache our original display.
200     style.setOriginalDisplay(style.display());
201 
202     if (style.display() == DisplayType::Contents)
203         adjustDisplayContentsStyle(style);
204 
205     if (style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents) {
206         if (m_element) {
207             // If we have a &lt;td&gt; that specifies a float property, in quirks mode we just drop the float
208             // property.
209             // Sites also commonly use display:inline/block on &lt;td&gt;s and &lt;table&gt;s. In quirks mode we force
210             // these tags to retain their display types.
211             if (m_document.inQuirksMode()) {
212                 if (m_element-&gt;hasTagName(tdTag)) {
213                     style.setDisplay(DisplayType::TableCell);
214                     style.setFloating(Float::No);
215                 } else if (is&lt;HTMLTableElement&gt;(*m_element))
216                     style.setDisplay(style.isDisplayInlineType() ? DisplayType::InlineTable : DisplayType::Table);
217             }
218 
219             if (m_element-&gt;hasTagName(tdTag) || m_element-&gt;hasTagName(thTag)) {
220                 if (style.whiteSpace() == WhiteSpace::KHTMLNoWrap) {
221                     // Figure out if we are really nowrapping or if we should just
222                     // use normal instead. If the width of the cell is fixed, then
223                     // we don&#39;t actually use WhiteSpace::NoWrap.
224                     if (style.width().isFixed())
225                         style.setWhiteSpace(WhiteSpace::Normal);
226                     else
227                         style.setWhiteSpace(WhiteSpace::NoWrap);
228                 }
229             }
230 
231             // Tables never support the -webkit-* values for text-align and will reset back to the default.
232             if (is&lt;HTMLTableElement&gt;(*m_element) &amp;&amp; (style.textAlign() == TextAlignMode::WebKitLeft || style.textAlign() == TextAlignMode::WebKitCenter || style.textAlign() == TextAlignMode::WebKitRight))
233                 style.setTextAlign(TextAlignMode::Start);
234 
235             // Frames and framesets never honor position:relative or position:absolute. This is necessary to
236             // fix a crash where a site tries to position these objects. They also never honor display.
237             if (m_element-&gt;hasTagName(frameTag) || m_element-&gt;hasTagName(framesetTag)) {
238                 style.setPosition(PositionType::Static);
239                 style.setDisplay(DisplayType::Block);
240             }
241 
242             // Ruby text does not support float or position. This might change with evolution of the specification.
243             if (m_element-&gt;hasTagName(rtTag)) {
244                 style.setPosition(PositionType::Static);
245                 style.setFloating(Float::No);
246             }
247 
248             // User agents are expected to have a rule in their user agent stylesheet that matches th elements that have a parent
249             // node whose computed value for the &#39;text-align&#39; property is its initial value, whose declaration block consists of
250             // just a single declaration that sets the &#39;text-align&#39; property to the value &#39;center&#39;.
251             // https://html.spec.whatwg.org/multipage/rendering.html#rendering
252             if (m_element-&gt;hasTagName(thTag) &amp;&amp; !style.hasExplicitlySetTextAlign() &amp;&amp; m_parentStyle.textAlign() == RenderStyle::initialTextAlign())
253                 style.setTextAlign(TextAlignMode::Center);
254 
255             if (m_element-&gt;hasTagName(legendTag))
256                 style.setDisplay(DisplayType::Block);
257         }
258 
259         // Absolute/fixed positioned elements, floating elements and the document element need block-like outside display.
260         if (style.hasOutOfFlowPosition() || style.isFloating() || (m_element &amp;&amp; m_document.documentElement() == m_element))
261             style.setDisplay(equivalentBlockDisplay(style, m_document));
262 
263         // FIXME: Don&#39;t support this mutation for pseudo styles like first-letter or first-line, since it&#39;s not completely
264         // clear how that should work.
265         if (style.display() == DisplayType::Inline &amp;&amp; style.styleType() == PseudoId::None &amp;&amp; style.writingMode() != m_parentStyle.writingMode())
266             style.setDisplay(DisplayType::InlineBlock);
267 
268         // After performing the display mutation, check table rows. We do not honor position:relative or position:sticky on
269         // table rows or cells. This has been established for position:relative in CSS2.1 (and caused a crash in containingBlock()
270         // on some sites).
271         if ((style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRowGroup
272             || style.display() == DisplayType::TableFooterGroup || style.display() == DisplayType::TableRow)
273             &amp;&amp; style.position() == PositionType::Relative)
274             style.setPosition(PositionType::Static);
275 
276         // writing-mode does not apply to table row groups, table column groups, table rows, and table columns.
277         // FIXME: Table cells should be allowed to be perpendicular or flipped with respect to the table, though.
278         if (style.display() == DisplayType::TableColumn || style.display() == DisplayType::TableColumnGroup || style.display() == DisplayType::TableFooterGroup
279             || style.display() == DisplayType::TableHeaderGroup || style.display() == DisplayType::TableRow || style.display() == DisplayType::TableRowGroup
280             || style.display() == DisplayType::TableCell)
281             style.setWritingMode(m_parentStyle.writingMode());
282 
283         // FIXME: Since we don&#39;t support block-flow on flexible boxes yet, disallow setting
284         // of block-flow to anything other than TopToBottomWritingMode.
285         // https://bugs.webkit.org/show_bug.cgi?id=46418 - Flexible box support.
286         if (style.writingMode() != TopToBottomWritingMode &amp;&amp; (style.display() == DisplayType::Box || style.display() == DisplayType::InlineBox))
287             style.setWritingMode(TopToBottomWritingMode);
288 
289         // https://www.w3.org/TR/css-display/#transformations
290         // &quot;A parent with a grid or flex display value blockifies the boxâ€™s display type.&quot;
291         if (m_parentBoxStyle.isDisplayFlexibleOrGridBox()) {
292             style.setFloating(Float::No);
293             style.setDisplay(equivalentBlockDisplay(style, m_document));
294         }
295     }
296 
297     // Make sure our z-index value is only applied if the object is positioned.
298     if (style.hasAutoSpecifiedZIndex() || (style.position() == PositionType::Static &amp;&amp; !m_parentBoxStyle.isDisplayFlexibleOrGridBox()))
299         style.setHasAutoUsedZIndex();
300     else
301         style.setUsedZIndex(style.specifiedZIndex());
302 
303     // Auto z-index becomes 0 for the root element and transparent objects. This prevents
304     // cases where objects that should be blended as a single unit end up with a non-transparent
305     // object wedged in between them. Auto z-index also becomes 0 for objects that specify transforms/masks/reflections.
306     if (style.hasAutoUsedZIndex()) {
307         if ((m_element &amp;&amp; m_document.documentElement() == m_element)
308             || style.opacity() &lt; 1.0f
309             || style.hasTransformRelatedProperty()
310             || style.hasMask()
311             || style.clipPath()
312             || style.boxReflect()
313             || style.hasFilter()
314 #if ENABLE(FILTERS_LEVEL_2)
315             || style.hasBackdropFilter()
316 #endif
317             || style.hasBlendMode()
318             || style.hasIsolation()
319             || style.position() == PositionType::Sticky
320             || style.position() == PositionType::Fixed
321             || style.willChangeCreatesStackingContext())
322             style.setUsedZIndex(0);
323     }
324 
325     if (m_element) {
326         // Textarea considers overflow visible as auto.
327         if (is&lt;HTMLTextAreaElement&gt;(*m_element)) {
328             style.setOverflowX(style.overflowX() == Overflow::Visible ? Overflow::Auto : style.overflowX());
329             style.setOverflowY(style.overflowY() == Overflow::Visible ? Overflow::Auto : style.overflowY());
330         }
331 
332         // Disallow -webkit-user-modify on :pseudo and ::pseudo elements.
333         if (!m_element-&gt;shadowPseudoId().isNull())
334             style.setUserModify(UserModify::ReadOnly);
335 
336         if (is&lt;HTMLMarqueeElement&gt;(*m_element)) {
337             // For now, &lt;marquee&gt; requires an overflow clip to work properly.
338             style.setOverflowX(Overflow::Hidden);
339             style.setOverflowY(Overflow::Hidden);
340 
341             bool isVertical = style.marqueeDirection() == MarqueeDirection::Up || style.marqueeDirection() == MarqueeDirection::Down;
342             // Make horizontal marquees not wrap.
343             if (!isVertical) {
344                 style.setWhiteSpace(WhiteSpace::NoWrap);
345                 style.setTextAlign(TextAlignMode::Start);
346             }
347             // Apparently this is the expected legacy behavior.
348             if (isVertical &amp;&amp; style.height().isAuto())
349                 style.setHeight(Length(200, Fixed));
350         }
351     }
352 
353     if (doesNotInheritTextDecoration(style, m_element))
354         style.setTextDecorationsInEffect(style.textDecoration());
355     else
356         style.addToTextDecorationsInEffect(style.textDecoration());
357 
358     // If either overflow value is not visible, change to auto.
359     if (style.overflowX() == Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Visible) {
360         // FIXME: Once we implement pagination controls, overflow-x should default to hidden
361         // if overflow-y is set to -webkit-paged-x or -webkit-page-y. For now, we&#39;ll let it
362         // default to auto so we can at least scroll through the pages.
363         style.setOverflowX(Overflow::Auto);
364     } else if (style.overflowY() == Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Visible)
365         style.setOverflowY(Overflow::Auto);
366 
367     // Call setStylesForPaginationMode() if a pagination mode is set for any non-root elements. If these
368     // styles are specified on a root element, then they will be incorporated in
369     // Style::createForm_document.
370     if ((style.overflowY() == Overflow::PagedX || style.overflowY() == Overflow::PagedY) &amp;&amp; !(m_element &amp;&amp; (m_element-&gt;hasTagName(htmlTag) || m_element-&gt;hasTagName(bodyTag))))
371         style.setColumnStylesFromPaginationMode(WebCore::paginationModeForRenderStyle(style));
372 
373     // Table rows, sections and the table itself will support overflow:hidden and will ignore scroll/auto.
374     // FIXME: Eventually table sections will support auto and scroll.
375     if (style.display() == DisplayType::Table || style.display() == DisplayType::InlineTable
376         || style.display() == DisplayType::TableRowGroup || style.display() == DisplayType::TableRow) {
377         if (style.overflowX() != Overflow::Visible &amp;&amp; style.overflowX() != Overflow::Hidden)
378             style.setOverflowX(Overflow::Visible);
379         if (style.overflowY() != Overflow::Visible &amp;&amp; style.overflowY() != Overflow::Hidden)
380             style.setOverflowY(Overflow::Visible);
381     }
382 
383     // Menulists should have visible overflow
384     if (style.appearance() == MenulistPart) {
385         style.setOverflowX(Overflow::Visible);
386         style.setOverflowY(Overflow::Visible);
387     }
388 
389 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
390     // Touch overflow scrolling creates a stacking context.
391     if (style.hasAutoUsedZIndex() &amp;&amp; style.useTouchOverflowScrolling() &amp;&amp; (isScrollableOverflow(style.overflowX()) || isScrollableOverflow(style.overflowY())))
392         style.setUsedZIndex(0);
393 #endif
394 
395     // Cull out any useless layers and also repeat patterns into additional layers.
396     style.adjustBackgroundLayers();
397     style.adjustMaskLayers();
398 
399     // Do the same for animations and transitions.
400     style.adjustAnimations();
401     style.adjustTransitions();
402 
403     // Important: Intrinsic margins get added to controls before the theme has adjusted the style, since the theme will
404     // alter fonts and heights/widths.
405     if (is&lt;HTMLFormControlElement&gt;(m_element) &amp;&amp; style.computedFontPixelSize() &gt;= 11) {
406         // Don&#39;t apply intrinsic margins to image buttons. The designer knows how big the images are,
407         // so we have to treat all image buttons as though they were explicitly sized.
408         if (!is&lt;HTMLInputElement&gt;(*m_element) || !downcast&lt;HTMLInputElement&gt;(*m_element).isImageButton())
409             addIntrinsicMargins(style);
410     }
411 
412     // Let the theme also have a crack at adjusting the style.
413     if (style.hasAppearance())
414         RenderTheme::singleton().adjustStyle(style, m_element, userAgentAppearanceStyle);
415 
416     // If we have first-letter pseudo style, do not share this style.
417     if (style.hasPseudoStyle(PseudoId::FirstLetter))
418         style.setUnique();
419 
420     // FIXME: when dropping the -webkit prefix on transform-style, we should also have opacity &lt; 1 cause flattening.
421     if (style.preserves3D() &amp;&amp; (style.overflowX() != Overflow::Visible
422         || style.overflowY() != Overflow::Visible
423         || style.hasClip()
424         || style.clipPath()
425         || style.hasFilter()
426 #if ENABLE(FILTERS_LEVEL_2)
427         || style.hasBackdropFilter()
428 #endif
429         || style.hasBlendMode()))
430         style.setTransformStyle3D(TransformStyle3D::Flat);
431 
432     if (is&lt;SVGElement&gt;(m_element))
433         adjustSVGElementStyle(style, downcast&lt;SVGElement&gt;(*m_element));
434 
435     // If the inherited value of justify-items includes the &#39;legacy&#39; keyword (plus &#39;left&#39;, &#39;right&#39; or
436     // &#39;center&#39;), &#39;legacy&#39; computes to the the inherited value. Otherwise, &#39;auto&#39; computes to &#39;normal&#39;.
437     if (m_parentBoxStyle.justifyItems().positionType() == ItemPositionType::Legacy &amp;&amp; style.justifyItems().position() == ItemPosition::Legacy)
438         style.setJustifyItems(m_parentBoxStyle.justifyItems());
439 
440 #if ENABLE(POINTER_EVENTS)
441     style.setEffectiveTouchActions(computeEffectiveTouchActions(style, m_parentStyle.effectiveTouchActions()));
442 #endif
443 
444 #if ENABLE(TEXT_AUTOSIZING)
445     if (m_element)
446         adjustForTextAutosizing(style, *m_element);
447 #endif
448 
449     adjustForSiteSpecificQuirks(style);
450 }
451 
452 static bool hasEffectiveDisplayNoneForDisplayContents(const Element&amp; element)
453 {
454     // https://drafts.csswg.org/css-display-3/#unbox-html
455     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {
456         static const HTMLQualifiedName* const tagList[] = {
457             &amp;brTag.get(),
458             &amp;wbrTag.get(),
459             &amp;meterTag.get(),
460             &amp;appletTag.get(),
461             &amp;progressTag.get(),
462             &amp;canvasTag.get(),
463             &amp;embedTag.get(),
464             &amp;objectTag.get(),
465             &amp;audioTag.get(),
466             &amp;iframeTag.get(),
467             &amp;imgTag.get(),
468             &amp;videoTag.get(),
469             &amp;frameTag.get(),
470             &amp;framesetTag.get(),
471             &amp;inputTag.get(),
472             &amp;textareaTag.get(),
473             &amp;selectTag.get(),
474         };
475         HashSet&lt;AtomString&gt; set;
476         for (auto&amp; name : tagList)
477             set.add(name-&gt;localName());
478         return set;
479     }();
480 
481     // https://drafts.csswg.org/css-display-3/#unbox-svg
482     // FIXME: &lt;g&gt;, &lt;use&gt; and &lt;tspan&gt; have special (?) behavior for display:contents in the current draft spec.
483     if (is&lt;SVGElement&gt;(element))
484         return true;
485 #if ENABLE(MATHML)
486     // Not sure MathML code can handle it.
487     if (is&lt;MathMLElement&gt;(element))
488         return true;
489 #endif // ENABLE(MATHML)
490     if (!is&lt;HTMLElement&gt;(element))
491         return false;
492     return tagNames.get().contains(element.localName());
493 }
494 
495 void Adjuster::adjustDisplayContentsStyle(RenderStyle&amp; style) const
496 {
497     if (!m_element) {
498         if (style.styleType() != PseudoId::Before &amp;&amp; style.styleType() != PseudoId::After)
499             style.setDisplay(DisplayType::None);
500         return;
501     }
502 
503     if (m_document.documentElement() == m_element) {
504         style.setDisplay(DisplayType::Block);
505         return;
506     }
507 
508     if (hasEffectiveDisplayNoneForDisplayContents(*m_element))
509         style.setDisplay(DisplayType::None);
510 }
511 
512 void Adjuster::adjustSVGElementStyle(RenderStyle&amp; style, const SVGElement&amp; svgElement)
513 {
514     // Only the root &lt;svg&gt; element in an SVG document fragment tree honors css position
515     auto isPositioningAllowed = svgElement.hasTagName(SVGNames::svgTag) &amp;&amp; svgElement.parentNode() &amp;&amp; !svgElement.parentNode()-&gt;isSVGElement() &amp;&amp; !svgElement.correspondingElement();
516     if (!isPositioningAllowed)
517         style.setPosition(RenderStyle::initialPosition());
518 
519     // RenderSVGRoot handles zooming for the whole SVG subtree, so foreignObject content should
520     // not be scaled again.
521     if (svgElement.hasTagName(SVGNames::foreignObjectTag))
522         style.setEffectiveZoom(RenderStyle::initialZoom());
523 
524     // SVG text layout code expects us to be a block-level style element.
525     if ((svgElement.hasTagName(SVGNames::foreignObjectTag) || svgElement.hasTagName(SVGNames::textTag)) &amp;&amp; style.isDisplayInlineType())
526         style.setDisplay(DisplayType::Block);
527 }
528 
529 void Adjuster::adjustAnimatedStyle(RenderStyle&amp; style, const RenderStyle* parentBoxStyle, OptionSet&lt;AnimationImpact&gt; impact)
530 {
531     // Set an explicit used z-index in two cases:
532     // 1. When the element respects z-index, and the style has an explicit z-index set (for example, the animation
533     //    itself may animate z-index).
534     // 2. When we want the stacking context side-effets of explicit z-index, via forceStackingContext.
535     // It&#39;s important to not clobber an existing used z-index, since an earlier animation may have set it, but we
536     // may still need to update the used z-index value from the specified value.
537     bool elementRespectsZIndex = style.position() != PositionType::Static || (parentBoxStyle &amp;&amp; parentBoxStyle-&gt;isDisplayFlexibleOrGridBox());
538 
539     if (elementRespectsZIndex &amp;&amp; !style.hasAutoSpecifiedZIndex())
540         style.setUsedZIndex(style.specifiedZIndex());
541     else if (impact.contains(AnimationImpact::ForcesStackingContext))
542         style.setUsedZIndex(0);
543 }
544 
545 void Adjuster::adjustForSiteSpecificQuirks(RenderStyle&amp; style) const
546 {
547     if (m_document.quirks().needsGMailOverflowScrollQuirk() &amp;&amp; m_element) {
548         // This turns sidebar scrollable without mouse move event.
549         static NeverDestroyed&lt;AtomString&gt; roleValue(&quot;navigation&quot;, AtomString::ConstructFromLiteral);
550         if (style.overflowY() == Overflow::Hidden &amp;&amp; m_element-&gt;attributeWithoutSynchronization(roleAttr) == roleValue)
551             style.setOverflowY(Overflow::Auto);
552     }
553     if (m_document.quirks().needsYouTubeOverflowScrollQuirk() &amp;&amp; m_element) {
554         // This turns sidebar scrollable without hover.
555         static NeverDestroyed&lt;AtomString&gt; idValue(&quot;guide-inner-content&quot;, AtomString::ConstructFromLiteral);
556         if (style.overflowY() == Overflow::Hidden &amp;&amp; m_element-&gt;idForStyleResolution() == idValue)
557             style.setOverflowY(Overflow::Auto);
558     }
559 }
560 
561 #if ENABLE(TEXT_AUTOSIZING)
562 static bool hasTextChild(const Element&amp; element)
563 {
564     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling()) {
565         if (is&lt;Text&gt;(child))
566             return true;
567     }
568     return false;
569 }
570 
571 bool Adjuster::adjustForTextAutosizing(RenderStyle&amp; style, const Element&amp; element)
572 {
573     auto&amp; document = element.document();
574     if (!document.settings().textAutosizingEnabled() || !document.settings().textAutosizingUsesIdempotentMode())
575         return false;
576 
577     AutosizeStatus::updateStatus(style);
578     if (style.textSizeAdjust().isNone())
579         return false;
580 
581     float initialScale = document.page() ? document.page()-&gt;initialScale() : 1;
582     auto adjustLineHeightIfNeeded = [&amp;](auto computedFontSize) {
583         auto lineHeight = style.specifiedLineHeight();
584         constexpr static unsigned eligibleFontSize = 12;
585         if (computedFontSize * initialScale &gt;= eligibleFontSize)
586             return;
587 
588         constexpr static float boostFactor = 1.25;
589         auto minimumLineHeight = boostFactor * computedFontSize;
590         if (!lineHeight.isFixed() || lineHeight.value() &gt;= minimumLineHeight)
591             return;
592 
593         if (AutosizeStatus::probablyContainsASmallFixedNumberOfLines(style))
594             return;
595 
596         style.setLineHeight({ minimumLineHeight, Fixed });
597     };
598 
599     auto fontDescription = style.fontDescription();
600     auto initialComputedFontSize = fontDescription.computedSize();
601     auto specifiedFontSize = fontDescription.specifiedSize();
602     bool isCandidate = style.isIdempotentTextAutosizingCandidate();
603     if (!isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, specifiedFontSize))
604         return false;
605 
606     auto adjustedFontSize = AutosizeStatus::idempotentTextSize(fontDescription.specifiedSize(), initialScale);
607     if (isCandidate &amp;&amp; WTF::areEssentiallyEqual(initialComputedFontSize, adjustedFontSize))
608         return false;
609 
610     if (!hasTextChild(element))
611         return false;
612 
613     fontDescription.setComputedSize(isCandidate ? adjustedFontSize : specifiedFontSize);
614     style.setFontDescription(WTFMove(fontDescription));
615     style.fontCascade().update(&amp;document.fontSelector());
616 
617     // FIXME: We should restore computed line height to its original value in the case where the element is not
618     // an idempotent text autosizing candidate; otherwise, if an element that is a text autosizing candidate contains
619     // children which are not autosized, the non-autosized content will end up with a boosted line height.
620     if (isCandidate)
621         adjustLineHeightIfNeeded(adjustedFontSize);
622 
623     return true;
624 }
625 #endif
626 
627 }
628 }
    </pre>
  </body>
</html>