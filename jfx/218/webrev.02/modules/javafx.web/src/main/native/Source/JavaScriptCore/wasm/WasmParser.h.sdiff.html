<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOperations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmPlan.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;B3Compilation.h&quot;
 31 #include &quot;B3Procedure.h&quot;

 32 #include &quot;WasmFormat.h&quot;
 33 #include &quot;WasmLimits.h&quot;
 34 #include &quot;WasmModuleInformation.h&quot;
 35 #include &quot;WasmOps.h&quot;
 36 #include &quot;WasmSections.h&quot;
 37 #include &lt;type_traits&gt;
 38 #include &lt;wtf/Expected.h&gt;
 39 #include &lt;wtf/LEBDecoder.h&gt;
 40 #include &lt;wtf/StdLibExtras.h&gt;

 41 #include &lt;wtf/text/WTFString.h&gt;
 42 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 43 
 44 namespace JSC { namespace Wasm {
 45 
 46 namespace FailureHelper {
 47 // FIXME We should move this to makeString. It&#39;s in its own namespace to enable C++ Argument Dependent Lookup à la std::swap: user code can deblare its own &quot;boxFailure&quot; and the fail() helper will find it.
<span class="line-modified"> 48 static inline auto makeString(const char *failure) { return failure; }</span>
<span class="line-modified"> 49 template &lt;typename Int, typename = typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt;</span>
<span class="line-removed"> 50 static inline auto makeString(Int failure) { return String::number(failure); }</span>
 51 }
 52 
 53 template&lt;typename SuccessType&gt;
 54 class Parser {
 55 public:
 56     typedef String ErrorType;
 57     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 58     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 59     typedef Expected&lt;SuccessType, ErrorType&gt; Result;
 60 
 61     const uint8_t* source() const { return m_source; }
 62     size_t length() const { return m_sourceLength; }
 63     size_t offset() const { return m_offset; }
 64 
 65 protected:
 66     Parser(const uint8_t*, size_t);
 67 
 68     bool WARN_UNUSED_RETURN consumeCharacter(char);
 69     bool WARN_UNUSED_RETURN consumeString(const char*);
 70     bool WARN_UNUSED_RETURN consumeUTF8String(Name&amp;, size_t);
 71 
 72     bool WARN_UNUSED_RETURN parseVarUInt1(uint8_t&amp;);
 73     bool WARN_UNUSED_RETURN parseInt7(int8_t&amp;);

 74     bool WARN_UNUSED_RETURN parseUInt7(uint8_t&amp;);
 75     bool WARN_UNUSED_RETURN parseUInt8(uint8_t&amp;);
 76     bool WARN_UNUSED_RETURN parseUInt32(uint32_t&amp;);
 77     bool WARN_UNUSED_RETURN parseUInt64(uint64_t&amp;);
 78     bool WARN_UNUSED_RETURN parseVarUInt32(uint32_t&amp;);
 79     bool WARN_UNUSED_RETURN parseVarUInt64(uint64_t&amp;);
 80 
 81     bool WARN_UNUSED_RETURN parseVarInt32(int32_t&amp;);
 82     bool WARN_UNUSED_RETURN parseVarInt64(int64_t&amp;);
 83 
<span class="line-modified"> 84     bool WARN_UNUSED_RETURN parseResultType(Type&amp;);</span>
 85     bool WARN_UNUSED_RETURN parseValueType(Type&amp;);
 86     bool WARN_UNUSED_RETURN parseExternalKind(ExternalKind&amp;);
 87 
 88     size_t m_offset = 0;
 89 
 90     template &lt;typename ...Args&gt;
 91     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 92     {
 93         using namespace FailureHelper; // See ADL comment in namespace above.
 94         return UnexpectedResult(makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...));
 95     }
 96 #define WASM_PARSER_FAIL_IF(condition, ...) do { \
 97     if (UNLIKELY(condition))                     \
 98         return fail(__VA_ARGS__);                \
 99     } while (0)
100 
101 #define WASM_FAIL_IF_HELPER_FAILS(helper) do {                      \
102         auto helperResult = helper;                                 \
103         if (UNLIKELY(!helperResult))                                \
104             return makeUnexpected(WTFMove(helperResult.error()));   \
105     } while (0)
106 
107 private:
108     const uint8_t* m_source;
109     size_t m_sourceLength;


110 };
111 
112 template&lt;typename SuccessType&gt;
113 ALWAYS_INLINE Parser&lt;SuccessType&gt;::Parser(const uint8_t* sourceBuffer, size_t sourceLength)
114     : m_source(sourceBuffer)
115     , m_sourceLength(sourceLength)

116 {
117 }
118 
119 template&lt;typename SuccessType&gt;
120 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeCharacter(char c)
121 {
122     if (m_offset &gt;= length())
123         return false;
124     if (c == source()[m_offset]) {
125         m_offset++;
126         return true;
127     }
128     return false;
129 }
130 
131 template&lt;typename SuccessType&gt;
132 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeString(const char* str)
133 {
134     unsigned start = m_offset;
135     if (m_offset &gt;= length())
</pre>
<hr />
<pre>
218 
219 template&lt;typename SuccessType&gt;
220 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt8(uint8_t&amp; result)
221 {
222     if (m_offset &gt;= length())
223         return false;
224     result = source()[m_offset++];
225     return true;
226 }
227 
228 template&lt;typename SuccessType&gt;
229 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseInt7(int8_t&amp; result)
230 {
231     if (m_offset &gt;= length())
232         return false;
233     uint8_t v = source()[m_offset++];
234     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;
235     return (v &amp; 0x80) == 0;
236 }
237 










238 template&lt;typename SuccessType&gt;
239 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt7(uint8_t&amp; result)
240 {
241     if (m_offset &gt;= length())
242         return false;
243     result = source()[m_offset++];
244     return result &lt; 0x80;
245 }
246 
247 template&lt;typename SuccessType&gt;
248 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarUInt1(uint8_t&amp; result)
249 {
250     uint32_t temp;
251     if (!parseVarUInt32(temp))
252         return false;
253     if (temp &gt; 1)
254         return false;
255     result = static_cast&lt;uint8_t&gt;(temp);
256     return true;
257 }
258 
259 template&lt;typename SuccessType&gt;
<span class="line-modified">260 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseResultType(Type&amp; result)</span>
261 {
262     int8_t value;
<span class="line-modified">263     if (!parseInt7(value))</span>
<span class="line-modified">264         return false;</span>
<span class="line-modified">265     if (!isValidType(value))</span>
<span class="line-modified">266         return false;</span>
<span class="line-modified">267     result = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified">268     return true;</span>











269 }
270 
271 template&lt;typename SuccessType&gt;
272 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseValueType(Type&amp; result)
273 {
<span class="line-modified">274     return parseResultType(result) &amp;&amp; isValueType(result);</span>






275 }
276 
277 template&lt;typename SuccessType&gt;
278 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseExternalKind(ExternalKind&amp; result)
279 {
280     uint8_t value;
281     if (!parseUInt7(value))
282         return false;
283     if (!isValidExternalKind(value))
284         return false;
285     result = static_cast&lt;ExternalKind&gt;(value);
286     return true;
287 }
288 
289 ALWAYS_INLINE I32InitExpr makeI32InitExpr(uint8_t opcode, uint32_t bits)
290 {
291     RELEASE_ASSERT(opcode == I32Const || opcode == GetGlobal);
292     if (opcode == I32Const)
293         return I32InitExpr::constValue(bits);
294     return I32InitExpr::globalImport(bits);
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;B3Compilation.h&quot;
 31 #include &quot;B3Procedure.h&quot;
<span class="line-added"> 32 #include &quot;VirtualRegister.h&quot;</span>
 33 #include &quot;WasmFormat.h&quot;
 34 #include &quot;WasmLimits.h&quot;
 35 #include &quot;WasmModuleInformation.h&quot;
 36 #include &quot;WasmOps.h&quot;
 37 #include &quot;WasmSections.h&quot;
 38 #include &lt;type_traits&gt;
 39 #include &lt;wtf/Expected.h&gt;
 40 #include &lt;wtf/LEBDecoder.h&gt;
 41 #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-added"> 42 #include &lt;wtf/StringPrintStream.h&gt;</span>
 43 #include &lt;wtf/text/WTFString.h&gt;
 44 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 45 
 46 namespace JSC { namespace Wasm {
 47 
 48 namespace FailureHelper {
 49 // FIXME We should move this to makeString. It&#39;s in its own namespace to enable C++ Argument Dependent Lookup à la std::swap: user code can deblare its own &quot;boxFailure&quot; and the fail() helper will find it.
<span class="line-modified"> 50 template&lt;typename T&gt;</span>
<span class="line-modified"> 51 inline String makeString(const T&amp; failure) { return WTF::toString(failure); }</span>

 52 }
 53 
 54 template&lt;typename SuccessType&gt;
 55 class Parser {
 56 public:
 57     typedef String ErrorType;
 58     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 59     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 60     typedef Expected&lt;SuccessType, ErrorType&gt; Result;
 61 
 62     const uint8_t* source() const { return m_source; }
 63     size_t length() const { return m_sourceLength; }
 64     size_t offset() const { return m_offset; }
 65 
 66 protected:
 67     Parser(const uint8_t*, size_t);
 68 
 69     bool WARN_UNUSED_RETURN consumeCharacter(char);
 70     bool WARN_UNUSED_RETURN consumeString(const char*);
 71     bool WARN_UNUSED_RETURN consumeUTF8String(Name&amp;, size_t);
 72 
 73     bool WARN_UNUSED_RETURN parseVarUInt1(uint8_t&amp;);
 74     bool WARN_UNUSED_RETURN parseInt7(int8_t&amp;);
<span class="line-added"> 75     bool WARN_UNUSED_RETURN peekInt7(int8_t&amp;);</span>
 76     bool WARN_UNUSED_RETURN parseUInt7(uint8_t&amp;);
 77     bool WARN_UNUSED_RETURN parseUInt8(uint8_t&amp;);
 78     bool WARN_UNUSED_RETURN parseUInt32(uint32_t&amp;);
 79     bool WARN_UNUSED_RETURN parseUInt64(uint64_t&amp;);
 80     bool WARN_UNUSED_RETURN parseVarUInt32(uint32_t&amp;);
 81     bool WARN_UNUSED_RETURN parseVarUInt64(uint64_t&amp;);
 82 
 83     bool WARN_UNUSED_RETURN parseVarInt32(int32_t&amp;);
 84     bool WARN_UNUSED_RETURN parseVarInt64(int64_t&amp;);
 85 
<span class="line-modified"> 86     PartialResult WARN_UNUSED_RETURN parseBlockSignature(const ModuleInformation&amp;, BlockSignature&amp;);</span>
 87     bool WARN_UNUSED_RETURN parseValueType(Type&amp;);
 88     bool WARN_UNUSED_RETURN parseExternalKind(ExternalKind&amp;);
 89 
 90     size_t m_offset = 0;
 91 
 92     template &lt;typename ...Args&gt;
 93     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 94     {
 95         using namespace FailureHelper; // See ADL comment in namespace above.
 96         return UnexpectedResult(makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...));
 97     }
 98 #define WASM_PARSER_FAIL_IF(condition, ...) do { \
 99     if (UNLIKELY(condition))                     \
100         return fail(__VA_ARGS__);                \
101     } while (0)
102 
103 #define WASM_FAIL_IF_HELPER_FAILS(helper) do {                      \
104         auto helperResult = helper;                                 \
105         if (UNLIKELY(!helperResult))                                \
106             return makeUnexpected(WTFMove(helperResult.error()));   \
107     } while (0)
108 
109 private:
110     const uint8_t* m_source;
111     size_t m_sourceLength;
<span class="line-added">112     // We keep a local reference to the global table so we don&#39;t have to fetch it to find thunk signatures.</span>
<span class="line-added">113     const SignatureInformation&amp; m_signatureInformation;</span>
114 };
115 
116 template&lt;typename SuccessType&gt;
117 ALWAYS_INLINE Parser&lt;SuccessType&gt;::Parser(const uint8_t* sourceBuffer, size_t sourceLength)
118     : m_source(sourceBuffer)
119     , m_sourceLength(sourceLength)
<span class="line-added">120     , m_signatureInformation(SignatureInformation::singleton())</span>
121 {
122 }
123 
124 template&lt;typename SuccessType&gt;
125 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeCharacter(char c)
126 {
127     if (m_offset &gt;= length())
128         return false;
129     if (c == source()[m_offset]) {
130         m_offset++;
131         return true;
132     }
133     return false;
134 }
135 
136 template&lt;typename SuccessType&gt;
137 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeString(const char* str)
138 {
139     unsigned start = m_offset;
140     if (m_offset &gt;= length())
</pre>
<hr />
<pre>
223 
224 template&lt;typename SuccessType&gt;
225 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt8(uint8_t&amp; result)
226 {
227     if (m_offset &gt;= length())
228         return false;
229     result = source()[m_offset++];
230     return true;
231 }
232 
233 template&lt;typename SuccessType&gt;
234 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseInt7(int8_t&amp; result)
235 {
236     if (m_offset &gt;= length())
237         return false;
238     uint8_t v = source()[m_offset++];
239     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;
240     return (v &amp; 0x80) == 0;
241 }
242 
<span class="line-added">243 template&lt;typename SuccessType&gt;</span>
<span class="line-added">244 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::peekInt7(int8_t&amp; result)</span>
<span class="line-added">245 {</span>
<span class="line-added">246     if (m_offset &gt;= length())</span>
<span class="line-added">247         return false;</span>
<span class="line-added">248     uint8_t v = source()[m_offset];</span>
<span class="line-added">249     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;</span>
<span class="line-added">250     return (v &amp; 0x80) == 0;</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
253 template&lt;typename SuccessType&gt;
254 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt7(uint8_t&amp; result)
255 {
256     if (m_offset &gt;= length())
257         return false;
258     result = source()[m_offset++];
259     return result &lt; 0x80;
260 }
261 
262 template&lt;typename SuccessType&gt;
263 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseVarUInt1(uint8_t&amp; result)
264 {
265     uint32_t temp;
266     if (!parseVarUInt32(temp))
267         return false;
268     if (temp &gt; 1)
269         return false;
270     result = static_cast&lt;uint8_t&gt;(temp);
271     return true;
272 }
273 
274 template&lt;typename SuccessType&gt;
<span class="line-modified">275 ALWAYS_INLINE typename Parser&lt;SuccessType&gt;::PartialResult Parser&lt;SuccessType&gt;::parseBlockSignature(const ModuleInformation&amp; info, BlockSignature&amp; result)</span>
276 {
277     int8_t value;
<span class="line-modified">278     if (peekInt7(value) &amp;&amp; isValidType(value)) {</span>
<span class="line-modified">279         Type type = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified">280         WASM_PARSER_FAIL_IF(!(isValueType(type) || type == Void), &quot;result type of block: &quot;, makeString(type), &quot; is not a value type or Void&quot;);</span>
<span class="line-modified">281         result = m_signatureInformation.thunkFor(type);</span>
<span class="line-modified">282         m_offset++;</span>
<span class="line-modified">283         return { };</span>
<span class="line-added">284     }</span>
<span class="line-added">285 </span>
<span class="line-added">286     WASM_PARSER_FAIL_IF(!Options::useWebAssemblyMultiValues(), &quot;Type table indices for block signatures are not supported yet&quot;);</span>
<span class="line-added">287 </span>
<span class="line-added">288     int64_t index;</span>
<span class="line-added">289     WASM_PARSER_FAIL_IF(!parseVarInt64(index), &quot;Block-like instruction doesn&#39;t return value type but can&#39;t decode type section index&quot;);</span>
<span class="line-added">290     WASM_PARSER_FAIL_IF(index &lt; 0, &quot;Block-like instruction signature index is negative&quot;);</span>
<span class="line-added">291     WASM_PARSER_FAIL_IF(static_cast&lt;size_t&gt;(index) &gt;= info.usedSignatures.size(), &quot;Block-like instruction signature index is out of bounds. Index: &quot;, index, &quot; type index space: &quot;, info.usedSignatures.size());</span>
<span class="line-added">292 </span>
<span class="line-added">293     result = &amp;info.usedSignatures[index].get();</span>
<span class="line-added">294     return { };</span>
295 }
296 
297 template&lt;typename SuccessType&gt;
298 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseValueType(Type&amp; result)
299 {
<span class="line-modified">300     int8_t value;</span>
<span class="line-added">301     if (!parseInt7(value))</span>
<span class="line-added">302         return false;</span>
<span class="line-added">303     if (!isValidType(value) || !isValueType(static_cast&lt;Type&gt;(value)))</span>
<span class="line-added">304         return false;</span>
<span class="line-added">305     result = static_cast&lt;Type&gt;(value);</span>
<span class="line-added">306     return true;</span>
307 }
308 
309 template&lt;typename SuccessType&gt;
310 ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseExternalKind(ExternalKind&amp; result)
311 {
312     uint8_t value;
313     if (!parseUInt7(value))
314         return false;
315     if (!isValidExternalKind(value))
316         return false;
317     result = static_cast&lt;ExternalKind&gt;(value);
318     return true;
319 }
320 
321 ALWAYS_INLINE I32InitExpr makeI32InitExpr(uint8_t opcode, uint32_t bits)
322 {
323     RELEASE_ASSERT(opcode == I32Const || opcode == GetGlobal);
324     if (opcode == I32Const)
325         return I32InitExpr::constValue(bits);
326     return I32InitExpr::globalImport(bits);
</pre>
</td>
</tr>
</table>
<center><a href="WasmOperations.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmPlan.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>