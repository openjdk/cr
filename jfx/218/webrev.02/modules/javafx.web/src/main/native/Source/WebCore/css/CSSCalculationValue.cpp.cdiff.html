<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSCalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSBasicShapes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCalculationValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSCalculationValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
<span class="line-modified">!  * Copyright (C) 2014 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
<span class="line-modified">!  * Copyright (C) 2014, 2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,265 ***</span>
  #include &quot;CSSCalculationValue.h&quot;
  
  #include &quot;CSSParser.h&quot;
  #include &quot;CSSParserTokenRange.h&quot;
  #include &quot;CSSPrimitiveValueMappings.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  static const int maxExpressionDepth = 100;
  
<span class="line-modified">! enum ParseState {</span>
<span class="line-modified">!     OK,</span>
<span class="line-modified">!     TooDeep,</span>
<span class="line-modified">!     NoMoreTokens</span>
<span class="line-modified">! };</span>
  
  namespace WebCore {
  
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp;, const RenderStyle&amp;);
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp;, const RenderStyle&amp;);
  
<span class="line-modified">! static CalculationCategory unitCategory(CSSPrimitiveValue::UnitType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case CSSPrimitiveValue::CSS_NUMBER:</span>
          return CalculationCategory::Number;
<span class="line-modified">!     case CSSPrimitiveValue::CSS_EMS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_EXS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PX:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_CM:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_MM:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_IN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PT:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PC:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_REMS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_CHS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VW:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VH:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VMIN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VMAX:</span>
          return CalculationCategory::Length;
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PERCENTAGE:</span>
          return CalculationCategory::Percent;
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DEG:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_RAD:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_GRAD:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_TURN:</span>
          return CalculationCategory::Angle;
<span class="line-modified">!     case CSSPrimitiveValue::CSS_MS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_S:</span>
          return CalculationCategory::Time;
<span class="line-modified">!     case CSSPrimitiveValue::CSS_HZ:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_KHZ:</span>
          return CalculationCategory::Frequency;
      default:
          return CalculationCategory::Other;
      }
  }
  
<span class="line-modified">! static bool hasDoubleValue(CSSPrimitiveValue::UnitType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case CSSPrimitiveValue::CSS_FR:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_NUMBER:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PERCENTAGE:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_EMS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_EXS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_CHS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_REMS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PX:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_CM:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_MM:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_IN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PT:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_PC:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DEG:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_RAD:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_GRAD:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_TURN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_MS:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_S:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_HZ:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_KHZ:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DIMENSION:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VW:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VH:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VMIN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_VMAX:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DPPX:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DPI:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_DPCM:</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_UNKNOWN:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_STRING:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_FONT_FAMILY:</span>
<span class="line-modified">!     case CSSPrimitiveValue::CSS_URI:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_IDENT:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_ATTR:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_COUNTER:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_RECT:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_RGBCOLOR:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_PAIR:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_UNICODE_RANGE:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_COUNTER_NAME:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_SHAPE:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_QUAD:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_QUIRKY_EMS:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_CALC:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_CALC_PERCENTAGE_WITH_NUMBER:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_CALC_PERCENTAGE_WITH_LENGTH:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_PROPERTY_ID:</span>
<span class="line-removed">-     case CSSPrimitiveValue::CSS_VALUE_ID:</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     return false;</span>
  }
  
<span class="line-modified">! String CSSCalcValue::customCSSText() const</span>
  {
<span class="line-modified">!     auto expression = m_expression-&gt;customCSSText();</span>
<span class="line-modified">!     if (expression[0] == &#39;(&#39;)</span>
<span class="line-modified">!         return makeString(&quot;calc&quot;, expression);</span>
<span class="line-modified">!     return makeString(&quot;calc(&quot;, expression, &#39;)&#39;);</span>
  }
  
<span class="line-modified">! bool CSSCalcValue::equals(const CSSCalcValue&amp; other) const</span>
  {
<span class="line-modified">!     return compareCSSValue(m_expression, other.m_expression);</span>
  }
  
<span class="line-modified">! inline double CSSCalcValue::clampToPermittedRange(double value) const</span>
  {
<span class="line-modified">!     return m_shouldClampToNonNegative &amp;&amp; value &lt; 0 ? 0 : value;</span>
  }
  
<span class="line-modified">! double CSSCalcValue::doubleValue() const</span>
  {
<span class="line-modified">!     return clampToPermittedRange(m_expression-&gt;doubleValue());</span>
  }
  
<span class="line-modified">! double CSSCalcValue::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
  {
<span class="line-modified">!     return clampToPermittedRange(m_expression-&gt;computeLengthPx(conversionData));</span>
  }
  
<span class="line-modified">! class CSSCalcPrimitiveValue final : public CSSCalcExpressionNode {</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static Ref&lt;CSSCalcPrimitiveValue&gt; create(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value, bool isInteger)</span>
      {
<span class="line-modified">!         return adoptRef(*new CSSCalcPrimitiveValue(WTFMove(value), isInteger));</span>
      }
  
<span class="line-modified">!     static RefPtr&lt;CSSCalcPrimitiveValue&gt; create(double value, CSSPrimitiveValue::UnitType type, bool isInteger)</span>
      {
          if (!std::isfinite(value))
              return nullptr;
<span class="line-modified">!         return adoptRef(new CSSCalcPrimitiveValue(CSSPrimitiveValue::create(value, type), isInteger));</span>
      }
  
  private:
      bool isZero() const final
      {
          return !m_value-&gt;doubleValue();
      }
  
<span class="line-modified">!     String customCSSText() const final</span>
      {
<span class="line-removed">-         return m_value-&gt;cssText();</span>
      }
  
<span class="line-modified">!     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         switch (category()) {</span>
<span class="line-modified">!         case CalculationCategory::Number:</span>
<span class="line-modified">!             return makeUnique&lt;CalcExpressionNumber&gt;(m_value-&gt;floatValue());</span>
<span class="line-modified">!         case CalculationCategory::Length:</span>
<span class="line-modified">!             return makeUnique&lt;CalcExpressionLength&gt;(Length(m_value-&gt;computeLength&lt;float&gt;(conversionData), WebCore::Fixed));</span>
<span class="line-modified">!         case CalculationCategory::Percent:</span>
<span class="line-modified">!         case CalculationCategory::PercentLength: {</span>
<span class="line-modified">!             return makeUnique&lt;CalcExpressionLength&gt;(m_value-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion&gt;(conversionData));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // Only types that could be part of a Length expression can be converted</span>
<span class="line-modified">!         // to a CalcExpressionNode. CalculationCategory::PercentNumber makes no sense as a Length.</span>
<span class="line-modified">!         case CalculationCategory::PercentNumber:</span>
<span class="line-modified">!         case CalculationCategory::Angle:</span>
<span class="line-modified">!         case CalculationCategory::Time:</span>
<span class="line-modified">!         case CalculationCategory::Frequency:</span>
<span class="line-modified">!         case CalculationCategory::Other:</span>
<span class="line-modified">!             ASSERT_NOT_REACHED();</span>
<span class="line-modified">!         }</span>
          ASSERT_NOT_REACHED();
<span class="line-modified">!         return nullptr;</span>
      }
  
<span class="line-modified">!     double doubleValue() const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (hasDoubleValue(primitiveType()))</span>
<span class="line-modified">!             return m_value-&gt;doubleValue();</span>
          ASSERT_NOT_REACHED();
<span class="line-removed">-         return 0;</span>
      }
  
<span class="line-modified">!     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         switch (category()) {</span>
<span class="line-modified">!         case CalculationCategory::Length:</span>
<span class="line-modified">!             return m_value-&gt;computeLength&lt;double&gt;(conversionData);</span>
<span class="line-modified">!         case CalculationCategory::Percent:</span>
<span class="line-modified">!         case CalculationCategory::Number:</span>
<span class="line-removed">-             return m_value-&gt;doubleValue();</span>
<span class="line-removed">-         case CalculationCategory::PercentLength:</span>
<span class="line-removed">-         case CalculationCategory::PercentNumber:</span>
<span class="line-removed">-         case CalculationCategory::Angle:</span>
<span class="line-removed">-         case CalculationCategory::Time:</span>
<span class="line-removed">-         case CalculationCategory::Frequency:</span>
<span class="line-removed">-         case CalculationCategory::Other:</span>
<span class="line-removed">-             ASSERT_NOT_REACHED();</span>
<span class="line-removed">-             break;</span>
          }
          ASSERT_NOT_REACHED();
<span class="line-modified">!         return 0;</span>
      }
  
<span class="line-modified">!     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final</span>
      {
<span class="line-modified">!         m_value-&gt;collectDirectComputationalDependencies(values);</span>
      }
  
<span class="line-modified">!     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final</span>
      {
<span class="line-removed">-         m_value-&gt;collectDirectRootComputationalDependencies(values);</span>
      }
  
<span class="line-modified">!     bool equals(const CSSCalcExpressionNode&amp; other) const final</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (type() != other.type())</span>
<span class="line-removed">-             return false;</span>
  
<span class="line-modified">!         return compareCSSValue(m_value, static_cast&lt;const CSSCalcPrimitiveValue&amp;&gt;(other).m_value);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     Type type() const final { return CssCalcPrimitiveValue; }</span>
<span class="line-modified">!     CSSPrimitiveValue::UnitType primitiveType() const final</span>
      {
<span class="line-modified">!         return CSSPrimitiveValue::UnitType(m_value-&gt;primitiveType());</span>
      }
  
  private:
<span class="line-modified">!     explicit CSSCalcPrimitiveValue(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value, bool isInteger)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(unitCategory((CSSPrimitiveValue::UnitType)value-&gt;primitiveType()), isInteger)</span>
<span class="line-modified">!         , m_value(WTFMove(value))</span>
      {
      }
  
<span class="line-modified">!     Ref&lt;CSSPrimitiveValue&gt; m_value;</span>
  };
  
  static const CalculationCategory addSubtractResult[static_cast&lt;unsigned&gt;(CalculationCategory::Angle)][static_cast&lt;unsigned&gt;(CalculationCategory::Angle)] = {
  //    CalculationCategory::Number         CalculationCategory::Length         CalculationCategory::Percent        CalculationCategory::PercentNumber  CalculationCategory::PercentLength
      { CalculationCategory::Number,        CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::Number
      { CalculationCategory::Other,         CalculationCategory::Length,        CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::Length
      { CalculationCategory::PercentNumber, CalculationCategory::PercentLength, CalculationCategory::Percent,       CalculationCategory::PercentNumber, CalculationCategory::PercentLength }, // CalculationCategory::Percent
<span class="line-new-header">--- 33,576 ---</span>
  #include &quot;CSSCalculationValue.h&quot;
  
  #include &quot;CSSParser.h&quot;
  #include &quot;CSSParserTokenRange.h&quot;
  #include &quot;CSSPrimitiveValueMappings.h&quot;
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;StyleResolver.h&quot;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-added">+ #include &lt;wtf/text/TextStream.h&gt;</span>
  
  static const int maxExpressionDepth = 100;
  
<span class="line-modified">! namespace WebCore {</span>
<span class="line-modified">! class CSSCalcPrimitiveValueNode;</span>
<span class="line-modified">! class CSSCalcOperationNode;</span>
<span class="line-modified">! class CSSCalcNegateNode;</span>
<span class="line-modified">! class CSSCalcInvertNode;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcPrimitiveValueNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcPrimitiveValue)</span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcOperationNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcOperation)</span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcNegateNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcNegate)</span>
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcInvertNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcInvert)</span>
  
  namespace WebCore {
  
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp;, const RenderStyle&amp;);
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp;, const RenderStyle&amp;);
  
<span class="line-modified">! static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     node.dump(ts);</span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static CalculationCategory calcUnitCategory(CSSUnitType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case CSSUnitType::CSS_NUMBER:</span>
          return CalculationCategory::Number;
<span class="line-modified">!     case CSSUnitType::CSS_EMS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_EXS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_PX:</span>
<span class="line-modified">!     case CSSUnitType::CSS_CM:</span>
<span class="line-modified">!     case CSSUnitType::CSS_MM:</span>
<span class="line-modified">!     case CSSUnitType::CSS_IN:</span>
<span class="line-modified">!     case CSSUnitType::CSS_PT:</span>
<span class="line-modified">!     case CSSUnitType::CSS_PC:</span>
<span class="line-modified">!     case CSSUnitType::CSS_Q:</span>
<span class="line-modified">!     case CSSUnitType::CSS_REMS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_CHS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VW:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VH:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VMIN:</span>
<span class="line-added">+     case CSSUnitType::CSS_VMAX:</span>
          return CalculationCategory::Length;
<span class="line-modified">!     case CSSUnitType::CSS_PERCENTAGE:</span>
          return CalculationCategory::Percent;
<span class="line-modified">!     case CSSUnitType::CSS_DEG:</span>
<span class="line-modified">!     case CSSUnitType::CSS_RAD:</span>
<span class="line-modified">!     case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified">!     case CSSUnitType::CSS_TURN:</span>
          return CalculationCategory::Angle;
<span class="line-modified">!     case CSSUnitType::CSS_MS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_S:</span>
          return CalculationCategory::Time;
<span class="line-modified">!     case CSSUnitType::CSS_HZ:</span>
<span class="line-modified">!     case CSSUnitType::CSS_KHZ:</span>
          return CalculationCategory::Frequency;
      default:
          return CalculationCategory::Other;
      }
  }
  
<span class="line-modified">! static CalculationCategory calculationCategoryForCombination(CSSUnitType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case CSSUnitType::CSS_NUMBER:</span>
<span class="line-modified">!         return CalculationCategory::Number;</span>
<span class="line-modified">!     case CSSUnitType::CSS_PX:</span>
<span class="line-modified">!     case CSSUnitType::CSS_CM:</span>
<span class="line-modified">!     case CSSUnitType::CSS_MM:</span>
<span class="line-modified">!     case CSSUnitType::CSS_IN:</span>
<span class="line-modified">!     case CSSUnitType::CSS_PT:</span>
<span class="line-modified">!     case CSSUnitType::CSS_PC:</span>
<span class="line-modified">!     case CSSUnitType::CSS_Q:</span>
<span class="line-modified">!         return CalculationCategory::Length;</span>
<span class="line-modified">!     case CSSUnitType::CSS_PERCENTAGE:</span>
<span class="line-modified">!         return CalculationCategory::Percent;</span>
<span class="line-modified">!     case CSSUnitType::CSS_DEG:</span>
<span class="line-modified">!     case CSSUnitType::CSS_RAD:</span>
<span class="line-modified">!     case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified">!     case CSSUnitType::CSS_TURN:</span>
<span class="line-modified">!         return CalculationCategory::Angle;</span>
<span class="line-modified">!     case CSSUnitType::CSS_MS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_S:</span>
<span class="line-modified">!         return CalculationCategory::Time;</span>
<span class="line-modified">!     case CSSUnitType::CSS_HZ:</span>
<span class="line-modified">!     case CSSUnitType::CSS_KHZ:</span>
<span class="line-modified">!         return CalculationCategory::Frequency;</span>
<span class="line-modified">!     case CSSUnitType::CSS_EMS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_EXS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_REMS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_CHS:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VW:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VH:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VMIN:</span>
<span class="line-modified">!     case CSSUnitType::CSS_VMAX:</span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!         return CalculationCategory::Other;</span>
<span class="line-modified">!     }</span>
  }
  
<span class="line-modified">! static CSSUnitType canonicalUnitTypeForCalculationCategory(CalculationCategory category)</span>
  {
<span class="line-modified">!     switch (category) {</span>
<span class="line-modified">!     case CalculationCategory::Number: return CSSUnitType::CSS_NUMBER;</span>
<span class="line-modified">!     case CalculationCategory::Length: return CSSUnitType::CSS_PX;</span>
<span class="line-modified">!     case CalculationCategory::Percent: return CSSUnitType::CSS_PERCENTAGE;</span>
<span class="line-added">+     case CalculationCategory::Angle: return CSSUnitType::CSS_DEG;</span>
<span class="line-added">+     case CalculationCategory::Time: return CSSUnitType::CSS_MS;</span>
<span class="line-added">+     case CalculationCategory::Frequency: return CSSUnitType::CSS_HZ;</span>
<span class="line-added">+     case CalculationCategory::Other:</span>
<span class="line-added">+     case CalculationCategory::PercentNumber:</span>
<span class="line-added">+     case CalculationCategory::PercentLength:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return CSSUnitType::CSS_UNKNOWN;</span>
  }
  
<span class="line-modified">! static bool hasDoubleValue(CSSUnitType type)</span>
  {
<span class="line-modified">!     switch (type) {</span>
<span class="line-added">+     case CSSUnitType::CSS_NUMBER:</span>
<span class="line-added">+     case CSSUnitType::CSS_PERCENTAGE:</span>
<span class="line-added">+     case CSSUnitType::CSS_EMS:</span>
<span class="line-added">+     case CSSUnitType::CSS_EXS:</span>
<span class="line-added">+     case CSSUnitType::CSS_CHS:</span>
<span class="line-added">+     case CSSUnitType::CSS_REMS:</span>
<span class="line-added">+     case CSSUnitType::CSS_PX:</span>
<span class="line-added">+     case CSSUnitType::CSS_CM:</span>
<span class="line-added">+     case CSSUnitType::CSS_MM:</span>
<span class="line-added">+     case CSSUnitType::CSS_IN:</span>
<span class="line-added">+     case CSSUnitType::CSS_PT:</span>
<span class="line-added">+     case CSSUnitType::CSS_PC:</span>
<span class="line-added">+     case CSSUnitType::CSS_DEG:</span>
<span class="line-added">+     case CSSUnitType::CSS_RAD:</span>
<span class="line-added">+     case CSSUnitType::CSS_GRAD:</span>
<span class="line-added">+     case CSSUnitType::CSS_TURN:</span>
<span class="line-added">+     case CSSUnitType::CSS_MS:</span>
<span class="line-added">+     case CSSUnitType::CSS_S:</span>
<span class="line-added">+     case CSSUnitType::CSS_HZ:</span>
<span class="line-added">+     case CSSUnitType::CSS_KHZ:</span>
<span class="line-added">+     case CSSUnitType::CSS_DIMENSION:</span>
<span class="line-added">+     case CSSUnitType::CSS_VW:</span>
<span class="line-added">+     case CSSUnitType::CSS_VH:</span>
<span class="line-added">+     case CSSUnitType::CSS_VMIN:</span>
<span class="line-added">+     case CSSUnitType::CSS_VMAX:</span>
<span class="line-added">+     case CSSUnitType::CSS_DPPX:</span>
<span class="line-added">+     case CSSUnitType::CSS_DPI:</span>
<span class="line-added">+     case CSSUnitType::CSS_DPCM:</span>
<span class="line-added">+     case CSSUnitType::CSS_FR:</span>
<span class="line-added">+     case CSSUnitType::CSS_Q:</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     case CSSUnitType::CSS_UNKNOWN:</span>
<span class="line-added">+     case CSSUnitType::CSS_STRING:</span>
<span class="line-added">+     case CSSUnitType::CSS_FONT_FAMILY:</span>
<span class="line-added">+     case CSSUnitType::CSS_URI:</span>
<span class="line-added">+     case CSSUnitType::CSS_IDENT:</span>
<span class="line-added">+     case CSSUnitType::CSS_ATTR:</span>
<span class="line-added">+     case CSSUnitType::CSS_COUNTER:</span>
<span class="line-added">+     case CSSUnitType::CSS_RECT:</span>
<span class="line-added">+     case CSSUnitType::CSS_RGBCOLOR:</span>
<span class="line-added">+     case CSSUnitType::CSS_PAIR:</span>
<span class="line-added">+     case CSSUnitType::CSS_UNICODE_RANGE:</span>
<span class="line-added">+     case CSSUnitType::CSS_COUNTER_NAME:</span>
<span class="line-added">+     case CSSUnitType::CSS_SHAPE:</span>
<span class="line-added">+     case CSSUnitType::CSS_QUAD:</span>
<span class="line-added">+     case CSSUnitType::CSS_QUIRKY_EMS:</span>
<span class="line-added">+     case CSSUnitType::CSS_CALC:</span>
<span class="line-added">+     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_NUMBER:</span>
<span class="line-added">+     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_LENGTH:</span>
<span class="line-added">+     case CSSUnitType::CSS_PROPERTY_ID:</span>
<span class="line-added">+     case CSSUnitType::CSS_VALUE_ID:</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return false;</span>
  }
  
<span class="line-modified">! static CSSValueID functionFromOperator(CalcOperator op)</span>
  {
<span class="line-modified">!     switch (op) {</span>
<span class="line-added">+     case CalcOperator::Add:</span>
<span class="line-added">+     case CalcOperator::Subtract:</span>
<span class="line-added">+     case CalcOperator::Multiply:</span>
<span class="line-added">+     case CalcOperator::Divide:</span>
<span class="line-added">+         return CSSValueCalc;</span>
<span class="line-added">+     case CalcOperator::Min:</span>
<span class="line-added">+         return CSSValueMin;</span>
<span class="line-added">+     case CalcOperator::Max:</span>
<span class="line-added">+         return CSSValueMax;</span>
<span class="line-added">+     case CalcOperator::Clamp:</span>
<span class="line-added">+         return CSSValueClamp;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return CSSValueCalc;</span>
  }
  
<span class="line-modified">! #if !LOG_DISABLED</span>
<span class="line-added">+ static String prettyPrintNode(const CSSCalcExpressionNode&amp; node)</span>
  {
<span class="line-modified">!     TextStream multilineStream;</span>
<span class="line-added">+     multilineStream &lt;&lt; node;</span>
<span class="line-added">+     return multilineStream.release();</span>
  }
  
<span class="line-modified">! static String prettyPrintNodes(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes)</span>
  {
<span class="line-modified">!     TextStream multilineStream;</span>
<span class="line-added">+     multilineStream &lt;&lt; nodes;</span>
<span class="line-added">+     return multilineStream.release();</span>
  }
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! class CSSCalcPrimitiveValueNode final : public CSSCalcExpressionNode {</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static Ref&lt;CSSCalcPrimitiveValueNode&gt; create(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)</span>
      {
<span class="line-modified">!         return adoptRef(*new CSSCalcPrimitiveValueNode(WTFMove(value)));</span>
      }
  
<span class="line-modified">!     static RefPtr&lt;CSSCalcPrimitiveValueNode&gt; create(double value, CSSUnitType type)</span>
      {
          if (!std::isfinite(value))
              return nullptr;
<span class="line-modified">!         return adoptRef(new CSSCalcPrimitiveValueNode(CSSPrimitiveValue::create(value, type)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     String customCSSText() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return m_value-&gt;cssText();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     CSSUnitType primitiveType() const final</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return m_value-&gt;primitiveType();</span>
      }
  
<span class="line-added">+     bool isNumericValue() const;</span>
<span class="line-added">+     bool isNegative() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void negate();</span>
<span class="line-added">+     void invert();</span>
<span class="line-added">+ </span>
<span class="line-added">+     enum class UnitConversion {</span>
<span class="line-added">+         Invalid,</span>
<span class="line-added">+         Preserve,</span>
<span class="line-added">+         Canonicalize</span>
<span class="line-added">+     };</span>
<span class="line-added">+     void add(const CSSCalcPrimitiveValueNode&amp;, UnitConversion = UnitConversion::Preserve);</span>
<span class="line-added">+     void multiply(double);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void convertToUnitType(CSSUnitType);</span>
<span class="line-added">+     void canonicalizeUnit();</span>
<span class="line-added">+ </span>
<span class="line-added">+     const CSSPrimitiveValue&amp; value() const { return m_value.get(); }</span>
<span class="line-added">+ </span>
  private:
      bool isZero() const final
      {
          return !m_value-&gt;doubleValue();
      }
  
<span class="line-modified">!     bool equals(const CSSCalcExpressionNode&amp; other) const final;</span>
<span class="line-added">+     Type type() const final { return CssCalcPrimitiveValue; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added">+     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added">+     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added">+     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void dump(TextStream&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     explicit CSSCalcPrimitiveValueNode(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)</span>
<span class="line-added">+         : CSSCalcExpressionNode(calcUnitCategory(value-&gt;primitiveType()))</span>
<span class="line-added">+         , m_value(WTFMove(value))</span>
      {
      }
  
<span class="line-modified">!     Ref&lt;CSSPrimitiveValue&gt; m_value;</span>
<span class="line-modified">! };</span>
<span class="line-modified">! </span>
<span class="line-modified">! // FIXME: Use calcUnitCategory?</span>
<span class="line-modified">! bool CSSCalcPrimitiveValueNode::isNumericValue() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return m_value-&gt;isLength() || m_value-&gt;isNumber() || m_value-&gt;isPercentage() || m_value-&gt;isAngle()</span>
<span class="line-modified">!         || m_value-&gt;isTime() || m_value-&gt;isResolution() || m_value-&gt;isFlex() || m_value-&gt;isFrequency();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool CSSCalcPrimitiveValueNode::isNegative() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return isNumericValue() &amp;&amp; m_value-&gt;doubleValue() &lt; 0.0;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void CSSCalcPrimitiveValueNode::negate()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(isNumericValue());</span>
<span class="line-modified">!     m_value = CSSPrimitiveValue::create(0.0 - m_value-&gt;doubleValue(), m_value-&gt;primitiveType());</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::invert()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isNumericValue());</span>
<span class="line-added">+     if (!m_value-&gt;doubleValue())</span>
<span class="line-added">+         m_value = CSSPrimitiveValue::create(std::numeric_limits&lt;double&gt;::infinity(), m_value-&gt;primitiveType());</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_value = CSSPrimitiveValue::create(1.0 / m_value-&gt;doubleValue(), m_value-&gt;primitiveType());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::add(const CSSCalcPrimitiveValueNode&amp; node, UnitConversion unitConversion)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto valueType = m_value-&gt;primitiveType();</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (unitConversion) {</span>
<span class="line-added">+     case UnitConversion::Invalid:</span>
          ASSERT_NOT_REACHED();
<span class="line-modified">!         break;</span>
<span class="line-added">+     case UnitConversion::Preserve:</span>
<span class="line-added">+         ASSERT(node.primitiveType() == valueType);</span>
<span class="line-added">+         m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue() + node.doubleValue(valueType), valueType);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case UnitConversion::Canonicalize: {</span>
<span class="line-added">+         auto valueCategory = unitCategory(valueType);</span>
<span class="line-added">+         // FIXME: It&#39;s awkward that canonicalUnitTypeForCategory() has special handling for CSSUnitCategory::Percent.</span>
<span class="line-added">+         auto canonicalType = valueCategory == CSSUnitCategory::Percent ? CSSUnitType::CSS_PERCENTAGE : canonicalUnitTypeForCategory(valueCategory);</span>
<span class="line-added">+         ASSERT(canonicalType != CSSUnitType::CSS_UNKNOWN);</span>
<span class="line-added">+         double leftValue = m_value-&gt;doubleValue(canonicalType);</span>
<span class="line-added">+         double rightValue = node.doubleValue(canonicalType);</span>
<span class="line-added">+         m_value = CSSPrimitiveValue::create(leftValue + rightValue, canonicalType);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
      }
<span class="line-added">+ }</span>
  
<span class="line-modified">! void CSSCalcPrimitiveValueNode::multiply(double multiplier)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto valueType = m_value-&gt;primitiveType();</span>
<span class="line-modified">!     ASSERT(hasDoubleValue(valueType));</span>
<span class="line-added">+     m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue(valueType) * multiplier, valueType);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::convertToUnitType(CSSUnitType unitType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(unitCategory(unitType) == unitCategory(m_value-&gt;primitiveType()));</span>
<span class="line-added">+     double newValue = m_value-&gt;doubleValue(unitType);</span>
<span class="line-added">+     m_value = CSSPrimitiveValue::create(newValue, unitType);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::canonicalizeUnit()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto category = calculationCategoryForCombination(m_value-&gt;primitiveType());</span>
<span class="line-added">+     if (category == CalculationCategory::Other)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto canonicalType = canonicalUnitTypeForCalculationCategory(category);</span>
<span class="line-added">+     if (canonicalType == m_value-&gt;primitiveType())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     double newValue = m_value-&gt;doubleValue(canonicalType);</span>
<span class="line-added">+     m_value = CSSPrimitiveValue::create(newValue, canonicalType);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcPrimitiveValueNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (category()) {</span>
<span class="line-added">+     case CalculationCategory::Number:</span>
<span class="line-added">+         return makeUnique&lt;CalcExpressionNumber&gt;(m_value-&gt;floatValue());</span>
<span class="line-added">+     case CalculationCategory::Length:</span>
<span class="line-added">+         return makeUnique&lt;CalcExpressionLength&gt;(Length(m_value-&gt;computeLength&lt;float&gt;(conversionData), WebCore::Fixed));</span>
<span class="line-added">+     case CalculationCategory::Percent:</span>
<span class="line-added">+     case CalculationCategory::PercentLength: {</span>
<span class="line-added">+         return makeUnique&lt;CalcExpressionLength&gt;(m_value-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion&gt;(conversionData));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Only types that could be part of a Length expression can be converted</span>
<span class="line-added">+     // to a CalcExpressionNode. CalculationCategory::PercentNumber makes no sense as a Length.</span>
<span class="line-added">+     case CalculationCategory::PercentNumber:</span>
<span class="line-added">+     case CalculationCategory::Angle:</span>
<span class="line-added">+     case CalculationCategory::Time:</span>
<span class="line-added">+     case CalculationCategory::Frequency:</span>
<span class="line-added">+     case CalculationCategory::Other:</span>
          ASSERT_NOT_REACHED();
      }
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! double CSSCalcPrimitiveValueNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (hasDoubleValue(unitType)) {</span>
<span class="line-modified">!         // FIXME: This should ASSERT(unitCategory(m_value-&gt;primitiveType()) == unitCategory(unitType)), but only when all callers are fixed (e.g. webkit.org/b/204826).</span>
<span class="line-modified">!         if (unitCategory(m_value-&gt;primitiveType()) != unitCategory(unitType)) {</span>
<span class="line-modified">!             LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Calling doubleValue() with unit &quot; &lt;&lt; unitType &lt;&lt; &quot; on a node of unit type &quot; &lt;&lt; m_value-&gt;primitiveType() &lt;&lt; &quot; which is incompatible&quot;);</span>
<span class="line-modified">!             return 0;</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         return m_value-&gt;doubleValue(unitType);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcPrimitiveValueNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (category()) {</span>
<span class="line-added">+     case CalculationCategory::Length:</span>
<span class="line-added">+         return m_value-&gt;computeLength&lt;double&gt;(conversionData);</span>
<span class="line-added">+     case CalculationCategory::Percent:</span>
<span class="line-added">+     case CalculationCategory::Number:</span>
<span class="line-added">+         return m_value-&gt;doubleValue();</span>
<span class="line-added">+     case CalculationCategory::PercentLength:</span>
<span class="line-added">+     case CalculationCategory::PercentNumber:</span>
<span class="line-added">+     case CalculationCategory::Angle:</span>
<span class="line-added">+     case CalculationCategory::Time:</span>
<span class="line-added">+     case CalculationCategory::Frequency:</span>
<span class="line-added">+     case CalculationCategory::Other:</span>
          ASSERT_NOT_REACHED();
<span class="line-modified">!         break;</span>
      }
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_value-&gt;collectDirectComputationalDependencies(values);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_value-&gt;collectDirectRootComputationalDependencies(values);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CSSCalcPrimitiveValueNode::equals(const CSSCalcExpressionNode&amp; other) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (type() != other.type())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return compareCSSValue(m_value, static_cast&lt;const CSSCalcPrimitiveValueNode&amp;&gt;(other).m_value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcPrimitiveValueNode::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;value &quot; &lt;&lt; m_value-&gt;customCSSText() &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type: &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! class CSSCalcNegateNode final : public CSSCalcExpressionNode {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     static Ref&lt;CSSCalcNegateNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
      {
<span class="line-modified">!         return adoptRef(*new CSSCalcNegateNode(WTFMove(child)));</span>
      }
  
<span class="line-modified">!     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }</span>
<span class="line-added">+     CSSCalcExpressionNode&amp; child() { return m_child.get(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     CSSCalcNegateNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
<span class="line-added">+         : CSSCalcExpressionNode(child-&gt;category())</span>
<span class="line-added">+         , m_child(WTFMove(child))</span>
      {
      }
  
<span class="line-modified">!     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
  
<span class="line-modified">!     bool isZero() const final { return m_child-&gt;isZero(); }</span>
<span class="line-modified">!     double doubleValue(CSSUnitType unitType) const final { return -m_child-&gt;doubleValue(unitType); }</span>
<span class="line-added">+     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final { return -m_child-&gt;computeLengthPx(conversionData); }</span>
<span class="line-added">+     Type type() const final { return Type::CssCalcNegate; }</span>
<span class="line-added">+     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }</span>
  
<span class="line-modified">!     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }</span>
<span class="line-modified">!     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void dump(TextStream&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;CSSCalcExpressionNode&gt; m_child;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcNegateNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto childNode = m_child-&gt;createCalcExpression(conversionData);</span>
<span class="line-added">+     return makeUnique&lt;CalcExpressionNegation&gt;(WTFMove(childNode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcNegateNode::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;-&quot; &lt;&lt; m_child.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class CSSCalcInvertNode final : public CSSCalcExpressionNode {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     static Ref&lt;CSSCalcInvertNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
      {
<span class="line-modified">!         return adoptRef(*new CSSCalcInvertNode(WTFMove(child)));</span>
      }
  
<span class="line-added">+     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }</span>
<span class="line-added">+     CSSCalcExpressionNode&amp; child() { return m_child.get(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     CSSCalcInvertNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(child-&gt;category())</span>
<span class="line-modified">!         , m_child(WTFMove(child))</span>
      {
      }
  
<span class="line-modified">!     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isZero() const final { return m_child-&gt;isZero(); }</span>
<span class="line-added">+     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added">+     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added">+     Type type() const final { return Type::CssCalcInvert; }</span>
<span class="line-added">+     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }</span>
<span class="line-added">+     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void dump(TextStream&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;CSSCalcExpressionNode&gt; m_child;</span>
  };
  
<span class="line-added">+ std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcInvertNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto childNode = m_child-&gt;createCalcExpression(conversionData);</span>
<span class="line-added">+     return makeUnique&lt;CalcExpressionInversion&gt;(WTFMove(childNode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcInvertNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto childValue = m_child-&gt;doubleValue(unitType);</span>
<span class="line-added">+     if (!childValue)</span>
<span class="line-added">+         return std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-added">+     return 1.0 / childValue;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcInvertNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto childValue = m_child-&gt;computeLengthPx(conversionData);</span>
<span class="line-added">+     if (!childValue)</span>
<span class="line-added">+         return std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-added">+     return 1.0 / childValue;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcInvertNode::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;1/&quot; &lt;&lt; m_child.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This is the result of the &quot;To add two types type1 and type2, perform the following steps:&quot; rules.</span>
<span class="line-added">+ </span>
  static const CalculationCategory addSubtractResult[static_cast&lt;unsigned&gt;(CalculationCategory::Angle)][static_cast&lt;unsigned&gt;(CalculationCategory::Angle)] = {
  //    CalculationCategory::Number         CalculationCategory::Length         CalculationCategory::Percent        CalculationCategory::PercentNumber  CalculationCategory::PercentLength
      { CalculationCategory::Number,        CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::Number
      { CalculationCategory::Other,         CalculationCategory::Length,        CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::Length
      { CalculationCategory::PercentNumber, CalculationCategory::PercentLength, CalculationCategory::Percent,       CalculationCategory::PercentNumber, CalculationCategory::PercentLength }, // CalculationCategory::Percent
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,19 ***</span>
          if (rightCategory != CalculationCategory::Number || rightSide.isZero())
              return CalculationCategory::Other;
          return leftCategory;
      case CalcOperator::Min:
      case CalcOperator::Max:
          ASSERT_NOT_REACHED();
          return CalculationCategory::Other;
      }
  
      ASSERT_NOT_REACHED();
      return CalculationCategory::Other;
  }
  
<span class="line-modified">! static CalculationCategory resolvedTypeForMinOrMax(CalculationCategory category, CalculationCategory destinationCategory)</span>
  {
      switch (category) {
      case CalculationCategory::Number:
      case CalculationCategory::Length:
      case CalculationCategory::PercentNumber:
<span class="line-new-header">--- 633,89 ---</span>
          if (rightCategory != CalculationCategory::Number || rightSide.isZero())
              return CalculationCategory::Other;
          return leftCategory;
      case CalcOperator::Min:
      case CalcOperator::Max:
<span class="line-added">+     case CalcOperator::Clamp:</span>
          ASSERT_NOT_REACHED();
          return CalculationCategory::Other;
      }
  
      ASSERT_NOT_REACHED();
      return CalculationCategory::Other;
  }
  
<span class="line-modified">! // FIXME: Need to implement correct category computation per:</span>
<span class="line-added">+ // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-invert-a-type&gt;</span>
<span class="line-added">+ // To invert a type type, perform the following steps:</span>
<span class="line-added">+ // Let result be a new type with an initially empty ordered map and an initially null percent hint</span>
<span class="line-added">+ // For each unit  exponent of type, set result[unit] to (-1 * exponent).</span>
<span class="line-added">+ static CalculationCategory categoryForInvert(CalculationCategory category)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return category;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static CalculationCategory determineCategory(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes, CalcOperator op)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (nodes.isEmpty())</span>
<span class="line-added">+         return CalculationCategory::Other;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto currentCategory = nodes[0]-&gt;category();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (unsigned i = 1; i &lt; nodes.size(); ++i) {</span>
<span class="line-added">+         const auto&amp; node = nodes[i].get();</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto usedOperator = op;</span>
<span class="line-added">+         if (node.type() == CSSCalcExpressionNode::Type::CssCalcInvert)</span>
<span class="line-added">+             usedOperator = CalcOperator::Divide;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto nextCategory = node.category();</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (usedOperator) {</span>
<span class="line-added">+         case CalcOperator::Add:</span>
<span class="line-added">+         case CalcOperator::Subtract:</span>
<span class="line-added">+             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-add-two-types&gt;</span>
<span class="line-added">+             // At a + or - sub-expression, attempt to add the types of the left and right arguments.</span>
<span class="line-added">+             // If this returns failure, the entire calculations type is failure. Otherwise, the sub-expressions type is the returned type.</span>
<span class="line-added">+             if (currentCategory &lt; CalculationCategory::Angle &amp;&amp; nextCategory &lt; CalculationCategory::Angle)</span>
<span class="line-added">+                 currentCategory = addSubtractResult[static_cast&lt;unsigned&gt;(currentCategory)][static_cast&lt;unsigned&gt;(nextCategory)];</span>
<span class="line-added">+             else if (currentCategory != nextCategory)</span>
<span class="line-added">+                 return CalculationCategory::Other;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case CalcOperator::Multiply:</span>
<span class="line-added">+             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-multiply-two-types&gt;</span>
<span class="line-added">+             // At a * sub-expression, multiply the types of the left and right arguments. The sub-expressions type is the returned result.</span>
<span class="line-added">+             if (currentCategory != CalculationCategory::Number &amp;&amp; nextCategory != CalculationCategory::Number)</span>
<span class="line-added">+                 return CalculationCategory::Other;</span>
<span class="line-added">+ </span>
<span class="line-added">+             currentCategory = currentCategory == CalculationCategory::Number ? nextCategory : currentCategory;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         case CalcOperator::Divide: {</span>
<span class="line-added">+             auto invertCategory = categoryForInvert(nextCategory);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // At a / sub-expression, let left type be the result of finding the types of its left argument,</span>
<span class="line-added">+             // and right type be the result of finding the types of its right argument and then inverting it.</span>
<span class="line-added">+             // The sub-expressions type is the result of multiplying the left type and right type.</span>
<span class="line-added">+             if (invertCategory != CalculationCategory::Number || node.isZero())</span>
<span class="line-added">+                 return CalculationCategory::Other;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case CalcOperator::Min:</span>
<span class="line-added">+         case CalcOperator::Max:</span>
<span class="line-added">+         case CalcOperator::Clamp:</span>
<span class="line-added">+             // The type of a min(), max(), or clamp() expression is the result of adding the types of its comma-separated calculations</span>
<span class="line-added">+             return CalculationCategory::Other;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return currentCategory;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static CalculationCategory resolvedTypeForMinOrMaxOrClamp(CalculationCategory category, CalculationCategory destinationCategory)</span>
  {
      switch (category) {
      case CalculationCategory::Number:
      case CalculationCategory::Length:
      case CalculationCategory::PercentNumber:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 354,588 ***</span>
      }
  
      return CalculationCategory::Other;
  }
  
<span class="line-removed">- static inline bool isIntegerResult(CalcOperator op, const CSSCalcExpressionNode&amp; leftSide, const CSSCalcExpressionNode&amp; rightSide)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Performs W3C spec&#39;s type checking for calc integers.</span>
<span class="line-removed">-     // http://www.w3.org/TR/css3-values/#calc-type-checking</span>
<span class="line-removed">-     return op != CalcOperator::Divide &amp;&amp; leftSide.isInteger() &amp;&amp; rightSide.isInteger();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline bool isIntegerResult(CalcOperator op, const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Performs W3C spec&#39;s type checking for calc integers.</span>
<span class="line-removed">-     // http://www.w3.org/TR/css3-values/#calc-type-checking</span>
<span class="line-removed">-     if (op == CalcOperator::Divide)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; node : nodes) {</span>
<span class="line-removed">-         if (!node-&gt;isInteger())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static bool isSamePair(CalculationCategory a, CalculationCategory b, CalculationCategory x, CalculationCategory y)
  {
      return (a == x &amp;&amp; b == y) || (a == y &amp;&amp; b == x);
  }
  
<span class="line-modified">! class CSSCalcOperation final : public CSSCalcExpressionNode {</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperation&gt; create(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (!leftSide || !rightSide)</span>
<span class="line-modified">!             return nullptr;</span>
  
<span class="line-modified">!         ASSERT(leftSide-&gt;category() &lt; CalculationCategory::Other);</span>
<span class="line-removed">-         ASSERT(rightSide-&gt;category() &lt; CalculationCategory::Other);</span>
  
<span class="line-modified">!         auto newCategory = determineCategory(*leftSide, *rightSide, op);</span>
<span class="line-removed">-         if (newCategory == CalculationCategory::Other)</span>
<span class="line-removed">-             return nullptr;</span>
  
<span class="line-modified">!         return adoptRef(new CSSCalcOperation(newCategory, op, leftSide.releaseNonNull(), rightSide.releaseNonNull()));</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperation&gt; createMinOrMax(CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         ASSERT(op == CalcOperator::Min || op == CalcOperator::Max);</span>
  
<span class="line-modified">!         Optional&lt;CalculationCategory&gt; category = WTF::nullopt;</span>
<span class="line-removed">-         for (auto&amp; value : values) {</span>
<span class="line-removed">-             auto valueCategory = resolvedTypeForMinOrMax(value-&gt;category(), destinationCategory);</span>
  
<span class="line-modified">!             ASSERT(valueCategory &lt; CalculationCategory::Other);</span>
<span class="line-modified">!             if (!category) {</span>
<span class="line-removed">-                 if (valueCategory == CalculationCategory::Other)</span>
<span class="line-removed">-                     return nullptr;</span>
<span class="line-removed">-                 category = valueCategory;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             if (category != valueCategory) {</span>
<span class="line-modified">!                 if (isSamePair(category.value(), valueCategory, CalculationCategory::Length, CalculationCategory::PercentLength)) {</span>
<span class="line-modified">!                     category = CalculationCategory::PercentLength;</span>
<span class="line-modified">!                     continue;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if (isSamePair(category.value(), valueCategory, CalculationCategory::Number, CalculationCategory::PercentNumber)) {</span>
<span class="line-modified">!                     category = CalculationCategory::PercentNumber;</span>
<span class="line-modified">!                     continue;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 return nullptr;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         return adoptRef(new CSSCalcOperation(category.value(), op, WTFMove(values)));</span>
      }
  
<span class="line-modified">!     static RefPtr&lt;CSSCalcExpressionNode&gt; createSimplified(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
      {
<span class="line-modified">!         if (!leftSide || !rightSide)</span>
              return nullptr;
  
<span class="line-modified">!         auto leftCategory = leftSide-&gt;category();</span>
<span class="line-modified">!         auto rightCategory = rightSide-&gt;category();</span>
<span class="line-removed">-         ASSERT(leftCategory &lt; CalculationCategory::Other);</span>
<span class="line-removed">-         ASSERT(rightCategory &lt; CalculationCategory::Other);</span>
  
<span class="line-modified">!         bool isInteger = isIntegerResult(op, *leftSide, *rightSide);</span>
  
<span class="line-modified">!         // Simplify numbers.</span>
<span class="line-modified">!         if (leftCategory == CalculationCategory::Number &amp;&amp; rightCategory == CalculationCategory::Number) {</span>
<span class="line-modified">!             CSSPrimitiveValue::UnitType evaluationType = CSSPrimitiveValue::CSS_NUMBER;</span>
<span class="line-modified">!             return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftSide-&gt;doubleValue(), rightSide-&gt;doubleValue() }), evaluationType, isInteger);</span>
          }
  
<span class="line-modified">!         // Simplify addition and subtraction between same types.</span>
<span class="line-modified">!         if (op == CalcOperator::Add || op == CalcOperator::Subtract) {</span>
<span class="line-modified">!             if (leftCategory == rightSide-&gt;category()) {</span>
<span class="line-modified">!                 CSSPrimitiveValue::UnitType leftType = leftSide-&gt;primitiveType();</span>
<span class="line-modified">!                 if (hasDoubleValue(leftType)) {</span>
<span class="line-modified">!                     CSSPrimitiveValue::UnitType rightType = rightSide-&gt;primitiveType();</span>
<span class="line-modified">!                     if (leftType == rightType)</span>
<span class="line-modified">!                         return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftSide-&gt;doubleValue(), rightSide-&gt;doubleValue() }), leftType, isInteger);</span>
<span class="line-modified">!                     CSSPrimitiveValue::UnitCategory leftUnitCategory = CSSPrimitiveValue::unitCategory(leftType);</span>
<span class="line-modified">!                     if (leftUnitCategory != CSSPrimitiveValue::UOther &amp;&amp; leftUnitCategory == CSSPrimitiveValue::unitCategory(rightType)) {</span>
<span class="line-modified">!                         CSSPrimitiveValue::UnitType canonicalType = CSSPrimitiveValue::canonicalUnitTypeForCategory(leftUnitCategory);</span>
<span class="line-modified">!                         if (canonicalType != CSSPrimitiveValue::CSS_UNKNOWN) {</span>
<span class="line-modified">!                             double leftValue = leftSide-&gt;doubleValue() * CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(leftType);</span>
<span class="line-modified">!                             double rightValue = rightSide-&gt;doubleValue() * CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(rightType);</span>
<span class="line-modified">!                             return CSSCalcPrimitiveValue::create(evaluateOperator(op, { leftValue, rightValue }), canonicalType, isInteger);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // Simplify multiplying or dividing by a number for simplifiable types.</span>
<span class="line-removed">-             ASSERT(op == CalcOperator::Multiply || op == CalcOperator::Divide);</span>
<span class="line-removed">-             auto* numberSide = getNumberSide(*leftSide, *rightSide);</span>
<span class="line-removed">-             if (!numberSide)</span>
<span class="line-removed">-                 return create(op, leftSide.releaseNonNull(), rightSide.releaseNonNull());</span>
<span class="line-removed">-             if (numberSide == leftSide &amp;&amp; op == CalcOperator::Divide)</span>
<span class="line-removed">-                 return nullptr;</span>
<span class="line-removed">-             auto&amp; otherSide = leftSide == numberSide ? *rightSide : *leftSide;</span>
  
<span class="line-modified">!             double number = numberSide-&gt;doubleValue();</span>
<span class="line-modified">!             if (!std::isfinite(number))</span>
<span class="line-modified">!                 return nullptr;</span>
<span class="line-modified">!             if (op == CalcOperator::Divide &amp;&amp; !number)</span>
<span class="line-modified">!                 return nullptr;</span>
  
<span class="line-modified">!             auto otherType = otherSide.primitiveType();</span>
<span class="line-modified">!             if (hasDoubleValue(otherType))</span>
<span class="line-modified">!                 return CSSCalcPrimitiveValue::create(evaluateOperator(op, { otherSide.doubleValue(), number }), otherType, isInteger);</span>
          }
  
<span class="line-modified">!         return create(op, leftSide.releaseNonNull(), rightSide.releaseNonNull());</span>
      }
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     bool isZero() const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         return !doubleValue();</span>
      }
  
<span class="line-modified">!     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-modified">!         nodes.reserveInitialCapacity(m_children.size());</span>
  
<span class="line-modified">!         for (auto&amp; child : m_children) {</span>
<span class="line-modified">!             auto node = child-&gt;createCalcExpression(conversionData);</span>
<span class="line-modified">!             if (!node)</span>
<span class="line-modified">!                 return nullptr;</span>
<span class="line-modified">!             nodes.uncheckedAppend(WTFMove(node));</span>
          }
<span class="line-modified">!         return makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(nodes), m_operator);</span>
      }
  
<span class="line-modified">!     double doubleValue() const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;double&gt; doubleValues;</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             doubleValues.append(child-&gt;doubleValue());</span>
<span class="line-modified">!         return evaluate(doubleValues);</span>
      }
  
<span class="line-modified">!     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;double&gt; doubleValues;</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             doubleValues.append(child-&gt;computeLengthPx(conversionData));</span>
<span class="line-modified">!         return evaluate(doubleValues);</span>
      }
  
<span class="line-modified">!     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             child-&gt;collectDirectComputationalDependencies(values);</span>
      }
  
<span class="line-modified">!     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const final</span>
<span class="line-modified">!     {</span>
          for (auto&amp; child : m_children)
<span class="line-modified">!             child-&gt;collectDirectRootComputationalDependencies(values);</span>
      }
  
<span class="line-modified">!     static String buildCssText(Vector&lt;String&gt; childExpressions, CalcOperator op)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         StringBuilder result;</span>
<span class="line-modified">!         result.append(&#39;(&#39;);</span>
<span class="line-modified">!         switch (op) {</span>
<span class="line-modified">!         case CalcOperator::Add:</span>
<span class="line-modified">!         case CalcOperator::Subtract:</span>
<span class="line-modified">!         case CalcOperator::Multiply:</span>
<span class="line-modified">!         case CalcOperator::Divide:</span>
<span class="line-modified">!             ASSERT(childExpressions.size() == 2);</span>
<span class="line-modified">!             result.append(childExpressions[0]);</span>
<span class="line-modified">!             result.append(&#39; &#39;);</span>
<span class="line-modified">!             result.append(static_cast&lt;char&gt;(op));</span>
<span class="line-modified">!             result.append(&#39; &#39;);</span>
<span class="line-modified">!             result.append(childExpressions[1]);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case CalcOperator::Min:</span>
<span class="line-modified">!         case CalcOperator::Max:</span>
<span class="line-modified">!             ASSERT(!childExpressions.isEmpty());</span>
<span class="line-modified">!             const char* functionName = op == CalcOperator::Min ? &quot;min(&quot; : &quot;max(&quot;;</span>
<span class="line-modified">!             result.append(functionName);</span>
<span class="line-modified">!             result.append(childExpressions[0]);</span>
<span class="line-modified">!             for (size_t i = 1; i &lt; childExpressions.size(); ++i) {</span>
<span class="line-modified">!                 result.append(&#39;,&#39;);</span>
<span class="line-modified">!                 result.append(&#39; &#39;);</span>
<span class="line-modified">!                 result.append(childExpressions[i]);</span>
              }
<span class="line-modified">!             result.append(&#39;)&#39;);</span>
          }
<span class="line-removed">-         result.append(&#39;)&#39;);</span>
  
<span class="line-modified">!         return result.toString();</span>
      }
  
<span class="line-modified">!     String customCSSText() const final</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Vector&lt;String&gt; cssTexts;</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             cssTexts.append(child-&gt;customCSSText());</span>
<span class="line-modified">!         return buildCssText(cssTexts, m_operator);</span>
      }
  
<span class="line-removed">-     bool equals(const CSSCalcExpressionNode&amp; exp) const final</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (type() != exp.type())</span>
<span class="line-removed">-             return false;</span>
  
<span class="line-modified">!         const CSSCalcOperation&amp; other = static_cast&lt;const CSSCalcOperation&amp;&gt;(exp);</span>
  
<span class="line-modified">!         if (m_children.size() != other.m_children.size() || m_operator != other.m_operator)</span>
<span class="line-removed">-             return false;</span>
  
<span class="line-modified">!         for (size_t i = 0; i &lt; m_children.size(); ++i) {</span>
<span class="line-modified">!             if (!compareCSSValue(m_children[i], other.m_children[i]))</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return true;</span>
      }
  
<span class="line-modified">!     Type type() const final { return CssCalcOperation; }</span>
  
<span class="line-modified">!     CSSPrimitiveValue::UnitType primitiveType() const final</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         switch (category()) {</span>
<span class="line-removed">-         case CalculationCategory::Number:</span>
<span class="line-removed">- #if !ASSERT_DISABLED</span>
<span class="line-removed">-             for (auto&amp; child : m_children)</span>
<span class="line-removed">-                 ASSERT(child-&gt;category() == CalculationCategory::Number);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-             return CSSPrimitiveValue::CSS_NUMBER;</span>
<span class="line-removed">-         case CalculationCategory::Length:</span>
<span class="line-removed">-         case CalculationCategory::Percent: {</span>
<span class="line-removed">-             if (m_children.isEmpty())</span>
<span class="line-removed">-                 return CSSPrimitiveValue::CSS_UNKNOWN;</span>
<span class="line-removed">-             if (m_children.size() == 2) {</span>
<span class="line-removed">-                 if (m_children[0]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-removed">-                     return m_children[1]-&gt;primitiveType();</span>
<span class="line-removed">-                 if (m_children[1]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-removed">-                     return m_children[0]-&gt;primitiveType();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             CSSPrimitiveValue::UnitType firstType = m_children[0]-&gt;primitiveType();</span>
<span class="line-removed">-             for (auto&amp; child : m_children) {</span>
<span class="line-removed">-                 if (firstType != child-&gt;primitiveType())</span>
<span class="line-removed">-                     return CSSPrimitiveValue::CSS_UNKNOWN;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return firstType;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         case CalculationCategory::Angle:</span>
<span class="line-removed">-             return CSSPrimitiveValue::CSS_DEG;</span>
<span class="line-removed">-         case CalculationCategory::Time:</span>
<span class="line-removed">-             return CSSPrimitiveValue::CSS_MS;</span>
<span class="line-removed">-         case CalculationCategory::Frequency:</span>
<span class="line-removed">-             return CSSPrimitiveValue::CSS_HZ;</span>
<span class="line-removed">-         case CalculationCategory::PercentLength:</span>
<span class="line-removed">-         case CalculationCategory::PercentNumber:</span>
<span class="line-removed">-         case CalculationCategory::Other:</span>
<span class="line-removed">-             return CSSPrimitiveValue::CSS_UNKNOWN;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         return CSSPrimitiveValue::CSS_UNKNOWN;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     CSSCalcOperation(CalculationCategory category, CalcOperator op, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(category, isIntegerResult(op, leftSide.get(), rightSide.get()))</span>
<span class="line-modified">!         , m_operator(op)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_children.reserveInitialCapacity(2);</span>
<span class="line-modified">!         m_children.uncheckedAppend(WTFMove(leftSide));</span>
<span class="line-modified">!         m_children.uncheckedAppend(WTFMove(rightSide));</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     CSSCalcOperation(CalculationCategory category, CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; children)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(category, isIntegerResult(op, children))</span>
<span class="line-modified">!         , m_operator(op)</span>
<span class="line-modified">!         , m_children(WTFMove(children))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     static CSSCalcExpressionNode* getNumberSide(CSSCalcExpressionNode&amp; leftSide, CSSCalcExpressionNode&amp; rightSide)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (leftSide.category() == CalculationCategory::Number)</span>
<span class="line-removed">-             return &amp;leftSide;</span>
<span class="line-removed">-         if (rightSide.category() == CalculationCategory::Number)</span>
<span class="line-removed">-             return &amp;rightSide;</span>
          return nullptr;
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     double evaluate(const Vector&lt;double&gt;&amp; children) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return evaluateOperator(m_operator, children);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     static double evaluateOperator(CalcOperator op, const Vector&lt;double&gt;&amp; children)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         switch (op) {</span>
<span class="line-removed">-         case CalcOperator::Add:</span>
<span class="line-removed">-             ASSERT(children.size() == 2);</span>
<span class="line-removed">-             return children[0] + children[1];</span>
<span class="line-removed">-         case CalcOperator::Subtract:</span>
<span class="line-removed">-             ASSERT(children.size() == 2);</span>
<span class="line-removed">-             return children[0] - children[1];</span>
<span class="line-removed">-         case CalcOperator::Multiply:</span>
<span class="line-removed">-             ASSERT(children.size() == 2);</span>
<span class="line-removed">-             return children[0] * children[1];</span>
<span class="line-removed">-         case CalcOperator::Divide:</span>
<span class="line-removed">-             ASSERT(children.size() == 1 || children.size() == 2);</span>
<span class="line-removed">-             if (children.size() == 1)</span>
<span class="line-removed">-                 return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">-             return children[0] / children[1];</span>
<span class="line-removed">-         case CalcOperator::Min: {</span>
<span class="line-removed">-             if (children.isEmpty())</span>
<span class="line-removed">-                 return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">-             double minimum = children[0];</span>
<span class="line-removed">-             for (auto child : children)</span>
<span class="line-removed">-                 minimum = std::min(minimum, child);</span>
<span class="line-removed">-             return minimum;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         case CalcOperator::Max: {</span>
<span class="line-removed">-             if (children.isEmpty())</span>
<span class="line-removed">-                 return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">-             double maximum = children[0];</span>
<span class="line-removed">-             for (auto child : children)</span>
<span class="line-removed">-                 maximum = std::max(maximum, child);</span>
<span class="line-removed">-             return maximum;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     const CalcOperator m_operator;</span>
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; m_children;</span>
  };
  
<span class="line-modified">! static ParseState checkDepthAndIndex(int* depth, CSSParserTokenRange tokens)</span>
  {
<span class="line-removed">-     (*depth)++;</span>
      if (tokens.atEnd())
          return NoMoreTokens;
<span class="line-modified">!     if (*depth &gt; maxExpressionDepth)</span>
          return TooDeep;
      return OK;
  }
  
<span class="line-modified">! class CSSCalcExpressionNodeParser {</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     explicit CSSCalcExpressionNodeParser(CalculationCategory destinationCategory)</span>
<span class="line-modified">!         : m_destinationCategory(destinationCategory)</span>
<span class="line-removed">-     { }</span>
  
<span class="line-modified">!     RefPtr&lt;CSSCalcExpressionNode&gt; parseCalc(CSSParserTokenRange tokens, CSSValueID function)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         Value result;</span>
<span class="line-modified">!         tokens.consumeWhitespace();</span>
<span class="line-modified">!         bool ok = false;</span>
<span class="line-modified">!         if (function == CSSValueCalc || function == CSSValueWebkitCalc)</span>
<span class="line-modified">!             ok = parseValueExpression(tokens, 0, &amp;result);</span>
<span class="line-modified">!         else if (function == CSSValueMin || function == CSSValueMax)</span>
<span class="line-modified">!             ok = parseMinMaxExpression(tokens, function, 0, &amp;result);</span>
<span class="line-modified">!         if (!ok || !tokens.atEnd())</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-modified">!         return result.value;</span>
      }
  
<span class="line-modified">! private:</span>
<span class="line-removed">-     struct Value {</span>
<span class="line-removed">-         RefPtr&lt;CSSCalcExpressionNode&gt; value;</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     char operatorValue(const CSSParserToken&amp; token)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (token.type() == DelimiterToken)</span>
<span class="line-modified">!             return token.delimiter();</span>
<span class="line-modified">!         return 0;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     bool parseValue(CSSParserTokenRange&amp; tokens, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         CSSParserToken token = tokens.consumeIncludingWhitespace();</span>
<span class="line-removed">-         if (!(token.type() == NumberToken || token.type() == PercentageToken || token.type() == DimensionToken))</span>
              return false;
  
<span class="line-modified">!         CSSPrimitiveValue::UnitType type = token.unitType();</span>
<span class="line-modified">!         if (unitCategory(type) == CalculationCategory::Other)</span>
              return false;
  
<span class="line-modified">!         bool isInteger = token.numericValueType() == IntegerValueType || (token.numericValueType() == NumberValueType &amp;&amp; token.numericValue() == trunc(token.numericValue()));</span>
<span class="line-modified">!         result-&gt;value = CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(token.numericValue(), type), isInteger);</span>
  
<span class="line-modified">!         return true;</span>
      }
  
<span class="line-modified">!     bool parseValueTerm(CSSParserTokenRange&amp; tokens, int depth, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (checkDepthAndIndex(&amp;depth, tokens) != OK)</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         auto functionId = tokens.peek().functionId();</span>
  
<span class="line-modified">!         if (tokens.peek().type() == LeftParenthesisToken || functionId == CSSValueCalc) {</span>
<span class="line-removed">-             CSSParserTokenRange innerRange = tokens.consumeBlock();</span>
<span class="line-removed">-             tokens.consumeWhitespace();</span>
<span class="line-removed">-             innerRange.consumeWhitespace();</span>
<span class="line-removed">-             return parseValueExpression(innerRange, depth, result);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         if (functionId == CSSValueMax || functionId == CSSValueMin) {</span>
<span class="line-modified">!             CSSParserTokenRange innerRange = tokens.consumeBlock();</span>
<span class="line-modified">!             tokens.consumeWhitespace();</span>
<span class="line-modified">!             innerRange.consumeWhitespace();</span>
<span class="line-modified">!             return parseMinMaxExpression(innerRange, functionId, depth, result);</span>
          }
  
<span class="line-modified">!         return parseValue(tokens, result);</span>
      }
  
<span class="line-modified">!     bool parseValueMultiplicativeExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         if (checkDepthAndIndex(&amp;depth, tokens) != OK)</span>
<span class="line-removed">-             return false;</span>
  
<span class="line-modified">!         if (!parseValueTerm(tokens, depth, result))</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         while (!tokens.atEnd()) {</span>
<span class="line-modified">!             char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-modified">!             if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Multiply) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Divide))</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             tokens.consumeIncludingWhitespace();</span>
  
<span class="line-modified">!             Value rhs;</span>
<span class="line-modified">!             if (!parseValueTerm(tokens, depth, &amp;rhs))</span>
<span class="line-modified">!                 return false;</span>
  
<span class="line-modified">!             result-&gt;value = CSSCalcOperation::createSimplified(static_cast&lt;CalcOperator&gt;(operatorCharacter), WTFMove(result-&gt;value), WTFMove(rhs.value));</span>
  
<span class="line-modified">!             if (!result-&gt;value)</span>
<span class="line-modified">!                 return false;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return true;</span>
      }
  
<span class="line-modified">!     bool parseAdditiveValueExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (checkDepthAndIndex(&amp;depth, tokens) != OK)</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         if (!parseValueMultiplicativeExpression(tokens, depth, result))</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         while (!tokens.atEnd()) {</span>
<span class="line-modified">!             char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-modified">!             if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Add) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Subtract))</span>
<span class="line-modified">!                 break;</span>
<span class="line-removed">-             if ((&amp;tokens.peek() - 1)-&gt;type() != WhitespaceToken)</span>
<span class="line-removed">-                 return false; // calc(1px+ 2px) is invalid</span>
<span class="line-removed">-             tokens.consume();</span>
<span class="line-removed">-             if (tokens.peek().type() != WhitespaceToken)</span>
<span class="line-removed">-                 return false; // calc(1px +2px) is invalid</span>
<span class="line-removed">-             tokens.consumeIncludingWhitespace();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Value rhs;</span>
<span class="line-removed">-             if (!parseValueMultiplicativeExpression(tokens, depth, &amp;rhs))</span>
<span class="line-removed">-                 return false;</span>
  
<span class="line-modified">!             result-&gt;value = CSSCalcOperation::createSimplified(static_cast&lt;CalcOperator&gt;(operatorCharacter), WTFMove(result-&gt;value), WTFMove(rhs.value));</span>
<span class="line-modified">!             if (!result-&gt;value)</span>
<span class="line-modified">!                 return false;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return true;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     bool parseMinMaxExpression(CSSParserTokenRange&amp; tokens, CSSValueID minMaxFunction, int depth, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (checkDepthAndIndex(&amp;depth, tokens) != OK)</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         CalcOperator op = (minMaxFunction == CSSValueMin) ? CalcOperator::Min : CalcOperator::Max;</span>
  
<span class="line-modified">!         Value value;</span>
<span class="line-modified">!         if (!parseValueExpression(tokens, depth, &amp;value))</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-removed">-         nodes.append(value.value.releaseNonNull());</span>
  
<span class="line-modified">!         while (!tokens.atEnd()) {</span>
<span class="line-modified">!             tokens.consumeWhitespace();</span>
<span class="line-modified">!             if (tokens.consume().type() != CommaToken)</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             tokens.consumeWhitespace();</span>
  
<span class="line-modified">!             if (!parseValueExpression(tokens, depth, &amp;value))</span>
<span class="line-modified">!                 return false;</span>
  
<span class="line-modified">!             nodes.append(value.value.releaseNonNull());</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         result-&gt;value = CSSCalcOperation::createMinOrMax(op, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-removed">-         return result-&gt;value;</span>
      }
  
<span class="line-modified">!     bool parseValueExpression(CSSParserTokenRange&amp; tokens, int depth, Value* result)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         return parseAdditiveValueExpression(tokens, depth, result);</span>
      }
  
<span class="line-modified">!     CalculationCategory m_destinationCategory;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! static inline RefPtr&lt;CSSCalcOperation&gt; createBlendHalf(const Length&amp; length, const RenderStyle&amp; style, float progress)</span>
  {
<span class="line-modified">!     return CSSCalcOperation::create(CalcOperator::Multiply, createCSS(length, style),</span>
<span class="line-modified">!         CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(progress, CSSPrimitiveValue::CSS_NUMBER), !progress || progress == 1));</span>
  }
  
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp; node, const RenderStyle&amp; style)
  {
      switch (node.type()) {
      case CalcExpressionNodeType::Number: {
<span class="line-modified">!         float value = toCalcExpressionNumber(node).value();</span>
<span class="line-modified">!         return CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(value, CSSPrimitiveValue::CSS_NUMBER), value == std::trunc(value));</span>
      }
      case CalcExpressionNodeType::Length:
<span class="line-modified">!         return createCSS(toCalcExpressionLength(node).length(), style);</span>
      case CalcExpressionNodeType::Operation: {
<span class="line-modified">!         auto&amp; operationNode = toCalcExpressionOperation(node);</span>
          auto&amp; operationChildren = operationNode.children();
          CalcOperator op = operationNode.getOperator();
<span class="line-modified">!         if (op == CalcOperator::Min || op == CalcOperator::Max) {</span>
              Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
              values.reserveInitialCapacity(operationChildren.size());
<span class="line-modified">!             for (auto&amp; child : operationChildren) {</span>
<span class="line-modified">!                 auto cssNode = createCSS(*child, style);</span>
<span class="line-modified">!                 if (!cssNode)</span>
<span class="line-modified">!                     return nullptr;</span>
<span class="line-modified">!                 values.uncheckedAppend(*cssNode);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return CSSCalcOperation::createMinOrMax(operationNode.getOperator(), WTFMove(values), CalculationCategory::Other);</span>
          }
  
<span class="line-modified">!         if (operationChildren.size() == 2)</span>
<span class="line-modified">!             return CSSCalcOperation::create(operationNode.getOperator(), createCSS(*operationChildren[0], style), createCSS(*operationChildren[1], style));</span>
  
          return nullptr;
      }
      case CalcExpressionNodeType::BlendLength: {
          // FIXME: (http://webkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.
<span class="line-modified">!         auto&amp; blend = toCalcExpressionBlendLength(node);</span>
          float progress = blend.progress();
<span class="line-modified">!         return CSSCalcOperation::create(CalcOperator::Add, createBlendHalf(blend.from(), style, 1 - progress), createBlendHalf(blend.to(), style, progress));</span>
      }
      case CalcExpressionNodeType::Undefined:
          ASSERT_NOT_REACHED();
      }
      return nullptr;
<span class="line-new-header">--- 735,1283 ---</span>
      }
  
      return CalculationCategory::Other;
  }
  
  static bool isSamePair(CalculationCategory a, CalculationCategory b, CalculationCategory x, CalculationCategory y)
  {
      return (a == x &amp;&amp; b == y) || (a == y &amp;&amp; b == x);
  }
  
<span class="line-modified">! class CSSCalcOperationNode final : public CSSCalcExpressionNode {</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperationNode&gt; create(CalcOperator, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide);</span>
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperationNode&gt; createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);</span>
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperationNode&gt; createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);</span>
<span class="line-modified">!     static RefPtr&lt;CSSCalcOperationNode&gt; createMinOrMaxOrClamp(CalcOperator, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory);</span>
  
<span class="line-modified">!     static Ref&lt;CSSCalcExpressionNode&gt; simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;);</span>
  
<span class="line-modified">!     static void buildCSSText(const CSSCalcExpressionNode&amp;, StringBuilder&amp;);</span>
  
<span class="line-modified">!     CalcOperator calcOperator() const { return m_operator; }</span>
<span class="line-modified">!     bool isCalcSumNode() const { return m_operator == CalcOperator::Add; }</span>
<span class="line-added">+     bool isCalcProductNode() const { return m_operator == CalcOperator::Multiply; }</span>
<span class="line-added">+     bool isMinOrMaxNode() const { return m_operator == CalcOperator::Min || m_operator == CalcOperator::Max; }</span>
<span class="line-added">+     bool shouldSortChildren() const { return isCalcSumNode() || isCalcProductNode(); }</span>
  
<span class="line-modified">!     void hoistChildrenWithOperator(CalcOperator);</span>
<span class="line-modified">!     void combineChildren();</span>
  
<span class="line-modified">!     bool canCombineAllChildren() const;</span>
  
<span class="line-modified">!     const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() const { return m_children; }</span>
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() { return m_children; }</span>
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(category)</span>
<span class="line-modified">!         , m_operator(op)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         m_children.reserveInitialCapacity(2);</span>
<span class="line-modified">!         m_children.uncheckedAppend(WTFMove(leftSide));</span>
<span class="line-modified">!         m_children.uncheckedAppend(WTFMove(rightSide));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; children)</span>
<span class="line-modified">!         : CSSCalcExpressionNode(category)</span>
<span class="line-added">+         , m_operator(op)</span>
<span class="line-added">+         , m_children(WTFMove(children))</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Type type() const final { return CssCalcOperation; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isZero() const final</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return !doubleValue(primitiveType());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool equals(const CSSCalcExpressionNode&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
  
<span class="line-modified">!     CSSUnitType primitiveType() const final;</span>
<span class="line-added">+     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added">+     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added">+     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void dump(TextStream&amp;) const final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static CSSCalcExpressionNode* getNumberSide(CSSCalcExpressionNode&amp; leftSide, CSSCalcExpressionNode&amp; rightSide)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (leftSide.category() == CalculationCategory::Number)</span>
<span class="line-added">+             return &amp;leftSide;</span>
<span class="line-added">+         if (rightSide.category() == CalculationCategory::Number)</span>
<span class="line-added">+             return &amp;rightSide;</span>
<span class="line-added">+         return nullptr;</span>
      }
  
<span class="line-modified">!     double evaluate(const Vector&lt;double&gt;&amp; children) const</span>
      {
<span class="line-modified">!         return evaluateOperator(m_operator, children);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static double evaluateOperator(CalcOperator, const Vector&lt;double&gt;&amp;);</span>
<span class="line-added">+     static Ref&lt;CSSCalcExpressionNode&gt; simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);</span>
<span class="line-added">+     static Ref&lt;CSSCalcExpressionNode&gt; simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);</span>
<span class="line-added">+ </span>
<span class="line-added">+     enum class GroupingParens {</span>
<span class="line-added">+         Omit,</span>
<span class="line-added">+         Include</span>
<span class="line-added">+     };</span>
<span class="line-added">+     static void buildCSSTextRecursive(const CSSCalcExpressionNode&amp;, StringBuilder&amp;, GroupingParens = GroupingParens::Include);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const CalcOperator m_operator;</span>
<span class="line-added">+     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; m_children;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::create(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!leftSide || !rightSide)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(leftSide-&gt;category() &lt; CalculationCategory::Other);</span>
<span class="line-added">+     ASSERT(rightSide-&gt;category() &lt; CalculationCategory::Other);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto newCategory = determineCategory(*leftSide, *rightSide, op);</span>
<span class="line-added">+     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNode(*leftSide) &lt;&lt; &quot; and &quot; &lt;&lt; *rightSide);</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return adoptRef(new CSSCalcOperationNode(newCategory, op, leftSide.releaseNonNull(), rightSide.releaseNonNull()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (values.isEmpty())</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto newCategory = determineCategory(values, CalcOperator::Add);</span>
<span class="line-added">+     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create sum node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added">+         newCategory = determineCategory(values, CalcOperator::Add);</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Add, WTFMove(values)));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (values.isEmpty())</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto newCategory = determineCategory(values, CalcOperator::Multiply);</span>
<span class="line-added">+     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create product node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Multiply, WTFMove(values)));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(op == CalcOperator::Min || op == CalcOperator::Max || op == CalcOperator::Clamp);</span>
<span class="line-added">+     ASSERT_IMPLIES(op == CalcOperator::Clamp, values.size() == 3);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;CalculationCategory&gt; category = WTF::nullopt;</span>
<span class="line-added">+     for (auto&amp; value : values) {</span>
<span class="line-added">+         auto valueCategory = resolvedTypeForMinOrMaxOrClamp(value-&gt;category(), destinationCategory);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(valueCategory &lt; CalculationCategory::Other);</span>
<span class="line-added">+         if (!category) {</span>
<span class="line-added">+             if (valueCategory == CalculationCategory::Other) {</span>
<span class="line-added">+                 LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             category = valueCategory;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (category != valueCategory) {</span>
<span class="line-added">+             if (isSamePair(category.value(), valueCategory, CalculationCategory::Length, CalculationCategory::PercentLength)) {</span>
<span class="line-added">+                 category = CalculationCategory::PercentLength;</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (isSamePair(category.value(), valueCategory, CalculationCategory::Number, CalculationCategory::PercentNumber)) {</span>
<span class="line-added">+                 category = CalculationCategory::PercentNumber;</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
              return nullptr;
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return adoptRef(new CSSCalcOperationNode(category.value(), op, WTFMove(values)));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void CSSCalcOperationNode::hoistChildrenWithOperator(CalcOperator op)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);</span>
  
<span class="line-modified">!     auto hasChildWithOperator = [&amp;] (CalcOperator op) {</span>
<span class="line-modified">!         for (auto&amp; child : m_children) {</span>
<span class="line-modified">!             if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op)</span>
<span class="line-modified">!                 return true;</span>
          }
<span class="line-added">+         return false;</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     if (!hasChildWithOperator(op))</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-modified">!     for (auto&amp; child : m_children) {</span>
<span class="line-modified">!         if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op) {</span>
<span class="line-modified">!             auto&amp; children = downcast&lt;CSSCalcOperationNode&gt;(child.get()).children();</span>
<span class="line-modified">!             for (auto&amp; childToMove : children)</span>
<span class="line-modified">!                 newChildren.append(WTFMove(childToMove));</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             newChildren.append(WTFMove(child));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     newChildren.shrinkToFit();</span>
<span class="line-modified">!     m_children = WTFMove(newChildren);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! enum class SortingCategory {</span>
<span class="line-added">+     Number,</span>
<span class="line-added">+     Percent,</span>
<span class="line-added">+     Dimension,</span>
<span class="line-added">+     Other</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static SortingCategory sortingCategoryForType(CSSUnitType unitType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static constexpr SortingCategory sortOrder[] = {</span>
<span class="line-added">+         SortingCategory::Number,        // CalculationCategory::Number,</span>
<span class="line-added">+         SortingCategory::Dimension,     // CalculationCategory::Length,</span>
<span class="line-added">+         SortingCategory::Percent,       // CalculationCategory::Percent,</span>
<span class="line-added">+         SortingCategory::Number,        // CalculationCategory::PercentNumber,</span>
<span class="line-added">+         SortingCategory::Dimension,     // CalculationCategory::PercentLength,</span>
<span class="line-added">+         SortingCategory::Dimension,     // CalculationCategory::Angle,</span>
<span class="line-added">+         SortingCategory::Dimension,     // CalculationCategory::Time,</span>
<span class="line-added">+         SortingCategory::Dimension,     // CalculationCategory::Frequency,</span>
<span class="line-added">+         SortingCategory::Other,         // UOther</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     COMPILE_ASSERT(ARRAY_SIZE(sortOrder) == static_cast&lt;unsigned&gt;(CalculationCategory::Other) + 1, sortOrder_size_should_match_UnitCategory);</span>
<span class="line-added">+     return sortOrder[static_cast&lt;unsigned&gt;(calcUnitCategory(unitType))];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static SortingCategory sortingCategory(const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added">+         return sortingCategoryForType(node.primitiveType());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SortingCategory::Other;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static CSSUnitType primitiveTypeForCombination(const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added">+         return node.primitiveType();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static CSSCalcPrimitiveValueNode::UnitConversion conversionToAddValuesWithTypes(CSSUnitType firstType, CSSUnitType secondType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (firstType == CSSUnitType::CSS_UNKNOWN || secondType == CSSUnitType::CSS_UNKNOWN)</span>
<span class="line-added">+         return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto firstCategory = calculationCategoryForCombination(firstType);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Compatible types.</span>
<span class="line-added">+     if (firstCategory != CalculationCategory::Other &amp;&amp; firstCategory == calculationCategoryForCombination(secondType))</span>
<span class="line-added">+         return CSSCalcPrimitiveValueNode::UnitConversion::Canonicalize;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Matching types.</span>
<span class="line-added">+     if (firstType == secondType &amp;&amp; hasDoubleValue(firstType))</span>
<span class="line-added">+         return CSSCalcPrimitiveValueNode::UnitConversion::Preserve;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CSSCalcOperationNode::canCombineAllChildren() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_children.size() &lt; 2)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!is&lt;CSSCalcPrimitiveValueNode&gt;(m_children[0]))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto firstUnitType = m_children[0]-&gt;primitiveType();</span>
<span class="line-added">+     auto firstCategory = calculationCategoryForCombination(m_children[0]-&gt;primitiveType());</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (unsigned i = 1; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">+         auto&amp; node = m_children[i];</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto nodeUnitType = node-&gt;primitiveType();</span>
<span class="line-added">+         auto nodeCategory = calculationCategoryForCombination(nodeUnitType);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (nodeCategory != firstCategory)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (nodeCategory == CalculationCategory::Other &amp;&amp; nodeUnitType != firstUnitType)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!hasDoubleValue(nodeUnitType))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcOperationNode::combineChildren()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_children.size() &lt; 2)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (shouldSortChildren()) {</span>
<span class="line-added">+         // &lt;https://drafts.csswg.org/css-values-4/#sort-a-calculations-children&gt;</span>
<span class="line-added">+         std::stable_sort(m_children.begin(), m_children.end(), [](const auto&amp; first, const auto&amp; second) {</span>
<span class="line-added">+             // Sort order: number, percentage, dimension, other.</span>
<span class="line-added">+             SortingCategory firstCategory = sortingCategory(first.get());</span>
<span class="line-added">+             SortingCategory secondCategory = sortingCategory(second.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (firstCategory == SortingCategory::Dimension &amp;&amp; secondCategory == SortingCategory::Dimension) {</span>
<span class="line-added">+                 // If nodes contains any dimensions, remove them from nodes, sort them by their units, and append them to ret.</span>
<span class="line-added">+                 auto firstUnitString = CSSPrimitiveValue::unitTypeString(first-&gt;primitiveType());</span>
<span class="line-added">+                 auto secondUnitString = CSSPrimitiveValue::unitTypeString(second-&gt;primitiveType());</span>
<span class="line-added">+                 return codePointCompareLessThan(firstUnitString, secondUnitString);</span>
              }
  
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(firstCategory) &lt; static_cast&lt;unsigned&gt;(secondCategory);</span>
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;post-sort: &quot; &lt;&lt; *this);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (calcOperator() == CalcOperator::Add) {</span>
<span class="line-added">+         // For each set of roots children that are numeric values with identical units,</span>
<span class="line-added">+         // remove those children and replace them with a single numeric value containing</span>
<span class="line-added">+         // the sum of the removed nodes, and with the same unit.</span>
<span class="line-added">+         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-added">+         newChildren.reserveInitialCapacity(m_children.size());</span>
<span class="line-added">+         newChildren.uncheckedAppend(m_children[0].copyRef());</span>
<span class="line-added">+ </span>
<span class="line-added">+         CSSUnitType previousType = primitiveTypeForCombination(newChildren[0].get());</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned i = 1; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">+             auto&amp; currentNode = m_children[i];</span>
<span class="line-added">+             CSSUnitType currentType = primitiveTypeForCombination(currentNode.get());</span>
  
<span class="line-modified">!             auto conversionType = conversionToAddValuesWithTypes(previousType, currentType);</span>
<span class="line-modified">!             if (conversionType != CSSCalcPrimitiveValueNode::UnitConversion::Invalid) {</span>
<span class="line-modified">!                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren.last().get()).add(downcast&lt;CSSCalcPrimitiveValueNode&gt;(currentNode.get()), conversionType);</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             previousType = primitiveTypeForCombination(currentNode);</span>
<span class="line-added">+             newChildren.uncheckedAppend(currentNode.copyRef());</span>
          }
  
<span class="line-modified">!         newChildren.shrinkToFit();</span>
<span class="line-added">+         m_children = WTFMove(newChildren);</span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-modified">!     if (calcOperator() == CalcOperator::Multiply) {</span>
<span class="line-modified">!         // If root has multiple children that are numbers (not percentages or dimensions),</span>
<span class="line-modified">!         // remove them and replace them with a single number containing the product of the removed nodes.</span>
<span class="line-modified">!         double multiplier = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Sorting will have put the number nodes first.</span>
<span class="line-added">+         unsigned leadingNumberNodeCount = 0;</span>
<span class="line-added">+         for (auto&amp; node : m_children) {</span>
<span class="line-added">+             auto nodeType = primitiveTypeForCombination(node.get());</span>
<span class="line-added">+             if (nodeType != CSSUnitType::CSS_NUMBER)</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             multiplier *= node-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
<span class="line-added">+             ++leadingNumberNodeCount;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-added">+         newChildren.reserveInitialCapacity(m_children.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If root contains only two children, one of which is a number (not a percentage or dimension) and the other of</span>
<span class="line-added">+         // which is a Sum whose children are all numeric values, multiply all of the Sums children by the number, then</span>
<span class="line-added">+         // return the Sum.</span>
<span class="line-added">+         // The Sum&#39;s children simplification will have happened already.</span>
<span class="line-added">+         bool didMultipy = false;</span>
<span class="line-added">+         if (leadingNumberNodeCount &amp;&amp; m_children.size() - leadingNumberNodeCount == 1) {</span>
<span class="line-added">+             auto multiplicandCategory = calcUnitCategory(primitiveTypeForCombination(m_children.last().get()));</span>
<span class="line-added">+             if (multiplicandCategory != CalculationCategory::Other) {</span>
<span class="line-added">+                 newChildren.uncheckedAppend(m_children.last().copyRef());</span>
<span class="line-added">+                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren[0].get()).multiply(multiplier);</span>
<span class="line-added">+                 didMultipy = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!didMultipy) {</span>
<span class="line-added">+             if (leadingNumberNodeCount) {</span>
<span class="line-added">+                 auto multiplierNode = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(multiplier, CSSUnitType::CSS_NUMBER));</span>
<span class="line-added">+                 newChildren.uncheckedAppend(WTFMove(multiplierNode));</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (unsigned i = leadingNumberNodeCount; i &lt; m_children.size(); ++i)</span>
<span class="line-added">+                 newChildren.uncheckedAppend(m_children[i].copyRef());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         newChildren.shrinkToFit();</span>
<span class="line-added">+         m_children = WTFMove(newChildren);</span>
      }
  
<span class="line-modified">!     if (isMinOrMaxNode() &amp;&amp; canCombineAllChildren()) {</span>
<span class="line-modified">!         auto combinedUnitType = m_children[0]-&gt;primitiveType();</span>
<span class="line-modified">!         auto category = calculationCategoryForCombination(combinedUnitType);</span>
<span class="line-modified">!         if (category != CalculationCategory::Other)</span>
<span class="line-added">+             combinedUnitType = canonicalUnitTypeForCalculationCategory(category);</span>
  
<span class="line-modified">!         double resolvedValue = doubleValue(combinedUnitType);</span>
<span class="line-modified">!         auto newChild = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(resolvedValue, combinedUnitType));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_children.clear();</span>
<span class="line-modified">!         m_children.append(WTFMove(newChild));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://drafts.csswg.org/css-values-4/#simplify-a-calculation-tree</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return simplifyRecursive(WTFMove(rootNode), 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-added">+         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; children = operationNode.children();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; children.size(); ++i) {</span>
<span class="line-added">+             auto child = children[i].copyRef();</span>
<span class="line-added">+             auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">+             if (newNode.ptr() != children[i].ptr())</span>
<span class="line-added">+                 children[i] = WTFMove(newNode);</span>
          }
<span class="line-modified">!     } else if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {</span>
<span class="line-added">+         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get());</span>
<span class="line-added">+         Ref&lt;CSSCalcExpressionNode&gt; child = negateNode.child();</span>
<span class="line-added">+         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">+         if (newNode.ptr() != &amp;negateNode.child())</span>
<span class="line-added">+             negateNode.setChild(WTFMove(newNode));</span>
<span class="line-added">+     } else if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {</span>
<span class="line-added">+         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get());</span>
<span class="line-added">+         Ref&lt;CSSCalcExpressionNode&gt; child = invertNode.child();</span>
<span class="line-added">+         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">+         if (newNode.ptr() != &amp;invertNode.child())</span>
<span class="line-added">+             invertNode.setChild(WTFMove(newNode));</span>
      }
  
<span class="line-modified">!     return simplifyNode(WTFMove(rootNode), depth);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (is&lt;CSSCalcPrimitiveValueNode&gt;(rootNode)) {</span>
<span class="line-added">+         // If root is a percentage that will be resolved against another value, and there is enough information</span>
<span class="line-added">+         // available to resolve it, do so, and express the resulting numeric value in the appropriate canonical</span>
<span class="line-added">+         // unit. Return the value.</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If root is a dimension that is not expressed in its canonical unit, and there is enough information</span>
<span class="line-added">+         // available to convert it to the canonical unit, do so, and return the value.</span>
<span class="line-added">+         auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(rootNode.get());</span>
<span class="line-added">+         primitiveValueNode.canonicalizeUnit();</span>
<span class="line-added">+         return WTFMove(rootNode);</span>
      }
  
<span class="line-modified">!     // If root is an operator node thats not one of the calc-operator nodes, and all of its children are numeric values</span>
<span class="line-modified">!     // with enough information to computed the operation root represents, return the result of running roots operation</span>
<span class="line-modified">!     // using its children, expressed in the results canonical unit.</span>
<span class="line-modified">!     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-modified">!         auto&amp; calcOperationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());</span>
<span class="line-modified">!         // Don&#39;t simplify at the root, otherwise we lose track of the operation for serialization.</span>
<span class="line-added">+         if (calcOperationNode.children().size() == 1 &amp;&amp; depth)</span>
<span class="line-added">+             return WTFMove(calcOperationNode.children()[0]);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (calcOperationNode.isCalcSumNode()) {</span>
<span class="line-added">+             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Add);</span>
<span class="line-added">+             calcOperationNode.combineChildren();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (calcOperationNode.isCalcProductNode()) {</span>
<span class="line-added">+             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Multiply);</span>
<span class="line-added">+             calcOperationNode.combineChildren();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (calcOperationNode.isMinOrMaxNode())</span>
<span class="line-added">+             calcOperationNode.combineChildren();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If only one child remains, return the child (except at the root).</span>
<span class="line-added">+         auto shouldCombineParentWithOnlyChild = [](const CSSCalcOperationNode&amp; parent, int depth)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             if (parent.children().size() != 1)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Always simplify below the root.</span>
<span class="line-added">+             if (depth)</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // At the root, preserve the root function by only merging nodes with the same function.</span>
<span class="line-added">+             auto&amp; child = parent.children().first();</span>
<span class="line-added">+             if (!is&lt;CSSCalcOperationNode&gt;(child))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto parentFunction = functionFromOperator(parent.calcOperator());</span>
<span class="line-added">+             auto childFunction = functionFromOperator(downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator());</span>
<span class="line-added">+             return childFunction == parentFunction;</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (shouldCombineParentWithOnlyChild(calcOperationNode, depth))</span>
<span class="line-added">+             return WTFMove(calcOperationNode.children().first());</span>
<span class="line-added">+ </span>
<span class="line-added">+         return WTFMove(rootNode);</span>
      }
  
<span class="line-modified">!     if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {</span>
<span class="line-modified">!         auto&amp; childNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get()).child();</span>
<span class="line-modified">!         // If roots child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).</span>
<span class="line-modified">!         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {</span>
<span class="line-added">+             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).negate();</span>
<span class="line-added">+             return childNode;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If roots child is a Negate node, return the childs child.</span>
<span class="line-added">+         if (is&lt;CSSCalcNegateNode&gt;(childNode))</span>
<span class="line-added">+             return downcast&lt;CSSCalcNegateNode&gt;(childNode).child();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return WTFMove(rootNode);</span>
      }
  
<span class="line-modified">!     if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {</span>
<span class="line-modified">!         auto&amp; childNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get()).child();</span>
<span class="line-added">+         // If roots child is a number (not a percentage or dimension) return the reciprocal of the childs value.</span>
<span class="line-added">+         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {</span>
<span class="line-added">+             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).invert();</span>
<span class="line-added">+             return childNode;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If roots child is an Invert node, return the childs child.</span>
<span class="line-added">+         if (is&lt;CSSCalcInvertNode&gt;(childNode))</span>
<span class="line-added">+             return downcast&lt;CSSCalcInvertNode&gt;(childNode).child();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return WTFMove(rootNode);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return WTFMove(rootNode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CSSUnitType CSSCalcOperationNode::primitiveType() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto unitCategory = category();</span>
<span class="line-added">+     switch (unitCategory) {</span>
<span class="line-added">+     case CalculationCategory::Number:</span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
          for (auto&amp; child : m_children)
<span class="line-modified">!             ASSERT(child-&gt;category() == CalculationCategory::Number);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         return CSSUnitType::CSS_NUMBER;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case CalculationCategory::Percent: {</span>
<span class="line-added">+         if (m_children.isEmpty())</span>
<span class="line-added">+             return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_children.size() == 2) {</span>
<span class="line-added">+             if (m_children[0]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-added">+                 return m_children[1]-&gt;primitiveType();</span>
<span class="line-added">+             if (m_children[1]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-added">+                 return m_children[0]-&gt;primitiveType();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         CSSUnitType firstType = m_children[0]-&gt;primitiveType();</span>
<span class="line-added">+         for (auto&amp; child : m_children) {</span>
<span class="line-added">+             if (firstType != child-&gt;primitiveType())</span>
<span class="line-added">+                 return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return firstType;</span>
      }
  
<span class="line-modified">!     case CalculationCategory::Length:</span>
<span class="line-modified">!     case CalculationCategory::Angle:</span>
<span class="line-modified">!     case CalculationCategory::Time:</span>
<span class="line-modified">!     case CalculationCategory::Frequency:</span>
<span class="line-modified">!         if (m_children.size() == 1)</span>
<span class="line-modified">!             return m_children.first()-&gt;primitiveType();</span>
<span class="line-modified">!         return canonicalUnitTypeForCalculationCategory(unitCategory);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     case CalculationCategory::PercentLength:</span>
<span class="line-modified">!     case CalculationCategory::PercentNumber:</span>
<span class="line-modified">!     case CalculationCategory::Other:</span>
<span class="line-modified">!         return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     ASSERT_NOT_REACHED();</span>
<span class="line-modified">!     return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcOperationNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-modified">!     nodes.reserveInitialCapacity(m_children.size());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (auto&amp; child : m_children) {</span>
<span class="line-modified">!         auto node = child-&gt;createCalcExpression(conversionData);</span>
<span class="line-modified">!         if (!node)</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-added">+         nodes.uncheckedAppend(WTFMove(node));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(nodes), m_operator);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcOperationNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool allowNumbers = calcOperator() == CalcOperator::Multiply;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return evaluate(m_children.map([&amp;] (auto&amp; child) {</span>
<span class="line-added">+         CSSUnitType childType = unitType;</span>
<span class="line-added">+         if (allowNumbers &amp;&amp; unitType != CSSUnitType::CSS_NUMBER &amp;&amp; child-&gt;primitiveType() == CSSUnitType::CSS_NUMBER)</span>
<span class="line-added">+             childType = CSSUnitType::CSS_NUMBER;</span>
<span class="line-added">+         return child-&gt;doubleValue(childType);</span>
<span class="line-added">+     }));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcOperationNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return evaluate(m_children.map([&amp;] (auto&amp; child) {</span>
<span class="line-added">+         return child-&gt;computeLengthPx(conversionData);</span>
<span class="line-added">+     }));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcOperationNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; child : m_children)</span>
<span class="line-added">+         child-&gt;collectDirectComputationalDependencies(values);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcOperationNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; child : m_children)</span>
<span class="line-added">+         child-&gt;collectDirectRootComputationalDependencies(values);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcOperationNode::buildCSSText(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto shouldOutputEnclosingCalc = [](const CSSCalcExpressionNode&amp; rootNode) {</span>
<span class="line-added">+         if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-added">+             auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode);</span>
<span class="line-added">+             return operationNode.isCalcSumNode() || operationNode.isCalcProductNode();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool outputCalc = shouldOutputEnclosingCalc(node);</span>
<span class="line-added">+     if (outputCalc)</span>
<span class="line-added">+         builder.append(&quot;calc(&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     buildCSSTextRecursive(node, builder, GroupingParens::Omit);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (outputCalc)</span>
<span class="line-added">+         builder.append(&#39;)&#39;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const char* functionPrefixForOperator(CalcOperator op)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (op) {</span>
<span class="line-added">+     case CalcOperator::Add:</span>
<span class="line-added">+     case CalcOperator::Subtract:</span>
<span class="line-added">+     case CalcOperator::Multiply:</span>
<span class="line-added">+     case CalcOperator::Divide:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return &quot;&quot;;</span>
<span class="line-added">+     case CalcOperator::Min: return &quot;min(&quot;;</span>
<span class="line-added">+     case CalcOperator::Max: return &quot;max(&quot;;</span>
<span class="line-added">+     case CalcOperator::Clamp: return &quot;clamp(&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return &quot;&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // &lt;https://drafts.csswg.org/css-values-4/#serialize-a-calculation-tree&gt;</span>
<span class="line-added">+ void CSSCalcOperationNode::buildCSSTextRecursive(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder, GroupingParens parens)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // If root is a numeric value, or a non-math function, serialize root per the normal rules for it and return the result.</span>
<span class="line-added">+     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node)) {</span>
<span class="line-added">+         auto&amp; valueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(node);</span>
<span class="line-added">+         builder.append(valueNode.customCSSText());</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (is&lt;CSSCalcOperationNode&gt;(node)) {</span>
<span class="line-added">+         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (operationNode.isCalcSumNode()) {</span>
<span class="line-added">+             // If root is a Sum node, let s be a string initially containing &quot;(&quot;.</span>
<span class="line-added">+             if (parens == GroupingParens::Include)</span>
<span class="line-added">+                 builder.append(&#39;(&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Simplification already sorted children.</span>
<span class="line-added">+             auto&amp; children = operationNode.children();</span>
<span class="line-added">+             ASSERT(children.size());</span>
<span class="line-added">+             // Serialize roots first child, and append it to s.</span>
<span class="line-added">+             buildCSSTextRecursive(children.first(), builder);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // For each child of root beyond the first:</span>
<span class="line-added">+             // If child is a Negate node, append &quot; - &quot; to s, then serialize the Negates child and append the result to s.</span>
<span class="line-added">+             // If child is a negative numeric value, append &quot; - &quot; to s, then serialize the negation of child as normal and append the result to s.</span>
<span class="line-added">+             // Otherwise, append &quot; + &quot; to s, then serialize child and append the result to s.</span>
<span class="line-added">+             for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">+                 auto&amp; child = children[i];</span>
<span class="line-added">+                 if (is&lt;CSSCalcNegateNode&gt;(child)) {</span>
<span class="line-added">+                     builder.append(&quot; - &quot;);</span>
<span class="line-added">+                     buildCSSTextRecursive(downcast&lt;CSSCalcNegateNode&gt;(child.get()).child(), builder);</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (is&lt;CSSCalcPrimitiveValueNode&gt;(child)) {</span>
<span class="line-added">+                     auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(child.get());</span>
<span class="line-added">+                     if (primitiveValueNode.isNegative()) {</span>
<span class="line-added">+                         builder.append(&quot; - &quot;);</span>
<span class="line-added">+                         // Serialize the negation of child.</span>
<span class="line-added">+                         auto unitType = primitiveValueNode.value().primitiveType();</span>
<span class="line-added">+                         builder.append(0 - primitiveValueNode.value().doubleValue(), CSSPrimitiveValue::unitTypeString(unitType));</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 builder.append(&quot; + &quot;);</span>
<span class="line-added">+                 buildCSSTextRecursive(child, builder);</span>
              }
<span class="line-modified">! </span>
<span class="line-added">+             if (parens == GroupingParens::Include)</span>
<span class="line-added">+                 builder.append(&#39;)&#39;);</span>
<span class="line-added">+             return;</span>
          }
  
<span class="line-modified">!         if (operationNode.isCalcProductNode()) {</span>
<span class="line-added">+             // If root is a Product node, let s be a string initially containing &quot;(&quot;.</span>
<span class="line-added">+             if (parens == GroupingParens::Include)</span>
<span class="line-added">+                 builder.append(&#39;(&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Simplification already sorted children.</span>
<span class="line-added">+             auto&amp; children = operationNode.children();</span>
<span class="line-added">+             ASSERT(children.size());</span>
<span class="line-added">+             // Serialize roots first child, and append it to s.</span>
<span class="line-added">+             buildCSSTextRecursive(children.first(), builder);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // For each child of root beyond the first:</span>
<span class="line-added">+             // If child is an Invert node, append &quot; / &quot; to s, then serialize the Inverts child and append the result to s.</span>
<span class="line-added">+             // Otherwise, append &quot; * &quot; to s, then serialize child and append the result to s.</span>
<span class="line-added">+             for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">+                 auto&amp; child = children[i];</span>
<span class="line-added">+                 if (is&lt;CSSCalcInvertNode&gt;(child)) {</span>
<span class="line-added">+                     builder.append(&quot; / &quot;);</span>
<span class="line-added">+                     buildCSSTextRecursive(downcast&lt;CSSCalcInvertNode&gt;(child.get()).child(), builder);</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 builder.append(&quot; * &quot;);</span>
<span class="line-added">+                 buildCSSTextRecursive(child, builder);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (parens == GroupingParens::Include)</span>
<span class="line-added">+                 builder.append(&#39;)&#39;);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If root is anything but a Sum, Negate, Product, or Invert node, serialize a math function for the</span>
<span class="line-added">+         // function corresponding to the node type, treating the nodes children as the functions</span>
<span class="line-added">+         // comma-separated calculation arguments, and return the result.</span>
<span class="line-added">+         builder.append(functionPrefixForOperator(operationNode.calcOperator()));</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto&amp; children = operationNode.children();</span>
<span class="line-added">+         ASSERT(children.size());</span>
<span class="line-added">+         buildCSSTextRecursive(children.first(), builder, GroupingParens::Omit);</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">+             builder.append(&quot;, &quot;);</span>
<span class="line-added">+             buildCSSTextRecursive(children[i], builder, GroupingParens::Omit);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         builder.append(&#39;)&#39;);</span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-modified">!     if (is&lt;CSSCalcNegateNode&gt;(node)) {</span>
<span class="line-modified">!         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(node);</span>
<span class="line-modified">!         // If root is a Negate node, let s be a string initially containing &quot;(-1 * &quot;.</span>
<span class="line-modified">!         builder.append(&quot;-1 *&quot;);</span>
<span class="line-modified">!         buildCSSTextRecursive(negateNode.child(), builder);</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (is&lt;CSSCalcInvertNode&gt;(node)) {</span>
<span class="line-added">+         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(node);</span>
<span class="line-added">+         // If root is an Invert node, let s be a string initially containing &quot;(1 / &quot;.</span>
<span class="line-added">+         builder.append(&quot;1 / &quot;);</span>
<span class="line-added">+         buildCSSTextRecursive(invertNode.child(), builder);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcOperationNode::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;calc operation &quot; &lt;&lt; m_operator &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextStream::GroupScope scope(ts);</span>
<span class="line-added">+     ts &lt;&lt; m_children.size() &lt;&lt; &quot; children&quot;;</span>
<span class="line-added">+     for (auto&amp; child : m_children)</span>
<span class="line-added">+         ts.dumpProperty(&quot;node&quot;, child);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CSSCalcOperationNode::equals(const CSSCalcExpressionNode&amp; exp) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (type() != exp.type())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const CSSCalcOperationNode&amp; other = static_cast&lt;const CSSCalcOperationNode&amp;&gt;(exp);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_children.size() != other.m_children.size() || m_operator != other.m_operator)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">+         if (!compareCSSValue(m_children[i], other.m_children[i]))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcOperationNode::evaluateOperator(CalcOperator op, const Vector&lt;double&gt;&amp; children)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (op) {</span>
<span class="line-added">+     case CalcOperator::Add: {</span>
<span class="line-added">+         double sum = 0;</span>
<span class="line-added">+         for (auto&amp; child : children)</span>
<span class="line-added">+             sum += child;</span>
<span class="line-added">+         return sum;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CalcOperator::Subtract:</span>
<span class="line-added">+         ASSERT(children.size() == 2);</span>
<span class="line-added">+         return children[0] - children[1];</span>
<span class="line-added">+     case CalcOperator::Multiply: {</span>
<span class="line-added">+         double product = 1;</span>
<span class="line-added">+         for (auto&amp; child : children)</span>
<span class="line-added">+             product *= child;</span>
<span class="line-added">+         return product;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CalcOperator::Divide:</span>
<span class="line-added">+         ASSERT(children.size() == 1 || children.size() == 2);</span>
<span class="line-added">+         if (children.size() == 1)</span>
<span class="line-added">+             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">+         return children[0] / children[1];</span>
<span class="line-added">+     case CalcOperator::Min: {</span>
<span class="line-added">+         if (children.isEmpty())</span>
<span class="line-added">+             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">+         double minimum = children[0];</span>
<span class="line-added">+         for (auto child : children)</span>
<span class="line-added">+             minimum = std::min(minimum, child);</span>
<span class="line-added">+         return minimum;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CalcOperator::Max: {</span>
<span class="line-added">+         if (children.isEmpty())</span>
<span class="line-added">+             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">+         double maximum = children[0];</span>
<span class="line-added">+         for (auto child : children)</span>
<span class="line-added">+             maximum = std::max(maximum, child);</span>
<span class="line-added">+         return maximum;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CalcOperator::Clamp: {</span>
<span class="line-added">+         if (children.size() != 3)</span>
<span class="line-added">+             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">+         double min = children[0];</span>
<span class="line-added">+         double value = children[1];</span>
<span class="line-added">+         double max = children[2];</span>
<span class="line-added">+         return std::max(min, std::min(value, max));</span>
      }
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
  
  
<span class="line-modified">! class CSSCalcExpressionNodeParser {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     explicit CSSCalcExpressionNodeParser(CalculationCategory destinationCategory)</span>
<span class="line-added">+         : m_destinationCategory(destinationCategory)</span>
<span class="line-added">+     { }</span>
  
<span class="line-modified">!     RefPtr&lt;CSSCalcExpressionNode&gt; parseCalc(CSSParserTokenRange, CSSValueID function);</span>
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     char operatorValue(const CSSParserToken&amp; token)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (token.type() == DelimiterToken)</span>
<span class="line-modified">!             return token.delimiter();</span>
<span class="line-added">+         return 0;</span>
      }
  
<span class="line-modified">!     bool parseValue(CSSParserTokenRange&amp;, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">+     bool parseValueTerm(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">+     bool parseCalcFunction(CSSParserTokenRange&amp;, CSSValueID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">+     bool parseCalcSum(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">+     bool parseCalcProduct(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">+     bool parseCalcValue(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
  
<span class="line-modified">!     CalculationCategory m_destinationCategory;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! // &lt;https://drafts.csswg.org/css-values-4/#calc-syntax&gt;:</span>
<span class="line-modified">! // &lt;calc()&gt;  = calc( &lt;calc-sum&gt; )</span>
<span class="line-modified">! // &lt;min()&gt;   = min( &lt;calc-sum&gt;# )</span>
<span class="line-modified">! // &lt;max()&gt;   = max( &lt;calc-sum&gt;# )</span>
<span class="line-modified">! // &lt;clamp()&gt; = clamp( &lt;calc-sum&gt;#{3} )</span>
<span class="line-modified">! // &lt;sin()&gt;   = sin( &lt;calc-sum&gt; )</span>
<span class="line-modified">! // &lt;cos()&gt;   = cos( &lt;calc-sum&gt; )</span>
<span class="line-modified">! // &lt;tan()&gt;   = tan( &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;asin()&gt;  = asin( &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;acos()&gt;  = acos( &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;atan()&gt;  = atan( &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;atan2()&gt; = atan2( &lt;calc-sum&gt;, &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;pow()&gt;   = pow( &lt;calc-sum&gt;, &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;sqrt()&gt;  = sqrt( &lt;calc-sum&gt; )</span>
<span class="line-added">+ // &lt;hypot()&gt; = hypot( &lt;calc-sum&gt;# )</span>
<span class="line-added">+ // &lt;calc-sum&gt; = &lt;calc-product&gt; [ [ &#39;+&#39; | &#39;-&#39; ] &lt;calc-product&gt; ]*</span>
<span class="line-added">+ // &lt;calc-product&gt; = &lt;calc-value&gt; [ [ &#39;*&#39; | &#39;/&#39; ] &lt;calc-value&gt; ]*</span>
<span class="line-added">+ // &lt;calc-value&gt; = &lt;number&gt; | &lt;dimension&gt; | &lt;percentage&gt; | ( &lt;calc-sum&gt; )</span>
<span class="line-added">+ RefPtr&lt;CSSCalcExpressionNode&gt; CSSCalcExpressionNodeParser::parseCalc(CSSParserTokenRange tokens, CSSValueID function)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     tokens.consumeWhitespace();</span>
  
<span class="line-modified">!     RefPtr&lt;CSSCalcExpressionNode&gt; result;</span>
<span class="line-modified">!     bool ok = parseCalcFunction(tokens, function, 0, result);</span>
<span class="line-modified">!     if (!ok || !tokens.atEnd())</span>
<span class="line-modified">!         return nullptr;</span>
  
<span class="line-modified">!     if (!result)</span>
          return nullptr;
  
<span class="line-modified">!     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc &quot; &lt;&lt; prettyPrintNode(*result));</span>
  
<span class="line-modified">!     result = CSSCalcOperationNode::simplify(result.releaseNonNull());</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc - after simplification &quot; &lt;&lt; prettyPrintNode(*result));</span>
<span class="line-modified">! </span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ enum ParseState {</span>
<span class="line-added">+     OK,</span>
<span class="line-added">+     TooDeep,</span>
<span class="line-added">+     NoMoreTokens</span>
  };
  
<span class="line-modified">! static ParseState checkDepthAndIndex(int depth, CSSParserTokenRange tokens)</span>
  {
      if (tokens.atEnd())
          return NoMoreTokens;
<span class="line-modified">!     if (depth &gt; maxExpressionDepth) {</span>
<span class="line-added">+         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Depth &quot; &lt;&lt; depth &lt;&lt; &quot; exceeded maxExpressionDepth &quot; &lt;&lt; maxExpressionDepth);</span>
          return TooDeep;
<span class="line-added">+     }</span>
      return OK;
  }
  
<span class="line-modified">! bool CSSCalcExpressionNodeParser::parseCalcFunction(CSSParserTokenRange&amp; tokens, CSSValueID functionID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     // &quot;arguments&quot; refers to things between commas.</span>
<span class="line-modified">!     unsigned minArgumentCount = 1;</span>
<span class="line-modified">!     Optional&lt;unsigned&gt; maxArgumentCount;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     switch (functionID) {</span>
<span class="line-modified">!     case CSSValueMin:</span>
<span class="line-modified">!     case CSSValueMax:</span>
<span class="line-modified">!         maxArgumentCount = WTF::nullopt;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case CSSValueClamp:</span>
<span class="line-modified">!         minArgumentCount = 3;</span>
<span class="line-modified">!         maxArgumentCount = 3;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSValueCalc:</span>
<span class="line-added">+         maxArgumentCount = 1;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot.</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         break;</span>
      }
  
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>
  
<span class="line-modified">!     bool requireComma = false;</span>
<span class="line-modified">!     unsigned argumentCount = 0;</span>
<span class="line-modified">!     while (!tokens.atEnd()) {</span>
<span class="line-modified">!         tokens.consumeWhitespace();</span>
<span class="line-modified">!         if (requireComma) {</span>
<span class="line-modified">!             if (tokens.consume().type() != CommaToken)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             tokens.consumeWhitespace();</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         RefPtr&lt;CSSCalcExpressionNode&gt; node;</span>
<span class="line-modified">!         if (!parseCalcSum(tokens, depth, node))</span>
              return false;
  
<span class="line-modified">!         ++argumentCount;</span>
<span class="line-modified">!         if (maxArgumentCount &amp;&amp; argumentCount &gt; maxArgumentCount.value())</span>
              return false;
  
<span class="line-modified">!         nodes.append(node.releaseNonNull());</span>
<span class="line-modified">!         requireComma = true;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (argumentCount &lt; minArgumentCount)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (functionID) {</span>
<span class="line-added">+     case CSSValueMin:</span>
<span class="line-added">+         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Min, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSValueMax:</span>
<span class="line-added">+         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Max, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSValueClamp:</span>
<span class="line-added">+         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Clamp, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case CSSValueWebkitCalc:</span>
<span class="line-added">+     case CSSValueCalc:</span>
<span class="line-added">+         result = CSSCalcOperationNode::createSum(WTFMove(nodes));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         break;</span>
      }
  
<span class="line-modified">!     return !!result;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool CSSCalcExpressionNodeParser::parseValue(CSSParserTokenRange&amp; tokens, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     CSSParserToken token = tokens.consumeIncludingWhitespace();</span>
<span class="line-added">+     if (!(token.type() == NumberToken || token.type() == PercentageToken || token.type() == DimensionToken))</span>
<span class="line-added">+         return false;</span>
  
<span class="line-modified">!     auto type = token.unitType();</span>
<span class="line-added">+     if (calcUnitCategory(type) == CalculationCategory::Other)</span>
<span class="line-added">+         return false;</span>
  
<span class="line-modified">!     result = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(token.numericValue(), type));</span>
  
<span class="line-modified">!     return true;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! bool CSSCalcExpressionNodeParser::parseCalcValue(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto findFunctionId = [&amp;](CSSValueID&amp; functionId) {</span>
<span class="line-added">+         if (tokens.peek().type() == LeftParenthesisToken) {</span>
<span class="line-added">+             functionId = CSSValueCalc;</span>
<span class="line-added">+             return true;</span>
          }
  
<span class="line-modified">!         functionId = tokens.peek().functionId();</span>
<span class="line-added">+         return CSSCalcValue::isCalcFunction(functionId);</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     CSSValueID functionId;</span>
<span class="line-added">+     if (findFunctionId(functionId)) {</span>
<span class="line-added">+         CSSParserTokenRange innerRange = tokens.consumeBlock();</span>
<span class="line-added">+         tokens.consumeWhitespace();</span>
<span class="line-added">+         innerRange.consumeWhitespace();</span>
<span class="line-added">+         return parseCalcFunction(innerRange, functionId, depth + 1, result);</span>
      }
  
<span class="line-modified">!     return parseValue(tokens, result);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! bool CSSCalcExpressionNodeParser::parseCalcProduct(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-added">+         return false;</span>
  
<span class="line-modified">!     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;</span>
<span class="line-modified">!     if (!parseCalcValue(tokens, depth, firstValue))</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (!tokens.atEnd()) {</span>
<span class="line-added">+         char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-added">+         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Multiply) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Divide))</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         tokens.consumeIncludingWhitespace();</span>
  
<span class="line-modified">!         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;</span>
<span class="line-added">+         if (!parseCalcValue(tokens, depth, nextValue) || !nextValue)</span>
<span class="line-added">+             return false;</span>
  
<span class="line-modified">!         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Divide))</span>
<span class="line-modified">!             nextValue = CSSCalcInvertNode::create(nextValue.releaseNonNull());</span>
  
<span class="line-modified">!         if (firstValue)</span>
<span class="line-added">+             nodes.append(firstValue.releaseNonNull());</span>
<span class="line-added">+ </span>
<span class="line-added">+         nodes.append(nextValue.releaseNonNull());</span>
      }
  
<span class="line-modified">!     if (nodes.isEmpty()) {</span>
<span class="line-modified">!         result = WTFMove(firstValue);</span>
<span class="line-modified">!         return !!result;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     result = CSSCalcOperationNode::createProduct(WTFMove(nodes));</span>
<span class="line-modified">!     return !!result;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool CSSCalcExpressionNodeParser::parseCalcSum(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;</span>
<span class="line-modified">!     if (!parseCalcProduct(tokens, depth, firstValue))</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>
  
<span class="line-modified">!     while (!tokens.atEnd()) {</span>
<span class="line-modified">!         char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-modified">!         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Add) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Subtract))</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!         if ((&amp;tokens.peek() - 1)-&gt;type() != WhitespaceToken)</span>
<span class="line-added">+             return false; // calc(1px+ 2px) is invalid</span>
  
<span class="line-modified">!         tokens.consume();</span>
<span class="line-modified">!         if (tokens.peek().type() != WhitespaceToken)</span>
<span class="line-modified">!             return false; // calc(1px +2px) is invalid</span>
  
<span class="line-modified">!         tokens.consumeIncludingWhitespace();</span>
  
<span class="line-modified">!         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;</span>
<span class="line-modified">!         if (!parseCalcProduct(tokens, depth, nextValue) || !nextValue)</span>
<span class="line-modified">!             return false;</span>
  
<span class="line-modified">!         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Subtract))</span>
<span class="line-modified">!             nextValue = CSSCalcNegateNode::create(nextValue.releaseNonNull());</span>
  
<span class="line-modified">!         if (firstValue)</span>
<span class="line-modified">!             nodes.append(firstValue.releaseNonNull());</span>
  
<span class="line-modified">!         nodes.append(nextValue.releaseNonNull());</span>
      }
  
<span class="line-modified">!     if (nodes.isEmpty()) {</span>
<span class="line-modified">!         result = WTFMove(firstValue);</span>
<span class="line-modified">!         return !!result;</span>
      }
  
<span class="line-modified">!     result = CSSCalcOperationNode::createSum(WTFMove(nodes));</span>
<span class="line-modified">!     return !!result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline RefPtr&lt;CSSCalcOperationNode&gt; createBlendHalf(const Length&amp; length, const RenderStyle&amp; style, float progress)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return CSSCalcOperationNode::create(CalcOperator::Multiply, createCSS(length, style),</span>
<span class="line-added">+         CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER)));</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; createCSS(const Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp; nodes, const RenderStyle&amp; style)</span>
  {
<span class="line-modified">!     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;</span>
<span class="line-modified">!     values.reserveInitialCapacity(nodes.size());</span>
<span class="line-added">+     for (auto&amp; node : nodes) {</span>
<span class="line-added">+         auto cssNode = createCSS(*node, style);</span>
<span class="line-added">+         if (!cssNode)</span>
<span class="line-added">+             return { };</span>
<span class="line-added">+         values.uncheckedAppend(cssNode.releaseNonNull());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return values;</span>
  }
  
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp; node, const RenderStyle&amp; style)
  {
      switch (node.type()) {
      case CalcExpressionNodeType::Number: {
<span class="line-modified">!         float value = downcast&lt;CalcExpressionNumber&gt;(node).value(); // double?</span>
<span class="line-modified">!         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(value, CSSUnitType::CSS_NUMBER));</span>
      }
      case CalcExpressionNodeType::Length:
<span class="line-modified">!         return createCSS(downcast&lt;CalcExpressionLength&gt;(node).length(), style);</span>
<span class="line-added">+ </span>
<span class="line-added">+     case CalcExpressionNodeType::Negation: {</span>
<span class="line-added">+         auto childNode = createCSS(*downcast&lt;CalcExpressionNegation&gt;(node).child(), style);</span>
<span class="line-added">+         if (!childNode)</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         return CSSCalcNegateNode::create(childNode.releaseNonNull());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case CalcExpressionNodeType::Inversion: {</span>
<span class="line-added">+         auto childNode = createCSS(*downcast&lt;CalcExpressionInversion&gt;(node).child(), style);</span>
<span class="line-added">+         if (!childNode)</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         return CSSCalcInvertNode::create(childNode.releaseNonNull());</span>
<span class="line-added">+     }</span>
      case CalcExpressionNodeType::Operation: {
<span class="line-modified">!         auto&amp; operationNode = downcast&lt;CalcExpressionOperation&gt;(node);</span>
          auto&amp; operationChildren = operationNode.children();
          CalcOperator op = operationNode.getOperator();
<span class="line-modified">! </span>
<span class="line-added">+         switch (op) {</span>
<span class="line-added">+         case CalcOperator::Add: {</span>
<span class="line-added">+             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">+             if (children.isEmpty())</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             return CSSCalcOperationNode::createSum(WTFMove(children));</span>
<span class="line-added">+         } case CalcOperator::Subtract: {</span>
<span class="line-added">+             ASSERT(operationChildren.size() == 2);</span>
<span class="line-added">+ </span>
              Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
              values.reserveInitialCapacity(operationChildren.size());
<span class="line-modified">! </span>
<span class="line-modified">!             auto firstChild = createCSS(*operationChildren[0], style);</span>
<span class="line-modified">!             if (!firstChild)</span>
<span class="line-modified">!                 return nullptr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             auto secondChild = createCSS(*operationChildren[1], style);</span>
<span class="line-modified">!             if (!secondChild)</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             auto negateNode = CSSCalcNegateNode::create(secondChild.releaseNonNull());</span>
<span class="line-added">+ </span>
<span class="line-added">+             values.append(firstChild.releaseNonNull());</span>
<span class="line-added">+             values.append(WTFMove(negateNode));</span>
<span class="line-added">+ </span>
<span class="line-added">+             return CSSCalcOperationNode::createSum(WTFMove(values));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case CalcOperator::Multiply: {</span>
<span class="line-added">+             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">+             if (children.isEmpty())</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             return CSSCalcOperationNode::createProduct(WTFMove(children));</span>
          }
<span class="line-added">+         case CalcOperator::Divide: {</span>
<span class="line-added">+             ASSERT(operationChildren.size() == 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;</span>
<span class="line-added">+             values.reserveInitialCapacity(operationChildren.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto firstChild = createCSS(*operationChildren[0], style);</span>
<span class="line-added">+             if (!firstChild)</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto secondChild = createCSS(*operationChildren[1], style);</span>
<span class="line-added">+             if (!secondChild)</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             auto invertNode = CSSCalcInvertNode::create(secondChild.releaseNonNull());</span>
  
<span class="line-modified">!             values.append(firstChild.releaseNonNull());</span>
<span class="line-modified">!             values.append(WTFMove(invertNode));</span>
  
<span class="line-added">+             return CSSCalcOperationNode::createProduct(createCSS(operationChildren, style));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case CalcOperator::Min:</span>
<span class="line-added">+         case CalcOperator::Max:</span>
<span class="line-added">+         case CalcOperator::Clamp: {</span>
<span class="line-added">+             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">+             if (children.isEmpty())</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             return CSSCalcOperationNode::createMinOrMaxOrClamp(op, WTFMove(children), CalculationCategory::Other);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         }</span>
          return nullptr;
      }
      case CalcExpressionNodeType::BlendLength: {
          // FIXME: (http://webkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.
<span class="line-modified">!         auto&amp; blend = downcast&lt;CalcExpressionBlendLength&gt;(node);</span>
          float progress = blend.progress();
<span class="line-modified">!         return CSSCalcOperationNode::create(CalcOperator::Add, createBlendHalf(blend.from(), style, 1 - progress), createBlendHalf(blend.to(), style, progress));</span>
      }
      case CalcExpressionNodeType::Undefined:
          ASSERT_NOT_REACHED();
      }
      return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 944,11 ***</span>
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp; length, const RenderStyle&amp; style)
  {
      switch (length.type()) {
      case Percent:
      case Fixed:
<span class="line-modified">!         return CSSCalcPrimitiveValue::create(CSSPrimitiveValue::create(length, style), length.value() == trunc(length.value()));</span>
      case Calculated:
          return createCSS(length.calculationValue().expression(), style);
      case Auto:
      case Intrinsic:
      case MinIntrinsic:
<span class="line-new-header">--- 2020,11 ---</span>
  static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp; length, const RenderStyle&amp; style)
  {
      switch (length.type()) {
      case Percent:
      case Fixed:
<span class="line-modified">!         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(length, style));</span>
      case Calculated:
          return createCSS(length.calculationValue().expression(), style);
      case Auto:
      case Intrinsic:
      case MinIntrinsic:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 961,23 ***</span>
          ASSERT_NOT_REACHED();
      }
      return nullptr;
  }
  
  RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(CSSValueID function, const CSSParserTokenRange&amp; tokens, CalculationCategory destinationCategory, ValueRange range)
  {
      CSSCalcExpressionNodeParser parser(destinationCategory);
      auto expression = parser.parseCalc(tokens, function);
      if (!expression)
          return nullptr;
<span class="line-modified">!     return adoptRef(new CSSCalcValue(expression.releaseNonNull(), range != ValueRangeAll));</span>
  }
  
  RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(const CalculationValue&amp; value, const RenderStyle&amp; style)
  {
      auto expression = createCSS(value.expression(), style);
      if (!expression)
          return nullptr;
<span class="line-modified">!     return adoptRef(new CSSCalcValue(expression.releaseNonNull(), value.shouldClampToNonNegative()));</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 2037,106 ---</span>
          ASSERT_NOT_REACHED();
      }
      return nullptr;
  }
  
<span class="line-added">+ String CSSCalcValue::customCSSText() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     StringBuilder builder;</span>
<span class="line-added">+     CSSCalcOperationNode::buildCSSText(m_expression.get(), builder);</span>
<span class="line-added">+     return builder.toString();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CSSCalcValue::equals(const CSSCalcValue&amp; other) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return compareCSSValue(m_expression, other.m_expression);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline double CSSCalcValue::clampToPermittedRange(double value) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_shouldClampToNonNegative &amp;&amp; value &lt; 0 ? 0 : value;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcValue::doubleValue() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return clampToPermittedRange(m_expression-&gt;doubleValue(primitiveType()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double CSSCalcValue::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return clampToPermittedRange(m_expression-&gt;computeLengthPx(conversionData));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CSSCalcValue::isCalcFunction(CSSValueID functionId)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (functionId) {</span>
<span class="line-added">+     case CSSValueCalc:</span>
<span class="line-added">+     case CSSValueWebkitCalc:</span>
<span class="line-added">+     case CSSValueMin:</span>
<span class="line-added">+     case CSSValueMax:</span>
<span class="line-added">+     case CSSValueClamp:</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSCalcValue::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;CSSCalcValue&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     TextStream multilineStream;</span>
<span class="line-added">+     multilineStream.setIndent(ts.indent() + 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     multilineStream.dumpProperty(&quot;should clamp non-negative&quot;, m_shouldClampToNonNegative);</span>
<span class="line-added">+     multilineStream.dumpProperty(&quot;expression&quot;, m_expression.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     ts &lt;&lt; multilineStream.release();</span>
<span class="line-added">+     ts &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(CSSValueID function, const CSSParserTokenRange&amp; tokens, CalculationCategory destinationCategory, ValueRange range)
  {
      CSSCalcExpressionNodeParser parser(destinationCategory);
      auto expression = parser.parseCalc(tokens, function);
      if (!expression)
          return nullptr;
<span class="line-modified">!     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), range != ValueRangeAll));</span>
<span class="line-added">+     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create &quot; &lt;&lt; *result);</span>
<span class="line-added">+     return result;</span>
  }
  
  RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(const CalculationValue&amp; value, const RenderStyle&amp; style)
  {
      auto expression = createCSS(value.expression(), style);
      if (!expression)
          return nullptr;
<span class="line-modified">!     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), value.shouldClampToNonNegative()));</span>
<span class="line-added">+     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create from CalculationValue: &quot; &lt;&lt; *result);</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalculationCategory category)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (category) {</span>
<span class="line-added">+     case CalculationCategory::Number: ts &lt;&lt; &quot;number&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Length: ts &lt;&lt; &quot;length&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Percent: ts &lt;&lt; &quot;percent&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::PercentNumber: ts &lt;&lt; &quot;percent-number&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::PercentLength: ts &lt;&lt; &quot;percent-length&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Angle: ts &lt;&lt; &quot;angle&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Time: ts &lt;&lt; &quot;time&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Frequency: ts &lt;&lt; &quot;frequency&quot;; break;</span>
<span class="line-added">+     case CalculationCategory::Other: ts &lt;&lt; &quot;other&quot;; break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ts;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcValue&amp; value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     value.dump(ts);</span>
<span class="line-added">+     return ts;</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="CSSBasicShapes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCalculationValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>