<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMBinding.h&quot;
 30 #include &quot;JSDOMConvertBase.h&quot;
 31 #include &quot;JSDOMConvertBufferSource.h&quot;
 32 #include &quot;JSDOMConvertInterface.h&quot;
 33 #include &quot;JSDOMConvertNull.h&quot;
 34 #include &lt;JavaScriptCore/IteratorOperations.h&gt;
 35 #include &lt;wtf/Variant.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 template&lt;typename ReturnType, bool enabled&gt;
 40 struct ConditionalReturner;
 41 
 42 template&lt;typename ReturnType&gt;
 43 struct ConditionalReturner&lt;ReturnType, true&gt; {
 44     template&lt;typename T&gt;
 45     static Optional&lt;ReturnType&gt; get(T&amp;&amp; value)
 46     {
 47         return ReturnType(std::forward&lt;T&gt;(value));
 48     }
 49 };
 50 
 51 template&lt;typename ReturnType&gt;
 52 struct ConditionalReturner&lt;ReturnType, false&gt; {
 53     template&lt;typename T&gt;
 54     static Optional&lt;ReturnType&gt; get(T&amp;&amp;)
 55     {
 56         return WTF::nullopt;
 57     }
 58 };
 59 
 60 template&lt;typename ReturnType, typename T, bool enabled&gt;
 61 struct ConditionalConverter;
 62 
 63 template&lt;typename ReturnType, typename T&gt;
 64 struct ConditionalConverter&lt;ReturnType, T, true&gt; {
 65     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSValue value)
 66     {
 67         return ReturnType(Converter&lt;T&gt;::convert(state, value));
 68     }
 69 };
 70 
 71 template&lt;typename ReturnType, typename T&gt;
 72 struct ConditionalConverter&lt;ReturnType, T, false&gt; {
 73     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSValue)
 74     {
 75         return WTF::nullopt;
 76     }
 77 };
 78 
 79 template&lt;typename ReturnType, typename T, bool enabled&gt;
 80 struct ConditionalSequenceConverter;
 81 
 82 template&lt;typename ReturnType, typename T&gt;
 83 struct ConditionalSequenceConverter&lt;ReturnType, T, true&gt; {
 84     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)
 85     {
 86         return ReturnType(Converter&lt;T&gt;::convert(state, object, method));
 87     }
 88 };
 89 
 90 template&lt;typename ReturnType, typename T&gt;
 91 struct ConditionalSequenceConverter&lt;ReturnType, T, false&gt; {
 92     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSObject*, JSC::JSValue)
 93     {
 94         return WTF::nullopt;
 95     }
 96 };
 97 
 98 namespace Detail {
 99 
100 template&lt;typename List, bool condition&gt;
101 struct ConditionalFront;
102 
103 template&lt;typename List&gt;
104 struct ConditionalFront&lt;List, true&gt; {
105     using type = brigand::front&lt;List&gt;;
106 };
107 
108 template&lt;typename List&gt;
109 struct ConditionalFront&lt;List, false&gt; {
110     using type = void;
111 };
112 
113 }
114 
115 template&lt;typename List, bool condition&gt;
116 using ConditionalFront = typename Detail::ConditionalFront&lt;List, condition&gt;::type;
117 
118 template&lt;typename... T&gt; struct Converter&lt;IDLUnion&lt;T...&gt;&gt; : DefaultConverter&lt;IDLUnion&lt;T...&gt;&gt; {
119     using Type = IDLUnion&lt;T...&gt;;
120     using TypeList = typename Type::TypeList;
121     using ReturnType = typename Type::ImplementationType;
122 
123     using NumericTypeList = brigand::filter&lt;TypeList, IsIDLNumber&lt;brigand::_1&gt;&gt;;
124     static constexpr size_t numberOfNumericTypes = brigand::size&lt;NumericTypeList&gt;::value;
125     static_assert(numberOfNumericTypes == 0 || numberOfNumericTypes == 1, &quot;There can be 0 or 1 numeric types in an IDLUnion.&quot;);
126     using NumericType = ConditionalFront&lt;NumericTypeList, numberOfNumericTypes != 0&gt;;
127 
128     using StringTypeList = brigand::filter&lt;TypeList, IsIDLStringOrEnumeration&lt;brigand::_1&gt;&gt;;
129     static constexpr size_t numberOfStringTypes = brigand::size&lt;StringTypeList&gt;::value;
130     static_assert(numberOfStringTypes == 0 || numberOfStringTypes == 1, &quot;There can be 0 or 1 string types in an IDLUnion.&quot;);
131     using StringType = ConditionalFront&lt;StringTypeList, numberOfStringTypes != 0&gt;;
132 
133     using SequenceTypeList = brigand::filter&lt;TypeList, IsIDLSequence&lt;brigand::_1&gt;&gt;;
134     static constexpr size_t numberOfSequenceTypes = brigand::size&lt;SequenceTypeList&gt;::value;
135     static_assert(numberOfSequenceTypes == 0 || numberOfSequenceTypes == 1, &quot;There can be 0 or 1 sequence types in an IDLUnion.&quot;);
136     using SequenceType = ConditionalFront&lt;SequenceTypeList, numberOfSequenceTypes != 0&gt;;
137 
138     using FrozenArrayTypeList = brigand::filter&lt;TypeList, IsIDLFrozenArray&lt;brigand::_1&gt;&gt;;
139     static constexpr size_t numberOfFrozenArrayTypes = brigand::size&lt;FrozenArrayTypeList&gt;::value;
140     static_assert(numberOfFrozenArrayTypes == 0 || numberOfFrozenArrayTypes == 1, &quot;There can be 0 or 1 FrozenArray types in an IDLUnion.&quot;);
141     using FrozenArrayType = ConditionalFront&lt;FrozenArrayTypeList, numberOfFrozenArrayTypes != 0&gt;;
142 
143     using DictionaryTypeList = brigand::filter&lt;TypeList, IsIDLDictionary&lt;brigand::_1&gt;&gt;;
144     static constexpr size_t numberOfDictionaryTypes = brigand::size&lt;DictionaryTypeList&gt;::value;
145     static_assert(numberOfDictionaryTypes == 0 || numberOfDictionaryTypes == 1, &quot;There can be 0 or 1 dictionary types in an IDLUnion.&quot;);
146     static constexpr bool hasDictionaryType = numberOfDictionaryTypes != 0;
147     using DictionaryType = ConditionalFront&lt;DictionaryTypeList, hasDictionaryType&gt;;
148 
149     using RecordTypeList = brigand::filter&lt;TypeList, IsIDLRecord&lt;brigand::_1&gt;&gt;;
150     static constexpr size_t numberOfRecordTypes = brigand::size&lt;RecordTypeList&gt;::value;
151     static_assert(numberOfRecordTypes == 0 || numberOfRecordTypes == 1, &quot;There can be 0 or 1 record types in an IDLUnion.&quot;);
152     static constexpr bool hasRecordType = numberOfRecordTypes != 0;
153     using RecordType = ConditionalFront&lt;RecordTypeList, hasRecordType&gt;;
154 
155     using ObjectTypeList = brigand::filter&lt;TypeList, std::is_same&lt;IDLObject, brigand::_1&gt;&gt;;
156     static constexpr size_t numberOfObjectTypes = brigand::size&lt;ObjectTypeList&gt;::value;
157     static_assert(numberOfObjectTypes == 0 || numberOfObjectTypes == 1, &quot;There can be 0 or 1 object types in an IDLUnion.&quot;);
158     static constexpr bool hasObjectType = numberOfObjectTypes != 0;
159     using ObjectType = ConditionalFront&lt;ObjectTypeList, hasObjectType&gt;;
160 
161     static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) &gt; 0;
162 
163     using InterfaceTypeList = brigand::filter&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;;
164     using TypedArrayTypeList = brigand::filter&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;;
165 
166     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)
167     {
168         JSC::VM&amp; vm = state.vm();
169         auto scope = DECLARE_THROW_SCOPE(vm);
170 
171         // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
172         constexpr bool hasNullType = brigand::any&lt;TypeList, std::is_same&lt;IDLNull, brigand::_1&gt;&gt;::value;
173         if (hasNullType) {
174             if (value.isUndefinedOrNull())
175                 return ConditionalConverter&lt;ReturnType, IDLNull, hasNullType&gt;::convert(state, value).value();
176         }
177 
178         // 2. Let types be the flattened member types of the union type.
179         // NOTE: Union is expected to be pre-flattented.
180 
181         // 3. If V is null or undefined then:
182         if (hasDictionaryType) {
183             if (value.isUndefinedOrNull()) {
184                 //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
185                 return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();
186             }
187         }
188 
189         // 4. If V is a platform object, then:
190         //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
191         //     2. If types includes object, then return the IDL value that is a reference to the object V.
192         //         (FIXME: Add support for object and step 4.2)
193         if (brigand::any&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;::value) {
194             Optional&lt;ReturnType&gt; returnValue;
195             brigand::for_each&lt;InterfaceTypeList&gt;([&amp;](auto&amp;&amp; type) {
196                 if (returnValue)
197                     return;
198 
199                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
200                 using ImplementationType = typename Type::ImplementationType;
201                 using RawType = typename Type::RawType;
202 
203                 auto castedValue = JSToWrappedOverloader&lt;RawType&gt;::toWrapped(state, value);
204                 if (!castedValue)
205                     return;
206 
207                 returnValue = ReturnType(ImplementationType(castedValue));
208             });
209 
210             if (returnValue)
211                 return WTFMove(returnValue.value());
212         }
213 
214         // FIXME: Add support for steps 5 &amp; 6.
215         //
216         // 5. If V is a DOMException platform object, then:
217         //     1. If types includes DOMException or Error, then return the result of converting V to that type.
218         //     2 If types includes object, then return the IDL value that is a reference to the object V.
219         //
220         // 6. If Type(V) is Object and V has an [[ErrorData]] internal slot), then:
221         //     1. If types includes Error, then return the result of converting V to Error.
222         //     2. If types includes object, then return the IDL value that is a reference to the object V.
223 
224 
225         // 7. If Type(V) is Object and V has an [[ArrayBufferData]] internal slot, then:
226         //     1. If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
227         //     2. If types includes object, then return the IDL value that is a reference to the object V.
228         constexpr bool hasArrayBufferType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBuffer, brigand::_1&gt;&gt;::value;
229         if (hasArrayBufferType || hasObjectType) {
230             auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
231             if (arrayBuffer) {
232                 if (hasArrayBufferType)
233                     return ConditionalReturner&lt;ReturnType, hasArrayBufferType&gt;::get(WTFMove(arrayBuffer)).value();
234                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();
235             }
236         }
237 
238         constexpr bool hasArrayBufferViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBufferView, brigand::_1&gt;&gt;::value;
239         if (hasArrayBufferViewType || hasObjectType) {
240             auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
241             if (arrayBufferView) {
242                 if (hasArrayBufferViewType)
243                     return ConditionalReturner&lt;ReturnType, hasArrayBufferViewType&gt;::get(WTFMove(arrayBufferView)).value();
244                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();
245             }
246         }
247 
248         // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
249         //     1. If types includes DataView, then return the result of converting V to DataView.
250         //     2. If types includes object, then return the IDL value that is a reference to the object V.
251         constexpr bool hasDataViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLDataView, brigand::_1&gt;&gt;::value;
252         if (hasDataViewType || hasObjectType) {
253             auto dataView = JSC::JSDataView::toWrapped(vm, value);
254             if (dataView) {
255                 if (hasDataViewType)
256                     return ConditionalReturner&lt;ReturnType, hasDataViewType&gt;::get(WTFMove(dataView)).value();
257                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();
258             }
259         }
260 
261         // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
262         //     1. If types includes a typed array type whose name is the value of Vâ€™s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
263         //     2. If types includes object, then return the IDL value that is a reference to the object V.
264         //         (FIXME: Add support for object and step 9.2)
265         constexpr bool hasTypedArrayType = brigand::any&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;::value;
266         if (hasTypedArrayType) {
267             Optional&lt;ReturnType&gt; returnValue;
268             brigand::for_each&lt;TypedArrayTypeList&gt;([&amp;](auto&amp;&amp; type) {
269                 if (returnValue)
270                     return;
271 
272                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
273                 using ImplementationType = typename Type::ImplementationType;
274                 using WrapperType = typename Converter&lt;Type&gt;::WrapperType;
275 
276                 auto castedValue = WrapperType::toWrapped(vm, value);
277                 if (!castedValue)
278                     return;
279 
280                 returnValue = ReturnType(ImplementationType(castedValue));
281             });
282 
283             if (returnValue)
284                 return WTFMove(returnValue.value());
285         }
286 
287         // FIXME: Add support for step 10.
288         //
289         // 10. If IsCallable(V) is true, then:
290         //     1. If types includes a callback function type, then return the result of converting V to that callback function type.
291         //     2. If types includes object, then return the IDL value that is a reference to the object V.
292 
293         // 11. If V is any kind of object, then:
294         if (hasAnyObjectType) {
295             if (value.isCell()) {
296                 JSC::JSCell* cell = value.asCell();
297                 if (cell-&gt;isObject()) {
298                     auto object = asObject(value);
299 
300                     //     1. If types includes a sequence type, then:
301                     //         1. Let method be the result of GetMethod(V, @@iterator).
302                     //         2. ReturnIfAbrupt(method).
303                     //         3. If method is not undefined, return the result of creating a
304                     //            sequence of that type from V and method.
305                     constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
306                     if (hasSequenceType) {
307                         auto method = JSC::iteratorMethod(state, object);
308                         RETURN_IF_EXCEPTION(scope, ReturnType());
309                         if (!method.isUndefined())
310                             return ConditionalSequenceConverter&lt;ReturnType, SequenceType, hasSequenceType&gt;::convert(state, object, method).value();
311                     }
312 
313                     //     2. If types includes a frozen array type, then:
314                     //         1. Let method be the result of GetMethod(V, @@iterator).
315                     //         2. ReturnIfAbrupt(method).
316                     //         3. If method is not undefined, return the result of creating a
317                     //            frozen array of that type from V and method.
318                     constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
319                     if (hasFrozenArrayType) {
320                         auto method = JSC::iteratorMethod(state, object);
321                         RETURN_IF_EXCEPTION(scope, ReturnType());
322                         if (!method.isUndefined())
323                             return ConditionalSequenceConverter&lt;ReturnType, FrozenArrayType, hasFrozenArrayType&gt;::convert(state, object, method).value();
324                     }
325 
326                     //     3. If types includes a dictionary type, then return the result of
327                     //        converting V to that dictionary type.
328                     if (hasDictionaryType)
329                         return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();
330 
331                     //     4. If types includes a record type, then return the result of converting V to that record type.
332                     if (hasRecordType)
333                         return ConditionalConverter&lt;ReturnType, RecordType, hasRecordType&gt;::convert(state, value).value();
334 
335                     //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
336                     //         (FIXME: Add support for callback interface type and step 12.5)
337 
338                     //     6. If types includes object, then return the IDL value that is a reference to the object V.
339                     if (hasObjectType)
340                         return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();
341                 }
342             }
343         }
344 
345         // 12. If V is a Boolean value, then:
346         //     1. If types includes a boolean, then return the result of converting V to boolean.
347         constexpr bool hasBooleanType = brigand::any&lt;TypeList, std::is_same&lt;IDLBoolean, brigand::_1&gt;&gt;::value;
348         if (hasBooleanType) {
349             if (value.isBoolean())
350                 return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();
351         }
352 
353         // 13. If V is a Number value, then:
354         //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
355         constexpr bool hasNumericType = brigand::size&lt;NumericTypeList&gt;::value != 0;
356         if (hasNumericType) {
357             if (value.isNumber())
358                 return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();
359         }
360 
361         // 14. If types includes a string type, then return the result of converting V to that type.
362         constexpr bool hasStringType = brigand::size&lt;StringTypeList&gt;::value != 0;
363         if (hasStringType)
364             return ConditionalConverter&lt;ReturnType, StringType, hasStringType&gt;::convert(state, value).value();
365 
366         // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
367         if (hasNumericType)
368             return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();
369 
370         // 16. If types includes a boolean, then return the result of converting V to boolean.
371         if (hasBooleanType)
372             return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();
373 
374         // 17. Throw a TypeError.
375         throwTypeError(&amp;state, scope);
376         return ReturnType();
377     }
378 };
379 
380 template&lt;typename... T&gt; struct JSConverter&lt;IDLUnion&lt;T...&gt;&gt; {
381     using Type = IDLUnion&lt;T...&gt;;
382     using TypeList = typename Type::TypeList;
383     using ImplementationType = typename Type::ImplementationType;
384 
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     using Sequence = brigand::make_sequence&lt;brigand::ptrdiff_t&lt;0&gt;, WTF::variant_size&lt;ImplementationType&gt;::value&gt;;
389 
390     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ImplementationType&amp; variant)
391     {
392         auto index = variant.index();
393 
394         Optional&lt;JSC::JSValue&gt; returnValue;
395         brigand::for_each&lt;Sequence&gt;([&amp;](auto&amp;&amp; type) {
396             using I = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
397             if (I::value == index) {
398                 ASSERT(!returnValue);
399                 returnValue = toJS&lt;brigand::at&lt;TypeList, I&gt;&gt;(state, globalObject, WTF::get&lt;I::value&gt;(variant));
400             }
401         });
402 
403         ASSERT(returnValue);
404         return returnValue.value();
405     }
406 };
407 
408 } // namespace WebCore
    </pre>
  </body>
</html>