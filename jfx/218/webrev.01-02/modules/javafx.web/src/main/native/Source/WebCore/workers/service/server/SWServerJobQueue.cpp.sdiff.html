<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerJobQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWServer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerJobQueue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerJobQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerJobQueue.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExceptionData.h&quot;
 32 #include &quot;SWServer.h&quot;
 33 #include &quot;SWServerRegistration.h&quot;
 34 #include &quot;SWServerWorker.h&quot;
<span class="line-removed"> 35 #include &quot;SchemeRegistry.h&quot;</span>
 36 #include &quot;SecurityOrigin.h&quot;
 37 #include &quot;ServiceWorkerFetchResult.h&quot;
 38 #include &quot;ServiceWorkerRegistrationData.h&quot;
 39 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 40 #include &quot;WorkerType.h&quot;
 41 
 42 namespace WebCore {
 43 
 44 SWServerJobQueue::SWServerJobQueue(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key)
 45     : m_jobTimer(*this, &amp;SWServerJobQueue::runNextJobSynchronously)
 46     , m_server(server)
 47     , m_registrationKey(key)
 48 {
 49 }
 50 
 51 SWServerJobQueue::~SWServerJobQueue()
 52 {
 53 }
 54 
 55 bool SWServerJobQueue::isCurrentlyProcessingJob(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier) const
 56 {
 57     return !m_jobQueue.isEmpty() &amp;&amp; firstJob().identifier() == jobDataIdentifier;
 58 }
 59 
<span class="line-modified"> 60 void SWServerJobQueue::scriptFetchFinished(SWServer::Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)</span>
 61 {
 62     if (!isCurrentlyProcessingJob(result.jobDataIdentifier))
 63         return;
 64 
 65     auto&amp; job = firstJob();
 66 
 67     auto* registration = m_server.getRegistration(m_registrationKey);
 68     if (!registration)
 69         return;
 70 
 71     auto* newestWorker = registration-&gt;getNewestWorker();
 72 
 73     if (!result.scriptError.isNull()) {
 74         // Invoke Reject Job Promise with job and TypeError.
 75         m_server.rejectJob(job, ExceptionData { TypeError, makeString(&quot;Script URL &quot;, job.scriptURL.string(), &quot; fetch resulted in error: &quot;, result.scriptError.localizedDescription()) });
 76 
 77         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
 78         if (!newestWorker)
 79             registration-&gt;clear();
 80 
</pre>
<hr />
<pre>
 85 
 86     registration-&gt;setLastUpdateTime(WallTime::now());
 87 
 88     // If newestWorker is not null, newestWorker&#39;s script url equals job&#39;s script url with the exclude fragments
 89     // flag set, and script&#39;s source text is a byte-for-byte match with newestWorker&#39;s script resource&#39;s source
 90     // text, then:
 91     if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(newestWorker-&gt;scriptURL(), job.scriptURL) &amp;&amp; result.script == newestWorker-&gt;script()) {
 92         // FIXME: for non classic scripts, check the script’s module record&#39;s [[ECMAScriptCode]].
 93 
 94         // Invoke Resolve Job Promise with job and registration.
 95         m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
 96 
 97         // Invoke Finish Job with job and abort these steps.
 98         finishCurrentJob();
 99         return;
100     }
101 
102     // FIXME: Update all the imported scripts as per spec. For now, we just do as if there is none.
103 
104     // FIXME: Support the proper worker type (classic vs module)
<span class="line-modified">105     m_server.updateWorker(connection, job.identifier(), *registration, job.scriptURL, result.script, result.contentSecurityPolicy, result.referrerPolicy, WorkerType::Classic, { });</span>
106 }
107 
108 // https://w3c.github.io/ServiceWorker/#update-algorithm
109 void SWServerJobQueue::scriptContextFailedToStart(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier, const String&amp; message)
110 {
111     if (!isCurrentlyProcessingJob(jobDataIdentifier))
112         return;
113 
114     // If an uncaught runtime script error occurs during the above step, then:
115     auto* registration = m_server.getRegistration(m_registrationKey);
116     ASSERT(registration);
117 
118     ASSERT(registration-&gt;preInstallationWorker());
119     registration-&gt;preInstallationWorker()-&gt;terminate();
120     registration-&gt;setPreInstallationWorker(nullptr);
121 
122     // Invoke Reject Job Promise with job and TypeError.
123     m_server.rejectJob(firstJob(), { TypeError, message });
124 
125     // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
</pre>
<hr />
<pre>
161 // https://w3c.github.io/ServiceWorker/#install (after resolving promise).
162 void SWServerJobQueue::didResolveRegistrationPromise()
163 {
164     auto* registration = m_server.getRegistration(m_registrationKey);
165     ASSERT(registration);
166     ASSERT(registration-&gt;installingWorker());
167 
168     RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::didResolveRegistrationPromise: Registration ID: %llu. Now proceeding with install&quot;, this, registration-&gt;identifier().toUInt64());
169 
170     // Queue a task to fire an event named updatefound at all the ServiceWorkerRegistration objects
171     // for all the service worker clients whose creation URL matches registration&#39;s scope url and
172     // all the service workers whose containing service worker registration is registration.
173     registration-&gt;fireUpdateFoundEvent();
174 
175     // Queue a task to fire the InstallEvent.
176     ASSERT(registration-&gt;installingWorker());
177     m_server.fireInstallEvent(*registration-&gt;installingWorker());
178 }
179 
180 // https://w3c.github.io/ServiceWorker/#install
<span class="line-modified">181 void SWServerJobQueue::didFinishInstall(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier identifier, bool wasSuccessful)</span>
182 {
183     if (!isCurrentlyProcessingJob(jobDataIdentifier))
184         return;
185 
<span class="line-modified">186     auto* registration = m_server.getRegistration(m_registrationKey);</span>
187     ASSERT(registration);
<span class="line-modified">188     ASSERT(registration-&gt;installingWorker());</span>
<span class="line-removed">189     ASSERT(registration-&gt;installingWorker()-&gt;identifier() == identifier);</span>
190 
191     if (!wasSuccessful) {
<span class="line-modified">192         RefPtr&lt;SWServerWorker&gt; worker = m_server.workerByID(identifier);</span>
<span class="line-removed">193         RELEASE_ASSERT(worker);</span>
<span class="line-removed">194 </span>
<span class="line-removed">195         worker-&gt;terminate();</span>
196         // Run the Update Registration State algorithm passing registration, &quot;installing&quot; and null as the arguments.
197         registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
198         // Run the Update Worker State algorithm passing registration&#39;s installing worker and redundant as the arguments.
<span class="line-modified">199         registration-&gt;updateWorkerState(*worker, ServiceWorkerState::Redundant);</span>
200 
201         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
202         if (!registration-&gt;getNewestWorker())
203             registration-&gt;clear();
204 
205         // Invoke Finish Job with job and abort these steps.
206         finishCurrentJob();
207         return;
208     }
209 
210     if (auto* waitingWorker = registration-&gt;waitingWorker()) {
211         waitingWorker-&gt;terminate();
212         registration-&gt;updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
213     }
214 
<span class="line-modified">215     auto* installing = registration-&gt;installingWorker();</span>
<span class="line-removed">216     ASSERT(installing);</span>
<span class="line-removed">217 </span>
<span class="line-removed">218     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Waiting, installing);</span>
219     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
<span class="line-modified">220     registration-&gt;updateWorkerState(*installing, ServiceWorkerState::Installed);</span>
221 
222     finishCurrentJob();
223 
224     // FIXME: Wait for all the tasks queued by Update Worker State invoked in this algorithm have executed.
225     registration-&gt;tryActivate();
226 }
227 
228 // https://w3c.github.io/ServiceWorker/#run-job
229 void SWServerJobQueue::runNextJob()
230 {
231     ASSERT(!m_jobQueue.isEmpty());
232     ASSERT(!m_jobTimer.isActive());
233     m_jobTimer.startOneShot(0_s);
234 }
235 
236 void SWServerJobQueue::runNextJobSynchronously()
237 {
238     ASSERT(!m_jobQueue.isEmpty());
239     if (m_jobQueue.isEmpty())
240         return;
</pre>
<hr />
<pre>
243     switch (job.type) {
244     case ServiceWorkerJobType::Register:
245         runRegisterJob(job);
246         return;
247     case ServiceWorkerJobType::Unregister:
248         runUnregisterJob(job);
249         return;
250     case ServiceWorkerJobType::Update:
251         runUpdateJob(job);
252         return;
253     }
254 
255     ASSERT_NOT_REACHED();
256 }
257 
258 // https://w3c.github.io/ServiceWorker/#register-algorithm
259 void SWServerJobQueue::runRegisterJob(const ServiceWorkerJobData&amp; job)
260 {
261     ASSERT(job.type == ServiceWorkerJobType::Register);
262 
<span class="line-modified">263     if (!shouldTreatAsPotentiallyTrustworthy(job.scriptURL) &amp;&amp; !SchemeRegistry::isServiceWorkerContainerCustomScheme(job.scriptURL.protocol().toStringWithoutCopying()))</span>
264         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script URL is not potentially trustworthy&quot;_s });
265 
266     // If the origin of job&#39;s script url is not job&#39;s referrer&#39;s origin, then:
267     if (!protocolHostAndPortAreEqual(job.scriptURL, job.clientCreationURL))
268         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script origin does not match the registering client&#39;s origin&quot;_s });
269 
270     // If the origin of job&#39;s scope url is not job&#39;s referrer&#39;s origin, then:
271     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
272         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Scope origin does not match the registering client&#39;s origin&quot;_s });
273 
274     // If registration is not null (in our parlance &quot;empty&quot;), then:
275     if (auto* registration = m_server.getRegistration(m_registrationKey)) {
<span class="line-removed">276         registration-&gt;setIsUninstalling(false);</span>
277         auto* newestWorker = registration-&gt;getNewestWorker();
278         if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()) &amp;&amp; job.registrationOptions.updateViaCache == registration-&gt;updateViaCache()) {
279             RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found directly reusable registration %llu for job %s (DONE)&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
280             m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
281             finishCurrentJob();
282             return;
283         }
284         // This is not specified yet (https://github.com/w3c/ServiceWorker/issues/1189).
285         if (registration-&gt;updateViaCache() != job.registrationOptions.updateViaCache)
286             registration-&gt;setUpdateViaCache(job.registrationOptions.updateViaCache);
287         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found registration %llu for job %s but it needs updating&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
288     } else {
289         auto newRegistration = makeUnique&lt;SWServerRegistration&gt;(m_server, m_registrationKey, job.registrationOptions.updateViaCache, job.scopeURL, job.scriptURL);
290         m_server.addRegistration(WTFMove(newRegistration));
291 
292         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: No existing registration for job %s, constructing a new one.&quot;, this, job.identifier().loggingString().utf8().data());
293     }
294 
295     runUpdateJob(job);
296 }
297 
298 // https://w3c.github.io/ServiceWorker/#unregister-algorithm
299 void SWServerJobQueue::runUnregisterJob(const ServiceWorkerJobData&amp; job)
300 {
301     // If the origin of job&#39;s scope url is not job&#39;s client&#39;s origin, then:
302     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
303         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Origin of scope URL does not match the client&#39;s origin&quot;_s });
304 
305     // Let registration be the result of running &quot;Get Registration&quot; algorithm passing job&#39;s scope url as the argument.
306     auto* registration = m_server.getRegistration(m_registrationKey);
307 
308     // If registration is null, then:
<span class="line-modified">309     if (!registration || registration-&gt;isUninstalling()) {</span>
310         // Invoke Resolve Job Promise with job and false.
311         m_server.resolveUnregistrationJob(job, m_registrationKey, false);
312         finishCurrentJob();
313         return;
314     }
315 
<span class="line-modified">316     // Set registration&#39;s uninstalling flag.</span>
<span class="line-modified">317     registration-&gt;setIsUninstalling(true);</span>
318 
319     // Invoke Resolve Job Promise with job and true.
320     m_server.resolveUnregistrationJob(job, m_registrationKey, true);
321 
322     // Invoke Try Clear Registration with registration.
323     registration-&gt;tryClear();
324     finishCurrentJob();
325 }
326 
327 // https://w3c.github.io/ServiceWorker/#update-algorithm
328 void SWServerJobQueue::runUpdateJob(const ServiceWorkerJobData&amp; job)
329 {
330     // Let registration be the result of running the Get Registration algorithm passing job&#39;s scope url as the argument.
331     auto* registration = m_server.getRegistration(m_registrationKey);
332 
333     // If registration is null (in our parlance &quot;empty&quot;) or registration&#39;s uninstalling flag is set, then:
334     if (!registration)
335         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a null/nonexistent service worker registration&quot;_s });
<span class="line-removed">336     if (registration-&gt;isUninstalling())</span>
<span class="line-removed">337         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker registration that is uninstalling&quot;_s });</span>
338 
339     // Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
340     auto* newestWorker = registration-&gt;getNewestWorker();
341 
342     // If job&#39;s type is update, and newestWorker&#39;s script url does not equal job&#39;s script url with the exclude fragments flag set, then:
343     if (job.type == ServiceWorkerJobType::Update &amp;&amp; newestWorker &amp;&amp; !equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()))
344         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker with a requested script URL whose newest worker has a different script URL&quot;_s });
345 
<span class="line-removed">346     FetchOptions::Cache cachePolicy = FetchOptions::Cache::Default;</span>
347     // Set request&#39;s cache mode to &quot;no-cache&quot; if any of the following are true:
348     // - registration&#39;s update via cache mode is not &quot;all&quot;.
349     // - job&#39;s force bypass cache flag is set.
350     // - newestWorker is not null, and registration&#39;s last update check time is not null and the time difference in seconds calculated by the
351     //   current time minus registration&#39;s last update check time is greater than 86400.
<span class="line-modified">352     if (registration-&gt;updateViaCache() != ServiceWorkerUpdateViaCache::All</span>
<span class="line-modified">353         || (newestWorker &amp;&amp; registration-&gt;lastUpdateTime() &amp;&amp; (WallTime::now() - registration-&gt;lastUpdateTime()) &gt; 86400_s)) {</span>
<span class="line-removed">354         cachePolicy = FetchOptions::Cache::NoCache;</span>
<span class="line-removed">355     }</span>
<span class="line-removed">356     m_server.startScriptFetch(job, cachePolicy);</span>
357 }
358 
359 void SWServerJobQueue::rejectCurrentJob(const ExceptionData&amp; exceptionData)
360 {
361     m_server.rejectJob(firstJob(), exceptionData);
362 
363     finishCurrentJob();
364 }
365 
366 // https://w3c.github.io/ServiceWorker/#finish-job
367 void SWServerJobQueue::finishCurrentJob()
368 {
369     ASSERT(!m_jobTimer.isActive());
370 
371     m_jobQueue.removeFirst();
372     if (!m_jobQueue.isEmpty())
373         runNextJob();
374 }
375 
376 void SWServerJobQueue::removeAllJobsMatching(const WTF::Function&lt;bool(ServiceWorkerJobData&amp;)&gt;&amp; matches)
</pre>
</td>
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerJobQueue.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExceptionData.h&quot;
 32 #include &quot;SWServer.h&quot;
 33 #include &quot;SWServerRegistration.h&quot;
 34 #include &quot;SWServerWorker.h&quot;

 35 #include &quot;SecurityOrigin.h&quot;
 36 #include &quot;ServiceWorkerFetchResult.h&quot;
 37 #include &quot;ServiceWorkerRegistrationData.h&quot;
 38 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 39 #include &quot;WorkerType.h&quot;
 40 
 41 namespace WebCore {
 42 
 43 SWServerJobQueue::SWServerJobQueue(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key)
 44     : m_jobTimer(*this, &amp;SWServerJobQueue::runNextJobSynchronously)
 45     , m_server(server)
 46     , m_registrationKey(key)
 47 {
 48 }
 49 
 50 SWServerJobQueue::~SWServerJobQueue()
 51 {
 52 }
 53 
 54 bool SWServerJobQueue::isCurrentlyProcessingJob(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier) const
 55 {
 56     return !m_jobQueue.isEmpty() &amp;&amp; firstJob().identifier() == jobDataIdentifier;
 57 }
 58 
<span class="line-modified"> 59 void SWServerJobQueue::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)</span>
 60 {
 61     if (!isCurrentlyProcessingJob(result.jobDataIdentifier))
 62         return;
 63 
 64     auto&amp; job = firstJob();
 65 
 66     auto* registration = m_server.getRegistration(m_registrationKey);
 67     if (!registration)
 68         return;
 69 
 70     auto* newestWorker = registration-&gt;getNewestWorker();
 71 
 72     if (!result.scriptError.isNull()) {
 73         // Invoke Reject Job Promise with job and TypeError.
 74         m_server.rejectJob(job, ExceptionData { TypeError, makeString(&quot;Script URL &quot;, job.scriptURL.string(), &quot; fetch resulted in error: &quot;, result.scriptError.localizedDescription()) });
 75 
 76         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
 77         if (!newestWorker)
 78             registration-&gt;clear();
 79 
</pre>
<hr />
<pre>
 84 
 85     registration-&gt;setLastUpdateTime(WallTime::now());
 86 
 87     // If newestWorker is not null, newestWorker&#39;s script url equals job&#39;s script url with the exclude fragments
 88     // flag set, and script&#39;s source text is a byte-for-byte match with newestWorker&#39;s script resource&#39;s source
 89     // text, then:
 90     if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(newestWorker-&gt;scriptURL(), job.scriptURL) &amp;&amp; result.script == newestWorker-&gt;script()) {
 91         // FIXME: for non classic scripts, check the script’s module record&#39;s [[ECMAScriptCode]].
 92 
 93         // Invoke Resolve Job Promise with job and registration.
 94         m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
 95 
 96         // Invoke Finish Job with job and abort these steps.
 97         finishCurrentJob();
 98         return;
 99     }
100 
101     // FIXME: Update all the imported scripts as per spec. For now, we just do as if there is none.
102 
103     // FIXME: Support the proper worker type (classic vs module)
<span class="line-modified">104     m_server.updateWorker(job.identifier(), *registration, job.scriptURL, result.script, result.contentSecurityPolicy, result.referrerPolicy, WorkerType::Classic, { });</span>
105 }
106 
107 // https://w3c.github.io/ServiceWorker/#update-algorithm
108 void SWServerJobQueue::scriptContextFailedToStart(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier, const String&amp; message)
109 {
110     if (!isCurrentlyProcessingJob(jobDataIdentifier))
111         return;
112 
113     // If an uncaught runtime script error occurs during the above step, then:
114     auto* registration = m_server.getRegistration(m_registrationKey);
115     ASSERT(registration);
116 
117     ASSERT(registration-&gt;preInstallationWorker());
118     registration-&gt;preInstallationWorker()-&gt;terminate();
119     registration-&gt;setPreInstallationWorker(nullptr);
120 
121     // Invoke Reject Job Promise with job and TypeError.
122     m_server.rejectJob(firstJob(), { TypeError, message });
123 
124     // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
</pre>
<hr />
<pre>
160 // https://w3c.github.io/ServiceWorker/#install (after resolving promise).
161 void SWServerJobQueue::didResolveRegistrationPromise()
162 {
163     auto* registration = m_server.getRegistration(m_registrationKey);
164     ASSERT(registration);
165     ASSERT(registration-&gt;installingWorker());
166 
167     RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::didResolveRegistrationPromise: Registration ID: %llu. Now proceeding with install&quot;, this, registration-&gt;identifier().toUInt64());
168 
169     // Queue a task to fire an event named updatefound at all the ServiceWorkerRegistration objects
170     // for all the service worker clients whose creation URL matches registration&#39;s scope url and
171     // all the service workers whose containing service worker registration is registration.
172     registration-&gt;fireUpdateFoundEvent();
173 
174     // Queue a task to fire the InstallEvent.
175     ASSERT(registration-&gt;installingWorker());
176     m_server.fireInstallEvent(*registration-&gt;installingWorker());
177 }
178 
179 // https://w3c.github.io/ServiceWorker/#install
<span class="line-modified">180 void SWServerJobQueue::didFinishInstall(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)</span>
181 {
182     if (!isCurrentlyProcessingJob(jobDataIdentifier))
183         return;
184 
<span class="line-modified">185     auto* registration = worker.registration();</span>
186     ASSERT(registration);
<span class="line-modified">187     ASSERT(registration-&gt;installingWorker() == &amp;worker);</span>

188 
189     if (!wasSuccessful) {
<span class="line-modified">190         worker.terminate();</span>



191         // Run the Update Registration State algorithm passing registration, &quot;installing&quot; and null as the arguments.
192         registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
193         // Run the Update Worker State algorithm passing registration&#39;s installing worker and redundant as the arguments.
<span class="line-modified">194         registration-&gt;updateWorkerState(worker, ServiceWorkerState::Redundant);</span>
195 
196         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
197         if (!registration-&gt;getNewestWorker())
198             registration-&gt;clear();
199 
200         // Invoke Finish Job with job and abort these steps.
201         finishCurrentJob();
202         return;
203     }
204 
205     if (auto* waitingWorker = registration-&gt;waitingWorker()) {
206         waitingWorker-&gt;terminate();
207         registration-&gt;updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
208     }
209 
<span class="line-modified">210     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Waiting, &amp;worker);</span>



211     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
<span class="line-modified">212     registration-&gt;updateWorkerState(worker, ServiceWorkerState::Installed);</span>
213 
214     finishCurrentJob();
215 
216     // FIXME: Wait for all the tasks queued by Update Worker State invoked in this algorithm have executed.
217     registration-&gt;tryActivate();
218 }
219 
220 // https://w3c.github.io/ServiceWorker/#run-job
221 void SWServerJobQueue::runNextJob()
222 {
223     ASSERT(!m_jobQueue.isEmpty());
224     ASSERT(!m_jobTimer.isActive());
225     m_jobTimer.startOneShot(0_s);
226 }
227 
228 void SWServerJobQueue::runNextJobSynchronously()
229 {
230     ASSERT(!m_jobQueue.isEmpty());
231     if (m_jobQueue.isEmpty())
232         return;
</pre>
<hr />
<pre>
235     switch (job.type) {
236     case ServiceWorkerJobType::Register:
237         runRegisterJob(job);
238         return;
239     case ServiceWorkerJobType::Unregister:
240         runUnregisterJob(job);
241         return;
242     case ServiceWorkerJobType::Update:
243         runUpdateJob(job);
244         return;
245     }
246 
247     ASSERT_NOT_REACHED();
248 }
249 
250 // https://w3c.github.io/ServiceWorker/#register-algorithm
251 void SWServerJobQueue::runRegisterJob(const ServiceWorkerJobData&amp; job)
252 {
253     ASSERT(job.type == ServiceWorkerJobType::Register);
254 
<span class="line-modified">255     if (!shouldTreatAsPotentiallyTrustworthy(job.scriptURL) &amp;&amp; !m_server.canHandleScheme(job.scriptURL.protocol()))</span>
256         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script URL is not potentially trustworthy&quot;_s });
257 
258     // If the origin of job&#39;s script url is not job&#39;s referrer&#39;s origin, then:
259     if (!protocolHostAndPortAreEqual(job.scriptURL, job.clientCreationURL))
260         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script origin does not match the registering client&#39;s origin&quot;_s });
261 
262     // If the origin of job&#39;s scope url is not job&#39;s referrer&#39;s origin, then:
263     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
264         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Scope origin does not match the registering client&#39;s origin&quot;_s });
265 
266     // If registration is not null (in our parlance &quot;empty&quot;), then:
267     if (auto* registration = m_server.getRegistration(m_registrationKey)) {

268         auto* newestWorker = registration-&gt;getNewestWorker();
269         if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()) &amp;&amp; job.registrationOptions.updateViaCache == registration-&gt;updateViaCache()) {
270             RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found directly reusable registration %llu for job %s (DONE)&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
271             m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
272             finishCurrentJob();
273             return;
274         }
275         // This is not specified yet (https://github.com/w3c/ServiceWorker/issues/1189).
276         if (registration-&gt;updateViaCache() != job.registrationOptions.updateViaCache)
277             registration-&gt;setUpdateViaCache(job.registrationOptions.updateViaCache);
278         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found registration %llu for job %s but it needs updating&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
279     } else {
280         auto newRegistration = makeUnique&lt;SWServerRegistration&gt;(m_server, m_registrationKey, job.registrationOptions.updateViaCache, job.scopeURL, job.scriptURL);
281         m_server.addRegistration(WTFMove(newRegistration));
282 
283         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: No existing registration for job %s, constructing a new one.&quot;, this, job.identifier().loggingString().utf8().data());
284     }
285 
286     runUpdateJob(job);
287 }
288 
289 // https://w3c.github.io/ServiceWorker/#unregister-algorithm
290 void SWServerJobQueue::runUnregisterJob(const ServiceWorkerJobData&amp; job)
291 {
292     // If the origin of job&#39;s scope url is not job&#39;s client&#39;s origin, then:
293     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
294         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Origin of scope URL does not match the client&#39;s origin&quot;_s });
295 
296     // Let registration be the result of running &quot;Get Registration&quot; algorithm passing job&#39;s scope url as the argument.
297     auto* registration = m_server.getRegistration(m_registrationKey);
298 
299     // If registration is null, then:
<span class="line-modified">300     if (!registration) {</span>
301         // Invoke Resolve Job Promise with job and false.
302         m_server.resolveUnregistrationJob(job, m_registrationKey, false);
303         finishCurrentJob();
304         return;
305     }
306 
<span class="line-modified">307     // Remove scope to registration map[job’s scope url].</span>
<span class="line-modified">308     m_server.removeFromScopeToRegistrationMap(m_registrationKey);</span>
309 
310     // Invoke Resolve Job Promise with job and true.
311     m_server.resolveUnregistrationJob(job, m_registrationKey, true);
312 
313     // Invoke Try Clear Registration with registration.
314     registration-&gt;tryClear();
315     finishCurrentJob();
316 }
317 
318 // https://w3c.github.io/ServiceWorker/#update-algorithm
319 void SWServerJobQueue::runUpdateJob(const ServiceWorkerJobData&amp; job)
320 {
321     // Let registration be the result of running the Get Registration algorithm passing job&#39;s scope url as the argument.
322     auto* registration = m_server.getRegistration(m_registrationKey);
323 
324     // If registration is null (in our parlance &quot;empty&quot;) or registration&#39;s uninstalling flag is set, then:
325     if (!registration)
326         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a null/nonexistent service worker registration&quot;_s });


327 
328     // Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
329     auto* newestWorker = registration-&gt;getNewestWorker();
330 
331     // If job&#39;s type is update, and newestWorker&#39;s script url does not equal job&#39;s script url with the exclude fragments flag set, then:
332     if (job.type == ServiceWorkerJobType::Update &amp;&amp; newestWorker &amp;&amp; !equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()))
333         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker with a requested script URL whose newest worker has a different script URL&quot;_s });
334 

335     // Set request&#39;s cache mode to &quot;no-cache&quot; if any of the following are true:
336     // - registration&#39;s update via cache mode is not &quot;all&quot;.
337     // - job&#39;s force bypass cache flag is set.
338     // - newestWorker is not null, and registration&#39;s last update check time is not null and the time difference in seconds calculated by the
339     //   current time minus registration&#39;s last update check time is greater than 86400.
<span class="line-modified">340     bool shouldRefreshCache = registration-&gt;updateViaCache() != ServiceWorkerUpdateViaCache::All || (newestWorker &amp;&amp; registration-&gt;isStale());</span>
<span class="line-modified">341     m_server.startScriptFetch(job, shouldRefreshCache);</span>



342 }
343 
344 void SWServerJobQueue::rejectCurrentJob(const ExceptionData&amp; exceptionData)
345 {
346     m_server.rejectJob(firstJob(), exceptionData);
347 
348     finishCurrentJob();
349 }
350 
351 // https://w3c.github.io/ServiceWorker/#finish-job
352 void SWServerJobQueue::finishCurrentJob()
353 {
354     ASSERT(!m_jobTimer.isActive());
355 
356     m_jobQueue.removeFirst();
357     if (!m_jobQueue.isEmpty())
358         runNextJob();
359 }
360 
361 void SWServerJobQueue::removeAllJobsMatching(const WTF::Function&lt;bool(ServiceWorkerJobData&amp;)&gt;&amp; matches)
</pre>
</td>
</tr>
</table>
<center><a href="SWServer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerJobQueue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>