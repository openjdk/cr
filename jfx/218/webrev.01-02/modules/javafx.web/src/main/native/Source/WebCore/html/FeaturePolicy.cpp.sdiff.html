<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTPDirectoryDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FeaturePolicy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/FeaturePolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FeaturePolicy.h&quot;
 28 

 29 #include &quot;Document.h&quot;


 30 #include &quot;HTMLParserIdioms.h&quot;
 31 #include &quot;SecurityOrigin.h&quot;
 32 
 33 namespace WebCore {
 34 

















































 35 static bool isAllowedByFeaturePolicy(const FeaturePolicy::AllowRule&amp; rule, const SecurityOriginData&amp; origin)
 36 {
 37     switch (rule.type) {
 38     case FeaturePolicy::AllowRule::Type::None:
 39         return false;
 40     case FeaturePolicy::AllowRule::Type::All:
 41         return true;
 42     case FeaturePolicy::AllowRule::Type::List:
 43         return rule.allowedList.contains(origin);
 44     }
 45     ASSERT_NOT_REACHED();
 46     return false;
 47 }
 48 
 49 static inline void processOriginItem(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView item)
 50 {
 51     if (rule.type == FeaturePolicy::AllowRule::Type::None)
 52         return;
 53 
 54     item = item.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
</pre>
<hr />
<pre>
 77 static inline void updateList(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView value)
 78 {
 79     // We keep the empty string value equivalent to &#39;*&#39; for existing websites.
 80     if (value.isEmpty()) {
 81         rule.type = FeaturePolicy::AllowRule::Type::All;
 82         return;
 83     }
 84 
 85     while (!value.isEmpty()) {
 86         auto position = value.find(isHTMLSpace&lt;UChar&gt;);
 87         if (position == notFound) {
 88             processOriginItem(document, rule, value);
 89             return;
 90         }
 91 
 92         processOriginItem(document, rule, value.substring(0, position));
 93         value = value.substring(position + 1).stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
 94     }
 95 }
 96 
<span class="line-modified"> 97 FeaturePolicy FeaturePolicy::parse(Document&amp; document, StringView allowAttributeValue)</span>
 98 {
 99     FeaturePolicy policy;
100     bool isCameraInitialized = false;
101     bool isMicrophoneInitialized = false;
102     bool isDisplayCaptureInitialized = false;


103     for (auto allowItem : allowAttributeValue.split(&#39;;&#39;)) {
104         auto item = allowItem.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
105         if (item.startsWith(&quot;camera&quot;)) {
106             isCameraInitialized = true;
107             updateList(document, policy.m_cameraRule, item.substring(7));
108             continue;
109         }
110         if (item.startsWith(&quot;microphone&quot;)) {
111             isMicrophoneInitialized = true;
112             updateList(document, policy.m_microphoneRule, item.substring(11));
113             continue;
114         }
115         if (item.startsWith(&quot;display-capture&quot;)) {
116             isDisplayCaptureInitialized = true;
117             updateList(document, policy.m_displayCaptureRule, item.substring(16));
118             continue;
119         }










120     }
121 
<span class="line-modified">122     // By default, camera, microphone and display-capture policy is &#39;self&#39;</span>
123     if (!isCameraInitialized)
124         policy.m_cameraRule.allowedList.add(document.securityOrigin().data());
125     if (!isMicrophoneInitialized)
126         policy.m_microphoneRule.allowedList.add(document.securityOrigin().data());
127     if (!isDisplayCaptureInitialized)
128         policy.m_displayCaptureRule.allowedList.add(document.securityOrigin().data());
129 


















130     return policy;
131 }
132 
133 bool FeaturePolicy::allows(Type type, const SecurityOriginData&amp; origin) const
134 {
135     switch (type) {
136     case Type::Camera:
137         return isAllowedByFeaturePolicy(m_cameraRule, origin);
138     case Type::Microphone:
139         return isAllowedByFeaturePolicy(m_microphoneRule, origin);
140     case Type::DisplayCapture:
141         return isAllowedByFeaturePolicy(m_displayCaptureRule, origin);




142     }
143     ASSERT_NOT_REACHED();
144     return false;
145 }
146 
147 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FeaturePolicy.h&quot;
 28 
<span class="line-added"> 29 #include &quot;DOMWindow.h&quot;</span>
 30 #include &quot;Document.h&quot;
<span class="line-added"> 31 #include &quot;HTMLIFrameElement.h&quot;</span>
<span class="line-added"> 32 #include &quot;HTMLNames.h&quot;</span>
 33 #include &quot;HTMLParserIdioms.h&quot;
 34 #include &quot;SecurityOrigin.h&quot;
 35 
 36 namespace WebCore {
 37 
<span class="line-added"> 38 using namespace HTMLNames;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 static const char* policyTypeName(FeaturePolicy::Type type)</span>
<span class="line-added"> 41 {</span>
<span class="line-added"> 42     switch (type) {</span>
<span class="line-added"> 43     case FeaturePolicy::Type::Camera:</span>
<span class="line-added"> 44         return &quot;Camera&quot;;</span>
<span class="line-added"> 45     case FeaturePolicy::Type::Microphone:</span>
<span class="line-added"> 46         return &quot;Microphone&quot;;</span>
<span class="line-added"> 47     case FeaturePolicy::Type::DisplayCapture:</span>
<span class="line-added"> 48         return &quot;DisplayCapture&quot;;</span>
<span class="line-added"> 49     case FeaturePolicy::Type::SyncXHR:</span>
<span class="line-added"> 50         return &quot;SyncXHR&quot;;</span>
<span class="line-added"> 51     case FeaturePolicy::Type::Fullscreen:</span>
<span class="line-added"> 52         return &quot;Fullscreen&quot;;</span>
<span class="line-added"> 53     }</span>
<span class="line-added"> 54     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 55     return &quot;&quot;;</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 bool isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type type, const Document&amp; document, LogFeaturePolicyFailure logFailure)</span>
<span class="line-added"> 59 {</span>
<span class="line-added"> 60     auto&amp; topDocument = document.topDocument();</span>
<span class="line-added"> 61     auto* ancestorDocument = &amp;document;</span>
<span class="line-added"> 62     while (ancestorDocument != &amp;topDocument) {</span>
<span class="line-added"> 63         if (!ancestorDocument) {</span>
<span class="line-added"> 64             if (logFailure == LogFeaturePolicyFailure::Yes &amp;&amp; document.domWindow())</span>
<span class="line-added"> 65                 document.domWindow()-&gt;printErrorMessage(makeString(&quot;Feature policy &#39;&quot;, policyTypeName(type), &quot;&#39; check failed.&quot;));</span>
<span class="line-added"> 66             return false;</span>
<span class="line-added"> 67         }</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69         auto* ownerElement = ancestorDocument-&gt;ownerElement();</span>
<span class="line-added"> 70         if (is&lt;HTMLIFrameElement&gt;(ownerElement)) {</span>
<span class="line-added"> 71             const auto&amp; featurePolicy = downcast&lt;HTMLIFrameElement&gt;(ownerElement)-&gt;featurePolicy();</span>
<span class="line-added"> 72             if (!featurePolicy.allows(type, ancestorDocument-&gt;securityOrigin().data())) {</span>
<span class="line-added"> 73                 if (logFailure == LogFeaturePolicyFailure::Yes &amp;&amp; document.domWindow()) {</span>
<span class="line-added"> 74                     auto&amp; allowValue = downcast&lt;HTMLIFrameElement&gt;(ownerElement)-&gt;attributeWithoutSynchronization(HTMLNames::allowAttr);</span>
<span class="line-added"> 75                     document.domWindow()-&gt;printErrorMessage(makeString(&quot;Feature policy &#39;&quot;, policyTypeName(type), &quot;&#39; check failed for iframe with origin &#39;&quot;, document.securityOrigin().toString(), &quot;&#39; and allow attribute &#39;&quot;, allowValue, &quot;&#39;.&quot;));</span>
<span class="line-added"> 76                 }</span>
<span class="line-added"> 77                 return false;</span>
<span class="line-added"> 78             }</span>
<span class="line-added"> 79         }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81         ancestorDocument = ancestorDocument-&gt;parentDocument();</span>
<span class="line-added"> 82     }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84     return true;</span>
<span class="line-added"> 85 }</span>
<span class="line-added"> 86 </span>
 87 static bool isAllowedByFeaturePolicy(const FeaturePolicy::AllowRule&amp; rule, const SecurityOriginData&amp; origin)
 88 {
 89     switch (rule.type) {
 90     case FeaturePolicy::AllowRule::Type::None:
 91         return false;
 92     case FeaturePolicy::AllowRule::Type::All:
 93         return true;
 94     case FeaturePolicy::AllowRule::Type::List:
 95         return rule.allowedList.contains(origin);
 96     }
 97     ASSERT_NOT_REACHED();
 98     return false;
 99 }
100 
101 static inline void processOriginItem(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView item)
102 {
103     if (rule.type == FeaturePolicy::AllowRule::Type::None)
104         return;
105 
106     item = item.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
</pre>
<hr />
<pre>
129 static inline void updateList(Document&amp; document, FeaturePolicy::AllowRule&amp; rule, StringView value)
130 {
131     // We keep the empty string value equivalent to &#39;*&#39; for existing websites.
132     if (value.isEmpty()) {
133         rule.type = FeaturePolicy::AllowRule::Type::All;
134         return;
135     }
136 
137     while (!value.isEmpty()) {
138         auto position = value.find(isHTMLSpace&lt;UChar&gt;);
139         if (position == notFound) {
140             processOriginItem(document, rule, value);
141             return;
142         }
143 
144         processOriginItem(document, rule, value.substring(0, position));
145         value = value.substring(position + 1).stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
146     }
147 }
148 
<span class="line-modified">149 FeaturePolicy FeaturePolicy::parse(Document&amp; document, const HTMLIFrameElement&amp; iframe, StringView allowAttributeValue)</span>
150 {
151     FeaturePolicy policy;
152     bool isCameraInitialized = false;
153     bool isMicrophoneInitialized = false;
154     bool isDisplayCaptureInitialized = false;
<span class="line-added">155     bool isSyncXHRInitialized = false;</span>
<span class="line-added">156     bool isFullscreenInitialized = false;</span>
157     for (auto allowItem : allowAttributeValue.split(&#39;;&#39;)) {
158         auto item = allowItem.stripLeadingAndTrailingMatchedCharacters(isHTMLSpace&lt;UChar&gt;);
159         if (item.startsWith(&quot;camera&quot;)) {
160             isCameraInitialized = true;
161             updateList(document, policy.m_cameraRule, item.substring(7));
162             continue;
163         }
164         if (item.startsWith(&quot;microphone&quot;)) {
165             isMicrophoneInitialized = true;
166             updateList(document, policy.m_microphoneRule, item.substring(11));
167             continue;
168         }
169         if (item.startsWith(&quot;display-capture&quot;)) {
170             isDisplayCaptureInitialized = true;
171             updateList(document, policy.m_displayCaptureRule, item.substring(16));
172             continue;
173         }
<span class="line-added">174         if (item.startsWith(&quot;sync-xhr&quot;)) {</span>
<span class="line-added">175             isSyncXHRInitialized = true;</span>
<span class="line-added">176             updateList(document, policy.m_syncXHRRule, item.substring(8));</span>
<span class="line-added">177             continue;</span>
<span class="line-added">178         }</span>
<span class="line-added">179         if (item.startsWith(&quot;fullscreen&quot;)) {</span>
<span class="line-added">180             isFullscreenInitialized = true;</span>
<span class="line-added">181             updateList(document, policy.m_fullscreenRule, item.substring(11));</span>
<span class="line-added">182             continue;</span>
<span class="line-added">183         }</span>
184     }
185 
<span class="line-modified">186     // By default, camera, microphone, display-capture, and fullscreen policy is &#39;self&#39;</span>
187     if (!isCameraInitialized)
188         policy.m_cameraRule.allowedList.add(document.securityOrigin().data());
189     if (!isMicrophoneInitialized)
190         policy.m_microphoneRule.allowedList.add(document.securityOrigin().data());
191     if (!isDisplayCaptureInitialized)
192         policy.m_displayCaptureRule.allowedList.add(document.securityOrigin().data());
193 
<span class="line-added">194     // https://w3c.github.io/webappsec-feature-policy/#process-feature-policy-attributes</span>
<span class="line-added">195     // 9.5 Process Feature Policy Attributes</span>
<span class="line-added">196     // 3.1 If elementâ€™s allowfullscreen attribute is specified, and container policy does</span>
<span class="line-added">197     //     not contain an allowlist for fullscreen,</span>
<span class="line-added">198     if (!isFullscreenInitialized) {</span>
<span class="line-added">199         if (iframe.hasAttribute(allowfullscreenAttr) || iframe.hasAttribute(webkitallowfullscreenAttr)) {</span>
<span class="line-added">200             // 3.1.1 Construct a new declaration for fullscreen, whose allowlist is the special value *.</span>
<span class="line-added">201             policy.m_fullscreenRule.type = FeaturePolicy::AllowRule::Type::All;</span>
<span class="line-added">202         } else {</span>
<span class="line-added">203             // https://fullscreen.spec.whatwg.org/#feature-policy-integration</span>
<span class="line-added">204             // The default allowlist is &#39;self&#39;.</span>
<span class="line-added">205             policy.m_fullscreenRule.allowedList.add(document.securityOrigin().data());</span>
<span class="line-added">206         }</span>
<span class="line-added">207     }</span>
<span class="line-added">208 </span>
<span class="line-added">209     if (!isSyncXHRInitialized)</span>
<span class="line-added">210         policy.m_syncXHRRule.type = AllowRule::Type::All;</span>
<span class="line-added">211 </span>
212     return policy;
213 }
214 
215 bool FeaturePolicy::allows(Type type, const SecurityOriginData&amp; origin) const
216 {
217     switch (type) {
218     case Type::Camera:
219         return isAllowedByFeaturePolicy(m_cameraRule, origin);
220     case Type::Microphone:
221         return isAllowedByFeaturePolicy(m_microphoneRule, origin);
222     case Type::DisplayCapture:
223         return isAllowedByFeaturePolicy(m_displayCaptureRule, origin);
<span class="line-added">224     case Type::SyncXHR:</span>
<span class="line-added">225         return isAllowedByFeaturePolicy(m_syncXHRRule, origin);</span>
<span class="line-added">226     case Type::Fullscreen:</span>
<span class="line-added">227         return isAllowedByFeaturePolicy(m_fullscreenRule, origin);</span>
228     }
229     ASSERT_NOT_REACHED();
230     return false;
231 }
232 
233 }
</pre>
</td>
</tr>
</table>
<center><a href="FTPDirectoryDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FeaturePolicy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>