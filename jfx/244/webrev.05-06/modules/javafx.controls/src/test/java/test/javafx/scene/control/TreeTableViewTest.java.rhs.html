<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/TreeTableViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  29 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  30 import static javafx.scene.control.TreeTableColumn.SortType.ASCENDING;
  31 import static javafx.scene.control.TreeTableColumn.SortType.DESCENDING;
  32 import static org.junit.Assert.*;
  33 import static org.junit.Assert.assertEquals;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.List;
  38 import java.util.Objects;
  39 import java.util.concurrent.atomic.AtomicInteger;
  40 import java.util.function.Consumer;
  41 import java.util.function.Supplier;
  42 import java.util.stream.Collectors;
  43 
  44 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  45 import javafx.beans.property.ReadOnlyIntegerWrapper;
  46 import javafx.collections.transformation.FilteredList;
  47 import javafx.scene.control.TableColumn;
  48 import javafx.scene.control.TableView;
  49 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  50 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  51 import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;
  52 import javafx.scene.control.skin.TreeTableCellSkin;
  53 import test.com.sun.javafx.scene.control.test.Data;
  54 
  55 import javafx.application.Platform;
  56 import javafx.beans.InvalidationListener;
  57 import javafx.beans.Observable;
  58 import javafx.beans.binding.Bindings;
  59 import javafx.beans.binding.ObjectBinding;
  60 import javafx.beans.property.ObjectProperty;
  61 import javafx.beans.property.ReadOnlyBooleanWrapper;
  62 import javafx.beans.property.ReadOnlyObjectWrapper;
  63 import javafx.beans.property.ReadOnlyStringWrapper;
  64 import javafx.beans.property.SimpleObjectProperty;
  65 import javafx.beans.property.SimpleStringProperty;
  66 import javafx.collections.FXCollections;
  67 import javafx.collections.ListChangeListener;
  68 import javafx.collections.ObservableList;
  69 import javafx.event.EventHandler;
  70 import javafx.scene.Group;
  71 import javafx.scene.Node;
  72 import javafx.scene.Scene;
  73 import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
  74 import javafx.scene.control.cell.*;
  75 import javafx.scene.image.ImageView;
  76 import javafx.scene.input.KeyCode;
  77 import javafx.scene.layout.StackPane;
  78 import javafx.scene.layout.VBox;
  79 import javafx.scene.paint.Color;
  80 import javafx.scene.shape.Circle;
  81 import javafx.scene.shape.Rectangle;
  82 import javafx.stage.Stage;
  83 import javafx.util.Callback;
  84 
  85 import org.junit.Before;
  86 import org.junit.Ignore;
  87 import org.junit.Test;
  88 
  89 import com.sun.javafx.scene.control.TableColumnComparatorBase.TreeTableColumnComparator;
  90 import test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils;
  91 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  92 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  93 import com.sun.javafx.scene.control.VirtualScrollBar;
  94 import test.com.sun.javafx.scene.control.test.Person;
  95 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  96 import com.sun.javafx.tk.Toolkit;
  97 import javafx.scene.control.Button;
  98 import javafx.scene.control.Cell;
  99 import javafx.scene.control.FocusModel;
 100 import javafx.scene.control.IndexedCell;
 101 import javafx.scene.control.MultipleSelectionModel;
 102 import javafx.scene.control.MultipleSelectionModelBaseShim;
 103 import javafx.scene.control.SelectionMode;
 104 import javafx.scene.control.TableColumnBaseShim;
 105 import javafx.scene.control.TableSelectionModel;
 106 import javafx.scene.control.TextField;
 107 import javafx.scene.control.TreeItem;
 108 import javafx.scene.control.TreeTableCell;
 109 import javafx.scene.control.TreeTableCellShim;
 110 import javafx.scene.control.TreeTableColumn;
 111 import javafx.scene.control.TreeTablePosition;
 112 import javafx.scene.control.TreeTableRow;
 113 import javafx.scene.control.TreeTableRowShim;
 114 import javafx.scene.control.TreeTableView;
 115 import javafx.scene.control.TreeTableViewShim;
 116 import javafx.scene.control.TreeView;
 117 
 118 public class TreeTableViewTest {
 119     private TreeTableView&lt;String&gt; treeTableView;
 120     private TreeTableView.TreeTableViewSelectionModel sm;
 121     private TreeTableViewFocusModel&lt;String&gt; fm;
 122 
 123 
 124     // sample data #1
 125     private TreeItem&lt;String&gt; root;
 126     private TreeItem&lt;String&gt; child1;
 127     private TreeItem&lt;String&gt; child2;
 128     private TreeItem&lt;String&gt; child3;
 129 
 130     // sample data #1
 131     private TreeItem&lt;String&gt; myCompanyRootNode;
 132         private TreeItem&lt;String&gt; salesDepartment;
 133             private TreeItem&lt;String&gt; ethanWilliams;
 134             private TreeItem&lt;String&gt; emmaJones;
 135             private TreeItem&lt;String&gt; michaelBrown;
 136             private TreeItem&lt;String&gt; annaBlack;
 137             private TreeItem&lt;String&gt; rodgerYork;
 138             private TreeItem&lt;String&gt; susanCollins;
 139 
 140         private TreeItem&lt;String&gt; itSupport;
 141             private TreeItem&lt;String&gt; mikeGraham;
 142             private TreeItem&lt;String&gt; judyMayer;
 143             private TreeItem&lt;String&gt; gregorySmith;
 144 
 145     @Before public void setup() {
 146         treeTableView = new TreeTableView&lt;String&gt;();
 147         sm = treeTableView.getSelectionModel();
 148         fm = treeTableView.getFocusModel();
 149 
 150         // build sample data #2, even though it may not be used...
 151         myCompanyRootNode = new TreeItem&lt;String&gt;(&quot;MyCompany Human Resources&quot;);
 152         salesDepartment = new TreeItem&lt;String&gt;(&quot;Sales Department&quot;);
 153             ethanWilliams = new TreeItem&lt;String&gt;(&quot;Ethan Williams&quot;);
 154             emmaJones = new TreeItem&lt;String&gt;(&quot;Emma Jones&quot;);
 155             michaelBrown = new TreeItem&lt;String&gt;(&quot;Michael Brown&quot;);
 156             annaBlack = new TreeItem&lt;String&gt;(&quot;Anna Black&quot;);
 157             rodgerYork = new TreeItem&lt;String&gt;(&quot;Rodger York&quot;);
 158             susanCollins = new TreeItem&lt;String&gt;(&quot;Susan Collins&quot;);
 159 
 160         itSupport = new TreeItem&lt;String&gt;(&quot;IT Support&quot;);
 161             mikeGraham = new TreeItem&lt;String&gt;(&quot;Mike Graham&quot;);
 162             judyMayer = new TreeItem&lt;String&gt;(&quot;Judy Mayer&quot;);
 163             gregorySmith = new TreeItem&lt;String&gt;(&quot;Gregory Smith&quot;);
 164 
 165         myCompanyRootNode.getChildren().setAll(
 166             salesDepartment,
 167             itSupport
 168         );
 169         salesDepartment.getChildren().setAll(
 170             ethanWilliams,
 171             emmaJones,
 172             michaelBrown,
 173             annaBlack,
 174             rodgerYork,
 175             susanCollins
 176         );
 177         itSupport.getChildren().setAll(
 178             mikeGraham,
 179             judyMayer,
 180             gregorySmith
 181         );
 182     }
 183 
 184     private void installChildren() {
 185         root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
 186         child1 = new TreeItem&lt;String&gt;(&quot;Child 1&quot;);
 187         child2 = new TreeItem&lt;String&gt;(&quot;Child 2&quot;);
 188         child3 = new TreeItem&lt;String&gt;(&quot;Child 3&quot;);
 189         root.setExpanded(true);
 190         root.getChildren().setAll(child1, child2, child3);
 191         treeTableView.setRoot(root);
 192     }
 193 
 194     private String debug() {
 195         StringBuilder sb = new StringBuilder(&quot;Selected Cells: [&quot;);
 196 
 197         List&lt;TreeTablePosition&lt;?,?&gt;&gt; cells = sm.getSelectedCells();
 198         for (TreeTablePosition cell : cells) {
 199             sb.append(&quot;(&quot;);
 200             sb.append(cell.getRow());
 201             sb.append(&quot;,&quot;);
 202             sb.append(cell.getColumn());
 203             sb.append(&quot;), &quot;);
 204         }
 205 
 206         sb.append(&quot;] \nFocus: &quot; + fm.getFocusedIndex());
 207 //        sb.append(&quot; \nAnchor: &quot; + getAnchor());
 208         return sb.toString();
 209     }
 210 
 211     @Test public void ensureCorrectInitialState() {
 212         installChildren();
 213         assertEquals(0, treeTableView.getRow(root));
 214         assertEquals(1, treeTableView.getRow(child1));
 215         assertEquals(2, treeTableView.getRow(child2));
 216         assertEquals(3, treeTableView.getRow(child3));
 217     }
 218 
 219 
 220 
 221 
 222 
 223 
 224 
 225 
 226     /***************************************************************************
 227      *
 228      *
 229      * Tests taken from TableViewTest
 230      * (scroll down further for the TreeViewTests)
 231      *
 232      *
 233      **************************************************************************/
 234 
 235     /*********************************************************************
 236      * Tests for the constructors                                        *
 237      ********************************************************************/
 238 
 239     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 240         assertNotNull(sm);
 241     }
 242 
 243     @Test public void noArgConstructor_selectedItemIsNull() {
 244         assertNull(sm.getSelectedItem());
 245     }
 246 
 247     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 248         assertEquals(-1, sm.getSelectedIndex());
 249     }
 250 
 251     @Test public void noArgConstructorSetsNonNullSortPolicy() {
 252         assertNotNull(treeTableView.getSortPolicy());
 253     }
 254 
 255     @Test public void noArgConstructorSetsNullComparator() {
 256         assertNull(treeTableView.getComparator());
 257     }
 258 
 259     @Test public void noArgConstructorSetsNullOnSort() {
 260         assertNull(treeTableView.getOnSort());
 261     }
 262 
 263 //    @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 264 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 265 //        assertNotNull(b2.getSelectionModel());
 266 //    }
 267 //
 268 //    @Test public void singleArgConstructorAllowsNullItems() {
 269 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(null);
 270 //        assertNull(b2.getItems());
 271 //    }
 272 //
 273 //    @Test public void singleArgConstructorTakesItems() {
 274 //        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 275 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(items);
 276 //        assertSame(items, b2.getItems());
 277 //    }
 278 //
 279 //    @Test public void singleArgConstructor_selectedItemIsNull() {
 280 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 281 //        assertNull(b2.getSelectionModel().getSelectedItem());
 282 //    }
 283 //
 284 //    @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 285 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 286 //        assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 287 //    }
 288 
 289     /*********************************************************************
 290      * Tests for columns                                                 *
 291      ********************************************************************/
 292 
 293     @Test public void testColumns() {
 294         TreeTableColumn col1 = new TreeTableColumn();
 295 
 296         assertNotNull(treeTableView.getColumns());
 297         assertEquals(0, treeTableView.getColumns().size());
 298 
 299         treeTableView.getColumns().add(col1);
 300         assertEquals(1, treeTableView.getColumns().size());
 301 
 302         treeTableView.getColumns().remove(col1);
 303         assertEquals(0, treeTableView.getColumns().size());
 304     }
 305 
 306     @Test public void testVisibleLeafColumns() {
 307         TreeTableColumn col1 = new TreeTableColumn();
 308 
 309         assertNotNull(treeTableView.getColumns());
 310         assertEquals(0, treeTableView.getColumns().size());
 311 
 312         treeTableView.getColumns().add(col1);
 313         assertEquals(1, treeTableView.getVisibleLeafColumns().size());
 314 
 315         treeTableView.getColumns().remove(col1);
 316         assertEquals(0, treeTableView.getVisibleLeafColumns().size());
 317     }
 318 
 319     @Test public void testSortOrderCleanup() {
 320         TreeTableView treeTableView = new TreeTableView();
 321         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 322         first.setCellValueFactory(new PropertyValueFactory(&quot;firstName&quot;));
 323         TreeTableColumn&lt;String,String&gt; second = new TreeTableColumn&lt;String,String&gt;(&quot;second&quot;);
 324         second.setCellValueFactory(new PropertyValueFactory(&quot;lastName&quot;));
 325         treeTableView.getColumns().addAll(first, second);
 326         treeTableView.getSortOrder().setAll(first, second);
 327         treeTableView.getColumns().remove(first);
 328         assertFalse(treeTableView.getSortOrder().contains(first));
 329     }
 330 
 331 
 332     /*********************************************************************
 333      * Tests for new sorting API in JavaFX 8.0                           *
 334      ********************************************************************/
 335 
 336     private TreeItem&lt;String&gt; apple, orange, banana;
 337 
 338     // TODO test for sort policies returning null
 339     // TODO test for changing column sortType out of order
 340 
 341     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; NO_SORT_FAILED_SORT_POLICY =
 342             treeTableView1 -&gt; false;
 343 
 344     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; SORT_SUCCESS_ASCENDING_SORT_POLICY =
 345             treeTableView1 -&gt; {
 346                 if (treeTableView1.getSortOrder().isEmpty()) return true;
 347                 FXCollections.sort(treeTableView1.getRoot().getChildren(), new Comparator&lt;TreeItem&lt;String&gt;&gt;() {
 348                     @Override public int compare(TreeItem&lt;String&gt; o1, TreeItem&lt;String&gt; o2) {
 349                         return o1.getValue().compareTo(o2.getValue());
 350                     }
 351                 });
 352                 return true;
 353             };
 354 
 355     private TreeTableColumn&lt;String, String&gt; initSortTestStructure() {
 356         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 357         col.setSortType(ASCENDING);
 358         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 359         treeTableView.getColumns().add(col);
 360 
 361         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 362         newRoot.setExpanded(true);
 363         newRoot.getChildren().addAll(
 364                 apple  = new TreeItem(&quot;Apple&quot;),
 365                 orange = new TreeItem(&quot;Orange&quot;),
 366                 banana = new TreeItem(&quot;Banana&quot;));
 367 
 368         treeTableView.setRoot(newRoot);
 369 
 370         return col;
 371     }
 372 
 373     private int countSelectedIndexChangeEvent;
 374     private int countSelectedItemChangeEvent;
 375     private int countSelectedIndicesChangeEvent;
 376     private int countSelectedItemsChangeEvent;
 377     private int expectedCountSelectedIndexChangeEvent;
 378     private int expectedCountSelectedItemChangeEvent;
 379     private int expectedCountSelectedIndicesChangeEvent;
 380     private int expectedCountSelectedItemsChangeEvent;
 381     private TreeItem&lt;String&gt; selectedItemBefore;
 382     private List&lt;TreeItem&lt;String&gt;&gt; selectedItemsBefore;
 383     private List&lt;Integer&gt; selectedIndicesBefore;
 384     private List&lt;TreeTablePosition&lt;String,?&gt;&gt; selectedCellsBefore;
 385 
 386     @Test public void testSelectionUpdatesCorrectlyAfterSort() {
 387         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();
 388         treeTableView.getSortOrder().add(col);
 389         verifySelectionAfterPermutation();
 390     }
 391 
 392     @Test public void testSelectionUpdatesCorrectlyAfterRootReverseAndSetAll() {
 393         setupForPermutationTest();
 394         TreeItem&lt;String&gt; parentTreeItem = treeTableView.getRoot();
 395         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 396         parentTreeItem.getChildren().setAll(childrenReversed);
 397         verifySelectionAfterPermutation();
 398     }
 399 
<a name="1" id="anc1"></a><span class="line-modified"> 400     @Ignore(&quot;JDK-8193442&quot;)</span>
 401     @Test public void testSelectionUpdatesCorrectlyAfterRemovingSelectedItem() {
 402         setupForPermutationTest();
 403         TreeItem&lt;String&gt; parentOfSelectedTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 404         expectedCountSelectedItemChangeEvent = 1;
 405         selectedItemBefore = treeTableView.getTreeItem(
 406                 (int)sm.getSelectedIndices().get(sm.getSelectedIndices().size() - 1));
 407         parentOfSelectedTreeItem.getChildren().remove(sm.getSelectedItem());
 408         verifySelectionAfterPermutation();
 409     }
 410 
<a name="2" id="anc2"></a><span class="line-modified"> 411     @Ignore(&quot;JDK-8248389&quot;)</span>
 412     @Test public void testSelectionUpdatesCorrectlyAfterAddingAnItemBeforeSelectedItem() {
 413         setupForPermutationTest();
 414         TreeItem&lt;String&gt; parentOfSelectedTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 415         int indexOfSelectedItem = parentOfSelectedTreeItem.getChildren().indexOf(sm.getSelectedItem());
 416         if (indexOfSelectedItem &gt; 0) {
 417             indexOfSelectedItem--;
 418         }
 419         parentOfSelectedTreeItem.getChildren().add(indexOfSelectedItem, new TreeItem(&quot;AddingOne&quot;));
 420         verifySelectionAfterPermutation();
 421     }
 422 
 423     @Test public void testSelectionUpdatesCorrectlyAfterChildReverseAndSetAll() {
 424         setupForPermutationTest();
 425         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 426         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 427         parentTreeItem.getChildren().setAll(childrenReversed);
 428         verifySelectionAfterPermutation();
 429     }
 430 
<a name="3" id="anc3"></a><span class="line-modified"> 431     @Ignore(&quot;JDK-8193442&quot;)</span>
 432     @Test public void testSelectionUpdatesCorrectlyAfterChildReverseRemoveOneAndSetAll() {
 433         setupForPermutationTest();
 434         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 435         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = getReverseChildrenOrder(parentTreeItem);
 436         childrenReversed.remove(0);
 437         parentTreeItem.getChildren().setAll(childrenReversed);
 438         verifySelectionAfterPermutation();
 439     }
 440 
<a name="4" id="anc4"></a><span class="line-modified"> 441     @Ignore(&quot;JDK-8193442&quot;)</span>
 442     @Test public void testSelectionUpdatesCorrectlyAfterChildRemoveOneAndSetAll() {
<a name="5" id="anc5"></a>
 443         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 444         List&lt;TreeItem&lt;String&gt;&gt; children = new ArrayList&lt;&gt;(parentTreeItem.getChildren());
 445         children.remove(0);
 446         parentTreeItem.getChildren().setAll(children);
 447         verifySelectionAfterPermutation();
 448     }
 449 
<a name="6" id="anc6"></a><span class="line-modified"> 450     @Ignore(&quot;JDK-8193442&quot;)</span>
 451     @Test public void testSelectionUpdatesCorrectlyAfterChildRemoveOneAndSetAllAndSort() {
 452         TreeTableColumn&lt;String, String&gt; col = setupForPermutationTest();
 453         TreeItem&lt;String&gt; parentTreeItem = ((TreeItem&lt;String&gt;)sm.getSelectedItem()).getParent();
 454         List&lt;TreeItem&lt;String&gt;&gt; children = new ArrayList&lt;&gt;(parentTreeItem.getChildren());
 455         children.remove(0);
 456         parentTreeItem.getChildren().setAll(children);
 457         treeTableView.getSortOrder().add(col);
 458         verifySelectionAfterPermutation();
 459     }
 460 
 461     private List&lt;TreeItem&lt;String&gt;&gt; getReverseChildrenOrder(TreeItem&lt;String&gt; treeItem) {
 462         List&lt;TreeItem&lt;String&gt;&gt; childrenReversed = new ArrayList&lt;&gt;();
 463         int childrenSize = treeItem.getChildren().size();
 464         for (int i = 0; i &lt; childrenSize; i++) {
 465             childrenReversed.add(treeItem.getChildren().get(childrenSize - 1 - i));
 466         }
 467         return childrenReversed;
 468     }
 469 
 470     private TreeTableColumn&lt;String, String&gt; setupForPermutationTest() {
 471         countSelectedIndexChangeEvent = 0;
 472         countSelectedItemChangeEvent = 0;
 473         countSelectedIndicesChangeEvent = 0;
 474         countSelectedItemsChangeEvent = 0;
 475         expectedCountSelectedIndexChangeEvent = 1;
 476         expectedCountSelectedItemChangeEvent = 0;
 477         expectedCountSelectedIndicesChangeEvent = 1;
 478         expectedCountSelectedItemsChangeEvent = 1;
 479 
 480         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 481         col.setSortType(DESCENDING);
 482         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 483         treeTableView.getColumns().add(col);
 484 
 485         TreeItem&lt;String&gt; treeRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 486         treeRoot.setExpanded(true);
 487         treeTableView.setRoot(treeRoot);
 488 
 489         final int FIRST_LEVEL_COUNT = 8;
 490         for (int i = 0; i &lt; FIRST_LEVEL_COUNT; i++) {
 491             TreeItem&lt;String&gt; ti = new TreeItem&lt;&gt;( &quot;&quot; + i);
 492             ti.setExpanded(true);
 493             treeRoot.getChildren().add(ti);
 494 
 495             for (int j = 0; j &lt; FIRST_LEVEL_COUNT - 1; j++) {
 496                 TreeItem&lt;String&gt; tj = new TreeItem&lt;&gt;(&quot;&quot; + i + j);
 497                 tj.setExpanded(true);
 498                 ti.getChildren().add(tj);
 499 
 500                 for (int k = 0; k &lt; FIRST_LEVEL_COUNT - 2; k++) {
 501                     TreeItem&lt;String&gt; tk = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k);
 502                     tk.setExpanded(true);
 503                     tj.getChildren().add(tk);
 504 
 505                     for (int l = 0; l &lt; FIRST_LEVEL_COUNT - 3; l++) {
 506                         TreeItem&lt;String&gt; tl = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l);
 507                         tl.setExpanded(true);
 508                         tk.getChildren().add(tl);
 509 
 510                         for (int m = 0; m &lt; FIRST_LEVEL_COUNT - 4; m++) {
 511                             TreeItem&lt;String&gt; tm = new TreeItem&lt;&gt;(&quot;&quot; + i + j + k + l + m);
 512                             tl.getChildren().add(tm);
 513                         }
 514                     }
 515                 }
 516             }
 517         }
 518 
 519         sm.setSelectionMode(SelectionMode.MULTIPLE);
 520         int indices[] = new int[] {1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400};
 521         sm.selectIndices(1, 400, 800, 1200, 1600, 2000, 2400, 2800, 3200, 3600, 4000, 4400, 4800, 5200, 5600, 6000, 6400);
 522 
 523         // Sanity checks
 524         assertEquals(indices.length, sm.getSelectedIndices().size());
 525         assertEquals(indices.length, sm.getSelectedItems().size());
 526         assertEquals(indices.length, sm.getSelectedCells().size());
 527         assertEquals(indices[indices.length - 1], sm.getSelectedIndex());
 528         assertEquals(treeTableView.getTreeItem(indices[indices.length - 1]), sm.getSelectedItem());
 529 
 530         selectedItemBefore = (TreeItem&lt;String&gt;) sm.getSelectedItem();
 531         selectedItemsBefore = new ArrayList&lt;&gt;(sm.getSelectedItems());
 532         selectedIndicesBefore = new ArrayList&lt;&gt;(sm.getSelectedIndices());
 533         selectedCellsBefore = new ArrayList&lt;&gt;(sm.getSelectedCells());
 534 
 535         sm.selectedIndexProperty().addListener(ov -&gt; {
 536             countSelectedIndexChangeEvent++;
 537             assertEquals(selectedItemBefore, treeTableView.getTreeItem(sm.getSelectedIndex()));
 538         });
 539         sm.selectedItemProperty().addListener(l -&gt; {
 540             countSelectedItemChangeEvent++;
 541         });
 542         sm.getSelectedIndices().addListener((ListChangeListener) c -&gt; {
 543             countSelectedIndicesChangeEvent++;
 544             c.next();
 545             if (c.wasRemoved()) {
 546                 assertTrue(selectedIndicesBefore.equals(c.getRemoved()));
 547             }
 548             verifySelectedIndices(c.getAddedSubList());
 549             verifySelectedIndices(c.getList());
 550         });
 551         sm.getSelectedItems().addListener((ListChangeListener) c -&gt; {
 552             countSelectedItemsChangeEvent++;
 553             c.next();
 554             if (c.wasRemoved()) {
 555                 verifySelectedItems(c.getRemoved());
 556             }
 557             verifySelectedItems(c.getAddedSubList());
 558             verifySelectedItems(c.getList());
 559         });
 560 
 561         return col;
 562     }
 563 
 564     private void verifySelectedCells(List&lt;TreeTablePosition&lt;String, ?&gt;&gt; selectedCells) {
 565         assertEquals(selectedCellsBefore.size(), selectedCells.size());
 566         for (TreeTablePosition beforePos : selectedCellsBefore) {
 567             boolean isCellStillSelected = false;
 568             for (TreeTablePosition afterPos : selectedCells) {
 569                 if ((beforePos.getTreeItem() == afterPos.getTreeItem()) &amp;&amp;
 570                         (beforePos.getTableColumn() == afterPos.getTableColumn()) &amp;&amp;
 571                         (beforePos.getColumn() == afterPos.getColumn())) {
 572                     isCellStillSelected = true;
 573                 }
 574             }
 575             assertTrue(&quot;The item (&quot; + beforePos.getRow() + &quot;, &quot; + beforePos.getColumn() +
 576                     &quot;) lost selection during permutation&quot;, isCellStillSelected);
 577         }
 578     }
 579 
 580     private void verifySelectedItems(List&lt;TreeItem&lt;String&gt;&gt; selectedItems) {
 581         assertEquals(selectedItemsBefore.size(), selectedItems.size());
 582         for (TreeItem&lt;String&gt; item : selectedItemsBefore) {
 583             assertTrue(&quot;The item (&quot; + item + &quot;) lost selection during permutation&quot;,
 584                     selectedItems.contains(item));
 585         }
 586     }
 587 
 588     private void verifySelectedIndices(List&lt;Integer&gt; currentIndices) {
 589         assertEquals(selectedIndicesBefore.size(), currentIndices.size());
 590         for (Integer row : currentIndices) {
 591             assertTrue(selectedItemsBefore.contains(treeTableView.getTreeItem(row)));
 592         }
 593     }
 594 
 595     private void verifySelectionAfterPermutation() {
 596         assertEquals(expectedCountSelectedIndexChangeEvent, countSelectedIndexChangeEvent);
 597         assertEquals(expectedCountSelectedItemChangeEvent, countSelectedItemChangeEvent);
 598         assertEquals(expectedCountSelectedIndicesChangeEvent, countSelectedIndicesChangeEvent);
 599         assertEquals(expectedCountSelectedItemsChangeEvent, countSelectedItemsChangeEvent);
 600 
 601         assertEquals(&quot;Selected Item should remain same&quot;, selectedItemBefore, sm.getSelectedItem());
 602         assertEquals(&quot;Selected index should be updated&quot;, treeTableView.getRow(selectedItemBefore), sm.getSelectedIndex());
 603 
 604         verifySelectedCells(sm.getSelectedCells());
 605         verifySelectedItems(sm.getSelectedItems());
 606         verifySelectedIndices(sm.getSelectedIndices());
 607     }
 608 
 609     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 610     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeSortOrderList() {
 611         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 612         treeTableView.setOnSort(event -&gt; {
 613             event.consume();
 614         });
 615 
 616         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 617         treeTableView.getSortOrder().add(col);
 618         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 619 
 620         // the sort order list should be returned back to its original state
 621         assertTrue(treeTableView.getSortOrder().isEmpty());
 622     }
 623 
 624     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeSortOrderList() {
 625         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 626         treeTableView.setOnSort(event -&gt; {
 627             // do not consume here - this allows the sort to happen
 628         });
 629 
 630         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 631         treeTableView.getSortOrder().add(col);
 632         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 633 
 634         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 635     }
 636 
 637     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 638     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_AscendingToDescending() {
 639         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 640         assertEquals(ASCENDING, col.getSortType());
 641         treeTableView.getSortOrder().add(col);
 642         treeTableView.setOnSort(event -&gt; {
 643             event.consume();
 644         });
 645 
 646         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 647 
 648         // when we change from ASCENDING to DESCENDING we don&#39;t expect the sort
 649         // to actually change (and in fact we expect the sort type to resort
 650         // back to being ASCENDING)
 651         col.setSortType(DESCENDING);
 652         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 653         assertEquals(ASCENDING, col.getSortType());
 654 
 655         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 656     }
 657 
 658     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_AscendingToDescending() {
 659         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 660         assertEquals(ASCENDING, col.getSortType());
 661         treeTableView.getSortOrder().add(col);
 662         treeTableView.setOnSort(event -&gt; {
 663             // do not consume here - this allows the sort to happen
 664         });
 665 
 666         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 667 
 668         col.setSortType(DESCENDING);
 669         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 670         assertEquals(DESCENDING, col.getSortType());
 671 
 672         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 673     }
 674 
 675     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 676     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_DescendingToNull() {
 677         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 678         col.setSortType(DESCENDING);
 679         assertEquals(DESCENDING, col.getSortType());
 680         treeTableView.getSortOrder().add(col);
 681         treeTableView.setOnSort(event -&gt; {
 682             event.consume();
 683         });
 684 
 685         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 686 
 687         col.setSortType(null);
 688         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 689         assertEquals(DESCENDING, col.getSortType());
 690 
 691         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 692     }
 693 
 694     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_DescendingToNull() {
 695         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 696         col.setSortType(DESCENDING);
 697         assertEquals(DESCENDING, col.getSortType());
 698         treeTableView.getSortOrder().add(col);
 699         treeTableView.setOnSort(event -&gt; {
 700             // do not consume here - this allows the sort to happen
 701         });
 702 
 703         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 704 
 705         col.setSortType(null);
 706         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 707         assertNull(col.getSortType());
 708 
 709         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 710     }
 711 
 712     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 713     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_NullToAscending() {
 714         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 715         col.setSortType(null);
 716         assertNull(col.getSortType());
 717         treeTableView.getSortOrder().add(col);
 718         treeTableView.setOnSort(event -&gt; {
 719             event.consume();
 720         });
 721 
 722         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 723 
 724         col.setSortType(ASCENDING);
 725         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 726         assertNull(col.getSortType());
 727 
 728         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 729     }
 730 
 731     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_NullToAscending() {
 732         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 733         col.setSortType(null);
 734         assertNull(col.getSortType());
 735         treeTableView.getSortOrder().add(col);
 736         treeTableView.setOnSort(event -&gt; {
 737             // do not consume here - this allows the sort to happen
 738         });
 739 
 740         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 741 
 742         col.setSortType(ASCENDING);
 743         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 744         assertEquals(ASCENDING, col.getSortType());
 745 
 746         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 747     }
 748 
 749     @Test public void testSortMethodWithNullSortPolicy() {
 750         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 751         treeTableView.setSortPolicy(null);
 752         assertNull(treeTableView.getSortPolicy());
 753         treeTableView.sort();
 754     }
 755 
 756     @Test public void testChangingSortPolicyUpdatesItemsList() {
 757         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 758         col.setSortType(DESCENDING);
 759         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 760         treeTableView.getSortOrder().add(col);
 761         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 762         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 763         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 764     }
 765 
 766     @Test public void testChangingSortPolicyDoesNotUpdateItemsListWhenTheSortOrderListIsEmpty() {
 767         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 768         col.setSortType(DESCENDING);
 769         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 770 
 771         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 772         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 773     }
 774 
 775     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderAddition() {
 776         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 777         col.setSortType(DESCENDING);
 778         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 779         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 780 
 781         treeTableView.getSortOrder().add(col);
 782 
 783         // no sort should be run (as we have a custom sort policy), and the
 784         // sortOrder list should be empty as the sortPolicy failed
 785         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 786         assertTrue(treeTableView.getSortOrder().isEmpty());
 787     }
 788 
 789     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderRemoval() {
 790         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 791         col.setSortType(DESCENDING);
 792         treeTableView.getSortOrder().add(col);
 793         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 794 
 795         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 796 
 797         // even though we remove the column from the sort order here, because the
 798         // sort policy fails the items list should remain unchanged and the sort
 799         // order list should continue to have the column in it.
 800         treeTableView.getSortOrder().remove(col);
 801         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 802         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 803     }
 804 
 805     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_ascendingToDescending() {
 806         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 807         col.setSortType(ASCENDING);
 808         treeTableView.getSortOrder().add(col);
 809         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 810 
 811         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 812 
 813         col.setSortType(DESCENDING);
 814         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 815         assertEquals(ASCENDING, col.getSortType());
 816     }
 817 
 818     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_descendingToNull() {
 819         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 820         col.setSortType(DESCENDING);
 821         treeTableView.getSortOrder().add(col);
 822         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 823 
 824         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 825 
 826         col.setSortType(null);
 827         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 828         assertEquals(DESCENDING, col.getSortType());
 829     }
 830 
 831     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_nullToAscending() {
 832         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 833         col.setSortType(null);
 834         treeTableView.getSortOrder().add(col);
 835         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 836 
 837         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 838 
 839         col.setSortType(ASCENDING);
 840         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 841         assertNull(col.getSortType());
 842     }
 843 
 844     @Test public void testComparatorChangesInSyncWithSortOrder_1() {
 845         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 846         assertNull(treeTableView.getComparator());
 847         assertTrue(treeTableView.getSortOrder().isEmpty());
 848 
 849         treeTableView.getSortOrder().add(col);
 850         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 851         assertNotNull(c);
 852         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 853     }
 854 
 855     @Test public void testComparatorChangesInSyncWithSortOrder_2() {
 856         // same as test above
 857         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 858         assertNull(treeTableView.getComparator());
 859         assertTrue(treeTableView.getSortOrder().isEmpty());
 860 
 861         treeTableView.getSortOrder().add(col);
 862         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 863         assertNotNull(c);
 864         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 865 
 866         // now remove column from sort order, and the comparator should go to
 867         // being null
 868         treeTableView.getSortOrder().remove(col);
 869         assertNull(treeTableView.getComparator());
 870     }
 871 
 872     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderAddition() {
 873         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 874         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 875 
 876         col.setSortType(DESCENDING);
 877         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 878         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 879 
 880         treeTableView.getSortOrder().add(col);
 881 
 882         assertEquals(oldComparator, treeTableView.getComparator());
 883     }
 884 
 885     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderRemoval() {
 886         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 887         TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 888         assertNull(oldComparator);
 889 
 890         col.setSortType(DESCENDING);
 891         treeTableView.getSortOrder().add(col);
 892         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 893         oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 894         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 895 
 896         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 897         treeTableView.getSortOrder().remove(col);
 898 
 899         assertTrue(treeTableView.getSortOrder().contains(col));
 900         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 901     }
 902 
 903     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortTypeChange() {
 904         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 905         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 906         assertNull(oldComparator);
 907 
 908         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 909         treeTableView.getSortOrder().add(col);
 910         col.setSortType(ASCENDING);
 911 
 912         assertTrue(treeTableView.getSortOrder().isEmpty());
 913         assertNull(oldComparator);
 914     }
 915 
 916 
 917 
 918     /*********************************************************************
 919      * Tests for specific bugs                                           *
 920      ********************************************************************/
 921 //    @Test public void test_rt16019() {
 922 //        // RT-16019: NodeMemory TableView tests fail with
 923 //        // IndexOutOfBoundsException (ObservableListWrapper.java:336)
 924 //        TreeTableView treeTableView = new TreeTableView();
 925 //        for (int i = 0; i &lt; 1000; i++) {
 926 //            treeTableView.getItems().add(&quot;data &quot; + i);
 927 //        }
 928 //    }
 929 //
 930 //    @Test public void test_rt15793() {
 931 //        // ListView/TableView selectedIndex is 0 although the items list is empty
 932 //        final TreeTableView tv = new TreeTableView();
 933 //        final ObservableList list = FXCollections.observableArrayList();
 934 //        tv.setItems(list);
 935 //        list.add(&quot;toto&quot;);
 936 //        tv.getSelectionModel().select(0);
 937 //        assertEquals(0, tv.getSelectionModel().getSelectedIndex());
 938 //        list.remove(0);
 939 //        assertEquals(-1, tv.getSelectionModel().getSelectedIndex());
 940 //    }
 941 //
 942 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 943 //        final TreeTableView lv = new TreeTableView();
 944 //        FocusModel fm = lv.getFocusModel();
 945 //        lv.getItems().add(&quot;row1&quot;);
 946 //        fm.focus(0);
 947 //        assertTrue(fm.isFocused(0));
 948 //
 949 //        lv.getItems().add(0, &quot;row0&quot;);
 950 //        assertTrue(fm.isFocused(1));
 951 //    }
 952 //
 953 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 954 //        final TreeTableView lv = new TreeTableView();
 955 //        FocusModel fm = lv.getFocusModel();
 956 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 957 //        fm.focus(1);
 958 //        assertTrue(fm.isFocused(1));
 959 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 960 //
 961 //        lv.getItems().add(1, &quot;row0&quot;);
 962 //        assertTrue(fm.isFocused(2));
 963 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 964 //        assertFalse(fm.isFocused(1));
 965 //    }
 966 //
 967 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 968 //        final TreeTableView lv = new TreeTableView();
 969 //        FocusModel fm = lv.getFocusModel();
 970 //        lv.getItems().addAll(&quot;row1&quot;);
 971 //        fm.focus(0);
 972 //        assertTrue(fm.isFocused(0));
 973 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 974 //
 975 //        lv.getItems().add(1, &quot;row2&quot;);
 976 //        assertTrue(fm.isFocused(0));
 977 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 978 //        assertFalse(fm.isFocused(1));
 979 //    }
 980 //
 981 //    @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 982 //        final TreeTableView lv = new TreeTableView();
 983 //        FocusModel fm = lv.getFocusModel();
 984 //        lv.getItems().add(&quot;row1&quot;);
 985 //        fm.focus(0);
 986 //        assertTrue(fm.isFocused(0));
 987 //
 988 //        lv.getItems().remove(&quot;row1&quot;);
 989 //        assertTrue(fm.getFocusedIndex() == -1);
 990 //        assertNull(fm.getFocusedItem());
 991 //    }
 992 //
 993 //    @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 994 //        final TreeTableView lv = new TreeTableView();
 995 //        FocusModel fm = lv.getFocusModel();
 996 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 997 //        fm.focus(1);
 998 //        assertTrue(fm.isFocused(1));
 999 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
1000 //
1001 //        lv.getItems().remove(&quot;row1&quot;);
1002 //        assertTrue(fm.isFocused(0));
1003 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
1004 //    }
1005 //
1006 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1007 //        final TreeTableView lv = new TreeTableView();
1008 //        FocusModel fm = lv.getFocusModel();
1009 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
1010 //        fm.focus(0);
1011 //        assertTrue(fm.isFocused(0));
1012 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
1013 //
1014 //        lv.getItems().remove(&quot;row2&quot;);
1015 //        assertTrue(fm.isFocused(0));
1016 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
1017 //    }
1018 //
1019 //    @Test public void test_rt18385() {
1020 //        treeTableView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1021 //        sm.select(1);
1022 //        treeTableView.getItems().add(&quot;Another Row&quot;);
1023 //        assertEquals(1, sm.getSelectedIndices().size());
1024 //        assertEquals(1, sm.getSelectedItems().size());
1025 //        assertEquals(1, sm.getSelectedCells().size());
1026 //    }
1027 
1028     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsFalse() {
1029         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1030         first.setEditable(false);
1031         treeTableView.getColumns().add(first);
1032         treeTableView.setEditable(false);
1033         treeTableView.edit(1, first);
1034         assertEquals(null, treeTableView.getEditingCell());
1035     }
1036 
1037     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsTrue() {
1038         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1039         first.setEditable(true);
1040         treeTableView.getColumns().add(first);
1041         treeTableView.setEditable(false);
1042         treeTableView.edit(1, first);
1043         assertEquals(null, treeTableView.getEditingCell());
1044     }
1045 
1046     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsFalse() {
1047         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1048         first.setEditable(false);
1049         treeTableView.getColumns().add(first);
1050         treeTableView.setEditable(true);
1051         treeTableView.edit(1, first);
1052         assertEquals(null, treeTableView.getEditingCell());
1053     }
1054 
1055     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsTrue() {
1056         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
1057         first.setEditable(true);
1058         treeTableView.getColumns().add(first);
1059         treeTableView.setEditable(true);
1060         treeTableView.edit(1, first);
1061         assertEquals(new TreeTablePosition(treeTableView, 1, first), treeTableView.getEditingCell());
1062     }
1063 
1064 //    @Test public void test_rt14451() {
1065 //        treeTableView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1066 //        sm.setSelectionMode(SelectionMode.MULTIPLE);
1067 //        sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1068 //        assertEquals(2, sm.getSelectedIndices().size());
1069 //    }
1070 //
1071 //    @Test public void test_rt21586() {
1072 //        treeTableView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
1073 //        treeTableView.getSelectionModel().select(1);
1074 //        assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1075 //        assertEquals(&quot;Orange&quot;, treeTableView.getSelectionModel().getSelectedItem());
1076 //
1077 //        treeTableView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
1078 //        assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1079 //        assertNull(treeTableView.getSelectionModel().getSelectedItem());
1080 //    }
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096     /***************************************************************************
1097      *
1098      *
1099      * Tests taken from TreeViewTest
1100      *
1101      *
1102      **************************************************************************/
1103 
1104 
1105 
1106 
1107     /*********************************************************************
1108      * Tests for the constructors                                        *
1109      ********************************************************************/
1110 
1111     @Test public void noArgConstructorSetsTheStyleClass() {
1112         assertStyleClassContains(treeTableView, &quot;tree-table-view&quot;);
1113     }
1114 
1115     @Test public void noArgConstructorSetsNullItems() {
1116         assertNull(treeTableView.getRoot());
1117     }
1118 
1119     @Test public void singleArgConstructorSetsTheStyleClass() {
1120         final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(new TreeItem&lt;String&gt;(&quot;Hi&quot;));
1121         assertStyleClassContains(b2, &quot;tree-table-view&quot;);
1122     }
1123 
1124     /*********************************************************************
1125      * Tests for selection model                                         *
1126      ********************************************************************/
1127 
1128     @Test public void selectionModelCanBeNull() {
1129         treeTableView.setSelectionModel(null);
1130         assertNull(treeTableView.getSelectionModel());
1131     }
1132 
1133     @Test public void selectionModelCanBeBound() {
1134         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1135                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1136         ObjectProperty&lt;TreeTableView.TreeTableViewSelectionModel&lt;String&gt;&gt; other =
1137                 new SimpleObjectProperty(sm);
1138         treeTableView.selectionModelProperty().bind(other);
1139         assertSame(sm, treeTableView.getSelectionModel());
1140     }
1141 
1142     @Test public void selectionModelCanBeChanged() {
1143         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1144                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1145         TreeTableViewShim.&lt;String&gt;setSelectionModel(treeTableView, sm);
1146         assertSame(sm, treeTableView.getSelectionModel());
1147     }
1148 
1149     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
1150         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1151         treeTableView.getSelectionModel().select(element);
1152         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1153         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1154     }
1155 
1156     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
1157         installChildren();
1158         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1159         treeTableView.getSelectionModel().select(element);
1160         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1161         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1162     }
1163 
1164     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
1165         installChildren();
1166         treeTableView.getSelectionModel().select(child1);
1167         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1168         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1169     }
1170 
1171     @Ignore(&quot;Not yet supported&quot;)
1172     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
1173         treeTableView.getSelectionModel().select(child1);
1174         installChildren();
1175         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1176         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1177     }
1178 
1179     @Ignore(&quot;Not yet supported&quot;)
1180     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
1181         installChildren();
1182         treeTableView.getSelectionModel().select(0);
1183         treeTableView.setRoot(null);
1184         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1185         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1186     }
1187 
1188     @Ignore(&quot;Not yet supported&quot;)
1189     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
1190         installChildren();
1191         treeTableView.getSelectionModel().select(2);
1192         treeTableView.setRoot(null);
1193         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1194         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1195     }
1196 
1197     @Ignore(&quot;Not yet supported&quot;)
1198     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
1199         installChildren();
1200         treeTableView.getSelectionModel().select(2);
1201         treeTableView.setRoot(null);
1202         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1203         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1204 
1205         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1206         TreeItem&lt;String&gt; newChild1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1207         TreeItem&lt;String&gt; newChild2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1208         TreeItem&lt;String&gt; newChild3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1209         newRoot.setExpanded(true);
1210         newRoot.getChildren().setAll(newChild1, newChild2, newChild3);
1211         treeTableView.setRoot(root);
1212 
1213         treeTableView.getSelectionModel().select(2);
1214         assertEquals(newChild2, treeTableView.getSelectionModel().getSelectedItem());
1215     }
1216 
1217     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
1218         installChildren();
1219         treeTableView.getSelectionModel().select(0);
1220         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1221 
1222         TreeItem newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1223         treeTableView.setRoot(newRoot);
1224         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1225         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1226         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1227         assertEquals(newRoot, treeTableView.getFocusModel().getFocusedItem());
1228     }
1229 
1230     @Test public void ensureSelectionRemainsOnBranchWhenExpanded() {
1231         installChildren();
1232         root.setExpanded(false);
1233         treeTableView.getSelectionModel().select(0);
1234         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1235         root.setExpanded(true);
1236         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1237         assertTrue(treeTableView.getSelectionModel().getSelectedItems().contains(root));
1238     }
1239 
1240     /*********************************************************************
1241      * Tests for misc                                                    *
1242      ********************************************************************/
1243     @Test public void ensureRootIndexIsZeroWhenRootIsShowing() {
1244         installChildren();
1245         assertEquals(0, treeTableView.getRow(root));
1246     }
1247 
1248     @Test public void ensureRootIndexIsNegativeOneWhenRootIsNotShowing() {
1249         installChildren();
1250         treeTableView.setShowRoot(false);
1251         assertEquals(-1, treeTableView.getRow(root));
1252     }
1253 
1254     @Test public void ensureCorrectIndexWhenRootTreeItemHasParent() {
1255         installChildren();
1256         treeTableView.setRoot(child1);
1257         assertEquals(-1, treeTableView.getRow(root));
1258         assertEquals(0, treeTableView.getRow(child1));
1259         assertEquals(1, treeTableView.getRow(child2));
1260         assertEquals(2, treeTableView.getRow(child3));
1261     }
1262 
1263     @Test public void ensureCorrectIndexWhenRootTreeItemHasParentAndRootIsNotShowing() {
1264         installChildren();
1265         treeTableView.setRoot(child1);
1266         treeTableView.setShowRoot(false);
1267 
1268         // despite the fact there are children in this tree, in reality none are
1269         // visible as the root node has no children (only siblings), and the
1270         // root node is not visible.
1271         assertEquals(0, treeTableView.getExpandedItemCount());
1272 
1273         assertEquals(-1, treeTableView.getRow(root));
1274         assertEquals(-1, treeTableView.getRow(child1));
1275         assertEquals(-1, treeTableView.getRow(child2));
1276         assertEquals(-1, treeTableView.getRow(child3));
1277     }
1278 
1279     @Test public void ensureCorrectIndexWhenRootTreeItemIsCollapsed() {
1280         installChildren();
1281         root.setExpanded(false);
1282         assertEquals(0, treeTableView.getRow(root));
1283 
1284         // note that the indices are negative, as these children rows are not
1285         // visible in the tree
1286         assertEquals(-1, treeTableView.getRow(child1));
1287         assertEquals(-1, treeTableView.getRow(child2));
1288         assertEquals(-1, treeTableView.getRow(child3));
1289     }
1290 
1291 //    @Test public void removingLastTest() {
1292 //        TreeTableView tree_view = new TreeTableView();
1293 //        MultipleSelectionModel sm = tree_view.getSelectionModel();
1294 //        TreeItem&lt;String&gt; tree_model = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1295 //        TreeItem node = new TreeItem(&quot;Data item&quot;);
1296 //        tree_model.getChildren().add(node);
1297 //        tree_view.setRoot(tree_model);
1298 //        tree_model.setExpanded(true);
1299 //        // select the &#39;Data item&#39; in the selection model
1300 //        sm.select(tree_model.getChildren().get(0));
1301 //        // remove the &#39;Data item&#39; from the root node
1302 //        tree_model.getChildren().remove(sm.getSelectedItem());
1303 //        // assert the there are no selected items any longer
1304 //        assertTrue(&quot;items: &quot; + sm.getSelectedItem(), sm.getSelectedItems().isEmpty());
1305 //    }
1306 
1307     /*********************************************************************
1308      * Tests from bug reports                                            *
1309      ********************************************************************/
1310     @Ignore @Test public void test_rt17112() {
1311         TreeItem&lt;String&gt; root1 = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1312         root1.setExpanded(true);
1313         addChildren(root1, &quot;child&quot;);
1314         for (TreeItem child : root1.getChildren()) {
1315             addChildren(child, (String)child.getValue());
1316             child.setExpanded(true);
1317         }
1318 
1319         final TreeTableView treeTableView1 = new TreeTableView();
1320         final MultipleSelectionModel sm = treeTableView1.getSelectionModel();
1321         sm.setSelectionMode(SelectionMode.MULTIPLE);
1322         treeTableView1.setRoot(root1);
1323 
1324         final TreeItem&lt;String&gt; rt17112_child1 = root1.getChildren().get(1);
1325         final TreeItem&lt;String&gt; rt17112_child1_0 = rt17112_child1.getChildren().get(0);
1326         final TreeItem&lt;String&gt; rt17112_child2 = root1.getChildren().get(2);
1327 
1328         sm.getSelectedItems().addListener(new InvalidationListener() {
1329             int count = 0;
1330             @Override public void invalidated(Observable observable) {
1331                 if (count == 0) {
1332                     assertEquals(rt17112_child1_0, sm.getSelectedItem());
1333                     assertEquals(1, sm.getSelectedIndices().size());
1334                     assertEquals(6, sm.getSelectedIndex());
1335                     assertTrue(treeTableView1.getFocusModel().isFocused(6));
1336                 } else if (count == 1) {
1337                     assertEquals(rt17112_child1, sm.getSelectedItem());
1338                     assertFalse(sm.getSelectedItems().contains(rt17112_child2));
1339                     assertEquals(1, sm.getSelectedIndices().size());
1340                     assertTrue(treeTableView1.getFocusModel().isFocused(5));
1341                 }
1342                 count++;
1343             }
1344         });
1345 
1346         // this triggers the first callback above, so that count == 0
1347         sm.select(rt17112_child1_0);
1348 
1349         // this triggers the second callback above, so that count == 1
1350         rt17112_child1.setExpanded(false);
1351     }
1352     private void addChildren(TreeItem parent, String name) {
1353         for (int i=0; i&lt;3; i++) {
1354             TreeItem&lt;String&gt; ti = new TreeItem&lt;String&gt;(name+&quot;-&quot;+i);
1355             parent.getChildren().add(ti);
1356         }
1357     }
1358 
1359     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex_1() {
1360         installChildren();
1361         FocusModel fm = treeTableView.getFocusModel();
1362         fm.focus(1);    // focus on child1
1363         assertTrue(fm.isFocused(1));
1364         assertEquals(child1, fm.getFocusedItem());
1365 
1366         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1367         root.getChildren().add(0, child0);  // 0th index == position of child1 in root
1368 
1369         assertEquals(child1, fm.getFocusedItem());
1370         assertTrue(fm.isFocused(2));
1371     }
1372 
1373     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex_1() {
1374         installChildren();
1375         FocusModel fm = treeTableView.getFocusModel();
1376         fm.focus(1);    // focus on child1
1377         assertTrue(fm.isFocused(1));
1378 
1379         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1380         root.getChildren().add(0, child0);
1381         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(2));
1382     }
1383 
1384     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex_1() {
1385         installChildren();
1386         FocusModel fm = treeTableView.getFocusModel();
1387         fm.focus(1);    // focus on child1
1388         assertTrue(fm.isFocused(1));
1389 
1390         TreeItem child4 = new TreeItem(&quot;child4&quot;);
1391         root.getChildren().add(3, child4);
1392         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1393     }
1394 
1395     @Test public void test_rt17522_focusShouldBeMovedWhenFocusedItemIsRemoved_1() {
1396         installChildren();
1397         FocusModel fm = treeTableView.getFocusModel();
1398         fm.focus(1);
1399         assertTrue(fm.isFocused(1));
1400 
1401         root.getChildren().remove(child1);
1402         assertEquals(0, fm.getFocusedIndex());
1403         assertEquals(treeTableView.getTreeItem(0), fm.getFocusedItem());
1404     }
1405 
1406     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex_1() {
1407         installChildren();
1408         FocusModel fm = treeTableView.getFocusModel();
1409         fm.focus(2);
1410         assertTrue(fm.isFocused(2));
1411 
1412         root.getChildren().remove(child1);
1413         assertTrue(fm.isFocused(1));
1414         assertEquals(child2, fm.getFocusedItem());
1415     }
1416 
1417 //    This test fails as, in TreeTableView FocusModel, we do not know the index of the
1418 //    removed tree items, which means we don&#39;t know whether they existed before
1419 //    or after the focused item.
1420 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1421 //        installChildren();
1422 //        FocusModel fm = treeTableView.getFocusModel();
1423 //        fm.focus(1);
1424 //        assertTrue(fm.isFocused(1));
1425 //
1426 //        root.getChildren().remove(child3);
1427 //        assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1428 //        assertEquals(child1, fm.getFocusedItem());
1429 //    }
1430 
1431     @Test public void test_rt18385() {
1432         installChildren();
1433 //        table.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1434         treeTableView.getSelectionModel().select(1);
1435         treeTableView.getRoot().getChildren().add(new TreeItem(&quot;Another Row&quot;));
1436         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndices().size());
1437         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1438     }
1439 
1440     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsFalse() {
1441         TreeItem root = new TreeItem(&quot;root&quot;);
1442         root.getChildren().setAll(
1443                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1444                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1445                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1446                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1447                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1448         root.setExpanded(true);
1449 
1450         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1451 
1452         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1453         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1454 
1455         table.setEditable(false);
1456         table.edit(0,firstNameCol);
1457         assertNull(table.getEditingCell());
1458     }
1459 
1460     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsTrue() {
1461         TreeItem root = new TreeItem(&quot;root&quot;);
1462         root.getChildren().setAll(
1463                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1464                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1465                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1466                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1467                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1468         root.setExpanded(true);
1469 
1470         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1471 
1472         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1473         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1474 
1475         table.setEditable(true);
1476         table.edit(0,firstNameCol);
1477         assertEquals(root, table.getEditingCell().getTreeItem());
1478     }
1479 
1480     @Test public void test_rt14451() {
1481         installChildren();
1482         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1483         treeTableView.getSelectionModel().selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1484         assertEquals(2, treeTableView.getSelectionModel().getSelectedIndices().size());
1485     }
1486 
1487     @Test public void test_rt21586() {
1488         installChildren();
1489         treeTableView.getSelectionModel().select(1);
1490         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1491         assertEquals(child1, treeTableView.getSelectionModel().getSelectedItem());
1492 
1493         TreeItem root = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1494         TreeItem child1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1495         TreeItem child2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1496         TreeItem child3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1497         root.setExpanded(true);
1498         root.getChildren().setAll(child1, child2, child3);
1499         treeTableView.setRoot(root);
1500         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1501         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1502         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1503         assertEquals(root, treeTableView.getFocusModel().getFocusedItem());
1504     }
1505 
1506     @Test public void test_rt27181() {
1507         myCompanyRootNode.setExpanded(true);
1508         treeTableView.setRoot(myCompanyRootNode);
1509 
1510         // start test
1511         salesDepartment.setExpanded(true);
1512         treeTableView.getSelectionModel().select(salesDepartment);
1513 
1514         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1515         itSupport.setExpanded(true);
1516         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1517     }
1518 
1519     @Test public void test_rt27185() {
1520         myCompanyRootNode.setExpanded(true);
1521         treeTableView.setRoot(myCompanyRootNode);
1522 
1523         // start test
1524         itSupport.setExpanded(true);
1525         treeTableView.getSelectionModel().select(mikeGraham);
1526 
1527         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1528         salesDepartment.setExpanded(true);
1529         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1530     }
1531 
1532     @Ignore(&quot;Bug hasn&#39;t been fixed yet&quot;)
1533     @Test public void test_rt28114() {
1534         myCompanyRootNode.setExpanded(true);
1535         treeTableView.setRoot(myCompanyRootNode);
1536 
1537         // start test
1538         itSupport.setExpanded(true);
1539         treeTableView.getSelectionModel().select(itSupport);
1540         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1541         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1542         assertTrue(! itSupport.isLeaf());
1543         assertTrue(itSupport.isExpanded());
1544 
1545         itSupport.getChildren().remove(mikeGraham);
1546         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1547         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1548         assertTrue(itSupport.isLeaf());
1549         assertTrue(!itSupport.isExpanded());
1550     }
1551 
1552     @Test public void test_rt27820_1() {
1553         TreeItem root = new TreeItem(&quot;root&quot;);
1554         root.setExpanded(true);
1555         TreeItem child = new TreeItem(&quot;child&quot;);
1556         root.getChildren().add(child);
1557         treeTableView.setRoot(root);
1558 
1559         treeTableView.getSelectionModel().select(0);
1560         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1561         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1562 
1563         treeTableView.setRoot(null);
1564         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1565         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1566     }
1567 
1568     @Test public void test_rt27820_2() {
1569         TreeItem root = new TreeItem(&quot;root&quot;);
1570         root.setExpanded(true);
1571         TreeItem child = new TreeItem(&quot;child&quot;);
1572         root.getChildren().add(child);
1573         treeTableView.setRoot(root);
1574 
1575         treeTableView.getSelectionModel().select(1);
1576         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1577         assertEquals(child, treeTableView.getSelectionModel().getSelectedItem());
1578 
1579         treeTableView.setRoot(null);
1580         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1581         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1582     }
1583 
1584     @Test public void test_rt28390() {
1585         // There should be no NPE when a TreeTableView is shown and the disclosure
1586         // node is null in a TreeCell
1587         TreeItem root = new TreeItem(&quot;root&quot;);
1588         treeTableView.setRoot(root);
1589 
1590         // install a custom cell factory that forces the disclosure node to be
1591         // null (because by default a null disclosure node will be replaced by
1592         // a non-null one).
1593         treeTableView.setRowFactory(new Callback() {
1594             @Override public Object call(Object p) {
1595                 TreeTableRow treeCell = new TreeTableRowShim() {
1596                     {
1597                         disclosureNodeProperty().addListener((ov, t, t1) -&gt; {
1598                             setDisclosureNode(null);
1599                         });
1600                     }
1601 
1602                     @Override public void updateItem(Object item, boolean empty) {
1603                         super.updateItem(item, empty);
1604                         setText(item == null ? &quot;&quot; : item.toString());
1605                     }
1606                 };
1607                 treeCell.setDisclosureNode(null);
1608                 return treeCell;
1609             }
1610         });
1611 
1612         try {
1613             Group group = new Group();
1614             group.getChildren().setAll(treeTableView);
1615             Scene scene = new Scene(group);
1616             Stage stage = new Stage();
1617             stage.setScene(scene);
1618             stage.show();
1619         } catch (NullPointerException e) {
1620             System.out.println(&quot;A null disclosure node is valid, so we shouldn&#39;t have an NPE here.&quot;);
1621             e.printStackTrace();
1622             assertTrue(false);
1623         }
1624     }
1625 
1626     @Ignore(&quot;This test begun failing when createDefaultCellImpl was removed from TreeTableViewSkin on 28/3/2013&quot;)
1627     @Test public void test_rt28534() {
1628         TreeItem root = new TreeItem(&quot;root&quot;);
1629         root.getChildren().setAll(
1630                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1631                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1632                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1633                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1634                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1635         root.setExpanded(true);
1636 
1637         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1638 
1639         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1640         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1641 
1642         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1643         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1644 
1645         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1646         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1647 
1648         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1649 
1650         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 6); // rows 0 - 6 should be filled
1651         VirtualFlowTestUtils.assertRowsEmpty(table, 6, -1); // rows 6+ should be empty
1652 
1653         // now we replace the data and expect the cells that have no data
1654         // to be empty
1655         root.getChildren().setAll(
1656                 new TreeItem(new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1657                 new TreeItem(new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1658 
1659         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 3); // rows 0 - 3 should be filled
1660         VirtualFlowTestUtils.assertRowsEmpty(table, 3, -1); // rows 3+ should be empty
1661     }
1662 
1663     @Test public void test_rt22463() {
1664         final TreeTableView&lt;RT_22463_Person&gt; table = new TreeTableView&lt;RT_22463_Person&gt;();
1665         table.setTableMenuButtonVisible(true);
1666         TreeTableColumn c1 = new TreeTableColumn(&quot;Id&quot;);
1667         TreeTableColumn c2 = new TreeTableColumn(&quot;Name&quot;);
1668         c1.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, Long&gt;(&quot;id&quot;));
1669         c2.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;name&quot;));
1670         table.getColumns().addAll(c1, c2);
1671 
1672         RT_22463_Person rootPerson = new RT_22463_Person();
1673         rootPerson.setName(&quot;Root&quot;);
1674         TreeItem&lt;RT_22463_Person&gt; root = new TreeItem&lt;RT_22463_Person&gt;(rootPerson);
1675         root.setExpanded(true);
1676 
1677         table.setRoot(root);
1678 
1679         // before the change things display fine
1680         RT_22463_Person p1 = new RT_22463_Person();
1681         p1.setId(1l);
1682         p1.setName(&quot;name1&quot;);
1683         RT_22463_Person p2 = new RT_22463_Person();
1684         p2.setId(2l);
1685         p2.setName(&quot;name2&quot;);
1686         root.getChildren().addAll(
1687                 new TreeItem&lt;RT_22463_Person&gt;(p1),
1688                 new TreeItem&lt;RT_22463_Person&gt;(p2));
1689         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;name1&quot;);
1690         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;name2&quot;);
1691 
1692         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
1693         // change - but the items list is cleared so the cells should update
1694         RT_22463_Person new_p1 = new RT_22463_Person();
1695         new_p1.setId(1l);
1696         new_p1.setName(&quot;updated name1&quot;);
1697         RT_22463_Person new_p2 = new RT_22463_Person();
1698         new_p2.setId(2l);
1699         new_p2.setName(&quot;updated name2&quot;);
1700         root.getChildren().clear();
1701         root.getChildren().setAll(
1702                 new TreeItem&lt;RT_22463_Person&gt;(new_p1),
1703                 new TreeItem&lt;RT_22463_Person&gt;(new_p2));
1704         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;updated name1&quot;);
1705         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;updated name2&quot;);
1706     }
1707 
1708     @Test public void test_rt28637() {
1709         TreeItem&lt;String&gt; s1, s2, s3, s4;
1710         ObservableList&lt;TreeItem&lt;String&gt;&gt; items = FXCollections.observableArrayList(
1711                 s1 = new TreeItem&lt;String&gt;(&quot;String1&quot;),
1712                 s2 = new TreeItem&lt;String&gt;(&quot;String2&quot;),
1713                 s3 = new TreeItem&lt;String&gt;(&quot;String3&quot;),
1714                 s4 = new TreeItem&lt;String&gt;(&quot;String4&quot;));
1715 
1716         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;();
1717 
1718         TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1719         root.setExpanded(true);
1720         treeTableView.setRoot(root);
1721         treeTableView.setShowRoot(false);
1722         root.getChildren().addAll(items);
1723 
1724         treeTableView.getSelectionModel().select(0);
1725         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItem());
1726         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItems().get(0));
1727         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1728 
1729         root.getChildren().remove(treeTableView.getSelectionModel().getSelectedItem());
1730         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItem());
1731         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItems().get(0));
1732         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1733     }
1734 
1735     @Test public void test_rt24844() {
1736         // p1 == lowest first name
1737         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1738 
1739         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1740             p3 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1741             p2 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1742             p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1743             p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1744             p4 = new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1745 
1746         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1747 
1748         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1749         root.setExpanded(true);
1750         table.setRoot(root);
1751         table.setShowRoot(false);
1752         root.getChildren().setAll(persons);
1753 
1754         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1755         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1756 
1757         // set dummy comparator to lock items in place until new comparator is set
1758         firstNameCol.setComparator((t, t1) -&gt; 0);
1759 
1760         table.getColumns().addAll(firstNameCol);
1761         table.getSortOrder().add(firstNameCol);
1762 
1763         // ensure the existing order is as expected
1764         assertEquals(p3, root.getChildren().get(0));
1765         assertEquals(p2, root.getChildren().get(1));
1766         assertEquals(p1, root.getChildren().get(2));
1767         assertEquals(p0, root.getChildren().get(3));
1768         assertEquals(p4, root.getChildren().get(4));
1769 
1770         // set a new comparator
1771         firstNameCol.setComparator((t, t1) -&gt; t.toString().compareTo(t1.toString()));
1772 
1773         // ensure the new order is as expected
1774         assertEquals(p0, root.getChildren().get(0));
1775         assertEquals(p1, root.getChildren().get(1));
1776         assertEquals(p2, root.getChildren().get(2));
1777         assertEquals(p3, root.getChildren().get(3));
1778         assertEquals(p4, root.getChildren().get(4));
1779     }
1780 
1781     @Test public void test_rt29331() {
1782         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;();
1783 
1784         // p1 == lowest first name
1785         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1786 
1787         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1788         firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1789 
1790         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1791         lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1792 
1793         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1794         emailCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1795 
1796         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1797         parentColumn.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1798 
1799         table.getColumns().addAll(parentColumn);
1800 
1801         // table is setup, now hide the &#39;last name&#39; column
1802         emailCol.setVisible(false);
1803         assertFalse(emailCol.isVisible());
1804 
1805         // reorder columns inside the parent column
1806         parentColumn.getColumns().setAll(emailCol, firstNameCol, lastNameCol);
1807 
1808         // the email column should not become visible after this, but it does
1809         assertFalse(emailCol.isVisible());
1810     }
1811 
1812     private int rt29330_count = 0;
1813     @Test public void test_rt29330_1() {
1814         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1815                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1816                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1817                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1818                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1819                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1820 
1821         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1822 
1823         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1824         root.setExpanded(true);
1825         table.setRoot(root);
1826         table.setShowRoot(false);
1827         root.getChildren().setAll(persons);
1828 
1829         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1830         table.getColumns().addAll(parentColumn);
1831 
1832         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1833         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1834 
1835         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1836         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1837 
1838         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1839 
1840         table.setOnSort(event -&gt; {
1841             rt29330_count++;
1842         });
1843 
1844         // test preconditions
1845         assertEquals(ASCENDING, lastNameCol.getSortType());
1846         assertEquals(0, rt29330_count);
1847 
1848         table.getSortOrder().add(lastNameCol);
1849         assertEquals(1, rt29330_count);
1850 
1851         lastNameCol.setSortType(DESCENDING);
1852         assertEquals(2, rt29330_count);
1853 
1854         lastNameCol.setSortType(null);
1855         assertEquals(3, rt29330_count);
1856 
1857         lastNameCol.setSortType(ASCENDING);
1858         assertEquals(4, rt29330_count);
1859     }
1860 
1861     @Test public void test_rt29330_2() {
1862         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1863                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1864                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1865                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1866                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1867                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1868 
1869         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1870 
1871         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1872         root.setExpanded(true);
1873         table.setRoot(root);
1874         table.setShowRoot(false);
1875         root.getChildren().setAll(persons);
1876 
1877         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1878         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1879 
1880         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1881         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1882 
1883         // this test differs from the previous one by installing the parent column
1884         // into the tableview after it has the children added into it
1885         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1886         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1887         table.getColumns().addAll(parentColumn);
1888 
1889         table.setOnSort(event -&gt; {
1890             rt29330_count++;
1891         });
1892 
1893         // test preconditions
1894         assertEquals(ASCENDING, lastNameCol.getSortType());
1895         assertEquals(0, rt29330_count);
1896 
1897         table.getSortOrder().add(lastNameCol);
1898         assertEquals(1, rt29330_count);
1899 
1900         lastNameCol.setSortType(DESCENDING);
1901         assertEquals(2, rt29330_count);
1902 
1903         lastNameCol.setSortType(null);
1904         assertEquals(3, rt29330_count);
1905 
1906         lastNameCol.setSortType(ASCENDING);
1907         assertEquals(4, rt29330_count);
1908     }
1909 
1910     @Test public void test_rt29313_selectedIndices() {
1911         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1912                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1913                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1914                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1915                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1916                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1917 
1918         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1919 
1920         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1921         root.setExpanded(true);
1922         table.setRoot(root);
1923         table.setShowRoot(false);
1924         root.getChildren().setAll(persons);
1925 
1926         TableSelectionModel sm = table.getSelectionModel();
1927 
1928         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1929         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1930 
1931         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1932         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1933 
1934         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1935         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1936 
1937         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1938         sm.setCellSelectionEnabled(true);
1939         sm.setSelectionMode(SelectionMode.MULTIPLE);
1940 
1941         assertTrue(sm.getSelectedIndices().isEmpty());
1942 
1943         // only (0,0) should be selected, so selected indices should be [0]
1944         sm.select(0, firstNameCol);
1945         assertEquals(1, sm.getSelectedIndices().size());
1946 
1947         // now (0,0) and (1,0) should be selected, so selected indices should be [0, 1]
1948         sm.select(1, firstNameCol);
1949         assertEquals(2, sm.getSelectedIndices().size());
1950 
1951         // now (0,0), (1,0) and (1,1) should be selected, but selected indices
1952         // should remain as [0, 1], as we don&#39;t want selected indices to become
1953         // [0,1,1] (which is what RT-29313 is about)
1954         sm.select(1, lastNameCol);
1955         assertEquals(2, sm.getSelectedIndices().size());
1956         assertEquals(0, sm.getSelectedIndices().get(0));
1957         assertEquals(1, sm.getSelectedIndices().get(1));
1958     }
1959 
1960     @Test public void test_rt29313_selectedItems() {
1961         TreeItem&lt;Person&gt; p0, p1;
1962         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1963                 p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1964                 p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1965                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1966                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1967                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1968 
1969         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1970 
1971         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1972         root.setExpanded(true);
1973         table.setRoot(root);
1974         table.setShowRoot(false);
1975         root.getChildren().setAll(persons);
1976 
1977         TableSelectionModel sm = table.getSelectionModel();
1978 
1979         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1980         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1981 
1982         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1983         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1984 
1985         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1986         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1987 
1988         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1989         sm.setCellSelectionEnabled(true);
1990         sm.setSelectionMode(SelectionMode.MULTIPLE);
1991 
1992         assertTrue(sm.getSelectedItems().isEmpty());
1993 
1994         // only (0,0) should be selected, so selected items should be [p0]
1995         sm.select(0, firstNameCol);
1996         assertEquals(1, sm.getSelectedItems().size());
1997 
1998         // now (0,0) and (1,0) should be selected, so selected items should be [p0, p1]
1999         sm.select(1, firstNameCol);
2000         assertEquals(2, sm.getSelectedItems().size());
2001 
2002         // now (0,0), (1,0) and (1,1) should be selected, but selected items
2003         // should remain as [p0, p1], as we don&#39;t want selected items to become
2004         // [p0,p1,p1] (which is what RT-29313 is about)
2005         sm.select(1, lastNameCol);
2006         assertEquals(2, sm.getSelectedItems().size());
2007         assertEquals(p0, sm.getSelectedItems().get(0));
2008         assertEquals(p1, sm.getSelectedItems().get(1));
2009     }
2010 
2011     @Test public void test_rt29566() {
2012         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2013                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2014                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2015                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2016                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2017                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
2018 
2019         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2020 
2021         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2022         root.setExpanded(true);
2023         table.setRoot(root);
2024         table.setShowRoot(false);
2025         root.getChildren().setAll(persons);
2026 
2027         TableSelectionModel sm = table.getSelectionModel();
2028 
2029         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2030         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2031 
2032         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
2033         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2034 
2035         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
2036         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2037 
2038         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
2039 
2040         // test the state before we hide and re-add a column
2041         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
2042         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
2043         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
2044         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
2045         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
2046 
2047         // hide the last name column, and test cells again
2048         table.getColumns().remove(lastNameCol);
2049         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;jacob.smith@example.com&quot;);
2050         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;isabella.johnson@example.com&quot;);
2051         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;ethan.williams@example.com&quot;);
2052         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;emma.jones@example.com&quot;);
2053         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;michael.brown@example.com&quot;);
2054 
2055         // re-add the last name column - we should go back to the original state.
2056         // However, what appears to be happening is that, for some reason, some
2057         // of the cells from the removed column do not reappear - meaning in this case
2058         // some of the last name values will not be where we expect them to be.
2059         // This is clearly not ideal!
2060         table.getColumns().add(1, lastNameCol);
2061         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
2062         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
2063         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
2064         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
2065         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
2066     }
2067 
2068     @Test public void test_rt29390() {
2069         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2070                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2071                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2072                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2073                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2074                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2075                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2076                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2077                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2078                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2079                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2080                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2081                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
2082                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
2083                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
2084                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
2085                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)
2086         ));
2087 
2088         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2089         table.setMaxHeight(50);
2090         table.setPrefHeight(50);
2091 
2092         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2093         root.setExpanded(true);
2094         table.setRoot(root);
2095         table.setShowRoot(false);
2096         root.getChildren().setAll(persons);
2097 
2098         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2099         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2100 
2101         table.getColumns().add(firstNameCol);
2102 
2103         Toolkit.getToolkit().firePulse();
2104 
2105         // we want the vertical scrollbar
2106         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(table);
2107 
2108         assertNotNull(scrollBar);
2109         assertTrue(scrollBar.isVisible());
2110         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
2111         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
2112 
2113         // this next test is likely to be brittle, but we&#39;ll see...If it is the
2114         // cause of failure then it can be commented out
2115         assertEquals(0.0625, scrollBar.getVisibleAmount(), 0.0);
2116     }
2117 
2118     @Test public void test_rt29676_withText() {
2119         // set up test
2120         TreeTableView&lt;Data&gt; treeTableView = new TreeTableView&lt;Data&gt;();
2121         treeTableView.setMaxWidth(100);
2122 
2123         TreeItem&lt;Data&gt; root = new TreeItem&lt;Data&gt;(new Data(&quot;Root&quot;));
2124         treeTableView.setRoot(root);
2125         addLevel(root, 0, 30);
2126 
2127         treeTableView.getRoot().setExpanded(true);
2128         TreeTableColumn&lt;Data, String&gt; column = new TreeTableColumn&lt;Data, String&gt;(&quot;Items&#39; name&quot;);
2129         column.setCellValueFactory(p -&gt; new ReadOnlyStringWrapper(p.getValue().getValue().getData()));
2130         treeTableView.getColumns().add(column);
2131 
2132         // show treeTableView
2133         StageLoader sl = new StageLoader(treeTableView);
2134 
2135         // expand all collapsed branches
2136         root.setExpanded(true);
2137         for (int i = 0; i &lt; root.getChildren().size(); i++) {
2138             TreeItem&lt;Data&gt; child = root.getChildren().get(i);
2139             child.setExpanded(true);
2140         }
2141 
2142         // get all cells and ensure their content is as expected
2143         int cellCount = VirtualFlowTestUtils.getCellCount(treeTableView);
2144         for (int i = 0; i &lt; cellCount; i++) {
2145             // get the TreeTableRow
2146             final TreeTableRow rowCell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, i);
2147             final TreeItem treeItem = rowCell.getTreeItem();
2148             if (treeItem == null) continue;
2149 
2150             final boolean isBranch = ! treeItem.isLeaf();
2151 
2152             // then check its children
2153             List&lt;Node&gt; children = rowCell.getChildrenUnmodifiable();
2154             for (int j = 0; j &lt; children.size(); j++) {
2155                 final Node child = children.get(j);
2156 
2157                 assertTrue(child.isVisible());
2158                 assertNotNull(child.getParent());
2159                 assertNotNull(child.getScene());
2160 
2161                 if (child.getStyleClass().contains(&quot;tree-disclosure-node&quot;)) {
2162                     // no-op
2163                 }
2164 
2165                 if (child.getStyleClass().contains(&quot;tree-table-cell&quot;)) {
2166                     TreeTableCell cell = (TreeTableCell) child;
2167                     assertNotNull(cell.getText());
2168                     assertFalse(cell.getText().isEmpty());
2169                 }
2170             }
2171         }
2172 
2173         sl.dispose();
2174     }
2175     private void addLevel(TreeItem&lt;Data&gt; item, int level, int length) {
2176         for (int i = 0; i &lt; 3; i++) {
2177             StringBuilder builder = new StringBuilder();
2178             builder.append(&quot;Level &quot; + level + &quot; Item &quot; + item);
2179             if (length &gt; 0) {
2180                 builder.append(&quot; l&quot;);
2181                 for (int j = 0; j &lt; length; j++) {
2182                     builder.append(&quot;o&quot;);
2183                 }
2184                 builder.append(&quot;ng&quot;);
2185             }
2186             String itemString = builder.toString();
2187             TreeItem&lt;Data&gt; child = new TreeItem&lt;Data&gt;(new Data(itemString));
2188             if (level &lt; 3 - 1) {
2189                 addLevel(child, level + 1, length);
2190             }
2191             item.getChildren().add(child);
2192         }
2193     }
2194 
2195     @Test public void test_rt27180_collapseBranch_childSelected_singleSelection() {
2196         sm.setCellSelectionEnabled(false);
2197         sm.setSelectionMode(SelectionMode.SINGLE);
2198 
2199         treeTableView.setRoot(myCompanyRootNode);
2200         myCompanyRootNode.setExpanded(true);
2201         salesDepartment.setExpanded(true);
2202         itSupport.setExpanded(true);
2203         sm.select(2);                   // ethanWilliams
2204         assertFalse(sm.isSelected(1));  // salesDepartment
2205         assertTrue(sm.isSelected(2));   // ethanWilliams
2206         assertTrue(treeTableView.getFocusModel().isFocused(2));
2207         assertEquals(1, sm.getSelectedCells().size());
2208 
2209         // now collapse the salesDepartment, selection should
2210         // not jump down to the itSupport people
2211         salesDepartment.setExpanded(false);
2212         assertTrue(sm.getSelectedIndices().toString(), sm.isSelected(1));   // salesDepartment
2213         assertTrue(treeTableView.getFocusModel().isFocused(1));
2214         assertEquals(1, sm.getSelectedCells().size());
2215     }
2216 
2217     @Test public void test_rt27180_collapseBranch_laterSiblingSelected_singleSelection() {
2218         sm.setCellSelectionEnabled(false);
2219         sm.setSelectionMode(SelectionMode.SINGLE);
2220 
2221         treeTableView.setRoot(myCompanyRootNode);
2222         myCompanyRootNode.setExpanded(true);
2223         salesDepartment.setExpanded(true);
2224         itSupport.setExpanded(true);
2225         sm.select(8);                   // itSupport
2226         assertFalse(sm.isSelected(1));  // salesDepartment
2227         assertTrue(sm.isSelected(8));   // itSupport
2228         assertTrue(treeTableView.getFocusModel().isFocused(8));
2229         assertEquals(1, sm.getSelectedIndices().size());
2230 
2231         salesDepartment.setExpanded(false);
2232         assertTrue(debug(), sm.isSelected(2));   // itSupport
2233         assertTrue(treeTableView.getFocusModel().isFocused(2));
2234         assertEquals(1, sm.getSelectedIndices().size());
2235     }
2236 
2237     @Test public void test_rt27180_collapseBranch_laterSiblingAndChildrenSelected() {
2238         sm.setSelectionMode(SelectionMode.MULTIPLE);
2239         sm.setCellSelectionEnabled(false);
2240 
2241         treeTableView.setRoot(myCompanyRootNode);
2242         myCompanyRootNode.setExpanded(true);
2243         salesDepartment.setExpanded(true);
2244         itSupport.setExpanded(true);
2245         sm.clearSelection();
2246         sm.selectIndices(8, 9, 10);     // itSupport, and two people
2247         assertFalse(sm.isSelected(1));  // salesDepartment
2248         assertTrue(sm.isSelected(8));   // itSupport
2249         assertTrue(sm.isSelected(9));   // mikeGraham
2250         assertTrue(sm.isSelected(10));  // judyMayer
2251         assertTrue(treeTableView.getFocusModel().isFocused(10));
2252         assertEquals(debug(), 3, sm.getSelectedIndices().size());
2253 
2254         salesDepartment.setExpanded(false);
2255         assertTrue(debug(), sm.isSelected(2));   // itSupport
2256         assertTrue(sm.isSelected(3));   // mikeGraham
2257         assertTrue(sm.isSelected(4));   // judyMayer
2258         assertTrue(treeTableView.getFocusModel().isFocused(4));
2259         assertEquals(3, sm.getSelectedIndices().size());
2260     }
2261 
2262     @Test public void test_rt27180_expandBranch_laterSiblingSelected_singleSelection() {
2263         sm.setCellSelectionEnabled(false);
2264         sm.setSelectionMode(SelectionMode.SINGLE);
2265 
2266         treeTableView.setRoot(myCompanyRootNode);
2267         myCompanyRootNode.setExpanded(true);
2268         salesDepartment.setExpanded(false);
2269         itSupport.setExpanded(true);
2270         sm.select(2);                   // itSupport
2271         assertFalse(sm.isSelected(1));  // salesDepartment
2272         assertTrue(sm.isSelected(2));   // itSupport
2273         assertTrue(treeTableView.getFocusModel().isFocused(2));
2274         assertEquals(1, sm.getSelectedIndices().size());
2275 
2276         salesDepartment.setExpanded(true);
2277         assertTrue(debug(), sm.isSelected(8));   // itSupport
2278         assertTrue(treeTableView.getFocusModel().isFocused(8));
2279         assertEquals(1, sm.getSelectedIndices().size());
2280     }
2281 
2282     @Test public void test_rt27180_expandBranch_laterSiblingAndChildrenSelected() {
2283         sm.setSelectionMode(SelectionMode.MULTIPLE);
2284         sm.setCellSelectionEnabled(false);
2285 
2286         treeTableView.setRoot(myCompanyRootNode);
2287         myCompanyRootNode.setExpanded(true);
2288         salesDepartment.setExpanded(false);
2289         itSupport.setExpanded(true);
2290         sm.clearSelection();
2291         sm.selectIndices(2,3,4);     // itSupport, and two people
2292         assertFalse(sm.isSelected(1));  // salesDepartment
2293         assertTrue(sm.isSelected(2));   // itSupport
2294         assertTrue(sm.isSelected(3));   // mikeGraham
2295         assertTrue(sm.isSelected(4));  // judyMayer
2296         assertTrue(treeTableView.getFocusModel().isFocused(4));
2297         assertEquals(3, sm.getSelectedIndices().size());
2298 
2299         salesDepartment.setExpanded(true);
2300         assertTrue(debug(), sm.isSelected(8));   // itSupport
2301         assertTrue(sm.isSelected(9));   // mikeGraham
2302         assertTrue(sm.isSelected(10));   // judyMayer
2303         assertTrue(treeTableView.getFocusModel().isFocused(10));
2304         assertEquals(3, sm.getSelectedIndices().size());
2305     }
2306 
2307     @Test public void test_rt30400() {
2308         // create a treetableview that&#39;ll render cells using the check box cell factory
2309         TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
2310         final TreeTableView&lt;String&gt; tableView = new TreeTableView&lt;String&gt;(rootItem);
2311         tableView.setMinHeight(100);
2312         tableView.setPrefHeight(100);
2313 
2314         TreeTableColumn&lt;String, String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2315         firstNameCol.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
2316         firstNameCol.setCellFactory(CheckBoxTreeTableCell.forTreeTableColumn(param -&gt; new ReadOnlyBooleanWrapper(true)));
2317         tableView.getColumns().add(firstNameCol);
2318 
2319         // because only the first row has data, all other rows should be
2320         // empty (and not contain check boxes - we just check the first four here)
2321         VirtualFlowTestUtils.assertRowsNotEmpty(tableView, 0, 1);
2322         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(tableView, 0));
2323         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 1));
2324         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 2));
2325         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 3));
2326     }
2327 
2328     @Ignore(&quot;This bug is not yet fixed&quot;)
2329     @Test public void test_rt31165() {
2330         installChildren();
2331         treeTableView.setEditable(true);
2332 
2333         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2334         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2335         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2336         firstNameCol.setEditable(true);
2337 
2338         treeTableView.getColumns().add(firstNameCol);
2339 
2340         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 1, 0);
2341         assertEquals(&quot;TEST&quot;, cell.getText());
2342         assertFalse(cell.isEditing());
2343 
2344         treeTableView.edit(1, firstNameCol);
2345 
2346         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2347         assertTrue(cell.isEditing());
2348 
2349         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2350         Toolkit.getToolkit().firePulse();
2351 
2352         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2353         assertTrue(cell.isEditing());
2354     }
2355 
2356     @Test public void test_rt31404() {
2357         installChildren();
2358 
2359         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2360         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2361 
2362         treeTableView.getColumns().add(firstNameCol);
2363 
2364         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2365         assertEquals(&quot;Root&quot;, cell.getText());
2366 
2367         treeTableView.setShowRoot(false);
2368         assertEquals(&quot;Child 1&quot;, cell.getText());
2369     }
2370 
2371     @Test public void test_rt31471() {
2372         installChildren();
2373 
2374         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2375         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2376 
2377         treeTableView.getColumns().add(firstNameCol);
2378 
2379         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0);
2380         assertEquals(&quot;Root&quot;, cell.getItem());
2381 
2382         treeTableView.setFixedCellSize(50);
2383 
2384         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2385         Toolkit.getToolkit().firePulse();
2386 
2387         assertEquals(&quot;Root&quot;, cell.getItem());
2388         assertEquals(50, cell.getHeight(), 0.00);
2389     }
2390 
2391     @Test public void test_rt30466() {
2392         final Node graphic1 = new Circle(6.75, Color.RED);
2393         final Node graphic2 = new Circle(6.75, Color.GREEN);
2394 
2395         installChildren();
2396 
2397         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2398         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2399 
2400         treeTableView.getColumns().add(firstNameCol);
2401 
2402         TreeTableRow cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2403         assertEquals(&quot;Root&quot;, cell.getItem());
2404 
2405         // set the first graphic - which we expect to see as a child of the cell
2406         root.setGraphic(graphic1);
2407         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2408         boolean matchGraphic1 = false;
2409         boolean matchGraphic2 = false;
2410         for (Node n : cell.getChildrenUnmodifiable()) {
2411             if (n == graphic1) {
2412                 matchGraphic1 = true;
2413             }
2414             if (n == graphic2) {
2415                 matchGraphic2 = true;
2416             }
2417         }
2418         assertTrue(matchGraphic1);
2419         assertFalse(matchGraphic2);
2420 
2421         // set the second graphic - which we also expect to see - but of course graphic1 should not be a child any longer
2422         root.setGraphic(graphic2);
2423         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2424         matchGraphic1 = false;
2425         matchGraphic2 = false;
2426         for (Node n : cell.getChildrenUnmodifiable()) {
2427             if (n == graphic1) {
2428                 matchGraphic1 = true;
2429             }
2430             if (n == graphic2) {
2431                 matchGraphic2 = true;
2432             }
2433         }
2434         assertFalse(matchGraphic1);
2435         assertTrue(matchGraphic2);
2436     }
2437 
2438     private int rt_31200_count = 0;
2439     @Test public void test_rt_31200_tableCell() {
2440         rt_31200_count = 0;
2441 
2442         installChildren();
2443         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2444         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2445         treeTableView.getColumns().add(firstNameCol);
2446 
2447         firstNameCol.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2448             @Override
2449             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2450                 return new TreeTableCellShim&lt;String, String&gt;() {
2451                     ImageView view = new ImageView();
2452 
2453                     {
2454                         setGraphic(view);
2455                     }
2456 
2457                     ;
2458 
2459                     @Override
2460                     public void updateItem(String item, boolean empty) {
2461                         if (getItem() == null ? item == null : getItem().equals(item)) {
2462                             rt_31200_count++;
2463                         }
2464                         super.updateItem(item, empty);
2465                         if (item == null || empty) {
2466                             view.setImage(null);
2467                             setText(null);
2468                         } else {
2469                             setText(item);
2470                         }
2471                     }
2472                 };
2473             }
2474         });
2475 
2476         StageLoader sl = new StageLoader(treeTableView);
2477 
2478         assertEquals(12, rt_31200_count);
2479 
2480         // resize the stage
2481         sl.getStage().setHeight(250);
2482         Toolkit.getToolkit().firePulse();
2483         sl.getStage().setHeight(50);
2484         Toolkit.getToolkit().firePulse();
2485         assertEquals(12, rt_31200_count);
2486 
2487         sl.dispose();
2488     }
2489 
2490     @Test public void test_rt_31200_tableRow() {
2491         rt_31200_count = 0;
2492 
2493         installChildren();
2494         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2495         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2496         treeTableView.getColumns().add(firstNameCol);
2497 
2498         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2499             @Override
2500             public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2501                 return new TreeTableRowShim&lt;String&gt;() {
2502                     ImageView view = new ImageView();
2503 
2504                     {
2505                         setGraphic(view);
2506                     }
2507 
2508                     ;
2509 
2510                     @Override
2511                     public void updateItem(String item, boolean empty) {
2512                         if (getItem() == null ? item == null : getItem().equals(item)) {
2513                             rt_31200_count++;
2514                         }
2515                         super.updateItem(item, empty);
2516                         if (item == null || empty) {
2517                             view.setImage(null);
2518                             setText(null);
2519                         } else {
2520                             setText(item.toString());
2521                         }
2522                     }
2523                 };
2524             }
2525         });
2526 
2527         StageLoader sl = new StageLoader(treeTableView);
2528 
2529         assertEquals(21, rt_31200_count);
2530 
2531         // resize the stage
2532         sl.getStage().setHeight(250);
2533         Toolkit.getToolkit().firePulse();
2534         sl.getStage().setHeight(50);
2535         Toolkit.getToolkit().firePulse();
2536         assertEquals(21, rt_31200_count);
2537 
2538         sl.dispose();
2539     }
2540 
2541     @Test public void test_rt_31727() {
2542         installChildren();
2543         treeTableView.setEditable(true);
2544 
2545         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2546         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2547         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2548         firstNameCol.setEditable(true);
2549 
2550         treeTableView.getColumns().add(firstNameCol);
2551 
2552         treeTableView.setEditable(true);
2553         firstNameCol.setEditable(true);
2554 
2555         // do a normal edit
2556         treeTableView.edit(0, firstNameCol);
2557         TreeTablePosition editingCell = treeTableView.getEditingCell();
2558         assertNotNull(editingCell);
2559         assertEquals(0, editingCell.getRow());
2560         assertEquals(0, editingCell.getColumn());
2561         assertEquals(firstNameCol, editingCell.getTableColumn());
2562         assertEquals(treeTableView, editingCell.getTreeTableView());
2563 
2564         // cancel editing
2565         treeTableView.edit(-1, null);
2566         editingCell = treeTableView.getEditingCell();
2567         assertNull(editingCell);
2568     }
2569 
2570     @Test public void test_rt_21517() {
2571         installChildren();
2572 
2573 //        final TableSelectionModel sm = t.getSelectionModel();
2574         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2575         col.setSortType(ASCENDING);
2576         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2577         treeTableView.getColumns().add(col);
2578 
2579         // test pre-conditions
2580         assertEquals(0, sm.getSelectedCells().size());
2581         assertEquals(0, sm.getSelectedItems().size());
2582         assertEquals(0, sm.getSelectedIndices().size());
2583 
2584         // select the 4th row (that is, the third child of the root)
2585         sm.select(3);
2586         assertTrue(sm.isSelected(3));
2587         assertEquals(3, sm.getSelectedIndex());
2588         assertEquals(1, sm.getSelectedIndices().size());
2589         assertTrue(sm.getSelectedIndices().contains(3));
2590         assertEquals(child3, sm.getSelectedItem());
2591         assertEquals(1, sm.getSelectedItems().size());
2592         assertTrue(sm.getSelectedItems().contains(child3));
2593 
2594         // we also want to test visually
2595         TreeTableRow rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2596         assertFalse(rootRow.isSelected());
2597         TreeTableRow child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2598         assertTrue(child3Row.isSelected());
2599 
2600         // sort tableview by firstname column in ascending (default) order
2601         // (so aaa continues to come first)
2602         treeTableView.getSortOrder().add(col);
2603 
2604         // nothing should have changed
2605         assertTrue(sm.isSelected(3));
2606         assertEquals(3, sm.getSelectedIndex());
2607         assertEquals(1, sm.getSelectedIndices().size());
2608         assertTrue(sm.getSelectedIndices().contains(3));
2609         assertEquals(child3, sm.getSelectedItem());
2610         assertEquals(1, sm.getSelectedItems().size());
2611         assertTrue(sm.getSelectedItems().contains(child3));
2612         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2613         assertFalse(rootRow.isSelected());
2614         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2615         assertTrue(child3Row.isSelected());
2616 
2617         // continue to sort tableview by firstname column, but now in descending
2618         // order, (so ccc to come first)
2619         col.setSortType(TreeTableColumn.SortType.DESCENDING);
2620 
2621         // now test to ensure that CCC is still the only selected item, but now
2622         // located in index 1 (as the first child of the root)
2623         assertTrue(debug(), sm.isSelected(1));
2624         assertEquals(1, sm.getSelectedIndex());
2625         assertEquals(1, sm.getSelectedIndices().size());
2626         assertTrue(sm.getSelectedIndices().contains(1));
2627         assertEquals(child3, sm.getSelectedItem());
2628         assertEquals(1, sm.getSelectedItems().size());
2629         assertTrue(sm.getSelectedItems().contains(child3));
2630 
2631         // we also want to test visually
2632         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2633         assertFalse(rootRow.isSelected());
2634         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 1);
2635         assertTrue(child3Row.isSelected());
2636     }
2637 
2638     @Test public void test_rt_30484_treeTableCell() {
2639         installChildren();
2640 
2641         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2642         col.setSortType(ASCENDING);
2643         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2644         treeTableView.getColumns().add(col);
2645 
2646         col.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2647             @Override
2648             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2649                 return new TreeTableCellShim&lt;String, String&gt;() {
2650                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2651                     { setGraphic(graphic); };
2652 
2653                     @Override public void updateItem(String item, boolean empty) {
2654                         super.updateItem(item, empty);
2655                         if (item == null || empty) {
2656                             graphic.setVisible(false);
2657                             setText(null);
2658                         } else {
2659                             graphic.setVisible(true);
2660                             setText(item);
2661                         }
2662                     }
2663                 };
2664             }
2665         });
2666 
2667         // First four rows have content, so the graphic should show.
2668         // All other rows have no content, so graphic should not show.
2669 
2670         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0, 0);
2671         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1, 0);
2672         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2, 0);
2673         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3, 0);
2674         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4, 0);
2675         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5, 0);
2676     }
2677 
2678     @Test public void test_rt_30484_treeTableRow() {
2679         installChildren();
2680 
2681         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2682         col.setSortType(ASCENDING);
2683         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2684         treeTableView.getColumns().add(col);
2685 
2686         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2687             @Override public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2688                 return new TreeTableRowShim&lt;String&gt;() {
2689                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2690                     { setGraphic(graphic); };
2691 
2692                     @Override public void updateItem(String item, boolean empty) {
2693                         super.updateItem(item, empty);
2694                         if (item == null || empty) {
2695                             graphic.setVisible(false);
2696                             setText(null);
2697                         } else {
2698                             graphic.setVisible(true);
2699                             setText(item.toString());
2700                         }
2701                     }
2702                 };
2703             }
2704         });
2705 
2706         // First two rows have content, so the graphic should show.
2707         // All other rows have no content, so graphic should not show.
2708 
2709         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0);
2710         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1);
2711         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2);
2712         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3);
2713         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4);
2714         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5);
2715     }
2716 
2717     private int rt_31015_count = 0;
2718     @Test public void test_rt_31015() {
2719         installChildren();
2720         root.getChildren().clear();
2721         treeTableView.setEditable(true);
2722 
2723         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2724         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2725         treeTableView.getColumns().add(col);
2726 
2727         //Set cell factory for cells that allow editing
2728         Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt; cellFactory = new Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2729             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; p) {
2730                 return new TreeTableCell&lt;String, String&gt;() {
2731                     @Override public void cancelEdit() {
2732                         super.cancelEdit();
2733                         rt_31015_count++;
2734                     }
2735                 };
2736             }
2737         };
2738         col.setCellFactory(cellFactory);
2739 
2740         StageLoader sl = new StageLoader(treeTableView);
2741 
2742         assertEquals(0, rt_31015_count);
2743 
2744         treeTableView.edit(0, col);
2745         assertEquals(0, rt_31015_count);
2746 
2747         treeTableView.edit(-1, null);
2748         assertEquals(1, rt_31015_count);
2749 
2750         sl.dispose();
2751     }
2752 
2753     @Test public void test_rt_30688() {
2754         installChildren();
2755         root.getChildren().clear();
2756         treeTableView.setColumnResizePolicy(TreeTableView.CONSTRAINED_RESIZE_POLICY);
2757 
2758         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2759         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2760         treeTableView.getColumns().add(col);
2761 
2762         StageLoader sl = new StageLoader(treeTableView);
2763 
2764         assertEquals(TreeTableViewShim.get_contentWidth(treeTableView),
2765                 TableColumnBaseShim.getWidth(col), 0.0);
2766 
2767         sl.dispose();
2768     }
2769 
2770     private int rt_29650_start_count = 0;
2771     private int rt_29650_commit_count = 0;
2772     private int rt_29650_cancel_count = 0;
2773     @Test public void test_rt_29650() {
2774         installChildren();
2775         treeTableView.setEditable(true);
2776 
2777         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2778         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2779         col.setCellFactory(factory);
2780         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2781         treeTableView.getColumns().add(col);
2782 
2783         col.setOnEditStart(t -&gt; {
2784             rt_29650_start_count++;
2785         });
2786         col.setOnEditCommit(t -&gt; {
2787             rt_29650_commit_count++;
2788         });
2789         col.setOnEditCancel(t -&gt; {
2790             rt_29650_cancel_count++;
2791         });
2792 
2793         StageLoader sl = new StageLoader(treeTableView);
2794 
2795         treeTableView.edit(0, col);
2796 
2797         Toolkit.getToolkit().firePulse();
2798 
2799         TreeTableCell rootCell = (TreeTableCell) VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2800         TextField textField = (TextField) rootCell.getGraphic();
2801         textField.setText(&quot;Testing!&quot;);
2802         KeyEventFirer keyboard = new KeyEventFirer(textField);
2803         keyboard.doKeyPress(KeyCode.ENTER);
2804 
2805         // TODO should the following assert be enabled?
2806 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
2807         assertEquals(1, rt_29650_start_count);
2808         assertEquals(1, rt_29650_commit_count);
2809         assertEquals(0, rt_29650_cancel_count);
2810 
2811         sl.dispose();
2812     }
2813 
2814     private int rt_29849_start_count = 0;
2815     @Test public void test_rt_29849() {
2816         installChildren();
2817         treeTableView.setEditable(true);
2818 
2819         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2820         col.setEditable(true);
2821         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2822         treeTableView.getColumns().add(col);
2823 
2824         col.setOnEditStart(t -&gt; {
2825             rt_29849_start_count++;
2826         });
2827 
2828         // load the table so the default cells are created
2829         StageLoader sl = new StageLoader(treeTableView);
2830 
2831         // now replace the cell factory
2832         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2833         col.setCellFactory(factory);
2834 
2835         Toolkit.getToolkit().firePulse();
2836 
2837         // now start an edit and count the start edit events - it should be just 1
2838         treeTableView.edit(0, col);
2839         assertEquals(1, rt_29849_start_count);
2840 
2841         sl.dispose();
2842     }
2843 
2844     @Test public void test_rt_34327() {
2845         // by default the comparator is null.
2846         // NOTE: this method (prior to the fix as part of RT-34327) would have
2847         // returned Comparator&lt;String&gt;, but after the fix it correctly returns
2848         // a Comparator&lt;TreeItem&lt;String&gt;&gt;
2849         Comparator nonGenericComparator = treeTableView.getComparator();
2850         Comparator&lt;TreeItem&lt;String&gt;&gt; genericComparator = treeTableView.getComparator();
2851         assertNull(nonGenericComparator);
2852         assertNull(genericComparator);
2853 
2854         // add in a column and some data
2855         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2856         col.setEditable(true);
2857         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2858         treeTableView.getColumns().add(col);
2859 
2860         installChildren();
2861 
2862         // sort by that column
2863         treeTableView.getSortOrder().add(col);
2864 
2865         // get the new comparator, which should no longer be null
2866         nonGenericComparator = treeTableView.getComparator();
2867         genericComparator = treeTableView.getComparator();
2868         assertNotNull(nonGenericComparator);
2869         assertNotNull(genericComparator);
2870 
2871         // now, as noted above, previously we would use the Comparator to compare
2872         // two String instances, which would fail at runtime as the Comparator
2873         // was actually expecting to compare two TreeItem&lt;String&gt;, but the API
2874         // was failing us.
2875         try {
2876             nonGenericComparator.compare(&quot;abc&quot;, &quot;def&quot;);
2877             fail(&quot;This should not work!&quot;);
2878         } catch (ClassCastException e) {
2879             // if we get the exception, we&#39;re happy
2880         }
2881 
2882         try {
2883             Object string1 = &quot;abc&quot;;
2884             Object string2 = &quot;def&quot;;
2885             genericComparator.compare((TreeItem&lt;String&gt;)string1, (TreeItem&lt;String&gt;)string2);
2886             fail(&quot;This should not work!&quot;);
2887         } catch (ClassCastException e) {
2888             // if we get the exception, we&#39;re happy
2889         }
2890     }
2891 
2892     @Test public void test_rt26718() {
2893         treeTableView.setRoot(new TreeItem(&quot;Root&quot;));
2894         treeTableView.getRoot().setExpanded(true);
2895 
2896         for (int i = 0; i &lt; 4; i++) {
2897             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2898             treeTableView.getRoot().getChildren().add(parent);
2899 
2900             for (int j = 0; j &lt; 4; j++) {
2901                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2902                 parent.getChildren().add(child);
2903             }
2904         }
2905 
2906         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2907 
2908         final TreeItem item0 = treeTableView.getTreeItem(1);
2909         final TreeItem item1 = treeTableView.getTreeItem(2);
2910 
2911         assertEquals(&quot;item - 0&quot;, item0.getValue());
2912         assertEquals(&quot;item - 1&quot;, item1.getValue());
2913 
2914         item0.setExpanded(true);
2915         item1.setExpanded(true);
2916         Toolkit.getToolkit().firePulse();
2917 
2918         treeTableView.getSelectionModel().selectRange(0, 8);
2919         assertEquals(8, treeTableView.getSelectionModel().getSelectedIndices().size());
2920         assertEquals(7, treeTableView.getSelectionModel().getSelectedIndex());
2921         assertEquals(7, treeTableView.getFocusModel().getFocusedIndex());
2922 
2923         // collapse item0 - but because the selected and focused indices are
2924         // not children of item 0, they should remain where they are (but of
2925         // course be shifted up). The bug was that focus was moving up to item0,
2926         // which makes no sense
2927         item0.setExpanded(false);
2928         Toolkit.getToolkit().firePulse();
2929         assertEquals(3, treeTableView.getSelectionModel().getSelectedIndex());
2930         assertEquals(3, treeTableView.getFocusModel().getFocusedIndex());
2931     }
2932 
2933 //    @Ignore(&quot;Test started intermittently failing, most probably due to RT-36855 changeset&quot;)
2934     @Test public void test_rt_34493() {
2935         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2936             new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;))
2937         );
2938 
2939         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2940 
2941         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2942         root.setExpanded(true);
2943         table.setRoot(root);
2944         table.setShowRoot(false);
2945         root.getChildren().setAll(persons);
2946 
2947         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2948         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2949 
2950         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
2951         last.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2952 
2953         TreeTableColumn email = new TreeTableColumn(&quot;Email&quot;);
2954         email.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2955 
2956         table.getColumns().addAll(first, last, email);
2957 
2958         // load the table
2959         StageLoader sl = new StageLoader(table);
2960 
2961         // resize the last column
2962         TableColumnBaseHelper.setWidth(last, 400);
2963         assertEquals(400, last.getWidth(), 0.0);
2964 
2965         // hide the first column
2966         table.getColumns().remove(first);
2967         Toolkit.getToolkit().firePulse();
2968 
2969         // the last column should still be 400px, not the default width or any
2970         // other value (based on the width of the content in that column)
2971         assertEquals(400, last.getWidth(), 0.0);
2972 
2973         sl.dispose();
2974     }
2975 
2976     @Test public void test_rt26721_collapseParent_firstRootChild() {
2977         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2978         table.setRoot(new TreeItem(&quot;Root&quot;));
2979         table.getRoot().setExpanded(true);
2980 
2981         for (int i = 0; i &lt; 4; i++) {
2982             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2983             table.getRoot().getChildren().add(parent);
2984 
2985             for (int j = 0; j &lt; 4; j++) {
2986                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2987                 parent.getChildren().add(child);
2988             }
2989         }
2990 
2991         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2992 
2993         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2994         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2995         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2996 
2997         assertEquals(&quot;item - 0&quot;, item0.getValue());
2998         assertEquals(&quot;item - 1&quot;, item1.getValue());
2999 
3000         item0.setExpanded(true);
3001         item1.setExpanded(true);
3002         Toolkit.getToolkit().firePulse();
3003 
3004         // select the first child of item0
3005         table.getSelectionModel().select(item0child0);
3006 
3007         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
3008         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
3009 
3010         // collapse item0 - we expect the selection / focus to move up to item0
3011         item0.setExpanded(false);
3012         Toolkit.getToolkit().firePulse();
3013         assertEquals(item0, table.getSelectionModel().getSelectedItem());
3014         assertEquals(item0, table.getFocusModel().getFocusedItem());
3015     }
3016 
3017     @Test public void test_rt26721_collapseParent_lastRootChild() {
3018         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3019         table.setRoot(new TreeItem(&quot;Root&quot;));
3020         table.getRoot().setExpanded(true);
3021 
3022         for (int i = 0; i &lt; 4; i++) {
3023             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
3024             table.getRoot().getChildren().add(parent);
3025 
3026             for (int j = 0; j &lt; 4; j++) {
3027                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
3028                 parent.getChildren().add(child);
3029             }
3030         }
3031 
3032         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
3033 
3034         final TreeItem&lt;String&gt; item3 = table.getTreeItem(4);
3035         final TreeItem&lt;String&gt; item3child0 = item3.getChildren().get(0);
3036 
3037         assertEquals(&quot;item - 3&quot;, item3.getValue());
3038         assertEquals(&quot;item - 3 0&quot;, item3child0.getValue());
3039 
3040         item3.setExpanded(true);
3041         Toolkit.getToolkit().firePulse();
3042 
3043         // select the first child of item0
3044         table.getSelectionModel().select(item3child0);
3045 
3046         assertEquals(item3child0, table.getSelectionModel().getSelectedItem());
3047         assertEquals(item3child0, table.getFocusModel().getFocusedItem());
3048 
3049         // collapse item3 - we expect the selection / focus to move up to item3
3050         item3.setExpanded(false);
3051         Toolkit.getToolkit().firePulse();
3052         assertEquals(item3, table.getSelectionModel().getSelectedItem());
3053         assertEquals(item3, table.getFocusModel().getFocusedItem());
3054     }
3055 
3056     @Test public void test_rt26721_collapseGrandParent() {
3057         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3058         table.setRoot(new TreeItem(&quot;Root&quot;));
3059         table.getRoot().setExpanded(true);
3060 
3061         for (int i = 0; i &lt; 4; i++) {
3062             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
3063             table.getRoot().getChildren().add(parent);
3064 
3065             for (int j = 0; j &lt; 4; j++) {
3066                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
3067                 parent.getChildren().add(child);
3068             }
3069         }
3070 
3071         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
3072 
3073         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
3074         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
3075         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
3076 
3077         assertEquals(&quot;item - 0&quot;, item0.getValue());
3078         assertEquals(&quot;item - 1&quot;, item1.getValue());
3079 
3080         item0.setExpanded(true);
3081         item1.setExpanded(true);
3082         Toolkit.getToolkit().firePulse();
3083 
3084         // select the first child of item0
3085         table.getSelectionModel().select(item0child0);
3086 
3087         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
3088         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
3089 
3090         // collapse root - we expect the selection / focus to move up to root
3091         table.getRoot().setExpanded(false);
3092         Toolkit.getToolkit().firePulse();
3093         assertEquals(table.getRoot(), table.getSelectionModel().getSelectedItem());
3094         assertEquals(table.getRoot(), table.getFocusModel().getFocusedItem());
3095     }
3096 
3097     @Test public void test_rt_34685_directEditCall_cellSelectionMode() {
3098         test_rt_34685_commitCount = 0;
3099         test_rt_34685(false, true);
3100     }
3101 
3102     @Test public void test_rt_34685_directEditCall_rowSelectionMode() {
3103         test_rt_34685_commitCount = 0;
3104         test_rt_34685(false, false);
3105     }
3106 
3107     @Test public void test_rt_34685_mouseDoubleClick_cellSelectionMode() {
3108         test_rt_34685_commitCount = 0;
3109         test_rt_34685(true, true);
3110     }
3111 
3112     @Test public void test_rt_34685_mouseDoubleClick_rowSelectionMode() {
3113         test_rt_34685_commitCount = 0;
3114         test_rt_34685(true, false);
3115     }
3116 
3117     private int test_rt_34685_commitCount = 0;
3118     private void test_rt_34685(boolean useMouseToInitiateEdit, boolean cellSelectionModeEnabled) {
3119         assertEquals(0, test_rt_34685_commitCount);
3120 
3121         Person person1;
3122         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
3123             new TreeItem&lt;&gt;(person1 = new Person(&quot;John&quot;, &quot;Smith&quot;, &quot;john.smith@example.com&quot;))
3124         );
3125 
3126         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
3127         table.getSelectionModel().setCellSelectionEnabled(cellSelectionModeEnabled);
3128         table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
3129         table.setEditable(true);
3130 
3131         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
3132         root.setExpanded(true);
3133         table.setRoot(root);
3134         table.setShowRoot(false);
3135         root.getChildren().setAll(persons);
3136 
3137         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
3138         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
3139         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
3140 
3141         EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt; onEditCommit = first.getOnEditCommit();
3142         first.setOnEditCommit(new EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt;() {
3143             @Override public void handle(TreeTableColumn.CellEditEvent&lt;Person, String&gt; event) {
3144                 test_rt_34685_commitCount++;
3145                 onEditCommit.handle(event);
3146             }
3147         });
3148 
3149         table.getColumns().addAll(first);
3150 
3151         // get the cell at (0,0) - we&#39;re hiding the root row
3152         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;
3153         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, 0, 0);
3154         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;
3155         assertTrue(cell.getSkin() instanceof TreeTableCellSkin);
3156         assertNull(cell.getGraphic());
3157         assertEquals(&quot;John&quot;, cell.getText());
3158         assertEquals(&quot;John&quot;, person1.getFirstName());
3159 
3160         // set the table to be editing the first cell at 0,0
3161         if (useMouseToInitiateEdit) {
3162             MouseEventFirer mouse = new MouseEventFirer(cell);
3163             mouse.fireMousePressAndRelease(2, 10, 10);  // click 10 pixels in and 10 pixels down
3164             mouse.dispose();
3165         } else {
3166             table.edit(0,first);
3167         }
3168 
3169         Toolkit.getToolkit().firePulse();
3170         assertNotNull(cell.getGraphic());
3171         assertTrue(cell.getGraphic() instanceof TextField);
3172 
3173         TextField textField = (TextField) cell.getGraphic();
3174         assertEquals(&quot;John&quot;, textField.getText());
3175 
3176         textField.setText(&quot;Andrew&quot;);
3177         textField.requestFocus();
3178         Toolkit.getToolkit().firePulse();
3179 
3180         KeyEventFirer keyboard = new KeyEventFirer(textField);
3181         keyboard.doKeyPress(KeyCode.ENTER);
3182 
3183         VirtualFlowTestUtils.getVirtualFlow(table).requestLayout();
3184         Toolkit.getToolkit().firePulse();
3185 
3186         VirtualFlowTestUtils.assertTableCellTextEquals(table, 0, 0, &quot;Andrew&quot;);
3187         assertEquals(&quot;Andrew&quot;, cell.getText());
3188         assertEquals(&quot;Andrew&quot;, person1.getFirstName());
3189         assertEquals(1, test_rt_34685_commitCount);
3190     }
3191 
3192     @Test public void test_rt34694() {
3193         TreeItem treeNode = new TreeItem(&quot;Controls&quot;);
3194         treeNode.getChildren().addAll(
3195                 new TreeItem(&quot;Button&quot;),
3196                 new TreeItem(&quot;ButtonBar&quot;),
3197                 new TreeItem(&quot;LinkBar&quot;),
3198                 new TreeItem(&quot;LinkButton&quot;),
3199                 new TreeItem(&quot;PopUpButton&quot;),
3200                 new TreeItem(&quot;ToggleButtonBar&quot;)
3201         );
3202 
3203         final TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3204         table.setRoot(treeNode);
3205         treeNode.setExpanded(true);
3206 
3207         table.getSelectionModel().select(0);
3208         assertTrue(table.getSelectionModel().isSelected(0));
3209         assertTrue(table.getFocusModel().isFocused(0));
3210 
3211         treeNode.getChildren().clear();
3212         treeNode.getChildren().addAll(
3213                 new TreeItem(&quot;Button1&quot;),
3214                 new TreeItem(&quot;ButtonBar1&quot;),
3215                 new TreeItem(&quot;LinkBar1&quot;),
3216                 new TreeItem(&quot;LinkButton1&quot;),
3217                 new TreeItem(&quot;PopUpButton1&quot;),
3218                 new TreeItem(&quot;ToggleButtonBar1&quot;)
3219         );
3220         Toolkit.getToolkit().firePulse();
3221 
3222         assertTrue(table.getSelectionModel().isSelected(0));
3223         assertTrue(table.getFocusModel().isFocused(0));
3224     }
3225 
3226     private int test_rt_35213_eventCount = 0;
3227     @Test public void test_rt35213() {
3228         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
3229 
3230         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Boss&quot;);
3231         view.setRoot(root);
3232 
3233         TreeItem&lt;String&gt; group1 = new TreeItem&lt;&gt;(&quot;Group 1&quot;);
3234         TreeItem&lt;String&gt; group2 = new TreeItem&lt;&gt;(&quot;Group 2&quot;);
3235         TreeItem&lt;String&gt; group3 = new TreeItem&lt;&gt;(&quot;Group 3&quot;);
3236 
3237         root.getChildren().addAll(group1, group2, group3);
3238 
3239         TreeItem&lt;String&gt; employee1 = new TreeItem&lt;&gt;(&quot;Employee 1&quot;);
3240         TreeItem&lt;String&gt; employee2 = new TreeItem&lt;&gt;(&quot;Employee 2&quot;);
3241 
3242         group2.getChildren().addAll(employee1, employee2);
3243 
3244         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;Name&quot;);
3245         nameColumn.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
3246         view.getColumns().add(nameColumn);
3247 
3248         view.expandedItemCountProperty().addListener((observableValue, oldCount, newCount) -&gt; {
3249 
3250             // DEBUG OUTPUT
3251 //                System.out.println(&quot;new expanded item count: &quot; + newCount.intValue());
3252 //                for (int i = 0; i &lt; newCount.intValue(); i++) {
3253 //                    TreeItem&lt;String&gt; item = view.getTreeItem(i);
3254 //                    String text = item.getValue();
3255 //                    System.out.println(&quot;person found at index &quot; + i + &quot; is &quot; + text);
3256 //                }
3257 //                System.out.println(&quot;------------------------------------------&quot;);
3258 
3259             if (test_rt_35213_eventCount == 0) {
3260                 assertEquals(4, newCount);
3261                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3262                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3263                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3264                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3265             } else if (test_rt_35213_eventCount == 1) {
3266                 assertEquals(6, newCount);
3267                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3268                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3269                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3270                 assertEquals(&quot;Employee 1&quot;, view.getTreeItem(3).getValue());
3271                 assertEquals(&quot;Employee 2&quot;, view.getTreeItem(4).getValue());
3272                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(5).getValue());
3273             } else if (test_rt_35213_eventCount == 2) {
3274                 assertEquals(4, newCount);
3275                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3276                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3277                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3278                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3279             }
3280 
3281             test_rt_35213_eventCount++;
3282         });
3283 
3284         StageLoader sl = new StageLoader(view);
3285 
3286         root.setExpanded(true);
3287         Toolkit.getToolkit().firePulse();
3288 
3289         group2.setExpanded(true);
3290         Toolkit.getToolkit().firePulse();
3291 
3292         group2.setExpanded(false);
3293         Toolkit.getToolkit().firePulse();
3294 
3295         sl.dispose();
3296     }
3297 
3298     @Test public void test_rt23245_itemIsInTree() {
3299         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;String&gt;();
3300         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3301         for (int i = 0; i &lt; 10; i++) {
3302             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3303             item.setExpanded(true);
3304             items.add(item);
3305         }
3306 
3307         // link the items up so that the next item is the child of the current item
3308         for (int i = 0; i &lt; 9; i++) {
3309             items.get(i).getChildren().add(items.get(i + 1));
3310         }
3311 
3312         view.setRoot(items.get(0));
3313 
3314         for (int i = 0; i &lt; 10; i++) {
3315             // we expect the level of the tree item at the ith position to be
3316             // 0, as every iteration we are setting the ith item as the root.
3317             assertEquals(0, view.getTreeItemLevel(items.get(i)));
3318 
3319             // whilst we are testing, we should also ensure that the ith item
3320             // is indeed the root item, and that the ith item is indeed the item
3321             // at the 0th position
3322             assertEquals(items.get(i), view.getRoot());
3323             assertEquals(items.get(i), view.getTreeItem(0));
3324 
3325             // shuffle the next item into the root position (keeping its parent
3326             // chain intact - which is what exposes this issue in the first place).
3327             if (i &lt; 9) {
3328                 view.setRoot(items.get(i + 1));
3329             }
3330         }
3331     }
3332 
3333     @Test public void test_rt23245_itemIsNotInTree_noRootNode() {
3334         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3335         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3336         for (int i = 0; i &lt; 10; i++) {
3337             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3338             item.setExpanded(true);
3339             items.add(item);
3340         }
3341 
3342         // link the items up so that the next item is the child of the current item
3343         for (int i = 0; i &lt; 9; i++) {
3344             items.get(i).getChildren().add(items.get(i + 1));
3345         }
3346 
3347         for (int i = 0; i &lt; 10; i++) {
3348             // because we have no root (and we are not changing the root like
3349             // the previous test), we expect the tree item level of the item
3350             // in the ith position to be i.
3351             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3352 
3353             // all items requested from the TreeView should be null, as the
3354             // TreeView does not have a root item
3355             assertNull(view.getTreeItem(i));
3356         }
3357     }
3358 
3359     @Test public void test_rt23245_itemIsNotInTree_withUnrelatedRootNode() {
3360         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3361         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3362         for (int i = 0; i &lt; 10; i++) {
3363             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3364             item.setExpanded(true);
3365             items.add(item);
3366         }
3367 
3368         // link the items up so that the next item is the child of the current item
3369         for (int i = 0; i &lt; 9; i++) {
3370             items.get(i).getChildren().add(items.get(i + 1));
3371         }
3372 
3373         view.setRoot(new TreeItem(&quot;Unrelated root node&quot;));
3374 
3375         for (int i = 0; i &lt; 10; i++) {
3376             // because we have no root (and we are not changing the root like
3377             // the previous test), we expect the tree item level of the item
3378             // in the ith position to be i.
3379             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3380 
3381             // all items requested from the TreeView should be null except for
3382             // the root node
3383             assertNull(view.getTreeItem(i + 1));
3384         }
3385     }
3386 
3387     @Test public void test_rt35039_setRoot() {
3388         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3389         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3390 
3391         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3392         root.setExpanded(true);
3393         root.getChildren().setAll(aabbaa, bbc);
3394 
3395         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3396         treeView.setRoot(root);
3397 
3398         StageLoader sl = new StageLoader(treeView);
3399 
3400         // Selection starts in row -1
3401         assertNull(treeView.getSelectionModel().getSelectedItem());
3402 
3403         // select &quot;bbc&quot; and ensure everything is set to that
3404         treeView.getSelectionModel().select(2);
3405         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3406 
3407         // change the items list - but retain the same content. We expect
3408         // that &quot;bbc&quot; remains selected as it is still in the list
3409         treeView.setRoot(root);
3410         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3411 
3412         sl.dispose();
3413     }
3414 
3415     @Test public void test_rt35039_resetRootChildren() {
3416         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3417         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3418 
3419         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3420         root.setExpanded(true);
3421         root.getChildren().setAll(aabbaa, bbc);
3422 
3423         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3424         treeView.setRoot(root);
3425 
3426         StageLoader sl = new StageLoader(treeView);
3427 
3428         // Selection starts in row -1
3429         assertNull(treeView.getSelectionModel().getSelectedItem());
3430 
3431         // select &quot;bbc&quot; and ensure everything is set to that
3432         treeView.getSelectionModel().select(2);
3433         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3434 
3435         // change the items list - but retain the same content. We expect
3436         // that &quot;bbc&quot; remains selected as it is still in the list
3437         root.getChildren().setAll(aabbaa, bbc);
3438         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3439 
3440         sl.dispose();
3441     }
3442 
3443     @Test public void test_rt35763() {
3444         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3445         root.setExpanded(true);
3446         TreeItem aaa = new TreeItem(&quot;aaa&quot;);
3447         TreeItem bbb = new TreeItem(&quot;bbb&quot;);
3448         root.getChildren().setAll(bbb, aaa);
3449 
3450         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3451 
3452         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3453         col.setCellValueFactory(param -&gt; param.getValue().valueProperty());
3454 
3455         treeView.getColumns().add(col);
3456         treeView.setRoot(root);
3457 
3458         assertEquals(root, treeView.getTreeItem(0));
3459         assertEquals(bbb, treeView.getTreeItem(1));
3460         assertEquals(aaa,treeView.getTreeItem(2));
3461 
3462         // change sort order - expect items to be sorted
3463         treeView.getSortOrder().setAll(col);
3464 
3465         assertEquals(1, treeView.getSortOrder().size());
3466         assertEquals(col, treeView.getSortOrder().get(0));
3467 
3468         Toolkit.getToolkit().firePulse();
3469 
3470         assertEquals(root, treeView.getTreeItem(0));
3471         assertEquals(bbb, treeView.getTreeItem(2));
3472         assertEquals(aaa,treeView.getTreeItem(1));
3473 
3474         // set new items into items list - expect sortOrder list to be reset
3475         // and the items list to remain unsorted
3476         TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root&quot;);
3477         root2.setExpanded(true);
3478         TreeItem ccc = new TreeItem(&quot;ccc&quot;);
3479         TreeItem ddd = new TreeItem(&quot;ddd&quot;);
3480         root2.getChildren().setAll(ddd, ccc);
3481         treeView.setRoot(root2);
3482 
3483         assertEquals(root2, treeView.getTreeItem(0));
3484         assertEquals(ddd, treeView.getTreeItem(1));
3485         assertEquals(ccc,treeView.getTreeItem(2));
3486 
3487         assertTrue(treeView.getSortOrder().isEmpty());
3488     }
3489 
3490     @Test public void test_rt35857() {
3491         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3492         root.setExpanded(true);
3493         TreeItem a = new TreeItem(&quot;A&quot;);
3494         TreeItem b = new TreeItem(&quot;B&quot;);
3495         TreeItem c = new TreeItem(&quot;C&quot;);
3496         root.getChildren().setAll(a, b, c);
3497 
3498         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;(root);
3499 
3500         treeTableView.getSelectionModel().select(1);
3501 
3502         ObservableList&lt;TreeItem&lt;String&gt;&gt; selectedItems = treeTableView.getSelectionModel().getSelectedItems();
3503         assertEquals(1, selectedItems.size());
3504         assertEquals(&quot;A&quot;, selectedItems.get(0).getValue());
3505 
3506         root.getChildren().removeAll(selectedItems);
3507         assertEquals(2, root.getChildren().size());
3508         assertEquals(&quot;B&quot;, root.getChildren().get(0).getValue());
3509         assertEquals(&quot;C&quot;, root.getChildren().get(1).getValue());
3510     }
3511 
3512     private int rt36452_instanceCount = 0;
3513     @Test public void test_rt36452() {
3514         TreeTableColumn&lt;String, String&gt; myColumn = new TreeTableColumn&lt;String,String&gt;();
3515         myColumn.setCellValueFactory((item)-&gt;(new ReadOnlyObjectWrapper&lt;&gt;(item.getValue().getValue())));
3516         myColumn.setCellFactory(column -&gt; new TreeTableCell&lt;String, String&gt;() {
3517             {
3518                 rt36452_instanceCount++;
3519             }
3520         });
3521 
3522         TreeTableView&lt;String&gt; ttv = new TreeTableView&lt;&gt;();
3523         ttv.setShowRoot(false);
3524         ttv.getColumns().add(myColumn);
3525 
3526         TreeItem&lt;String&gt; treeRootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
3527         treeRootItem.setExpanded(true);
3528 
3529         for (int i = 0; i &lt; 100; i++) {
3530             treeRootItem.getChildren().add(new TreeItem&lt;&gt;(&quot;Child: &quot; + i));
3531         }
3532 
3533         ttv.setRoot(treeRootItem);
3534         ttv.setFixedCellSize(25);
3535 
3536         StackPane root = new StackPane();
3537         root.getChildren().add(ttv);
3538 
3539         StageLoader sl = new StageLoader(root);
3540 
3541         final int cellCountAtStart = rt36452_instanceCount;
3542 
3543         // start scrolling
3544         for (int i = 0; i &lt; 100; i++) {
3545             ttv.scrollTo(i);
3546             Toolkit.getToolkit().firePulse();
3547         }
3548 
3549         // we don&#39;t mind if an extra few cells are created. What we are really
3550         // testing for here is that we don&#39;t end up with an order of magnitude
3551         // extra cells.
3552         // On my machine the cellCountAtStart is 16. Before this issue was fixed
3553         // I would end up with 102 instances after running this test. Once the
3554         // bug was fixed, I would consistently see that 17 cells had been
3555         // created in total.
3556         // However, for now, we&#39;ll test on the assumption that across all
3557         // platforms we only get one extra cell created, and we can loosen this
3558         // up if necessary.
3559         assertEquals(cellCountAtStart + 1, rt36452_instanceCount);
3560 
3561         sl.dispose();
3562     }
3563 
3564     @Test public void test_rt25679_rowSelection() {
3565         test_rt25679(true);
3566     }
3567 
3568     @Test public void test_rt25679_cellSelection() {
3569         test_rt25679(false);
3570     }
3571 
3572     private void test_rt25679(boolean rowSelection) {
3573         Button focusBtn = new Button(&quot;Focus here&quot;);
3574 
3575         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3576         root.getChildren().setAll(new TreeItem(&quot;a&quot;), new TreeItem(&quot;b&quot;));
3577         root.setExpanded(true);
3578 
3579         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3580         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3581         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3582         treeView.getColumns().add(tableColumn);
3583 
3584         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3585         sm.setCellSelectionEnabled(! rowSelection);
3586 
3587         VBox vbox = new VBox(focusBtn, treeView);
3588 
3589         StageLoader sl = new StageLoader(vbox);
3590         sl.getStage().requestFocus();
3591         focusBtn.requestFocus();
3592         Toolkit.getToolkit().firePulse();
3593 
3594         // test initial state
3595         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
3596         assertTrue(focusBtn.isFocused());
3597         assertEquals(-1, sm.getSelectedIndex());
3598         assertNull(sm.getSelectedItem());
3599 
3600         // move focus to the TreeTableView
3601         treeView.requestFocus();
3602 
3603         // ensure that there is a selection (where previously there was not one)
3604         assertEquals(sl.getStage().getScene().getFocusOwner(), treeView);
3605         assertTrue(treeView.isFocused());
3606 
3607         if (rowSelection) {
3608             assertEquals(0, sm.getSelectedIndices().size());
3609             assertNull(sm.getSelectedItem());
3610             assertFalse(sm.isSelected(0));
3611             assertEquals(0, sm.getSelectedCells().size());
3612         } else {
3613             assertFalse(sm.isSelected(0, tableColumn));
3614             assertEquals(0, sm.getSelectedCells().size());
3615         }
3616 
3617         sl.dispose();
3618     }
3619 
3620     @Test public void test_rt36885() {
3621         test_rt36885(false);
3622     }
3623 
3624     @Test public void test_rt36885_addChildAfterSelection() {
3625         test_rt36885(true);
3626     }
3627 
3628     private void test_rt36885(boolean addChildToAAfterSelection) {
3629         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);         // 0
3630                 TreeItem&lt;String&gt; a = new TreeItem&lt;&gt;(&quot;a&quot;);       // 1
3631                     TreeItem&lt;String&gt; a1 = new TreeItem&lt;&gt;(&quot;a1&quot;); // a expanded = 2, a collapsed = -1
3632             TreeItem&lt;String&gt; b = new TreeItem&lt;&gt;(&quot;b&quot;);           // a expanded = 3, a collapsed = 2
3633                 TreeItem&lt;String&gt; b1 = new TreeItem&lt;&gt;(&quot;b1&quot;);     // a expanded = 4, a collapsed = 3
3634                 TreeItem&lt;String&gt; b2 = new TreeItem&lt;&gt;(&quot;b2&quot;);     // a expanded = 5, a collapsed = 4
3635 
3636         root.setExpanded(true);
3637         root.getChildren().setAll(a, b);
3638 
3639         a.setExpanded(false);
3640         if (!addChildToAAfterSelection) {
3641             a.getChildren().add(a1);
3642         }
3643 
3644         b.setExpanded(true);
3645         b.getChildren().addAll(b1, b2);
3646 
3647         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3648         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3649         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3650         treeView.getColumns().add(tableColumn);
3651 
3652         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3653         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = treeView.getFocusModel();
3654 
3655         sm.select(b1);
3656         assertEquals(3, sm.getSelectedIndex());
3657         assertEquals(b1, sm.getSelectedItem());
3658         assertEquals(3, fm.getFocusedIndex());
3659         assertEquals(b1, fm.getFocusedItem());
3660 
3661         if (addChildToAAfterSelection) {
3662             a.getChildren().add(a1);
3663         }
3664 
3665         a.setExpanded(true);
3666         assertEquals(4, sm.getSelectedIndex());
3667         assertEquals(b1, sm.getSelectedItem());
3668         assertEquals(4, fm.getFocusedIndex());
3669         assertEquals(b1, fm.getFocusedItem());
3670     }
3671 
3672     private int rt_37061_index_counter = 0;
3673     private int rt_37061_item_counter = 0;
3674     @Test public void test_rt_37061() {
3675         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3676         root.setExpanded(true);
3677         TreeTableView&lt;Integer&gt; tv = new TreeTableView&lt;&gt;();
3678         tv.setRoot(root);
3679         tv.getSelectionModel().select(0);
3680 
3681         // note we add the listeners after the selection is made, so the counters
3682         // at this point are still both at zero.
3683         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
3684             rt_37061_index_counter++;
3685         });
3686 
3687         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
3688             rt_37061_item_counter++;
3689         });
3690 
3691         // add a new item. This does not impact the selected index or selected item
3692         // so the counters should remain at zero.
3693         tv.getRoot().getChildren().add(new TreeItem(&quot;1&quot;));
3694         assertEquals(0, rt_37061_index_counter);
3695         assertEquals(0, rt_37061_item_counter);
3696     }
3697 
3698     @Test public void test_rt_37054_noScroll() {
3699         test_rt_37054(false);
3700     }
3701 
3702     @Test public void test_rt_37054_scroll() {
3703         test_rt_37054(true);
3704     }
3705 
3706     private void test_rt_37054(boolean scroll) {
3707         ObjectProperty&lt;Integer&gt; offset = new SimpleObjectProperty&lt;Integer&gt;(0);
3708 
3709         // create table with a bunch of rows and 1 column...
3710         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3711         root.setExpanded(true);
3712         for (int i = 1; i &lt;= 50; i++) {
3713             root.getChildren().add(new TreeItem&lt;&gt;(i));
3714         }
3715 
3716         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3717 
3718         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3719         table.getColumns().add( column );
3720         column.setPrefWidth( 150 );
3721 
3722         // each cell displays x, where x = &quot;cell row number + offset&quot;
3723         column.setCellValueFactory( cdf -&gt; new ObjectBinding&lt;Integer&gt;() {
3724             { super.bind( offset ); }
3725 
3726             @Override protected Integer computeValue() {
3727                 return cdf.getValue().getValue() + offset.get();
3728             }
3729         });
3730 
3731         StackPane stack = new StackPane();
3732         stack.getChildren().add(table);
3733         StageLoader sl = new StageLoader(stack);
3734 
3735         int index = scroll ? 0 : 25;
3736 
3737         if (scroll) {
3738             // we scroll to force the table cells to update the objects they observe
3739             table.scrollTo(index);
3740             Toolkit.getToolkit().firePulse();
3741         }
3742 
3743         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, index + 3, 0);
3744         final int initialValue = (Integer) cell.getItem();
3745 
3746         // increment the offset value
3747         offset.setValue(offset.get() + 1);
3748         Toolkit.getToolkit().firePulse();
3749 
3750         final int incrementedValue = (Integer) cell.getItem();
3751         assertEquals(initialValue + 1, incrementedValue);
3752 
3753         sl.dispose();
3754     }
3755 
3756     private int rt_37395_index_addCount = 0;
3757     private int rt_37395_index_removeCount = 0;
3758     private int rt_37395_index_permutationCount = 0;
3759     private int rt_37395_item_addCount = 0;
3760     private int rt_37395_item_removeCount = 0;
3761     private int rt_37395_item_permutationCount = 0;
3762 
3763     @Test public void test_rt_37395() {
3764         // table items - 3 items, 2nd item has 2 children
3765         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3766 
3767         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3768         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3769         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3770 
3771         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3772         root.getChildren().add(two);
3773         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3774 
3775         // table columns - 1 column; name
3776         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3777         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3778         nameColumn.setPrefWidth(200);
3779 
3780         // table
3781         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3782         table.setShowRoot(false);
3783         table.setRoot(root);
3784         table.getColumns().addAll(nameColumn);
3785 
3786         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
3787         sm.getSelectedIndices().addListener(new ListChangeListener&lt;Integer&gt;() {
3788             @Override public void onChanged(Change&lt;? extends Integer&gt; c) {
3789                 while (c.next()) {
3790                     if (c.wasRemoved()) {
3791                         c.getRemoved().forEach(item -&gt; {
3792                             if (item == null) {
3793                                 fail(&quot;Removed index should never be null&quot;);
3794                             } else {
3795                                 rt_37395_index_removeCount++;
3796                             }
3797                         });
3798                     }
3799                     if (c.wasAdded()) {
3800                         c.getAddedSubList().forEach(item -&gt; {
3801                             rt_37395_index_addCount++;
3802                         });
3803                     }
3804                     if (c.wasPermutated()) {
3805                         rt_37395_index_permutationCount++;
3806                     }
3807                 }
3808             }
3809         });
3810         sm.getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;String&gt;&gt;() {
3811             @Override public void onChanged(Change&lt;? extends TreeItem&lt;String&gt;&gt; c) {
3812                 while (c.next()) {
3813                     if (c.wasRemoved()) {
3814                         c.getRemoved().forEach(item -&gt; {
3815                             if (item == null) {
3816                                 fail(&quot;Removed item should never be null&quot;);
3817                             } else {
3818                                 rt_37395_item_removeCount++;
3819                             }
3820                         });
3821                     }
3822                     if (c.wasAdded()) {
3823                         c.getAddedSubList().forEach(item -&gt; {
3824                             rt_37395_item_addCount++;
3825                         });
3826                     }
3827                     if (c.wasPermutated()) {
3828                         rt_37395_item_permutationCount++;
3829                     }
3830                 }
3831             }
3832         });
3833 
3834         assertEquals(0, rt_37395_index_removeCount);
3835         assertEquals(0, rt_37395_index_addCount);
3836         assertEquals(0, rt_37395_index_permutationCount);
3837         assertEquals(0, rt_37395_item_removeCount);
3838         assertEquals(0, rt_37395_item_addCount);
3839         assertEquals(0, rt_37395_item_permutationCount);
3840 
3841         StageLoader sl = new StageLoader(table);
3842 
3843         // step one: select item &#39;three&#39; in index 2
3844         sm.select(2);
3845         assertEquals(0, rt_37395_index_removeCount);
3846         assertEquals(1, rt_37395_index_addCount);
3847         assertEquals(0, rt_37395_index_permutationCount);
3848         assertEquals(0, rt_37395_item_removeCount);
3849         assertEquals(1, rt_37395_item_addCount);
3850         assertEquals(0, rt_37395_item_permutationCount);
3851 
3852         // step two: expand item &#39;two&#39;
3853         // The first part of the bug report was that we received add/remove
3854         // change events here, when in reality we shouldn&#39;t have, so lets enforce
3855         // that. We do expect a permutation event on the index, as it has been
3856         // pushed down, but this should not result in an item permutation event,
3857         // as it remains unchanged
3858         two.setExpanded(true);
3859         assertEquals(1, rt_37395_index_removeCount);
3860         assertEquals(2, rt_37395_index_addCount);
3861         assertEquals(0, rt_37395_index_permutationCount);
3862         assertEquals(0, rt_37395_item_removeCount);
3863         assertEquals(1, rt_37395_item_addCount);
3864         assertEquals(0, rt_37395_item_permutationCount);
3865 
3866         // step three: collapse item &#39;two&#39;
3867         // Same argument as in step two above: no addition or removal, just a
3868         // permutation on the index
3869         two.setExpanded(false);
3870         assertEquals(2, rt_37395_index_removeCount);
3871         assertEquals(3, rt_37395_index_addCount);
3872         assertEquals(0, rt_37395_index_permutationCount);
3873         assertEquals(0, rt_37395_item_removeCount);
3874         assertEquals(1, rt_37395_item_addCount);
3875         assertEquals(0, rt_37395_item_permutationCount);
3876 
3877         sl.dispose();
3878     }
3879 
3880     @Test public void test_rt_37429() {
3881         // table items - 3 items, 2nd item has 2 children
3882         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3883 
3884         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3885         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3886         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3887         two.setExpanded(true);
3888 
3889         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3890         root.getChildren().add(two);
3891         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3892 
3893         // table columns - 1 column; name
3894         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3895         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3896         nameColumn.setPrefWidth(200);
3897 
3898         // table
3899         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3900         table.setShowRoot(false);
3901         table.setRoot(root);
3902         table.getColumns().addAll(nameColumn);
3903 
3904         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3905             while (c.next()) {
3906                 if(c.wasRemoved()) {
3907                     // The removed list of items must be iterated or the AIOOBE will
3908                     // not be thrown when getAddedSubList is called.
3909                     c.getRemoved().forEach(item -&gt; {});
3910                 }
3911 
3912                 if (c.wasAdded()) {
3913                     c.getAddedSubList();
3914                 }
3915             }
3916         });
3917 
3918         StageLoader sl = new StageLoader(table);
3919 
3920         ControlTestUtils.runWithExceptionHandler(() -&gt; {
3921             table.getSelectionModel().select(0);
3922             table.getSortOrder().add(nameColumn);
3923         });
3924 
3925         sl.dispose();
3926     }
3927 
3928     private int rt_37429_items_change_count = 0;
3929     private int rt_37429_cells_change_count = 0;
3930     @Test public void test_rt_37429_sortEventsShouldNotFireExtraChangeEvents() {
3931         // table items - 3 items, 2nd item has 2 children
3932         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3933 
3934         root.getChildren().add(new TreeItem&lt;&gt;(&quot;a&quot;));
3935         root.getChildren().add(new TreeItem&lt;&gt;(&quot;c&quot;));
3936         root.getChildren().add(new TreeItem&lt;&gt;(&quot;b&quot;));
3937 
3938         // table columns - 1 column; name
3939         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3940         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3941         nameColumn.setPrefWidth(200);
3942 
3943         // table
3944         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3945         table.setShowRoot(false);
3946         table.setRoot(root);
3947         table.getColumns().addAll(nameColumn);
3948 
3949         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3950             while (c.next()) {
3951                 rt_37429_items_change_count++;
3952             }
3953         });
3954         table.getSelectionModel().getSelectedCells().addListener((ListChangeListener&lt;TreeTablePosition&lt;String, ?&gt;&gt;) c -&gt; {
3955             while (c.next()) {
3956                 rt_37429_cells_change_count++;
3957             }
3958         });
3959 
3960         StageLoader sl = new StageLoader(table);
3961 
3962         assertEquals(0, rt_37429_items_change_count);
3963         assertEquals(0, rt_37429_cells_change_count);
3964 
3965         table.getSelectionModel().select(0);
3966         assertEquals(1, rt_37429_items_change_count);
3967         assertEquals(1, rt_37429_cells_change_count);
3968 
3969         table.getSortOrder().add(nameColumn);
3970         assertEquals(1, rt_37429_items_change_count);
3971         assertEquals(1, rt_37429_cells_change_count);
3972 
3973         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3974         assertEquals(1, rt_37429_items_change_count);
3975         assertEquals(2, rt_37429_cells_change_count);
3976 
3977         nameColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
3978         assertEquals(1, rt_37429_items_change_count);
3979         assertEquals(3, rt_37429_cells_change_count);
3980 
3981         sl.dispose();
3982     }
3983 
3984     private int rt_37538_count = 0;
3985     @Test public void test_rt_37538_noCNextCall() {
3986         test_rt_37538(false, false);
3987     }
3988 
3989     @Test public void test_rt_37538_callCNextOnce() {
3990         test_rt_37538(true, false);
3991     }
3992 
3993     @Test public void test_rt_37538_callCNextInLoop() {
3994         test_rt_37538(false, true);
3995     }
3996 
3997     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
3998         // create table with a bunch of rows and 1 column...
3999         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
4000         root.setExpanded(true);
4001         for (int i = 1; i &lt;= 50; i++) {
4002             root.getChildren().add(new TreeItem&lt;&gt;(i));
4003         }
4004 
4005         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4006         column.setCellValueFactory( cdf -&gt; new ReadOnlyObjectWrapper&lt;Integer&gt;(cdf.getValue().getValue()));
4007 
4008         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
4009         table.getColumns().add( column );
4010 
4011         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;Integer&gt;&gt; c) -&gt; {
4012             if (callCNextOnce) {
4013                 c.next();
4014             } else if (callCNextInLoop) {
4015                 while (c.next()) {
4016                     // no-op
4017                 }
4018             }
4019 
4020             if (rt_37538_count &gt;= 1) {
4021                 Thread.dumpStack();
4022                 fail(&quot;This method should only be called once&quot;);
4023             }
4024 
4025             rt_37538_count++;
4026         });
4027 
4028         StageLoader sl = new StageLoader(table);
4029         assertEquals(0, rt_37538_count);
4030         table.getSelectionModel().select(0);
4031         assertEquals(1, rt_37538_count);
4032         sl.dispose();
4033     }
4034 
4035     @Test public void test_rt_37593() {
4036         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
4037 
4038         TreeItem&lt;String&gt; one = new TreeItem&lt;&gt;(&quot;one&quot;);
4039         root.getChildren().add(one);
4040 
4041         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
4042         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
4043         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
4044         root.getChildren().add(two);
4045 
4046         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
4047 
4048         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
4049         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
4050 
4051         treeTableView.setShowRoot(false);
4052         treeTableView.setRoot(root);
4053         treeTableView.getColumns().addAll(nameColumn);
4054 
4055         treeTableView.getSortOrder().add(nameColumn);
4056         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
4057         sm.select(one);
4058 
4059         // at this point, the &#39;one&#39; item should be in row 2
4060         assertTrue(sm.isSelected(2));
4061         assertEquals(one, sm.getSelectedItem());
4062 
4063         two.setExpanded(true);
4064 
4065         // we should end up with the selection being on index 4, which is the
4066         // final location of the &#39;one&#39; tree item, after sorting and expanding &#39;two&#39;
4067         assertEquals(one, sm.getSelectedItem());
4068         assertTrue(debug(), sm.isSelected(4));
4069 
4070         // this line would create a NPE
4071         VirtualFlowTestUtils.clickOnRow(treeTableView, 4, true);
4072 
4073         // The mouse click should not change selection at all
4074         assertEquals(one, sm.getSelectedItem());
4075         assertTrue(debug(), sm.isSelected(4));
4076     }
4077 
4078     @Test public void test_rt_35395_testCell_fixedCellSize() {
4079         test_rt_35395(true, true);
4080     }
4081 
4082     @Test public void test_rt_35395_testCell_notFixedCellSize() {
4083         test_rt_35395(true, false);
4084     }
4085 
4086     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4087     @Test public void test_rt_35395_testRow_fixedCellSize() {
4088         test_rt_35395(false, true);
4089     }
4090 
4091     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
4092     @Test public void test_rt_35395_testRow_notFixedCellSize() {
4093         test_rt_35395(false, false);
4094     }
4095 
4096     private int rt_35395_counter;
4097     private void test_rt_35395(boolean testCell, boolean useFixedCellSize) {
4098         rt_35395_counter = 0;
4099 
4100         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;green&quot;);
4101         root.setExpanded(true);
4102         for (int i = 0; i &lt; 20; i++) {
4103             root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;red&quot;), new TreeItem&lt;&gt;(&quot;green&quot;), new TreeItem&lt;&gt;(&quot;blue&quot;), new TreeItem&lt;&gt;(&quot;purple&quot;));
4104         }
4105 
4106         TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4107         if (useFixedCellSize) {
4108             treeTableView.setFixedCellSize(24);
4109         }
4110         treeTableView.setRowFactory(tv -&gt; new TreeTableRowShim&lt;String&gt;() {
4111             @Override public void updateItem(String color, boolean empty) {
4112                 rt_35395_counter += testCell ? 0 : 1;
4113                 super.updateItem(color, empty);
4114             }
4115         });
4116 
4117         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4118         column.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
4119         column.setCellFactory(tv -&gt; new TreeTableCellShim&lt;String,String&gt;() {
4120             @Override public void updateItem(String color, boolean empty) {
4121                 rt_35395_counter += testCell ? 1 : 0;
4122                 super.updateItem(color, empty);
4123                 setText(null);
4124                 if (empty) {
4125                     setGraphic(null);
4126                 } else {
4127                     Rectangle rect = new Rectangle(16, 16);
4128                     rect.setStyle(&quot;-fx-fill: &quot; + color);
4129                     setGraphic(rect);
4130                 }
4131             }
4132         });
4133         treeTableView.getColumns().addAll(column);
4134 
4135         StageLoader sl = new StageLoader(treeTableView);
4136 
4137         Platform.runLater(() -&gt; {
4138             rt_35395_counter = 0;
4139             root.getChildren().set(10, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4140             Platform.runLater(() -&gt; {
4141                 Toolkit.getToolkit().firePulse();
4142                 assertEquals(1, rt_35395_counter);
4143                 rt_35395_counter = 0;
4144                 root.getChildren().set(30, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4145                 Platform.runLater(() -&gt; {
4146                     Toolkit.getToolkit().firePulse();
4147                     assertEquals(0, rt_35395_counter);
4148                     rt_35395_counter = 0;
4149                     treeTableView.scrollTo(5);
4150                     Platform.runLater(() -&gt; {
4151                         Toolkit.getToolkit().firePulse();
4152                         assertEquals(useFixedCellSize ? 5 : 5, rt_35395_counter);
4153                         rt_35395_counter = 0;
4154                         treeTableView.scrollTo(55);
4155                         Platform.runLater(() -&gt; {
4156                             Toolkit.getToolkit().firePulse();
4157 
4158                             assertEquals(useFixedCellSize ? 7 : 59, rt_35395_counter);
4159                             sl.dispose();
4160                         });
4161                     });
4162                 });
4163             });
4164         });
4165     }
4166 
4167     @Test public void test_rt_37632() {
4168         final TreeItem&lt;String&gt; rootOne = new TreeItem&lt;&gt;(&quot;Root 1&quot;);
4169         final TreeItem&lt;String&gt; rootTwo = new TreeItem&lt;&gt;(&quot;Root 2&quot;);
4170 
4171         TreeTableColumn&lt;String,String&gt; tableColumn = new TreeTableColumn(&quot;column&quot;);
4172         tableColumn.setCellValueFactory(c -&gt; new ReadOnlyStringWrapper(c.getValue().getValue()));
4173 
4174         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;();
4175         treeTableView.getColumns().addAll(tableColumn);
4176         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4177         treeTableView.setRoot(rootOne);
4178         treeTableView.getSelectionModel().selectFirst();
4179 
4180         assertEquals(0, sm.getSelectedIndex());
4181         assertEquals(rootOne, sm.getSelectedItem());
4182         assertEquals(1, sm.getSelectedIndices().size());
4183         assertEquals(0, (int) sm.getSelectedIndices().get(0));
4184         assertEquals(1, sm.getSelectedItems().size());
4185         assertEquals(rootOne, sm.getSelectedItems().get(0));
4186 
4187         treeTableView.setRoot(rootTwo);
4188 
4189         assertEquals(-1, sm.getSelectedIndex());
4190         assertNull(sm.getSelectedItem());
4191         assertEquals(0, sm.getSelectedIndices().size());
4192         assertEquals(0, sm.getSelectedItems().size());
4193     }
4194 
4195     private TreeTableView&lt;Person&gt; test_rt_38464_createControl() {
4196         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4197                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4198                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4199                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4200                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4201                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4202 
4203         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4204         table.setShowRoot(false);
4205 
4206         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4207         root.setExpanded(true);
4208         root.getChildren().setAll(persons);
4209         table.setRoot(root);
4210 
4211 
4212 
4213         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
4214         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
4215 
4216         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
4217         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
4218 
4219         table.getColumns().addAll(firstNameCol, lastNameCol);
4220 
4221         return table;
4222     }
4223 
4224     @Test public void test_rt_38464_rowSelection_selectFirstRowOnly() {
4225         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4226         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4227         sm.setCellSelectionEnabled(false);
4228         sm.setSelectionMode(SelectionMode.MULTIPLE);
4229 
4230         sm.select(0);
4231 
4232         assertTrue(sm.isSelected(0));
4233         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4234         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4235 
4236         assertEquals(1, sm.getSelectedIndices().size());
4237         assertEquals(1, sm.getSelectedItems().size());
4238         assertEquals(1, sm.getSelectedCells().size());
4239     }
4240 
4241     @Test public void test_rt_38464_rowSelection_selectFirstRowAndThenCallNoOpMethods() {
4242         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4243         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4244         sm.setCellSelectionEnabled(false);
4245         sm.setSelectionMode(SelectionMode.MULTIPLE);
4246 
4247         sm.select(0);               // select first row
4248         sm.select(0);               // this should be a no-op
4249         sm.select(0, table.getColumns().get(0)); // so should this, as we are in row selection mode
4250         sm.select(0, table.getColumns().get(1));  // and same here
4251 
4252         assertTrue(sm.isSelected(0));
4253         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4254         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4255 
4256         assertEquals(1, sm.getSelectedIndices().size());
4257         assertEquals(1, sm.getSelectedItems().size());
4258         assertEquals(1, sm.getSelectedCells().size());
4259     }
4260 
4261 
4262     @Test public void test_rt_38464_cellSelection_selectFirstRowOnly() {
4263         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4264         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4265         sm.setCellSelectionEnabled(true);
4266         sm.setSelectionMode(SelectionMode.MULTIPLE);
4267 
4268         // select first row. This should be translated into selection of all
4269         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4270         // considered selected.
4271         sm.select(0);
4272 
4273         assertTrue(sm.isSelected(0));
4274         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4275         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4276 
4277         assertEquals(1, sm.getSelectedIndices().size());
4278         assertEquals(1, sm.getSelectedItems().size());
4279         assertEquals(2, sm.getSelectedCells().size());
4280     }
4281 
4282     @Test public void test_rt_38464_cellSelection_selectFirstRowAndThenCallNoOpMethods() {
4283         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4284         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4285         sm.setCellSelectionEnabled(true);
4286         sm.setSelectionMode(SelectionMode.MULTIPLE);
4287 
4288         // select first row. This should be translated into selection of all
4289         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4290         // considered selected.
4291         sm.select(0);                            // select first row
4292         sm.select(0, table.getColumns().get(0)); // This line and the next should be no-ops
4293         sm.select(0, table.getColumns().get(1));
4294 
4295         assertTrue(sm.isSelected(0));
4296         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4297         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4298 
4299         assertEquals(1, sm.getSelectedIndices().size());
4300         assertEquals(1, sm.getSelectedItems().size());
4301         assertEquals(2, sm.getSelectedCells().size());
4302     }
4303 
4304     @Test public void test_rt38464_selectCellMultipleTimes() {
4305         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4306         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4307         sm.setCellSelectionEnabled(true);
4308         sm.setSelectionMode(SelectionMode.MULTIPLE);
4309 
4310         // default selection when in cell selection mode
4311         assertEquals(0, sm.getSelectedCells().size());
4312         assertEquals(0, sm.getSelectedItems().size());
4313         assertEquals(0, sm.getSelectedIndices().size());
4314 
4315         // select the first cell
4316         sm.select(0, table.getColumns().get(0));
4317         assertEquals(1, sm.getSelectedCells().size());
4318         assertEquals(1, sm.getSelectedItems().size());
4319         assertEquals(1, sm.getSelectedIndices().size());
4320 
4321         // select the first cell....again
4322         sm.select(0, table.getColumns().get(0));
4323         assertEquals(1, sm.getSelectedCells().size());
4324         assertEquals(1, sm.getSelectedItems().size());
4325         assertEquals(1, sm.getSelectedIndices().size());
4326     }
4327 
4328     @Test public void test_rt38464_selectCellThenRow() {
4329         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4330         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4331         sm.setCellSelectionEnabled(true);
4332         sm.setSelectionMode(SelectionMode.MULTIPLE);
4333 
4334         // default selection when in cell selection mode
4335         assertEquals(0, sm.getSelectedCells().size());
4336         assertEquals(0, sm.getSelectedItems().size());
4337         assertEquals(0, sm.getSelectedIndices().size());
4338 
4339         // select the first cell
4340         sm.select(0, table.getColumns().get(0));
4341         assertEquals(1, sm.getSelectedCells().size());
4342         assertEquals(1, sm.getSelectedItems().size());
4343         assertEquals(1, sm.getSelectedIndices().size());
4344 
4345         // select the first row
4346         sm.select(0);
4347 
4348         // we go to 2 here as all cells in the row become selected. What we do
4349         // not expect is to go to 3, as that would mean duplication
4350         assertEquals(2, sm.getSelectedCells().size());
4351         assertEquals(1, sm.getSelectedItems().size());
4352         assertEquals(1, sm.getSelectedIndices().size());
4353     }
4354 
4355     @Test public void test_rt38464_selectRowThenCell() {
4356         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4357         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4358         sm.setCellSelectionEnabled(true);
4359         sm.setSelectionMode(SelectionMode.MULTIPLE);
4360 
4361         // default selection when in cell selection mode
4362         assertEquals(0, sm.getSelectedCells().size());
4363         assertEquals(0, sm.getSelectedItems().size());
4364         assertEquals(0, sm.getSelectedIndices().size());
4365 
4366         // select the first row
4367         sm.select(0);
4368 
4369         // we go to 2 here as all cells in the row become selected.
4370         assertEquals(2, sm.getSelectedCells().size());
4371         assertEquals(1, sm.getSelectedItems().size());
4372         assertEquals(1, sm.getSelectedIndices().size());
4373 
4374         // select the first cell - no change is expected
4375         sm.select(0, table.getColumns().get(0));
4376         assertEquals(2, sm.getSelectedCells().size());
4377         assertEquals(1, sm.getSelectedItems().size());
4378         assertEquals(1, sm.getSelectedIndices().size());
4379     }
4380 
4381     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsOneRow() {
4382         test_rt38464_selectTests(true, true, true);
4383     }
4384 
4385     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsTwoRows() {
4386         test_rt38464_selectTests(true, true, false);
4387     }
4388 
4389     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsOneRow() {
4390         test_rt38464_selectTests(true, false, true);
4391     }
4392 
4393     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsTwoRows() {
4394         test_rt38464_selectTests(true, false, false);
4395     }
4396 
4397     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsOneRow() {
4398         test_rt38464_selectTests(false, true, true);
4399     }
4400 
4401     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsTwoRows() {
4402         test_rt38464_selectTests(false, true, false);
4403     }
4404 
4405     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsOneRow() {
4406         test_rt38464_selectTests(false, false, true);
4407     }
4408 
4409     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsTwoRows() {
4410         test_rt38464_selectTests(false, false, false);
4411     }
4412 
4413     private void test_rt38464_selectTests(boolean cellSelection, boolean singleSelection, boolean selectsOneRow) {
4414         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4415         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4416         sm.setCellSelectionEnabled(cellSelection);
4417         sm.setSelectionMode(singleSelection ? SelectionMode.SINGLE : SelectionMode.MULTIPLE);
4418 
4419         // default selection when in cell selection mode
4420         assertEquals(0, sm.getSelectedCells().size());
4421         assertEquals(0, sm.getSelectedItems().size());
4422         assertEquals(0, sm.getSelectedIndices().size());
4423 
4424         if (selectsOneRow) {
4425             sm.select(0);
4426         } else {
4427             // select the first two rows
4428             sm.selectIndices(0, 1);
4429         }
4430 
4431         final int expectedCells = singleSelection                    ? 1 :
4432                                   selectsOneRow   &amp;&amp; cellSelection   ? 2 :
4433                                   selectsOneRow   &amp;&amp; !cellSelection  ? 1 :
4434                                   !selectsOneRow  &amp;&amp; cellSelection   ? 4 :
4435                                /* !selectsOneRow  &amp;&amp; !cellSelection */ 2;
4436 
4437         final int expectedItems = singleSelection ? 1 :
4438                 selectsOneRow   ? 1 : 2;
4439 
4440         assertEquals(expectedCells, sm.getSelectedCells().size());
4441         assertEquals(expectedItems, sm.getSelectedItems().size());
4442         assertEquals(expectedItems, sm.getSelectedIndices().size());
4443 
4444         // we expect the table column of all selected cells, in this instance,
4445         // to be null as we have not explicitly stated a column, nor have we clicked
4446         // on a column. The only alternative is to use the first column.
4447         for (TreeTablePosition&lt;?,?&gt; tp : sm.getSelectedCells()) {
4448             if (cellSelection) {
4449                 assertNotNull(tp.getTableColumn());
4450             } else {
4451                 assertNull(tp.getTableColumn());
4452             }
4453         }
4454     }
4455 
4456     @Test public void test_rt_37853_replaceRoot() {
4457         test_rt_37853(true);
4458     }
4459 
4460     @Test public void test_rt_37853_replaceRootChildren() {
4461         test_rt_37853(false);
4462     }
4463 
4464     private int rt_37853_cancelCount;
4465     private int rt_37853_commitCount;
4466     public void test_rt_37853(boolean replaceRoot) {
4467         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;&gt;(&quot;first&quot;);
4468         first.setEditable(true);
4469         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
4470         treeTableView.getColumns().add(first);
4471         treeTableView.setEditable(true);
4472         treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;Root&quot;));
4473         treeTableView.getRoot().setExpanded(true);
4474 
4475         for (int i = 0; i &lt; 10; i++) {
4476             treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;&quot; + i));
4477         }
4478 
4479         StageLoader sl = new StageLoader(treeTableView);
4480 
4481         first.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
4482         first.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
4483 
4484         assertEquals(0, rt_37853_cancelCount);
4485         assertEquals(0, rt_37853_commitCount);
4486 
4487         treeTableView.edit(1, first);
4488         assertNotNull(treeTableView.getEditingCell());
4489 
4490         if (replaceRoot) {
4491             treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;New Root&quot;));
4492         } else {
4493             treeTableView.getRoot().getChildren().clear();
4494             for (int i = 0; i &lt; 10; i++) {
4495                 treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;new item &quot; + i));
4496             }
4497         }
4498         assertEquals(1, rt_37853_cancelCount);
4499         assertEquals(0, rt_37853_commitCount);
4500 
4501         sl.dispose();
4502     }
4503 
4504 
4505     /**************************************************************************
4506      *
4507      * Tests (and related code) for RT-38892
4508      *
4509      *************************************************************************/
4510 
4511     private final Supplier&lt;TreeTableColumn&lt;Person,String&gt;&gt; columnCallable = () -&gt; {
4512         TreeTableColumn&lt;Person,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Last Name&quot;);
4513         column.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person,String&gt;(&quot;lastName&quot;));
4514         return column;
4515     };
4516 
4517     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_firstNameCol;
4518     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_lastNameCol;
4519 
4520     private TreeTableView&lt;Person&gt; init_test_rt_38892() {
4521         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4522                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4523                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4524                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4525                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4526                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4527 
4528         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4529         table.setShowRoot(false);
4530         table.getSelectionModel().setCellSelectionEnabled(true);
4531         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
4532 
4533         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4534         root.setExpanded(true);
4535         root.getChildren().setAll(persons);
4536         table.setRoot(root);
4537 
4538         test_rt_38892_firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
4539         test_rt_38892_firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
4540         test_rt_38892_lastNameCol = columnCallable.get();
4541         table.getColumns().addAll(test_rt_38892_firstNameCol, test_rt_38892_lastNameCol);
4542 
4543         return table;
4544     }
4545 
4546     @Test public void test_rt_38892_focusMovesToLeftWhenPossible() {
4547         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4548 
4549         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4550         fm.focus(0, test_rt_38892_lastNameCol);
4551 
4552         // assert pre-conditions
4553         assertEquals(0, fm.getFocusedIndex());
4554         assertEquals(0, fm.getFocusedCell().getRow());
4555         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4556         assertEquals(1, fm.getFocusedCell().getColumn());
4557 
4558         // now remove column where focus is and replace it with a new column.
4559         // We expect focus to move to the left one cell.
4560         table.getColumns().remove(1);
4561         table.getColumns().add(columnCallable.get());
4562 
4563         assertEquals(0, fm.getFocusedIndex());
4564         assertEquals(0, fm.getFocusedCell().getRow());
4565         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4566         assertEquals(0, fm.getFocusedCell().getColumn());
4567     }
4568 
4569     @Test public void test_rt_38892_removeLeftMostColumn() {
4570         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4571 
4572         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4573         fm.focus(0, test_rt_38892_firstNameCol);
4574 
4575         // assert pre-conditions
4576         assertEquals(0, fm.getFocusedIndex());
4577         assertEquals(0, fm.getFocusedCell().getRow());
4578         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4579         assertEquals(0, fm.getFocusedCell().getColumn());
4580 
4581         // now remove column where focus is and replace it with a new column.
4582         // In the current (non-specified) behavior, this results in focus being
4583         // shifted to a cell in the remaining column, even when we add a new column
4584         // as we index based on the column, not on its index.
4585         table.getColumns().remove(0);
4586         TreeTableColumn&lt;Person,String&gt; newColumn = columnCallable.get();
4587         table.getColumns().add(0, newColumn);
4588 
4589         assertEquals(0, fm.getFocusedIndex());
4590         assertEquals(0, fm.getFocusedCell().getRow());
4591         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4592         assertEquals(0, fm.getFocusedCell().getColumn());
4593     }
4594 
4595     @Test public void test_rt_38892_removeSelectionFromCellsInRemovedColumn() {
4596         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4597 
4598         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
4599         sm.select(0, test_rt_38892_firstNameCol);
4600         sm.select(1, test_rt_38892_lastNameCol);    // this should go
4601         sm.select(2, test_rt_38892_firstNameCol);
4602         sm.select(3, test_rt_38892_lastNameCol);    // so should this
4603         sm.select(4, test_rt_38892_firstNameCol);
4604 
4605         assertEquals(5, sm.getSelectedCells().size());
4606 
4607         table.getColumns().remove(1);
4608 
4609         assertEquals(3, sm.getSelectedCells().size());
4610         assertTrue(sm.isSelected(0, test_rt_38892_firstNameCol));
4611         assertFalse(sm.isSelected(1, test_rt_38892_lastNameCol));
4612         assertTrue(sm.isSelected(2, test_rt_38892_firstNameCol));
4613         assertFalse(sm.isSelected(3, test_rt_38892_lastNameCol));
4614         assertTrue(sm.isSelected(4, test_rt_38892_firstNameCol));
4615     }
4616 
4617     @Test public void test_rt_38787_remove_b() {
4618         // Remove &#39;b&#39;, selection moves to &#39;a&#39;
4619         test_rt_38787(&quot;a&quot;, 0, 1);
4620     }
4621 
4622     @Test public void test_rt_38787_remove_b_c() {
4623         // Remove &#39;b&#39; and &#39;c&#39;, selection moves to &#39;a&#39;
4624         test_rt_38787(&quot;a&quot;, 0, 1, 2);
4625     }
4626 
4627     @Test public void test_rt_38787_remove_c_d() {
4628         // Remove &#39;c&#39; and &#39;d&#39;, selection moves to &#39;b&#39;
4629         test_rt_38787(&quot;b&quot;, 1, 2, 3);
4630     }
4631 
4632     @Test public void test_rt_38787_remove_a() {
4633         // Remove &#39;a&#39;, selection moves to &#39;b&#39;, now in index 0
4634         test_rt_38787(&quot;b&quot;, 0, 0);
4635     }
4636 
4637     private void test_rt_38787(String expectedItem, int expectedIndex, int... indicesToRemove) {
4638         TreeItem&lt;String&gt; a, b, c, d;
4639         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4640         root.setExpanded(true);
4641         root.getChildren().addAll(
4642                 a = new TreeItem&lt;String&gt;(&quot;a&quot;),
4643                 b = new TreeItem&lt;String&gt;(&quot;b&quot;),
4644                 c = new TreeItem&lt;String&gt;(&quot;c&quot;),
4645                 d = new TreeItem&lt;String&gt;(&quot;d&quot;)
4646         );
4647 
4648         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4649         stringTreeTableView.setShowRoot(false);
4650 
4651         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4652         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4653         stringTreeTableView.getColumns().add(column);
4654 
4655         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4656         sm.select(b);
4657 
4658         // test pre-conditions
4659         assertEquals(1, sm.getSelectedIndex());
4660         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4661         assertEquals(b, sm.getSelectedItem());
4662         assertEquals(b, sm.getSelectedItems().get(0));
4663         assertFalse(sm.isSelected(0));
4664         assertTrue(sm.isSelected(1));
4665         assertFalse(sm.isSelected(2));
4666 
4667         // removing items
4668         List&lt;TreeItem&lt;String&gt;&gt; itemsToRemove = new ArrayList&lt;&gt;(indicesToRemove.length);
4669         for (int index : indicesToRemove) {
4670             itemsToRemove.add(root.getChildren().get(index));
4671         }
4672         root.getChildren().removeAll(itemsToRemove);
4673 
4674         // testing against expectations
4675         assertEquals(expectedIndex, sm.getSelectedIndex());
4676         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
4677         assertEquals(expectedItem, sm.getSelectedItem().getValue());
4678         assertEquals(expectedItem, sm.getSelectedItems().get(0).getValue());
4679     }
4680 
4681     private int rt_38341_indices_count = 0;
4682     private int rt_38341_items_count = 0;
4683     @Test public void test_rt_38341() {
4684         Callback&lt;Integer, TreeItem&lt;String&gt;&gt; callback = number -&gt; {
4685             final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root &quot; + number);
4686             final TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;Child &quot; + number);
4687 
4688             root.getChildren().add(child);
4689             return root;
4690         };
4691 
4692         final TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;();
4693         root.setExpanded(true);
4694         root.getChildren().addAll(callback.call(1), callback.call(2));
4695 
4696         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4697         treeTableView.setShowRoot(false);
4698 
4699         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4700         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4701         treeTableView.getColumns().add(column);
4702 
4703         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4704         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
4705         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; rt_38341_items_count++);
4706 
4707         assertEquals(0, rt_38341_indices_count);
4708         assertEquals(0, rt_38341_items_count);
4709 
4710         // expand the first child of root, and select it (note: root isn&#39;t visible)
4711         root.getChildren().get(0).setExpanded(true);
4712         sm.select(1);
4713         assertEquals(1, sm.getSelectedIndex());
4714         assertEquals(1, sm.getSelectedIndices().size());
4715         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4716         assertEquals(1, sm.getSelectedItems().size());
4717         assertEquals(&quot;Child 1&quot;, sm.getSelectedItem().getValue());
4718         assertEquals(&quot;Child 1&quot;, sm.getSelectedItems().get(0).getValue());
4719 
4720         assertEquals(1, rt_38341_indices_count);
4721         assertEquals(1, rt_38341_items_count);
4722 
4723         // now delete it
4724         root.getChildren().get(0).getChildren().remove(0);
4725 
4726         // selection should move to the childs parent in index 0
4727         assertEquals(0, sm.getSelectedIndex());
4728         assertEquals(1, sm.getSelectedIndices().size());
4729         assertEquals(0, (int)sm.getSelectedIndices().get(0));
4730         assertEquals(1, sm.getSelectedItems().size());
4731         assertEquals(&quot;Root 1&quot;, sm.getSelectedItem().getValue());
4732         assertEquals(&quot;Root 1&quot;, sm.getSelectedItems().get(0).getValue());
4733 
4734         // we also expect there to be an event in the selection model for
4735         // selected indices and selected items
4736         assertEquals(2, rt_38341_indices_count);
4737         assertEquals(2, rt_38341_items_count);
4738     }
4739 
4740     private int rt_38943_index_count = 0;
4741     private int rt_38943_item_count = 0;
4742     @Test public void test_rt_38943() {
4743         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4744         root.setExpanded(true);
4745         root.getChildren().addAll(
4746             new TreeItem&lt;&gt;(&quot;a&quot;),
4747             new TreeItem&lt;&gt;(&quot;b&quot;),
4748             new TreeItem&lt;&gt;(&quot;c&quot;),
4749             new TreeItem&lt;&gt;(&quot;d&quot;)
4750         );
4751 
4752         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4753         stringTreeTableView.setShowRoot(false);
4754 
4755         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4756         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4757         stringTreeTableView.getColumns().add(column);
4758 
4759         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4760 
4761         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
4762         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
4763 
4764         assertEquals(-1, sm.getSelectedIndex());
4765         assertNull(sm.getSelectedItem());
4766         assertEquals(0, rt_38943_index_count);
4767         assertEquals(0, rt_38943_item_count);
4768 
4769         sm.select(0);
4770         assertEquals(0, sm.getSelectedIndex());
4771         assertEquals(&quot;a&quot;, sm.getSelectedItem().getValue());
4772         assertEquals(1, rt_38943_index_count);
4773         assertEquals(1, rt_38943_item_count);
4774 
4775         sm.clearSelection(0);
4776         assertEquals(-1, sm.getSelectedIndex());
4777         assertNull(sm.getSelectedItem());
4778         assertEquals(2, rt_38943_index_count);
4779         assertEquals(2, rt_38943_item_count);
4780     }
4781 
4782     @Test public void test_rt_38884() {
4783         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4784         final TreeItem&lt;String&gt; foo = new TreeItem&lt;&gt;(&quot;foo&quot;);
4785 
4786         TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
4787         treeView.setShowRoot(false);
4788         root.setExpanded(true);
4789 
4790         treeView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4791             while (c.next()) {
4792                 if (c.wasRemoved()) {
4793                     assertTrue(c.getRemovedSize() &gt; 0);
4794 
4795                     List&lt;? extends TreeItem&lt;String&gt;&gt; removed = c.getRemoved();
4796                     TreeItem&lt;String&gt; removedItem = null;
4797                     try {
4798                         removedItem = removed.get(0);
4799                     } catch (Exception e) {
4800                         fail();
4801                     }
4802 
4803                     assertEquals(foo, removedItem);
4804                 }
4805             }
4806         });
4807 
4808         root.getChildren().add(foo);
4809         treeView.getSelectionModel().select(0);
4810         root.getChildren().clear();
4811     }
4812 
4813     private int rt_37360_add_count = 0;
4814     private int rt_37360_remove_count = 0;
4815     @Test public void test_rt_37360() {
4816         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4817         root.setExpanded(true);
4818         root.getChildren().addAll(
4819                 new TreeItem&lt;&gt;(&quot;a&quot;),
4820                 new TreeItem&lt;&gt;(&quot;b&quot;)
4821         );
4822 
4823         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4824         stringTreeTableView.setShowRoot(false);
4825 
4826         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4827         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4828         stringTreeTableView.getColumns().add(column);
4829 
4830         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4831         sm.setSelectionMode(SelectionMode.MULTIPLE);
4832         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
4833             while (c.next()) {
4834                 if (c.wasAdded()) {
4835                     rt_37360_add_count += c.getAddedSize();
4836                 }
4837                 if (c.wasRemoved()) {
4838                     rt_37360_remove_count += c.getRemovedSize();
4839                 }
4840             }
4841         });
4842 
4843         assertEquals(0, sm.getSelectedItems().size());
4844         assertEquals(0, rt_37360_add_count);
4845         assertEquals(0, rt_37360_remove_count);
4846 
4847         sm.select(0);
4848         assertEquals(1, sm.getSelectedItems().size());
4849         assertEquals(1, rt_37360_add_count);
4850         assertEquals(0, rt_37360_remove_count);
4851 
4852         sm.select(1);
4853         assertEquals(2, sm.getSelectedItems().size());
4854         assertEquals(2, rt_37360_add_count);
4855         assertEquals(0, rt_37360_remove_count);
4856 
4857         sm.clearAndSelect(1);
4858         assertEquals(1, sm.getSelectedItems().size());
4859         assertEquals(2, rt_37360_add_count);
4860         assertEquals(1, rt_37360_remove_count);
4861     }
4862 
4863     private int rt_37366_count = 0;
4864     @Test public void test_rt_37366() {
4865         final TreeItem&lt;String&gt; treeItem2 = new TreeItem&lt;&gt;(&quot;Item 2&quot;);
4866         treeItem2.getChildren().addAll(new TreeItem&lt;&gt;(&quot;Item 21&quot;), new TreeItem&lt;&gt;(&quot;Item 22&quot;));
4867 
4868         final TreeItem&lt;String&gt; root1 = new TreeItem&lt;&gt;(&quot;Root Node 1&quot;);
4869         TreeItem&lt;String&gt; treeItem1 = new TreeItem&lt;&gt;(&quot;Item 1&quot;);
4870         root1.getChildren().addAll(treeItem1, treeItem2, new TreeItem&lt;&gt;(&quot;Item 3&quot;));
4871         root1.setExpanded(true);
4872 
4873         final TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root Node 2&quot;);
4874 
4875         final TreeItem&lt;String&gt; hiddenRoot = new TreeItem&lt;&gt;(&quot;Hidden Root Node&quot;);
4876         hiddenRoot.getChildren().add(root1);
4877         hiddenRoot.getChildren().add(root2);
4878 
4879         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(hiddenRoot);
4880         treeView.setShowRoot(false);
4881 
4882         AtomicInteger step = new AtomicInteger();
4883         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeView.getSelectionModel();
4884         sm.setSelectionMode(SelectionMode.MULTIPLE);
4885         sm.getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4886             switch (step.get()) {
4887                 case 0: {
4888                     // we expect treeItem1 to be the only item added
4889                     while (c.next()) {
4890                         assertFalse(c.wasRemoved());
4891                         assertTrue(c.wasAdded());
4892                         assertEquals(1, c.getAddedSize());
4893                         assertTrue(c.getAddedSubList().contains(treeItem1));
4894                     }
4895                     break;
4896                 }
4897                 case 1: {
4898                     // we expect treeItem2 to be the only item added
4899                     while (c.next()) {
4900                         assertFalse(c.wasRemoved());
4901                         assertTrue(c.wasAdded());
4902                         assertEquals(1, c.getAddedSize());
4903                         assertTrue(c.getAddedSubList().contains(treeItem2));
4904                     }
4905                     break;
4906                 }
4907                 case 2: {
4908                     // we expect treeItem1 and treeItem2 to be removed in one separate event,
4909                     // and then we expect a separate event for root1 to be added. Therefore,
4910                     // once the remove event is received, we will increment the step to test for
4911                     // the addition
4912                     boolean wasRemoved = false;
4913                     while (c.next()) {
4914                         if (c.wasAdded()) {
4915                             fail(&quot;no addition expected yet&quot;);
4916                         }
4917                         if (c.wasRemoved()) {
4918                             assertTrue(c.getRemoved().containsAll(FXCollections.observableArrayList(treeItem1, treeItem2)));
4919                             wasRemoved = true;
4920                         }
4921                     }
4922                     if (!wasRemoved) {
4923                         fail(&quot;Expected a remove operation&quot;);
4924                     }
4925                     step.incrementAndGet();
4926                     break;
4927                 }
4928                 case 3: {
4929                     boolean wasAdded = false;
4930                     while (c.next()) {
4931                         if (c.wasAdded()) {
4932                             assertEquals(1, c.getAddedSize());
4933                             assertTrue(c.getAddedSubList().contains(root1));
4934                             wasAdded = true;
4935                         }
4936                         if (c.wasRemoved()) {
4937                             fail(&quot;no removal expected now&quot;);
4938                         }
4939                     }
4940                     if (!wasAdded) {
4941                         fail(&quot;Expected an add operation&quot;);
4942                     }
4943                     break;
4944                 }
4945             }
4946             rt_37366_count++;
4947         });
4948 
4949         assertEquals(0, rt_37366_count);
4950 
4951         step.set(0);
4952         sm.select(1); // select &quot;Item 1&quot;
4953         assertEquals(1, rt_37366_count);
4954         assertFalse(sm.isSelected(0));
4955         assertTrue(sm.isSelected(1));
4956         assertFalse(sm.isSelected(2));
4957 
4958         step.set(1);
4959         sm.select(2); // select &quot;Item 2&quot;
4960         assertEquals(2, rt_37366_count);
4961         assertFalse(sm.isSelected(0));
4962         assertTrue(sm.isSelected(1));
4963         assertTrue(sm.isSelected(2));
4964 
4965         step.set(2);
4966         root1.setExpanded(false); // collapse &quot;Root Node 1&quot; and deselect the two children, moving selection up to &quot;Root Node 1&quot;
4967         assertEquals(4, rt_37366_count);
4968         assertTrue(sm.isSelected(0));
4969         assertFalse(sm.isSelected(1));
4970         assertFalse(sm.isSelected(2));
4971     }
4972 
4973     @Test public void test_rt_38491() {
4974         TreeItem&lt;String&gt; a;
4975         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4976         root.setExpanded(true);
4977         root.getChildren().addAll(
4978                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4979                 new TreeItem&lt;&gt;(&quot;b&quot;)
4980         );
4981 
4982         TreeTableView&lt;String&gt; stringTreeView = new TreeTableView&lt;&gt;(root);
4983         stringTreeView.setShowRoot(false);
4984 
4985         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4986         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4987         stringTreeView.getColumns().add(column);
4988 
4989         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeView.getSelectionModel();
4990         sm.setSelectionMode(SelectionMode.MULTIPLE);
4991 
4992         TreeTableViewFocusModel&lt;String&gt; fm = stringTreeView.getFocusModel();
4993 
4994         StageLoader sl = new StageLoader(stringTreeView);
4995 
4996         // test pre-conditions
4997         assertTrue(sm.isEmpty());
4998         assertEquals(a, fm.getFocusedItem());
4999         assertEquals(0, fm.getFocusedIndex());
5000 
5001         // click on row 0
5002 //        VirtualFlowTestUtils.clickOnRow(stringTreeView, 0);
5003         sm.select(0, column);
5004         assertTrue(sm.isSelected(0));
5005         assertEquals(a, sm.getSelectedItem());
5006         assertTrue(fm.isFocused(0));
5007         assertEquals(a, fm.getFocusedItem());
5008         assertEquals(0, fm.getFocusedIndex());
5009         assertEquals(0, fm.getFocusedCell().getRow());
5010         assertEquals(column, fm.getFocusedCell().getTableColumn());
5011 
5012         TreeTablePosition&lt;String, ?&gt; anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
5013         assertNotNull(anchor);
5014         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
5015         assertEquals(0, anchor.getRow());
5016 
5017         // now add a new item at row 0. This has the effect of pushing down
5018         // the selected item into row 1.
5019         root.getChildren().add(0, new TreeItem(&quot;z&quot;));
5020 
5021         // The first bug was that selection and focus were not moving down to
5022         // be on row 1, so we test that now
5023         assertFalse(sm.isSelected(0));
5024         assertFalse(fm.isFocused(0));
5025         assertTrue(sm.isSelected(1));
5026         assertEquals(a, sm.getSelectedItem());
5027         assertTrue(fm.isFocused(1));
5028         assertEquals(a, fm.getFocusedItem());
5029         assertEquals(1, fm.getFocusedIndex());
5030         assertEquals(1, fm.getFocusedCell().getRow());
5031         assertEquals(column, fm.getFocusedCell().getTableColumn());
5032 
5033         // The second bug was that the anchor was not being pushed down as well
5034         // (when it should).
5035         anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
5036         assertNotNull(anchor);
5037         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
5038         assertEquals(1, anchor.getRow());
5039         assertEquals(column, anchor.getTableColumn());
5040 
5041         sl.dispose();
5042     }
5043 
5044     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39256_list = FXCollections.observableArrayList();
5045     @Test public void test_rt_39256() {
5046         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5047         root.setExpanded(true);
5048         root.getChildren().addAll(
5049                 new TreeItem&lt;&gt;(&quot;a&quot;),
5050                 new TreeItem&lt;&gt;(&quot;b&quot;),
5051                 new TreeItem&lt;&gt;(&quot;c&quot;),
5052                 new TreeItem&lt;&gt;(&quot;d&quot;)
5053         );
5054 
5055         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5056         stringTreeTableView.setShowRoot(false);
5057 
5058         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5059         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5060         stringTreeTableView.getColumns().add(column);
5061 
5062         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
5063         sm.setSelectionMode(SelectionMode.MULTIPLE);
5064 
5065 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5066 //            while (change.next()) {
5067 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5068 //            }
5069 //        });
5070 
5071         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
5072 
5073         assertEquals(0, sm.getSelectedItems().size());
5074         assertEquals(0, rt_39256_list.size());
5075 
5076         sm.selectAll();
5077         assertEquals(4, sm.getSelectedItems().size());
5078         assertEquals(4, rt_39256_list.size());
5079 
5080         sm.selectAll();
5081         assertEquals(4, sm.getSelectedItems().size());
5082         assertEquals(4, rt_39256_list.size());
5083 
5084         sm.selectAll();
5085         assertEquals(4, sm.getSelectedItems().size());
5086         assertEquals(4, rt_39256_list.size());
5087     }
5088 
5089     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39482_list = FXCollections.observableArrayList();
5090     @Test public void test_rt_39482() {
5091         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5092         root.setExpanded(true);
5093         root.getChildren().addAll(
5094                 new TreeItem&lt;&gt;(&quot;a&quot;),
5095                 new TreeItem&lt;&gt;(&quot;b&quot;),
5096                 new TreeItem&lt;&gt;(&quot;c&quot;),
5097                 new TreeItem&lt;&gt;(&quot;d&quot;)
5098         );
5099 
5100         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5101         stringTreeTableView.setShowRoot(false);
5102 
5103         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5104         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5105         stringTreeTableView.getColumns().add(column);
5106 
5107         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5108         sm.setSelectionMode(SelectionMode.MULTIPLE);
5109 
5110 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
5111 //            while (change.next()) {
5112 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
5113 //            }
5114 //        });
5115 
5116         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
5117 
5118         assertEquals(0, sm.getSelectedItems().size());
5119         assertEquals(0, rt_39482_list.size());
5120 
5121         test_rt_39482_selectRow(&quot;a&quot;, sm, 0, column);
5122         test_rt_39482_selectRow(&quot;b&quot;, sm, 1, column);
5123         test_rt_39482_selectRow(&quot;c&quot;, sm, 2, column);
5124         test_rt_39482_selectRow(&quot;d&quot;, sm, 3, column);
5125     }
5126 
5127     private void test_rt_39482_selectRow(String expectedString,
5128                                          TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm,
5129                                          int rowToSelect,
5130                                          TreeTableColumn&lt;String,String&gt; columnToSelect) {
5131         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
5132         sm.selectAll();
5133         assertEquals(4, sm.getSelectedCells().size());
5134         assertEquals(4, sm.getSelectedIndices().size());
5135         assertEquals(4, sm.getSelectedItems().size());
5136         assertEquals(4, rt_39482_list.size());
5137 
5138         sm.clearAndSelect(rowToSelect, columnToSelect);
5139         assertEquals(1, sm.getSelectedCells().size());
5140         assertEquals(1, sm.getSelectedIndices().size());
5141         assertEquals(1, sm.getSelectedItems().size());
5142         assertEquals(expectedString, sm.getSelectedItem().getValue());
5143         assertEquals(expectedString, rt_39482_list.get(0).getValue());
5144         assertEquals(1, rt_39482_list.size());
5145     }
5146 
5147     @Test public void test_rt_39559_useSM_selectAll() {
5148         test_rt_39559(true);
5149     }
5150 
5151     @Test public void test_rt_39559_useKeyboard_selectAll() {
5152         test_rt_39559(false);
5153     }
5154 
5155     private void test_rt_39559(boolean useSMSelectAll) {
5156         TreeItem&lt;String&gt; a, b;
5157         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5158         root.setExpanded(true);
5159         root.getChildren().addAll(
5160                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
5161                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5162                 new TreeItem&lt;&gt;(&quot;c&quot;),
5163                 new TreeItem&lt;&gt;(&quot;d&quot;)
5164         );
5165 
5166         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5167         stringTreeTableView.setShowRoot(false);
5168 
5169         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5170         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5171         stringTreeTableView.getColumns().add(column);
5172 
5173         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5174         sm.setSelectionMode(SelectionMode.MULTIPLE);
5175 
5176         StageLoader sl = new StageLoader(stringTreeTableView);
5177         KeyEventFirer keyboard = new KeyEventFirer(stringTreeTableView);
5178 
5179         assertEquals(0, sm.getSelectedItems().size());
5180 
5181         sm.clearAndSelect(0);
5182 
5183         if (useSMSelectAll) {
5184             sm.selectAll();
5185         } else {
5186             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
5187         }
5188 
5189         assertEquals(4, sm.getSelectedItems().size());
5190         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5191 
5192         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
5193 
5194         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5195         assertEquals(2, sm.getSelectedItems().size());
5196         assertEquals(a, sm.getSelectedItems().get(0));
5197         assertEquals(b, sm.getSelectedItems().get(1));
5198 
5199         sl.dispose();
5200     }
5201 
5202     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
5203         // select and then remove the &#39;a&#39; item, selection and focus should both
5204         // stay at the first row, now &#39;b&#39;
5205         test_rt_16068(0, 0, 0);
5206     }
5207 
5208     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
5209         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
5210         test_rt_16068(0, 2, 0);
5211     }
5212 
5213     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
5214         // select and then remove the &#39;b&#39; item, selection and focus should both
5215         // move up one row to the &#39;a&#39; item
5216         test_rt_16068(1, 1, 0);
5217     }
5218 
5219     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
5220         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
5221         test_rt_16068(1, 2, 1);
5222     }
5223 
5224     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
5225         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
5226         // one row, remaining on &#39;b&#39;
5227         test_rt_16068(1, 0, 0);
5228     }
5229 
5230     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
5231         // select and then remove the &#39;d&#39; item, selection and focus should both
5232         // move up one row to the &#39;c&#39; item
5233         test_rt_16068(3, 3, 2);
5234     }
5235 
5236     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
5237         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
5238         // one row, remaining on &#39;d&#39;
5239         test_rt_16068(3, 0, 2);
5240     }
5241 
5242     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
5243         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5244         root.setExpanded(true);
5245         root.getChildren().addAll(
5246                 new TreeItem&lt;&gt;(&quot;a&quot;), // 0
5247                 new TreeItem&lt;&gt;(&quot;b&quot;), // 1
5248                 new TreeItem&lt;&gt;(&quot;c&quot;), // 2
5249                 new TreeItem&lt;&gt;(&quot;d&quot;)  // 3
5250         );
5251 
5252         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5253         stringTreeTableView.setShowRoot(false);
5254 
5255         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5256         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5257         stringTreeTableView.getColumns().add(column);
5258 
5259         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5260         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = stringTreeTableView.getFocusModel();
5261 
5262         sm.select(indexToSelect);
5263         assertEquals(indexToSelect, sm.getSelectedIndex());
5264         assertEquals(root.getChildren().get(indexToSelect).getValue(), sm.getSelectedItem().getValue());
5265         assertEquals(indexToSelect, fm.getFocusedIndex());
5266         assertEquals(root.getChildren().get(indexToSelect).getValue(), fm.getFocusedItem().getValue());
5267 
5268         root.getChildren().remove(indexToRemove);
5269         assertEquals(expectedIndex, sm.getSelectedIndex());
5270         assertEquals(root.getChildren().get(expectedIndex).getValue(), sm.getSelectedItem().getValue());
5271         assertEquals(debug(), expectedIndex, fm.getFocusedIndex());
5272         assertEquals(root.getChildren().get(expectedIndex).getValue(), fm.getFocusedItem().getValue());
5273     }
5274 
5275     @Test public void test_rt_39675() {
5276         TreeItem&lt;String&gt; b;
5277         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5278         root.setExpanded(true);
5279         root.getChildren().addAll(
5280                 new TreeItem&lt;&gt;(&quot;a&quot;),
5281                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5282                 new TreeItem&lt;&gt;(&quot;c&quot;),
5283                 new TreeItem&lt;&gt;(&quot;d&quot;)
5284         );
5285 
5286         b.setExpanded(true);
5287         b.getChildren().addAll(
5288                 new TreeItem&lt;&gt;(&quot;b1&quot;),
5289                 new TreeItem&lt;&gt;(&quot;b2&quot;),
5290                 new TreeItem&lt;&gt;(&quot;b3&quot;),
5291                 new TreeItem&lt;&gt;(&quot;b4&quot;)
5292         );
5293 
5294         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5295 
5296         TreeTableColumn&lt;String,String&gt; column0 = new TreeTableColumn&lt;&gt;(&quot;Column1&quot;);
5297         column0.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5298 
5299         TreeTableColumn&lt;String,String&gt; column1 = new TreeTableColumn&lt;&gt;(&quot;Column2&quot;);
5300         column1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5301 
5302         TreeTableColumn&lt;String,String&gt; column2 = new TreeTableColumn&lt;&gt;(&quot;Column3&quot;);
5303         column2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5304 
5305         stringTreeTableView.getColumns().addAll(column0, column1, column2);
5306 
5307         sm = stringTreeTableView.getSelectionModel();
5308         sm.setSelectionMode(SelectionMode.SINGLE);
5309         sm.setCellSelectionEnabled(true);
5310 
5311         StageLoader sl = new StageLoader(stringTreeTableView);
5312 
5313         assertEquals(0, sm.getSelectedItems().size());
5314 
5315         sm.clearAndSelect(4, column0);  // select &#39;b2&#39; in row 4, column 0
5316         assertTrue(sm.isSelected(4, column0));
5317         assertEquals(1, sm.getSelectedCells().size());
5318         assertEquals(&quot;b2&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5319 
5320         // collapse the &#39;b&#39; tree item, selection and focus should go to
5321         // the &#39;b&#39; tree item in row 2, column 0
5322         b.setExpanded(false);
5323         assertTrue(sm.isSelected(2, column0));
5324         assertEquals(1, sm.getSelectedCells().size());
5325         assertEquals(&quot;b&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5326 
5327         sl.dispose();
5328     }
5329 
5330 
5331     private ObservableList&lt;String&gt; test_rt_39661_setup() {
5332         ObservableList&lt;String&gt;  rawItems = FXCollections.observableArrayList(
5333                 &quot;9-item&quot;, &quot;8-item&quot;, &quot;7-item&quot;, &quot;6-item&quot;,
5334                 &quot;5-item&quot;, &quot;4-item&quot;, &quot;3-item&quot;, &quot;2-item&quot;, &quot;1-item&quot;);
5335         root = createSubTree(&quot;root&quot;, rawItems);
5336         root.setExpanded(true);
5337         treeTableView = new TreeTableView(root);
5338         return rawItems;
5339     }
5340 
5341     private TreeItem createSubTree(Object item, ObservableList&lt;String&gt; rawItems) {
5342         TreeItem child = new TreeItem(item);
5343         child.getChildren().setAll(rawItems.stream()
5344                 .map(rawItem -&gt; new TreeItem(rawItem))
5345                 .collect(Collectors.toList()));
5346         return child;
5347     }
5348 
5349     @Test public void test_rt_39661_rowLessThanExpandedItemCount() {
5350         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5351         TreeItem child = createSubTree(&quot;child&quot;, rawItems);
5352         TreeItem grandChild = (TreeItem) child.getChildren().get(rawItems.size() - 1);
5353         root.getChildren().add(child);
5354         assertTrue(&quot;row of item must be less than expandedItemCount, but was: &quot; + treeTableView.getRow(grandChild),
5355                 treeTableView.getRow(grandChild) &lt; treeTableView.getExpandedItemCount());
5356     }
5357 
5358     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAbove() {
5359         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5360         int grandIndex = 2;
5361         int childIndex = 3;
5362 
5363         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5364         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5365         root.getChildren().add(childIndex, child);
5366 
5367         int rowOfGrand = treeTableView.getRow(grandChild);
5368         root.getChildren().add(childIndex - 1, createSubTree(&quot;other&quot;, rawItems));
5369 
5370         assertEquals(-1, treeTableView.getRow(grandChild));
5371     }
5372 
5373     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAboveWithoutAccess() {
5374         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5375         int grandIndex = 2;
5376         int childIndex = 3;
5377 
5378         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5379         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5380         root.getChildren().add(childIndex, child);
5381 
5382         int rowOfGrand = 7; //treeTableView.getRow(grandChild);
5383         root.getChildren().add(childIndex, createSubTree(&quot;other&quot;, rawItems));
5384 
5385         assertEquals(-1, treeTableView.getRow(grandChild));
5386     }
5387 
5388     @Test public void test_rt_39661_rowOfGrandChildParentExpandedUpdatedOnInsertAbove() {
5389         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5390         int grandIndex = 2;
5391         int childIndex = 3;
5392         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5393         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5394         child.setExpanded(true);
5395         root.getChildren().add(childIndex, child);
5396         int rowOfGrand = treeTableView.getRow(grandChild);
5397         root.getChildren().add(childIndex -1, createSubTree(&quot;other&quot;, rawItems));
5398         assertEquals(rowOfGrand + 1, treeTableView.getRow(grandChild));
5399     }
5400 
5401     /**
5402      * Testing getRow on grandChild: compare collapsed/expanded parent.
5403      */
5404     @Test public void test_rt_39661_rowOfGrandChildDependsOnParentExpansion() {
5405         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5406         int grandIndex = 2;
5407         int childIndex = 3;
5408 
5409         TreeItem collapsedChild = createSubTree(&quot;addedChild&quot;, rawItems);
5410         TreeItem collapsedGrandChild = (TreeItem) collapsedChild.getChildren().get(grandIndex);
5411         root.getChildren().add(childIndex, collapsedChild);
5412 
5413         int collapedGrandIndex = treeTableView.getRow(collapsedGrandChild);
5414         int collapsedRowCount = treeTableView.getExpandedItemCount();
5415 
5416         // start again
5417         test_rt_39661_setup();
5418         assertEquals(collapsedRowCount - 1, treeTableView.getExpandedItemCount());
5419         TreeItem expandedChild = createSubTree(&quot;addedChild2&quot;, rawItems);
5420         TreeItem expandedGrandChild = (TreeItem) expandedChild.getChildren().get(grandIndex);
5421         expandedChild.setExpanded(true);
5422 
5423         root.getChildren().add(childIndex, expandedChild);
5424         assertNotSame(&quot;getRow must depend on expansionState &quot; + collapedGrandIndex,
5425                 collapedGrandIndex, treeTableView.getRow(expandedGrandChild));
5426     }
5427 
5428     @Test public void test_rt_39661_rowOfGrandChildInCollapsedChild() {
5429         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5430 
5431         // create a collapsed new child to insert into the root
5432         TreeItem newChild = createSubTree(&quot;added-child&quot;, rawItems);
5433         TreeItem grandChild = (TreeItem) newChild.getChildren().get(2);
5434         root.getChildren().add(6, newChild);
5435 
5436         // query the row of a grand-child
5437         int row = treeTableView.getRow(grandChild);
5438 
5439         // grandChild not visible, row coordinate in tree is not available
5440         assertEquals(&quot;grandChild not visible&quot;, -1, row);
5441 
5442         // the other way round: if we get a row, expect the item at the row be the grandChild
5443         if (row &gt; -1) {
5444             assertEquals(grandChild, treeTableView.getTreeItem(row));
5445         }
5446     }
5447 
5448     @Test public void test_rt_39661_rowOfRootChild() {
5449         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5450         int index = 2;
5451 
5452         TreeItem child = (TreeItem) root.getChildren().get(index);
5453         assertEquals(index + 1, treeTableView.getRow(child));
5454     }
5455 
5456     @Test public void test_rt_39661_expandedItemCount() {
5457         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5458         int initialRowCount = treeTableView.getExpandedItemCount();
5459         assertEquals(root.getChildren().size() + 1, initialRowCount);
5460 
5461         TreeItem collapsedChild = createSubTree(&quot;collapsed-child&quot;, rawItems);
5462         root.getChildren().add(collapsedChild);
5463         assertEquals(initialRowCount + 1, treeTableView.getExpandedItemCount());
5464 
5465         TreeItem expandedChild = createSubTree(&quot;expanded-child&quot;, rawItems);
5466         expandedChild.setExpanded(true);
5467         root.getChildren().add(0, expandedChild);
5468         assertEquals(2 * initialRowCount + 1, treeTableView.getExpandedItemCount());
5469     }
5470 
5471     private int test_rt_39822_count = 0;
5472     @Test public void test_rt_39822() {
5473         // get the current exception handler before replacing with our own,
5474         // as ListListenerHelp intercepts the exception otherwise
5475         final Thread.UncaughtExceptionHandler exceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();
5476         Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; {
5477 
5478             if (test_rt_39822_count == 0) {
5479                 test_rt_39822_count++;
5480                 if (! (e instanceof IllegalStateException)) {
5481                     e.printStackTrace();
5482                     fail(&quot;Expected IllegalStateException, instead got &quot; + e);
5483                 }
5484             } else {
5485                 // don&#39;t care
5486                 test_rt_39822_count++;
5487             }
5488         });
5489 
5490         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
5491         TreeTableColumn&lt;String, String&gt; col1 = new TreeTableColumn&lt;&gt;(&quot;Foo&quot;);
5492         table.getColumns().addAll(col1, col1);  // add column twice
5493 
5494         StageLoader sl = null;
5495         try {
5496             sl = new StageLoader(table);
5497         } finally {
5498             if (sl != null) {
5499                 sl.dispose();
5500             }
5501 
5502             // reset the exception handler
5503             Thread.currentThread().setUncaughtExceptionHandler(exceptionHandler);
5504         }
5505     }
5506 
5507     private int test_rt_39842_count = 0;
5508     @Test public void test_rt_39842_selectLeftDown() {
5509         test_rt_39842(true, false);
5510     }
5511 
5512     @Test public void test_rt_39842_selectLeftUp() {
5513         test_rt_39842(true, true);
5514     }
5515 
5516     @Test public void test_rt_39842_selectRightDown() {
5517         test_rt_39842(false, false);
5518     }
5519 
5520     @Test public void test_rt_39842_selectRightUp() {
5521         test_rt_39842(false, true);
5522     }
5523 
5524     private void test_rt_39842(boolean selectToLeft, boolean selectUpwards) {
5525         test_rt_39842_count = 0;
5526 
5527         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
5528         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
5529 
5530         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
5531         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
5532 
5533         TreeItem root = new TreeItem(&quot;root&quot;);
5534         root.getChildren().setAll(
5535                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
5536                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
5537                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
5538                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
5539                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
5540         root.setExpanded(true);
5541 
5542         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;(root);
5543         table.setShowRoot(false);
5544         table.getColumns().addAll(firstNameCol, lastNameCol);
5545 
5546         sm = table.getSelectionModel();
5547         sm.setCellSelectionEnabled(true);
5548         sm.setSelectionMode(SelectionMode.MULTIPLE);
5549         sm.getSelectedCells().addListener((ListChangeListener) c -&gt; test_rt_39842_count++);
5550 
5551         StageLoader sl = new StageLoader(table);
5552 
5553         assertEquals(0, test_rt_39842_count);
5554 
5555         if (selectToLeft) {
5556             if (selectUpwards) {
5557                 sm.selectRange(3, lastNameCol, 0, firstNameCol);
5558             } else {
5559                 sm.selectRange(0, lastNameCol, 3, firstNameCol);
5560             }
5561         } else {
5562             if (selectUpwards) {
5563                 sm.selectRange(3, firstNameCol, 0, lastNameCol);
5564             } else {
5565                 sm.selectRange(0, firstNameCol, 3, lastNameCol);
5566             }
5567         }
5568 
5569         // test model state
5570         assertEquals(8, sm.getSelectedCells().size());
5571         assertEquals(1, test_rt_39842_count);
5572 
5573         // test visual state
5574         for (int row = 0; row &lt;= 3; row++) {
5575             for (int column = 0; column &lt;= 1; column++) {
5576                 IndexedCell cell = VirtualFlowTestUtils.getCell(table, row, column);
5577                 assertTrue(cell.isSelected());
5578             }
5579         }
5580 
5581         sl.dispose();
5582     }
5583 
5584     @Test public void test_rt_22599() {
5585         TreeItem&lt;RT22599_DataType&gt; root = new TreeItem&lt;&gt;();
5586         root.getChildren().setAll(
5587                 new TreeItem&lt;&gt;(new RT22599_DataType(1, &quot;row1&quot;)),
5588                 new TreeItem&lt;&gt;(new RT22599_DataType(2, &quot;row2&quot;)),
5589                 new TreeItem&lt;&gt;(new RT22599_DataType(3, &quot;row3&quot;)));
5590         root.setExpanded(true);
5591 
5592         TreeTableColumn&lt;RT22599_DataType, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Header&quot;);
5593         col.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue().text));
5594 
5595         TreeTableView&lt;RT22599_DataType&gt; table = new TreeTableView&lt;&gt;(root);
5596         table.setShowRoot(false);
5597         table.getColumns().addAll(col);
5598 
5599         StageLoader sl = new StageLoader(table);
5600 
5601         // testing initial state
5602         assertNotNull(table.getSkin());
5603         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5604         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(table, 1, 0).getText());
5605         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(table, 2, 0).getText());
5606 
5607         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
5608         // Because &#39;set&#39; is called, the control should update to the new content
5609         // without any user interaction
5610         TreeItem&lt;RT22599_DataType&gt; data;
5611         root.getChildren().set(0, data = new TreeItem&lt;&gt;(new RT22599_DataType(0, &quot;row1a&quot;)));
5612         Toolkit.getToolkit().firePulse();
5613         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5614 
5615         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
5616         // Because there is no associated property, this won&#39;t be observed, so
5617         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
5618         data.getValue().text = &quot;row1b&quot;;
5619         Toolkit.getToolkit().firePulse();
5620         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5621 
5622         // call refresh() to force a refresh of all visible cells
5623         table.refresh();
5624         Toolkit.getToolkit().firePulse();
5625         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5626 
5627         sl.dispose();
5628     }
5629 
5630     private static class RT22599_DataType {
5631         public int id = 0;
5632         public String text = &quot;&quot;;
5633 
5634         public RT22599_DataType(int id, String text) {
5635             this.id = id;
5636             this.text = text;
5637         }
5638 
5639         @Override public boolean equals(Object obj) {
5640             if (obj == null) return false;
5641             return id == ((RT22599_DataType)obj).id;
5642         }
5643     }
5644 
5645     private int rt_39966_count = 0;
5646     @Test public void test_rt_39966() {
5647         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5648         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;(root);
5649         table.setShowRoot(true);
5650 
5651         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5652         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5653         table.getColumns().add(column);
5654 
5655         StageLoader sl = new StageLoader(table);
5656 
5657         // initially there is no selection
5658         assertTrue(table.getSelectionModel().isEmpty());
5659 
5660         table.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
5661             if (rt_39966_count == 0) {
5662                 rt_39966_count++;
5663                 assertFalse(table.getSelectionModel().isEmpty());
5664             } else {
5665                 assertTrue(table.getSelectionModel().isEmpty());
5666             }
5667         });
5668 
5669         // our assertion two lines down always succeeds. What fails is our
5670         // assertion above within the listener.
5671         table.getSelectionModel().select(0);
5672         assertFalse(table.getSelectionModel().isEmpty());
5673 
5674         table.setRoot(null);
5675         assertTrue(table.getSelectionModel().isEmpty());
5676 
5677         sl.dispose();
5678     }
5679 
5680     /**
5681      * Bullet 1: selected index must be updated
5682      * Corner case: last selected. Fails for core
5683      */
5684     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
5685         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5686         root.setExpanded(true);
5687         root.getChildren().addAll(
5688             new TreeItem&lt;&gt;(&quot;0&quot;),
5689             new TreeItem&lt;&gt;(&quot;1&quot;),
5690             new TreeItem&lt;&gt;(&quot;2&quot;),
5691             new TreeItem&lt;&gt;(&quot;3&quot;),
5692             new TreeItem&lt;&gt;(&quot;4&quot;),
5693             new TreeItem&lt;&gt;(&quot;5&quot;)
5694         );
5695 
5696         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5697         stringTreeTableView.setShowRoot(false);
5698         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5699 
5700         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5701         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5702         stringTreeTableView.getColumns().add(column);
5703 
5704         int last = root.getChildren().size() - 1;
5705 
5706         // selecting item &quot;5&quot;
5707         sm.select(last);
5708 
5709         // disjoint remove of 2 elements above the last selected
5710         // Removing &quot;1&quot; and &quot;3&quot;
5711         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5712 
5713         // selection should move up two places such that it remains on item &quot;5&quot;,
5714         // but in index (last - 2).
5715         int expected = last - 2;
5716         assertEquals(&quot;5&quot;, sm.getSelectedItem().getValue());
5717         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
5718     }
5719 
5720     /**
5721      * Variant of 1: if selectedIndex is not updated,
5722      * the old index is no longer valid
5723      * for accessing the items.
5724      */
5725     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
5726         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5727         root.setExpanded(true);
5728         root.getChildren().addAll(
5729                 new TreeItem&lt;&gt;(&quot;0&quot;),
5730                 new TreeItem&lt;&gt;(&quot;1&quot;),
5731                 new TreeItem&lt;&gt;(&quot;2&quot;),
5732                 new TreeItem&lt;&gt;(&quot;3&quot;),
5733                 new TreeItem&lt;&gt;(&quot;4&quot;),
5734                 new TreeItem&lt;&gt;(&quot;5&quot;)
5735         );
5736 
5737         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5738         stringTreeTableView.setShowRoot(false);
5739         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5740 
5741         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5742         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5743         stringTreeTableView.getColumns().add(column);
5744 
5745         int last = root.getChildren().size() - 1;
5746 
5747         // selecting item &quot;5&quot;
5748         sm.select(last);
5749 
5750         // disjoint remove of 2 elements above the last selected
5751         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5752         int selected = sm.getSelectedIndex();
5753         if (selected &gt; -1) {
5754             root.getChildren().get(selected);
5755         }
5756     }
5757 
5758     /**
5759      * Bullet 2: selectedIndex notification count
5760      *
5761      * Note that we don&#39;t use the corner case of having the last index selected
5762      * (which fails already on updating the index)
5763      */
5764     private int rt_40012_count = 0;
5765     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
5766         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5767         root.setExpanded(true);
5768         root.getChildren().addAll(
5769                 new TreeItem&lt;&gt;(&quot;0&quot;),
5770                 new TreeItem&lt;&gt;(&quot;1&quot;),
5771                 new TreeItem&lt;&gt;(&quot;2&quot;),
5772                 new TreeItem&lt;&gt;(&quot;3&quot;),
5773                 new TreeItem&lt;&gt;(&quot;4&quot;),
5774                 new TreeItem&lt;&gt;(&quot;5&quot;)
5775         );
5776 
5777         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5778         stringTreeTableView.setShowRoot(false);
5779         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5780 
5781         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5782         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5783         stringTreeTableView.getColumns().add(column);
5784 
5785         int last = root.getChildren().size() - 2;
5786         sm.select(last);
5787         assertEquals(last, sm.getSelectedIndex());
5788 
5789         rt_40012_count = 0;
5790         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
5791 
5792         // disjoint remove of 2 elements above the last selected
5793         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5794         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
5795         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
5796     }
5797 
5798     /**
5799      * Bullet 3: unchanged selectedItem must not fire change
5800      */
5801     @Test
5802     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
5803         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5804         root.setExpanded(true);
5805         root.getChildren().addAll(
5806                 new TreeItem&lt;&gt;(&quot;0&quot;),
5807                 new TreeItem&lt;&gt;(&quot;1&quot;),
5808                 new TreeItem&lt;&gt;(&quot;2&quot;),
5809                 new TreeItem&lt;&gt;(&quot;3&quot;),
5810                 new TreeItem&lt;&gt;(&quot;4&quot;),
5811                 new TreeItem&lt;&gt;(&quot;5&quot;)
5812         );
5813 
5814         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5815         stringTreeTableView.setShowRoot(false);
5816         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5817 
5818         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5819         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5820         stringTreeTableView.getColumns().add(column);
5821 
5822         int last = root.getChildren().size() - 2;
5823         Object lastItem = root.getChildren().get(last);
5824         sm.select(last);
5825         assertEquals(lastItem, sm.getSelectedItem());
5826 
5827         rt_40012_count = 0;
5828         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
5829 
5830         // disjoint remove of 2 elements above the last selected
5831         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5832         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
5833         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
5834     }
5835 
5836     private int rt_40010_count = 0;
5837     @Test public void test_rt_40010() {
5838         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5839         TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;child&quot;);
5840         root.setExpanded(true);
5841         root.getChildren().addAll(child);
5842 
5843         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5844         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5845 
5846         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5847         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5848         stringTreeTableView.getColumns().add(column);
5849 
5850         sm.getSelectedIndices().addListener((ListChangeListener&lt;? super Integer&gt;) l -&gt; rt_40010_count++);
5851         sm.getSelectedItems().addListener((ListChangeListener&lt;? super TreeItem&lt;String&gt;&gt;) l -&gt; rt_40010_count++);
5852 
5853         assertEquals(0, rt_40010_count);
5854 
5855         sm.select(1);
5856         assertEquals(1, sm.getSelectedIndex());
5857         assertEquals(child, sm.getSelectedItem());
5858         assertEquals(2, rt_40010_count);
5859 
5860         root.getChildren().remove(child);
5861         assertEquals(0, sm.getSelectedIndex());
5862         assertEquals(root, sm.getSelectedItem());
5863         assertEquals(4, rt_40010_count);
5864     }
5865 
5866     /**
5867      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
5868      */
5869     private int rt_40212_count = 0;
5870     @Test public void test_rt_40212() {
5871         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5872         root.setExpanded(true);
5873         root.getChildren().addAll(
5874                 new TreeItem&lt;&gt;(&quot;0&quot;),
5875                 new TreeItem&lt;&gt;(&quot;1&quot;),
5876                 new TreeItem&lt;&gt;(&quot;2&quot;),
5877                 new TreeItem&lt;&gt;(&quot;3&quot;),
5878                 new TreeItem&lt;&gt;(&quot;4&quot;),
5879                 new TreeItem&lt;&gt;(&quot;5&quot;)
5880         );
5881 
5882         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5883         stringTreeTableView.setShowRoot(false);
5884 
5885         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5886         sm.setSelectionMode(SelectionMode.MULTIPLE);
5887 
5888         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5889         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5890         stringTreeTableView.getColumns().add(column);
5891 
5892         sm.selectRange(3, 5);
5893         int selected = sm.getSelectedIndex();
5894 
5895         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
5896             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
5897             while(change.next()) {
5898                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
5899 
5900                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
5901                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
5902             }
5903         });
5904 
5905         sm.clearAndSelect(selected);
5906     }
5907 
5908     @Test public void test_rt_40280() {
5909         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
5910         StageLoader sl = new StageLoader(view);
5911         MultipleSelectionModelBaseShim.getFocusedIndex(view.getSelectionModel());
5912         view.getFocusModel().getFocusedIndex();
5913         sl.dispose();
5914     }
5915 
5916     @Test public void test_rt_40278_showRoot() {
5917         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5918         root.setExpanded(true);
5919         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5920 
5921         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5922         view.setShowRoot(false);
5923         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5924 
5925         assertFalse(&quot;sanity: test setup such that root is not showing&quot;, view.isShowRoot());
5926         sm.select(0);
5927         assertEquals(0, sm.getSelectedIndex());
5928         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5929         view.setShowRoot(true);
5930         assertEquals(1, sm.getSelectedIndex());
5931         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5932     }
5933 
5934     @Test public void test_rt_40278_hideRoot_selectionOnChild() {
5935         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5936         root.setExpanded(true);
5937         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5938 
5939         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5940         view.setShowRoot(true);
5941         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5942 
5943         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5944         sm.select(1);
5945         assertEquals(1, sm.getSelectedIndex());
5946         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5947         view.setShowRoot(false);
5948         assertEquals(0, sm.getSelectedIndex());
5949         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5950     }
5951 
5952     @Test public void test_rt_40278_hideRoot_selectionOnRoot() {
5953         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5954         root.setExpanded(true);
5955         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5956 
5957         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5958         view.setShowRoot(true);
5959         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5960 
5961         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5962         sm.select(0);
5963         assertEquals(0, sm.getSelectedIndex());
5964         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5965         view.setShowRoot(false);
5966         assertEquals(0, sm.getSelectedIndex());
5967         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5968     }
5969 
5970     /**
5971      * Test list change of selectedIndices on setIndices. Fails for core ..
5972      */
5973     @Test public void test_rt_40263() {
5974         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(-1);
5975         root.setExpanded(true);
5976 
5977         for (int i = 0; i &lt; 10; i++) {
5978             root.getChildren().add(new TreeItem&lt;Integer&gt;(i));
5979         }
5980 
5981         final TreeTableView&lt;Integer&gt; view = new TreeTableView&lt;&gt;(root);
5982         TreeTableView.TreeTableViewSelectionModel&lt;Integer&gt; sm = view.getSelectionModel();
5983         sm.setSelectionMode(SelectionMode.MULTIPLE);
5984 
5985         int[] indices = new int[]{2, 5, 7};
5986         ListChangeListener&lt;Integer&gt; l = c -&gt; {
5987             // firstly, we expect only one change
5988             int subChanges = 0;
5989             while(c.next()) {
5990                 subChanges++;
5991             }
5992             assertEquals(1, subChanges);
5993 
5994             // secondly, we expect the added size to be three, as that is the
5995             // number of items selected
5996             c.reset();
5997             c.next();
5998             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
5999             assertEquals(indices.length, c.getAddedSize());
6000             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
6001         };
6002         sm.getSelectedIndices().addListener(l);
6003         sm.selectIndices(indices[0], indices);
6004     }
6005 
6006     @Test public void test_rt_40319_toRight_toBottom()          { test_rt_40319(true, true, false);   }
6007     @Test public void test_rt_40319_toRight_toTop()             { test_rt_40319(true, false, false);  }
6008     @Test public void test_rt_40319_toLeft_toBottom()           { test_rt_40319(false, true, false);  }
6009     @Test public void test_rt_40319_toLeft_toTop()              { test_rt_40319(false, false, false); }
6010     @Test public void test_rt_40319_toRight_toBottom_useMouse() { test_rt_40319(true, true, true);    }
6011     @Test public void test_rt_40319_toRight_toTop_useMouse()    { test_rt_40319(true, false, true);   }
6012     @Test public void test_rt_40319_toLeft_toBottom_useMouse()  { test_rt_40319(false, true, true);   }
6013     @Test public void test_rt_40319_toLeft_toTop_useMouse()     { test_rt_40319(false, false, true);  }
6014 
6015     private void test_rt_40319(boolean toRight, boolean toBottom, boolean useMouse) {
6016         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
6017         root.setExpanded(true);
6018         root.getChildren().addAll(
6019                 new TreeItem&lt;&gt;(&quot;0&quot;),
6020                 new TreeItem&lt;&gt;(&quot;1&quot;),
6021                 new TreeItem&lt;&gt;(&quot;2&quot;),
6022                 new TreeItem&lt;&gt;(&quot;3&quot;),
6023                 new TreeItem&lt;&gt;(&quot;4&quot;),
6024                 new TreeItem&lt;&gt;(&quot;5&quot;)
6025         );
6026 
6027         TreeTableView&lt;String&gt; t = new TreeTableView&lt;&gt;(root);
6028         t.setShowRoot(false);
6029 
6030         sm = t.getSelectionModel();
6031         sm.setSelectionMode(SelectionMode.MULTIPLE);
6032 
6033         TreeTableColumn&lt;String,String&gt; c1 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6034         c1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
6035         TreeTableColumn&lt;String,String&gt; c2 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6036         c2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
6037         t.getColumns().addAll(c1, c2);
6038 
6039         final int startIndex = toRight ? 0 : 2;
6040         final int endIndex = toRight ? 2 : 0;
6041         final TreeTableColumn&lt;String,String&gt; startColumn = toBottom ? c1 : c2;
6042         final TreeTableColumn&lt;String,String&gt; endColumn = toBottom ? c2 : c1;
6043 
6044         sm.select(startIndex, startColumn);
6045 
6046         if (useMouse) {
6047             Cell endCell = VirtualFlowTestUtils.getCell(t, endIndex, toRight ? 1 : 0);
6048             MouseEventFirer mouse = new MouseEventFirer(endCell);
6049             mouse.fireMousePressAndRelease(KeyModifier.SHIFT);
6050         } else {
6051             t.getSelectionModel().selectRange(startIndex, startColumn, endIndex, endColumn);
6052         }
6053 
6054         assertEquals(3, sm.getSelectedItems().size());
6055         assertEquals(3, sm.getSelectedIndices().size());
6056         assertEquals(3, sm.getSelectedCells().size());
6057     }
6058 
6059     @Test public void test_jdk_8147483() {
6060         TreeItem&lt;Number&gt; root = new TreeItem&lt;&gt;(0);
6061         root.setExpanded(true);
6062 
6063         final TreeTableView&lt;Number&gt; view = new TreeTableView&lt;&gt;(root);
6064         view.setShowRoot(false);
6065 
6066         AtomicInteger cellUpdateCount = new AtomicInteger();
6067         AtomicInteger rowCreateCount = new AtomicInteger();
6068 
6069         TreeTableColumn&lt;Number, Number&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
6070         column.setCellValueFactory(cdf -&gt; new ReadOnlyIntegerWrapper(0));
6071         column.setCellFactory( ttc -&gt; new TreeTableCell&lt;Number,Number&gt;() {
6072             @Override protected void updateItem(Number item, boolean empty) {
6073                 cellUpdateCount.incrementAndGet();
6074                 super.updateItem(item, empty);
6075             }
6076         });
6077         view.getColumns().add(column);
6078 
6079         view.setRowFactory(t -&gt; {
6080             rowCreateCount.incrementAndGet();
6081             return new TreeTableRow&lt;&gt;();
6082         });
6083 
6084         assertEquals(0, cellUpdateCount.get());
6085         assertEquals(0, rowCreateCount.get());
6086 
6087         StageLoader sl = new StageLoader(view);
6088 
6089         // Before the fix, we got cellUpdateCount = 18 and rowCreateCount = 17 for the first add below.
6090         // After the second add, these numbers went to 53 and 17 respectively.
6091         // Because these numbers might differ on other systems, we simply record the values after
6092         // the first add, and then we expect the cellUpdateCount to increase by one, and rowCreateCount to
6093         // not increase at all.
6094         root.getChildren().add(new TreeItem(1));
6095         Toolkit.getToolkit().firePulse();
6096         final int firstCellUpdateCount = cellUpdateCount.get();
6097         final int firstRowCreateCount = rowCreateCount.get();
6098 
6099         root.getChildren().add(new TreeItem(2));
6100         Toolkit.getToolkit().firePulse();
6101         assertEquals(firstCellUpdateCount+1, cellUpdateCount.get());
6102         assertEquals(firstRowCreateCount, rowCreateCount.get());
6103 
6104         root.getChildren().add(new TreeItem(3));
6105         Toolkit.getToolkit().firePulse();
6106         assertEquals(firstCellUpdateCount+2, cellUpdateCount.get());
6107         assertEquals(firstRowCreateCount, rowCreateCount.get());
6108 
6109         sl.dispose();
6110     }
6111 
6112     @Test public void test_jdk_8144681_removeColumn() {
6113         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6114 
6115         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6116         root.getChildren().addAll(
6117                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6118                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6119                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6120                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6121         table.setRoot(root);
6122 
6123         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6124         for (String prop : columns) {
6125             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6126             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6127             table.getColumns().add(col);
6128         }
6129         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6130         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6131         table.getSelectionModel().setCellSelectionEnabled(true);
6132 
6133         table.getSelectionModel().selectAll();
6134 
6135         ControlTestUtils.runWithExceptionHandler(() -&gt; table.getColumns().remove(2));
6136     }
6137 
6138     @Test public void test_jdk_8144681_moveColumn() {
6139         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6140 
6141         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6142         root.getChildren().addAll(
6143                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6144                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6145                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6146                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6147         table.setRoot(root);
6148 
6149         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6150         for (String prop : columns) {
6151             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6152             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6153             table.getColumns().add(col);
6154         }
6155         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6156         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6157         table.getSelectionModel().setCellSelectionEnabled(true);
6158 
6159         table.getSelectionModel().selectAll();
6160 
6161         ControlTestUtils.runWithExceptionHandler(() -&gt; {
6162             table.getColumns().setAll(table.getColumns().get(0), table.getColumns().get(2), table.getColumns().get(1));
6163         });
6164     }
6165 
6166     private static class Book {
6167         private SimpleStringProperty title = new SimpleStringProperty();
6168         private SimpleStringProperty author = new SimpleStringProperty();
6169         private SimpleStringProperty remark = new SimpleStringProperty();
6170 
6171         public Book(String title, String author, String remark) {
6172             super();
6173             setTitle(title);
6174             setAuthor(author);
6175             setRemark(remark);
6176         }
6177 
6178         public SimpleStringProperty titleProperty() {
6179             return this.title;
6180         }
6181 
6182         public java.lang.String getTitle() {
6183             return this.titleProperty().get();
6184         }
6185 
6186         public void setTitle(final java.lang.String title) {
6187             this.titleProperty().set(title);
6188         }
6189 
6190         public SimpleStringProperty authorProperty() {
6191             return this.author;
6192         }
6193 
6194         public java.lang.String getAuthor() {
6195             return this.authorProperty().get();
6196         }
6197 
6198         public void setAuthor(final java.lang.String author) {
6199             this.authorProperty().set(author);
6200         }
6201 
6202         public SimpleStringProperty remarkProperty() {
6203             return this.remark;
6204         }
6205 
6206         public java.lang.String getRemark() {
6207             return this.remarkProperty().get();
6208         }
6209 
6210         public void setRemark(final java.lang.String remark) {
6211             this.remarkProperty().set(remark);
6212         }
6213 
6214         @Override
6215         public String toString() {
6216             return String.format(&quot;%s(%s) - %s&quot;, getTitle(), getAuthor(), getRemark());
6217         }
6218     }
6219 
6220     @Test public void test_jdk_8157205() {
6221         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6222         childNode1.setExpanded(true);
6223         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6224         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6225         childNode1.getChildren().addAll(item1, item2);
6226 
6227         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6228         root.setExpanded(true);
6229         root.getChildren().add(childNode1);
6230 
6231         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6232         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6233         sm.setSelectionMode(SelectionMode.MULTIPLE);
6234 
6235         AtomicInteger step = new AtomicInteger();
6236 
6237         AtomicInteger indicesEventCount = new AtomicInteger();
6238         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
6239             switch (step.get()) {
6240                 case 0: {
6241                     // expect to see [1,2,3] added at index 0
6242                     c.next();
6243                     assertEquals(3, c.getAddedSize());
6244                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6245                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(1,2,3)));
6246                     assertEquals(0, c.getFrom());
6247                     break;
6248                 }
6249                 case 1: {
6250                     // expect to see [2,3] removed
6251                     List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
6252                     while (c.next()) {
6253                         if (c.wasRemoved()) {
6254                             removed.addAll(c.getRemoved());
6255                         } else {
6256                             fail(&quot;Unexpected state&quot;);
6257                         }
6258                     }
6259                     if (!removed.isEmpty()) {
6260                         assertTrue(removed.containsAll(FXCollections.observableArrayList(2,3)));
6261                     }
6262                     break;
6263                 }
6264             }
6265 
6266             indicesEventCount.incrementAndGet();
6267         });
6268 
6269         AtomicInteger itemsEventCount = new AtomicInteger();
6270         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;)c -&gt; {
6271             switch (step.get()) {
6272                 case 0: {
6273                     // expect to see [1,2,3] added at index 0
6274                     c.next();
6275                     assertEquals(3, c.getAddedSize());
6276                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6277                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(childNode1, item1, item2)));
6278                     assertEquals(0, c.getFrom());
6279                     break;
6280                 }
6281                 case 1: {
6282                     // expect to see [2,3] removed
6283                     List&lt;TreeItem&lt;String&gt;&gt; removed = new ArrayList&lt;&gt;();
6284                     while (c.next()) {
6285                         if (c.wasRemoved()) {
6286                             removed.addAll(c.getRemoved());
6287                         } else {
6288                             fail(&quot;Unexpected state&quot;);
6289                         }
6290                     }
6291                     if (!removed.isEmpty()) {
6292                         assertTrue(removed.containsAll(FXCollections.observableArrayList(item1, item2)));
6293                     }
6294                     break;
6295                 }
6296             }
6297 
6298             itemsEventCount.incrementAndGet();
6299         });
6300 
6301         assertEquals(0, indicesEventCount.get());
6302         assertEquals(0, itemsEventCount.get());
6303 
6304         step.set(0);
6305         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6306         assertTrue(sm.isSelected(1));
6307         assertTrue(sm.isSelected(2));
6308         assertTrue(sm.isSelected(3));
6309         assertEquals(3, sm.getSelectedIndices().size());
6310         assertEquals(3, sm.getSelectedItems().size());
6311         assertEquals(1, indicesEventCount.get());
6312         assertEquals(1, itemsEventCount.get());
6313 
6314         step.set(1);
6315         System.out.println(&quot;about to collapse now&quot;);
6316         childNode1.setExpanded(false); // collapse Child Node 1 and expect both children to be deselected
6317         assertTrue(sm.isSelected(1));
6318         assertFalse(sm.isSelected(2));
6319         assertFalse(sm.isSelected(3));
6320         assertEquals(1, sm.getSelectedIndices().size());
6321         assertEquals(1, sm.getSelectedItems().size());
6322         assertEquals(2, indicesEventCount.get());
6323         assertEquals(2, itemsEventCount.get());
6324 
6325         step.set(2);
6326         childNode1.setExpanded(true); // expand Child Node 1 and expect both children to still be deselected
6327         assertTrue(sm.isSelected(1));
6328         assertFalse(sm.isSelected(2));
6329         assertFalse(sm.isSelected(3));
6330         assertEquals(1, sm.getSelectedIndices().size());
6331         assertEquals(1, sm.getSelectedItems().size());
6332         assertEquals(2, indicesEventCount.get());
6333         assertEquals(2, itemsEventCount.get());
6334     }
6335 
6336     @Test public void test_jdk_8157285() {
6337         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6338         childNode1.setExpanded(true);
6339         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6340         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6341         childNode1.getChildren().addAll(item1, item2);
6342 
6343         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6344         root.setExpanded(true);
6345         root.getChildren().add(childNode1);
6346 
6347         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6348         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6349         sm.setSelectionMode(SelectionMode.MULTIPLE);
6350 
6351         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6352             if (childNode1.isExpanded()) return;
6353             System.out.println(sm.getSelectedIndices());
6354             System.out.println(sm.getSelectedItems());
6355             assertTrue(sm.isSelected(1));
6356             assertFalse(sm.isSelected(2));
6357             assertFalse(sm.isSelected(3));
6358             assertEquals(1, sm.getSelectedIndices().size());
6359             assertEquals(1, sm.getSelectedItems().size());
6360         });
6361 
6362         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6363         assertTrue(sm.isSelected(1));
6364         assertTrue(sm.isSelected(2));
6365         assertTrue(sm.isSelected(3));
6366         assertEquals(3, sm.getSelectedIndices().size());
6367         assertEquals(3, sm.getSelectedItems().size());
6368 
6369         // collapse Child Node 1 and expect both children to be deselected,
6370         // and that in the expandedItemCount listener that we get the right values
6371         // in the selectedIndices and selectedItems list
6372         childNode1.setExpanded(false);
6373     }
6374 
6375     @Test public void test_jdk_8152396() {
6376         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6377         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6378         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6379         childNode1.getChildren().addAll(item1, item2);
6380 
6381         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6382         root.setExpanded(true);
6383         root.getChildren().add(childNode1);
6384 
6385         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6386         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6387         sm.setSelectionMode(SelectionMode.MULTIPLE);
6388 
6389         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6390             if (newCount.intValue() &gt; oldCount.intValue()) {
6391                 for (int index: sm.getSelectedIndices()) {
6392                     TreeItem&lt;String&gt; item = view.getTreeItem(index);
6393 
6394                     if (item != null &amp;&amp; item.isExpanded() &amp;&amp; !item.getChildren().isEmpty()) {
6395                         int startIndex = index + 1;
6396                         int maxCount = startIndex + item.getChildren().size();
6397 
6398                         sm.selectRange(startIndex, maxCount);
6399                     }
6400                 }
6401             }
6402         });
6403 
6404         FilteredList filteredList = sm.getSelectedItems().filtered(Objects::nonNull);
6405 
6406         StageLoader sl = new StageLoader(view);
6407 
6408         sm.select(1);
6409         childNode1.setExpanded(true);
6410         Toolkit.getToolkit().firePulse();
6411 
6412         // collapse Child Node 1 and expect both children to be deselected,
6413         // and that the filtered list does not throw an exception
6414         assertEquals(3, filteredList.size());
6415         ControlTestUtils.runWithExceptionHandler(() -&gt; childNode1.setExpanded(false));
6416 
6417         Toolkit.getToolkit().firePulse();
6418         assertEquals(1, filteredList.size());
6419 
6420         sl.dispose();
6421     }
6422 
6423     @Test public void test_jdk_8160771() {
6424         TreeTableView table = new TreeTableView();
6425         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
6426         table.getColumns().add(first);
6427         table.getVisibleLeafColumns().addListener((ListChangeListener) c -&gt; {
6428             c.next();
6429             assertTrue(c.wasAdded());
6430             assertSame(table, ((TreeTableColumn) c.getAddedSubList().get(0)).getTreeTableView());
6431         });
6432         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
6433         table.getColumns().add(0, last);
6434     }
6435 
6436     private void test_jdk_8169642(Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; before,
6437                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterDescending,
6438                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterAscending) {
6439         final TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
6440         rootItem.setExpanded(true);
6441         rootItem.getChildren().addAll(new TreeItem&lt;&gt;(&quot;first child&quot;), new TreeItem&lt;&gt;(&quot;second child&quot;), new TreeItem&lt;&gt;(&quot;third child&quot;));
6442 
6443         final TreeTableView&lt;String&gt; tree = new TreeTableView&lt;&gt;(rootItem);
6444         final TreeTableColumn&lt;String, String&gt; column = new TreeTableColumn&lt;&gt;(&quot;first column&quot;);
6445         column.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
6446         tree.getColumns().add(column);
6447 
6448         TreeTableView.TreeTableViewSelectionModel sm = tree.getSelectionModel();
6449         sm.setSelectionMode(SelectionMode.MULTIPLE);
6450 
6451         assertTrue(sm.isEmpty());
6452         before.accept(sm);
6453 
6454         tree.getSortOrder().add(column);
6455         column.setSortType(TreeTableColumn.SortType.DESCENDING);
6456         afterDescending.accept(sm);
6457 
6458         column.setSortType(TreeTableColumn.SortType.ASCENDING);
6459         afterAscending.accept(sm);
6460     }
6461 
6462     @Test public void test_jdk_8169642_1_only() {
6463         test_jdk_8169642(
6464             sm -&gt; {
6465                 // select &#39;first&#39;
6466                 sm.select(1);
6467                 assertTrue(sm.isSelected(1));
6468                 assertEquals(1, sm.getSelectedCells().size());
6469             },
6470             sm -&gt; {
6471                 assertTrue(sm.isSelected(3));
6472                 assertEquals(1, sm.getSelectedCells().size());
6473             },
6474             sm -&gt; {
6475                 assertTrue(sm.isSelected(1));
6476                 assertEquals(1, sm.getSelectedCells().size());
6477             }
6478         );
6479     }
6480 
6481     @Test public void test_jdk_8169642_2_only() {
6482         test_jdk_8169642(
6483             sm -&gt; {
6484                 // select &#39;second&#39;
6485                 sm.select(2);
6486                 assertTrue(sm.isSelected(2));
6487                 assertEquals(1, sm.getSelectedCells().size());
6488             },
6489             sm -&gt; {
6490                 assertTrue(sm.isSelected(2));
6491                 assertEquals(1, sm.getSelectedCells().size());
6492             },
6493             sm -&gt; {
6494                 assertTrue(sm.isSelected(2));
6495                 assertEquals(1, sm.getSelectedCells().size());
6496             }
6497         );
6498     }
6499 
6500     @Test public void test_jdk_8169642_1_and_3() {
6501         test_jdk_8169642(
6502             sm -&gt; {
6503                 // select &#39;first&#39; and &#39;third&#39;, they should flip positions
6504                 sm.select(1);
6505                 sm.select(3);
6506                 assertTrue(sm.isSelected(1));
6507                 assertTrue(sm.isSelected(3));
6508                 assertEquals(2, sm.getSelectedCells().size());
6509             },
6510             sm -&gt; {
6511                 assertTrue(sm.isSelected(1));
6512                 assertTrue(sm.isSelected(3));
6513                 assertEquals(2, sm.getSelectedCells().size());
6514             },
6515             sm -&gt; {
6516                 assertTrue(sm.isSelected(1));
6517                 assertTrue(sm.isSelected(3));
6518                 assertEquals(2, sm.getSelectedCells().size());
6519             }
6520         );
6521     }
6522 
6523     @Test public void test_jdk_8169642_0_and_3() {
6524         test_jdk_8169642(
6525                 sm -&gt; {
6526                     // select &#39;root&#39; and &#39;third&#39;
6527                     sm.select(0);
6528                     sm.select(3);
6529                     assertTrue(sm.isSelected(0));
6530                     assertTrue(sm.isSelected(3));
6531                     assertEquals(2, sm.getSelectedCells().size());
6532                 },
6533                 sm -&gt; {
6534                     assertTrue(sm.isSelected(0));
6535                     assertTrue(sm.isSelected(1));
6536                     assertEquals(2, sm.getSelectedCells().size());
6537                 },
6538                 sm -&gt; {
6539                     assertTrue(sm.isSelected(0));
6540                     assertTrue(sm.isSelected(3));
6541                     assertEquals(2, sm.getSelectedCells().size());
6542                 }
6543         );
6544     }
6545 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>