<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Animatable.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationEffect.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,31 ***</span>
  {
      // The Web Animations spec introduces a number of animation effect time-related definitions that refer
      // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
      // to return them all as a single BasicEffectTiming.
  
<span class="line-removed">-     auto activeDuration = [this]() -&gt; Seconds {</span>
<span class="line-removed">-         // 3.8.2. Calculating the active duration</span>
<span class="line-removed">-         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // The active duration is calculated as follows:</span>
<span class="line-removed">-         // active duration = iteration duration × iteration count</span>
<span class="line-removed">-         // If either the iteration duration or iteration count are zero, the active duration is zero.</span>
<span class="line-removed">-         if (!m_iterationDuration || !m_iterations)</span>
<span class="line-removed">-             return 0_s;</span>
<span class="line-removed">-         return m_iterationDuration * m_iterations;</span>
<span class="line-removed">-     }();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto endTime = [this, activeDuration]() -&gt; Seconds {</span>
<span class="line-removed">-         // 3.5.3 The active interval</span>
<span class="line-removed">-         // https://drafts.csswg.org/web-animations-1/#end-time</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).</span>
<span class="line-removed">-         auto endTime = m_delay + activeDuration + m_endDelay;</span>
<span class="line-removed">-         return endTime &gt; 0_s ? endTime : 0_s;</span>
<span class="line-removed">-     }();</span>
<span class="line-removed">- </span>
      auto localTime = [this]() -&gt; Optional&lt;Seconds&gt; {
          // 4.5.4. Local time
          // https://drafts.csswg.org/web-animations-1/#local-time-section
  
          // The local time of an animation effect at a given moment is based on the first matching condition from the following:
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,17 ***</span>
          if (m_animation)
              return m_animation-&gt;currentTime();
          return WTF::nullopt;
      }();
  
<span class="line-modified">!     auto phase = [this, endTime, localTime, activeDuration]() -&gt; AnimationEffectPhase {</span>
          // 3.5.5. Animation effect phases and states
          // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
  
          bool animationIsBackwards = m_animation &amp;&amp; m_animation-&gt;playbackRate() &lt; 0;
<span class="line-modified">!         auto beforeActiveBoundaryTime = std::max(std::min(m_delay, endTime), 0_s);</span>
<span class="line-modified">!         auto activeAfterBoundaryTime = std::max(std::min(m_delay + activeDuration, endTime), 0_s);</span>
  
          // (This should be the last statement, but it&#39;s more efficient to cache the local time and return right away if it&#39;s not resolved.)
          // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
          // as being in the idle phase.
          if (!localTime)
<span class="line-new-header">--- 74,17 ---</span>
          if (m_animation)
              return m_animation-&gt;currentTime();
          return WTF::nullopt;
      }();
  
<span class="line-modified">!     auto phase = [this, localTime]() -&gt; AnimationEffectPhase {</span>
          // 3.5.5. Animation effect phases and states
          // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
  
          bool animationIsBackwards = m_animation &amp;&amp; m_animation-&gt;playbackRate() &lt; 0;
<span class="line-modified">!         auto beforeActiveBoundaryTime = std::max(std::min(m_delay, m_endTime), 0_s);</span>
<span class="line-modified">!         auto activeAfterBoundaryTime = std::max(std::min(m_delay + m_activeDuration, m_endTime), 0_s);</span>
  
          // (This should be the last statement, but it&#39;s more efficient to cache the local time and return right away if it&#39;s not resolved.)
          // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
          // as being in the idle phase.
          if (!localTime)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,11 ***</span>
          // in either the before phase nor the after phase.
          // (No need to check, we&#39;ve already established that local time was resolved).
          return AnimationEffectPhase::Active;
      }();
  
<span class="line-modified">!     auto activeTime = [this, localTime, phase, activeDuration]() -&gt; Optional&lt;Seconds&gt; {</span>
          // 3.8.3.1. Calculating the active time
          // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
  
          // The active time is based on the local time and start delay. However, it is only defined
          // when the animation effect should produce an output and hence depends on its fill mode
<span class="line-new-header">--- 108,11 ---</span>
          // in either the before phase nor the after phase.
          // (No need to check, we&#39;ve already established that local time was resolved).
          return AnimationEffectPhase::Active;
      }();
  
<span class="line-modified">!     auto activeTime = [this, localTime, phase]() -&gt; Optional&lt;Seconds&gt; {</span>
          // 3.8.3.1. Calculating the active time
          // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
  
          // The active time is based on the local time and start delay. However, it is only defined
          // when the animation effect should produce an output and hence depends on its fill mode
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,31 ***</span>
          // condition from the following,
          if (phase == AnimationEffectPhase::After) {
              // If the fill mode is forwards or both, return the result of evaluating
              // max(min(local time - start delay, active duration), 0).
              if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
<span class="line-modified">!                 return std::max(std::min(*localTime - m_delay, activeDuration), 0_s);</span>
              // Otherwise, return an unresolved time value.
              return WTF::nullopt;
          }
  
          // Otherwise (the local time is unresolved), return an unresolved time value.
          return WTF::nullopt;
      }();
  
<span class="line-modified">!     return { localTime, activeTime, endTime, activeDuration, phase };</span>
  }
  
  ComputedEffectTiming AnimationEffect::getComputedTiming() const
  {
      // The Web Animations spec introduces a number of animation effect time-related definitions that refer
      // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
      // to return them all as a single ComputedEffectTiming.
  
      auto basicEffectTiming = getBasicTiming();
      auto activeTime = basicEffectTiming.activeTime;
<span class="line-removed">-     auto activeDuration = basicEffectTiming.activeDuration;</span>
      auto phase = basicEffectTiming.phase;
  
      auto overallProgress = [this, phase, activeTime]() -&gt; Optional&lt;double&gt; {
          // 3.8.3.2. Calculating the overall progress
          // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
<span class="line-new-header">--- 137,30 ---</span>
          // condition from the following,
          if (phase == AnimationEffectPhase::After) {
              // If the fill mode is forwards or both, return the result of evaluating
              // max(min(local time - start delay, active duration), 0).
              if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
<span class="line-modified">!                 return std::max(std::min(*localTime - m_delay, m_activeDuration), 0_s);</span>
              // Otherwise, return an unresolved time value.
              return WTF::nullopt;
          }
  
          // Otherwise (the local time is unresolved), return an unresolved time value.
          return WTF::nullopt;
      }();
  
<span class="line-modified">!     return { localTime, activeTime, m_endTime, m_activeDuration, phase };</span>
  }
  
  ComputedEffectTiming AnimationEffect::getComputedTiming() const
  {
      // The Web Animations spec introduces a number of animation effect time-related definitions that refer
      // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
      // to return them all as a single ComputedEffectTiming.
  
      auto basicEffectTiming = getBasicTiming();
      auto activeTime = basicEffectTiming.activeTime;
      auto phase = basicEffectTiming.phase;
  
      auto overallProgress = [this, phase, activeTime]() -&gt; Optional&lt;double&gt; {
          // 3.8.3.2. Calculating the overall progress
          // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
          // 3. Return the result of calculating overall progress + iteration start.
          overallProgress += m_iterationStart;
          return std::abs(overallProgress);
      }();
  
<span class="line-modified">!     auto simpleIterationProgress = [this, overallProgress, phase, activeTime, activeDuration]() -&gt; Optional&lt;double&gt; {</span>
          // 3.8.3.3. Calculating the simple iteration progress
          // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
  
          // The simple iteration progress is a fraction of the progress through the current iteration that
          // ignores transformations to the time introduced by the playback direction or timing functions
<span class="line-new-header">--- 186,11 ---</span>
          // 3. Return the result of calculating overall progress + iteration start.
          overallProgress += m_iterationStart;
          return std::abs(overallProgress);
      }();
  
<span class="line-modified">!     auto simpleIterationProgress = [this, overallProgress, phase, activeTime]() -&gt; Optional&lt;double&gt; {</span>
          // 3.8.3.3. Calculating the simple iteration progress
          // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
  
          // The simple iteration progress is a fraction of the progress through the current iteration that
          // ignores transformations to the time introduced by the playback direction or timing functions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,11 ***</span>
          // the simple iteration progress calculated above is zero, and
          // the animation effect is in the active phase or the after phase, and
          // the active time is equal to the active duration, and
          // the iteration count is not equal to zero.
          // let the simple iteration progress be 1.0.
<span class="line-modified">!         if (!simpleIterationProgress &amp;&amp; (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) &amp;&amp; std::abs(activeTime-&gt;microseconds() - activeDuration.microseconds()) &lt; timeEpsilon.microseconds() &amp;&amp; m_iterations)</span>
              return 1;
  
          return simpleIterationProgress;
      }();
  
<span class="line-new-header">--- 209,11 ---</span>
          // the simple iteration progress calculated above is zero, and
          // the animation effect is in the active phase or the after phase, and
          // the active time is equal to the active duration, and
          // the iteration count is not equal to zero.
          // let the simple iteration progress be 1.0.
<span class="line-modified">!         if (!simpleIterationProgress &amp;&amp; (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) &amp;&amp; std::abs(activeTime-&gt;microseconds() - m_activeDuration.microseconds()) &lt; timeEpsilon.microseconds() &amp;&amp; m_iterations)</span>
              return 1;
  
          return simpleIterationProgress;
      }();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,12 ***</span>
      computedTiming.iterationStart = m_iterationStart;
      computedTiming.iterations = m_iterations;
      computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
      computedTiming.direction = m_direction;
      computedTiming.easing = m_timingFunction-&gt;cssText();
<span class="line-modified">!     computedTiming.endTime = secondsToWebAnimationsAPITime(basicEffectTiming.endTime);</span>
<span class="line-modified">!     computedTiming.activeDuration = secondsToWebAnimationsAPITime(activeDuration);</span>
      if (basicEffectTiming.localTime)
          computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
      computedTiming.simpleIterationProgress = simpleIterationProgress;
      computedTiming.progress = transformedProgress;
      computedTiming.currentIteration = currentIteration;
<span class="line-new-header">--- 323,12 ---</span>
      computedTiming.iterationStart = m_iterationStart;
      computedTiming.iterations = m_iterations;
      computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
      computedTiming.direction = m_direction;
      computedTiming.easing = m_timingFunction-&gt;cssText();
<span class="line-modified">!     computedTiming.endTime = secondsToWebAnimationsAPITime(m_endTime);</span>
<span class="line-modified">!     computedTiming.activeDuration = secondsToWebAnimationsAPITime(m_activeDuration);</span>
      if (basicEffectTiming.localTime)
          computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
      computedTiming.simpleIterationProgress = simpleIterationProgress;
      computedTiming.progress = transformedProgress;
      computedTiming.currentIteration = currentIteration;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,10 ***</span>
<span class="line-new-header">--- 343,14 ---</span>
  
      // To update the timing properties of an animation effect, effect, from an EffectTiming or OptionalEffectTiming object, input, perform the following steps:
      if (!timing)
          return { };
  
<span class="line-added">+     Optional&lt;ComputedEffectTiming&gt; previousTiming;</span>
<span class="line-added">+     if (m_animation)</span>
<span class="line-added">+         previousTiming = getComputedTiming();</span>
<span class="line-added">+ </span>
      // 1. If the iterationStart member of input is present and less than zero, throw a TypeError and abort this procedure.
      if (timing-&gt;iterationStart) {
          if (timing-&gt;iterationStart.value() &lt; 0)
              return Exception { TypeError };
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,16 ***</span>
          m_iterationDuration = WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value()) ? Seconds::fromMilliseconds(WTF::get&lt;double&gt;(timing-&gt;duration.value())) : 0_s;
  
      if (timing-&gt;direction)
          m_direction = timing-&gt;direction.value();
  
      if (m_animation)
<span class="line-modified">!         m_animation-&gt;effectTimingDidChange();</span>
  
      return { };
  }
  
  ExceptionOr&lt;void&gt; AnimationEffect::setIterationStart(double iterationStart)
  {
      // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
      // If an attempt is made to set this attribute to a value less than zero, a TypeError must
      // be thrown and the value of the iterationStart attribute left unchanged.
<span class="line-new-header">--- 412,40 ---</span>
          m_iterationDuration = WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value()) ? Seconds::fromMilliseconds(WTF::get&lt;double&gt;(timing-&gt;duration.value())) : 0_s;
  
      if (timing-&gt;direction)
          m_direction = timing-&gt;direction.value();
  
<span class="line-added">+     updateStaticTimingProperties();</span>
<span class="line-added">+ </span>
      if (m_animation)
<span class="line-modified">!         m_animation-&gt;effectTimingDidChange(previousTiming);</span>
  
      return { };
  }
  
<span class="line-added">+ void AnimationEffect::updateStaticTimingProperties()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // 3.8.2. Calculating the active duration</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The active duration is calculated as follows:</span>
<span class="line-added">+     // active duration = iteration duration × iteration count</span>
<span class="line-added">+     // If either the iteration duration or iteration count are zero, the active duration is zero.</span>
<span class="line-added">+     if (!m_iterationDuration || !m_iterations)</span>
<span class="line-added">+         m_activeDuration = 0_s;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_activeDuration = m_iterationDuration * m_iterations;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // 3.5.3 The active interval</span>
<span class="line-added">+     // https://drafts.csswg.org/web-animations-1/#end-time</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).</span>
<span class="line-added">+     m_endTime = m_delay + m_activeDuration + m_endDelay;</span>
<span class="line-added">+     if (m_endTime &lt; 0_s)</span>
<span class="line-added">+         m_endTime = 0_s;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ExceptionOr&lt;void&gt; AnimationEffect::setIterationStart(double iterationStart)
  {
      // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
      // If an attempt is made to set this attribute to a value less than zero, a TypeError must
      // be thrown and the value of the iterationStart attribute left unchanged.
</pre>
<center><a href="Animatable.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationEffect.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>