<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../indexeddb/shared/IDBTransactionInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaCapabilities.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MediaCapabilities.h&quot;
 28 
 29 #include &quot;ContentType.h&quot;
 30 #include &quot;Document.h&quot;

 31 #include &quot;JSMediaCapabilitiesDecodingInfo.h&quot;
 32 #include &quot;JSMediaCapabilitiesEncodingInfo.h&quot;

 33 #include &quot;MediaCapabilitiesDecodingInfo.h&quot;
 34 #include &quot;MediaCapabilitiesEncodingInfo.h&quot;

 35 #include &quot;MediaDecodingConfiguration.h&quot;
 36 #include &quot;MediaEncodingConfiguration.h&quot;
 37 #include &quot;MediaEngineConfigurationFactory.h&quot;
 38 #include &quot;Settings.h&quot;
 39 #include &lt;wtf/HashSet.h&gt;

 40 
 41 namespace WebCore {
 42 
 43 static const HashSet&lt;String&gt;&amp; bucketMIMETypes()
 44 {
 45     // A &quot;bucket&quot; MIME types is one whose container type does not uniquely specify a codec.
 46     // See: https://tools.ietf.org/html/rfc6381
 47     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; bucketMIMETypes = HashSet&lt;String&gt;({
 48         &quot;audio/3gpp&quot;,
 49         &quot;video/3gpp&quot;,
 50         &quot;audio/3gpp2&quot;,
 51         &quot;video/3gpp2&quot;,
 52         &quot;audio/mp4&quot;,
 53         &quot;video/mp4&quot;,
 54         &quot;application/mp4&quot;,
 55         &quot;video/quicktime&quot;,
 56         &quot;application/mp21&quot;,
 57         &quot;audio/vnd.apple.mpegurl&quot;,
 58         &quot;video/vnd.apple.mpegurl&quot;,
 59         &quot;audio/ogg&quot;,
</pre>
<hr />
<pre>
149     // 2.1.1. MediaConfiguration
150     // https://wicg.github.io/media-capabilities/#mediaconfiguration
151     // For a MediaConfiguration to be a valid MediaConfiguration, audio or video MUST be present.
152     if (!configuration.video &amp;&amp; !configuration.audio)
153         return false;
154 
155     if (configuration.video &amp;&amp; !isValidVideoConfiguration(configuration.video.value()))
156         return false;
157 
158     if (configuration.audio &amp;&amp; !isValidAudioConfiguration(configuration.audio.value()))
159         return false;
160 
161     return true;
162 }
163 
164 void MediaCapabilities::decodingInfo(Document&amp; document, MediaDecodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
165 {
166     // 2.4 Media Capabilities Interface
167     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
168 



169     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
170     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
171     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
172     if (!isValidMediaConfiguration(configuration)) {



173         promise-&gt;reject(TypeError);
174         return;
175     }
176 
177     if (!document.settings().mediaCapabilitiesExtensionsEnabled() &amp;&amp; configuration.video)
178         configuration.video.value().alphaChannel.reset();
179 
180     // 4. Let p be a new promise.
181     // 5. In parallel, run the create a MediaCapabilitiesInfo algorithm with configuration and resolve p with its result.
182     // 6. Return p.
<span class="line-modified">183     m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise)] () mutable {</span>
184 
185         // 2.2.3 If configuration is of type MediaDecodingConfiguration, run the following substeps:
<span class="line-modified">186         MediaEngineConfigurationFactory::DecodingConfigurationCallback callback = [promise = WTFMove(promise)] (auto info) mutable {</span>
187             // 2.2.3.1. If the user agent is able to decode the media represented by
188             // configuration, set supported to true. Otherwise set it to false.
189             // 2.2.3.2. If the user agent is able to decode the media represented by
190             // configuration at a pace that allows a smooth playback, set smooth to
191             // true. Otherwise set it to false.
192             // 2.2.3.3. If the user agent is able to decode the media represented by
193             // configuration in a power efficient manner, set powerEfficient to
194             // true. Otherwise set it to false. The user agent SHOULD NOT take into
195             // consideration the current power source in order to determine the
196             // decoding power efficiency unless the device’s power source has side
197             // effects such as enabling different decoding modules.



198             promise-&gt;resolve&lt;IDLDictionary&lt;MediaCapabilitiesDecodingInfo&gt;&gt;(WTFMove(info));
199         };
200 
201         MediaEngineConfigurationFactory::createDecodingConfiguration(WTFMove(configuration), WTFMove(callback));
202     });
203 }
204 
205 void MediaCapabilities::encodingInfo(MediaEncodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
206 {
207     // 2.4 Media Capabilities Interface
208     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
209 
210     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
211     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
212     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
213     if (!isValidMediaConfiguration(configuration)) {
214         promise-&gt;reject(TypeError);
215         return;
216     }
217 
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MediaCapabilities.h&quot;
 28 
 29 #include &quot;ContentType.h&quot;
 30 #include &quot;Document.h&quot;
<span class="line-added"> 31 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 32 #include &quot;JSMediaCapabilitiesDecodingInfo.h&quot;
 33 #include &quot;JSMediaCapabilitiesEncodingInfo.h&quot;
<span class="line-added"> 34 #include &quot;Logging.h&quot;</span>
 35 #include &quot;MediaCapabilitiesDecodingInfo.h&quot;
 36 #include &quot;MediaCapabilitiesEncodingInfo.h&quot;
<span class="line-added"> 37 #include &quot;MediaCapabilitiesLogging.h&quot;</span>
 38 #include &quot;MediaDecodingConfiguration.h&quot;
 39 #include &quot;MediaEncodingConfiguration.h&quot;
 40 #include &quot;MediaEngineConfigurationFactory.h&quot;
 41 #include &quot;Settings.h&quot;
 42 #include &lt;wtf/HashSet.h&gt;
<span class="line-added"> 43 #include &lt;wtf/Logger.h&gt;</span>
 44 
 45 namespace WebCore {
 46 
 47 static const HashSet&lt;String&gt;&amp; bucketMIMETypes()
 48 {
 49     // A &quot;bucket&quot; MIME types is one whose container type does not uniquely specify a codec.
 50     // See: https://tools.ietf.org/html/rfc6381
 51     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; bucketMIMETypes = HashSet&lt;String&gt;({
 52         &quot;audio/3gpp&quot;,
 53         &quot;video/3gpp&quot;,
 54         &quot;audio/3gpp2&quot;,
 55         &quot;video/3gpp2&quot;,
 56         &quot;audio/mp4&quot;,
 57         &quot;video/mp4&quot;,
 58         &quot;application/mp4&quot;,
 59         &quot;video/quicktime&quot;,
 60         &quot;application/mp21&quot;,
 61         &quot;audio/vnd.apple.mpegurl&quot;,
 62         &quot;video/vnd.apple.mpegurl&quot;,
 63         &quot;audio/ogg&quot;,
</pre>
<hr />
<pre>
153     // 2.1.1. MediaConfiguration
154     // https://wicg.github.io/media-capabilities/#mediaconfiguration
155     // For a MediaConfiguration to be a valid MediaConfiguration, audio or video MUST be present.
156     if (!configuration.video &amp;&amp; !configuration.audio)
157         return false;
158 
159     if (configuration.video &amp;&amp; !isValidVideoConfiguration(configuration.video.value()))
160         return false;
161 
162     if (configuration.audio &amp;&amp; !isValidAudioConfiguration(configuration.audio.value()))
163         return false;
164 
165     return true;
166 }
167 
168 void MediaCapabilities::decodingInfo(Document&amp; document, MediaDecodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
169 {
170     // 2.4 Media Capabilities Interface
171     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
172 
<span class="line-added">173     auto identifier = WTF::Logger::LogSiteIdentifier(&quot;MediaCapabilities&quot;, __func__, this);</span>
<span class="line-added">174     Ref&lt;Logger&gt; logger = document.logger();</span>
<span class="line-added">175 </span>
176     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
177     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
178     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
179     if (!isValidMediaConfiguration(configuration)) {
<span class="line-added">180 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">181         logger-&gt;info(LogMedia, identifier, &quot; - Rejected. configuration: &quot;, configuration);</span>
<span class="line-added">182 #endif</span>
183         promise-&gt;reject(TypeError);
184         return;
185     }
186 
187     if (!document.settings().mediaCapabilitiesExtensionsEnabled() &amp;&amp; configuration.video)
188         configuration.video.value().alphaChannel.reset();
189 
190     // 4. Let p be a new promise.
191     // 5. In parallel, run the create a MediaCapabilitiesInfo algorithm with configuration and resolve p with its result.
192     // 6. Return p.
<span class="line-modified">193     m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] () mutable {</span>
194 
195         // 2.2.3 If configuration is of type MediaDecodingConfiguration, run the following substeps:
<span class="line-modified">196         MediaEngineConfigurationFactory::DecodingConfigurationCallback callback = [promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] (auto info) mutable {</span>
197             // 2.2.3.1. If the user agent is able to decode the media represented by
198             // configuration, set supported to true. Otherwise set it to false.
199             // 2.2.3.2. If the user agent is able to decode the media represented by
200             // configuration at a pace that allows a smooth playback, set smooth to
201             // true. Otherwise set it to false.
202             // 2.2.3.3. If the user agent is able to decode the media represented by
203             // configuration in a power efficient manner, set powerEfficient to
204             // true. Otherwise set it to false. The user agent SHOULD NOT take into
205             // consideration the current power source in order to determine the
206             // decoding power efficiency unless the device’s power source has side
207             // effects such as enabling different decoding modules.
<span class="line-added">208 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">209             logger-&gt;info(LogMedia, identifier, &quot;::callback() - Resolved. info: &quot;, info);</span>
<span class="line-added">210 #endif</span>
211             promise-&gt;resolve&lt;IDLDictionary&lt;MediaCapabilitiesDecodingInfo&gt;&gt;(WTFMove(info));
212         };
213 
214         MediaEngineConfigurationFactory::createDecodingConfiguration(WTFMove(configuration), WTFMove(callback));
215     });
216 }
217 
218 void MediaCapabilities::encodingInfo(MediaEncodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
219 {
220     // 2.4 Media Capabilities Interface
221     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
222 
223     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
224     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
225     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
226     if (!isValidMediaConfiguration(configuration)) {
227         promise-&gt;reject(TypeError);
228         return;
229     }
230 
</pre>
</td>
</tr>
</table>
<center><a href="../indexeddb/shared/IDBTransactionInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaCapabilities.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>