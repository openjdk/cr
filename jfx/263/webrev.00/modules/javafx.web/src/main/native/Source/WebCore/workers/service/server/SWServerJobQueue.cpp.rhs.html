<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerJobQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerJobQueue.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExceptionData.h&quot;
 32 #include &quot;SWServer.h&quot;
 33 #include &quot;SWServerRegistration.h&quot;
 34 #include &quot;SWServerWorker.h&quot;
<a name="1" id="anc1"></a>
 35 #include &quot;SecurityOrigin.h&quot;
 36 #include &quot;ServiceWorkerFetchResult.h&quot;
 37 #include &quot;ServiceWorkerRegistrationData.h&quot;
 38 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 39 #include &quot;WorkerType.h&quot;
 40 
 41 namespace WebCore {
 42 
 43 SWServerJobQueue::SWServerJobQueue(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key)
 44     : m_jobTimer(*this, &amp;SWServerJobQueue::runNextJobSynchronously)
 45     , m_server(server)
 46     , m_registrationKey(key)
 47 {
 48 }
 49 
 50 SWServerJobQueue::~SWServerJobQueue()
 51 {
 52 }
 53 
 54 bool SWServerJobQueue::isCurrentlyProcessingJob(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier) const
 55 {
 56     return !m_jobQueue.isEmpty() &amp;&amp; firstJob().identifier() == jobDataIdentifier;
 57 }
 58 
<a name="2" id="anc2"></a><span class="line-modified"> 59 void SWServerJobQueue::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)</span>
 60 {
 61     if (!isCurrentlyProcessingJob(result.jobDataIdentifier))
 62         return;
 63 
 64     auto&amp; job = firstJob();
 65 
 66     auto* registration = m_server.getRegistration(m_registrationKey);
 67     if (!registration)
 68         return;
 69 
 70     auto* newestWorker = registration-&gt;getNewestWorker();
 71 
 72     if (!result.scriptError.isNull()) {
 73         // Invoke Reject Job Promise with job and TypeError.
 74         m_server.rejectJob(job, ExceptionData { TypeError, makeString(&quot;Script URL &quot;, job.scriptURL.string(), &quot; fetch resulted in error: &quot;, result.scriptError.localizedDescription()) });
 75 
 76         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
 77         if (!newestWorker)
 78             registration-&gt;clear();
 79 
 80         // Invoke Finish Job with job and abort these steps.
 81         finishCurrentJob();
 82         return;
 83     }
 84 
 85     registration-&gt;setLastUpdateTime(WallTime::now());
 86 
 87     // If newestWorker is not null, newestWorker&#39;s script url equals job&#39;s script url with the exclude fragments
 88     // flag set, and script&#39;s source text is a byte-for-byte match with newestWorker&#39;s script resource&#39;s source
 89     // text, then:
 90     if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(newestWorker-&gt;scriptURL(), job.scriptURL) &amp;&amp; result.script == newestWorker-&gt;script()) {
 91         // FIXME: for non classic scripts, check the script’s module record&#39;s [[ECMAScriptCode]].
 92 
 93         // Invoke Resolve Job Promise with job and registration.
 94         m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
 95 
 96         // Invoke Finish Job with job and abort these steps.
 97         finishCurrentJob();
 98         return;
 99     }
100 
101     // FIXME: Update all the imported scripts as per spec. For now, we just do as if there is none.
102 
103     // FIXME: Support the proper worker type (classic vs module)
<a name="3" id="anc3"></a><span class="line-modified">104     m_server.updateWorker(job.identifier(), *registration, job.scriptURL, result.script, result.contentSecurityPolicy, result.referrerPolicy, WorkerType::Classic, { });</span>
105 }
106 
107 // https://w3c.github.io/ServiceWorker/#update-algorithm
108 void SWServerJobQueue::scriptContextFailedToStart(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier, const String&amp; message)
109 {
110     if (!isCurrentlyProcessingJob(jobDataIdentifier))
111         return;
112 
113     // If an uncaught runtime script error occurs during the above step, then:
114     auto* registration = m_server.getRegistration(m_registrationKey);
115     ASSERT(registration);
116 
117     ASSERT(registration-&gt;preInstallationWorker());
118     registration-&gt;preInstallationWorker()-&gt;terminate();
119     registration-&gt;setPreInstallationWorker(nullptr);
120 
121     // Invoke Reject Job Promise with job and TypeError.
122     m_server.rejectJob(firstJob(), { TypeError, message });
123 
124     // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
125     if (!registration-&gt;getNewestWorker())
126         registration-&gt;clear();
127 
128     // Invoke Finish Job with job and abort these steps.
129     finishCurrentJob();
130 }
131 
132 void SWServerJobQueue::scriptContextStarted(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier identifier)
133 {
134     if (!isCurrentlyProcessingJob(jobDataIdentifier))
135         return;
136 
137     auto* registration = m_server.getRegistration(m_registrationKey);
138     ASSERT(registration);
139 
140     install(*registration, identifier);
141 }
142 
143 // https://w3c.github.io/ServiceWorker/#install
144 void SWServerJobQueue::install(SWServerRegistration&amp; registration, ServiceWorkerIdentifier installingWorker)
145 {
146     // The Install algorithm should never be invoked with a null worker.
147     auto* worker = m_server.workerByID(installingWorker);
148     RELEASE_ASSERT(worker);
149 
150     ASSERT(registration.preInstallationWorker() == worker);
151     registration.setPreInstallationWorker(nullptr);
152 
153     registration.updateRegistrationState(ServiceWorkerRegistrationState::Installing, worker);
154     registration.updateWorkerState(*worker, ServiceWorkerState::Installing);
155 
156     // Invoke Resolve Job Promise with job and registration.
157     m_server.resolveRegistrationJob(firstJob(), registration.data(), ShouldNotifyWhenResolved::Yes);
158 }
159 
160 // https://w3c.github.io/ServiceWorker/#install (after resolving promise).
161 void SWServerJobQueue::didResolveRegistrationPromise()
162 {
163     auto* registration = m_server.getRegistration(m_registrationKey);
164     ASSERT(registration);
165     ASSERT(registration-&gt;installingWorker());
166 
167     RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::didResolveRegistrationPromise: Registration ID: %llu. Now proceeding with install&quot;, this, registration-&gt;identifier().toUInt64());
168 
169     // Queue a task to fire an event named updatefound at all the ServiceWorkerRegistration objects
170     // for all the service worker clients whose creation URL matches registration&#39;s scope url and
171     // all the service workers whose containing service worker registration is registration.
172     registration-&gt;fireUpdateFoundEvent();
173 
174     // Queue a task to fire the InstallEvent.
175     ASSERT(registration-&gt;installingWorker());
176     m_server.fireInstallEvent(*registration-&gt;installingWorker());
177 }
178 
179 // https://w3c.github.io/ServiceWorker/#install
<a name="4" id="anc4"></a><span class="line-modified">180 void SWServerJobQueue::didFinishInstall(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)</span>
181 {
182     if (!isCurrentlyProcessingJob(jobDataIdentifier))
183         return;
184 
<a name="5" id="anc5"></a><span class="line-modified">185     auto* registration = worker.registration();</span>
186     ASSERT(registration);
<a name="6" id="anc6"></a><span class="line-modified">187     ASSERT(registration-&gt;installingWorker() == &amp;worker);</span>

188 
189     if (!wasSuccessful) {
<a name="7" id="anc7"></a><span class="line-modified">190         worker.terminate();</span>



191         // Run the Update Registration State algorithm passing registration, &quot;installing&quot; and null as the arguments.
192         registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
193         // Run the Update Worker State algorithm passing registration&#39;s installing worker and redundant as the arguments.
<a name="8" id="anc8"></a><span class="line-modified">194         registration-&gt;updateWorkerState(worker, ServiceWorkerState::Redundant);</span>
195 
196         // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
197         if (!registration-&gt;getNewestWorker())
198             registration-&gt;clear();
199 
200         // Invoke Finish Job with job and abort these steps.
201         finishCurrentJob();
202         return;
203     }
204 
205     if (auto* waitingWorker = registration-&gt;waitingWorker()) {
206         waitingWorker-&gt;terminate();
207         registration-&gt;updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
208     }
209 
<a name="9" id="anc9"></a><span class="line-modified">210     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Waiting, &amp;worker);</span>



211     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
<a name="10" id="anc10"></a><span class="line-modified">212     registration-&gt;updateWorkerState(worker, ServiceWorkerState::Installed);</span>
213 
214     finishCurrentJob();
215 
216     // FIXME: Wait for all the tasks queued by Update Worker State invoked in this algorithm have executed.
217     registration-&gt;tryActivate();
218 }
219 
220 // https://w3c.github.io/ServiceWorker/#run-job
221 void SWServerJobQueue::runNextJob()
222 {
223     ASSERT(!m_jobQueue.isEmpty());
224     ASSERT(!m_jobTimer.isActive());
225     m_jobTimer.startOneShot(0_s);
226 }
227 
228 void SWServerJobQueue::runNextJobSynchronously()
229 {
230     ASSERT(!m_jobQueue.isEmpty());
231     if (m_jobQueue.isEmpty())
232         return;
233 
234     auto&amp; job = firstJob();
235     switch (job.type) {
236     case ServiceWorkerJobType::Register:
237         runRegisterJob(job);
238         return;
239     case ServiceWorkerJobType::Unregister:
240         runUnregisterJob(job);
241         return;
242     case ServiceWorkerJobType::Update:
243         runUpdateJob(job);
244         return;
245     }
246 
247     ASSERT_NOT_REACHED();
248 }
249 
250 // https://w3c.github.io/ServiceWorker/#register-algorithm
251 void SWServerJobQueue::runRegisterJob(const ServiceWorkerJobData&amp; job)
252 {
253     ASSERT(job.type == ServiceWorkerJobType::Register);
254 
<a name="11" id="anc11"></a><span class="line-modified">255     if (!shouldTreatAsPotentiallyTrustworthy(job.scriptURL) &amp;&amp; !m_server.canHandleScheme(job.scriptURL.protocol()))</span>
256         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script URL is not potentially trustworthy&quot;_s });
257 
258     // If the origin of job&#39;s script url is not job&#39;s referrer&#39;s origin, then:
259     if (!protocolHostAndPortAreEqual(job.scriptURL, job.clientCreationURL))
260         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script origin does not match the registering client&#39;s origin&quot;_s });
261 
262     // If the origin of job&#39;s scope url is not job&#39;s referrer&#39;s origin, then:
263     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
264         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Scope origin does not match the registering client&#39;s origin&quot;_s });
265 
266     // If registration is not null (in our parlance &quot;empty&quot;), then:
267     if (auto* registration = m_server.getRegistration(m_registrationKey)) {
<a name="12" id="anc12"></a>
268         auto* newestWorker = registration-&gt;getNewestWorker();
269         if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()) &amp;&amp; job.registrationOptions.updateViaCache == registration-&gt;updateViaCache()) {
270             RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found directly reusable registration %llu for job %s (DONE)&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
271             m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
272             finishCurrentJob();
273             return;
274         }
275         // This is not specified yet (https://github.com/w3c/ServiceWorker/issues/1189).
276         if (registration-&gt;updateViaCache() != job.registrationOptions.updateViaCache)
277             registration-&gt;setUpdateViaCache(job.registrationOptions.updateViaCache);
278         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found registration %llu for job %s but it needs updating&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
279     } else {
280         auto newRegistration = makeUnique&lt;SWServerRegistration&gt;(m_server, m_registrationKey, job.registrationOptions.updateViaCache, job.scopeURL, job.scriptURL);
281         m_server.addRegistration(WTFMove(newRegistration));
282 
283         RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: No existing registration for job %s, constructing a new one.&quot;, this, job.identifier().loggingString().utf8().data());
284     }
285 
286     runUpdateJob(job);
287 }
288 
289 // https://w3c.github.io/ServiceWorker/#unregister-algorithm
290 void SWServerJobQueue::runUnregisterJob(const ServiceWorkerJobData&amp; job)
291 {
292     // If the origin of job&#39;s scope url is not job&#39;s client&#39;s origin, then:
293     if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
294         return rejectCurrentJob(ExceptionData { SecurityError, &quot;Origin of scope URL does not match the client&#39;s origin&quot;_s });
295 
296     // Let registration be the result of running &quot;Get Registration&quot; algorithm passing job&#39;s scope url as the argument.
297     auto* registration = m_server.getRegistration(m_registrationKey);
298 
299     // If registration is null, then:
<a name="13" id="anc13"></a><span class="line-modified">300     if (!registration) {</span>
301         // Invoke Resolve Job Promise with job and false.
302         m_server.resolveUnregistrationJob(job, m_registrationKey, false);
303         finishCurrentJob();
304         return;
305     }
306 
<a name="14" id="anc14"></a><span class="line-modified">307     // Remove scope to registration map[job’s scope url].</span>
<span class="line-modified">308     m_server.removeFromScopeToRegistrationMap(m_registrationKey);</span>
309 
310     // Invoke Resolve Job Promise with job and true.
311     m_server.resolveUnregistrationJob(job, m_registrationKey, true);
312 
313     // Invoke Try Clear Registration with registration.
314     registration-&gt;tryClear();
315     finishCurrentJob();
316 }
317 
318 // https://w3c.github.io/ServiceWorker/#update-algorithm
319 void SWServerJobQueue::runUpdateJob(const ServiceWorkerJobData&amp; job)
320 {
321     // Let registration be the result of running the Get Registration algorithm passing job&#39;s scope url as the argument.
322     auto* registration = m_server.getRegistration(m_registrationKey);
323 
324     // If registration is null (in our parlance &quot;empty&quot;) or registration&#39;s uninstalling flag is set, then:
325     if (!registration)
326         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a null/nonexistent service worker registration&quot;_s });
<a name="15" id="anc15"></a>

327 
328     // Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
329     auto* newestWorker = registration-&gt;getNewestWorker();
330 
331     // If job&#39;s type is update, and newestWorker&#39;s script url does not equal job&#39;s script url with the exclude fragments flag set, then:
332     if (job.type == ServiceWorkerJobType::Update &amp;&amp; newestWorker &amp;&amp; !equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()))
333         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker with a requested script URL whose newest worker has a different script URL&quot;_s });
334 
<a name="16" id="anc16"></a>
335     // Set request&#39;s cache mode to &quot;no-cache&quot; if any of the following are true:
336     // - registration&#39;s update via cache mode is not &quot;all&quot;.
337     // - job&#39;s force bypass cache flag is set.
338     // - newestWorker is not null, and registration&#39;s last update check time is not null and the time difference in seconds calculated by the
339     //   current time minus registration&#39;s last update check time is greater than 86400.
<a name="17" id="anc17"></a><span class="line-modified">340     bool shouldRefreshCache = registration-&gt;updateViaCache() != ServiceWorkerUpdateViaCache::All || (newestWorker &amp;&amp; registration-&gt;isStale());</span>
<span class="line-modified">341     m_server.startScriptFetch(job, shouldRefreshCache);</span>



342 }
343 
344 void SWServerJobQueue::rejectCurrentJob(const ExceptionData&amp; exceptionData)
345 {
346     m_server.rejectJob(firstJob(), exceptionData);
347 
348     finishCurrentJob();
349 }
350 
351 // https://w3c.github.io/ServiceWorker/#finish-job
352 void SWServerJobQueue::finishCurrentJob()
353 {
354     ASSERT(!m_jobTimer.isActive());
355 
356     m_jobQueue.removeFirst();
357     if (!m_jobQueue.isEmpty())
358         runNextJob();
359 }
360 
361 void SWServerJobQueue::removeAllJobsMatching(const WTF::Function&lt;bool(ServiceWorkerJobData&amp;)&gt;&amp; matches)
362 {
363     bool isFirst = true;
364     bool didRemoveFirstJob = false;
365     m_jobQueue.removeAllMatching([&amp;](auto&amp; job) {
366         bool shouldRemove = matches(job);
367         if (isFirst) {
368             isFirst = false;
369             if (shouldRemove)
370                 didRemoveFirstJob = true;
371         }
372         return shouldRemove;
373     });
374 
375     if (m_jobTimer.isActive()) {
376         if (m_jobQueue.isEmpty())
377             m_jobTimer.stop();
378     } else if (didRemoveFirstJob &amp;&amp; !m_jobQueue.isEmpty())
379         runNextJob();
380 }
381 
382 void SWServerJobQueue::cancelJobsFromConnection(SWServerConnectionIdentifier connectionIdentifier)
383 {
384     removeAllJobsMatching([connectionIdentifier](auto&amp; job) {
385         return job.identifier().connectionIdentifier == connectionIdentifier;
386     });
387 }
388 
389 void SWServerJobQueue::cancelJobsFromServiceWorker(ServiceWorkerIdentifier serviceWorkerIdentifier)
390 {
391     removeAllJobsMatching([serviceWorkerIdentifier](auto&amp; job) {
392         return WTF::holds_alternative&lt;ServiceWorkerIdentifier&gt;(job.sourceContext) &amp;&amp; WTF::get&lt;ServiceWorkerIdentifier&gt;(job.sourceContext) == serviceWorkerIdentifier;
393     });
394 }
395 
396 } // namespace WebCore
397 
398 #endif // ENABLE(SERVICE_WORKER)
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>