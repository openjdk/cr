<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/gcVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoader.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;gc/shared/allocTracer.hpp&quot;
 29 #include &quot;gc/shared/gcId.hpp&quot;
 30 #include &quot;gc/shared/gcLocker.hpp&quot;
 31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;interpreter/oopMapCache.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/init.hpp&quot;
 39 #include &quot;utilities/dtrace.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 #include &quot;utilities/preserveException.hpp&quot;
 42 #if INCLUDE_G1GC
 43 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 44 #include &quot;gc/g1/g1Policy.hpp&quot;
 45 #endif // INCLUDE_G1GC
 46 
 47 VM_GC_Operation::~VM_GC_Operation() {
 48   CollectedHeap* ch = Universe::heap();
 49   ch-&gt;soft_ref_policy()-&gt;set_all_soft_refs_clear(false);
 50 }
 51 
 52 // The same dtrace probe can&#39;t be inserted in two different files, so we
 53 // have to call it here, so it&#39;s only in one file.  Can&#39;t create new probes
 54 // for the other file anymore.   The dtrace probes have to remain stable.
 55 void VM_GC_Operation::notify_gc_begin(bool full) {
 56   HOTSPOT_GC_BEGIN(
 57                    full);
 58 }
 59 
 60 void VM_GC_Operation::notify_gc_end() {
 61   HOTSPOT_GC_END();
 62 }
 63 
 64 // Allocations may fail in several threads at about the same time,
 65 // resulting in multiple gc requests.  We only want to do one of them.
 66 // In case a GC locker is active and the need for a GC is already signaled,
 67 // we want to skip this GC attempt altogether, without doing a futile
 68 // safepoint operation.
 69 bool VM_GC_Operation::skip_operation() const {
 70   bool skip = (_gc_count_before != Universe::heap()-&gt;total_collections());
 71   if (_full &amp;&amp; skip) {
 72     skip = (_full_gc_count_before != Universe::heap()-&gt;total_full_collections());
 73   }
 74   if (!skip &amp;&amp; GCLocker::is_active_and_needs_gc()) {
 75     skip = Universe::heap()-&gt;is_maximal_no_gc();
 76     assert(!(skip &amp;&amp; (_gc_cause == GCCause::_gc_locker)),
 77            &quot;GCLocker cannot be active when initiating GC&quot;);
 78   }
 79   return skip;
 80 }
 81 
 82 bool VM_GC_Operation::doit_prologue() {
 83   assert(((_gc_cause != GCCause::_no_gc) &amp;&amp;
 84           (_gc_cause != GCCause::_no_cause_specified)), &quot;Illegal GCCause&quot;);
 85 
 86   // To be able to handle a GC the VM initialization needs to be completed.
 87   if (!is_init_completed()) {
 88     vm_exit_during_initialization(
 89       err_msg(&quot;GC triggered before VM initialization completed. Try increasing &quot;
 90               &quot;NewSize, current value &quot; SIZE_FORMAT &quot;%s.&quot;,
 91               byte_size_in_proper_unit(NewSize),
 92               proper_unit_for_byte_size(NewSize)));
 93   }
 94 
 95   // If the GC count has changed someone beat us to the collection
 96   Heap_lock-&gt;lock();
 97 
 98   // Check invocations
 99   if (skip_operation()) {
100     // skip collection
101     Heap_lock-&gt;unlock();
102     _prologue_succeeded = false;
103   } else {
104     _prologue_succeeded = true;
105   }
106   return _prologue_succeeded;
107 }
108 
109 
110 void VM_GC_Operation::doit_epilogue() {
111   // Clean up old interpreter OopMap entries that were replaced
112   // during the GC thread root traversal.
113   OopMapCache::cleanup_old_entries();
114   if (Universe::has_reference_pending_list()) {
115     Heap_lock-&gt;notify_all();
116   }
117   Heap_lock-&gt;unlock();
118 }
119 
120 bool VM_GC_HeapInspection::skip_operation() const {
121   return false;
122 }
123 
124 bool VM_GC_HeapInspection::collect() {
125   if (GCLocker::is_active()) {
126     return false;
127   }
128   Universe::heap()-&gt;collect_as_vm_thread(GCCause::_heap_inspection);
129   return true;
130 }
131 
132 void VM_GC_HeapInspection::doit() {
133   HandleMark hm;
134   Universe::heap()-&gt;ensure_parsability(false); // must happen, even if collection does
135                                                // not happen (e.g. due to GCLocker)
136                                                // or _full_gc being false
137   if (_full_gc) {
138     if (!collect()) {
139       // The collection attempt was skipped because the gc locker is held.
140       // The following dump may then be a tad misleading to someone expecting
141       // only live objects to show up in the dump (see CR 6944195). Just issue
142       // a suitable warning in that case and do not attempt to do a collection.
143       // The latter is a subtle point, because even a failed attempt
144       // to GC will, in fact, induce one in the future, which we
145       // probably want to avoid in this case because the GC that we may
146       // be about to attempt holds value for us only
147       // if it happens now and not if it happens in the eventual
148       // future.
149       log_warning(gc)(&quot;GC locker is held; pre-dump GC was skipped&quot;);
150     }
151   }
152   HeapInspection inspect;
153   inspect.heap_inspection(_out);
154 }
155 
156 
157 void VM_GenCollectForAllocation::doit() {
158   SvcGCMarker sgcm(SvcGCMarker::MINOR);
159 
160   GenCollectedHeap* gch = GenCollectedHeap::heap();
161   GCCauseSetter gccs(gch, _gc_cause);
162   _result = gch-&gt;satisfy_failed_allocation(_word_size, _tlab);
163   assert(_result == NULL || gch-&gt;is_in_reserved(_result), &quot;result not in heap&quot;);
164 
165   if (_result == NULL &amp;&amp; GCLocker::is_active_and_needs_gc()) {
166     set_gc_locked();
167   }
168 }
169 
170 void VM_GenCollectFull::doit() {
171   SvcGCMarker sgcm(SvcGCMarker::FULL);
172 
173   GenCollectedHeap* gch = GenCollectedHeap::heap();
174   GCCauseSetter gccs(gch, _gc_cause);
175   gch-&gt;do_full_collection(gch-&gt;must_clear_all_soft_refs(), _max_generation);
176 }
177 
178 VM_CollectForMetadataAllocation::VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
179                                                                  size_t size,
180                                                                  Metaspace::MetadataType mdtype,
181                                                                  uint gc_count_before,
182                                                                  uint full_gc_count_before,
183                                                                  GCCause::Cause gc_cause)
184     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
185       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
186   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
187   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
188 }
189 
190 // Returns true iff concurrent GCs unloads metadata.
191 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
192 #if INCLUDE_G1GC
193   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
194     G1CollectedHeap* g1h = G1CollectedHeap::heap();
195     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
196 
197     GCCauseSetter x(g1h, _gc_cause);
198 
199     // At this point we are supposed to start a concurrent cycle. We
200     // will do so if one is not already in progress.
201     bool should_start = g1h-&gt;policy()-&gt;force_concurrent_start_if_outside_cycle(_gc_cause);
202 
203     if (should_start) {
204       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
205       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
206     }
207     return true;
208   }
209 #endif
210 
211   return false;
212 }
213 
214 void VM_CollectForMetadataAllocation::doit() {
215   SvcGCMarker sgcm(SvcGCMarker::FULL);
216 
217   CollectedHeap* heap = Universe::heap();
218   GCCauseSetter gccs(heap, _gc_cause);
219 
220   // Check again if the space is available.  Another thread
221   // may have similarly failed a metadata allocation and induced
222   // a GC that freed space for the allocation.
223   if (!MetadataAllocationFailALot) {
224     _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
225     if (_result != NULL) {
226       return;
227     }
228   }
229 
230   if (initiate_concurrent_GC()) {
231     // For G1 expand since the collection is going to be concurrent.
232     _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
233     if (_result != NULL) {
234       return;
235     }
236 
237     log_debug(gc)(&quot;G1 full GC for Metaspace&quot;);
238   }
239 
240   // Don&#39;t clear the soft refs yet.
241   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_threshold);
242   // After a GC try to allocate without expanding.  Could fail
243   // and expansion will be tried below.
244   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
245   if (_result != NULL) {
246     return;
247   }
248 
249   // If still failing, allow the Metaspace to expand.
250   // See delta_capacity_until_GC() for explanation of the
251   // amount of the expansion.
252   // This should work unless there really is no more space
253   // or a MaxMetaspaceSize has been specified on the command line.
254   _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
255   if (_result != NULL) {
256     return;
257   }
258 
259   // If expansion failed, do a collection clearing soft references.
260   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_clear_soft_refs);
261   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
262   if (_result != NULL) {
263     return;
264   }
265 
266   log_debug(gc)(&quot;After Metaspace GC failed to allocate size &quot; SIZE_FORMAT, _size);
267 
268   if (GCLocker::is_active_and_needs_gc()) {
269     set_gc_locked();
270   }
271 }
272 
273 VM_CollectForCodeCacheAllocation::VM_CollectForCodeCacheAllocation(uint gc_count_before,
274                                                                    uint full_gc_count_before,
275                                                                    GCCause::Cause gc_cause)
276     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true) {
277 }
278 
279 void VM_CollectForCodeCacheAllocation::doit() {
280   SvcGCMarker sgcm(SvcGCMarker::FULL);
281 
282   CollectedHeap* heap = Universe::heap();
283   GCCauseSetter gccs(heap, _gc_cause);
284 
285   log_debug(gc)(&quot;Full GC for CodeCache&quot;);
286 
287   // Don&#39;t clear the soft refs yet.
<a name="1" id="anc1"></a><span class="line-modified">288   heap-&gt;collect_as_vm_thread(GCCause::_codecache_GC_threshold);</span>
289 
290   log_debug(gc)(&quot;After GC for CodeCache&quot;);
291 
292   if (GCLocker::is_active_and_needs_gc()) {
293     set_gc_locked();
294   }
295 }
296 
297 VM_CollectForAllocation::VM_CollectForAllocation(size_t word_size, uint gc_count_before, GCCause::Cause cause)
298     : VM_GC_Operation(gc_count_before, cause), _word_size(word_size), _result(NULL) {
299   // Only report if operation was really caused by an allocation.
300   if (_word_size != 0) {
301     AllocTracer::send_allocation_requiring_gc_event(_word_size * HeapWordSize, GCId::peek());
302   }
303 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>